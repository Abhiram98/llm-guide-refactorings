[
    {
        "oracle": "method com.ibm.as400.access.NPCPAttributeIDList::readObject(java.io.ObjectInputStream):void need move com.ibm.as400.access.PrintObjectList",
        "class_name": "com.ibm.as400.access.NPCPAttributeIDList",
        "telemetry": {
            "id": "f1a4bff0-91a6-451b-a133-1ddcec8b538a",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 307,
                "lineStart": 19,
                "lineEnd": 325,
                "bodyLineStart": 19,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/small/small/jtopen-7.8/src/com/ibm/as400/access/NPCPAttributeIDList.java",
                "sourceCode": "/**\n  * NPAttributeIDList class - class for an attribute ID list code point used with\n  * the network print server's data stream.\n  * This class is derived from NPCodePoint and will be used to build a code\n  * point that has as its data a list of attribute IDs.  Each ID is a 2 byte\n  * value defined by the network print server.\n  *\n  * The layout of an Attribute List codepoint in memory is:\n  *\n  *       ------------------------------\n  *       | LLLL | CPID |     data     |\n  *       ------------------------------\n  *       LLLL - four byte code point length\n  *       CPID - code point ID (2 bytes)\n  *       data - code point data as follows:\n  *       ---------------------------------------------------\n  *       |nn | LEN | ID1 | ID2 | ID3 | ID4 | ....... | IDnn|\n  *       ---------------------------------------------------\n  *        nn   - two byte total # of attributes in code point\n  *        LEN  - two byte length of each attribute entry, right\n  *               now this will be 2 (0x02).\n  *        IDx  - two byte attribute ID\n  *\n  *      The base code point class takes care of the first 6 bytes (LLLL and CPID)\n  *      and we handle the data part of it\n  *\n*/\nclass NPCPAttributeIDList extends NPCodePoint implements Cloneable\n{\n  private static final String copyright = \"Copyright (C) 1997-2000 International Business Machines Corporation and others.\";\n\n\n    static final long serialVersionUID = 4L;\n\n\n    private final static int LEN_ATTRLIST_HEADER = 4;  // size of header on this data\n\n    private byte[]    idList_;\n    private boolean   fDataOutOfDate_;  // is base codepoint raw data out of date?\n    private boolean   fListOutOfDate_;  // is our vector out of date?\n\n\n    protected Object clone()\n    {\n       NPCPAttributeIDList cp = new NPCPAttributeIDList(this);\n       return cp;\n    }\n\n   /**\n    * copy constructor\n    */\n    NPCPAttributeIDList(NPCPAttributeIDList cp)\n    {\n       super(cp);\n       fDataOutOfDate_ = cp.fDataOutOfDate_;\n       fListOutOfDate_ = cp.fListOutOfDate_;\n       idList_ = new byte[PrintObject.MAX_ATTR_ID + 1];\n       System.arraycopy(cp.idList_, 0,\n                        idList_, 0,\n                        idList_.length);\n    }\n\n    public NPCPAttributeIDList()\n    {\n       super(NPCodePoint.ATTRIBUTE_LIST);     // construct codepoint with attribute list ID\n       fDataOutOfDate_ = false;\n       fListOutOfDate_ = false;\n       idList_ = new byte[PrintObject.MAX_ATTR_ID + 1];\n    }\n\n    NPCPAttributeIDList(byte[] data )\n    {\n        super(NPCodePoint.ATTRIBUTE_LIST, data);     // construct codepoint with attribute list ID\n        fDataOutOfDate_ = false;\n        fListOutOfDate_ = true;\n        idList_ = new byte[PrintObject.MAX_ATTR_ID + 1];\n    }\n\n\n    // override getLength from NPCodePoint class\n    // returns total length of code point (data and header)\n    int getLength()\n    {\n       if (fDataOutOfDate_)\n       {\n          updateData();\n       }\n       return super.getLength();\n    }\n\n    void setDataBuffer( byte[] dataBuffer, int datalen, int offset)\n    {\n        fListOutOfDate_ = true;\n        fDataOutOfDate_ = false;\n        super.setDataBuffer(dataBuffer, datalen, offset);\n    }\n\n    // get current data buffer\n    byte[] getDataBuffer()\n    {\n        if (fDataOutOfDate_)\n        {\n           updateData();\n        }\n        return super.getDataBuffer();\n    }\n\n    // get current data buffer and make it big enough to handle this many bytes\n    byte[] getDataBuffer(int dataLength)\n    {\n        if (fDataOutOfDate_)\n        {\n           updateData();\n        }\n        fListOutOfDate_ = true;\n        return super.getDataBuffer(dataLength);\n    }\n\n    // override reset() method to wipe out our data\n    void reset()\n    {\n        zeroIDList();\n        fListOutOfDate_ = false;\n        fDataOutOfDate_ = false;\n        super.reset();\n    }\n\n\n\n    /**\n      * addAttrID will add the specified Attribute ID to the list if it's not\n      * there already (if it is there - no harm done).\n     **/\n    void addAttrID(int ID)\n    {\n       if (!NPAttribute.idIsValid(ID))\n       {\n          throw(new ExtendedIllegalArgumentException(PrintObject.getAttributeName(ID),\n\t\t\t\t\t\t       ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID));\n       } else {\n\n          if (fListOutOfDate_)\n          {\n             updateList();\n          }\n          if (ID < 0)\n          {\n             ID = java.lang.Math.abs(ID) - 1;\n             NPAttributeIFS ifsAttr = NPAttributeIFS.ifsAttrs[ID];\n             idList_[ifsAttr.nameID_] = (byte)1;\n             idList_[ifsAttr.libraryID_] = (byte)1;\n             if (ifsAttr.typeID_ != 0)\n             {\n                 idList_[ifsAttr.typeID_] = (byte)1;\n             }\n\n          } else {\n             idList_[ID] = (byte)1;\n          }\n          fDataOutOfDate_ = true;\n       }\n    }\n\n    /**\n     * checks if an ID is contained in the codepoint\n     * @return true if this ID is in the list\n     **/\n    boolean containsID(int ID)\n    {\n        boolean fRC = false;\n        if (NPAttribute.idIsValid(ID))\n        {\n           if (fListOutOfDate_)\n           {\n               updateList();\n           }\n           if (ID < 0)\n           {\n               ID = java.lang.Math.abs(ID) - 1;\n               NPAttributeIFS ifsAttr = NPAttributeIFS.ifsAttrs[ID];\n               if ( (idList_[ifsAttr.nameID_] != 0) &&\n                    (idList_[ifsAttr.libraryID_] != 0))\n               {\n                   if (ifsAttr.typeID_ != 0)\n                   {\n                       if (idList_[ifsAttr.typeID_] != 0)\n                       {\n                          fRC = true;\n                       }\n                   } else {\n                      fRC = true;\n                   }\n               }\n           } else {\n              if (idList_[ID] != 0)\n              {\n                  fRC = true;\n              }\n           }\n        }\n        return fRC;\n    }\n\n\n    // private data members & methods\n    private void updateData()\n    {\n       int dataLength, index, elements, dataOffset;\n       byte[] data;\n\n       elements = 0;\n       dataLength =  LEN_ATTRLIST_HEADER;\n       for (index = 0; index < idList_.length; index++)\n       {\n          if (idList_[index] != 0)\n          {\n             elements++;\n          }\n       }\n       dataLength += 2 * elements;\n       data = super.getDataBuffer(dataLength);\n\n       // set the number of IDs in the codepoint\n       dataOffset = super.getOffset();\n       BinaryConverter.unsignedShortToByteArray(elements, data, dataOffset);\n       dataOffset += 2;\n\n       // set the length (2) of each ID\n       BinaryConverter.unsignedShortToByteArray(2, data, dataOffset);\n       dataOffset += 2;\n\n       // add each ID to the data\n       for (index = 0; (index < idList_.length) && (elements != 0); index++)\n       {\n          if (idList_[index] != 0)\n          {\n             BinaryConverter.unsignedShortToByteArray(index, data, dataOffset);\n             dataOffset += 2;\n             elements--;\n          }\n       }\n       fDataOutOfDate_ = false;\n    }  // updateData()\n\n    private void updateList()\n    {\n       byte[] data;\n       // zero out array and the rebuild based on data\n       zeroIDList();\n       data = super.getDataBuffer();\n       if ( (data != null) && (data.length >= LEN_ATTRLIST_HEADER) )\n       {\n          long dataLength;\n          int  elements, offset;\n          dataLength = (long)super.getDataLength();\n          offset = super.getOffset();\n          if (dataLength > LEN_ATTRLIST_HEADER)\n          {\n             elements = BinaryConverter.byteArrayToUnsignedShort(data, offset);\n             offset += 2;\n             if (elements != 0)\n             {\n                int size;\n                size = BinaryConverter.byteArrayToUnsignedShort(data, offset);\n                offset += 2;\n                if ( (size == 2) && (dataLength >= (offset+elements*2)) )\n                {\n                   int ID;\n                   while (elements != 0)\n                   {\n                      ID = BinaryConverter.byteArrayToUnsignedShort(data, offset);\n                      offset += 2;\n                      elements--;\n                      if ( (ID <0) || (ID >= idList_.length) )\n                      {\n                          // ??? throw some sorta programmer error exception here\n                      } else {\n                         idList_[ID] = (byte)1;\n                      }\n\n                   }\n                }\n             }\n          }\n       }\n       fListOutOfDate_ = false;\n    }\n\n    private void zeroIDList()\n    {\n       int length, index;\n       length = idList_.length;\n       for (index=0; index < length; index++)\n       {\n          idList_[index] = 0;\n       }\n    }\n\n\tvoid readObject(PrintObjectList printObjectList, ObjectInputStream in)\n\t  throws IOException, ClassNotFoundException\n\t{\n\t    in.defaultReadObject();  \n\t    printObjectList.initializeTransient();\n\t}\n\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 11605
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "addAttrID",
                            "method_signature": "void addAttrID(int ID)",
                            "target_class": "NPAttribute",
                            "rationale": "The method addAttrID() is responsible for validating and adding attribute IDs, which is closely related to the NPAttribute class. Moving it there would enhance cohesion and maintainability."
                        },
                        {
                            "method_name": "containsID",
                            "method_signature": "boolean containsID(int ID)",
                            "target_class": "NPAttribute",
                            "rationale": "The containsID() method checks if an ID is valid and present in the list, which is a responsibility that aligns more closely with the NPAttribute class. This would improve the separation of concerns."
                        },
                        {
                            "method_name": "updateData",
                            "method_signature": "private void updateData()",
                            "target_class": "DataBufferManager",
                            "rationale": "The updateData() method handles the logic of updating the data buffer, which could be better managed in a dedicated DataBufferManager class, promoting single responsibility and cleaner code."
                        },
                        {
                            "method_name": "updateList",
                            "method_signature": "private void updateList()",
                            "target_class": "DataBufferManager",
                            "rationale": "Similar to updateData(), the updateList() method is focused on managing the list of IDs and could be moved to a DataBufferManager class to encapsulate data management logic."
                        },
                        {
                            "method_name": "zeroIDList",
                            "method_signature": "private void zeroIDList()",
                            "target_class": "IDListManager",
                            "rationale": "The zeroIDList() method is specifically responsible for resetting the ID list, which could be better encapsulated in an IDListManager class, enhancing clarity and maintainability."
                        }
                    ],
                    "llm_response_time": 3871
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "addAttrID",
                            "method_signature": "void addAttrID(int ID)",
                            "target_class": "NPAttribute",
                            "rationale": "The method addAttrID() is responsible for validating and adding attribute IDs, which is closely related to the NPAttribute class. Moving it there would enhance cohesion and encapsulation."
                        },
                        {
                            "method_name": "containsID",
                            "method_signature": "boolean containsID(int ID)",
                            "target_class": "NPAttribute",
                            "rationale": "The containsID() method checks if an ID is valid and present in the list, which is a responsibility that aligns more closely with the NPAttribute class, improving the separation of concerns."
                        },
                        {
                            "method_name": "updateData",
                            "method_signature": "private void updateData()",
                            "target_class": "DataBufferManager",
                            "rationale": "The updateData() method handles the logic of updating the data buffer, which could be better managed in a separate DataBufferManager class to adhere to the Single Responsibility Principle."
                        },
                        {
                            "method_name": "updateList",
                            "method_signature": "private void updateList()",
                            "target_class": "DataBufferManager",
                            "rationale": "Similar to updateData(), the updateList() method is focused on managing the list of IDs and could be moved to a DataBufferManager class to improve code organization and maintainability."
                        },
                        {
                            "method_name": "zeroIDList",
                            "method_signature": "private void zeroIDList()",
                            "target_class": "IDListManager",
                            "rationale": "The zeroIDList() method is specifically responsible for resetting the ID list, which could be encapsulated in an IDListManager class to enhance clarity and separation of concerns."
                        }
                    ],
                    "llm_response_time": 3184
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "addAttrID",
                            "method_signature": "void addAttrID(int ID)",
                            "target_class": "NPAttribute",
                            "rationale": "The method addAttrID() is responsible for validating and adding attribute IDs, which is closely related to the NPAttribute class. Moving it there would enhance cohesion and encapsulation."
                        },
                        {
                            "method_name": "containsID",
                            "method_signature": "boolean containsID(int ID)",
                            "target_class": "NPAttribute",
                            "rationale": "The containsID() method checks if an ID is valid and present in the list, which is a responsibility that aligns more closely with the NPAttribute class, improving the separation of concerns."
                        },
                        {
                            "method_name": "updateData",
                            "method_signature": "private void updateData()",
                            "target_class": "DataBufferManager",
                            "rationale": "The updateData() method handles the logic of updating the data buffer, which could be better managed in a separate DataBufferManager class to adhere to the Single Responsibility Principle."
                        },
                        {
                            "method_name": "updateList",
                            "method_signature": "private void updateList()",
                            "target_class": "DataBufferManager",
                            "rationale": "Similar to updateData(), the updateList() method is focused on managing the list of IDs and could be moved to a DataBufferManager class to improve code organization and maintainability."
                        },
                        {
                            "method_name": "zeroIDList",
                            "method_signature": "private void zeroIDList()",
                            "target_class": "IDListManager",
                            "rationale": "The zeroIDList() method is specifically responsible for resetting the ID list, which could be encapsulated in a dedicated IDListManager class to enhance clarity and separation of concerns."
                        }
                    ],
                    "llm_response_time": 3834
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "addAttrID",
                            "method_signature": "void addAttrID(int ID)",
                            "target_class": "NPAttribute",
                            "rationale": "The method addAttrID() is responsible for validating and adding attribute IDs, which is closely related to the NPAttribute class. Moving it there would enhance cohesion and maintainability."
                        },
                        {
                            "method_name": "containsID",
                            "method_signature": "boolean containsID(int ID)",
                            "target_class": "NPAttribute",
                            "rationale": "The containsID() method checks if an ID is valid and present in the list, which is a responsibility that aligns more closely with the NPAttribute class. This would improve the separation of concerns."
                        },
                        {
                            "method_name": "updateData",
                            "method_signature": "private void updateData()",
                            "target_class": "DataBufferManager",
                            "rationale": "The updateData() method handles the logic of updating the data buffer, which could be better managed in a dedicated DataBufferManager class, promoting single responsibility and cleaner code."
                        },
                        {
                            "method_name": "updateList",
                            "method_signature": "private void updateList()",
                            "target_class": "DataBufferManager",
                            "rationale": "Similar to updateData(), the updateList() method is focused on managing the list of IDs and could be moved to a DataBufferManager class to encapsulate data management logic."
                        },
                        {
                            "method_name": "zeroIDList",
                            "method_signature": "private void zeroIDList()",
                            "target_class": "IDListManager",
                            "rationale": "The zeroIDList() method is specifically responsible for resetting the ID list, which could be better encapsulated in an IDListManager class, enhancing clarity and maintainability."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "addAttrID",
                    "containsID",
                    "updateData",
                    "updateList",
                    "zeroIDList"
                ],
                "llm_response_time": 629
            },
            "targetClassMap": {
                "addAttrID": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 989,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "containsID": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1056,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "updateData": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1053,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "updateList": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1506,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "zeroIDList": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1219,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.access.SystemValueList::removeWorkingListener(WorkingListener):void need move com.ibm.as400.vaccess.VSystemValueList",
        "class_name": "com.ibm.as400.access.SystemValueList",
        "telemetry": {
            "id": "ec1c4fba-73d9-40c2-88b0-d0393662093d",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 777,
                "lineStart": 31,
                "lineEnd": 807,
                "bodyLineStart": 31,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/small/small/jtopen-7.8/src/com/ibm/as400/access/SystemValueList.java",
                "sourceCode": "/**\n Provided methods for retrieving information about lists of System Values.\n @see SystemValue\n**/\npublic class SystemValueList implements Serializable\n{\n    static final long serialVersionUID = 4L;\n\n    /**\n     Constant indicating the system value's group is *ALC (Allocation).\n     **/\n    public static final int GROUP_ALC = 0;\n    /**\n     Constant indicating the system value's group is *ALL (All).\n     **/\n    public static final int GROUP_ALL = 9;\n    /**\n     Constant indicating the system value's group is *DATTIM (Date and Time).\n     **/\n    public static final int GROUP_DATTIM = 1;\n    /**\n     Constant indicating the system value's group is *EDT (Editing).\n     **/\n    public static final int GROUP_EDT = 2;\n    /**\n     Constant indicating the system value's group is *LIBL (Library List).\n     **/\n    public static final int GROUP_LIBL = 3;\n    /**\n     Constant indicating the system value's group is *MSG (Message and Logging).\n     **/\n    public static final int GROUP_MSG = 4;\n    /**\n     Constant indicating the system value's group is *NET (Net Attribute).\n     **/\n    public static final int GROUP_NET = 8;\n    /**\n     Constant indicating the system value's group is *SEC (Security).\n     **/\n    public static final int GROUP_SEC = 5;\n    /**\n     Constant indicating the system value's group is *STG (Storage).\n     **/\n    public static final int GROUP_STG = 6;\n    /**\n     Constant indicating the system value's group is *SYSCTL (System control).\n     **/\n    public static final int GROUP_SYSCTL = 7;\n\n    /**\n     Constant indicating the returned system value type is String[].\n     **/\n    public static final int TYPE_ARRAY = 4;\n    /**\n     Constant indicating the returned system value type is Date.\n     **/\n    public static final int TYPE_DATE = 5;\n    /**\n     Constant indicating the returned system value type is BigDecimal.\n     **/\n    public static final int TYPE_DECIMAL = 2;\n    /**\n     Constant indicating the returned system value type is Integer.\n     **/\n    public static final int TYPE_INTEGER = 3;\n    /**\n     Constant indicating the returned system value type is String.\n     **/\n    public static final int TYPE_STRING = 1;\n\n    // Constant indicating the system value's type on the system is BINARY.\n    static final byte SERVER_TYPE_BINARY = (byte)0xC2;\n    // Constant indicating the system value's type on the system is CHAR.\n    static final byte SERVER_TYPE_CHAR = (byte)0xC3;\n\n    // Constants for operating system VRM.\n    private static final int VRM420 = 0x00040200;\n    private static final int VRM430 = 0x00040300;\n    private static final int VRM440 = 0x00040400;\n    private static final int VRM510 = 0x00050100;\n    private static final int VRM520 = 0x00050200;\n    private static final int VRM530 = 0x00050300;\n    private static final int VRM540 = 0x00050400;\n    private static final int VRM610 = 0x00060100;\n\n    // The total number of groups.\n    private static final int GROUP_COUNT = 10;\n\n    // The MRI for the group names.\n    private static final String[] GROUP_NAMES = new String[]\n    {\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_ALC_NAME\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_DATTIM_NAME\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_EDT_NAME\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_LIBL_NAME\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_MSG_NAME\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_SEC_NAME\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_STG_NAME\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_SYSCTL_NAME\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_NET_NAME\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_ALL_NAME\"),\n    };\n\n    // The MRI for the group descriptions.\n    private static final String[] GROUP_DESCRIPTIONS = new String[]\n    {\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_ALC_DESC\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_DATTIM_DESC\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_EDT_DESC\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_LIBL_DESC\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_MSG_DESC\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_SEC_DESC\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_STG_DESC\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_SYSCTL_DESC\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_NET_DESC\"),\n        ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_ALL_DESC\"),\n    };\n\n    // The list of all SystemValueInfo objects.\n    // For V4R2, there are 125 system values and 35 network attributes.\n    // For V4R3, there are an additional 5 system values.\n    // For V4R4, there are 2 additional system values and 2 additional network attributes.\n    // For V5R1, there are 6 additional system values.\n    // For V5R2, there are 2 additional system values.\n    // For V5R3, there are 10 additional system values.\n    // For V5R4, there are 2 additional system values.\n    // For V6R1, there are 6 additional system values.\n    // There are at least 195 system values.\n    // The optimal hash size is 195/0.75 = 260.\n    private static Hashtable list = new Hashtable(260);\n\n    // Provided for convenient lookup of system value groups.\n    static Vector[] groups = { new Vector(), new Vector(), new Vector(), new Vector(), new Vector(), new Vector(), new Vector(), new Vector(), new Vector(), new Vector() };\n\n    // Initialize the hashtables.\n    static\n    {\n        if (Trace.isTraceOn()) Trace.log(Trace.DIAGNOSTIC, \"Populating system value table...\");\n\n        // Network attributes.\n        SystemValueList.list.put(\"ALRBCKFP\", new SystemValueInfo(\"ALRBCKFP\", SERVER_TYPE_CHAR, 8, 2, TYPE_ARRAY, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"ALRBCKFP_DES\")));\n        SystemValueList.list.put(\"ALRCTLD\", new SystemValueInfo(\"ALRCTLD\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"ALRCTLD_DES\")));\n        SystemValueList.list.put(\"ALRDFTFP\", new SystemValueInfo(\"ALRDFTFP\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"ALRDFTFP_DES\")));\n        SystemValueList.list.put(\"ALRFTR\", new SystemValueInfo(\"ALRFTR\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"ALRFTR_DES\")));\n        SystemValueList.list.put(\"ALRHLDCNT\", new SystemValueInfo(\"ALRHLDCNT\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"ALRHLDCNT_DES\")));\n        SystemValueList.list.put(\"ALRLOGSTS\", new SystemValueInfo(\"ALRLOGSTS\", SERVER_TYPE_CHAR, 8, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"ALRLOGSTS_DES\")));\n        SystemValueList.list.put(\"ALRPRIFP\", new SystemValueInfo(\"ALRPRIFP\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"ALRPRIFP_DES\")));\n        SystemValueList.list.put(\"ALRRQSFP\", new SystemValueInfo(\"ALRRQSFP\", SERVER_TYPE_CHAR, 8, 2, TYPE_ARRAY, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"ALRRQSFP_DES\")));\n        SystemValueList.list.put(\"ALRSTS\", new SystemValueInfo(\"ALRSTS\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"ALRSTS_DES\")));\n        SystemValueList.list.put(\"ALWANYNET\", new SystemValueInfo(\"ALWANYNET\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"ALWANYNET_DES\")));\n        SystemValueList.list.put(\"ALWHPRTWR\", new SystemValueInfo(\"ALWHPRTWR\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"ALWHPRTWR_DES\")));\n        SystemValueList.list.put(\"ALWVRTAPPN\", new SystemValueInfo(\"ALWVRTAPPN\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"ALWVRTAPPN_DES\")));\n        SystemValueList.list.put(\"DDMACC\", new SystemValueInfo(\"DDMACC\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"DDMACC_DES\")));\n        SystemValueList.list.put(\"DFTCNNLST\", new SystemValueInfo(\"DFTCNNLST\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"DFTCNNLST_DES\")));\n        SystemValueList.list.put(\"DFTMODE\", new SystemValueInfo(\"DFTMODE\", SERVER_TYPE_CHAR, 8, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"DFTMODE_DES\")));\n        SystemValueList.list.put(\"DFTNETTYPE\", new SystemValueInfo(\"DFTNETTYPE\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"DFTNETTYPE_DES\")));\n        SystemValueList.list.put(\"DTACPR\", new SystemValueInfo(\"DTACPR\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"DTACPR_DES\")));\n        SystemValueList.list.put(\"DTACPRINM\", new SystemValueInfo(\"DTACPRINM\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"DTACPRINM_DES\")));\n        SystemValueList.list.put(\"HPRPTHTMR\", new SystemValueInfo(\"HPRPTHTMR\", SERVER_TYPE_CHAR, 10, 4, TYPE_ARRAY, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"HPRPTHTMR_DES\")));\n        SystemValueList.list.put(\"JOBACN\", new SystemValueInfo(\"JOBACN\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"JOBACN_DES\")));\n        SystemValueList.list.put(\"LCLCPNAME\", new SystemValueInfo(\"LCLCPNAME\", SERVER_TYPE_CHAR, 8, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"LCLCPNAME_DES\")));\n        SystemValueList.list.put(\"LCLLOCNAME\", new SystemValueInfo(\"LCLLOCNAME\", SERVER_TYPE_CHAR, 8, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"LCLLOCNAME_DES\")));\n        SystemValueList.list.put(\"LCLNETID\", new SystemValueInfo(\"LCLNETID\", SERVER_TYPE_CHAR, 8, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"LCLNETID_DES\")));\n        SystemValueList.list.put(\"MAXHOP\", new SystemValueInfo(\"MAXHOP\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"MAXHOP_DES\")));\n        SystemValueList.list.put(\"MAXINTSSN\", new SystemValueInfo(\"MAXINTSSN\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"MAXINTSSN_DES\")));\n        SystemValueList.list.put(\"MSGQ\", new SystemValueInfo(\"MSGQ\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"MSGQ_DES\")));\n        SystemValueList.list.put(\"NETSERVER\", new SystemValueInfo(\"NETSERVER\", SERVER_TYPE_CHAR, 17, 5, TYPE_ARRAY, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"NETSERVER_DES\")));\n        SystemValueList.list.put(\"NODETYPE\", new SystemValueInfo(\"NODETYPE\", SERVER_TYPE_CHAR, 8, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"NODETYPE_DES\")));\n        SystemValueList.list.put(\"NWSDOMAIN\", new SystemValueInfo(\"NWSDOMAIN\", SERVER_TYPE_CHAR, 8, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"NWSDOMAIN_DES\")));\n        SystemValueList.list.put(\"OUTQ\", new SystemValueInfo(\"OUTQ\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"OUTQ_DES\")));\n        SystemValueList.list.put(\"PCSACC\", new SystemValueInfo(\"PCSACC\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"PCSACC_DES\")));\n        SystemValueList.list.put(\"PNDSYSNAME\", new SystemValueInfo(\"PNDSYSNAME\", SERVER_TYPE_CHAR, 8, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"PNDSYSNAME_DES\"),true));\n        SystemValueList.list.put(\"RAR\", new SystemValueInfo(\"RAR\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"RAR_DES\")));\n        SystemValueList.list.put(\"SYSNAME\", new SystemValueInfo(\"SYSNAME\", SERVER_TYPE_CHAR, 8, 1, TYPE_STRING, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"SYSNAME_DES\")));\n        SystemValueList.list.put(\"VRTAUTODEV\", new SystemValueInfo(\"VRTAUTODEV\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_NET, VRM420, ResourceBundleLoader.getSystemValueText(\"VRTAUTODEV_DES\")));\n\n        // V4R4 network attributes.\n        SystemValueList.list.put(\"ALWADDCLU\", new SystemValueInfo(\"ALWADDCLU\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_NET, VRM440, ResourceBundleLoader.getSystemValueText(\"ALWADDCLU_DES\")));\n        SystemValueList.list.put(\"MDMCNTRYID\", new SystemValueInfo(\"MDMCNTRYID\", SERVER_TYPE_CHAR, 2, 1, TYPE_STRING, GROUP_NET, VRM440, ResourceBundleLoader.getSystemValueText(\"MDMCNTRYID_DES\")));\n\n        // System values.\n        SystemValueList.list.put(\"QABNORMSW\", new SystemValueInfo(\"QABNORMSW\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QABNORMSW_DES\"), true));\n        SystemValueList.list.put(\"QACGLVL\", new SystemValueInfo(\"QACGLVL\", SERVER_TYPE_CHAR, 10, 8, TYPE_ARRAY, GROUP_MSG, VRM420, ResourceBundleLoader.getSystemValueText(\"QACGLVL_DES\")));\n        SystemValueList.list.put(\"QACTJOB\", new SystemValueInfo(\"QACTJOB\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_ALC, VRM420, ResourceBundleLoader.getSystemValueText(\"QACTJOB_DES\")));\n        SystemValueList.list.put(\"QADLACTJ\", new SystemValueInfo(\"QADLACTJ\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_ALC, VRM420, ResourceBundleLoader.getSystemValueText(\"QADLACTJ_DES\")));\n        SystemValueList.list.put(\"QADLSPLA\", new SystemValueInfo(\"QADLSPLA\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_ALC, VRM420, ResourceBundleLoader.getSystemValueText(\"QADLSPLA_DES\")));\n        SystemValueList.list.put(\"QADLTOTJ\", new SystemValueInfo(\"QADLTOTJ\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_ALC, VRM420, ResourceBundleLoader.getSystemValueText(\"QADLTOTJ_DES\")));\n        SystemValueList.list.put(\"QALWOBJRST\", new SystemValueInfo(\"QALWOBJRST\", SERVER_TYPE_CHAR, 10, 15, TYPE_ARRAY, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QALWOBJRST_DES\")));\n        SystemValueList.list.put(\"QALWUSRDMN\", new SystemValueInfo(\"QALWUSRDMN\", SERVER_TYPE_CHAR, 10, 50, TYPE_ARRAY, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QALWUSRDMN_DES\")));\n        SystemValueList.list.put(\"QASTLVL\", new SystemValueInfo(\"QASTLVL\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QASTLVL_DES\")));\n        SystemValueList.list.put(\"QATNPGM\", new SystemValueInfo(\"QATNPGM\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QATNPGM_DES\")));\n        SystemValueList.list.put(\"QAUDCTL\", new SystemValueInfo(\"QAUDCTL\", SERVER_TYPE_CHAR, 10, 5, TYPE_ARRAY, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QAUDCTL_DES\")));\n        SystemValueList.list.put(\"QAUDENDACN\", new SystemValueInfo(\"QAUDENDACN\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QAUDENDACN_DES\")));\n        SystemValueList.list.put(\"QAUDFRCLVL\", new SystemValueInfo(\"QAUDFRCLVL\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QAUDFRCLVL_DES\")));\n        SystemValueList.list.put(\"QAUDLVL\", new SystemValueInfo(\"QAUDLVL\", SERVER_TYPE_CHAR, 10, 16, TYPE_ARRAY, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QAUDLVL_DES\")));\n        SystemValueList.list.put(\"QAUTOCFG\", new SystemValueInfo(\"QAUTOCFG\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QAUTOCFG_DES\")));\n        SystemValueList.list.put(\"QAUTORMT\", new SystemValueInfo(\"QAUTORMT\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QAUTORMT_DES\")));\n        SystemValueList.list.put(\"QAUTOSPRPT\", new SystemValueInfo(\"QAUTOSPRPT\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QAUTOSPRPT_DES\")));\n        SystemValueList.list.put(\"QAUTOVRT\", new SystemValueInfo(\"QAUTOVRT\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QAUTOVRT_DES\")));\n        SystemValueList.list.put(\"QBASACTLVL\", new SystemValueInfo(\"QBASACTLVL\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_STG, VRM420, ResourceBundleLoader.getSystemValueText(\"QBASACTLVL_DES\")));\n        SystemValueList.list.put(\"QBASPOOL\", new SystemValueInfo(\"QBASPOOL\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_STG, VRM420, ResourceBundleLoader.getSystemValueText(\"QBASPOOL_DES\")));\n        SystemValueList.list.put(\"QBOOKPATH\", new SystemValueInfo(\"QBOOKPATH\", SERVER_TYPE_CHAR, 63, 5, TYPE_ARRAY, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QBOOKPATH_DES\")));\n        SystemValueList.list.put(\"QCCSID\", new SystemValueInfo(\"QCCSID\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QCCSID_DES\")));\n        SystemValueList.list.put(\"QCENTURY\", new SystemValueInfo(\"QCENTURY\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_DATTIM, VRM420, ResourceBundleLoader.getSystemValueText(\"QCENTURY_DES\")));\n        SystemValueList.list.put(\"QCHRID\", new SystemValueInfo(\"QCHRID\", SERVER_TYPE_CHAR, 10, 2, TYPE_ARRAY, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QCHRID_DES\")));\n        SystemValueList.list.put(\"QCMNARB\", new SystemValueInfo(\"QCMNARB\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QCMNARB_DES\")));\n        SystemValueList.list.put(\"QCMNRCYLMT\", new SystemValueInfo(\"QCMNRCYLMT\", SERVER_TYPE_CHAR, 10, 2, TYPE_ARRAY, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QCMNRCYLMT_DES\")));\n        SystemValueList.list.put(\"QCNTRYID\", new SystemValueInfo(\"QCNTRYID\", SERVER_TYPE_CHAR, 2, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QCNTRYID_DES\")));\n        SystemValueList.list.put(\"QCONSOLE\", new SystemValueInfo(\"QCONSOLE\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QCONSOLE_DES\"), true));\n        SystemValueList.list.put(\"QCRTAUT\", new SystemValueInfo(\"QCRTAUT\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QCRTAUT_DES\")));\n        SystemValueList.list.put(\"QCRTOBJAUD\", new SystemValueInfo(\"QCRTOBJAUD\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QCRTOBJAUD_DES\")));\n        SystemValueList.list.put(\"QCTLSBSD\", new SystemValueInfo(\"QCTLSBSD\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QCTLSBSD_DES\")));\n        SystemValueList.list.put(\"QCURSYM\", new SystemValueInfo(\"QCURSYM\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_EDT, VRM420, ResourceBundleLoader.getSystemValueText(\"QCURSYM_DES\")));\n        SystemValueList.list.put(\"QDATE\", new SystemValueInfo(\"QDATE\", SERVER_TYPE_CHAR, 7, 1, TYPE_DATE, GROUP_DATTIM, VRM420, ResourceBundleLoader.getSystemValueText(\"QDATE_DES\")));\n        SystemValueList.list.put(\"QDATFMT\", new SystemValueInfo(\"QDATFMT\", SERVER_TYPE_CHAR, 3, 1, TYPE_STRING, GROUP_EDT, VRM420, ResourceBundleLoader.getSystemValueText(\"QDATFMT_DES\")));\n        SystemValueList.list.put(\"QDATSEP\", new SystemValueInfo(\"QDATSEP\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_EDT, VRM420, ResourceBundleLoader.getSystemValueText(\"QDATSEP_DES\")));\n        SystemValueList.list.put(\"QDAY\", new SystemValueInfo(\"QDAY\", SERVER_TYPE_CHAR, 3, 1, TYPE_STRING, GROUP_DATTIM, VRM420, ResourceBundleLoader.getSystemValueText(\"QDAY_DES\")));\n        SystemValueList.list.put(\"QDAYOFWEEK\", new SystemValueInfo(\"QDAYOFWEEK\", SERVER_TYPE_CHAR, 4, 1, TYPE_STRING, GROUP_DATTIM, VRM420, ResourceBundleLoader.getSystemValueText(\"QDAYOFWEEK_DES\"), true));\n        SystemValueList.list.put(\"QDBRCVYWT\", new SystemValueInfo(\"QDBRCVYWT\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QDBRCVYWT_DES\")));\n        SystemValueList.list.put(\"QDECFMT\", new SystemValueInfo(\"QDECFMT\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_EDT, VRM420, ResourceBundleLoader.getSystemValueText(\"QDECFMT_DES\")));\n        SystemValueList.list.put(\"QDEVNAMING\", new SystemValueInfo(\"QDEVNAMING\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QDEVNAMING_DES\")));\n        SystemValueList.list.put(\"QDEVRCYACN\", new SystemValueInfo(\"QDEVRCYACN\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QDEVRCYACN_DES\")));\n        SystemValueList.list.put(\"QDSCJOBITV\", new SystemValueInfo(\"QDSCJOBITV\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QDSCJOBITV_DES\")));\n        SystemValueList.list.put(\"QDSPSGNINF\", new SystemValueInfo(\"QDSPSGNINF\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QDSPSGNINF_DES\")));\n        SystemValueList.list.put(\"QDYNPTYSCD\", new SystemValueInfo(\"QDYNPTYSCD\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QDYNPTYSCD_DES\")));\n        SystemValueList.list.put(\"QFRCCVNRST\", new SystemValueInfo(\"QFRCCVNRST\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QFRCCVNRST_DES\")));\n        SystemValueList.list.put(\"QHOUR\", new SystemValueInfo(\"QHOUR\", SERVER_TYPE_CHAR, 2, 1, TYPE_STRING, GROUP_DATTIM, VRM420, ResourceBundleLoader.getSystemValueText(\"QHOUR_DES\")));\n        SystemValueList.list.put(\"QHSTLOGSIZ\", new SystemValueInfo(\"QHSTLOGSIZ\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_MSG, VRM420, ResourceBundleLoader.getSystemValueText(\"QHSTLOGSIZ_DES\")));\n        SystemValueList.list.put(\"QIGC\", new SystemValueInfo(\"QIGC\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QIGC_DES\"), true));\n        SystemValueList.list.put(\"QIGCCDEFNT\", new SystemValueInfo(\"QIGCCDEFNT\", SERVER_TYPE_CHAR, 10, 2, TYPE_ARRAY, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QIGCCDEFNT_DES\")));\n        SystemValueList.list.put(\"QINACTITV\", new SystemValueInfo(\"QINACTITV\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QINACTITV_DES\")));\n        SystemValueList.list.put(\"QINACTMSGQ\", new SystemValueInfo(\"QINACTMSGQ\", SERVER_TYPE_CHAR, 10, 2, TYPE_ARRAY, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QINACTMSGQ_DES\")));\n        SystemValueList.list.put(\"QIPLDATTIM\", new SystemValueInfo(\"QIPLDATTIM\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QIPLDATTIM_DES\")));\n        SystemValueList.list.put(\"QIPLSTS\", new SystemValueInfo(\"QIPLSTS\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QIPLSTS_DES\"), true));\n        SystemValueList.list.put(\"QIPLTYPE\", new SystemValueInfo(\"QIPLTYPE\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QIPLTYPE_DES\")));\n        SystemValueList.list.put(\"QJOBMSGQFL\", new SystemValueInfo(\"QJOBMSGQFL\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_ALC, VRM420, ResourceBundleLoader.getSystemValueText(\"QJOBMSGQFL_DES\")));\n        SystemValueList.list.put(\"QJOBMSGQMX\", new SystemValueInfo(\"QJOBMSGQMX\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_ALC, VRM420, ResourceBundleLoader.getSystemValueText(\"QJOBMSGQMX_DES\")));\n        SystemValueList.list.put(\"QJOBMSGQSZ\", new SystemValueInfo(\"QJOBMSGQSZ\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_ALC, VRM420, ResourceBundleLoader.getSystemValueText(\"QJOBMSGQSZ_DES\")));\n        SystemValueList.list.put(\"QJOBMSGQTL\", new SystemValueInfo(\"QJOBMSGQTL\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_ALC, VRM420, ResourceBundleLoader.getSystemValueText(\"QJOBMSGQTL_DES\")));\n        SystemValueList.list.put(\"QJOBSPLA\", new SystemValueInfo(\"QJOBSPLA\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_ALC, VRM420, ResourceBundleLoader.getSystemValueText(\"QJOBSPLA_DES\")));\n        SystemValueList.list.put(\"QKBDBUF\", new SystemValueInfo(\"QKBDBUF\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QKBDBUF_DES\")));\n        SystemValueList.list.put(\"QKBDTYPE\", new SystemValueInfo(\"QKBDTYPE\", SERVER_TYPE_CHAR, 3, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QKBDTYPE_DES\")));\n        SystemValueList.list.put(\"QLANGID\", new SystemValueInfo(\"QLANGID\", SERVER_TYPE_CHAR, 3, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QLANGID_DES\")));\n        SystemValueList.list.put(\"QLEAPADJ\", new SystemValueInfo(\"QLEAPADJ\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_DATTIM, VRM420, ResourceBundleLoader.getSystemValueText(\"QLEAPADJ_DES\")));\n        SystemValueList.list.put(\"QLMTDEVSSN\", new SystemValueInfo(\"QLMTDEVSSN\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QLMTDEVSSN_DES\")));\n        SystemValueList.list.put(\"QLMTSECOFR\", new SystemValueInfo(\"QLMTSECOFR\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QLMTSECOFR_DES\")));\n        // This is size 2080 because of data returned on API. Actual size for path name is 1024 chars.\n        SystemValueList.list.put(\"QLOCALE\", new SystemValueInfo(\"QLOCALE\", SERVER_TYPE_CHAR, 2080, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QLOCALE_DES\")));\n        SystemValueList.list.put(\"QMAXACTLVL\", new SystemValueInfo(\"QMAXACTLVL\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_STG, VRM420, ResourceBundleLoader.getSystemValueText(\"QMAXACTLVL_DES\")));\n        SystemValueList.list.put(\"QMAXSGNACN\", new SystemValueInfo(\"QMAXSGNACN\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QMAXSGNACN_DES\")));\n        SystemValueList.list.put(\"QMAXSIGN\", new SystemValueInfo(\"QMAXSIGN\", SERVER_TYPE_CHAR, 6, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QMAXSIGN_DES\")));\n        SystemValueList.list.put(\"QMCHPOOL\", new SystemValueInfo(\"QMCHPOOL\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_STG, VRM420, ResourceBundleLoader.getSystemValueText(\"QMCHPOOL_DES\")));\n        SystemValueList.list.put(\"QMINUTE\", new SystemValueInfo(\"QMINUTE\", SERVER_TYPE_CHAR, 2, 1, TYPE_STRING, GROUP_DATTIM, VRM420, ResourceBundleLoader.getSystemValueText(\"QMINUTE_DES\")));\n        SystemValueList.list.put(\"QMODEL\", new SystemValueInfo(\"QMODEL\", SERVER_TYPE_CHAR, 4, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QMODEL_DES\"),true));\n        SystemValueList.list.put(\"QMONTH\", new SystemValueInfo(\"QMONTH\", SERVER_TYPE_CHAR, 2, 1, TYPE_STRING, GROUP_DATTIM, VRM420, ResourceBundleLoader.getSystemValueText(\"QMONTH_DES\")));\n        SystemValueList.list.put(\"QPASTHRSVR\", new SystemValueInfo(\"QPASTHRSVR\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QPASTHRSVR_DES\")));\n        SystemValueList.list.put(\"QPFRADJ\", new SystemValueInfo(\"QPFRADJ\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QPFRADJ_DES\")));\n        SystemValueList.list.put(\"QPRBFTR\", new SystemValueInfo(\"QPRBFTR\", SERVER_TYPE_CHAR, 10, 2, TYPE_ARRAY, GROUP_MSG, VRM420, ResourceBundleLoader.getSystemValueText(\"QPRBFTR_DES\")));\n        SystemValueList.list.put(\"QPRBHLDITV\", new SystemValueInfo(\"QPRBHLDITV\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_MSG, VRM420, ResourceBundleLoader.getSystemValueText(\"QPRBHLDITV_DES\")));\n        SystemValueList.list.put(\"QPRTDEV\", new SystemValueInfo(\"QPRTDEV\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QPRTDEV_DES\")));\n        SystemValueList.list.put(\"QPRTKEYFMT\", new SystemValueInfo(\"QPRTKEYFMT\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QPRTKEYFMT_DES\")));\n        SystemValueList.list.put(\"QPRTTXT\", new SystemValueInfo(\"QPRTTXT\", SERVER_TYPE_CHAR, 30, 1, TYPE_STRING, GROUP_MSG, VRM420, ResourceBundleLoader.getSystemValueText(\"QPRTTXT_DES\")));\n        SystemValueList.list.put(\"QPWDEXPITV\", new SystemValueInfo(\"QPWDEXPITV\", SERVER_TYPE_CHAR, 6, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QPWDEXPITV_DES\")));\n        SystemValueList.list.put(\"QPWDLMTAJC\", new SystemValueInfo(\"QPWDLMTAJC\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QPWDLMTAJC_DES\")));\n        SystemValueList.list.put(\"QPWDLMTCHR\", new SystemValueInfo(\"QPWDLMTCHR\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QPWDLMTCHR_DES\")));\n        SystemValueList.list.put(\"QPWDLMTREP\", new SystemValueInfo(\"QPWDLMTREP\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QPWDLMTREP_DES\")));\n        SystemValueList.list.put(\"QPWDMAXLEN\", new SystemValueInfo(\"QPWDMAXLEN\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QPWDMAXLEN_DES\")));\n        SystemValueList.list.put(\"QPWDMINLEN\", new SystemValueInfo(\"QPWDMINLEN\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QPWDMINLEN_DES\")));\n        SystemValueList.list.put(\"QPWDPOSDIF\", new SystemValueInfo(\"QPWDPOSDIF\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QPWDPOSDIF_DES\")));\n        SystemValueList.list.put(\"QPWDRQDDGT\", new SystemValueInfo(\"QPWDRQDDGT\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QPWDRQDDGT_DES\")));\n        SystemValueList.list.put(\"QPWDRQDDIF\", new SystemValueInfo(\"QPWDRQDDIF\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QPWDRQDDIF_DES\")));\n        SystemValueList.list.put(\"QPWDVLDPGM\", new SystemValueInfo(\"QPWDVLDPGM\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QPWDVLDPGM_DES\")));\n        SystemValueList.list.put(\"QPWRDWNLMT\", new SystemValueInfo(\"QPWRDWNLMT\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QPWRDWNLMT_DES\")));\n        SystemValueList.list.put(\"QPWRRSTIPL\", new SystemValueInfo(\"QPWRRSTIPL\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QPWRRSTIPL_DES\")));\n        SystemValueList.list.put(\"QQRYDEGREE\", new SystemValueInfo(\"QQRYDEGREE\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QQRYDEGREE_DES\")));\n        SystemValueList.list.put(\"QQRYTIMLMT\", new SystemValueInfo(\"QQRYTIMLMT\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QQRYTIMLMT_DES\")));\n        SystemValueList.list.put(\"QRCLSPLSTG\", new SystemValueInfo(\"QRCLSPLSTG\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_ALC, VRM420, ResourceBundleLoader.getSystemValueText(\"QRCLSPLSTG_DES\")));\n        SystemValueList.list.put(\"QRETSVRSEC\", new SystemValueInfo(\"QRETSVRSEC\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QRETSVRSEC_DES\")));\n        SystemValueList.list.put(\"QRMTIPL\", new SystemValueInfo(\"QRMTIPL\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QRMTIPL_DES\")));\n        SystemValueList.list.put(\"QRMTSIGN\", new SystemValueInfo(\"QRMTSIGN\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QRMTSIGN_DES\")));\n        SystemValueList.list.put(\"QRMTSRVATR\", new SystemValueInfo(\"QRMTSRVATR\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QRMTSRVATR_DES\")));\n        SystemValueList.list.put(\"QSCPFCONS\", new SystemValueInfo(\"QSCPFCONS\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QSCPFCONS_DES\")));\n        SystemValueList.list.put(\"QSECOND\", new SystemValueInfo(\"QSECOND\", SERVER_TYPE_CHAR, 2, 1, TYPE_STRING, GROUP_DATTIM, VRM420, ResourceBundleLoader.getSystemValueText(\"QSECOND_DES\")));\n        SystemValueList.list.put(\"QSECURITY\", new SystemValueInfo(\"QSECURITY\", SERVER_TYPE_CHAR, 2, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QSECURITY_DES\")));\n        SystemValueList.list.put(\"QSETJOBATR\", new SystemValueInfo(\"QSETJOBATR\", SERVER_TYPE_CHAR, 10, 16, TYPE_ARRAY, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QSETJOBATR_DES\")));\n        SystemValueList.list.put(\"QSFWERRLOG\", new SystemValueInfo(\"QSFWERRLOG\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_MSG, VRM420, ResourceBundleLoader.getSystemValueText(\"QSFWERRLOG_DES\")));\n        SystemValueList.list.put(\"QSPCENV\", new SystemValueInfo(\"QSPCENV\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QSPCENV_DES\")));\n        SystemValueList.list.put(\"QSRLNBR\", new SystemValueInfo(\"QSRLNBR\", SERVER_TYPE_CHAR, 8, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QSRLNBR_DES\"),true));\n        SystemValueList.list.put(\"QSRTSEQ\", new SystemValueInfo(\"QSRTSEQ\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QSRTSEQ_DES\")));\n        SystemValueList.list.put(\"QSRVDMP\", new SystemValueInfo(\"QSRVDMP\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_MSG, VRM420, ResourceBundleLoader.getSystemValueText(\"QSRVDMP_DES\")));\n        SystemValueList.list.put(\"QSTGLOWACN\", new SystemValueInfo(\"QSTGLOWACN\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_STG, VRM420, ResourceBundleLoader.getSystemValueText(\"QSTGLOWACN_DES\")));\n        SystemValueList.list.put(\"QSTGLOWLMT\", new SystemValueInfo(\"QSTGLOWLMT\", SERVER_TYPE_BINARY, 7, 4, 1, TYPE_DECIMAL, GROUP_STG, VRM420, ResourceBundleLoader.getSystemValueText(\"QSTGLOWLMT_DES\")));\n        SystemValueList.list.put(\"QSTRPRTWTR\", new SystemValueInfo(\"QSTRPRTWTR\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QSTRPRTWTR_DES\"), true));\n        SystemValueList.list.put(\"QSTRUPPGM\", new SystemValueInfo(\"QSTRUPPGM\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QSTRUPPGM_DES\")));\n        SystemValueList.list.put(\"QSTSMSG\", new SystemValueInfo(\"QSTSMSG\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_MSG, VRM420, ResourceBundleLoader.getSystemValueText(\"QSTSMSG_DES\")));\n        SystemValueList.list.put(\"QSVRAUTITV\", new SystemValueInfo(\"QSVRAUTITV\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QSVRAUTITV_DES\")));\n        SystemValueList.list.put(\"QSYSLIBL\", new SystemValueInfo(\"QSYSLIBL\", SERVER_TYPE_CHAR, 10, 15, TYPE_ARRAY, GROUP_LIBL, VRM420, ResourceBundleLoader.getSystemValueText(\"QSYSLIBL_DES\")));\n        SystemValueList.list.put(\"QTIME\", new SystemValueInfo(\"QTIME\", SERVER_TYPE_CHAR, 9, 1, TYPE_DATE, GROUP_DATTIM, VRM420, ResourceBundleLoader.getSystemValueText(\"QTIME_DES\")));\n        SystemValueList.list.put(\"QTIMSEP\", new SystemValueInfo(\"QTIMSEP\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_EDT, VRM420, ResourceBundleLoader.getSystemValueText(\"QTIMSEP_DES\")));\n        SystemValueList.list.put(\"QTOTJOB\", new SystemValueInfo(\"QTOTJOB\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_ALC, VRM420, ResourceBundleLoader.getSystemValueText(\"QTOTJOB_DES\")));\n        SystemValueList.list.put(\"QTSEPOOL\", new SystemValueInfo(\"QTSEPOOL\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_STG, VRM420, ResourceBundleLoader.getSystemValueText(\"QTSEPOOL_DES\")));\n        SystemValueList.list.put(\"QUPSDLYTIM\", new SystemValueInfo(\"QUPSDLYTIM\", SERVER_TYPE_CHAR, 10, 2, TYPE_ARRAY, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QUPSDLYTIM_DES\")));\n        SystemValueList.list.put(\"QUPSMSGQ\", new SystemValueInfo(\"QUPSMSGQ\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_SYSCTL, VRM420, ResourceBundleLoader.getSystemValueText(\"QUPSMSGQ_DES\")));\n        SystemValueList.list.put(\"QUSEADPAUT\", new SystemValueInfo(\"QUSEADPAUT\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SEC, VRM420, ResourceBundleLoader.getSystemValueText(\"QUSEADPAUT_DES\")));\n        SystemValueList.list.put(\"QUSRLIBL\", new SystemValueInfo(\"QUSRLIBL\", SERVER_TYPE_CHAR, 10, 25, TYPE_ARRAY, GROUP_LIBL, VRM420, ResourceBundleLoader.getSystemValueText(\"QUSRLIBL_DES\")));\n        SystemValueList.list.put(\"QUTCOFFSET\", new SystemValueInfo(\"QUTCOFFSET\", SERVER_TYPE_CHAR, 5, 1, TYPE_STRING, GROUP_DATTIM, VRM420, ResourceBundleLoader.getSystemValueText(\"QUTCOFFSET_DES\")));\n        SystemValueList.list.put(\"QYEAR\", new SystemValueInfo(\"QYEAR\", SERVER_TYPE_CHAR, 2, 1, TYPE_STRING, GROUP_DATTIM, VRM420, ResourceBundleLoader.getSystemValueText(\"QYEAR_DES\")));\n\n        // V4R3 system values.\n        SystemValueList.list.put(\"QCHRIDCTL\", new SystemValueInfo(\"QCHRIDCTL\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SYSCTL, VRM430, ResourceBundleLoader.getSystemValueText(\"QCHRIDCTL_DES\")));\n        SystemValueList.list.put(\"QDYNPTYADJ\", new SystemValueInfo(\"QDYNPTYADJ\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM430, ResourceBundleLoader.getSystemValueText(\"QDYNPTYADJ_DES\")));\n        SystemValueList.list.put(\"QIGCFNTSIZ\", new SystemValueInfo(\"QIGCFNTSIZ\", SERVER_TYPE_BINARY, 4, 1, 1, TYPE_DECIMAL, GROUP_SYSCTL, VRM430, ResourceBundleLoader.getSystemValueText(\"QIGCFNTSIZ_DES\")));\n        SystemValueList.list.put(\"QPRCMLTTSK\", new SystemValueInfo(\"QPRCMLTTSK\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM430, ResourceBundleLoader.getSystemValueText(\"QPRCMLTTSK_DES\")));\n        SystemValueList.list.put(\"QPRCFEAT\", new SystemValueInfo(\"QPRCFEAT\", SERVER_TYPE_CHAR, 4, 1, TYPE_STRING, GROUP_SYSCTL, VRM430, ResourceBundleLoader.getSystemValueText(\"QPRCFEAT_DES\"),true));\n\n        // V4R4 system values.\n        SystemValueList.list.put(\"QCFGMSGQ\", new SystemValueInfo(\"QCFGMSGQ\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_MSG, VRM440, ResourceBundleLoader.getSystemValueText(\"QCFGMSGQ_DES\")));\n        SystemValueList.list.put(\"QMLTTHDACN\", new SystemValueInfo(\"QMLTTHDACN\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM440, ResourceBundleLoader.getSystemValueText(\"QMLTTHDACN_DES\")));\n\n        SystemValueList.list.put(\"QMAXJOB\",    new SystemValueInfo(\"QMAXJOB\",    SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_ALC,  VRM510, ResourceBundleLoader.getSystemValueText(\"QMAXJOB_DES\")));\n        SystemValueList.list.put(\"QMAXSPLF\",   new SystemValueInfo(\"QMAXSPLF\",   SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_ALC,  VRM510, ResourceBundleLoader.getSystemValueText(\"QMAXSPLF_DES\")));\n        SystemValueList.list.put(\"QVFYOBJRST\", new SystemValueInfo(\"QVFYOBJRST\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING,  GROUP_SEC,  VRM510, ResourceBundleLoader.getSystemValueText(\"QVFYOBJRST_DES\")));\n        SystemValueList.list.put(\"QSHRMEMCTL\", new SystemValueInfo(\"QSHRMEMCTL\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING,  GROUP_SEC,  VRM510, ResourceBundleLoader.getSystemValueText(\"QSHRMEMCTL_DES\")));\n        SystemValueList.list.put(\"QLIBLCKLVL\", new SystemValueInfo(\"QLIBLCKLVL\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING,  GROUP_LIBL, VRM510, ResourceBundleLoader.getSystemValueText(\"QLIBLCKLVL_DES\")));\n        SystemValueList.list.put(\"QPWDLVL\", new SystemValueInfo(\"QPWDLVL\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_SEC,  VRM510, ResourceBundleLoader.getSystemValueText(\"QPWDLVL_DES\")));\n\n        // V5R2 system values.\n        SystemValueList.list.put(\"QSPLFACN\",   new SystemValueInfo(\"QSPLFACN\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_ALC, VRM520, ResourceBundleLoader.getSystemValueText(\"QSPLFACN_DES\")));\n        SystemValueList.list.put(\"QDBFSTCCOL\", new SystemValueInfo(\"QDBFSTCCOL\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SYSCTL, VRM520, ResourceBundleLoader.getSystemValueText(\"QDBFSTCCOL_DES\")));\n\n        // V5R3 system values.\n        SystemValueList.list.put(\"QAUDLVL2\",   new SystemValueInfo(\"QAUDLVL2\", SERVER_TYPE_CHAR, 10, 99, TYPE_ARRAY, GROUP_SEC, VRM530, ResourceBundleLoader.getSystemValueText(\"QAUDLVL2_DES\")));\n        SystemValueList.list.put(\"QDATETIME\",   new SystemValueInfo(\"QDATETIME\", SERVER_TYPE_CHAR, 20, 1, TYPE_STRING, GROUP_DATTIM, VRM530, ResourceBundleLoader.getSystemValueText(\"QDATETIME_DES\")));\n        // The format of the QDATETIME field is YYYYMMDDHHNNSSXXXXXX\n        // where YYYY is the year, MM is the month, DD is the day,\n        // HH is the hours, NN is the minutes, SS is the seconds,\n        // and XXXXXX is the microseconds.\n\n        SystemValueList.list.put(\"QENDJOBLMT\",   new SystemValueInfo(\"QENDJOBLMT\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_SYSCTL, VRM530, ResourceBundleLoader.getSystemValueText(\"QENDJOBLMT_DES\")));\n        SystemValueList.list.put(\"QSAVACCPTH\",   new SystemValueInfo(\"QSAVACCPTH\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM530, ResourceBundleLoader.getSystemValueText(\"QSAVACCPTH_DES\")));\n        SystemValueList.list.put(\"QSCANFS\",   new SystemValueInfo(\"QSCANFS\", SERVER_TYPE_CHAR, 10, 20, TYPE_ARRAY, GROUP_SEC, VRM530, ResourceBundleLoader.getSystemValueText(\"QSCANFS_DES\")));\n        SystemValueList.list.put(\"QSCANFSCTL\",   new SystemValueInfo(\"QSCANFSCTL\", SERVER_TYPE_CHAR, 10, 20, TYPE_ARRAY, GROUP_SEC, VRM530, ResourceBundleLoader.getSystemValueText(\"QSCANFSCTL_DES\")));\n        SystemValueList.list.put(\"QTIMADJ\",   new SystemValueInfo(\"QTIMADJ\", SERVER_TYPE_CHAR, 28, 1, TYPE_STRING, GROUP_DATTIM, VRM530, ResourceBundleLoader.getSystemValueText(\"QTIMADJ_DES\")));\n        SystemValueList.list.put(\"QTIMZON\",   new SystemValueInfo(\"QTIMZON\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_DATTIM, VRM530, ResourceBundleLoader.getSystemValueText(\"QTIMZON_DES\")));\n        SystemValueList.list.put(\"QTHDRSCAFN\", new SystemValueInfo(\"QTHDRSCAFN\", SERVER_TYPE_CHAR, 10, 2, TYPE_ARRAY, GROUP_SYSCTL, VRM530, ResourceBundleLoader.getSystemValueText(\"QTHDRSCAFN_DES\")));\n        SystemValueList.list.put(\"QTHDRSCADJ\", new SystemValueInfo(\"QTHDRSCADJ\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM530, ResourceBundleLoader.getSystemValueText(\"QTHDRSCADJ_DES\")));\n\n        // V5R4 system values.\n        SystemValueList.list.put(\"QALWJOBITP\", new SystemValueInfo(\"QALWJOBITP\", SERVER_TYPE_CHAR, 1, 1, TYPE_STRING, GROUP_SYSCTL, VRM540, ResourceBundleLoader.getSystemValueText(\"QALWJOBITP_DES\")));\n        SystemValueList.list.put(\"QLOGOUTPUT\", new SystemValueInfo(\"QLOGOUTPUT\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_MSG, VRM540, ResourceBundleLoader.getSystemValueText(\"QLOGOUTPUT_DES\")));\n\n        // V6R1 system values.\n        SystemValueList.list.put(\"QPWDRULES\", new SystemValueInfo(\"QPWDRULES\", SERVER_TYPE_CHAR, 15, 50, TYPE_ARRAY, GROUP_SEC, VRM610, ResourceBundleLoader.getSystemValueText(\"QPWDRULES_DES\")));\n        SystemValueList.list.put(\"QPWDCHGBLK\", new SystemValueInfo(\"QPWDCHGBLK\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SEC, VRM610, ResourceBundleLoader.getSystemValueText(\"QPWDCHGBLK_DES\")));\n        SystemValueList.list.put(\"QPWDEXPWRN\", new SystemValueInfo(\"QPWDEXPWRN\", SERVER_TYPE_BINARY, 4, 1, TYPE_INTEGER, GROUP_SEC, VRM610, ResourceBundleLoader.getSystemValueText(\"QPWDEXPWRN_DES\")));\n        SystemValueList.list.put(\"QSSLPCL\", new SystemValueInfo(\"QSSLPCL\", SERVER_TYPE_CHAR, 10, 10, TYPE_ARRAY, GROUP_SEC, VRM610, ResourceBundleLoader.getSystemValueText(\"QSSLPCL_DES\")));\n        SystemValueList.list.put(\"QSSLCSLCTL\", new SystemValueInfo(\"QSSLCSLCTL\", SERVER_TYPE_CHAR, 10, 1, TYPE_STRING, GROUP_SEC, VRM610, ResourceBundleLoader.getSystemValueText(\"QSSLCSLCTL_DES\")));\n        SystemValueList.list.put(\"QSSLCSL\", new SystemValueInfo(\"QSSLCSL\", SERVER_TYPE_CHAR, 40, 32, TYPE_ARRAY, GROUP_SEC, VRM610, ResourceBundleLoader.getSystemValueText(\"QSSLCSL_DES\")));\n\n        // Populate the group vectors.\n        Enumeration elements = SystemValueList.list.elements();\n        while (elements.hasMoreElements())\n        {\n            SystemValueInfo obj = (SystemValueInfo)elements.nextElement();\n            SystemValueList.groups[obj.group_].addElement(obj);\n            SystemValueList.groups[GROUP_ALL].addElement(obj);\n        }\n    }\n\n    // The system where the system value list is located.\n    private AS400 system_ = null;\n    // Flag indicating if a connection been made.\n    private boolean connected_ = false;\n\n    // List of property change event bean listeners.\n    private transient PropertyChangeSupport propertyChangeListeners_ = null;  // Set on first add.\n    // List of vetoable change event bean listeners.\n    private transient VetoableChangeSupport vetoableChangeListeners_ = null;  // Set on first add.\n\n    /**\n     Constructs a SystemValueList object.  It creates a default SystemValueList object.  The <i>system</i> property must be set before attempting a connection.\n     **/\n    public SystemValueList()\n    {\n        if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"Constructing SystemValueList object.\");\n    }\n\n    /**\n     Constructs a SystemValueList object. It creates a SystemValueList instance that represents a list of system values on <i>system</i>.\n     @param  system  The system that contains the system values.\n     **/\n    public SystemValueList(AS400 system)\n    {\n        if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"Constructing SystemValueGroup object, system: \" + system);\n        if (system == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'system' is null.\");\n            throw new NullPointerException(\"system\");\n        }\n        system_ = system;\n    }\n\n    /**\n     Adds a PropertyChangeListener.  The specified PropertyChangeListener's <b>propertyChange</b> method will be called each time the value of any bound property is changed.  The PropertyChangeListener object is added to a list of PropertyChangeListeners managed by this SystemValue.  It can be removed with removePropertyChangeListener.\n     @param  listener  The listener object.\n     **/\n    public void addPropertyChangeListener(PropertyChangeListener listener)\n    {\n        if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"Adding property change listener.\");\n        if (listener == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'listener' is null.\");\n            throw new NullPointerException(\"listener\");\n        }\n        synchronized (this)\n        {\n            // If first add.\n            if (propertyChangeListeners_ == null)\n            {\n                propertyChangeListeners_ = new PropertyChangeSupport(this);\n            }\n            propertyChangeListeners_.addPropertyChangeListener(listener);\n        }\n    }\n\n    /**\n     Adds a VetoableChangeListener.  The specified VetoableChangeListener's <b>vetoableChange</b> method will be called each time the value of any constrained property is changed.\n     @param  listener  The listener object.\n     **/\n    public void addVetoableChangeListener(VetoableChangeListener listener)\n    {\n        if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"Adding vetoable change listener.\");\n        if (listener == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'listener' is null.\");\n            throw new NullPointerException(\"listener\");\n        }\n        synchronized (this)\n        {\n            // If first add.\n            if (vetoableChangeListeners_ == null)\n            {\n                vetoableChangeListeners_ = new VetoableChangeSupport(this);\n            }\n            vetoableChangeListeners_.addVetoableChangeListener(listener);\n        }\n    }\n\n    // Makes a connection to the system.  The <i>system</i> property must be set before a connection can be made.\n    private void connect() throws AS400SecurityException, IOException\n    {\n        if (system_ == null)\n        {\n            Trace.log(Trace.ERROR, \"Cannot connect before setting system.\");\n            throw new ExtendedIllegalStateException(\"system\", ExtendedIllegalStateException.PROPERTY_NOT_SET);\n        }\n\n        connected_ = true;\n    }\n\n    /**\n     Returns a set of SystemValue objects.  Returns the system values that belong to the system value group specified by <i>group</i> and sorted by name.\n     @param  group  The system value group.\n     @return  A Vector of {@link SystemValue SystemValue} objects.\n     @exception  AS400SecurityException  If a security or authority error occurs.\n     @exception  ErrorCompletingRequestException  If an error occurs before the request is completed.\n     @exception  InterruptedException  If this thread is interrupted.\n     @exception  IOException  If an error occurs while communicating with the system.\n     @exception  ObjectDoesNotExistException  If the object does not exist on the system.\n     **/\n    public Vector getGroup(int group) throws AS400SecurityException, ErrorCompletingRequestException, InterruptedException, IOException, ObjectDoesNotExistException\n    {\n        if (!connected_) connect();\n\n        if (group < 0 || group > GROUP_ALL)\n        {\n            Trace.log(Trace.ERROR, \"Value of parameter 'group' is not valid:\", group);\n            throw new ExtendedIllegalArgumentException(\"group\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        // Get the group vector.\n        Vector infos = SystemValueList.groups[group];\n\n        // QFRCCVNRST was in group SYSCTL in release V5R1M0 and below, and moved to group SEC in V5R2M0 and above.  By default we have it in group SEC, so if the IBM i release is V5R1M0 or below, we fix up the group here.\n        if (system_.getVRM() <= VRM510)\n        {\n            switch (group)\n            {\n                case SystemValueList.GROUP_SEC:\n                    // Make a copy of the group and remove QFRCCVNRST.\n                    infos = (Vector)infos.clone();\n                    infos.removeElement(SystemValueList.lookup(\"QFRCCVNRST\"));\n                    break;\n                case SystemValueList.GROUP_SYSCTL:\n                    // Make a copy of the group and add QFRCCVNRST.\n                    infos = (Vector)infos.clone();\n                    infos.addElement(SystemValueList.lookup(\"QFRCCVNRST\"));\n                    break;\n            }\n        }\n\n        // Call retrieve() to get the data from the server and create a Vector of corresponding SystemValue objects.\n        return sort(SystemValueUtility.retrieve(system_, infos.elements(), getGroupName(group), getGroupDescription(group)));\n    }\n\n    /**\n     Returns the total number of possible groups.\n     @return  The number of groups.\n     **/\n    public static int getGroupCount()\n    {\n        return GROUP_COUNT;\n    }\n\n    /**\n     Returns the description for the specified system value group.\n     @param  group  The system value group.\n     @return  The description of the system value group.\n     **/\n    public static String getGroupDescription(int group)\n    {\n        if (group < 0 || group > GROUP_ALL)\n        {\n            Trace.log(Trace.ERROR, \"Value of parameter 'group' is not valid:\", group);\n            throw new ExtendedIllegalArgumentException(\"group\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        return GROUP_DESCRIPTIONS[group];\n    }\n\n    /**\n     Returns the description for the specified system value group.\n     @param  group  The system value group.\n     @param  locale  The Locale used to load the appropriate language.\n     @return  The description of the system value group.\n     **/\n    public static String getGroupDescription(int group, Locale locale)\n    {\n        if (group < 0 || group > GROUP_ALL)\n        {\n            Trace.log(Trace.ERROR, \"Value of parameter 'group' is not valid:\", group);\n            throw new ExtendedIllegalArgumentException(\"group\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n        if (locale == null) return GROUP_DESCRIPTIONS[group];\n        switch (group)\n        {\n            case 0: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_ALC_DESC\", locale);\n            case 1: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_DATTIM_DESC\", locale);\n            case 2: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_EDT_DESC\", locale);\n            case 3: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_LIBL_DESC\", locale);\n            case 4: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_MSG_DESC\", locale);\n            case 5: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_SEC_DESC\", locale);\n            case 6: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_STG_DESC\", locale);\n            case 7: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_SYSCTL_DESC\", locale);\n            case 8: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_NET_DESC\", locale);\n            case 9: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_ALL_DESC\", locale);\n        }\n        return GROUP_DESCRIPTIONS[group];\n    }\n\n    /**\n     Returns the name of the specified system value group.\n     @param  group  The system value group.\n     @return  The name of the system value group.\n     **/\n    public static String getGroupName(int group)\n    {\n        if (group < 0 || group > GROUP_ALL)\n        {\n            Trace.log(Trace.ERROR, \"Value of parameter 'group' is not valid:\", group);\n            throw new ExtendedIllegalArgumentException(\"group\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        return GROUP_NAMES[group];\n    }\n\n    /**\n     Returns the name of the specified system value group.\n     @param  group  The system value group.\n     @param  locale  The Locale used to load the appropriate language.\n     @return  The name of the system value group.\n     **/\n    public static String getGroupName(int group, Locale locale)\n    {\n        if (group < 0 || group > GROUP_ALL)\n        {\n            Trace.log(Trace.ERROR, \"Value of parameter 'group' is not valid:\", group);\n            throw new ExtendedIllegalArgumentException(\"group\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n        if (locale == null) return GROUP_NAMES[group];\n        switch (group)\n        {\n            case 0: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_ALC_NAME\", locale);\n            case 1: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_DATTIM_NAME\", locale);\n            case 2: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_EDT_NAME\", locale);\n            case 3: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_LIBL_NAME\", locale);\n            case 4: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_MSG_NAME\", locale);\n            case 5: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_SEC_NAME\", locale);\n            case 6: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_STG_NAME\", locale);\n            case 7: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_SYSCTL_NAME\", locale);\n            case 8: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_NET_NAME\", locale);\n            case 9: return ResourceBundleLoader.getSystemValueText(\"SYSTEM_VALUE_GROUP_ALL_NAME\", locale);\n        }\n        return GROUP_NAMES[group];\n    }\n\n    /**\n     Returns the system object representing the system on which the system value list exists.\n     @return  The system object representing the system on which the system value list exists.  If the system has not been set, null is returned.\n     **/\n    public AS400 getSystem()\n    {\n        if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"Getting system: \" + system_);\n        return system_;\n    }\n\n    // Returns a SystemValueInfo object for the system value specified by <i>name</i>.\n    // @param  name  The name of the system value.\n    // @return  The SystemValueInfo object corresponding to <i>name</i>.\n    static SystemValueInfo lookup(String name)\n    {\n        SystemValueInfo obj = (SystemValueInfo)SystemValueList.list.get(name);\n        if (obj == null)\n        {\n            Trace.log(Trace.ERROR, \"System value was not found: \" + name);\n            throw new ExtendedIllegalArgumentException(name, ExtendedIllegalArgumentException.FIELD_NOT_FOUND);\n        }\n        return obj;\n    }\n\n    // Returns the locale-specific description for a SystemValue.\n    static String lookupDescription(SystemValueInfo info, Locale locale)\n    {\n        return ResourceBundleLoader.getSystemValueText(info.name_.toUpperCase().trim() + \"_DES\", locale);\n    }\n\n    /**\n     Removes the PropertyChangeListener.  If the PropertyChangeListener is not on the list, nothing is done.\n     @param  listener  The listener object.\n     **/\n    public void removePropertyChangeListener(PropertyChangeListener listener)\n    {\n        if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"Removing property change listener.\");\n        if (listener == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'listener' is null.\");\n            throw new NullPointerException(\"listener\");\n        }\n        // If we have listeners.\n        if (propertyChangeListeners_ != null)\n        {\n            propertyChangeListeners_.removePropertyChangeListener(listener);\n        }\n    }\n\n    /**\n     Removes the VetoableChangeListener.  If the VetoableChangeListener is not on the list, nothing is done.\n     @param  listener  The listener object.\n     **/\n    public void removeVetoableChangeListener(VetoableChangeListener listener)\n    {\n        if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"Removing vetoable change listener.\");\n        if (listener == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'listener' is null.\");\n            throw new NullPointerException(\"listener\");\n        }\n        // If we have listeners.\n        if (vetoableChangeListeners_ != null)\n        {\n            vetoableChangeListeners_.removeVetoableChangeListener(listener);\n        }\n    }\n\n    /**\n     Sets the system object representing the system on which the system value list exists.\n     @param  system  The system object representing the system on which the system value list exists.\n     @exception  PropertyVetoException  If any of the registered listeners vetos the property change.\n     **/\n    public void setSystem(AS400 system) throws PropertyVetoException\n    {\n        if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"Setting system: \" + system);\n\n        if (system == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'system' is null.\");\n            throw new NullPointerException(\"system\");\n        }\n        if (connected_)\n        {\n            Trace.log(Trace.ERROR, \"Cannot set property 'system' after connect.\");\n            throw new ExtendedIllegalStateException(\"system\", ExtendedIllegalStateException.PROPERTY_NOT_CHANGED);\n        }\n\n        if (propertyChangeListeners_ == null && vetoableChangeListeners_ == null)\n        {\n            system_ = system;\n        }\n        else\n        {\n            AS400 oldValue = system_;\n            AS400 newValue = system;\n\n            if (vetoableChangeListeners_ != null)\n            {\n                vetoableChangeListeners_.fireVetoableChange(\"system\", oldValue, newValue);\n            }\n            system_ = system;\n            if (propertyChangeListeners_ != null)\n            {\n                propertyChangeListeners_.firePropertyChange(\"system\", oldValue, newValue);\n            }\n        }\n    }\n\n    /**\n\t * Removes a working listener.\n\t * @param vSystemValueList TODO\n\t * @param  listener    The listener.\n\t**/\n\tpublic void removeWorkingListener(VSystemValueList vSystemValueList, WorkingListener listener)\n\t{\n\t  if (listener == null)\n\t    throw new NullPointerException(\"listener\");\n\t\n\t    vSystemValueList.workingEventSupport_.removeWorkingListener(listener); \n\t}\n\n\t// Recursively sorts vectors of SystemValue objects by name.\n    // @param  vec  The objects to sort.\n    // @return  The Vector of sorted objects.\n    static Vector sort(Vector vec)\n    {\n        int len = vec.size();\n        if (len < 2) return vec;\n        SystemValue middle = (SystemValue)vec.elementAt(len / 2);\n        Vector lessthan = new Vector(len / 2);\n        Vector equalto = new Vector(len / 2);\n        Vector greaterthan = new Vector(len / 2);\n        Enumeration elements = vec.elements();\n        while (elements.hasMoreElements())\n        {\n            SystemValue obj = (SystemValue)elements.nextElement();\n            int comparison = obj.getName().compareTo(middle.getName());\n            if (comparison < 0) lessthan.addElement(obj);\n            else if (comparison > 0) greaterthan.addElement(obj);\n            else equalto.addElement(obj);\n        }\n        lessthan.trimToSize();\n        equalto.trimToSize();\n        greaterthan.trimToSize();\n        Vector lefthalf = sort(lessthan);\n        Vector righthalf = sort(greaterthan);\n        Vector whole = new Vector(lefthalf.size() + righthalf.size() + equalto.size());\n        elements = lefthalf.elements();\n        while (elements.hasMoreElements())\n        {\n            whole.addElement(elements.nextElement());\n        }\n        elements = equalto.elements();\n        while (elements.hasMoreElements())\n        {\n            whole.addElement(elements.nextElement());\n        }\n        elements = righthalf.elements();\n        while (elements.hasMoreElements())\n        {\n            whole.addElement(elements.nextElement());\n        }\n        return whole;\n    }\n\n/*    static String getName(Vector systemValues, int position)\n    {\n        return ((SystemValue)systemValues.elementAt(position)).info_.name_;\n    }*/\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 2,
                "candidates": [
                    {
                        "lineStart": 660,
                        "lineEnd": 664,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method lookupDescription to class ObjectDescriptionEnumeration",
                        "description": "move method to com.ibm.as400.access.ObjectDescriptionEnumeration\nRationale: The method lookupDescription is responsible for retrieving locale-specific descriptions, which aligns with the purpose of managing and enumerating object descriptions.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 758,
                        "lineEnd": 800,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method sort to class AS400CertificateUtilImplRemote",
                        "description": "move method to com.ibm.as400.access.AS400CertificateUtilImplRemote\nRationale: The method is responsible for sorting SystemValue objects, which may relate to certificate management in the AS400 context, making it suitable for the AS400CertificateUtilImplRemote class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 23178
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getGroup",
                            "method_signature": "public Vector getGroup(int group) throws AS400SecurityException, ErrorCompletingRequestException, InterruptedException, IOException, ObjectDoesNotExistException",
                            "target_class": "SystemValueUtility",
                            "rationale": "The method retrieves system values and sorts them, which aligns more closely with utility functions that handle system value operations rather than being part of the SystemValueList class."
                        },
                        {
                            "method_name": "lookup",
                            "method_signature": "static SystemValueInfo lookup(String name)",
                            "target_class": "SystemValueUtility",
                            "rationale": "The lookup method is a utility function that retrieves a SystemValueInfo object based on the name, which is better suited in a utility class that handles operations related to SystemValue."
                        },
                        {
                            "method_name": "lookupDescription",
                            "method_signature": "static String lookupDescription(SystemValueInfo info, Locale locale)",
                            "target_class": "SystemValueUtility",
                            "rationale": "This method is a utility function for retrieving locale-specific descriptions, which should be part of a utility class focused on SystemValue operations."
                        },
                        {
                            "method_name": "sort",
                            "method_signature": "static Vector sort(Vector vec)",
                            "target_class": "SystemValueUtility",
                            "rationale": "The sort method is a utility function that sorts SystemValue objects, which is more appropriate in a utility class rather than being part of the SystemValueList class."
                        }
                    ],
                    "llm_response_time": 5139
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "getGroup",
                            "method_signature": "public Vector getGroup(int group) throws AS400SecurityException, ErrorCompletingRequestException, InterruptedException, IOException, ObjectDoesNotExistException",
                            "target_class": "SystemValueUtility",
                            "rationale": "The method retrieves system values and sorts them, which aligns more closely with utility functions that handle system value operations."
                        },
                        {
                            "method_name": "lookup",
                            "method_signature": "static SystemValueInfo lookup(String name)",
                            "target_class": "SystemValueUtility",
                            "rationale": "The lookup method is a utility function that retrieves a SystemValueInfo object based on the name, making it more appropriate for a utility class."
                        },
                        {
                            "method_name": "lookupDescription",
                            "method_signature": "static String lookupDescription(SystemValueInfo info, Locale locale)",
                            "target_class": "SystemValueUtility",
                            "rationale": "This method is a utility function for retrieving locale-specific descriptions, which fits better in a utility class focused on system value operations."
                        },
                        {
                            "method_name": "sort",
                            "method_signature": "static Vector sort(Vector vec)",
                            "target_class": "SystemValueUtility",
                            "rationale": "The sort method is a utility function for sorting SystemValue objects, which should be encapsulated in a utility class rather than being part of the SystemValueList class."
                        }
                    ],
                    "llm_response_time": 4195
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "getGroup",
                            "method_signature": "public Vector getGroup(int group) throws AS400SecurityException, ErrorCompletingRequestException, InterruptedException, IOException, ObjectDoesNotExistException",
                            "target_class": "SystemValueUtility",
                            "rationale": "The method retrieves system values and sorts them, which aligns more closely with utility functions that handle system value operations."
                        },
                        {
                            "method_name": "lookup",
                            "method_signature": "static SystemValueInfo lookup(String name)",
                            "target_class": "SystemValueUtility",
                            "rationale": "The lookup method is a utility function that retrieves a SystemValueInfo object based on the name, making it more appropriate for a utility class."
                        },
                        {
                            "method_name": "lookupDescription",
                            "method_signature": "static String lookupDescription(SystemValueInfo info, Locale locale)",
                            "target_class": "SystemValueUtility",
                            "rationale": "This method provides a utility function to retrieve locale-specific descriptions, which fits better in a utility class."
                        },
                        {
                            "method_name": "sort",
                            "method_signature": "static Vector sort(Vector vec)",
                            "target_class": "SystemValueUtility",
                            "rationale": "The sort method is a utility function for sorting SystemValue objects, which should be encapsulated in a utility class for better organization."
                        }
                    ],
                    "llm_response_time": 3948
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getGroup",
                            "method_signature": "public Vector getGroup(int group) throws AS400SecurityException, ErrorCompletingRequestException, InterruptedException, IOException, ObjectDoesNotExistException",
                            "target_class": "SystemValueUtility",
                            "rationale": "The method retrieves system values and sorts them, which aligns more closely with utility functions that handle system value operations rather than being part of the SystemValueList class."
                        },
                        {
                            "method_name": "lookup",
                            "method_signature": "static SystemValueInfo lookup(String name)",
                            "target_class": "SystemValueUtility",
                            "rationale": "The lookup method is a utility function that retrieves a SystemValueInfo object based on the name, which is better suited in a utility class that handles operations related to SystemValue."
                        },
                        {
                            "method_name": "lookupDescription",
                            "method_signature": "static String lookupDescription(SystemValueInfo info, Locale locale)",
                            "target_class": "SystemValueUtility",
                            "rationale": "This method is a utility function for retrieving locale-specific descriptions, which should be part of a utility class focused on SystemValue operations."
                        },
                        {
                            "method_name": "sort",
                            "method_signature": "static Vector sort(Vector vec)",
                            "target_class": "SystemValueUtility",
                            "rationale": "The sort method is a utility function that sorts SystemValue objects, which is more appropriate in a utility class rather than being part of the SystemValueList class."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "getGroup",
                    "lookup",
                    "lookupDescription",
                    "sort"
                ],
                "llm_response_time": 9758
            },
            "targetClassMap": {
                "getGroup": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1182,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "lookup": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1321,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "lookupDescription": {
                    "target_classes": [
                        {
                            "class_name": "IFSFileOutputStreamImplProxy",
                            "similarity_score": 0.24873089770551926
                        },
                        {
                            "class_name": "IFSRandomAccessFileImplProxy",
                            "similarity_score": 0.28103954475240933
                        },
                        {
                            "class_name": "LicenseGetInformationRequest",
                            "similarity_score": 0.23225021019333955
                        },
                        {
                            "class_name": "ObjectAlreadyExistsException",
                            "similarity_score": 0.3863720294986007
                        },
                        {
                            "class_name": "ObjectDescriptionEnumeration",
                            "similarity_score": 0.28663185141221514
                        },
                        {
                            "class_name": "RCCallProgramReplyDataStream",
                            "similarity_score": 0.3316739956936693
                        },
                        {
                            "class_name": "RequestNotSupportedException",
                            "similarity_score": 0.36237698361460674
                        },
                        {
                            "class_name": "UserSpaceNativeReadWriteImpl",
                            "similarity_score": 0.12152338248029255
                        },
                        {
                            "class_name": "ZonedDecimalFieldDescription",
                            "similarity_score": 0.37030497878464075
                        },
                        {
                            "class_name": "AS400JDBCXADataSourceBeanInfo",
                            "similarity_score": 0.33041327505236084
                        },
                        {
                            "class_name": "DBColumnDescriptorsDataFormat",
                            "similarity_score": 0.4170552616595197
                        },
                        {
                            "class_name": "DQRequestAttributesDataStream",
                            "similarity_score": 0.21501647626876536
                        },
                        {
                            "class_name": "ExtendedIllegalStateException",
                            "similarity_score": 0.35251748960922935
                        },
                        {
                            "class_name": "IFSFileOutputStreamImplRemote",
                            "similarity_score": 0.37990836754625573
                        },
                        {
                            "class_name": "IFSRandomAccessFileImplRemote",
                            "similarity_score": 0.35884888043824364
                        },
                        {
                            "class_name": "PackedDecimalFieldDescription",
                            "similarity_score": 0.368136956106892
                        },
                        {
                            "class_name": "PSSecureServerSocketContainer",
                            "similarity_score": 0.35794273016525285
                        },
                        {
                            "class_name": "RCRunCommandRequestDataStream",
                            "similarity_score": 0.27713699773684664
                        },
                        {
                            "class_name": "AS400CertificateUsrPrfUtilImpl",
                            "similarity_score": 0.22673582664105926
                        },
                        {
                            "class_name": "AS400CertificateUtilImplNative",
                            "similarity_score": 0.300004155210981
                        },
                        {
                            "class_name": "AS400CertificateUtilImplRemote",
                            "similarity_score": 0.22165325119928325
                        },
                        {
                            "class_name": "AS400FileRecordDescriptionImpl",
                            "similarity_score": 0.2493876450535206
                        },
                        {
                            "class_name": "DQExchangeAttributesDataStream",
                            "similarity_score": 0.2568347534004199
                        },
                        {
                            "class_name": "IFSTextFileInputStreamBeanInfo",
                            "similarity_score": 0.3086066999241839
                        },
                        {
                            "class_name": "PrintObjectPageInputStreamImpl",
                            "similarity_score": 0.03659267940619219
                        },
                        {
                            "class_name": "PSServerSocketContainerAdapter",
                            "similarity_score": 0.3223580875770885
                        },
                        {
                            "class_name": "RCCallProgramRequestDataStream",
                            "similarity_score": 0.3564511202795869
                        },
                        {
                            "class_name": "VariableLengthFieldDescription",
                            "similarity_score": 0.17189598467744835
                        },
                        {
                            "class_name": "AS400CertificateUserProfileUtil",
                            "similarity_score": 0.24296090933756953
                        },
                        {
                            "class_name": "AS400FileRecordDescriptionEvent",
                            "similarity_score": 0.329914439536929
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ObjectDescriptionEnumeration",
                        "AS400FileRecordDescriptionImpl",
                        "DBColumnDescriptorsDataFormat",
                        "ObjectAlreadyExistsException",
                        "IFSFileOutputStreamImplRemote",
                        "ZonedDecimalFieldDescription",
                        "PackedDecimalFieldDescription",
                        "RequestNotSupportedException",
                        "IFSRandomAccessFileImplRemote",
                        "PSSecureServerSocketContainer",
                        "RCCallProgramRequestDataStream",
                        "ExtendedIllegalStateException",
                        "RCCallProgramReplyDataStream",
                        "AS400JDBCXADataSourceBeanInfo",
                        "AS400FileRecordDescriptionEvent",
                        "PSServerSocketContainerAdapter",
                        "IFSTextFileInputStreamBeanInfo",
                        "AS400CertificateUtilImplNative",
                        "IFSRandomAccessFileImplProxy",
                        "RCRunCommandRequestDataStream",
                        "DQExchangeAttributesDataStream",
                        "IFSFileOutputStreamImplProxy",
                        "AS400CertificateUserProfileUtil",
                        "LicenseGetInformationRequest",
                        "AS400CertificateUsrPrfUtilImpl",
                        "AS400CertificateUtilImplRemote",
                        "DQRequestAttributesDataStream",
                        "VariableLengthFieldDescription",
                        "UserSpaceNativeReadWriteImpl",
                        "PrintObjectPageInputStreamImpl"
                    ],
                    "llm_response_time": 994,
                    "similarity_computation_time": 14,
                    "similarity_metric": "cosine"
                },
                "sort": {
                    "target_classes": [
                        {
                            "class_name": "IFSFileOutputStreamImplProxy",
                            "similarity_score": 0.30394792953008004
                        },
                        {
                            "class_name": "IFSRandomAccessFileImplProxy",
                            "similarity_score": 0.3296217035086506
                        },
                        {
                            "class_name": "LicenseGetInformationRequest",
                            "similarity_score": 0.3060066930374735
                        },
                        {
                            "class_name": "ObjectAlreadyExistsException",
                            "similarity_score": 0.2734000097215621
                        },
                        {
                            "class_name": "ObjectDescriptionEnumeration",
                            "similarity_score": 0.4663518835457254
                        },
                        {
                            "class_name": "RCCallProgramReplyDataStream",
                            "similarity_score": 0.4937292317704094
                        },
                        {
                            "class_name": "RequestNotSupportedException",
                            "similarity_score": 0.2423429076707135
                        },
                        {
                            "class_name": "UserSpaceNativeReadWriteImpl",
                            "similarity_score": 0.11287214122565173
                        },
                        {
                            "class_name": "ZonedDecimalFieldDescription",
                            "similarity_score": 0.4290486941732518
                        },
                        {
                            "class_name": "AS400JDBCXADataSourceBeanInfo",
                            "similarity_score": 0.3412720064001278
                        },
                        {
                            "class_name": "DBColumnDescriptorsDataFormat",
                            "similarity_score": 0.3432066197661488
                        },
                        {
                            "class_name": "DQRequestAttributesDataStream",
                            "similarity_score": 0.23299437943462017
                        },
                        {
                            "class_name": "ExtendedIllegalStateException",
                            "similarity_score": 0.27370498918578284
                        },
                        {
                            "class_name": "IFSFileOutputStreamImplRemote",
                            "similarity_score": 0.44909800338606765
                        },
                        {
                            "class_name": "IFSRandomAccessFileImplRemote",
                            "similarity_score": 0.41898285921264805
                        },
                        {
                            "class_name": "PackedDecimalFieldDescription",
                            "similarity_score": 0.42659362664179123
                        },
                        {
                            "class_name": "PSSecureServerSocketContainer",
                            "similarity_score": 0.3784680150287427
                        },
                        {
                            "class_name": "RCRunCommandRequestDataStream",
                            "similarity_score": 0.4022319289278642
                        },
                        {
                            "class_name": "AS400CertificateUsrPrfUtilImpl",
                            "similarity_score": 0.24278024225552272
                        },
                        {
                            "class_name": "AS400CertificateUtilImplNative",
                            "similarity_score": 0.2613147774168545
                        },
                        {
                            "class_name": "AS400CertificateUtilImplRemote",
                            "similarity_score": 0.6066731845420633
                        },
                        {
                            "class_name": "AS400FileRecordDescriptionImpl",
                            "similarity_score": 0.12050866206978893
                        },
                        {
                            "class_name": "DQExchangeAttributesDataStream",
                            "similarity_score": 0.24522345193217962
                        },
                        {
                            "class_name": "IFSTextFileInputStreamBeanInfo",
                            "similarity_score": 0.30907576599116143
                        },
                        {
                            "class_name": "PrintObjectPageInputStreamImpl",
                            "similarity_score": 0.0504665092278537
                        },
                        {
                            "class_name": "PSServerSocketContainerAdapter",
                            "similarity_score": 0.23124551735177443
                        },
                        {
                            "class_name": "RCCallProgramRequestDataStream",
                            "similarity_score": 0.5112193514366058
                        },
                        {
                            "class_name": "VariableLengthFieldDescription",
                            "similarity_score": 0.09852218616575632
                        },
                        {
                            "class_name": "AS400CertificateUserProfileUtil",
                            "similarity_score": 0.317905187472816
                        },
                        {
                            "class_name": "AS400FileRecordDescriptionEvent",
                            "similarity_score": 0.2888882118079359
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "AS400CertificateUtilImplRemote",
                        "AS400CertificateUtilImplNative",
                        "AS400CertificateUsrPrfUtilImpl",
                        "RCCallProgramRequestDataStream",
                        "RCCallProgramReplyDataStream",
                        "ObjectDescriptionEnumeration",
                        "IFSFileOutputStreamImplRemote",
                        "ZonedDecimalFieldDescription",
                        "PackedDecimalFieldDescription",
                        "IFSRandomAccessFileImplRemote",
                        "RCRunCommandRequestDataStream",
                        "PSSecureServerSocketContainer",
                        "DBColumnDescriptorsDataFormat",
                        "AS400JDBCXADataSourceBeanInfo",
                        "IFSRandomAccessFileImplProxy",
                        "AS400CertificateUserProfileUtil",
                        "IFSTextFileInputStreamBeanInfo",
                        "LicenseGetInformationRequest",
                        "IFSFileOutputStreamImplProxy",
                        "AS400FileRecordDescriptionEvent",
                        "ExtendedIllegalStateException",
                        "ObjectAlreadyExistsException",
                        "DQExchangeAttributesDataStream",
                        "RequestNotSupportedException",
                        "DQRequestAttributesDataStream",
                        "PSServerSocketContainerAdapter",
                        "AS400FileRecordDescriptionImpl",
                        "UserSpaceNativeReadWriteImpl",
                        "VariableLengthFieldDescription",
                        "PrintObjectPageInputStreamImpl"
                    ],
                    "llm_response_time": 1554,
                    "similarity_computation_time": 8,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.access.FileEvent::fileOpened(FileEvent):void need move com.ibm.as400.vaccess.FileEventSupport",
        "class_name": "com.ibm.as400.access.FileEvent",
        "telemetry": {
            "id": "bb8d92f2-8c0e-4c05-a4c5-c7136ea85852",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 82,
                "lineStart": 18,
                "lineEnd": 99,
                "bodyLineStart": 18,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/small/small/jtopen-7.8/src/com/ibm/as400/access/FileEvent.java",
                "sourceCode": "/**\n   The FileEvent class represents a File event.\n**/\n\npublic class FileEvent extends java.util.EventObject\n{\n  private static final String copyright = \"Copyright (C) 1997-2000 International Business Machines Corporation and others.\";\n\n\n\n    static final long serialVersionUID = 4L;\n\n\n\n  /**\n   The file closed event ID.  This event is delivered when a file is closed.\n   **/\n  public static final int FILE_CLOSED = 0;\n\n  /**\n   The file deleted event ID.  This event is delivered when a file is deleted.\n   **/\n  public static final int FILE_DELETED = 1;\n\n  /**\n   The file modified event ID.  This event is delivered when a file is modified.\n   **/\n  public static final int FILE_MODIFIED = 2;\n\n  /**\n   The file opened event ID.  This event is delivered when a file is opened.\n   **/\n  public static final int FILE_OPENED = 3;\n\n  /**\n   The file created event ID.  This event is delivered when a file is created.\n   **/\n  public static final int FILE_CREATED = 4;\n\n\n  private int id_; // event identifier\n\n\n  /**\n   Constructs a FileEvent object. It uses the specified source and ID.\n   @param source The object where the event originated.\n   @param id The event identifier.\n   **/\n  public FileEvent(Object source,\n                   int    id)\n  {\n    super(source);\n\n    if (id < FILE_CLOSED || id > FILE_CREATED)\n    {\n      throw new ExtendedIllegalArgumentException(\"id\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n    }\n\n    id_ = id;\n  }\n\n  \n  /**\n   Returns the identifier for this event.\n   @return The identifier for this event.\n   **/\n  public int getID()\n  {\n    return id_;\n  }\n\n\n/**\nProcesses a file open event.\n\n@param fileEventSupport TODO\n**/\n    public void fileOpened (FileEventSupport fileEventSupport)\n    {\n         fileEventSupport.fireFileOpened ();\n    }\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 89,
                        "lineEnd": 97,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method fileOpened to class FileEventSupport",
                        "description": "Move method to com.ibm.as400.vaccess.FileEventSupport\nRationale: The method fileOpened directly interacts with the FileEventSupport instance to fire the file opened event, making it more appropriate for this method to reside within the FileEventSupport class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 5794
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "fileOpened",
                            "method_signature": "public void fileOpened(FileEventSupport fileEventSupport)",
                            "target_class": "FileEventSupport",
                            "rationale": "The fileOpened() method is responsible for processing a file open event and directly interacts with the FileEventSupport class. It should be moved to the FileEventSupport class to adhere to the Single Responsibility Principle."
                        }
                    ],
                    "llm_response_time": 1108
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "fileOpened",
                            "method_signature": "public void fileOpened(FileEventSupport fileEventSupport)",
                            "target_class": "FileEventSupport",
                            "rationale": "The fileOpened method is responsible for processing a file open event, which is more related to the behavior of the FileEventSupport class. Moving it there would adhere to the Single Responsibility Principle."
                        }
                    ],
                    "llm_response_time": 1023
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "fileOpened",
                            "method_signature": "public void fileOpened(FileEventSupport fileEventSupport)",
                            "target_class": "FileEventSupport",
                            "rationale": "The fileOpened() method is responsible for processing a file open event, which is more related to the behavior of the FileEventSupport class. Moving it there would adhere to the Single Responsibility Principle."
                        }
                    ],
                    "llm_response_time": 1003
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "fileOpened",
                            "method_signature": "public void fileOpened(FileEventSupport fileEventSupport)",
                            "target_class": "FileEventSupport",
                            "rationale": "The fileOpened() method is responsible for processing a file open event and directly interacts with the FileEventSupport class. It should be moved to the FileEventSupport class to adhere to the Single Responsibility Principle."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "fileOpened"
                ],
                "llm_response_time": 2594
            },
            "targetClassMap": {
                "fileOpened": {
                    "target_classes": [
                        {
                            "class_name": "FileEventSupport",
                            "similarity_score": 0.6383401194118878
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "FileEventSupport"
                    ],
                    "llm_response_time": 833,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.access.RecordFormat::setColumnLabel(int, String):void need move com.ibm.as400.util.servlet.RecordFormatMetaData",
        "class_name": "com.ibm.as400.access.RecordFormat",
        "telemetry": {
            "id": "728e45c8-d785-4d72-bc72-d4728c57de31",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1084,
                "lineStart": 34,
                "lineEnd": 1117,
                "bodyLineStart": 34,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/small/small/jtopen-7.8/src/com/ibm/as400/access/RecordFormat.java",
                "sourceCode": "/**\n *The RecordFormat class represents the format of data returned from an IBM i system.\n *It contains FieldDescription objects that describe the\n *data returned from a system.  The RecordFormat class is used to generate a Record\n *object that can be used to access the data returned from the system as Java objects or\n *as byte arrays of IBM i data.\n *For instance, the entries on a data queue\n *may have a specific format.  This format could be represented by a\n *RecordFormat object. The RecordFormat object could be used to generate a Record\n *object containing the data read from the data queue.  Based on the description of the\n *data contained in the RecordFormat object, the Record object could be used by the Java\n *program to handle the data as Java objects. As another example, a parameter for a program\n *may be\n *an array of bytes representing several different types of data.  Such a parameter\n *could be described by a RecordFormat object.\n *<p>\n *The RecordFormat class is also used to describe the record format of a file when using\n *the record-level database access classes.  The record format of the file must be set prior\n *to invoking the open() method on an AS400File object.\n *<p>\n *The RecordFormat class is also used to describe the record format of a record when using\n *the LineDataRecordWriter class.  The following record format attributes are required to be\n *set.\n *<ul>\n *<li>Record format ID\n *<li>Record format type\n *<li>Field descriptions that make up the record format\n *<li>The delimiter, when the record format type is VARIABLE_LAYOUT_LENGTH\n *<li>Field description layout attributes,length and alignment, when the record format\n *is FIXED_LAYOUT_LENGTH\n *</ul>\n *<p>\n *The RecordFormat class allows the user to do the following:\n *<ul>\n *<li>Describe the data returned from a system.\n *<li>Retrieve a Record object containing data that is described by the RecordFormat.\n *</ul>\n *RecordFormat objects generate the following events:\n *<ul>\n *<li>{@link com.ibm.as400.access.RecordDescriptionEvent RecordDescriptionEvent}\n *<br>The events fired are:\n *<ul>\n *<li>fieldDescriptionAdded()\n *<li>keyFieldDescriptionAdded()\n *</ul>\n *<li>PropertyChangeEvent\n *<li>VetoableChangeEvent\n *</ul>\n *<b>Examples</b>\n *<ul>\n *<li><a href=\"doc-files/recordxmp.html\">Using the RecordFormat class with the Data queue classes</a>\n *<li><a href=\"doc-files/RLReadFileExample.html\">Using the RecordFormat class with the record-level database access classes</a>\n *<li><a href=\"doc-files/LDRWExample.html\">Using the RecordFormat class with the LineDataRecordWriter class</a>\n *</ul>\n *@see AS400FileRecordDescription\n**/\npublic class RecordFormat implements Serializable\n{\n    static final long serialVersionUID = 4L;\n\n\n  /** Constant indicating the layout length of all fields is fixed. **/ // @C1A\n  /** This constant is only used for record level writing.          **/ // @C1A\n  public static final int FIXED_LAYOUT_LENGTH    = 1;       // @C1A\n  /** Constant indicating the layout length of all fields is variable. **/ //@C1A\n  /** This constant is only used for record level writing.          **/ // @C1A\n  public static final int VARIABLE_LAYOUT_LENGTH = 2;       // @C1A\n  // The delimiter used for printing variable length field records  @C1A\n  private char delimiter_;   // @C1A\n\n  // The fieldDescriptions that make up this record format.\n  private Vector fieldDescriptions_ = new Vector();\n  // Hashtable mapping the field names to their index in fieldDescriptions_\n  private Hashtable fieldNameToIndexMap_ = new Hashtable();\n  // Indicates if this format contains dependent fields\n  private boolean hasDependentFields_;\n  // The keyFieldDescriptions that make up this record format.\n  private Vector keyFieldDescriptions_ = new Vector();\n  // Hashtable mapping the key field names to their index in keyFieldDescriptions_\n  private Hashtable keyFieldNameToIndexMap_ = new Hashtable();\n  // Contains the index of the field depended on for length by the field description specified by the\n  // the index into this Vector.\n  private Vector lengthDependentFields_ = new Vector();\n  // Name of this record format\n  private String name_ = \"\";\n  // Constant used to indicate that a field is not a dependent field\n  private static final Integer NOT_DEPENDENT_ = new Integer(-1);\n  // Contains the index of the field depended on for offset by the field description specified by the\n  // the index into this Vector.\n  private Vector offsetDependentFields_ = new Vector();\n  // The record format type   @C1A\n  private int recordFormatType_;  // @C1A\n  // The record format ID     @C1A\n  private String recordFormatID_ = \"\";             // @C1A\n\n  // Transient data.\n  transient private PropertyChangeSupport changes_; //@B0C\n//@B0D  transient private Vector currentVetoListeners_ = new Vector(); //@B0C\n//@B0D  transient private Vector currentRecordDescriptionListeners_ = new Vector(); //@B0C\n  transient private Vector rdListeners_; //@B0C\n  transient private VetoableChangeSupport vetos_; //@B0C\n\n  /**\n   *Constructs a RecordFormat object.<br>\n   *<b>Note:</b> When using this object with the record level access classes,\n   *the version of the constructor that takes <i>name</i> must be used.\n   *@see RecordFormat#RecordFormat(java.lang.String)\n  **/\n  public RecordFormat()\n  {\n    initializeTransient(); //@B0A\n  }\n\n  /**\n   *Constructs a RecordFormat object. It uses the name specified.<br>\n   *<b>Note:</b> Use this version of the constructor when the object is\n   *being used with the record level access classes.\n   *@param name The name of the record format.  The <i>name</i> is converted\n   *to uppercase by this method.  When using this object with the record level\n   *access classes, the <i>name</i> must be the name of the record format for\n   *the file that is being described.\n  **/\n  public RecordFormat(String name)\n  {\n    if (name == null)\n    {\n      throw new NullPointerException(\"name\");\n    }\n    name_ = name.toUpperCase();\n    initializeTransient(); //@B0A\n  }\n\n  /**\n   *Adds a field description to this record format.  The field description\n   *is added to the end of the field descriptions in this object.\n   *@param field The field description to be added.\n  **/\n  public void addFieldDescription(FieldDescription field)\n  {\n    if (field == null)\n    {\n      throw new NullPointerException(\"field\");\n    }\n    // Map the name to the appropriate index\n    fieldNameToIndexMap_.put(field.getFieldName(), new Integer(fieldDescriptions_.size()));\n    // Add the field to the field descriptions\n    fieldDescriptions_.addElement(field);\n    // Indicate that this field is not a dependent field\n    lengthDependentFields_.addElement(NOT_DEPENDENT_);\n    // Indicate that this field is not a dependent field\n    offsetDependentFields_.addElement(NOT_DEPENDENT_);\n\n    // Fire FIELD_DESCRIPTION_ADDED event\n    //@B0D - removed event firing code block\n    fireEvent(RecordDescriptionEvent.FIELD_DESCRIPTION_ADDED); //@B0A\n  }\n\n  /**\n   *Adds a key field description to this record format.\n   *The key field description is determined by the index of a field description\n   *that was already added to this object. The key field description\n   *is added to the end of the key field descriptions in this object.\n   *The order in which the key field descriptions are added must match\n   *the order of the key fields in the files for which this record format\n   *is meant.\n   *@param index The index of a field description that was already\n   *added to this object via addFieldDescription().  The <i>index</i> must\n   *be in the range zero to getNumberOfFields() - 1.\n  **/\n  public void addKeyFieldDescription(int index)\n  {\n    if (index < 0 || index > fieldDescriptions_.size() - 1)\n    {\n      throw new ExtendedIllegalArgumentException(\"index\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n    }\n    FieldDescription f = (FieldDescription)fieldDescriptions_.elementAt(index);\n    // Map the name to the appropriate index\n    keyFieldNameToIndexMap_.put(f.getFieldName(), new Integer(keyFieldDescriptions_.size()));\n    // Add the field to the key field descriptions\n    keyFieldDescriptions_.addElement(f);\n\n    // Fire KEY_FIELD_DESCRIPTION_ADDED event\n    //@B0D - removed event firing code block\n    fireEvent(RecordDescriptionEvent.KEY_FIELD_DESCRIPTION_ADDED); //@B0A\n  }\n\n\n  /**\n   *Adds a key field description to this record format.\n   *The key field description is determined by the name of a field description\n   *that was already added to this object. The key field description\n   *is added to the end of the key field descriptions in this object.\n   *The order in which the key field descriptions are added must match\n   *the order of the key fields in the files for which this record format\n   *is meant.\n   *@param name The name of a field description that was already\n   *added to this object via addFieldDescription().  The <i>name</i> is\n   *case sensitive.\n  **/\n  public void addKeyFieldDescription(String name)\n  {\n    if (name == null)\n    {\n      throw new NullPointerException(\"name\");\n    }\n    // Do not add this key if the key is *NONE\n    if (!(name.equals(\"*NONE\")))                       //@A1A \n    {\n      // Key(s) of *NONE are just place holders for DB code for multi-format\n      // logical files.  Key(s) of *NONE allows DB to build a search index  \n      // for a multi-format logical file.  The toolbox code does not use the\n      // *NONE key(s) in any way.\n      addKeyFieldDescription(getIndexOfFieldName(name));\n    }\n  }\n\n  /**\n   *Adds a listener to be notified when the value of any bound\n   *property is changed.  The <b>propertyChange</b> method will be\n   *called.\n   *@see #removePropertyChangeListener\n   *@param listener The PropertyChangeListener.\n  **/\n  public /*@B0D synchronized*/ void addPropertyChangeListener(PropertyChangeListener listener)\n  {\n    if (listener == null)\n    {\n      throw new NullPointerException(\"listener\");\n    }\n    if (changes_ == null) changes_ = new PropertyChangeSupport(this);\n    changes_.addPropertyChangeListener(listener);\n  }\n\n  /**\n   *Adds a listener to be notified when a RecordDescriptionEvent is fired.\n   *@see #removeRecordDescriptionListener\n   *@param listener The RecordDescriptionListener.\n  **/\n  public /*@B0D synchronized*/ void addRecordDescriptionListener(RecordDescriptionListener listener)\n  {\n    if (listener == null)\n    {\n      throw new NullPointerException(\"listener\");\n    }\n    if (rdListeners_ == null) rdListeners_ = new Vector();\n    rdListeners_.addElement(listener); //@B0C\n//@B0D    currentRecordDescriptionListeners_ = (Vector)recordDescriptionListeners_.clone();\n  }\n\n  /**\n   *Adds a listener to be notified when the value of any constrained\n   *property is changed.\n   *The <b>vetoableChange</b> method will be called.\n   *@see #removeVetoableChangeListener\n   *@param listener The VetoableChangeListener.\n  **/\n  public /*@B0D synchronized*/ void addVetoableChangeListener(VetoableChangeListener listener)\n  {\n    if (listener == null)\n    {\n      throw new NullPointerException(\"listener\");\n    }\n    if (vetos_ == null) vetos_ = new VetoableChangeSupport(this);\n    vetos_.addVetoableChangeListener(listener); //@B0C\n//@B0D    currentVetoListeners_ = (Vector)vetoListeners_.clone();\n  }\n\n\n  //@B0A\n  /**\n   * Fire the appropriate event.\n  **/\n  private void fireEvent(int index)\n  {\n    if (rdListeners_ == null) return;\n    Vector targets = (Vector)rdListeners_.clone();\n    RecordDescriptionEvent event = new RecordDescriptionEvent(this, index);\n    for (int i=0; i<targets.size(); ++i)\n    {\n      RecordDescriptionListener target = (RecordDescriptionListener)targets.elementAt(i);\n      switch(index)\n      {\n        case RecordDescriptionEvent.FIELD_DESCRIPTION_ADDED:\n          target.fieldDescriptionAdded(event);\n          break;\n        case RecordDescriptionEvent.KEY_FIELD_DESCRIPTION_ADDED:\n          target.keyFieldDescriptionAdded(event);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  //@C1A\n  /**\n   * Returns the delimiter.  The delimiter is the character\n   * used to separate variable length fields when the record is\n   * written using the line data record writer class.  This value is only\n   * valid when the record format type is VARIABLE_LAYOUT_LENGTH.\n   *\n   * @return  The delimiter.\n  **/\n  public char getDelimiter()\n  {\n    return delimiter_;\n  }\n\n\n  /**\n   *Returns the field description at the specified index.\n   *@param index The index of the field description.  The <i>index</i> must\n   *be in the range zero to getNumberOfFields() - 1.\n   *@return The field description.\n  **/\n  public FieldDescription getFieldDescription(int index)\n  {\n    if (index < 0 || index > fieldDescriptions_.size() - 1)\n    {\n      throw new ExtendedIllegalArgumentException(\"index\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n    }\n    return (FieldDescription)fieldDescriptions_.elementAt(index);\n  }\n\n  /**\n   *Returns the field description with the specified name.\n   *@param name The name of the field description.  The <i>name</i> is\n   *case sensitive.\n   *@return The field description.\n  **/\n  public FieldDescription getFieldDescription(String name)\n  {\n    return (FieldDescription)fieldDescriptions_.elementAt(getIndexOfFieldName(name));\n  }\n\n  /**\n   *Returns the field descriptions that make up this object.\n   *@return The field descriptions.  An array of size zero is returned if no\n   *fields have been added to this object.\n  **/\n  public FieldDescription[] getFieldDescriptions()\n  {\n    FieldDescription[] fds = new FieldDescription[fieldDescriptions_.size()];\n    fieldDescriptions_.copyInto(fds);\n    return fds;\n  }\n\n  /**\n   *Returns the names of the field descriptions that make up this record format.\n   *@return The names of the field descriptions.  An array of size zero is\n   *returned if no fields have been added to this object.\n  **/\n  public String[] getFieldNames()\n  {\n    int size = fieldDescriptions_.size();\n    String[] names = new String[size];\n    for (int i = 0; i < size; ++i)\n    {\n      names[i] = ((FieldDescription)fieldDescriptions_.elementAt(i)).getFieldName();\n    }\n    return names;\n  }\n\n  /**\n   *Indicates if this record format contains dependent fields.\n   *@return true if this record format contains dependent fields; false otherwise\n  **/\n  boolean getHasDependentFields()\n  {\n    return hasDependentFields_;\n  }\n\n  /**\n   *Returns the index of the field description named <i>name</i>.\n   *@param name The name of the field description.  The <i>name</i>\n   *is case sensitive.\n   *@return The index of the field description.\n  **/\n  public int getIndexOfFieldName(String name)\n  {\n    if (name == null)\n    {\n      throw new NullPointerException(\"name\");\n    }\n    Integer i = (Integer)fieldNameToIndexMap_.get(name);\n    if (i == null)\n    {\n      throw new ExtendedIllegalArgumentException(\"name (\" + name + \")\", ExtendedIllegalArgumentException.FIELD_NOT_FOUND);\n    }\n    return i.intValue();\n  }\n\n  /**\n   *Returns the index of the field description of the key field named <i>name</i>.\n   *@param name The name of the key field description.  The <i>name</i> is\n   *case sensitive.\n   *@return The index of the key field description.  This is the index of the key field description\n   *in the key field descriptions for this object.  It is not the index of the field description in the\n   *field descriptions for this object.\n  **/\n  public int getIndexOfKeyFieldName(String name)\n  {\n    if (name == null)\n    {\n      throw new NullPointerException(\"name\");\n    }\n    Integer i = (Integer)keyFieldNameToIndexMap_.get(name);\n    if (i == null)\n    {\n      throw new ExtendedIllegalArgumentException(\"name (\" + name + \")\", ExtendedIllegalArgumentException.FIELD_NOT_FOUND);\n    }\n    return i.intValue();\n  }\n\n  /**\n   *Returns the field description of the key field at the specified index.\n   *@param index The index of the key field description in the key field descriptions for this object.\n   *@return The key field description.\n  **/\n  public FieldDescription getKeyFieldDescription(int index)\n  {\n    if (index < 0 || index > fieldDescriptions_.size() - 1)\n    {\n      throw new ExtendedIllegalArgumentException(\"index\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n    }\n    return (FieldDescription)keyFieldDescriptions_.elementAt(index);\n  }\n\n  /**\n   *Returns the field description of the key field with the specified name.\n   *@param name The name of the key field description.  The <i>name</i> is\n   *case sensitive.\n   *@return The key field description.\n  **/\n  public FieldDescription getKeyFieldDescription(String name)\n  {\n    if (name == null)\n    {\n      throw new NullPointerException(\"name\");\n    }\n    return (FieldDescription)keyFieldDescriptions_.elementAt(getIndexOfKeyFieldName(name));\n  }\n\n  /**\n   *Returns the key field descriptions that make up this object.\n   *@return The key field descriptions.\n  **/\n  public FieldDescription[] getKeyFieldDescriptions()\n  {\n    FieldDescription[] fds = new FieldDescription[keyFieldDescriptions_.size()];\n    keyFieldDescriptions_.copyInto(fds);\n    return fds;\n  }\n\n  /**\n   *Returns the names of the field descriptions of the keys that make up this record format.\n   *@return The names of the key field descriptions.  If no key field descriptions exist,\n   *an array of size 0 is returned.\n  **/\n  public String[] getKeyFieldNames()\n  {\n    int size = keyFieldDescriptions_.size();\n    String[] names = new String[size];\n    for (int i = 0; i < size; ++i)\n    {\n      names[i] = ((FieldDescription)keyFieldDescriptions_.elementAt(i)).getFieldName();\n    }\n    return names;\n  }\n\n  /**\n   *Returns the index of the field description on which the field description at the specified\n   *index depends.\n   *@param index The index of the field description.  The <i>index</i> must be in the range 0 to\n   *getNumberOfFields() - 1.\n   *@return The index of the field description on which the field description at the specified\n   *index depends.\n   *If <i>index</i> is not the index of a dependent field, -1 is returned.\n  **/\n  public int getLengthDependency(int index)\n  {\n    if (index < 0 || index > fieldDescriptions_.size() - 1)\n    {\n      throw new ExtendedIllegalArgumentException(\"index\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n    }\n    return  ((Integer)lengthDependentFields_.elementAt(index)).intValue();\n  }\n\n  /**\n   *Returns the index of the field description on which the field description with the specified\n   *name depends.\n   *@param name The name of the field description.  The <i>name</i> is\n   *case sensitive.\n   *@return The index of the field description on which the field description with the specified\n   *name depends.\n   *If <i>name</i> is not the name of a dependent field, -1 is returned.\n  **/\n  public int getLengthDependency(String name)\n  {\n    if (name == null)\n    {\n      throw new NullPointerException(\"name\");\n    }\n    return ((Integer)lengthDependentFields_.elementAt(getIndexOfFieldName(name))).intValue();\n  }\n\n  /**\n   *Returns the name of this record format.\n   *@return The name of this record format.  If the name has not been\n   *set, an empty string is returned.\n  **/\n  public String getName()\n  {\n    return name_;\n  }\n\n  /**\n   *Returns a new record based on this record format, which contains default values for the\n   *contents of the fields.  The default values are determined as follows:\n   *<ol>\n   *<li>Use the value specified for the DFT keyword on the field description object for\n   *a particular field.\n   *<li>If no value was specified for the DFT keyword, use the default value from the\n   *AS400DataType object specified when constructing the field description object for\n   *a particular field.\n   *</ol>\n   *@return A record based on this record format.  If no field descriptions have been\n   *added to this object, null is returned.\n  **/\n  public Record getNewRecord()\n  {\n    if (fieldDescriptions_.size() == 0)\n    {\n      return null;\n    }\n    return new Record(this);\n  }\n\n  /**\n   *Returns a new record based on this record format, which contains default values for the\n   *contents of the fields.  The default values are determined as follows:\n   *<ol>\n   *<li>Use the value specified for the DFT keyword on the field description object for\n   *a particular field.\n   *<li>If no value was specified for the DFT keyword, use the default value from the\n   *AS400DataType object specified when constructing the field description object for\n   *a particular field.\n   *</ol>\n   *@param recordName The name to assign to the Record object being returned.\n   *@return A record based on this record format.\n   *If no field descriptions have been added to this object, null is returned.\n  **/\n  public Record getNewRecord(String recordName)\n  {\n    if (recordName == null)\n    {\n      throw new NullPointerException(\"recordName\");\n    }\n    if (fieldDescriptions_.size() == 0)\n    {\n      return null;\n    }\n    return new Record(this, recordName);\n  }\n\n  /**\n   *Returns a new record based on this record format, which contains data from\n   *the specified byte array.\n   *@param contents The data with which to initialize the contents of the record.\n   *The length of <i>contents</i> must be greater than zero.\n   *@return A record based on this record format.\n   *If no field descriptions have been added to this object, null is returned.\n   *@exception UnsupportedEncodingException If an error occurs during conversion.\n  **/\n  public Record getNewRecord(byte[] contents)\n    throws UnsupportedEncodingException\n  {\n    return getNewRecord(contents, 0);\n  }\n\n  /**\n   *Returns a new record based on this record format, which contains data from\n   *the specified byte array.\n   *@param contents The data with which to initialize the contents of the record.\n   *The length of <i>contents</i> must be greater than zero.\n   *@param recordName The name to assign to the Record object being returned.\n   *@return A record based on this record format.\n   *If no field descriptions have been added to this object, null is returned.\n   *@exception UnsupportedEncodingException If an error occurs during conversion.\n  **/\n  public Record getNewRecord(byte[] contents, String recordName)\n    throws UnsupportedEncodingException\n  {\n    return getNewRecord(contents, 0, recordName);\n  }\n\n  /**\n   *Returns a new record based on this record format, which contains data from\n   *the specified byte array.\n   *@param contents The data with which to initialize the contents of the record.\n   *The length of <i>contents</i> must be greater than zero.\n   *@param offset The offset in <i>contents</i> at which to start.  The <i>offset</i>\n   *cannot be less than zero.\n   *@return A record based on this record format.\n   *If no field descriptions have been added to this object, null is returned.\n   *@exception UnsupportedEncodingException If an error occurs during conversion.\n  **/\n  public Record getNewRecord(byte[] contents, int offset)\n    throws UnsupportedEncodingException\n  {\n    if (contents == null)\n    {\n      throw new NullPointerException(\"contents\");\n    }\n    if (contents.length == 0)\n    {\n      throw new ExtendedIllegalArgumentException(\"contents\", ExtendedIllegalArgumentException.LENGTH_NOT_VALID);\n    }\n    if (offset < 0)\n    {\n      throw new ExtendedIllegalArgumentException(\"offset\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n    }\n    if (fieldDescriptions_.size() == 0)\n    {\n      return null;\n    }\n    return new Record(this, contents, offset);\n  }\n\n  /**\n   *Returns a new record based on this record format, which contains data from\n   *the specified byte array.\n   *@param contents The data with which to initialize the contents of the record.\n   *The length of <i>contents</i> must be greater than zero.\n   *@param offset The offset in <i>contents</i> at which to start.  The <i>offset</i>\n   *cannot be less than zero.\n   *@param recordName The name to assign to the Record object being returned.\n   *@return A record based on this record format.\n   *If no field descriptions have been added to this object, null is returned.\n   *@exception UnsupportedEncodingException If an error occurs during conversion.\n  **/\n  public Record getNewRecord(byte[] contents, int offset, String recordName)\n    throws UnsupportedEncodingException\n  {\n    if (contents == null)\n    {\n      throw new NullPointerException(\"contents\");\n    }\n    if (contents.length == 0)\n    {\n      throw new ExtendedIllegalArgumentException(\"contents\", ExtendedIllegalArgumentException.LENGTH_NOT_VALID);\n    }\n    if (offset < 0)\n    {\n      throw new ExtendedIllegalArgumentException(\"offset\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n    }\n    if (recordName == null)\n    {\n      throw new NullPointerException(\"recordName\");\n    }\n    if (fieldDescriptions_.size() == 0)\n    {\n      return null;\n    }\n    return new Record(this, contents, offset, recordName);\n  }\n\n  /**\n   *Returns the number of field descriptions in this record format.\n   *@return The number of field descriptions in this record format.\n  **/\n  public int getNumberOfFields()\n  {\n    return fieldDescriptions_.size();\n  }\n\n  /**\n   *Returns the number of key field descriptions in this record format.\n   *@return The number of key field descriptions in this record format.\n  **/\n  public int getNumberOfKeyFields()\n  {\n    return keyFieldDescriptions_.size();\n  }\n\n  /**\n   *Returns the index of the field description on which the field description at the specified\n   *index depends.\n   *@param index The index of the field description.  The <i>index</i> must be in the range 0 to\n   *getNumberOfFields() - 1.\n   *@return The index of the field description on which the field description at the specified\n   *index depends.\n   *If <i>index</i> is not the index of a dependent field, -1 is returned.\n  **/\n  public int getOffsetDependency(int index)\n  {\n    if (index < 0 || index > fieldDescriptions_.size() - 1)\n    {\n      throw new ExtendedIllegalArgumentException(\"index\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n    }\n    return  ((Integer)offsetDependentFields_.elementAt(index)).intValue();\n  }\n\n  /**\n   *Returns the index of the field description on which the field description with the specified\n   *name depends.\n   *@param name The name of the field description.  The <i>name</i> is\n   *case sensitive.\n   *@return The index of the field description on which the field description with the specified\n   *name depends.\n   *If <i>name</i> is not the name of a dependent field, -1 is returned.\n  **/\n  public int getOffsetDependency(String name)\n  {\n    if (name == null)\n    {\n      throw new NullPointerException(\"name\");\n    }\n    return ((Integer)offsetDependentFields_.elementAt(getIndexOfFieldName(name))).intValue();\n  }\n\n  // @C1A - added method\n /**\n   * Returns the record format ID.\n   * The record format ID corresponds to a record format ID within a page definition\n   * defined on the system.\n   *\n   * @return  The record format ID.\n  **/\n  public String getRecordFormatID()\n  {\n    return recordFormatID_;\n  }\n\n  // @C1A - added method\n  /**\n   * Returns the record format type.\n   *\n   * @return  The record format type.\n  **/\n  public int getRecordFormatType()\n  {\n    return recordFormatType_;\n  }\n\n  //@D0A\n  /**\n   * This should be called by any class that is running proxified and retrieves\n   * a RecordFormat from the System i side.\n  **/\n  void initializeTextObjects(AS400 system)\n  {\n    //@D0A - need to finish filling in the AS400Text objects\n    // now that we're back on the client\n    for (int i=0; i<fieldDescriptions_.size(); ++i)\n    {\n      AS400DataType dt = ((FieldDescription)fieldDescriptions_.elementAt(i)).dataType_;\n//      if (dt instanceof AS400Text)\n      if (dt.getInstanceType() == AS400DataType.TYPE_TEXT)\n      {\n        ((AS400Text)dt).setConverter(system);\n      }\n    }\n  }\n\n\n\n  //@B0A\n  /**\n   * Initialize transient data.\n  **/\n  private void initializeTransient()\n  {\n//    rdListeners_ = new Vector();\n//    vetos_ = new VetoableChangeSupport(this);\n//    changes_ = new PropertyChangeSupport(this);\n  }\n\n\n  /**\n   *Overrides the ObjectInputStream.readObject() method in order to return any\n   *transient parts of the object to there properly initialized state.\n   * I.e we in effect\n   *call the null constructor.  By calling ObjectInputStream.defaultReadObject()\n   *we restore the state of any non-static and non-transient variables.  We\n   *then continue on to restore the state (as necessary) of the remaining varaibles.\n   *@param in The input stream from which to deserialize the object.\n   *@exception ClassNotFoundException If the class being deserialized is not found.\n   *@exception IOException If an error occurs during deserialization.\n  **/\n\n  private void readObject(java.io.ObjectInputStream in)\n    throws ClassNotFoundException,\n           IOException\n  {\n    in.defaultReadObject();\n    initializeTransient(); //@B0A\n  }\n\n  /**\n   *Removes a listener from the change list.\n   *If the listener is not on the list, do nothing.\n   *@see #addPropertyChangeListener\n   *@param listener The PropertyChangeListener.\n  **/\n  public /*@B0D synchronized*/ void removePropertyChangeListener(PropertyChangeListener listener)\n  {\n    if (listener == null)\n    {\n      throw new NullPointerException(\"listener\");\n    }\n    if (changes_ != null) changes_.removePropertyChangeListener(listener);\n  }\n\n  /**\n   *Removes a listener from the  record description listeners list.\n   *If the listener is not on the list, do nothing.\n   *@see #addRecordDescriptionListener\n   *@param listener The RecordDescriptionListener.\n  **/\n  public /*@B0D synchronized*/ void removeRecordDescriptionListener(RecordDescriptionListener listener)\n  {\n    if (listener == null)\n    {\n      throw new NullPointerException(\"listener\");\n    }\n    if (rdListeners_ != null) rdListeners_.removeElement(listener); //@B0C\n//@B0D    currentRecordDescriptionListeners_ = (Vector)recordDescriptionListeners_.clone();\n  }\n\n  /**\n   *Removes a listener from the veto change listeners list.\n   *If the listener is not on the list, do nothing.\n   *@see #addVetoableChangeListener\n   *@param listener The VetoableChangeListener.\n  **/\n  public /*@B0D synchronized*/ void removeVetoableChangeListener(VetoableChangeListener listener)\n  {\n    if (listener == null)\n    {\n      throw new NullPointerException(\"listener\");\n    }\n    if (vetos_ != null) vetos_.removeVetoableChangeListener(listener); //@B0C\n//@B0D    currentVetoListeners_ = (Vector)vetoListeners_.clone();\n  }\n\n  //@D0A\n  /**\n   * This should be called by any class that is running on the proxy server and retrieves\n   * a RecordFormat from the client side.\n  **/\n//@E0: This function has been moved to AS400FileImplBase.\n/*@E0D  void setConverter(ConverterImpl conv)\n  {\n    //@D0A - need to finish filling in the AS400Text objects\n    // now that we're back on the client\n    for (int i=0; i<fieldDescriptions_.size(); ++i)\n    {\n      AS400DataType dt = ((FieldDescription)fieldDescriptions_.elementAt(i)).dataType_;\n      if (dt instanceof AS400Text)\n      {\n        ((AS400Text)dt).setConverter(conv);\n      }\n    }\n  }\n*/\n\n  // @C1A - added method\n  /**\n   * Sets the delimiter.  The delimiter is the character\n   * used to separate variable length fields when the record is\n   * written using the line data record writer class.  This value is only\n   * valid when the record format type is VARIABLE_LAYOUT_LENGTH.\n   *\n   * @param delimiter The delimiter.\n  **/\n  public void setDelimiter(char delimiter)\n  {\n    delimiter_ = delimiter;\n  }\n\n\n  /**\n   *Sets the field on which a dependent field depends.  Both fields must have been added already\n   *to this RecordFormat.  The <i>fieldDependedOn</i> must have been added prior to adding the\n   *<i>dependentField</i>.\n   *@param dependentField The index of the dependent field.  The\n   *<i>dependentField</i> must be in the range 1 to getNumberOfFields() - 1.\n   *@param fieldDependedOn The index of a field on which this field depends.  The <i>fieldDependedOn</i> must\n   *be in the range 0 to <i>dependentField</i>.\n  **/\n  public void setLengthDependency(int dependentField, int fieldDependedOn)\n  {\n    if (dependentField < 0)\n    {\n      throw new ExtendedIllegalArgumentException(\"dependentField\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n    }\n    if (dependentField > fieldDescriptions_.size() - 1)\n    {\n      throw new ExtendedIllegalArgumentException(\"dependentField\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n    }\n    if (fieldDependedOn < 0)\n    {\n      throw new ExtendedIllegalArgumentException(\"fieldDependedOn\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n    }\n    if (dependentField > fieldDescriptions_.size() - 1)\n    {\n      throw new ExtendedIllegalArgumentException(\"dependentField\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n    }\n    if (fieldDependedOn >= dependentField)\n    {\n      throw new ExtendedIllegalArgumentException(\"fieldDependedOn\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n    }\n    lengthDependentFields_.setElementAt(new Integer(fieldDependedOn), dependentField);\n    hasDependentFields_ = true;\n  }\n\n  /**\n   *Sets the field on which a dependent field depends.  Both fields must have been added already\n   *to this RecordFormat.  The <i>fieldDependedOn</i> must have been added prior to adding the\n   *<i>dependentField</i>.  The names of the fields are\n   *case sensitive.\n   *@param dependentField The name of the dependent field.\n   *@param fieldDependedOn The name of a field on which this field depends.  The index of\n   *<i>fieldDependedOn</i> in this RecordFormat must be less than the index of <i>dependentField</i>.\n  **/\n  public void setLengthDependency(String dependentField, String fieldDependedOn)\n  {\n    if (dependentField == null)\n    {\n      throw new NullPointerException(\"dependentField\");\n    }\n    if (fieldDependedOn == null)\n    {\n      throw new NullPointerException(\"fieldDependedOn\");\n    }\n    int depOnIndex = getIndexOfFieldName(fieldDependedOn);\n    int depIndex = getIndexOfFieldName(dependentField);\n    setLengthDependency(depIndex, depOnIndex);\n  }\n\n  /**\n   *Sets the name of this record format.\n   *@param name The name of this record format.\n   *The <i>name</i> is converted to uppercase by this method.\n   *@exception PropertyVetoException If a change is vetoed.\n  **/\n  public void setName(String name)\n    throws PropertyVetoException\n  {\n    if (name == null)\n    {\n      throw new NullPointerException(\"name\");\n    }\n\n    //@B0D: removed old veto-listener code block\n\n    String old = name_;\n    if (vetos_ != null) vetos_.fireVetoableChange(\"name\", old, name.toUpperCase()); //@B0A\n    name_ = name.toUpperCase();\n    if (changes_ != null) changes_.firePropertyChange(\"name\", old, name_);\n  }\n\n  /**\n   *Sets the field on which a dependent field depends.  Both fields must have been added already\n   *to this RecordFormat.  The <i>fieldDependedOn</i> must have been added prior to adding the\n   *<i>dependentField</i>.\n   *@param dependentField The index of the dependent field.  The\n   *<i>dependentField</i> must be in the range 1 to getNumberOfFields() - 1.\n   *@param fieldDependedOn The index of a field on which this field depends.  The <i>fieldDependedOn</i> must\n   *be in the range 0 to <i>dependentField</i>.\n  **/\n  public void setOffsetDependency(int dependentField, int fieldDependedOn)\n  {\n    if (dependentField < 0)\n    {\n      throw new ExtendedIllegalArgumentException(\"dependentField\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n    }\n    if (fieldDependedOn < 0)\n    {\n      throw new ExtendedIllegalArgumentException(\"fieldDependedOn\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n    }\n    if (dependentField > fieldDescriptions_.size() - 1)\n    {\n      throw new ExtendedIllegalArgumentException(\"dependentField\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n    }\n    if (fieldDependedOn >= dependentField)\n    {\n      throw new ExtendedIllegalArgumentException(\"fieldDependedOn\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n    }\n    offsetDependentFields_.setElementAt(new Integer(fieldDependedOn), dependentField);\n    hasDependentFields_ = true;\n  }\n\n  /**\n   *Sets the field on which a dependent field depends.  Both fields must have been added already\n   *to this RecordFormat.  The <i>fieldDependedOn</i> must have been added prior to adding the\n   *<i>dependentField</i>.  The names of the fields are\n   *case sensitive.\n   *@param dependentField The name of the dependent field.\n   *@param fieldDependedOn The name of a field on which this field depends.  The index of\n   *<i>fieldDependedOn</i> in this RecordFormat must be less than the index of <i>dependentField</i>.\n  **/\n  public void setOffsetDependency(String dependentField, String fieldDependedOn)\n  {\n    if (dependentField == null)\n    {\n      throw new NullPointerException(\"dependentField\");\n    }\n    if (fieldDependedOn == null)\n    {\n      throw new NullPointerException(\"fieldDependedOn\");\n    }\n    int depOnIndex = getIndexOfFieldName(fieldDependedOn);\n    int depIndex = getIndexOfFieldName(dependentField);\n    setOffsetDependency(depIndex, depOnIndex);\n  }\n\n  // @C1A - added method\n  /**\n   * Sets the record format ID. The length of the record format ID must be 10 characters\n   * or less.  The record format ID corresponds to a record format ID within a page\n   * definition on the system.  If the record format ID is less than 10 characters,\n   * it is padded to 10 characters in length with spaces.\n   *\n   * @param id  The record format ID.\n  **/\n  public void setRecordFormatID(String id)\n  {\n    String pad = \"          \" ;\n    if (id.length() > 10) {\n        throw new ExtendedIllegalArgumentException(\"id\",\n            ExtendedIllegalArgumentException.LENGTH_NOT_VALID);\n    }\n    if (id.length() < 10) {\n      int padl = 10 - id.length();\n      recordFormatID_ = id + pad.substring(0,padl);\n    }\n    else\n       recordFormatID_ = id;\n\n\n  }\n\n// @C1A - added method\n  /**\n   * Sets the record format type. Valid values are FIXED_LAYOUT_LENGTH and\n   * VARIABLE_LAYOUT_LENGTH.  This attribute is only valid when using the\n   * line record writer class.\n   *\n   * @param type  The record format type.\n  **/\n\n  public void setRecordFormatType(int type)\n  {\n    if ((type != VARIABLE_LAYOUT_LENGTH) && (type != FIXED_LAYOUT_LENGTH)) {\n        throw new ExtendedIllegalArgumentException(\"type\",\n            ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n    }\n    recordFormatType_ = type;\n  }\n\n/**\n   *  Sets the specified <i>label</i> at the column specified by <i>columnIndex</i>.\n   *  @param recordFormatMetaData TODO\n * @param columnIndex The column index (0-based).\n * @param label The label.\n   **/\n   public void setColumnLabel(RecordFormatMetaData recordFormatMetaData, int columnIndex, String label)\n   {\n      // Validate that the record format is set.\n      recordFormatMetaData.validateRecordFormat(\"Attempting to set the column label\");\n\n      // Validate the label parameter.\n      if (label == null)\n         throw new NullPointerException(\"label\");\n\n      // Validate the columnIndex parameter.\n      recordFormatMetaData.validateColumnIndex(columnIndex);\n\n      recordFormatMetaData.columnLabel_[columnIndex] = label;\n   }\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 1095,
                        "lineEnd": 1114,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method setColumnLabel to class RecordFormatMetaData",
                        "description": "Move method to com.ibm.as400.util.servlet.RecordFormatMetaData\nRationale: The method setColumnLabel directly manipulates the column labels within the RecordFormatMetaData class and requires access to its internal state, making it logical to move this method to the RecordFormatMetaData class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 6159
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setColumnLabel",
                            "method_signature": "public void setColumnLabel(RecordFormatMetaData recordFormatMetaData, int columnIndex, String label)",
                            "target_class": "RecordFormatMetaData",
                            "rationale": "The setColumnLabel method operates directly on the RecordFormatMetaData object, which suggests that it is more appropriate for this method to belong to the RecordFormatMetaData class."
                        }
                    ],
                    "llm_response_time": 2056
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "setColumnLabel",
                            "method_signature": "public void setColumnLabel(RecordFormatMetaData recordFormatMetaData, int columnIndex, String label)",
                            "target_class": "RecordFormatMetaData",
                            "rationale": "The setColumnLabel method operates directly on the RecordFormatMetaData object, which suggests that it is more appropriate for this method to reside within the RecordFormatMetaData class."
                        }
                    ],
                    "llm_response_time": 1678
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "setColumnLabel",
                            "method_signature": "public void setColumnLabel(RecordFormatMetaData recordFormatMetaData, int columnIndex, String label)",
                            "target_class": "RecordFormatMetaData",
                            "rationale": "The setColumnLabel method operates directly on the RecordFormatMetaData object, which suggests that it is more appropriate for this method to reside within the RecordFormatMetaData class."
                        }
                    ],
                    "llm_response_time": 1381
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setColumnLabel",
                            "method_signature": "public void setColumnLabel(RecordFormatMetaData recordFormatMetaData, int columnIndex, String label)",
                            "target_class": "RecordFormatMetaData",
                            "rationale": "The setColumnLabel method operates directly on the RecordFormatMetaData object, which suggests that it is more appropriate for this method to belong to the RecordFormatMetaData class."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "setColumnLabel"
                ],
                "llm_response_time": 947
            },
            "targetClassMap": {
                "setColumnLabel": {
                    "target_classes": [
                        {
                            "class_name": "RecordFormatMetaData",
                            "similarity_score": 0.8253190557195006
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "RecordFormatMetaData"
                    ],
                    "llm_response_time": 751,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.vaccess.SQLMetaDataTablePane::readObject(java.io.ObjectInputStream):void need move com.ibm.as400.vaccess.SQLQueryFieldsPane",
        "class_name": "com.ibm.as400.vaccess.SQLMetaDataTablePane",
        "telemetry": {
            "id": "03164b22-7156-4587-b04b-53a2d32229d1",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 184,
                "lineStart": 28,
                "lineEnd": 211,
                "bodyLineStart": 28,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/small/small/jtopen-7.8/src/com/ibm/as400/vaccess/SQLMetaDataTablePane.java",
                "sourceCode": "/**\nThe SQLMetaDataTablePane class represents a table that contains the\nfield information for a set of tables.\n**/\nclass SQLMetaDataTablePane\nextends JPanel\nimplements java.io.Serializable //@B0A - for consistency\n{\n  private static final String copyright = \"Copyright (C) 1997-2000 International Business Machines Corporation and others.\";\n\n\n\n//The table contained in this panel.\ntransient JTable table_; //@B0C - made transient\n// The data model for the table.\nSQLMetaDataTableModel model_;\n\n\n/**\nConstructs a SQLMetaDataTablePane object.\n\n@param       model  The data model for table data.\n**/\npublic SQLMetaDataTablePane (SQLMetaDataTableModel model)\n{\n    super();\n    addFocusListener(new SerializationListener(this)); //@B0A - for safe serialization\n    model_ = model;\n    table_ = new JTable();\n    table_.setAutoCreateColumnsFromModel(false);\n    table_.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN); //@B0C\n    table_.setModel(model_);\n    table_.setShowGrid(false);\n    // set up table columns\n    TableColumn column = new TableColumn(SQLMetaDataTableModel.FIELD_NAME_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_NAME\"));\n    column.setPreferredWidth(150); //@B0C\n    table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_TYPE_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_TYPE\"));\n    column.setPreferredWidth(70); //@B0C\n    table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_LENGTH_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_LENGTH\"));\n    column.setPreferredWidth(60); //@B0C\n    table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_DECIMALS_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_DECIMALS\"));\n    column.setPreferredWidth(65); //@B0C\n    table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_NULLS_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_NULL\"));\n    column.setPreferredWidth(80); //@B0C\n    table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_DESC_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_DESCRIPTION\"));\n    column.setPreferredWidth(180); //@B0C\n    table_.addColumn(column);\n    // build panel with table and headings\n    setupPane();\n}\n\n\n\n/**\nLoads the table data from the system.\n**/\npublic void load()\n{\n    // refresh the result set data\n    model_.load();\n}\n\n\n//@B0A\n/**\nRestores the state of this object from an object input stream.\nIt is used when deserializing an object.\n@param in The input stream of the object being deserialized.\n@exception IOException\n@exception ClassNotFoundException\n**/\nprivate void readObject(java.io.ObjectInputStream in)\n     throws java.io.IOException, ClassNotFoundException\n{\n    in.defaultReadObject();\n    addFocusListener(new SerializationListener(this)); //@B0A - for safe serialization next time\n\n    //@B0A: The following code is copied from the constructor since\n    // table_ is now transient.\n    table_ = new JTable();\n    table_.setAutoCreateColumnsFromModel(false);\n    table_.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN); //@B0C\n    table_.setModel(model_);\n    table_.setShowGrid(false);\n    // set up table columns\n    TableColumn column = new TableColumn(SQLMetaDataTableModel.FIELD_NAME_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_NAME\"));\n    column.setPreferredWidth(150); //@B0C\n    table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_TYPE_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_TYPE\"));\n    column.setPreferredWidth(70); //@B0C\n    table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_LENGTH_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_LENGTH\"));\n    column.setPreferredWidth(60); //@B0C\n    table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_DECIMALS_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_DECIMALS\"));\n    column.setPreferredWidth(65); //@B0C\n    table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_NULLS_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_NULL\"));\n    column.setPreferredWidth(80); //@B0C\n    table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_DESC_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_DESCRIPTION\"));\n    column.setPreferredWidth(180); //@B0C\n    table_.addColumn(column);\n    // build panel with table and headings\n    setupPane();\n}\n\n\n\n\n/**\nChanges the data for the table.\n\n@param model The data model for the table.\n**/\npublic void setDataModel(SQLMetaDataTableModel model)\n{\n    model_ = model;\n    table_.setModel(model);\n}\n\n\n\n/**\nEnables or disables this pane\n@param enabled true if the pane should be enabled, false otherwise.\n**/\npublic void setEnabled(boolean enabled)\n{\n    table_.setEnabled(enabled);\n}\n\n\n/**\nPuts the table and heading into the panel.\n**/\nprivate void setupPane()\n{\n\tsetLayout(new BorderLayout());\n\n    // Add table to panel.\n    JScrollPane pane = new JScrollPane (table_); // @A1C\n    BevelBorder border = new BevelBorder(BevelBorder.LOWERED);\n    pane.setBorder(border);\n    add(\"Center\", pane);\n}\n\n\n\n/**\nRestores the state of this object from an object input stream.\nIt is used when deserializing an object.\n@param sqlQueryFieldsPane TODO\n * @param in The input stream of the object being deserialized.\n * @exception IOException\n@exception ClassNotFoundException\n**/\nvoid readObject(SQLQueryFieldsPane sqlQueryFieldsPane, ObjectInputStream in)\n     throws IOException, ClassNotFoundException\n{\n    // Restore the non-static and non-transient fields.\n    in.defaultReadObject();\n    // Initialize the transient fields.\n    sqlQueryFieldsPane.fieldListener_ = null;\n}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 3,
                "candidates": [
                    {
                        "lineStart": 177,
                        "lineEnd": 189,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method setupPane to class SQLMetaDataTableModel",
                        "description": "Move method to com.ibm.as400.vaccess.SQLMetaDataTableModel\nRationale: The setupPane() method is responsible for setting up the visual representation of a table, which is likely related to the data model represented by SQLMetaDataTableModel. Moving this method to SQLMetaDataTableModel would encapsulate the UI setup logic with the data it represents.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 154,
                        "lineEnd": 163,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method setDataModel to class SQLMetaDataTableModel",
                        "description": "Move method to com.ibm.as400.vaccess.SQLMetaDataTableModel\nRationale: The setDataModel method directly manipulates an instance of SQLMetaDataTableModel, indicating that it is closely related to the data model itself. Moving this method to SQLMetaDataTableModel would encapsulate the behavior of setting the model within the class that represents the model.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 91,
                        "lineEnd": 98,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method load to class SQLMetaDataTableModel",
                        "description": "Move method to com.ibm.as400.vaccess.SQLMetaDataTableModel\nRationale: The load() method is responsible for loading table data, which directly relates to the functionality of the SQLMetaDataTableModel class, as it likely manages the data representation and retrieval for SQL metadata.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 11829
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setupPane",
                            "method_signature": "private void setupPane()",
                            "target_class": "SQLMetaDataTableModel",
                            "rationale": "The setupPane() method is responsible for configuring the layout and adding components to the panel. This functionality could be better encapsulated within a dedicated class that manages the UI components, such as SQLMetaDataTableModel, which can handle its own presentation logic."
                        },
                        {
                            "method_name": "setDataModel",
                            "method_signature": "public void setDataModel(SQLMetaDataTableModel model)",
                            "target_class": "SQLMetaDataTableModel",
                            "rationale": "The setDataModel() method modifies the model of the table. This method should be moved to the SQLMetaDataTableModel class to maintain a clear separation of concerns, allowing the model to manage its own data and state."
                        },
                        {
                            "method_name": "load",
                            "method_signature": "public void load()",
                            "target_class": "SQLMetaDataTableModel",
                            "rationale": "The load() method directly interacts with the model to refresh data. It would be more appropriate for this method to reside in the SQLMetaDataTableModel class, where it can manage its own data loading logic."
                        }
                    ],
                    "llm_response_time": 2986
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "setupPane",
                            "method_signature": "private void setupPane()",
                            "target_class": "SQLMetaDataTableModel",
                            "rationale": "The setupPane() method is responsible for configuring the layout and adding components to the panel. This functionality could be better encapsulated within a dedicated class that manages the UI layout and presentation logic, such as SQLMetaDataTableModel, which can handle the visual representation of the data model."
                        },
                        {
                            "method_name": "setDataModel",
                            "method_signature": "public void setDataModel(SQLMetaDataTableModel model)",
                            "target_class": "SQLMetaDataTableModel",
                            "rationale": "The setDataModel() method modifies the data model of the table. This method should be moved to the SQLMetaDataTableModel class to maintain a clear separation of concerns, allowing the model to manage its own data and state."
                        },
                        {
                            "method_name": "load",
                            "method_signature": "public void load()",
                            "target_class": "SQLMetaDataTableModel",
                            "rationale": "The load() method is responsible for refreshing the data in the model. It should be moved to the SQLMetaDataTableModel class, as it directly interacts with the model's data and should be part of the model's responsibilities."
                        }
                    ],
                    "llm_response_time": 5606
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "setupPane",
                            "method_signature": "private void setupPane()",
                            "target_class": "SQLMetaDataTableModel",
                            "rationale": "The setupPane() method is responsible for configuring the layout and adding components to the panel. This functionality could be better encapsulated within a dedicated class that manages the UI layout and presentation logic, such as SQLMetaDataTableModel, which can handle the visual representation of the data model."
                        },
                        {
                            "method_name": "setDataModel",
                            "method_signature": "public void setDataModel(SQLMetaDataTableModel model)",
                            "target_class": "SQLMetaDataTableModel",
                            "rationale": "The setDataModel() method modifies the data model of the table. This method should be moved to the SQLMetaDataTableModel class to maintain a clear separation of concerns, allowing the model to manage its own data and state."
                        },
                        {
                            "method_name": "load",
                            "method_signature": "public void load()",
                            "target_class": "SQLMetaDataTableModel",
                            "rationale": "The load() method is responsible for refreshing the data in the model. It should be moved to the SQLMetaDataTableModel class, as it directly interacts with the model's data and should be part of its responsibilities."
                        }
                    ],
                    "llm_response_time": 2678
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setupPane",
                            "method_signature": "private void setupPane()",
                            "target_class": "SQLMetaDataTableModel",
                            "rationale": "The setupPane() method is responsible for configuring the layout and adding components to the panel. This functionality could be better encapsulated within a dedicated class that manages the UI components, such as SQLMetaDataTableModel, which can handle its own presentation logic."
                        },
                        {
                            "method_name": "setDataModel",
                            "method_signature": "public void setDataModel(SQLMetaDataTableModel model)",
                            "target_class": "SQLMetaDataTableModel",
                            "rationale": "The setDataModel() method modifies the model of the table. This method should be moved to the SQLMetaDataTableModel class to maintain a clear separation of concerns, allowing the model to manage its own data and state."
                        },
                        {
                            "method_name": "load",
                            "method_signature": "public void load()",
                            "target_class": "SQLMetaDataTableModel",
                            "rationale": "The load() method directly interacts with the model to refresh data. It would be more appropriate for this method to reside in the SQLMetaDataTableModel class, where it can manage its own data loading logic."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "setupPane",
                    "setDataModel",
                    "load"
                ],
                "llm_response_time": 491
            },
            "targetClassMap": {
                "setupPane": {
                    "target_classes": [
                        {
                            "class_name": "SQLMetaDataTableModel",
                            "similarity_score": 0.5750983288300429
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SQLMetaDataTableModel"
                    ],
                    "llm_response_time": 1045,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "setDataModel": {
                    "target_classes": [
                        {
                            "class_name": "SQLMetaDataTableModel",
                            "similarity_score": 0.5285462866788998
                        },
                        {
                            "class_name": "SQLMetaDataTableModel",
                            "similarity_score": 0.5285462866788998
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SQLMetaDataTableModel",
                        "SQLMetaDataTableModel"
                    ],
                    "llm_response_time": 1089,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "load": {
                    "target_classes": [
                        {
                            "class_name": "SQLMetaDataTableModel",
                            "similarity_score": 0.5547300556246916
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SQLMetaDataTableModel"
                    ],
                    "llm_response_time": 915,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.access.SystemPool::removeErrorListener(ErrorListener):void need move com.ibm.as400.vaccess.VSystemPool",
        "class_name": "com.ibm.as400.access.SystemPool",
        "telemetry": {
            "id": "524c5181-46bd-4a6d-9a1a-48a220822cb7",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 2465,
                "lineStart": 28,
                "lineEnd": 2492,
                "bodyLineStart": 28,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/small/small/jtopen-7.8/src/com/ibm/as400/access/SystemPool.java",
                "sourceCode": "/**\n * Represents a system pool.  It provides\n * facilities for retrieving and changing system pool information.\n *\n * Here is a example:\n *\n * <p><blockquote><pre>\n *  try {\n *      // Creates AS400 object.\n *      AS400 as400 = new AS400(\"systemName\");\n *      // Constructs a SystemPool object\n *      SystemPool systemPool = new SystemPool(as400,\"*SPOOL\");\n *      // Gets system pool attributes.\n *      System.out.println(\"Paging option : \"+systemPool.getPagingOption());\n *\n *  } catch (Exception e)\n *  {\n *      System.out.println(\"error : \"+e)\n *  }\n * </pre></blockquote></p>\n *\n **/\npublic class SystemPool\n{\n  private static final boolean DEBUG = false;\n\n     /**\n      * Indicates that the system should calculate\n      * a system pool attribute.\n      * @deprecated\n     **/\n     public static final float CALCULATE = -2;\n     private static final Float CALCULATE_FLOAT = new Float(-2);\n\n     /**\n      * Indicates that the system should calculate\n      * a system pool attribute.\n      * @deprecated\n     **/\n     public static final int CALCULATE_INT = -2;\n\n     private static final Integer CALCULATE_INTEGER = new Integer(-2);\n     private static final Integer NO_CHANGE = new Integer(-1);\n     private static final String DEFAULT = \"*DFT\";\n\n     private AS400 system_;\n\n     // The pool's name.  In the case of a subsystem (non-shared) pool, this field will contain a number from 1-10.\n     private String poolName_;\n\n     // The system pool identifier.  The number is assigned by the system, and is unique across the system at any given moment.  Shared system pools that are not in use by a subsystem, will not have a system pool identifier assigned; in which case this variable will be null.  Otherwise, this variable will contain a number from 1-64.\n     private Integer poolIdentifier_;\n\n     private boolean indicatedSharedPool_; // true if caller indicated it's a shared system pool; false otherwise\n\n     // Attributes that are meaningful only if the pool is a subsystem (non-shared) pool.\n     private String subsystemLibrary_;\n     private String subsystemName_;\n     private int poolSequenceNumber_;  // subsystem pool sequence number (within the subsystem) (1-10)\n\n     private transient boolean connected_;\n     private boolean cacheChanges_ = false;\n\n     private transient PropertyChangeSupport changes_;\n     private transient VetoableChangeSupport vetos_;\n\n     // This format maps the API getter.\n     private SystemStatusFormat systemStatusFormat_;\n     // This format maps the pool information portion of the format.\n     private PoolInformationFormat poolFormat_;\n\n     // This record holds the data for one system pool -- us.\n     private Record poolRecord_;\n\n     // This table holds the data to be set on the API.\n     private transient Hashtable changesTable_;\n\n     /**\n      * Constructs a SystemPool object.\n      **/\n     public SystemPool()\n     {\n     }\n\n     /**\n      * Constructs a SystemPool object, to represent a <i>shared</i> system pool.\n      *\n      * @param system The system.\n      * @param poolName The name of the shared system pool.\n      * Valid values are *MACHINE, *BASE, *INTERACT, *SPOOL, and *SHRPOOL1-60.\n      **/\n     public SystemPool(AS400 system, String poolName)\n     {\n         if (system == null)\n            throw new NullPointerException (\"system\");\n         if (poolName == null)\n            throw new NullPointerException (\"poolName\");\n         if (Trace.isTraceOn() && !isValidNameForSharedPool(poolName)) {\n           Trace.log(Trace.WARNING, \"Invalid name for shared pool: \" + poolName);\n         }\n\n         system_ = system;\n         poolName_ = poolName.trim();\n         indicatedSharedPool_ = true;\n     }\n\n     /**\n      * Constructs a SystemPool object, to represent a <i>subsystem (non-shared)</i> pool.\n      *\n      * @param subsystem The subsystem that \"owns\" the pool.\n      * @param sequenceNumber The pool's sequence number within the subsystem.\n      * Valid values are 1 through 10.\n      **/\n     public SystemPool(Subsystem subsystem, int sequenceNumber)\n     {\n       if (subsystem == null) throw new NullPointerException (\"subsystem\");\n\n       if (sequenceNumber < 1 || sequenceNumber > 10)\n       {\n         throw new ExtendedIllegalArgumentException(\"sequenceNumber (\" + sequenceNumber + \")\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n       }\n\n       system_ = subsystem.getSystem();\n       poolName_ = Integer.toString(sequenceNumber);\n       subsystemLibrary_ = subsystem.getLibrary();\n       subsystemName_ = subsystem.getName();\n       poolSequenceNumber_ = sequenceNumber;  // pool sequence number within the subsystem (1-10)\n       indicatedSharedPool_ = false;  // not a shared system pool\n     }\n\n     /**\n      * Constructs a SystemPool object, to represent a <i>subsystem (non-shared)</i> pool.\n      *\n      * @param subsystem The subsystem that \"owns\" the pool.\n      * @param sequenceNumber The pool's sequence number within the subsystem.\n      * Valid values are 1 through 10.\n      * @param size The size of the system pool, in kilobytes.\n      * @param activityLevel The activity level of the pool.\n      **/\n     public SystemPool(Subsystem subsystem, int sequenceNumber, int size, int activityLevel)\n     {\n       this(subsystem, sequenceNumber);\n\n       cacheChanges_ = true; // don't send values to the system yet\n       try {\n         set(\"poolSize\", new Integer(size));\n         set(\"activityLevel\", new Integer(activityLevel));\n       }\n       catch (Exception e) { // should never happen, no system contact\n         Trace.log(Trace.ERROR, e);\n         throw new InternalErrorException(InternalErrorException.UNEXPECTED_EXCEPTION);\n       }\n       cacheChanges_ = false;\n     }\n\n     /**\n      * Constructs a SystemPool object, to represent a <i>shared</i> system pool.\n      *\n      * @param system The system.\n      * @param poolName The name of the shared system pool.\n      * Valid values are *MACHINE, *BASE, *INTERACT, *SPOOL, and *SHRPOOL1-60.\n      * @param poolIdentifier The system pool identifier.\n      * Valid values are 1 through 64.\n      * @deprecated Use {@link #SystemPool(AS400,int) SystemPool(system, poolIdentifier)} instead.\n      **/\n     public SystemPool(AS400 system, String poolName, int poolIdentifier)\n     {\n         if (system == null)\n            throw new NullPointerException (\"system\");\n         if (poolName == null)\n            throw new NullPointerException (\"poolName\");\n\n         if (poolIdentifier < 1 || poolIdentifier > 64)\n         {\n           throw new ExtendedIllegalArgumentException(\"poolIdentifier (\" + poolIdentifier + \")\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n         }\n\n         system_ = system;\n         poolName_ = poolName.trim();\n         poolIdentifier_ = new Integer(poolIdentifier);\n         indicatedSharedPool_ = true;\n\n         if (Trace.isTraceOn() && !isValidNameForSharedPool(poolName)) {\n           Trace.log(Trace.WARNING, \"Invalid name for shared pool: \" + poolName);\n         }\n     }\n\n     /**\n      * Constructs a SystemPool object, to represent a pool identified\n      * by its unique system pool identifier.\n      * Either a <i>shared</i> pool or a <i>non-shared</i> pool can be specified.\n      *\n      * @param system The system.\n      * @param poolIdentifier The system pool identifier.\n      * Valid values are 1 through 64.\n      **/\n     public SystemPool(AS400 system, int poolIdentifier)\n     {\n         if (system == null)\n            throw new NullPointerException (\"system\");\n\n         if (poolIdentifier < 1 || poolIdentifier > 64)\n         {\n           throw new ExtendedIllegalArgumentException(\"poolIdentifier (\" + poolIdentifier + \")\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n         }\n\n         system_ = system;\n         poolIdentifier_ = new Integer(poolIdentifier);\n     }\n\n\n     /**\n      * Adds a listener to be notified when the value of any bound property\n      * changes.\n      *\n      * @param listener The listener.\n      **/\n     public void addPropertyChangeListener(PropertyChangeListener listener)\n     {\n       if (listener == null)\n       {\n         throw new NullPointerException(\"listener\");\n       }\n       if (changes_ == null) changes_ = new PropertyChangeSupport(this);\n       changes_.addPropertyChangeListener(listener);\n     }\n\n     /**\n      * Adds a listener to be notified when the value of any constrained\n      * property changes.\n      *\n      * @param listener The listener.\n      **/\n     public void addVetoableChangeListener(VetoableChangeListener listener)\n     {\n       if (listener == null)\n       {\n         throw new NullPointerException(\"listener\");\n       }\n       if (vetos_ == null) vetos_ = new VetoableChangeSupport(this);\n       vetos_.addVetoableChangeListener(listener);\n     }\n\n\n     // Converts a Float value to hundredths, and returns it as an Integer.\n     // Assumes that obj is never null.\n     private static final Integer convertToHundredths(Object obj)\n     {\n       float floatVal = ((Float)obj).floatValue();\n       Integer obj1;\n\n       // For some fields, negative values have special meanings.\n       // It never makes sense to convert a negative value to hundredths.\n       if (floatVal <= 0) obj1 = new Integer((int)floatVal);\n       else obj1 = new Integer((int)(floatVal*100));\n\n       return obj1;\n     }\n\n\n    /**\n     * Commits any cached system pool information changes to the system.\n     * If caching is not enabled, this method does nothing.\n     * @see #isCaching\n     * @see #refreshCache\n     * @see #setCaching\n     * @exception AS400Exception If the system returns an error\n     *            message.\n     * @exception AS400SecurityException If a security or authority error\n     *            occurs.\n     * @exception ConnectionDroppedException If the connection is dropped\n     *            unexpectedly.\n     * @exception ErrorCompletingRequestException If an error occurs before\n     *            the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with\n     *            the system.\n     * @exception ObjectDoesNotExistException If the object does not exist on the system.\n     * @exception UnsupportedEncodingException If the character encoding is\n     *            not supported.\n    **/\n    public synchronized void commitCache()\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n    {\n      // If there are no changes, don't do anything!\n      if (changesTable_ == null || changesTable_.isEmpty()) return;\n\n      if (!connected_) connect();\n\n      int poolIdentifier = 0;\n      try {\n        poolIdentifier = getIdentifier();\n      }\n      catch (ObjectDoesNotExistException e) {\n        // This may indicate that it's a shared pool that's not currently in use by any subsystem.\n        poolIdentifier = 0;\n        if (Trace.isTraceOn()) {\n          Trace.log(Trace.DIAGNOSTIC, \"No pool identifier is assigned to pool.\", e);\n        }\n      }\n\n      String messageLogging_pending = null;  // We might need to leave the change uncommitted, if we end up calling CHGSHRPOOL.\n\n      // Note: \"Shared\" pools that are not currently in use by any subsystem, do not have a system pool identifier assigned, and therefore are beyond the reach of QUSCHGPA.\n      // QUSCHGPA works only on active pools that have been allocated by system pood ID.\n      // To modify such pools, we must use CHGSHRPOOL.\n\n      if (poolIdentifier == 0)\n      {\n        // We need to use CHGSHRPOOL, since QUSCHGPA requires a unique system pool identifier.\n        StringBuffer cmdBuf = new StringBuffer(\"QSYS/CHGSHRPOOL POOL(\"+poolName_+\")\");\n        Object obj;  // attribute value\n\n        obj = changesTable_.get(\"poolSize\");\n        if (obj != null) {\n          cmdBuf.append(\" SIZE(\"+obj.toString()+\")\");\n        }\n\n        obj = changesTable_.get(\"activityLevel\");\n        if (obj != null) {\n          if (obj.equals(CALCULATE_INTEGER)) { // this constant has been deprecated\n            obj = \"*SAME\";\n            if (Trace.isTraceOn()) {\n              Trace.log(Trace.WARNING, \"Setting activityLevel to SAME.\");\n            }\n          }\n          cmdBuf.append(\" ACTLVL(\"+obj.toString()+\")\");\n        }\n\n        obj = changesTable_.get(\"pagingOption\");\n        if (obj != null) {\n          cmdBuf.append(\" PAGING(\"+obj.toString()+\")\");\n        }\n\n        obj = changesTable_.get(\"priority\");\n        if (obj != null) {\n          if (obj.equals(CALCULATE_INTEGER)) {\n            obj = DEFAULT;\n            if (Trace.isTraceOn()) {\n              Trace.log(Trace.WARNING, \"Setting priority to DEFAULT.\");\n            }\n          }\n          cmdBuf.append(\" PTY(\"+obj.toString()+\")\");\n        }\n\n        obj = changesTable_.get(\"minimumPoolSize\");\n        if (obj != null) {\n          if (obj.equals(CALCULATE_FLOAT)) { // this constant has been deprecated\n            obj = DEFAULT;\n            if (Trace.isTraceOn()) {\n              Trace.log(Trace.WARNING, \"Setting minimumPoolSize to DEFAULT.\");\n            }\n          }\n          cmdBuf.append(\" MINPCT(\"+obj.toString()+\")\");\n        }\n\n        obj = changesTable_.get(\"maximumPoolSize\");\n        if (obj != null) {\n          if (obj.equals(CALCULATE_FLOAT)) {\n            obj = DEFAULT;\n            if (Trace.isTraceOn()) {\n              Trace.log(Trace.WARNING, \"Setting maximumPoolSize to DEFAULT.\");\n            }\n          }\n          cmdBuf.append(\" MAXPCT(\"+obj.toString()+\")\");\n        }\n\n        obj = changesTable_.get(\"minimumFaults\");\n        if (obj != null) {\n          if (obj.equals(CALCULATE_FLOAT)) {\n            obj = DEFAULT;\n            if (Trace.isTraceOn()) {\n              Trace.log(Trace.WARNING, \"Setting minimumFaults to DEFAULT.\");\n            }\n          }\n          cmdBuf.append(\" MINFAULT(\"+obj.toString()+\")\");\n        }\n\n        obj = changesTable_.get(\"perThreadFaults\");\n        if (obj != null) {\n          if (obj.equals(CALCULATE_FLOAT)) {\n            obj = DEFAULT;\n            if (Trace.isTraceOn()) {\n              Trace.log(Trace.WARNING, \"Setting perThreadFaults to DEFAULT.\");\n            }\n          }\n          cmdBuf.append(\" JOBFAULT(\"+obj.toString()+\")\");\n        }\n\n        obj = changesTable_.get(\"maximumFaults\");\n        if (obj != null) {\n          if (obj.equals(CALCULATE_FLOAT)) {\n            obj = DEFAULT;\n            if (Trace.isTraceOn()) {\n              Trace.log(Trace.WARNING, \"Setting maximumFaults to DEFAULT.\");\n            }\n          }\n          cmdBuf.append(\" MAXFAULT(\"+obj.toString()+\")\");\n        }\n\n        if (DEBUG) System.out.println(\"Running command: \" + cmdBuf.toString());\n        CommandCall cmd = new CommandCall(system_, cmdBuf.toString());\n        // CHGSHRPOOL is not thread safe.\n        cmd.suggestThreadsafe(false);\n        if (!cmd.run()) {\n          throw new AS400Exception(cmd.getMessageList());\n        }\n\n        // See if we were asked to change the message logging attribute.\n        // The CL command doesn't have a \"message logging\" parameter.\n        messageLogging_pending = (String)changesTable_.get(\"messageLogging\");\n\n        // Future enhancement: The CL command also has a TEXT() parameter, which can be specified to change the pool's text description.\n      }\n\n      else // The pool identifier is known, therefore we can use the QUSCHGPA API.\n      {\n        QSYSObjectPathName prgName = new QSYSObjectPathName(\"QSYS\",\"QUSCHGPA\",\"PGM\");\n        AS400Bin4 bin4 = new AS400Bin4();\n        AS400Text text;\n\n        ProgramParameter[] parmList = new ProgramParameter[12];\n\n        parmList[0] = new ProgramParameter(bin4.toBytes(getIdentifier()));\n\n        Object obj = changesTable_.get(\"poolSize\");\n        if (obj == null) obj = NO_CHANGE;\n        parmList[1] = new ProgramParameter(bin4.toBytes(obj));\n\n        obj = changesTable_.get(\"activityLevel\");\n        if (obj == null) obj = NO_CHANGE;\n        parmList[2] = new ProgramParameter(bin4.toBytes(obj));\n\n        obj = changesTable_.get(\"messageLogging\");\n        if (obj == null) obj = \"Y\"; // no change\n        AS400Text text1 = new AS400Text(1, system_.getCcsid(), system_);\n        parmList[3] = new ProgramParameter(text1.toBytes(obj));\n\n        byte[] errorInfo = new byte[32];\n        parmList[4] = new ProgramParameter(errorInfo, 0); // don't care about error info\n\n        obj = changesTable_.get(\"pagingOption\");\n        if (obj == null) obj = \"*SAME\"; // no change\n        AS400Text text10 = new AS400Text(10, system_.getCcsid(), system_);\n        parmList[5] = new ProgramParameter(text10.toBytes(obj));\n\n        obj = changesTable_.get(\"priority\");\n        if (obj == null) obj = NO_CHANGE;\n        parmList[6] = new ProgramParameter(bin4.toBytes(obj));\n\n        obj = changesTable_.get(\"minimumPoolSize\");\n        if (obj == null) obj = NO_CHANGE;\n        else if (obj.equals(CALCULATE_FLOAT)) obj = CALCULATE_INTEGER;\n        else obj = convertToHundredths(obj); // the API expect units of hundredths\n        parmList[7] = new ProgramParameter(bin4.toBytes(obj));\n\n        obj = changesTable_.get(\"maximumPoolSize\");\n        if (obj == null) obj = NO_CHANGE;\n        else if (obj.equals(CALCULATE_FLOAT)) obj = CALCULATE_INTEGER;\n        else obj = convertToHundredths(obj);\n        parmList[8] = new ProgramParameter(bin4.toBytes(obj));\n\n        obj = changesTable_.get(\"minimumFaults\");\n        if (obj == null) obj = NO_CHANGE;\n        else if (obj.equals(CALCULATE_FLOAT)) obj = CALCULATE_INTEGER;\n        else obj = convertToHundredths(obj);\n        parmList[9] = new ProgramParameter(bin4.toBytes(obj));\n\n        obj = changesTable_.get(\"perThreadFaults\");\n        if (obj == null) obj = NO_CHANGE;\n        else if (obj.equals(CALCULATE_FLOAT)) obj = CALCULATE_INTEGER;\n        else obj = convertToHundredths(obj);\n        parmList[10] = new ProgramParameter(bin4.toBytes(obj));\n\n        obj = changesTable_.get(\"maximumFaults\");\n        if (obj == null) obj = NO_CHANGE;\n        else if (obj.equals(CALCULATE_FLOAT)) obj = CALCULATE_INTEGER;\n        else obj = convertToHundredths(obj);\n        parmList[11] = new ProgramParameter(bin4.toBytes(obj));\n\n        ProgramCall pgm = new ProgramCall(system_);\n        try\n        {\n          pgm.setProgram(prgName.getPath(), parmList);\n        }\n        catch(PropertyVetoException pve) {} // Quiet the compiler\n\n        if (Trace.isTraceOn())\n        {\n          Trace.log(Trace.DIAGNOSTIC, \"Setting system pool information.\");\n        }\n        if (pgm.run() != true)\n        {\n          AS400Message[] msgList = pgm.getMessageList();\n          if (Trace.isTraceOn())\n          {\n            Trace.log(Trace.ERROR, \"Error setting system pool information:\");\n            for (int i=0; i<msgList.length; ++i)\n            {\n              Trace.log(Trace.ERROR, msgList[i].toString());\n            }\n          }\n          throw new AS400Exception(msgList);\n        }\n      }\n\n      changesTable_.clear();  // clear all pending changes\n\n      if (messageLogging_pending != null) {\n        // Put the (uncommitted) messageLogging value back in to the changes table.\n        changesTable_.put(\"messageLogging\", messageLogging_pending);\n        Trace.log(Trace.ERROR, \"Unable to update 'message logging' attribute, since shared pool \" + poolName_ + \" is not in use.  The change remains pending.\");\n      }\n    }\n\n    /**\n     * Connects to the 400 by loading system status information.\n     * Does nothing if we have already connected.\n     *\n     * @exception AS400SecurityException If a security or authority error\n     *            occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before\n     *            the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with\n     *            the system.\n     * @exception ObjectDoesNotExistException If the object does not exist on the system.\n     * @exception UnsupportedEncodingException If the character encoding is\n     *            not supported.\n    **/\n    private void connect()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n    {\n      if (system_ == null)\n      {\n        Trace.log(Trace.ERROR, \"Attempt to connect before setting system.\");\n        throw new ExtendedIllegalStateException(\"system\", ExtendedIllegalStateException.PROPERTY_NOT_SET);\n      }\n\n      connected_ = true;\n    }\n\n\n  /**\n   Determines whether this SystemPool object is equal to another object.\n   @return <tt>true</tt> if the two instances are equal.\n   **/\n  public boolean equals(Object obj)\n  {\n\t  if (obj == null) return false; \n    try\n    {\n      SystemPool other = (SystemPool)obj;\n\n      if (system_ == null) {\n        if (other.getSystem() != null) return false;\n      }\n      else if (!system_.equals(other.getSystem())) return false;\n\n      if (poolName_ == null) {\n        if (other.getName() != null) return false;\n      }\n      else if (!poolName_.equals(other.getName())) return false;\n\n      if (subsystemLibrary_ == null) {\n        if (other.getSubsystemLibrary() != null) return false;\n      }\n      else if (!subsystemLibrary_.equals(other.getSubsystemLibrary())) return false;\n\n      if (subsystemName_ == null) {\n        if (other.getSubsystemName() != null) return false;\n      }\n      else if (!subsystemName_.equals(other.getSubsystemName())) return false;\n\n      // If both objects have non-zero identifiers, they must match.\n      if (poolIdentifier_ != null &&\n          poolIdentifier_.intValue() != 0 &&\n          other.getIdentifier() != 0)\n      {\n        if (poolIdentifier_.intValue() != other.getIdentifier()) return false;\n      }\n\n      return true;\n    }\n    catch (Throwable e) {\n      return false;\n    }\n  }\n\n  /**\n   Returns a hash code value for the object.\n   @return A hash code value for this object.\n   **/\n  public int hashCode()\n  {\n    // We must conform to the invariant that equal objects must have equal hashcodes.\n    int hash = 0;\n\n    if (system_ != null)           hash += system_.hashCode();\n    if (poolName_ != null)         hash += poolName_.hashCode();\n    if (subsystemLibrary_ != null) hash += subsystemLibrary_.hashCode();\n    if (subsystemName_ != null)    hash += subsystemName_.hashCode();\n    if (poolIdentifier_ != null)   hash += poolIdentifier_.hashCode(); \n\n    return hash;\n  }\n\n\n    /**\n     * Gets the value for the specified field out of the\n     * appropriate record in the format cache.  If the particular\n     * format has not been loaded yet, it is loaded from the 400.\n    **/\n    private Object get(String field)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n    {\n      // Retrieve the info out of our own record\n      Object obj = null;\n      if (!cacheChanges_) {\n        refreshCache(); // Load the info if we're not caching.\n      }\n      else {\n        if (changesTable_ != null) obj = changesTable_.get(field);\n      }\n\n      if (obj == null)\n      {\n        retrieveInformation();  // this will do the connect() if needed\n        obj = poolRecord_.getField(field);\n      }\n      return obj;\n    }\n\n\n     /**\n      * Returns the rate, in transitions per minute, of transitions\n      * of threads from an active condition to an ineligible condition.\n      *\n      * @return The rate.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n     **/\n     public float getActiveToIneligible()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return ((Integer)get(\"activeToIneligible\")).floatValue()/(float)10.0;\n     }\n\n     /**\n      * Returns the rate, in transitions per minute, of transitions\n      * of threads from an active condition to a waiting condition.\n      *\n      * @return The rate.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public float getActiveToWait()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return ((Integer)get(\"activeToWait\")).floatValue()/(float)10.0;\n     }\n\n     /**\n      * Returns the rate, shown in page faults per second, of\n      * database page faults against pages containing either database data\n      * or access paths.  A page fault is a program notification that occurs\n      * when a page that is marked as not in main storage is referred to be\n      * an active program.  An access path is the means by which the system\n      * provides a logical organization to the data in a database file.\n      *\n      * @return The rate.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public float getDatabaseFaults()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return ((Integer)get(\"databaseFaults\")).floatValue()/(float)10.0;\n     }\n\n     /**\n      * Returns the rate, in pages per second, at which database\n      * pages are brought into the storage pool.\n      *\n      * @return The rate.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public float getDatabasePages()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return ((Integer)get(\"databasePages\")).floatValue()/(float)10.0;\n     }\n\n     /**\n      * Returns the description of the system pool.\n      *\n      * @return The description of the system pool.\n      **/\n     public String getDescription()\n     {\n         if(poolName_ == null) return \"\";\n         if(poolName_.equals(\"*MACHINE\"))\n            return ResourceBundleLoader.getText(\"SYSTEM_POOL_MACHINE\");\n         else if(poolName_.equals(\"*BASE\"))\n            return ResourceBundleLoader.getText(\"SYSTEM_POOL_BASE\");\n         else if(poolName_.equals(\"*INTERACT\"))\n            return ResourceBundleLoader.getText(\"SYSTEM_POOL_INTERACT\");\n         else if(poolName_.equals(\"*SPOOL\"))\n            return ResourceBundleLoader.getText(\"SYSTEM_POOL_SPOOL\");\n         else\n            return ResourceBundleLoader.getText(\"SYSTEM_POOL_OTHER\");\n     }\n\n     /**\n      * Returns the maximum number of threads that can be active in the pool\n      * at any one time.\n      *\n      * @return The maximum number of threads.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      * @deprecated Use getActivityLevel() instead.\n      **/\n     public int getMaximumActiveThreads()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return getActivityLevel();\n     }\n\n\n     /**\n      * Returns the activity level for the pool.  This is the maximum number of\n      * threads that can be active in the pool at any one time.\n      *\n      * @return The pool activity level.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public int getActivityLevel()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return ((Integer)get(\"activityLevel\")).intValue();\n     }\n\n     /**\n      * Returns the rate, in page faults per second, of\n      * nondatabase page faults against pages other than those designated\n      * as database pages.\n      *\n      * @return The rate.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public float getNonDatabaseFaults()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return ((Integer)get(\"nonDatabaseFaults\")).floatValue()/(float)10.0;\n     }\n\n     /**\n      * Returns the rate, in page per second, at which non-database\n      * pages are brought into the storage pool.\n      *\n      * @return The rate.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public float getNonDatabasePages()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return ((Integer)get(\"nonDatabasePages\")).floatValue()/(float)10.0;\n     }\n\n     /**\n      * Returns the value indicating whether the system will dynamically\n      * adjust the paging characteristics of the storage pool for optimum\n      * performance.  The following special values may be returned.\n      *\n      *   *FIXED:   The system does not dynamically adjust the paging\n      *             characteristics.\n      *   *CALC:    The system dynamically adjusts the paging\n      *             characteristics.\n      *   USRDFN:   The system does not dynamically adjust the paging\n      *             characteristics for the storage pool but uses values\n      *             that have been defined through an API.\n      *\n      * @return The value indicating whether the system will dynamically adjust\n      *         the paging characteristics of the storage pool for optimum performance.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public String getPagingOption()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return ((String)get(\"pagingOption\")).trim();\n     }\n\n     /**\n      * Returns the system pool identifier.\n      *\n      * @return The system pool identifier.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      * @deprecated Use getIdentifier() instead.\n      **/\n     public int getPoolIdentifier()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return getIdentifier();\n     }\n\n     /**\n      * Returns the system pool identifier.\n      * The system assigns a unique identifier (from 1 through 64) to each\n      * system storage pool that currently has main storage allocated.\n      * If the pool is inactive, 0 is returned.\n      *\n      * @return The system pool identifier.  0 indicates that the pool is inactive.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public int getIdentifier()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       if (poolIdentifier_ == null) {\n         synchronized(this) {\n           if (poolIdentifier_ == null) {\n             boolean oldVal = cacheChanges_;\n             cacheChanges_ = true;\n             poolIdentifier_ = (Integer)get(\"poolIdentifier\");\n             cacheChanges_ = oldVal;\n           }\n         }\n       }\n       return (poolIdentifier_ == null ? 0 : poolIdentifier_.intValue());\n     }\n\n     /**\n      * Returns the name of this storage pool.  The name may be a number, in\n      * which case it is a non-shared pool associated with a subsystem.\n      * The following special values may be returned, in the case of shared pools:\n      *<p>\n      *<li> *MACHINE  The specified pool definition is defined to be the\n      *   machine pool.\n      *<li> *BASE     The specified pool definition is defined to be the base\n      *   system pool, which can be shared with other subsystems.\n      *<li> *INTERACT The specified pool definition is defined to be shared\n      *   pool used for interactive work.\n      *<li> *SPOOL    The specified pool definition is defined to be the\n      *   shared pool used for spooled writers.\n      *<li> *SHRPOOL1 - *SHRPOOL60  The specified pool definition is defined\n      *   to be a shared pool.\n      *</p>\n      *\n      * @return The pool name.\n      * @deprecated Use getName() instead.\n      **/\n     public String getPoolName()\n     {\n       //return (String)get(\"poolName\");\n       return getName();\n     }\n\n     /**\n      * Returns the name of this storage pool.  The name may be a number, in\n      * which case it is a non-shared pool associated with a subsystem.\n      * The following special values may be returned, in the case of shared pools:\n      *<p>\n      *<li> *MACHINE  The specified pool definition is defined to be the\n      *   machine pool.\n      *<li> *BASE     The specified pool definition is defined to be the base\n      *   system pool, which can be shared with other subsystems.\n      *<li> *INTERACT The specified pool definition is defined to be shared\n      *   pool used for interactive work.\n      *<li> *SPOOL    The specified pool definition is defined to be the\n      *   shared pool used for spooled writers.\n      *<li> *SHRPOOL1 - *SHRPOOL60  The specified pool definition is defined\n      *   to be a shared pool.\n      *</p>\n      *\n      * @return The pool name.  If the pool name cannot be determined, null is returned.\n      **/\n     public String getName()\n     {\n       if (poolName_ != null) return poolName_;\n       else {\n         try\n         {\n           poolName_ = ((String)get(\"poolName\")).trim();\n           return poolName_;\n         }\n         catch (Exception e)\n         {\n           if (Trace.isTraceOn()) Trace.log(Trace.ERROR, \"Unable to get pool name.\", e);\n           return null;\n         }\n       }\n     }\n\n     /**\n      * Returns the amount of main storage, in kilobytes, currently allocated to the pool.\n      * Note: Depending on system storage availability, this may be less than\n      * the pool's requested (\"defined\") size.\n      *\n      * @return The pool size, in kilobytes.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      * @deprecated Use getSize() instead.\n      **/\n     public int getPoolSize()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return getSize();\n     }\n\n     /**\n      * Returns the amount of main storage, in kilobytes, currently allocated to the pool.\n      * Note: Depending on system storage availability, this may be less than\n      * the pool's requested (\"defined\") size.\n      *\n      * @return The pool size, in kilobytes.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public int getSize()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return ((Integer)get(\"poolSize\")).intValue();\n     }\n\n     /**\n      * Returns the amount of storage, in kilobytes, in the pool reserved for\n      * system use.  (For example, for save and restore operations.)  The system\n      * calculates this amount by using storage pool sizes and activity levels.\n      *\n      * @return The reserved size.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public int getReservedSize()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return ((Integer)get(\"reservedSize\")).intValue();\n     }\n\n     /**\n      * Returns the library of the subsystem with which this storage pool is associated.\n      * The field will be blank for shared pools.\n      *\n      * @return The subsystem library.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public String getSubsystemLibrary()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return ((String)get(\"subsystemLibraryName\")).trim();\n     }\n\n     /**\n      * Returns the subsystem with which this storage pool is associated.\n      * The field will be blank for shared pools.\n      *\n      * @return The subsystem name.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public String getSubsystemName()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return ((String)get(\"subsystemName\")).trim();\n     }\n\n     /**\n      * Returns the system.\n      *\n      * @return The system.\n      **/\n     public AS400 getSystem()\n     {\n       return system_;\n     }\n\n     /**\n      * Returns the rate, in transitions per minute, of transitions\n      * of threads from a waiting condition to an ineligible condition.\n      *\n      * @return The rate.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public float getWaitToIneligible()\n        throws AS400SecurityException,\n               ErrorCompletingRequestException,\n               InterruptedException,\n               IOException,\n               ObjectDoesNotExistException,\n               UnsupportedEncodingException\n     {\n       return ((Integer)get(\"waitToIneligible\")).floatValue()/(float)10.0;\n     }\n\n    /**\n     * Returns the current cache status.\n     * The default behavior is no caching.\n     * @return true if caching is enabled, false otherwise.\n     * @see #commitCache\n     * @see #refreshCache\n     * @see #setCaching\n    **/\n    public boolean isCaching()\n    {\n      return cacheChanges_;\n    }\n\n\n    /**\n     * Indicates whether the pool is a shared system pool.\n     * <br>Note: In some cases, this method may incorrectly report <tt>false</tt> for a shared pool; for example, if the object was constructed using {@link #SystemPool(AS400, int) SystemPool(system, poolIdentifier)}, and the pool name is not *MACHINE, *BASE, *INTERACT, *SPOOL, or *SHRPOOL1-60.\n     * @return true if it's a shared system pool, false otherwise.\n    **/\n    public boolean isShared()\n    {\n      return (indicatedSharedPool_ || isValidNameForSharedPool(poolName_)) &&\n        (subsystemLibrary_ == null && subsystemName_ == null &&\n         poolSequenceNumber_ == 0);\n    }\n\n\n     /**\n      * Loads the system pool information.  The system and the system pool\n      * name or identifier should be set before this method is invoked.\n      *\n      * Note: This method is equivalent to the refreshCache() method.\n      *\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n     **/\n     public void loadInformation()\n            throws AS400SecurityException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n     {\n       refreshCache();\n     }\n\n    /*\n     * Refreshes the current system pool information.  The\n     * currently cached data is cleared and new data will\n     * be retrieved from the system when needed.  That is,\n     * after a call to refreshCache(), a call to one of the get() or set()\n     * methods will go to the system to retrieve or set the value.\n     *\n     * Any cached (uncommitted) changes will be lost if not committed by a prior call\n     * to commitCache().\n     *\n     * If caching is not enabled, this method does nothing.\n     * @see #commitCache\n     * @see #isCaching\n     * @see #setCaching\n    **/\n    public synchronized void refreshCache()\n    {\n      // The next time a get() is done, the record data\n      // will be reloaded.\n      poolRecord_ = null;\n\n      // Clear the current cache of (uncommitted) changes.\n      if (changesTable_ != null) changesTable_.clear();\n    }\n\n     /**\n      * Removes a property change listener.\n      *\n      * @param listener The listener.\n      **/\n\n     public void removePropertyChangeListener(PropertyChangeListener listener)\n     {\n        if(listener==null)\n           throw new NullPointerException(\"listener\");\n        if (changes_ != null) changes_.removePropertyChangeListener(listener);\n     }\n\n     /**\n      * Removes a vetoable change listener.\n      *\n      * @param listener The listener.\n      **/\n     public void removeVetoableChangeListener(VetoableChangeListener listener)\n     {\n        if(listener==null)\n           throw new NullPointerException(\"listener\");\n        if (vetos_ != null) vetos_.removeVetoableChangeListener(listener);\n     }\n\n\n  private final static String TEN_BLANKS = \"          \";\n\n  /**\n   * Creates a parameter list for the call to QWCRSSTS.\n  **/\n  private ProgramParameter[] buildParameterList()\n  {\n    AS400Bin4 bin4 = new AS400Bin4();\n    AS400Text text;\n\n    // Note: If we have a pool identifier, or if the pool is identified as a \"shared\" pool, we can use the 7-parameter call.\n    // Otherwise we must use the 5-parameter call.\n\n    int numParms;\n    if (indicatedSharedPool_ || poolIdentifier_ != null)\n    {\n      numParms = 7;\n      if (systemStatusFormat_ == null ||\n          systemStatusFormat_.getClass() != SSTS0400Format.class)\n      {\n        systemStatusFormat_ = new SSTS0400Format(system_);\n        poolFormat_ = new PoolInformationFormat0400(system_);\n      }\n    }\n    else\n    {\n      numParms = 5;\n      if (systemStatusFormat_ == null ||\n          systemStatusFormat_.getClass() != SSTS0300Format.class)\n      {\n        systemStatusFormat_ = new SSTS0300Format(system_);\n        poolFormat_ = new PoolInformationFormat(system_);\n      }\n    }\n    ProgramParameter[] parmList = new ProgramParameter[numParms];\n\n    // Required parameters:\n\n    // Receiver variable\n    int receiverLength = systemStatusFormat_.getNewRecord().getRecordLength();\n    parmList[0] = new ProgramParameter(receiverLength);\n\n    // Length of receiver variable\n    parmList[1] = new ProgramParameter(bin4.toBytes(receiverLength));\n    if (DEBUG) System.out.println(\"QWCRSSTS parm 2: \" + receiverLength);\n\n    // Format name\n    text = new AS400Text(8, system_.getCcsid(), system_);\n    parmList[2] = new ProgramParameter(text.toBytes(systemStatusFormat_.getName()));\n    if (DEBUG) System.out.println(\"QWCRSSTS parm 3: \" + systemStatusFormat_.getName());\n\n    // Reset status statistics\n    text = new AS400Text(10, system_.getCcsid(), system_);\n    parmList[3] = new ProgramParameter(text.toBytes(\"*NO\"));\n    // Note that this parm is ignored for formats SSTS0100 and SSTS0500.\n    if (DEBUG) System.out.println(\"QWCRSSTS parm 4: \" + \"*NO\");\n\n    // Error code\n    byte[] errorInfo = new byte[32];\n    parmList[4] = new ProgramParameter(errorInfo, 0);\n    if (DEBUG) System.out.println(\"QWCRSSTS parm 5: \" + \"0\");\n\n    if (numParms > 5)\n    {\n      // Optional parameters:\n\n      // Pool selection information.\n      // 3 subfields:\n      // typeOfPool (CHAR10) - Possible values are:  *SHARED, *SYSTEM.\n      // sharedPoolName (CHAR10) - Possible values are:  *ALL, *MACHINE, *BASE, *INTERACT, *SPOOL, *SHRPOOL1-60.  If type of pool is *SYSTEM, then this field must be blank.\n      // systemPoolIdentifier (BIN4) - If typeOfPool is *SHARED, must be zero.  Otherwise: -1 for \"all active pools\"; 1-64 to specify an active pool.  If the pool is not active, CPF186B is sent.\n\n      // Note: The typeOfPool field simply indicates _how_ we are identifying the pool in this API: Either by shared-pool name, or by system pool identifier.\n      String typeOfPool = (indicatedSharedPool_ ? \"*SHARED   \" : \"*SYSTEM   \");\n\n      StringBuffer sharedPoolName = new StringBuffer(indicatedSharedPool_ ? poolName_ : \"\");\n      if (sharedPoolName.length() < 10) {\n        int numPadBytes = 10 - sharedPoolName.length();\n        sharedPoolName.append(TEN_BLANKS.substring(10-numPadBytes));  // pad field to a length of 10 chars\n      }\n\n      int systemPoolIdentifier = (indicatedSharedPool_ ? 0 : poolIdentifier_.intValue());\n\n      byte[] poolType = text.toBytes(typeOfPool);\n      byte[] poolNam  = text.toBytes(sharedPoolName.toString());\n      byte[] poolId = BinaryConverter.intToByteArray(systemPoolIdentifier);\n      byte[] poolSelectionInformation = new byte[24];\n      System.arraycopy(poolType, 0, poolSelectionInformation,  0, 10);\n      System.arraycopy(poolNam,  0, poolSelectionInformation, 10, 10);\n      System.arraycopy(poolId,   0, poolSelectionInformation, 20,  4);\n      parmList[5] = new ProgramParameter(poolSelectionInformation);\n      if (Trace.isTraceOn())\n      {\n        Trace.log(Trace.DIAGNOSTIC, \"QWCRSSTS parameter 6: poolType==|\" + typeOfPool +\"| , poolName==|\"+ sharedPoolName.toString() +\"| , poolID==|\"+ systemPoolIdentifier +\"|\");\n      }\n\n      // Size of pool selection information.\n      // Valid values are 0, 20, or 24\n      parmList[6] = new ProgramParameter(bin4.toBytes(24));  // size is 24 bytes\n      if (DEBUG) System.out.println(\"QWCRSSTS parm 7: \" + \"24\");\n    }\n\n    return parmList;\n  }\n\n\n    /**\n     * Indicates whether the pool name is a valid name for a shared system pool.\n     * <br>Note: In some cases, this method may incorrectly report <tt>false</tt> for a name that actually specifies a shared pool; for example, for a shared pool with a non-standard name.\n     * @return true if poolName is *MACHINE, *BASE, *INTERACT, *SPOOL, or *SHRPOOLxx; false otherwise.\n    **/\n  public static final boolean isValidNameForSharedPool(String name)\n  {\n    if (name == null) return false;\n    if (name.equals(\"*ALL\") ||\n        name.equals(\"*MACHINE\") ||\n        name.equals(\"*BASE\") ||\n        name.equals(\"*INTERACT\") ||\n        name.equals(\"*SPOOL\") ||\n        name.startsWith(\"*SHRPOOL\"))\n      return true;\n    else return false;\n  }\n\n\n  /**\n   * Loads pool data from the system using the SSTS0300 or SSTS0400 format.\n   * If the information is already cached, this method does nothing.\n  **/\n  private void retrieveInformation()\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n  {\n    // Check to see if the format has been loaded already\n    if (poolRecord_ != null) return;\n\n    if (!connected_) connect();\n\n    QSYSObjectPathName prgName = new QSYSObjectPathName(\"QSYS\",\"QWCRSSTS\",\"PGM\");\n    ProgramParameter[] parmList = buildParameterList();\n\n    ProgramCall pgm = new ProgramCall(system_);\n    try\n    {\n      pgm.setProgram(prgName.getPath(), parmList);\n    }\n    catch(PropertyVetoException pve) {} // Quiet the compiler\n\n    if (Trace.isTraceOn())\n    {\n      Trace.log(Trace.DIAGNOSTIC, \"Retrieving system pool information.\");\n    }\n    if (pgm.run() != true)\n    {\n      AS400Message[] msgList = pgm.getMessageList();\n      if (Trace.isTraceOn())\n      {\n        Trace.log(Trace.ERROR, \"Error retrieving system pool information:\");\n        for (int i=0; i<msgList.length; ++i)\n        {\n          Trace.log(Trace.ERROR, msgList[i].toString());\n        }\n      }\n      if ((poolIdentifier_==null) && !isValidNameForSharedPool(poolName_)) {\n        Trace.log(Trace.ERROR, \"Invalid name for shared pool: \"+poolName_);\n        throw new ObjectDoesNotExistException(poolName_, ObjectDoesNotExistException.OBJECT_DOES_NOT_EXIST);\n      }\n      else throw new AS400Exception(msgList);\n    }\n    byte[] retrievedData = parmList[0].getOutputData();\n    Record rec = systemStatusFormat_.getNewRecord(retrievedData);\n    // It's possible we didn't retrieve all of the pools.\n    // We may need to increase the fields in the record format to\n    // hold more pool information and then do the API call again.\n    if (resizeFormat(rec))\n    {\n      // Now hopefully we have a big enough byte array.\n      // Try the API call again.\n      retrieveInformation();\n      return;\n    }\n\n    // Now determine which system pool we are out of the list.\n    // This is the data returned on the API.\n    int offsetToInfo = ((Integer)rec.getField(\"offsetToPoolInformation\")).intValue();\n    int numPools = ((Integer)rec.getField(\"numberOfPools\")).intValue();\n    int entryLength = ((Integer)rec.getField(\"lengthOfPoolInformationEntry\")).intValue();\n    byte[] data = rec.getContents();\n    if (Trace.isTraceOn())\n    {\n      Trace.log(Trace.DIAGNOSTIC, \"Parsing out \"+numPools+\" system pools with \"+entryLength+\" bytes each starting at offset \"+offsetToInfo+\" for a maximum length of \"+data.length+\".\");\n    }\n\n    // Get each of the pools out of the data, and check to see which one is me.\n\n    for (int i=0; i<numPools; ++i)\n    {\n      int offset = offsetToInfo + i*entryLength;\n      Record pool = poolFormat_.getNewRecord(data, offset);\n      if (Trace.isTraceOn())\n      {\n        Trace.log(Trace.DIAGNOSTIC, \"Parsed pool at offset \"+offset+\": \"+pool.toString());\n      }\n      String returnedName = ((String)pool.getField(\"poolName\")).trim();\n      Integer poolIdentifier = ((Integer)pool.getField(\"poolIdentifier\"));\n\n      // If we know the system pool identifier, just need to match that.\n      if (poolIdentifier_ != null)\n      {\n        if (poolIdentifier_.equals(poolIdentifier))\n        {\n          if (Trace.isTraceOn()) {\n            Trace.log(Trace.DIAGNOSTIC, \"Found matching system pool '\"+poolName_+\"'\");\n          }\n\n          poolRecord_ = pool;\n          return;\n        }\n      }\n      else  // The caller didn't specify the system pool identifier, so we need to uniquely identify the pool some other way.\n      {\n        if (indicatedSharedPool_)\n        {\n          // It's a shared system pool, so it's uniquely identified by the pool name.\n          if (DEBUG) {\n            System.out.println(\"Looking for poolName==\"+poolName_+\", got: \" + returnedName);\n          }\n          if (returnedName.equals(poolName_))\n          {\n            if (Trace.isTraceOn()) {\n              Trace.log(Trace.DIAGNOSTIC, \"Found matching system pool '\"+poolName_+\"'\");\n            }\n\n            poolRecord_ = pool;\n            if (poolIdentifier_ == null) poolIdentifier_ = poolIdentifier;\n            return;\n          }\n        }\n        else  // The caller didn't indicate it's a shared pool, and didn't specify a system pool identifier.\n        {\n          // It's a subsystem pool, so poolName is actually the pool's sequence number within the subsystem (1-10).\n          // Need to match subsystem library and name, and pool name (pool sequence number).\n          String subsysName = ((String)pool.getField(\"subsystemName\")).trim();\n          String subsysLib = ((String)pool.getField(\"subsystemLibraryName\")).trim();\n          if (DEBUG) {\n            System.out.println(\"Returned subsysLib: |\" + subsysLib + \"|\");\n            System.out.println(\"Returned subsysName: |\" + subsysName + \"|\");\n            System.out.println(\"Returned poolName: |\" + returnedName + \"|\");\n          }\n\n          if (subsysName.equalsIgnoreCase(subsystemName_) &&\n              subsysLib.equalsIgnoreCase(subsystemLibrary_))\n          {\n            // We've matched the subsystem.  Now match the sequence number.\n            if (DEBUG) System.out.println(\"Matched the subsystem.  Looking for subsys pool sequence number \" + poolName_ + \", got \" + returnedName);\n            if (returnedName.equals(poolName_))\n            {\n              poolRecord_ = pool;\n              if (poolIdentifier_ == null) poolIdentifier_ = poolIdentifier;\n              return;\n            }\n            else {\n              if (DEBUG) {\n                System.out.println(\"Mismatched subsystem library/name.  Expected: \" + subsystemLibrary_+\"/\"+subsystemName_+\"/\"+poolName_ + \", got \" + subsysLib+\"/\"+subsysName+\"/\"+returnedName + \")\");\n              }\n              continue;  // not a match, so keep looking through the list\n            }\n          }\n        }\n      }\n\n    }  // 'for' loop\n\n    Trace.log(Trace.ERROR, \"System pool '\"+poolName_+\"' not found.\");\n    throw new ObjectDoesNotExistException(poolName_, ObjectDoesNotExistException.OBJECT_DOES_NOT_EXIST);\n  }\n\n\n  /**\n   * Adjusts the 0300 or 0400 format to be large enough to hold all of the\n   * information returned on the API call.\n   * @return true if the format was resized.\n  **/\n  private boolean resizeFormat(Record rec)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n  {\n    int available = ((Integer)rec.getField(\"numberOfBytesAvailable\")).intValue();\n    int returned = ((Integer)rec.getField(\"numberOfBytesReturned\")).intValue();\n    if (Trace.isTraceOn())\n    {\n      Trace.log(Trace.DIAGNOSTIC, \"Size check of System Status format: \"+available+\", \"+returned);\n      int numPools = ((Integer)rec.getField(\"numberOfPools\")).intValue();\n      int offset = ((Integer)rec.getField(\"offsetToPoolInformation\")).intValue();\n      int entryLength = ((Integer)rec.getField(\"lengthOfPoolInformationEntry\")).intValue();\n      Trace.log(Trace.DIAGNOSTIC, \"  Old pool information: \"+numPools+\", \"+offset+\", \"+entryLength+\", \"+rec.getRecordLength());\n    }\n    // Only resize the format if we didn't get all the info.\n    // The resize should happen no more than once per API call.\n    if (available > returned)\n    {\n      int numPools = ((Integer)rec.getField(\"numberOfPools\")).intValue();\n      int offset = ((Integer)rec.getField(\"offsetToPoolInformation\")).intValue();\n      int entryLength = ((Integer)rec.getField(\"lengthOfPoolInformationEntry\")).intValue();\n      // Make the byte array big enough to hold the pool information.\n      int baseLength = systemStatusFormat_.getNewRecord().getRecordLength();\n      int newLength = numPools*entryLength + (offset-baseLength);\n      systemStatusFormat_.addFieldDescription(new HexFieldDescription(new AS400ByteArray(newLength), \"poolInformation\"));\n      if (Trace.isTraceOn())\n      {\n        Trace.log(Trace.DIAGNOSTIC, \"Resizing System Status format to hold more system pool information.\");\n        Trace.log(Trace.DIAGNOSTIC, \"  New pool information: \"+baseLength+\", \"+newLength+\", \"+systemStatusFormat_.getNewRecord().getRecordLength());\n      }\n      return true;\n    }\n    return false;\n  }\n\n\n    /**\n     * Sets the value for the specified field to value in the\n     * appropriate record in the format cache.\n    **/\n    private void set(String field, Object value)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   PropertyVetoException,\n                   UnsupportedEncodingException\n\n    {\n      // Set the info into our own record\n      Object oldValue = null;\n      if ((vetos_ != null || changes_ != null) &&\n          changesTable_ != null) {\n        oldValue = changesTable_.get(field);\n      }\n      if (vetos_ != null) vetos_.fireVetoableChange(field, oldValue, value);\n      if (changesTable_ == null) changesTable_ = new Hashtable(11);\n      changesTable_.put(field, value);\n      if (changes_ != null) changes_.firePropertyChange(field, oldValue, value);\n      if (!cacheChanges_) commitCache();\n    }\n\n\n    /**\n     * Turns caching on or off.\n     * If caching is turned off, the next get() or set() will go to the system.\n     * @param cache true if caching should be used when getting\n     *              and setting information to and from the system; false\n     *              if every get or set should communicate with the system\n     *              immediately.  Any cached changes that are not committed\n     *              when caching is turned off will be lost.\n     *              The default behavior is no caching.\n     * @see #commitCache\n     * @see #isCaching\n     * @see #refreshCache\n    **/\n    public synchronized void setCaching(boolean cache)\n    {\n      cacheChanges_ = cache;\n    }\n\n\n     /**\n      * Sets the minimum faults-per-second guideline, the faults per second for each active thread,\n      * and the maximum faults-per-second guideline for this storage pool.\n      * The sum of minimum faults and per-thread faults must be less than the\n      * value of the maximum faults parameter.  Each value is used by the\n      * system if the performance adjustment (QPFRADJ) system value is set to\n      * 2 or 3.\n      * <br>Note: This method is supported only for shared pools,\n      * not for subsystem (non-shared) pools.\n      *\n      * @param minValue The new minimum faults-per-second guideline.\n      * @param perValue The new faults per second for each active thread.\n      * @param maxValue The new maximum faults-per-second guideline.\n      * @exception AS400Exception If the system returns an error\n      *            message.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ConnectionDroppedException If the connection is dropped\n      *            unexpectedly.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception PropertyVetoException If the change is vetoed.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      * @see #isShared\n      **/\n     public void setFaults(float minValue, float perValue, float maxValue)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   PropertyVetoException,\n                   UnsupportedEncodingException\n     {\n       if (!indicatedSharedPool_) throwUnsupported();\n       if (!cacheChanges_)\n       {\n         synchronized(this)\n         {\n           cacheChanges_ = true;\n           setMinimumFaults(minValue);\n           setPerThreadFaults(perValue);\n           setMaximumFaults(maxValue);\n           commitCache();\n           cacheChanges_ = false;\n         }\n       }\n       else\n       {\n         setMinimumFaults(minValue);\n         setPerThreadFaults(perValue);\n         setMaximumFaults(maxValue);\n       }\n     }\n\n\n     /**\n      * Sets the maximum faults-per-second guideline to use for this storage\n      * pool.  The sum of minimum faults and per-thread faults must be less than the\n      * value of the maximum faults parameter.  This value is used by the\n      * system if the performance adjustment (QPFRADJ) system value is set to\n      * 2 or 3.\n      * <br>Note: This method is supported only for shared pools,\n      * not for subsystem (non-shared) pools.\n      *\n      * @param value The new maximum faults-per-second guideline.\n      * @exception AS400Exception If the system returns an error\n      *            message.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ConnectionDroppedException If the connection is dropped\n      *            unexpectedly.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception PropertyVetoException If the change is vetoed.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      * @see #isShared\n      **/\n     public void setMaximumFaults(float value)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   PropertyVetoException,\n                   UnsupportedEncodingException\n     {\n       if (!indicatedSharedPool_) throwUnsupported();\n       set(\"maximumFaults\", new Float(value));\n     }\n\n     /**\n      * Sets the maximum amount of storage to allocate to this storage pool\n      * (as a percentage of total main storage).  This value cannot be\n      * less than the minimum pool size % parameter value.  This value is used\n      * by the system if the performance adjustment (QPFRADJ) system value\n      * is set to 2 or 3.\n      * <br>Note: This method is supported only for shared pools,\n      * not for subsystem (non-shared) pools.\n      *\n      * @param value The new maximum pool size.\n      * @exception AS400Exception If the system returns an error\n      *            message.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ConnectionDroppedException If the connection is dropped\n      *            unexpectedly.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception PropertyVetoException If the change is vetoed.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      * @see #isShared\n      **/\n     public void setMaximumPoolSize(float value)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   PropertyVetoException,\n                   UnsupportedEncodingException\n     {\n       if (!indicatedSharedPool_) throwUnsupported();\n       set(\"maximumPoolSize\", new Float(value));\n     }\n\n\n     /**\n      * Sets the value indicating whether messages reporting that a change was\n      * made are written to the current job's job log and to the QHST message\n      * log.  This affects the logging of change-related messages only; it does\n      * not affect the logging of error messages.  Valid values are:\n      *<p>\n      *<li> true - Log change messages.\n      *<li> false - Do not log change messages.\n      *</p>\n      *    The default value for messages logging is true.\n      *\n      * @param log The value indicating whether messages reporting that a\n      *              change was made are written to the current job's job log\n      *              and to the QHST message log.\n      * @exception AS400Exception If the system returns an error\n      *            message.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ConnectionDroppedException If the connection is dropped\n      *            unexpectedly.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception PropertyVetoException If the change is vetoed.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public void setMessageLogging(boolean log)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   PropertyVetoException,\n                   UnsupportedEncodingException\n     {\n       set(\"messageLogging\", log ? \"Y\" : \"N\");\n     }\n\n\n     /**\n      * Sets the minimum faults-per-second guideline to use for this storage\n      * pool.  This value is used by the system if the performance adjustment\n      * (QPFRADJ) system value is set to 2 or 3.  If you want the system to\n      * calculate the priority, you must specify -2 for this parameter.  If\n      * you do not want this value to change, you may specify -1 for this\n      * parameter.\n      * <br>Note: This method is supported only for shared pools,\n      * not for subsystem (non-shared) pools.\n      *\n      * @param value The new minumum faults-per-second guideline.\n      *\n      * @exception AS400Exception If the system returns an error\n      *            message.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ConnectionDroppedException If the connection is dropped\n      *            unexpectedly.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception PropertyVetoException If the change is vetoed.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      * @see #isShared\n      **/\n     public void setMinimumFaults(float value)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   PropertyVetoException,\n                   UnsupportedEncodingException\n     {\n       if (!indicatedSharedPool_) throwUnsupported();\n       set(\"minimumFaults\", new Float(value));\n     }\n\n\n     /**\n      * Sets the minimum and maximum amount of storage to allocate to this storage pool\n      * (as a percentage of total main storage).  Maximum value cannot be\n      * less than the minimum pool size % parameter value.  Each value is used\n      * by the system if the performance adjustment (QPFRADJ) system value\n      * is set to 2 or 3.\n      * <br>Note: This method is supported only for shared pools,\n      * not for subsystem (non-shared) pools.\n      *\n      * @param minValue The new minimum pool size.\n      * @param maxValue The new maximum pool size.\n      * @exception AS400Exception If the system returns an error\n      *            message.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ConnectionDroppedException If the connection is dropped\n      *            unexpectedly.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception PropertyVetoException If the change is vetoed.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      * @see #isShared\n      **/\n     public void setMinAndMaxPoolSize(float minValue, float maxValue)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   PropertyVetoException,\n                   UnsupportedEncodingException\n     {\n       if (!indicatedSharedPool_) throwUnsupported();\n       if (!cacheChanges_)\n       {\n         synchronized(this)\n         {\n           cacheChanges_ = true;\n           setMinimumPoolSize(minValue);\n           setMaximumPoolSize(maxValue);\n           commitCache();\n           cacheChanges_ = false;\n         }\n       }\n       else\n       {\n         setMinimumPoolSize(minValue);\n         setMaximumPoolSize(maxValue);\n       }\n     }\n\n\n     /**\n      * Sets the minimum amount of storage to allocate to this storage pool\n      * (as a percentage of total main storage).  This value cannot be\n      * greater than the maximum pool size % parameter value.  This value is\n      * used by the system if the performance adjustment (QPFRADJ) system\n      * value is set to 2 or 3.\n      * <br>Note: This method is supported only for shared pools,\n      * not for subsystem (non-shared) pools.\n      *\n      * @param value  The new minimum pool size.\n      * @exception AS400Exception If the system returns an error\n      *            message.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ConnectionDroppedException If the connection is dropped\n      *            unexpectedly.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception PropertyVetoException If the change is vetoed.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      * @see #isShared\n      **/\n\n     public void setMinimumPoolSize(float value)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   PropertyVetoException,\n                   UnsupportedEncodingException\n     {\n       if (!indicatedSharedPool_) throwUnsupported();\n       set(\"minimumPoolSize\", new Float(value));\n     }\n\n\n     /**\n      * Sets the value indicating whether the system dynamically adjust the\n      * paging characteristics of the storage pool for optimum performance.\n      * Valid values are:\n      *<p>\n      *<li> *SAME  - The paging option for the storage pool is not changed.\n      *<li> *FIXED - The system will not dynamically adjust the paging\n      *               characteristics; system default values are used.\n      *<li> *CALC  - The system will dynamically adjust the paging\n      *               characteristics.\n      *\n      * @param value The value indicating whether the system dynamically adjust\n      *              the paging characteristics of the sorage pool for optimum\n      *              performance.\n      * @exception AS400Exception If the system returns an error\n      *            message.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ConnectionDroppedException If the connection is dropped\n      *            unexpectedly.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception PropertyVetoException If the change is vetoed.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public void setPagingOption(String value)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   PropertyVetoException,\n                   UnsupportedEncodingException\n     {\n       set(\"pagingOption\", value);\n     }\n\n\n     /**\n      * Sets the faults per second for each active thread in this storage\n      * pool.  Each job is comprised of one or more threads.  The system multiples\n      * this number by the number of active threads that it finds in the\n      * pool.  This result is added to the minimum faults parameter to\n      * calculate the faults-per-second guideline to use for this pool.  This\n      * value is used by the system if the performance adjustment (QPFRADJ)\n      * system value is set to 2 or 3.\n      * <br>Note: This method is supported only for shared pools,\n      * not for subsystem (non-shared) pools.\n      *\n      * @param value The new faults.\n      * @exception AS400Exception If the system returns an error\n      *            message.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ConnectionDroppedException If the connection is dropped\n      *            unexpectedly.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception PropertyVetoException If the change is vetoed.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      * @see #isShared\n      **/\n     public void setPerThreadFaults(float value)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   PropertyVetoException,\n                   UnsupportedEncodingException\n     {\n       if (!indicatedSharedPool_) throwUnsupported();\n       set(\"perThreadFaults\", new Float(value));\n     }\n\n\n     /**\n      * Sets the activity level for the pool.  This is the maximum number of\n      * threads that can be active in the pool at any one time.\n      * The activity level of a \"machine\" pool (*MACHINE) cannot be changed.\n      *\n      * @param value The new activity level for the pool.\n      * @exception AS400Exception If the system returns an error\n      *            message.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ConnectionDroppedException If the connection is dropped\n      *            unexpectedly.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception PropertyVetoException If the change is vetoed.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      * @deprecated Use setActivityLevel() instead.\n      **/\n     public void setPoolActivityLevel(int value)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   PropertyVetoException,\n                   UnsupportedEncodingException\n     {\n       setActivityLevel(value);\n     }\n\n\n     /**\n      * Sets the activity level for the pool.  This is the maximum number of\n      * threads that can be active in the pool at any one time.\n      * The activity level of a \"machine\" pool (*MACHINE) cannot be changed.\n      *\n      * Recommended coding pattern:\n      *  systemPool.setCaching(true);\n      *  systemPool.setSize(size);\n      *  systemPool.setActivityLevel(level);\n      *  systemPool.commitCache();\n      *\n      * @param value The new activity level for the pool.\n      * @exception AS400Exception If the system returns an error\n      *            message.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ConnectionDroppedException If the connection is dropped\n      *            unexpectedly.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception PropertyVetoException If the change is vetoed.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public void setActivityLevel(int value)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   PropertyVetoException,\n                   UnsupportedEncodingException\n     {\n       set(\"activityLevel\", new Integer(value));\n     }\n\n\n     /**\n      * Sets the system pool name.\n      *\n      * @param poolName The name of the system pool.\n      * @exception PropertyVetoException If the change is vetoed.\n      * @deprecated Use setName() instead.\n      **/\n     public void setPoolName(String poolName)\n            throws PropertyVetoException\n     {\n       setName(poolName);\n     }\n\n\n     /**\n      * Sets the system pool name.\n      *\n      * @param poolName The name of the system pool.\n      * @exception PropertyVetoException If the change is vetoed.\n      *\n      **/\n     public void setName(String poolName)\n            throws PropertyVetoException\n     {\n        if (poolName == null)\n            throw new NullPointerException(\"poolName\");\n        if (connected_)\n            throw new ExtendedIllegalStateException(\"poolName\",\n                    ExtendedIllegalStateException.PROPERTY_NOT_CHANGED);\n\n        String oldValue = poolName_;\n        String newValue = poolName.trim();\n        if (vetos_ != null) vetos_.fireVetoableChange(\"poolName\", oldValue, newValue);\n        poolName_ = poolName;\n        if (changes_ != null) changes_.firePropertyChange(\"poolName\", oldValue, newValue);\n     }\n\n\n     /**\n      * Sets the size of the system pool in kilobytes, where one kilobyte is\n      * 1024 bytes.\n      * For shared pools, this specifies the requested (\"defined\") size.\n      * The minimum value is 256 kilobytes.\n      * To indicate that no storage or activity level is defined\n      * for the pool, specify 0.\n      *\n      * @param value The new size of the system pool.\n      * @exception AS400Exception If the system returns an error\n      *            message.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ConnectionDroppedException If the connection is dropped\n      *            unexpectedly.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception PropertyVetoException If the change is vetoed.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      * @deprecated Use setSize() instead.\n      **/\n     public void setPoolSize(int value)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   PropertyVetoException,\n                   UnsupportedEncodingException\n     {\n       setSize(value);\n     }\n\n\n     /**\n      * Sets the size of the system pool in kilobytes, where one kilobyte is\n      * 1024 bytes.\n      * For shared pools, this specifies the requested (\"defined\") size.\n      * The minimum value is 256 kilobytes.\n      * To indicate that no storage or activity level is defined\n      * for the pool, specify 0.\n      *\n      * Recommended coding pattern:\n      *  systemPool.setCaching(true);\n      *  systemPool.setSize(size);\n      *  systemPool.setActivityLevel(level);\n      *  systemPool.commitCache();\n      *\n      * @param value The new size of the system pool.\n      * @exception AS400Exception If the system returns an error\n      *            message.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ConnectionDroppedException If the connection is dropped\n      *            unexpectedly.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception PropertyVetoException If the change is vetoed.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      **/\n     public void setSize(int value)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   PropertyVetoException,\n                   UnsupportedEncodingException\n     {\n       set(\"poolSize\", new Integer(value));\n     }\n\n\n     /**\n      * Sets the priority of this pool relative the priority of the other\n      * storage pools.  Valid values are 1 through 14.  The priority for the\n      * *MACHINE pool must be 1.  This value is used by the system if the\n      * performance adjustment (QPFRADJ) system value is set to 2 or 3.\n      * <br>Note: This method is supported only for shared pools,\n      * not for subsystem (non-shared) pools.\n      *\n      * @param value The new priority.\n      * @exception AS400Exception If the system returns an error\n      *            message.\n      * @exception AS400SecurityException If a security or authority error\n      *            occurs.\n      * @exception ConnectionDroppedException If the connection is dropped\n      *            unexpectedly.\n      * @exception ErrorCompletingRequestException If an error occurs before\n      *            the request is completed.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception IOException If an error occurs while communicating with\n      *            the system.\n      * @exception ObjectDoesNotExistException If the object does not exist on the system.\n      * @exception PropertyVetoException If the change is vetoed.\n      * @exception UnsupportedEncodingException If the character encoding is\n      *            not supported.\n      * @see #isShared\n      **/\n     public void setPriority(int value)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   PropertyVetoException,\n                   UnsupportedEncodingException\n     {\n       if (!indicatedSharedPool_) throwUnsupported();\n       set(\"priority\", new Integer(value));\n     }\n\n\n     /**\n      * Sets the system.\n      * @param system The system.\n      * @exception PropertyVetoException If the change is vetoed.\n      **/\n     public void setSystem(AS400 system)\n            throws PropertyVetoException\n     {\n        if (system == null)\n            throw new NullPointerException(\"system\");\n        if (connected_)\n            throw new ExtendedIllegalStateException(\"system\",\n                    ExtendedIllegalStateException.PROPERTY_NOT_CHANGED);\n\n        AS400 oldValue = system_;\n        AS400 newValue = system;\n        if (vetos_ != null) vetos_.fireVetoableChange(\"system\", oldValue,newValue);\n        system_ = system;\n        if (changes_ != null) changes_.firePropertyChange(\"system\", oldValue,newValue);\n     }\n\n\n     /**\n      * Return the pool name.\n      *\n      * @return The pool name.\n      **/\n     public String toString()\n     {\n       StringBuffer buf = new StringBuffer(super.toString());\n       if (poolName_ != null || subsystemName_ != null || poolIdentifier_ != null)\n       {\n         if (subsystemName_ != null) {\n           buf.append(\"[\"+subsystemLibrary_+\"/\"+subsystemName_+\"/\"+poolSequenceNumber_+\"]\");\n         }\n         else if (poolName_ != null) {\n           buf.append(\"[\"+poolName_+\"]\");\n         }\n         else if (poolIdentifier_ != null) {\n           buf.append(\"[poolID=\"+poolIdentifier_.toString()+\"]\");\n         }\n       }\n       return buf.toString();\n     }\n\n     /**\n\t * Removes an error listener.\n\t *\n\t * @param vSystemPool TODO\n\t * @param listener The listener.\n\t**/\n\tpublic void removeErrorListener (VSystemPool vSystemPool, ErrorListener listener)\n\t{\n\t    vSystemPool.errorEventSupport_.removeErrorListener (listener);\n\t}\n\n\tprivate static final void throwUnsupported()\n     {\n       Trace.log(Trace.ERROR, \"Method not supported for subsystem (non-shared) pools.\");\n       throw new UnsupportedOperationException();\n     }\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 3,
                "candidates": [
                    {
                        "lineStart": 1654,
                        "lineEnd": 1698,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method resizeFormat to class SystemStatusFormat",
                        "description": "Move method to com.ibm.as400.access.SystemStatusFormat\nRationale: The resizeFormat method directly manipulates the systemStatusFormat_ object and is responsible for adjusting the format based on the data it retrieves from the Record. This indicates that it is closely related to the functionality of the SystemStatusFormat class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1476,
                        "lineEnd": 1492,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method isValidNameForSharedPool to class AS400CertificateUtilImplNative",
                        "description": "move method to com.ibm.as400.access.AS400CertificateUtilImplNative\nRationale: The method isValidNameForSharedPool deals with validation of pool names, which is likely related to system resources and configurations. AS400CertificateUtilImplNative may handle various utility functions related to AS400 system resources, making it a suitable candidate for this method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 2485,
                        "lineEnd": 2489,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method throwUnsupported to class RequestNotSupportedException",
                        "description": "move method to com.ibm.as400.access.RequestNotSupportedException\nRationale: The method throwUnsupported() is designed to handle unsupported operations, which aligns with the purpose of the RequestNotSupportedException class, making it a suitable target for this method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 25343
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "isValidNameForSharedPool",
                            "method_signature": "public static final boolean isValidNameForSharedPool(String name)",
                            "target_class": "PoolNameValidator",
                            "rationale": "This method is a utility function that validates pool names and does not depend on the state of the SystemPool class. It should be moved to a separate class dedicated to validation logic."
                        },
                        {
                            "method_name": "buildParameterList",
                            "method_signature": "private ProgramParameter[] buildParameterList()",
                            "target_class": "ParameterBuilder",
                            "rationale": "This method constructs a parameter list for API calls and does not rely on the internal state of the SystemPool class. It would be better suited in a dedicated class for building parameters."
                        },
                        {
                            "method_name": "retrieveInformation",
                            "method_signature": "private void retrieveInformation()",
                            "target_class": "SystemPoolRetriever",
                            "rationale": "This method is responsible for retrieving system pool information and could be encapsulated in a separate class that handles all retrieval logic, improving separation of concerns."
                        },
                        {
                            "method_name": "resizeFormat",
                            "method_signature": "private boolean resizeFormat(Record rec)",
                            "target_class": "FormatResizer",
                            "rationale": "This method is focused on resizing data formats and should be moved to a dedicated class that handles format-related operations."
                        },
                        {
                            "method_name": "set",
                            "method_signature": "private void set(String field, Object value)",
                            "target_class": "SystemPoolUpdater",
                            "rationale": "This method modifies the state of the SystemPool and could be better organized in a class that handles updates to system pool attributes."
                        },
                        {
                            "method_name": "connect",
                            "method_signature": "private void connect()",
                            "target_class": "SystemConnectionManager",
                            "rationale": "This method manages the connection to the system and should be moved to a dedicated class that handles all connection-related logic."
                        }
                    ],
                    "llm_response_time": 7849
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "isValidNameForSharedPool",
                            "method_signature": "public static final boolean isValidNameForSharedPool(String name)",
                            "target_class": "PoolNameValidator",
                            "rationale": "This method is a utility function that validates pool names and does not depend on the state of the SystemPool class. It should be moved to a separate class dedicated to validation logic."
                        },
                        {
                            "method_name": "buildParameterList",
                            "method_signature": "private ProgramParameter[] buildParameterList()",
                            "target_class": "ParameterBuilder",
                            "rationale": "This method constructs a parameter list for API calls and does not rely on the internal state of the SystemPool class. It would be better suited in a dedicated class for building parameters."
                        },
                        {
                            "method_name": "retrieveInformation",
                            "method_signature": "private void retrieveInformation()",
                            "target_class": "SystemPoolRetriever",
                            "rationale": "This method is responsible for retrieving system pool information and can be abstracted into a separate class that handles retrieval logic, improving separation of concerns."
                        },
                        {
                            "method_name": "resizeFormat",
                            "method_signature": "private boolean resizeFormat(Record rec)",
                            "target_class": "FormatResizer",
                            "rationale": "This method is focused on resizing data formats and should be moved to a dedicated class that handles format-related operations."
                        },
                        {
                            "method_name": "set",
                            "method_signature": "private void set(String field, Object value)",
                            "target_class": "SystemPoolDataUpdater",
                            "rationale": "This method is responsible for setting values in the system pool and can be moved to a class that manages updates to system pool data."
                        },
                        {
                            "method_name": "connect",
                            "method_signature": "private void connect()",
                            "target_class": "SystemPoolConnector",
                            "rationale": "This method handles the connection logic and should be moved to a dedicated class that manages connections to the system."
                        },
                        {
                            "method_name": "commitCache",
                            "method_signature": "public synchronized void commitCache()",
                            "target_class": "CacheManager",
                            "rationale": "This method manages cache operations and should be moved to a class that specifically handles caching logic."
                        },
                        {
                            "method_name": "refreshCache",
                            "method_signature": "public synchronized void refreshCache()",
                            "target_class": "CacheManager",
                            "rationale": "Similar to commitCache, this method deals with cache management and should be part of a dedicated CacheManager class."
                        }
                    ],
                    "llm_response_time": 8767
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "isValidNameForSharedPool",
                            "method_signature": "public static final boolean isValidNameForSharedPool(String name)",
                            "target_class": "PoolNameValidator",
                            "rationale": "This method is a utility function that validates pool names and does not depend on the state of the SystemPool class. It should be moved to a separate class dedicated to validation logic."
                        },
                        {
                            "method_name": "buildParameterList",
                            "method_signature": "private ProgramParameter[] buildParameterList()",
                            "target_class": "ParameterBuilder",
                            "rationale": "This method constructs a parameter list for API calls and does not rely on the internal state of the SystemPool class. It would be better suited in a dedicated class that handles parameter building."
                        },
                        {
                            "method_name": "retrieveInformation",
                            "method_signature": "private void retrieveInformation()",
                            "target_class": "SystemPoolRetriever",
                            "rationale": "This method is responsible for retrieving system pool information and could be better organized in a separate class that handles retrieval logic, improving separation of concerns."
                        },
                        {
                            "method_name": "resizeFormat",
                            "method_signature": "private boolean resizeFormat(Record rec)",
                            "target_class": "FormatResizer",
                            "rationale": "This method adjusts the format size based on retrieved data and should be moved to a dedicated class that manages format resizing, enhancing code organization."
                        },
                        {
                            "method_name": "throwUnsupported",
                            "method_signature": "private static final void throwUnsupported()",
                            "target_class": "UnsupportedOperationHandler",
                            "rationale": "This method handles unsupported operations and could be better placed in a utility class that manages exceptions and unsupported operations, promoting code reuse."
                        }
                    ],
                    "llm_response_time": 5840
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "isValidNameForSharedPool",
                            "method_signature": "public static final boolean isValidNameForSharedPool(String name)",
                            "target_class": "PoolNameValidator",
                            "rationale": "This method is a utility function that validates pool names and does not depend on the state of the SystemPool class. It should be moved to a separate class dedicated to validation logic."
                        },
                        {
                            "method_name": "buildParameterList",
                            "method_signature": "private ProgramParameter[] buildParameterList()",
                            "target_class": "ParameterBuilder",
                            "rationale": "This method constructs a parameter list for API calls and does not rely on the internal state of the SystemPool class. It would be better suited in a dedicated class for building parameters."
                        },
                        {
                            "method_name": "retrieveInformation",
                            "method_signature": "private void retrieveInformation()",
                            "target_class": "SystemPoolRetriever",
                            "rationale": "This method is responsible for retrieving system pool information and could be encapsulated in a separate class that handles all retrieval logic, improving separation of concerns."
                        },
                        {
                            "method_name": "resizeFormat",
                            "method_signature": "private boolean resizeFormat(Record rec)",
                            "target_class": "FormatResizer",
                            "rationale": "This method is focused on resizing data formats and should be moved to a dedicated class that handles format-related operations."
                        },
                        {
                            "method_name": "set",
                            "method_signature": "private void set(String field, Object value)",
                            "target_class": "SystemPoolUpdater",
                            "rationale": "This method modifies the state of the SystemPool and could be better organized in a class that handles updates to system pool attributes."
                        },
                        {
                            "method_name": "connect",
                            "method_signature": "private void connect()",
                            "target_class": "SystemConnectionManager",
                            "rationale": "This method manages the connection to the system and should be moved to a dedicated class that handles all connection-related logic."
                        },
                        {
                            "method_name": "commitCache",
                            "method_signature": "public synchronized void commitCache()",
                            "target_class": "CacheManager",
                            "rationale": "This method manages cache operations and should be moved to a class that specifically handles caching logic."
                        },
                        {
                            "method_name": "refreshCache",
                            "method_signature": "public synchronized void refreshCache()",
                            "target_class": "CacheManager",
                            "rationale": "Similar to commitCache, this method deals with cache management and should be part of a dedicated CacheManager class."
                        },
                        {
                            "method_name": "throwUnsupported",
                            "method_signature": "private static final void throwUnsupported()",
                            "target_class": "UnsupportedOperationHandler",
                            "rationale": "This method handles unsupported operations and could be better placed in a utility class that manages exceptions and unsupported operations, promoting code reuse."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "retrieveInformation",
                    "commitCache",
                    "refreshCache",
                    "set",
                    "connect",
                    "buildParameterList",
                    "resizeFormat",
                    "isValidNameForSharedPool",
                    "throwUnsupported"
                ],
                "llm_response_time": 2755
            },
            "targetClassMap": {
                "retrieveInformation": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1380,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "commitCache": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1328,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "refreshCache": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3758,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "set": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1241,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "connect": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1277,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "buildParameterList": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3123,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "resizeFormat": {
                    "target_classes": [
                        {
                            "class_name": "SystemStatusFormat",
                            "similarity_score": 0.3921625502580641
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SystemStatusFormat"
                    ],
                    "llm_response_time": 848,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "isValidNameForSharedPool": {
                    "target_classes": [
                        {
                            "class_name": "IFSFileOutputStreamImplProxy",
                            "similarity_score": 0.10828691551553274
                        },
                        {
                            "class_name": "IFSRandomAccessFileImplProxy",
                            "similarity_score": 0.12353221764453988
                        },
                        {
                            "class_name": "LicenseGetInformationRequest",
                            "similarity_score": 0.16407707187377413
                        },
                        {
                            "class_name": "ObjectAlreadyExistsException",
                            "similarity_score": 0.28042186638602346
                        },
                        {
                            "class_name": "ObjectDescriptionEnumeration",
                            "similarity_score": 0.2428413805840603
                        },
                        {
                            "class_name": "RCCallProgramReplyDataStream",
                            "similarity_score": 0.21747038213882963
                        },
                        {
                            "class_name": "RequestNotSupportedException",
                            "similarity_score": 0.26979396338464967
                        },
                        {
                            "class_name": "UserSpaceNativeReadWriteImpl",
                            "similarity_score": 0.06925894983258163
                        },
                        {
                            "class_name": "ZonedDecimalFieldDescription",
                            "similarity_score": 0.309812579314642
                        },
                        {
                            "class_name": "AS400JDBCXADataSourceBeanInfo",
                            "similarity_score": 0.22968121952801915
                        },
                        {
                            "class_name": "DBColumnDescriptorsDataFormat",
                            "similarity_score": 0.33012404754212554
                        },
                        {
                            "class_name": "DQRequestAttributesDataStream",
                            "similarity_score": 0.11437327837539776
                        },
                        {
                            "class_name": "ExtendedIllegalStateException",
                            "similarity_score": 0.2671569200308311
                        },
                        {
                            "class_name": "IFSFileOutputStreamImplRemote",
                            "similarity_score": 0.23242875281108652
                        },
                        {
                            "class_name": "IFSRandomAccessFileImplRemote",
                            "similarity_score": 0.2757521377440787
                        },
                        {
                            "class_name": "PackedDecimalFieldDescription",
                            "similarity_score": 0.3059724138045159
                        },
                        {
                            "class_name": "PSSecureServerSocketContainer",
                            "similarity_score": 0.3193162488948476
                        },
                        {
                            "class_name": "RCRunCommandRequestDataStream",
                            "similarity_score": 0.1197762486694715
                        },
                        {
                            "class_name": "AS400CertificateUsrPrfUtilImpl",
                            "similarity_score": 0.10159839642839164
                        },
                        {
                            "class_name": "AS400CertificateUtilImplNative",
                            "similarity_score": 0.16273021930993714
                        },
                        {
                            "class_name": "AS400CertificateUtilImplRemote",
                            "similarity_score": 0.12570600638694449
                        },
                        {
                            "class_name": "AS400FileRecordDescriptionImpl",
                            "similarity_score": 0.29847659515978225
                        },
                        {
                            "class_name": "DQExchangeAttributesDataStream",
                            "similarity_score": 0.07224968689382254
                        },
                        {
                            "class_name": "IFSTextFileInputStreamBeanInfo",
                            "similarity_score": 0.20092076061667605
                        },
                        {
                            "class_name": "PrintObjectPageInputStreamImpl",
                            "similarity_score": 0.05778573841483405
                        },
                        {
                            "class_name": "PSServerSocketContainerAdapter",
                            "similarity_score": 0.3352483439003025
                        },
                        {
                            "class_name": "RCCallProgramRequestDataStream",
                            "similarity_score": 0.16729969576843023
                        },
                        {
                            "class_name": "VariableLengthFieldDescription",
                            "similarity_score": 0.3636670334262918
                        },
                        {
                            "class_name": "AS400CertificateUserProfileUtil",
                            "similarity_score": 0.357142309857384
                        },
                        {
                            "class_name": "AS400FileRecordDescriptionEvent",
                            "similarity_score": 0.33818523988270044
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "AS400CertificateUtilImplNative",
                        "AS400CertificateUtilImplRemote",
                        "VariableLengthFieldDescription",
                        "AS400CertificateUserProfileUtil",
                        "AS400FileRecordDescriptionEvent",
                        "PSServerSocketContainerAdapter",
                        "DBColumnDescriptorsDataFormat",
                        "PSSecureServerSocketContainer",
                        "ZonedDecimalFieldDescription",
                        "PackedDecimalFieldDescription",
                        "AS400FileRecordDescriptionImpl",
                        "ObjectAlreadyExistsException",
                        "IFSRandomAccessFileImplRemote",
                        "RequestNotSupportedException",
                        "ExtendedIllegalStateException",
                        "ObjectDescriptionEnumeration",
                        "IFSFileOutputStreamImplRemote",
                        "AS400JDBCXADataSourceBeanInfo",
                        "RCCallProgramReplyDataStream",
                        "IFSTextFileInputStreamBeanInfo",
                        "RCCallProgramRequestDataStream",
                        "LicenseGetInformationRequest",
                        "IFSRandomAccessFileImplProxy",
                        "RCRunCommandRequestDataStream",
                        "DQRequestAttributesDataStream",
                        "IFSFileOutputStreamImplProxy",
                        "AS400CertificateUsrPrfUtilImpl",
                        "DQExchangeAttributesDataStream",
                        "UserSpaceNativeReadWriteImpl",
                        "PrintObjectPageInputStreamImpl"
                    ],
                    "llm_response_time": 1184,
                    "similarity_computation_time": 12,
                    "similarity_metric": "cosine"
                },
                "throwUnsupported": {
                    "target_classes": [
                        {
                            "class_name": "IFSFileOutputStreamImplProxy",
                            "similarity_score": 0.3965934444687469
                        },
                        {
                            "class_name": "IFSRandomAccessFileImplProxy",
                            "similarity_score": 0.39727311077192
                        },
                        {
                            "class_name": "LicenseGetInformationRequest",
                            "similarity_score": 0.18814417367671946
                        },
                        {
                            "class_name": "ObjectAlreadyExistsException",
                            "similarity_score": 0.14106912317171966
                        },
                        {
                            "class_name": "ObjectDescriptionEnumeration",
                            "similarity_score": 0.33955886003678853
                        },
                        {
                            "class_name": "RCCallProgramReplyDataStream",
                            "similarity_score": 0.278638002545715
                        },
                        {
                            "class_name": "RequestNotSupportedException",
                            "similarity_score": 0.16538530041390564
                        },
                        {
                            "class_name": "UserSpaceNativeReadWriteImpl",
                            "similarity_score": 0.1125087900926024
                        },
                        {
                            "class_name": "ZonedDecimalFieldDescription",
                            "similarity_score": 0.19336544141146322
                        },
                        {
                            "class_name": "AS400JDBCXADataSourceBeanInfo",
                            "similarity_score": 0.22710998958306755
                        },
                        {
                            "class_name": "DBColumnDescriptorsDataFormat",
                            "similarity_score": 0.168543634268378
                        },
                        {
                            "class_name": "DQRequestAttributesDataStream",
                            "similarity_score": 0.2322443380972059
                        },
                        {
                            "class_name": "ExtendedIllegalStateException",
                            "similarity_score": 0.13715635089726155
                        },
                        {
                            "class_name": "IFSFileOutputStreamImplRemote",
                            "similarity_score": 0.28711245399881463
                        },
                        {
                            "class_name": "IFSRandomAccessFileImplRemote",
                            "similarity_score": 0.21837557435955374
                        },
                        {
                            "class_name": "PackedDecimalFieldDescription",
                            "similarity_score": 0.18835264373920446
                        },
                        {
                            "class_name": "PSSecureServerSocketContainer",
                            "similarity_score": 0.20619857947388243
                        },
                        {
                            "class_name": "RCRunCommandRequestDataStream",
                            "similarity_score": 0.12971494035267078
                        },
                        {
                            "class_name": "AS400CertificateUsrPrfUtilImpl",
                            "similarity_score": 0.09583148474999101
                        },
                        {
                            "class_name": "AS400CertificateUtilImplNative",
                            "similarity_score": 0.22171262104188208
                        },
                        {
                            "class_name": "AS400CertificateUtilImplRemote",
                            "similarity_score": 0.16195576792929983
                        },
                        {
                            "class_name": "AS400FileRecordDescriptionImpl",
                            "similarity_score": 0.05387388869928149
                        },
                        {
                            "class_name": "DQExchangeAttributesDataStream",
                            "similarity_score": 0.21339479988815996
                        },
                        {
                            "class_name": "IFSTextFileInputStreamBeanInfo",
                            "similarity_score": 0.20833333333333337
                        },
                        {
                            "class_name": "PrintObjectPageInputStreamImpl",
                            "similarity_score": 0.05928691667287522
                        },
                        {
                            "class_name": "PSServerSocketContainerAdapter",
                            "similarity_score": 0.17855719466852676
                        },
                        {
                            "class_name": "RCCallProgramRequestDataStream",
                            "similarity_score": 0.19250560684908286
                        },
                        {
                            "class_name": "VariableLengthFieldDescription",
                            "similarity_score": 0.05063696835418334
                        },
                        {
                            "class_name": "AS400CertificateUserProfileUtil",
                            "similarity_score": 0.16357605740209083
                        },
                        {
                            "class_name": "AS400FileRecordDescriptionEvent",
                            "similarity_score": 0.24746411288187445
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "RequestNotSupportedException",
                        "ExtendedIllegalStateException",
                        "IFSRandomAccessFileImplProxy",
                        "IFSFileOutputStreamImplProxy",
                        "ObjectDescriptionEnumeration",
                        "IFSFileOutputStreamImplRemote",
                        "RCCallProgramReplyDataStream",
                        "AS400FileRecordDescriptionEvent",
                        "DQRequestAttributesDataStream",
                        "AS400JDBCXADataSourceBeanInfo",
                        "AS400CertificateUtilImplNative",
                        "IFSRandomAccessFileImplRemote",
                        "DQExchangeAttributesDataStream",
                        "IFSTextFileInputStreamBeanInfo",
                        "PSSecureServerSocketContainer",
                        "ZonedDecimalFieldDescription",
                        "RCCallProgramRequestDataStream",
                        "PackedDecimalFieldDescription",
                        "LicenseGetInformationRequest",
                        "PSServerSocketContainerAdapter",
                        "DBColumnDescriptorsDataFormat",
                        "AS400CertificateUserProfileUtil",
                        "AS400CertificateUtilImplRemote",
                        "ObjectAlreadyExistsException",
                        "RCRunCommandRequestDataStream",
                        "UserSpaceNativeReadWriteImpl",
                        "AS400CertificateUsrPrfUtilImpl",
                        "PrintObjectPageInputStreamImpl",
                        "AS400FileRecordDescriptionImpl",
                        "VariableLengthFieldDescription"
                    ],
                    "llm_response_time": 938,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.resource.ProgramMap::end():void need move com.ibm.as400.access.NetServerSession",
        "class_name": "com.ibm.as400.resource.ProgramMap",
        "telemetry": {
            "id": "3f064fa9-f16f-43ee-9a13-cfb1ff0d0ea5",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 441,
                "lineStart": 30,
                "lineEnd": 470,
                "bodyLineStart": 30,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/small/small/jtopen-7.8/src/com/ibm/as400/resource/ProgramMap.java",
                "sourceCode": "/**\nThe ProgramMap class represents a map between logical values such\nas {@link com.ibm.as400.resource.Resource Resource}\nattribute values and data in a PCML document.  Each logical value is\nreferred to by a logical ID in the map.  A logical value may map to\nmultiple pieces of data in a PCML document.\n\n<p>This class is intended as a helper class for implementing subclasses\nof {@link com.ibm.as400.resource.Resource Resource}.\n@deprecated Use packages <tt>com.ibm.as400.access</tt> and <tt>com.ibm.as400.access.list</tt> instead. \n**/\npublic class ProgramMap\nimplements Serializable\n{\n  private static final String copyright = \"Copyright (C) 1997-2000 International Business Machines Corporation and others.\";\n\n\n\n\n    static final long serialVersionUID = 4L;\n\n\n\n    // Private data.\n    private Hashtable   table_              = new Hashtable();\n    private Object[]    ids_                = null;\n    private Vector      idsV_               = new Vector();\n\n\n\n/**\nAdds a map entry.\n\n@param id               Identifies the logical value.\n@param programName      The program name in the PCML definition.\n@param dataName         The data name in the PCML definition.\n**/\n    public void add(Object id, String programName, String dataName)\n    {\n        // Validate the parameters.\n        if (dataName == null)\n            throw new NullPointerException(\"dataName\");\n\n        add(id, new ProgramMapEntry(programName, dataName, (int[])null, null, null));\n    }\n\n\n\n/**\nAdds a map entry.\n\n@param id               Identifies the logical value.\n@param programName      The program name in the PCML definition.\n@param dataName         The data name in the PCML definition.\n@param valueMap         The value map, or null if there is none.\n**/\n    public void add(Object id, String programName, String dataName, ValueMap valueMap)\n    {\n        // Validate the parameters.\n        if (dataName == null)\n            throw new NullPointerException(\"dataName\");\n\n        add(id, new ProgramMapEntry(programName, dataName, (int[])null, valueMap, null));\n    }\n\n\n\n/**\nAdds a map entry.\n\n@param id               Identifies the logical value.\n@param programName      The program name in the PCML definition.\n@param dataName         The data name in the PCML definition.\n@param valueMap         The value map, or null if there is none.\n@param level            The level where this entry is valid, or null if this\n                        entry is always valid.\n**/\n    public void add(Object id, String programName, String dataName, ValueMap valueMap, ResourceLevel level)\n    {\n        // Validate the parameters.\n        if (dataName == null)\n            throw new NullPointerException(\"dataName\");\n\n        add(id, new ProgramMapEntry(programName, dataName, (int[])null, valueMap, level));\n    }\n\n\n\n/**\nAdds a map entry.\n\n@param id               Identifies the logical value.\n@param programName      The program name in the PCML definition.\n@param dataName         The data name in the PCML definition.\n@param indices          The indices in the PCML definition, or null if there are none.\n**/\n    public void add(Object id, String programName, String dataName, int[] indices)\n    {\n        // Validate the parameters.\n        if (dataName == null)\n            throw new NullPointerException(\"dataName\");\n\n        add(id, new ProgramMapEntry(programName, dataName, indices, null, null));\n    }\n\n\n\n/**\nAdds a map entry for array elements.\n\n@param id               Identifies the logical value.\n@param programName      The program name in the PCML definition.\n@param dataName         The data name in the PCML definition.\n@param countName        The data name in the PCML defintion which specifies\n                        the size of the array.\n@param map         The value map, or null if there is none.\n**/\n    public void add(Object id, String programName, String dataName, String countName, ValueMap map)\n    {\n        // Validate the parameters.\n        if (dataName == null)\n            throw new NullPointerException(\"dataName\");\n\n        add(id, new ProgramMapEntry(programName, dataName, countName, map, null));\n    }\n\n\n\n/**\nAdds a map entry for array elements.\n\n@param id               Identifies the logical value.\n@param programName      The program name in the PCML definition.\n@param dataName         The data name in the PCML definition.\n@param countName        The data name in the PCML defintion which specifies\n                        the size of the array.\n**/\n    public void add(Object id, String programName, String dataName, String countName)\n    {\n        // Validate the parameters.\n        if (dataName == null)\n            throw new NullPointerException(\"dataName\");\n\n        add(id, new ProgramMapEntry(programName, dataName, countName, null, null));\n    }\n\n\n\n/**\nAdds a map entry.\n\n@param id               Identifies the logical value.\n@param programName      The program name in the PCML definition, or null\n                        if it will be filled in later.\n@param dataName         The data name in the PCML definition.\n@param indices          The indices in the PCML definition, or null if there are none.\n@param valueMap         The value map, or null if there is none.\n**/\n    public void add(Object id, String programName, String dataName, int[] indices, ValueMap valueMap)\n    {\n        // Validate the parameters.\n        if (dataName == null)\n            throw new NullPointerException(\"dataName\");\n\n        add(id, new ProgramMapEntry(programName, dataName, indices, valueMap, null));\n    }\n\n\n\n\n/**\nAdds a map entry.\n\n@param id               Identifies the logical value.\n@param entry            The entry.\n**/\n    private synchronized void add(Object id, ProgramMapEntry entry)\n    {\n        // Validate the parameters.\n        if (id == null)\n            throw new NullPointerException(\"id\");\n        if (entry == null)\n            throw new NullPointerException(\"entry\");\n\n        // Add the entry to the table.  The table is a hashtable where the keys\n        // are IDs, and the elements are each a Vector with a list of entries.\n        // This Vector is necessary to account for IDs that map to multiple\n        // entries.\n        Vector entriesV;\n        if (table_.containsKey(id))\n            entriesV = (Vector)table_.get(id);\n        else {\n            entriesV = new Vector();\n            table_.put(id, entriesV);\n        }\n\n        entriesV.addElement(entry);\n        idsV_.addElement(id);\n\n        // Since we changed the list, reset the array to null to force it to be\n        // rebuilt the next time it is needed.\n        ids_ = null;\n    }\n\n\n\n\n/**\nReturns the map entries for a particular logical value.\n\n@param id               Identifies the logical value.\n@return                 The entries.\n**/\n    ProgramMapEntry[] getEntries(Object id)\n    {\n        // Validate the parameter.\n        if (id == null)\n            throw new NullPointerException(\"id\");\n        if (! table_.containsKey(id))\n            throw new ExtendedIllegalArgumentException(\"id\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n\n        // Take the Vector element from the hashtable and turn it\n        // into an array.\n        Vector entriesV = (Vector)table_.get(id);\n        ProgramMapEntry[] entries = new ProgramMapEntry[entriesV.size()];\n        entriesV.copyInto(entries);\n        return entries;\n    }\n\n\n\n/**\nReturns the list of IDs in the map.\n\n@return The list of IDs.\n**/\n    public synchronized Object[] getIDs()\n    {\n        // If the array needs to be created, do so here.\n        // We will keep it around in case its needed again.\n        if (ids_ == null) {\n            ids_ = new Object[idsV_.size()];\n            idsV_.copyInto(ids_);\n        }\n        return ids_;\n    }\n\n\n\n/**\nReturns the list of IDs in the map which match a specific level.\n\n@return The list of IDs.\n**/\n    synchronized Object[] getIDs(String level)\n    {\n        Vector subset = new Vector(idsV_.size());\n        Enumeration enum1 = idsV_.elements();\n        while(enum1.hasMoreElements()) {\n            Object id = enum1.nextElement();\n            Vector entries = (Vector)table_.get(id);\n            Enumeration enum2 = entries.elements();\n            while(enum2.hasMoreElements()) {\n                ProgramMapEntry entry = (ProgramMapEntry)enum2.nextElement();\n                if (entry.getLevel().checkLevel(level)) {\n                    if (!subset.contains(id))\n                        subset.addElement(id);\n                }\n            }\n        }\n\n        Object[] ids = new Object[subset.size()];\n        subset.copyInto(ids);\n        return ids;\n    }\n\n\n\n/**\nGet a set of values from the PCML document and map them to\nthe appropriate logical values.\n\n@param ids              Identifies the logical values.\n@param system           The system.\n@param document         The PCML document.\n@param programName      The PCML program name, or null if\n                        the program name is specified as\n                        part of the entry.\n@param indices          The indices, or null if not applicable,\n                        or if the indices are specified as\n                        part of the entry.\n**/\n    public Object[] getValues(Object[] ids,\n                              AS400 system,\n                              ProgramCallDocument document,\n                              String programName,\n                              int[] indices)\n    throws PcmlException\n    {\n        // Validate the parameters.\n        if (ids == null)\n            throw new NullPointerException(\"ids\");\n        if (document == null)\n            throw new NullPointerException(\"document\");\n\n        int bidiStringType = AS400BidiTransform.getStringType((char)system.getCcsid()); // @A2A\n\n        // Loop for each specified id...\n        Object[] values = new Object[ids.length];\n        for(int i = 0; i < ids.length; ++i) {\n            if (!table_.containsKey(ids[i]))\n                throw new ExtendedIllegalArgumentException(\"ids[\" + i + \"]\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n\n            // Loop for each entry associated with the id...\n            Vector entriesV = (Vector)table_.get(ids[i]);\n            Enumeration entries = entriesV.elements();\n            while(entries.hasMoreElements()) {\n                ProgramMapEntry entry = (ProgramMapEntry)entries.nextElement();\n                String entryProgramName = entry.getProgramName();\n\n                // If no program name was specified here or in the entry,\n                // then use the first entry.\n                if ((programName == null) || (entryProgramName == null)) {\n                    values[i] = entry.getValue(system, document, programName, indices, bidiStringType); // @A2C\n                    break;\n                }\n\n                // Otherwise, find the one that matches.\n                else if (programName.equals(entry.getProgramName())) {\n                    values[i] = entry.getValue(system, document, programName, indices, bidiStringType); // @A2C\n                    break;\n                }\n            }\n\n            // If no value was assigned, it means something is not\n            // quite right with the map.\n            if (values[i] == null)\n                throw new ExtendedIllegalArgumentException(\"values[\" + i + \"]\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        return values;\n    }\n\n\n\n/**\nSet a set of values in the PCML document and map them from\nthe appropriate logical values.\n\n@param ids              Identifies the logical values.\n@param values           The logical values.\n@param system           The system.\n@param document         The PCML document.\n@param programName      The PCML program name, or null if\n                        the program name is specified as\n                        part of the entry.\n@param indices          The indices, or null if not applicable,\n                        or if the indices are specified as\n                        part of the entry.\n@param bidiStringTypes   The bidi string types as defined by the CDRA (Character Data \n                        Representataion Architecture). See \n                        {@link com.ibm.as400.access.BidiStringType BidiStringType}\n                        for more information and valid values. \n**/\n    void setValues(Object[] ids,\n                          Object[] values,\n                          AS400 system,\n                          ProgramCallDocument document,\n                          String programName,\n                          int[] indices,\n                          int[] bidiStringTypes)                        // @A2A\n    throws PcmlException\n    {\n        // Validate the parameters.\n        if (ids == null)\n            throw new NullPointerException(\"ids\");\n        if (values == null)\n            throw new NullPointerException(\"values\");\n        if (ids.length != values.length)\n            throw new ExtendedIllegalArgumentException(\"values\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        if (ids.length != bidiStringTypes.length)\n            throw new ExtendedIllegalArgumentException(\"bidiStringTypes\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        if (document == null)\n            throw new NullPointerException(\"document\");\n\n        // Loop for each specified id...\n        for(int i = 0; i < ids.length; ++i) {\n            if (table_.containsKey(ids[i])) {\n\n                // Loop for each entry associated with the id...\n                Vector entriesV = (Vector)table_.get(ids[i]);\n                Enumeration entries = entriesV.elements();\n                while(entries.hasMoreElements()) {\n                    ProgramMapEntry entry = (ProgramMapEntry)entries.nextElement();\n                    String entryProgramName = entry.getProgramName();\n\n                    // If no program name was specified here or in the entry,\n                    // then use the first entry.\n                    if (programName == null) {\n                        entry.setValue(system, document, entryProgramName, indices, values[i], bidiStringTypes[i]); // @A2C\n                        break;\n                    }\n                    else if (entryProgramName == null) {\n                        entry.setValue(system, document, programName, indices, values[i], bidiStringTypes[i]); // @A2C\n                        break;\n                    }\n\n                    // Otherwise, find the one that matches.\n                    else if (programName.equals(entry.getProgramName())) {\n                        entry.setValue(system, document, programName, indices, values[i], bidiStringTypes[i]); // @A2C\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n\n\n/**\n   Ends the session.\n   This method fires a resourceDeleted() ResourceEvent.\n   <br>This method requires *IOSYSCFG special authority on the system.\n\n   @param netServerSession TODO\n * @exception ResourceException  If an error occurs.\n   **/\n  public void end(NetServerSession netServerSession)\n    throws ResourceException\n  {\n    if (! netServerSession.isConnectionEstablished()) {\n      netServerSession.establishConnection();\n    }\n\n    NetServerSession.endSession(netServerSession.getSystem(), netServerSession.name_);\n    // fireSessionEnded();  // future\n  }\n\n\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 448,
                        "lineEnd": 465,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method end to class NetServerSession",
                        "description": "Move method to com.ibm.as400.access.NetServerSession\nRationale: The end() method directly operates on the NetServerSession instance, checking its connection status and invoking static methods related to session management, making it logical for it to reside within the NetServerSession class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 9558
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getValues",
                            "method_signature": "public Object[] getValues(Object[] ids, AS400 system, ProgramCallDocument document, String programName, int[] indices) throws PcmlException",
                            "target_class": "PCMLDocumentHandler",
                            "rationale": "The getValues method is responsible for retrieving values from a PCML document based on logical IDs. It would be more appropriate for this method to reside in a class that specifically handles interactions with PCML documents."
                        },
                        {
                            "method_name": "setValues",
                            "method_signature": "void setValues(Object[] ids, Object[] values, AS400 system, ProgramCallDocument document, String programName, int[] indices, int[] bidiStringTypes) throws PcmlException",
                            "target_class": "PCMLDocumentHandler",
                            "rationale": "The setValues method is responsible for setting values in a PCML document based on logical IDs. This functionality should be encapsulated in a class dedicated to managing PCML document operations."
                        },
                        {
                            "method_name": "end",
                            "method_signature": "public void end(NetServerSession netServerSession) throws ResourceException",
                            "target_class": "SessionManager",
                            "rationale": "The end method manages the lifecycle of a network server session. It should be moved to a class that is responsible for session management to adhere to the Single Responsibility Principle."
                        }
                    ],
                    "llm_response_time": 3449
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "getValues",
                            "method_signature": "public Object[] getValues(Object[] ids, AS400 system, ProgramCallDocument document, String programName, int[] indices) throws PcmlException",
                            "target_class": "PCMLDocumentHandler",
                            "rationale": "The getValues method is responsible for retrieving values from a PCML document based on logical IDs. It would be more appropriate to move this method to a class that specifically handles interactions with PCML documents."
                        },
                        {
                            "method_name": "setValues",
                            "method_signature": "void setValues(Object[] ids, Object[] values, AS400 system, ProgramCallDocument document, String programName, int[] indices, int[] bidiStringTypes) throws PcmlException",
                            "target_class": "PCMLDocumentHandler",
                            "rationale": "The setValues method is responsible for setting values in a PCML document based on logical IDs. It would be more appropriate to move this method to a class that specifically handles interactions with PCML documents."
                        },
                        {
                            "method_name": "end",
                            "method_signature": "public void end(NetServerSession netServerSession) throws ResourceException",
                            "target_class": "SessionManager",
                            "rationale": "The end method is related to managing the lifecycle of a network server session. It should be moved to a dedicated class that handles session management."
                        }
                    ],
                    "llm_response_time": 2726
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "getValues",
                            "method_signature": "public Object[] getValues(Object[] ids, AS400 system, ProgramCallDocument document, String programName, int[] indices) throws PcmlException",
                            "target_class": "PCMLDocumentHandler",
                            "rationale": "The getValues method is responsible for retrieving values from a PCML document, which suggests that it should be part of a class that specifically handles operations related to PCML documents."
                        },
                        {
                            "method_name": "setValues",
                            "method_signature": "void setValues(Object[] ids, Object[] values, AS400 system, ProgramCallDocument document, String programName, int[] indices, int[] bidiStringTypes) throws PcmlException",
                            "target_class": "PCMLDocumentHandler",
                            "rationale": "The setValues method is responsible for setting values in a PCML document, indicating that it should belong to a class dedicated to managing PCML document interactions."
                        },
                        {
                            "method_name": "end",
                            "method_signature": "public void end(NetServerSession netServerSession) throws ResourceException",
                            "target_class": "SessionManager",
                            "rationale": "The end method manages the termination of a network server session, which is more aligned with session management responsibilities and should be moved to a dedicated SessionManager class."
                        }
                    ],
                    "llm_response_time": 2693
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getValues",
                            "method_signature": "public Object[] getValues(Object[] ids, AS400 system, ProgramCallDocument document, String programName, int[] indices) throws PcmlException",
                            "target_class": "PCMLDocumentHandler",
                            "rationale": "The getValues method is responsible for retrieving values from a PCML document based on logical IDs. It would be more appropriate for this method to reside in a class that specifically handles interactions with PCML documents."
                        },
                        {
                            "method_name": "setValues",
                            "method_signature": "void setValues(Object[] ids, Object[] values, AS400 system, ProgramCallDocument document, String programName, int[] indices, int[] bidiStringTypes) throws PcmlException",
                            "target_class": "PCMLDocumentHandler",
                            "rationale": "The setValues method is responsible for setting values in a PCML document based on logical IDs. This functionality should be encapsulated in a class dedicated to managing PCML document operations."
                        },
                        {
                            "method_name": "end",
                            "method_signature": "public void end(NetServerSession netServerSession) throws ResourceException",
                            "target_class": "SessionManager",
                            "rationale": "The end method manages the lifecycle of a network server session. It should be moved to a class that is responsible for session management to adhere to the Single Responsibility Principle."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "getValues",
                    "setValues",
                    "end"
                ],
                "llm_response_time": 609
            },
            "targetClassMap": {
                "getValues": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1577,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "setValues": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1269,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "end": {
                    "target_classes": [
                        {
                            "class_name": "NetServerSession",
                            "similarity_score": 0.5458866584325098
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "NetServerSession"
                    ],
                    "llm_response_time": 673,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.access.ActionCompletedEvent::actionCompleted(ActionCompletedEvent):void need move com.ibm.as400.vaccess.ActionCompletedEventSupport",
        "class_name": "com.ibm.as400.access.ActionCompletedEvent",
        "telemetry": {
            "id": "0f40570c-44f3-495f-b7b7-95e27c653798",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 32,
                "lineStart": 20,
                "lineEnd": 51,
                "bodyLineStart": 20,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/small/small/jtopen-7.8/src/com/ibm/as400/access/ActionCompletedEvent.java",
                "sourceCode": "/**\n The ActionCompletedEvent class represents an ActionCompleted event.\n **/\npublic class ActionCompletedEvent extends EventObject\n{\n  private static final String copyright = \"Copyright (C) 1997-2000 International Business Machines Corporation and others.\";\n\n\n\n    static final long serialVersionUID = 4L;\n\n\n    /**\n     Constructs an ActionCompletedEvent object.  It uses the specified source object that completed the action.\n     @param  source  The object where the event originated.\n     **/\n    public ActionCompletedEvent(Object source)\n    {\n        super(source);\n    }\n\n\n\t/**\n\tProcesses an action completed event.\n\t\n\t@param actionCompletedEventSupport TODO\n\t**/\n\tpublic void actionCompleted (ActionCompletedEventSupport actionCompletedEventSupport)\n\t{\n\t    actionCompletedEventSupport.fireActionCompleted ();\n\t}\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 41,
                        "lineEnd": 49,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method actionCompleted to class ActionCompletedEventSupport",
                        "description": "Move method to com.ibm.as400.vaccess.ActionCompletedEventSupport\nRationale: The method actionCompleted directly interacts with the ActionCompletedEventSupport instance, making it more appropriate for this method to reside within the ActionCompletedEventSupport class, as it processes an event related to that class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 3646
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "actionCompleted",
                            "method_signature": "public void actionCompleted(ActionCompletedEventSupport actionCompletedEventSupport)",
                            "target_class": "ActionCompletedEventSupport",
                            "rationale": "The actionCompleted() method is responsible for processing the event and interacting with ActionCompletedEventSupport, which suggests that it belongs in that class to maintain separation of concerns."
                        }
                    ],
                    "llm_response_time": 1115
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "actionCompleted",
                            "method_signature": "public void actionCompleted(ActionCompletedEventSupport actionCompletedEventSupport)",
                            "target_class": "ActionCompletedEventSupport",
                            "rationale": "The actionCompleted() method is responsible for processing the event and interacting with ActionCompletedEventSupport, which suggests that it belongs in that class to maintain separation of concerns."
                        }
                    ],
                    "llm_response_time": 918
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "actionCompleted",
                            "method_signature": "public void actionCompleted(ActionCompletedEventSupport actionCompletedEventSupport)",
                            "target_class": "ActionCompletedEventSupport",
                            "rationale": "The actionCompleted() method is responsible for processing the event and interacting with ActionCompletedEventSupport, which suggests that it belongs in that class to maintain separation of concerns."
                        }
                    ],
                    "llm_response_time": 920
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "actionCompleted",
                            "method_signature": "public void actionCompleted(ActionCompletedEventSupport actionCompletedEventSupport)",
                            "target_class": "ActionCompletedEventSupport",
                            "rationale": "The actionCompleted() method is responsible for processing the event and interacting with ActionCompletedEventSupport, which suggests that it belongs in that class to maintain separation of concerns."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "actionCompleted"
                ],
                "llm_response_time": 502
            },
            "targetClassMap": {
                "actionCompleted": {
                    "target_classes": [
                        {
                            "class_name": "ActionCompletedEventSupport",
                            "similarity_score": 0.42833666034776985
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ActionCompletedEventSupport"
                    ],
                    "llm_response_time": 783,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.access.SequentialFile::getFileName():String need move com.ibm.as400.vaccess.RecordListData",
        "class_name": "com.ibm.as400.access.SequentialFile",
        "telemetry": {
            "id": "d4754116-2ac2-451b-b456-93a12c4da186",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 459,
                "lineStart": 23,
                "lineEnd": 481,
                "bodyLineStart": 23,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/small/small/jtopen-7.8/src/com/ibm/as400/access/SequentialFile.java",
                "sourceCode": "/**\n *The SequentialFile class represents a physical or logical file on the system.\n *The SequentialFile class allows the user to do the following:\n *<ul>\n *<li>Create a physical file by:\n *<ul>\n *<li>Specifying a record length.\n *<li>Specifying an existing DDS source file.\n *<li>Specifying a RecordFormat object that contains a description of the\n *    record format for the file.\n *</ul>\n *<li>Access the records in a file sequentially or by record number.\n * Note: To read a keyed physical or logical file sequentially and have the records\n * returned in key order, use the <tt>read...()</tt> methods of {@link KeyedFile KeyedFile}.\n *<li>Write records to a file sequentially.\n *<li>Update records in a file sequentially or by record number.\n *<li>Lock a file for different types of access.\n *<li>Use commitment control when accessing a file.  The user can:\n *<ul>\n *<li>Start commitment control for the connection.\n *<li>Specify different commitment control lock levels for the individual\n *    files being accessed.\n *<li>Commit and rollback transactions for the connection.\n *</ul>\n *<li>Delete a physical or logical file or member.\n *</ul>\n *SequentialFile objects generate the following events:\n *<ul>\n *<li><a href=\"FileEvent.html\">FileEvent</a>\n *<br>The events fired are:\n *<ul>\n *<li>FILE_CLOSED\n *<li>FILE_CREATED\n *<li>FILE_DELETED\n *<li>FILE_MODIFIED\n *<li>FILE_OPENED\n *</ul>\n *<li>PropertyChangeEvent\n *<li>VetoableChangeEvent\n *</ul>\n *@see MemberList\n**/\npublic class SequentialFile extends AS400File implements Serializable\n{\n    static final long serialVersionUID = 4L;\n\n\n\n  /**\n   *Constructs a SequentialFile object.\n  **/\n  public SequentialFile()\n  {\n\n  }\n\n  /**\n   *Constructs a SequentialFile object. It uses the\n   * system and file name specified.\n   *If the <i>name</i> for the file does not include a member, the\n   *first member of the file will be used.\n   *@param system The system to which to connect. The <i>system</i> cannot\n   *be null.\n   *@param name The integrated file system pathname of the file. The <i>name</i>\n   *cannot be null.\n  **/\n  public SequentialFile(AS400 system, String name)\n  {\n    super(system, name);\n  }\n\n  /**\n   *Deletes the record specified by record number.  The file must be open when\n   *invoking this method.\n   *@param recordNumber The record number of the record to be deleted.\n   *@exception AS400Exception If the system returns an error message.\n   *@exception AS400SecurityException If a security or authority error occurs.\n   *@exception ConnectionDroppedException If the connection is dropped unexpectedly.\n   *@exception InterruptedException If this thread is interrupted.\n   *@exception IOException If an error occurs while communicating with the system.\n  **/\n  public void deleteRecord(int recordNumber)\n    throws AS400Exception,\n           AS400SecurityException,\n           InterruptedException,\n           IOException\n  {\n    // Find the record\n    positionCursor(recordNumber);\n    // Call super to delete it\n    deleteCurrentRecord();\n  }\n\n  //@C0D - moved open(...) code to base class\n  /**\n   *Opens the file.  The file must not be open when invoking this method.\n   *If commitment control is not started for the connection,\n   *<i>commitLockLevel</i> is ignored.  The file cursor is positioned prior\n   *to the first record.  If <i>blockingFactor</i> is greater than one (or\n   *if zero is specified and a blocking factor greater than one is determined\n   *by the object) and the file is opened for READ_ONLY, the record cache will\n   *be filled with an initial set of records.<br>\n   *The record format for the file must be set prior to calling this method.<br>\n   *The name of the file and the system to which to connect must be set prior\n   *to invoking this method.\n   *@see AS400File#AS400File(com.ibm.as400.access.AS400, java.lang.String)\n   *@see AS400File#setPath\n   *@see AS400File#setSystem\n   *@see AS400File#refreshRecordCache\n   *@see AS400File#setRecordFormat\n   *@param openType The manner in which to open the file.  Valid values are:\n   *                <ul>\n   *                <li>READ_ONLY\n   *                <li>READ_WRITE\n   *                <li>WRITE_ONLY\n   *                </ul>\n   *@param blockingFactor The number of records to retrieve or to write during a\n   *read or write operation.<br>\n   *The AS400File object will attempt to anticipate the need for data by accessing\n   *blocks of records if the <i>openType</i> is READ_ONLY.  If the <i>openType</i>\n   *is WRITE_ONLY, <i>blockingFactor</i> number of records will be written at one\n   *time when writing an array of records.\n   *If the open type is READ_WRITE, <i>blockingFactor</i> is ignored and a\n   *blocking factor of 1 will be used for data integrity reasons.\n   *Specify an appropriate <i>blockingFactor</i> for your performance needs.<br>\n   *If 0 is specified for <i>blockingFactor</i>, a default value will be calculated\n   *by taking the integer result of dividing 2048 by the byte length of the record\n   *plus 16.<br>\n   *If the user either specifies a blocking factor greater than 1 or specifies 0,\n   *which will cause a blocking factor to be calculated, there is the risk of\n   *obtaining stale data when doing multiple read operations.\n   *Invoke the refreshRecordCache() method prior to reading a record to cause the object\n   *to read from the system if this is a problem.<br>\n   *@param commitLockLevel Used to control record locking during a transaction if\n   *commitment control has been started for the connection.\n   *Valid values are:\n   *<ul>\n   *<li>COMMIT_LOCK_LEVEL_ALL\n   *<li>COMMIT_LOCK_LEVEL_CHANGE\n   *<li>COMMIT_LOCK_LEVEL_CURSOR_STABILITY\n   *<li>COMMIT_LOCK_LEVEL_DEFAULT\n   *<li>COMMIT_LOCK_LEVEL_NONE\n   *</ul>\n   *The <i>commitLockLevel</i> is ignored if commitment control is not started for\n   *the connection.\n   *@exception AS400Exception If the system returns an error message.\n   *@exception AS400SecurityException If a security or authority error occurs.\n   *@exception ConnectionDroppedException If the connection is dropped unexpectedly.\n   *@exception InterruptedException If this thread is interrupted.\n   *@exception IOException If an error occurs while communicating with the system.\n   *@exception ServerStartupException If the host server cannot be started.\n   *@exception UnknownHostException If the system cannot be located.\n  **/\n/*@C0D  public void open(int openType, int blockingFactor, int commitLockLevel)\n    throws AS400Exception,\n           AS400SecurityException,\n           InterruptedException,\n           IOException\n  {\n    // Verify the object state\n    if (recordFormat_ == null)\n    {\n      throw new ExtendedIllegalStateException(\"recordFormat\", ExtendedIllegalStateException.PROPERTY_NOT_SET);\n    }\n    // Verify the parameters\n    if (openType != READ_ONLY &&\n        openType != READ_WRITE &&\n        openType != WRITE_ONLY)\n    {\n      throw new ExtendedIllegalArgumentException(\"openType\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n    }\n    if (blockingFactor < 0)\n    {\n      throw new ExtendedIllegalArgumentException(\"blockingFactor\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n    }\n    if (commitLockLevel < 0 || commitLockLevel > 4)\n    {\n      throw new ExtendedIllegalArgumentException(\"commitLockLevel\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n    }\n\n    openFile(openType, blockingFactor, commitLockLevel, \"seq\");\n  }\n*/ // @C0D\n\n  /**\n   *Positions the file cursor to the first record whose record number\n   *matches the specified record number.  The file must be open when invoking\n   *this method.\n   *@param recordNumber The record number of the record at which to position the\n   *cursor.\n   *@exception AS400Exception If the system returns an error message.\n   *@exception AS400SecurityException If a security or authority error occurs.\n   *@exception ConnectionDroppedException If the connection is dropped unexpectedly.\n   *@exception InterruptedException If this thread is interrupted.\n   *@exception IOException If an error occurs while communicating with the system.\n  **/\n  public void positionCursor(int recordNumber)\n    throws AS400Exception,\n           AS400SecurityException,\n           InterruptedException,\n           IOException\n  {\n    verifyState(recordNumber); //@C0A\n    impl_.doIt(\"positionCursor\", new Class[] { Integer.TYPE }, new Object[] { new Integer(recordNumber) });\n  }\n\n\n  /**\n   *Positions the file cursor to the first record after the record specified\n   *by the record number.  The file must be open when invoking\n   *this method.\n   *@param recordNumber The record number of the record after which to position the\n   *           cursor.  The <i>recordNumber</i> must be greater than zero.\n   *@exception AS400Exception If the system returns an error message.\n   *@exception AS400SecurityException If a security or authority error occurs.\n   *@exception ConnectionDroppedException If the connection is dropped unexpectedly.\n   *@exception InterruptedException If this thread is interrupted.\n   *@exception IOException If an error occurs while communicating with the system.\n  **/\n  public void positionCursorAfter(int recordNumber)\n    throws AS400Exception,\n           AS400SecurityException,\n           InterruptedException,\n           IOException\n  {\n    positionCursor(recordNumber);  // This will cause the cache to be refreshed if we\n                                   // are caching and the record is not in the cache\n    positionCursorToNext();        // This will do the same, however at this point\n                                   // the record will be in the cache if caching\n  }\n\n  /**\n   *Positions the file cursor to the first record before the record specified\n   *by the record number.  The file must be open when invoking\n   *this method.\n   *@param recordNumber The record number of the record before which to position\n   *           the cursor.  The <i>recordNumber</i> must be greater than zero.\n   *@exception AS400Exception If the system returns an error message.\n   *@exception AS400SecurityException If a security or authority error occurs.\n   *@exception ConnectionDroppedException If the connection is dropped unexpectedly.\n   *@exception InterruptedException If this thread is interrupted.\n   *@exception IOException If an error occurs while communicating with the system.\n  **/\n  public void positionCursorBefore(int recordNumber)\n    throws AS400Exception,\n           AS400SecurityException,\n           InterruptedException,\n           IOException\n  {\n    verifyState(recordNumber); //@C0A\n    impl_.doIt(\"positionCursorBefore\", new Class[] { Integer.TYPE }, new Object[] { new Integer(recordNumber) });\n  }\n\n\n  /**\n   *Reads the record with the specified record number.  The file must be open\n   *when invoking this method.\n   *@param recordNumber The record number of the record to be read.  The\n   *<i>recordNumber</i> must be greater than zero.\n   *@return The record read.  If the record is not found, null is returned.\n   *@exception AS400Exception If the system returns an error message.\n   *@exception AS400SecurityException If a security or authority error occurs.\n   *@exception ConnectionDroppedException If the connection is dropped unexpectedly.\n   *@exception InterruptedException If this thread is interrupted.\n   *@exception IOException If an error occurs while communicating with the system.\n  **/\n  public Record read(int recordNumber)\n    throws AS400Exception,\n           AS400SecurityException,\n           InterruptedException,\n           IOException\n  {\n    verifyState(recordNumber); //@C0A\n    return fillInRecord(impl_.doItRecord(\"read\", new Class[] { Integer.TYPE }, new Object[] { new Integer(recordNumber) })); //@D0C\n  }\n\n\n  /**\n   *Reads the first record after the record with the specified record number.\n   *The file must be open when invoking this method.\n   *@param recordNumber record number of the record prior to the record to be read.\n   *The <i>recordNumber</i> must be greater than zero.\n   *@return The record read.  If the record is not found, null is returned.\n   *@exception AS400Exception If the system returns an error message.\n   *@exception AS400SecurityException If a security or authority error occurs.\n   *@exception ConnectionDroppedException If the connection is dropped unexpectedly.\n   *@exception InterruptedException If this thread is interrupted.\n   *@exception IOException If an error occurs while communicating with the system.\n  **/\n  public Record readAfter(int recordNumber)\n    throws AS400Exception,\n           AS400SecurityException,\n           InterruptedException,\n           IOException\n  {\n    verifyState(recordNumber); //@C0A\n    return fillInRecord(impl_.doItRecord(\"readAfter\", new Class[] { Integer.TYPE }, new Object[] { new Integer(recordNumber) })); //@D0C\n  }\n\n\n  /**\n   *Reads all the records in the file. The file must be closed when invoking this method.\n   *The record format for the file must have been set prior to invoking this method.\n   *@return The records read.  If no records are read, an array of size zero is returned.\n   *@exception AS400Exception If the system returns an error message.\n   *@exception AS400SecurityException If a security or authority error occurs.\n   *@exception ConnectionDroppedException If the connection is dropped unexpectedly.\n   *@exception InterruptedException If this thread is interrupted.\n   *@exception IOException If an error occurs while communicating with the system.\n   *@exception ServerStartupException If the host server cannot be started.\n   *@exception UnknownHostException If the system cannot be located.\n  **/\n  public Record[] readAll()\n    throws AS400Exception,\n           AS400SecurityException,\n           InterruptedException,\n           IOException\n  {\n    if (isOpen_)\n    {\n      throw new ExtendedIllegalStateException(ExtendedIllegalStateException.OBJECT_CAN_NOT_BE_OPEN);\n    }\n    if (recordFormat_ == null)\n    {\n      throw new ExtendedIllegalStateException(\"recordFormat\", ExtendedIllegalStateException.PROPERTY_NOT_SET);\n    }\n\n    // Read all records.\n    // Since readAll() now behaves under-the-covers like readNext(),\n    // need to open the file. Also synchronize on this, because\n    // the file isn't supposed to be open and this might mess up\n    // other references to this object, which expect it to be closed.\n    // See AS400FileImplRemote.readAll() for information regarding\n    // changes in the under-the-covers behavior.\n    chooseImpl();\n\n    // Before we calculate, make sure the record format has had\n    // its text objects initialized.\n    recordFormat_.initializeTextObjects(system_); //@D0A\n\n    // Use a calculated blocking factor, else use a large blocking factor\n    int bf = 2048/(recordFormat_.getNewRecord().getRecordLength() + 16); //@D0M\n    if (bf <= 1) bf = 100; //@D0M\n\n    Record[] recs = impl_.doItRecordArray(\"readAll\", new Class[] { String.class, Integer.TYPE }, new Object[] { \"seq\", new Integer(bf) }); //@D0C\n    //@D0A\n    if (recs != null)\n    {\n      for (int i=0; i<recs.length; ++i)\n      {\n        recs[i] = fillInRecord(recs[i]);\n      }\n    }\n\n    return recs; //@D0C\n  }\n\n\n  /**\n   *Reads the first record before the record with the specified record number.\n   *The file must be open when invoking this method.\n   *@param recordNumber The record number of the record after the record to be read.\n   *The <i>recordNumber</i> must be greater than zero.\n   *@return The record read.  If the record is not found, null is returned.\n   *@exception AS400Exception If the system returns an error message.\n   *@exception AS400SecurityException If a security or authority error occurs.\n   *@exception ConnectionDroppedException If the connection is dropped unexpectedly.\n   *@exception InterruptedException If this thread is interrupted.\n   *@exception IOException If an error occurs while communicating with the system.\n  **/\n  public Record readBefore(int recordNumber)\n    throws AS400Exception,\n           AS400SecurityException,\n           InterruptedException,\n           IOException\n  {\n    verifyState(recordNumber); //@C0A\n    return fillInRecord(impl_.doItRecord(\"readBefore\", new Class[] { Integer.TYPE }, new Object[] { new Integer(recordNumber) })); //@D0C\n  }\n\n\n  /**\n   *Overrides the ObjectInputStream.readObject() method in order to return any\n   *transient parts of the object to there properly initialized state.  We also\n   *generate a declared file name for the object.  I.e we in effect\n   *call the null constructor.  By calling ObjectInputStream.defaultReadObject()\n   *we restore the state of any non-static and non-transient variables.  We\n   *then continue on to restore the state (as necessary) of the remaining varaibles.\n   *@param in The input stream from which to deserialize the object.\n   *@exception ClassNotFoundException If the class being deserialized is not found.\n   *@exception IOException If an error occurs while communicating with the system.\n  **/\n\n  private void readObject(ObjectInputStream in)\n    throws ClassNotFoundException,\n           IOException\n  {\n    in.defaultReadObject();\n    initializeTransient(); //@C0C\n  }\n\n\n  /**\n   *Updates the record at the position specified by the record number.  The file\n   *must be open when invoking this method.\n   *@param recordNumber The record number of the record to update.\n   *The <i>recordNumber</i> must be greater than zero.\n   *@param record The record with which to update.\n   *@exception AS400Exception If the system returns an error message.\n   *@exception AS400SecurityException If a security or authority error occurs.\n   *@exception ConnectionDroppedException If the connection is dropped unexpectedly.\n   *@exception InterruptedException If this thread is interrupted.\n   *@exception IOException If an error occurs while communicating with the system.\n  **/\n  public void update(int recordNumber, Record record)\n    throws AS400Exception,\n           AS400SecurityException,\n           InterruptedException,\n           IOException\n  {\n    if (record == null)\n    {\n      throw new NullPointerException(\"record\");\n    }\n    positionCursor(recordNumber);\n    update(record);\n  }\n\n\n  //@C0A\n  /**\n  * Make sure the file is open and the recordNumber is valid.\n  **/\n  private void verifyState(int recordNumber)\n  {\n    // Verify object state\n    if (!isOpen_)\n    {\n      throw new ExtendedIllegalStateException(ExtendedIllegalStateException.OBJECT_MUST_BE_OPEN);\n    }\n    // Verify parameters\n    if (recordNumber < 1)\n    {\n      throw new ExtendedIllegalArgumentException(\"recordNumber\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n    }\n  }\n\n/**\nReturns the file name.\nThe name is formatted as a fully qualified path name in the library file system.\n\n@param recordListData TODO\n * @return The file name.\n**/\npublic String getFileName (RecordListData recordListData)\n{\n    return recordListData.fileName_;\n}\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 469,
                        "lineEnd": 479,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method getFileName to class RecordListData",
                        "description": "Move method to com.ibm.as400.vaccess.RecordListData\nRationale: The method getFileName() directly accesses the fileName_ property of the RecordListData instance, making it more appropriate for this method to reside within the RecordListData class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 4272
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getFileName",
                            "method_signature": "public String getFileName(RecordListData recordListData)",
                            "target_class": "RecordListData",
                            "rationale": "The getFileName method directly accesses the fileName_ property of RecordListData, indicating that it is more appropriate for this method to reside within the RecordListData class."
                        }
                    ],
                    "llm_response_time": 1224
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "getFileName",
                            "method_signature": "public String getFileName(RecordListData recordListData)",
                            "target_class": "RecordListData",
                            "rationale": "The getFileName method directly accesses the fileName_ property of RecordListData, indicating that it is more appropriate for this method to reside within the RecordListData class."
                        }
                    ],
                    "llm_response_time": 1116
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "getFileName",
                            "method_signature": "public String getFileName(RecordListData recordListData)",
                            "target_class": "RecordListData",
                            "rationale": "The getFileName method directly accesses the fileName_ property of RecordListData, indicating that it is more appropriate for this method to reside within the RecordListData class."
                        }
                    ],
                    "llm_response_time": 1260
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getFileName",
                            "method_signature": "public String getFileName(RecordListData recordListData)",
                            "target_class": "RecordListData",
                            "rationale": "The getFileName method directly accesses the fileName_ property of RecordListData, indicating that it is more appropriate for this method to reside within the RecordListData class."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "getFileName"
                ],
                "llm_response_time": 606
            },
            "targetClassMap": {
                "getFileName": {
                    "target_classes": [
                        {
                            "class_name": "RecordListData",
                            "similarity_score": 0.48155625297498705
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "RecordListData"
                    ],
                    "llm_response_time": 572,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.access.DataQueueEvent::cleared(DataQueueEvent):void need move com.ibm.as400.vaccess.DataQueueEventSupport",
        "class_name": "com.ibm.as400.access.DataQueueEvent",
        "telemetry": {
            "id": "de94f0ca-4b41-45dd-8054-13b7e01f8b99",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 69,
                "lineStart": 20,
                "lineEnd": 88,
                "bodyLineStart": 20,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/small/small/jtopen-7.8/src/com/ibm/as400/access/DataQueueEvent.java",
                "sourceCode": "/**\n The DataQueueEvent class represents a DataQueue event.\n **/\npublic class DataQueueEvent extends EventObject\n{\n    private static final String copyright = \"Copyright (C) 1997-2003 International Business Machines Corporation and others.\";\n\n    static final long serialVersionUID = 4L;\n\n    /**\n     The DataQueue clear event ID.  This event is delivered when a clear has been performed.\n     **/\n    public static final int DQ_CLEARED = 0;\n\n    /**\n     The DataQueue peek event ID.  This event is delivered when a peek has been performed.\n     **/\n    public static final int DQ_PEEKED = 1;\n\n    /**\n     The DataQueue read event ID.  This event is delivered when a read has been performed.\n     **/\n    public static final int DQ_READ = 2;\n\n    /**\n     The DataQueue write event ID.  This event is delivered when a write has been performed.\n     **/\n    public static final int DQ_WRITTEN = 3;\n\n    // Event identifier.\n    private int id_;\n\n    /**\n     Constructs a DataQueueEvent object. It uses the specified source and ID.\n     @param  source  The object where the event originated.\n     @param  id  The event identifier.\n     **/\n    public DataQueueEvent(Object source, int id)\n    {\n        super(source);\n\n        if (id < DQ_CLEARED || id > DQ_WRITTEN)\n        {\n            Trace.log(Trace.ERROR, \"Value of parameter 'id' is not valid:\", id);\n            throw new ExtendedIllegalArgumentException(\"id (\" + id + \")\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        id_ = id;\n    }\n\n    /**\n     Returns the identifier for this event.\n     @return  The identifier for this event.\n     **/\n    public int getID()\n    {\n        return id_;\n    }\n\n\t/**\n\tProcesses data queue cleared events.\n\t\n\t@param dataQueueEventSupport TODO\n\t**/\n\t    public void cleared (DataQueueEventSupport dataQueueEventSupport)\n\t    {\n\t        dataQueueEventSupport.fireCleared (this);\n\t    }\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 78,
                        "lineEnd": 86,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method cleared to class DataQueueEventSupport",
                        "description": "Move method to com.ibm.as400.vaccess.DataQueueEventSupport\nRationale: The method 'cleared' directly interacts with the 'DataQueueEventSupport' instance by calling its 'fireCleared' method, indicating that it is more appropriate for this method to reside within the 'DataQueueEventSupport' class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 4773
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "cleared",
                            "method_signature": "public void cleared(DataQueueEventSupport dataQueueEventSupport)",
                            "target_class": "DataQueueEventSupport",
                            "rationale": "The cleared() method is responsible for processing cleared events and directly interacts with the DataQueueEventSupport class. It would be more appropriate for this method to reside in the DataQueueEventSupport class, which is likely responsible for handling event notifications."
                        }
                    ],
                    "llm_response_time": 1453
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "cleared",
                            "method_signature": "public void cleared(DataQueueEventSupport dataQueueEventSupport)",
                            "target_class": "DataQueueEventSupport",
                            "rationale": "The cleared() method is responsible for processing events related to the clearing of a data queue, which is more aligned with the responsibilities of the DataQueueEventSupport class. Moving it there would adhere to the Single Responsibility Principle."
                        }
                    ],
                    "llm_response_time": 1316
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "cleared",
                            "method_signature": "public void cleared(DataQueueEventSupport dataQueueEventSupport)",
                            "target_class": "DataQueueEventSupport",
                            "rationale": "The cleared() method is responsible for processing cleared events and directly interacts with DataQueueEventSupport. It should be moved to the DataQueueEventSupport class to adhere to the Single Responsibility Principle."
                        }
                    ],
                    "llm_response_time": 1122
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "cleared",
                            "method_signature": "public void cleared(DataQueueEventSupport dataQueueEventSupport)",
                            "target_class": "DataQueueEventSupport",
                            "rationale": "The cleared() method is responsible for processing cleared events and directly interacts with the DataQueueEventSupport class. It would be more appropriate for this method to reside in the DataQueueEventSupport class, which is likely responsible for handling event notifications."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "cleared"
                ],
                "llm_response_time": 812
            },
            "targetClassMap": {
                "cleared": {
                    "target_classes": [
                        {
                            "class_name": "DataQueueEventSupport",
                            "similarity_score": 0.5327913597957292
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "DataQueueEventSupport"
                    ],
                    "llm_response_time": 857,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    }
]