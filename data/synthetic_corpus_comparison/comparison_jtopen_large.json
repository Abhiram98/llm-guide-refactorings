[
    {
        "oracle": "method com.ibm.as400.access.FTPThread::readObject(java.io.ObjectInputStream):void need move com.ibm.as400.access.FTP",
        "class_name": "com.ibm.as400.access.FTPThread",
        "telemetry": {
            "id": "e641caa8-7524-438a-bfb9-43b681fb9fb9",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 214,
                "lineStart": 20,
                "lineEnd": 233,
                "bodyLineStart": 20,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/large/big/jtopen-7.8/src/com/ibm/as400/access/FTPThread.java",
                "sourceCode": "class FTPThread implements Runnable\n{\n  private FTP ftp_;\n  \n  private int port_;\n  private Socket socket_;\n  private boolean running_ = false;\n  private final Object runLock_ = new Object();\n\n  private InetAddress localAddress_;\n\n  FTPThread(FTP ftp)\n  {\n    ftp_ = ftp;\n  }\n\n  // This must be called before the thread is started.\n  public void setLocalAddress(InetAddress localAddress)\n  {\n    localAddress_ = localAddress;\n    if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"FTP thread's local address set to: \"+localAddress_.toString());\n  }\n\n  public void waitUntilStarted()\n  {\n    try\n    {\n      while (!running_)\n      {\n        synchronized (runLock_)\n        {\n          if (!running_) runLock_.wait();\n        }\n      }\n    }\n    catch (Exception e)\n    {\n      Trace.log(Trace.ERROR, \"Error while waiting for FTP thread to start.\", e);\n    }\n  }\n\n  public int getLocalPort()\n  {\n    return port_;\n  }\n\n  public Socket getSocket()\n  {\n    if (socket_ == null)\n    {\n      try\n      {\n        synchronized(this)\n        {\n          if (socket_ == null) wait(60000); // Wait 60 seconds to prevent hanging.\n        }\n      }\n      catch (Exception e)\n      {\n        Trace.log(Trace.ERROR, \"Error while getting socket from FTP thread.\", e);\n        return null;\n      }\n    }\n    Socket s = socket_;\n    socket_ = null;\n    if (Trace.traceOn_)\n    {\n      Trace.log(Trace.DIAGNOSTIC, \"FTP thread returned previously accepted socket.\");\n      if (s == null) Trace.log(Trace.DIAGNOSTIC, \"FTPThread.getSocket() is returning null.\");\n    }\n    return s;\n  }\n\n  public void issuePortCommand() throws IOException\n  {\n      String addr = localAddress_.getHostAddress();\n      // Try the extended port command.\n      String response = ftp_.issueCommand(\"EPRT |\" + (addr.indexOf(':') == -1 ? \"1\" : \"2\") + \"|\" + addr + \"|\" + port_ + \"|\");\n      if (response.startsWith(\"200\")) return;\n\n      // System may not support EPRT, fallback to the port command.\n    StringTokenizer st = new StringTokenizer(addr, \".\");\n    StringBuffer cmd = new StringBuffer(\"PORT \");\n    while (st.hasMoreTokens())\n    {\n      cmd.append(st.nextToken());\n      cmd.append(\",\");\n    }\n    cmd.append(port_/256);\n    cmd.append(\",\");\n    cmd.append(port_ % 256);\n    response = ftp_.issueCommand(cmd.toString());\n    // A \"successful\" response will begin with 200.\n    if (!response.startsWith(\"200\"))\n    {\n      Trace.log(Trace.ERROR, \"Unexpected response to \" + cmd + \": \" + response);\n    }\n  }\n\n  public void run()\n  {\n    ServerSocket ss = null;\n    try\n    {\n      if (ftp_.isReuseSocket())\n      {\n        if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"FTP thread will reuse socket if multiple transfers.\");\n        ss = new ServerSocket(0, 50, localAddress_);\n        port_ = ss.getLocalPort();\n        while (true)\n        {\n          if (Trace.traceOn_)\n          {\n            Trace.log(Trace.DIAGNOSTIC, \"FTP thread waiting for new active mode socket.\");\n          }\n          if (!running_)\n          {\n            running_ = true;\n            synchronized (runLock_)\n            {\n              runLock_.notifyAll();\n            }\n          }\n          socket_ = ss.accept();\n          if (Trace.traceOn_)\n          {\n            Trace.log(Trace.DIAGNOSTIC, \"FTP thread accepted active mode socket: \"+socket_);\n          }\n          synchronized (this)\n          {\n            notifyAll();\n          }\n        }\n      }\n      else  // don't reuse socket\n      {\n        if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"FTP thread create new socket if multiple transfers.\");\n        while (true)\n        {\n          if (ss == null)\n          {\n            ss = new ServerSocket(0, 1, localAddress_);\n            port_ = ss.getLocalPort();\n          }\n          if (!running_)\n          {\n            running_ = true;\n            synchronized (runLock_)\n            {\n              runLock_.notifyAll();\n            }\n          }\n          if (Trace.traceOn_)\n          {\n            Trace.log(Trace.DIAGNOSTIC, \"FTP thread waiting for new active mode socket.\");\n          }\n          socket_ = ss.accept();\n          if (Trace.traceOn_)\n          {\n            Trace.log(Trace.DIAGNOSTIC, \"FTP thread accepted active mode socket: \"+socket_);\n          }\n          synchronized (this)\n          {\n            notifyAll();\n          }\n          // Get a new server socket each time to avoid bug on AIX.\n          // We create the server socket with only 1 connection in the backlog\n          // so any other incoming requests will have to wait until we can get them\n          // a new server socket.  This bottlenecks a multi-threaded client that is\n          // sharing an FTP object across threads, but they shouldn't be doing that anyway.\n          ss.close();\n          ss = null;\n        }\n      }\n    }\n    catch (Throwable e)\n    {\n      Trace.log(Trace.ERROR, \"Exception in FTP thread.\", e);\n    }\n    finally\n    {\n      if (socket_ != null) {\n        try { socket_.close(); }\n        catch (Throwable e) { Trace.log(Trace.ERROR, e); }\n      }\n      if (ss != null) {\n        try { ss.close(); }\n        catch (Throwable e) { Trace.log(Trace.ERROR, e); }\n      }\n    }\n  }\n\n/**\n    * During object deserialization, this method is called.  When it is called\n    * we need to initialize transient data.\n * @param ftp TODO\n * @param in TODO\n   **/\n\n    void readObject2(FTP ftp, ObjectInputStream in)\n        throws IOException, ClassNotFoundException\n    {\n        in.defaultReadObject();\n\n        ftp.connectionState_     = FTP.PARKED;\n        ftp.inConnect_           = false;\n        ftp.lastMessage_         = \"\";\n        ftp.changes_             = null;\n        ftp.vetos_               = null;\n        ftp.listeners_           = null;\n        ftp.listenerLock_        = new Object();\n        ftp.externallyConnected_ = false;                              // @D2a\n    }\n}",
                "methodCount": 8
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 211,
                        "lineEnd": 231,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method readObject2 to class FTP",
                        "description": "Move method readObject2 to com.ibm.as400.access.FTP\nRationale: The method readObject2() is responsible for initializing transient data during object deserialization, which is directly related to the state and properties of the FTP class. Since it manipulates the transient fields of the FTP class, it is logical for it to reside within the FTP class itself. Moving this method to the FTP class will ensure that the transient fields are properly initialized when an FTP object is deserialized, maintaining the integrity of the object's state.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "issuePortCommand",
                            "method_signature": "public void issuePortCommand() throws IOException",
                            "target_class": "FTP",
                            "rationale": "The issuePortCommand method is primarily concerned with issuing commands to the FTP server and handling responses, which aligns more closely with the responsibilities of the FTP class."
                        },
                        {
                            "method_name": "getSocket",
                            "method_signature": "public Socket getSocket()",
                            "target_class": "SocketManager",
                            "rationale": "The getSocket method is responsible for managing socket connections, which could be better handled in a dedicated SocketManager class that encapsulates socket-related operations."
                        },
                        {
                            "method_name": "waitUntilStarted",
                            "method_signature": "public void waitUntilStarted()",
                            "target_class": "ThreadManager",
                            "rationale": "The waitUntilStarted method is related to thread management and synchronization, which could be more appropriately placed in a ThreadManager class that handles thread lifecycle and coordination."
                        }
                    ],
                    "llm_response_time": 5305
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "issuePortCommand",
                            "method_signature": "public void issuePortCommand() throws IOException",
                            "target_class": "FTP",
                            "rationale": "The issuePortCommand method is primarily concerned with issuing commands to the FTP server and manipulating FTP-specific data. It should be moved to the FTP class to encapsulate FTP command logic within the FTP class."
                        },
                        {
                            "method_name": "getSocket",
                            "method_signature": "public Socket getSocket()",
                            "target_class": "SocketManager",
                            "rationale": "The getSocket method is responsible for managing socket connections and should be moved to a dedicated SocketManager class to separate socket management logic from the FTPThread class."
                        },
                        {
                            "method_name": "waitUntilStarted",
                            "method_signature": "public void waitUntilStarted()",
                            "target_class": "ThreadManager",
                            "rationale": "The waitUntilStarted method is related to thread management and synchronization. It should be moved to a ThreadManager class to better encapsulate thread-related functionality."
                        },
                        {
                            "method_name": "setLocalAddress",
                            "method_signature": "public void setLocalAddress(InetAddress localAddress)",
                            "target_class": "NetworkConfiguration",
                            "rationale": "The setLocalAddress method is responsible for configuring network settings. It should be moved to a NetworkConfiguration class to separate network configuration logic from the FTPThread class."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(FTP ftp, ObjectInputStream in) throws IOException, ClassNotFoundException",
                            "target_class": "FTP",
                            "rationale": "The readObject2 method is related to the deserialization of FTP objects and should be moved to the FTP class to keep serialization logic within the FTP class."
                        }
                    ],
                    "llm_response_time": 8626
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "issuePortCommand",
                            "method_signature": "public void issuePortCommand() throws IOException",
                            "target_class": "FTP",
                            "rationale": "The issuePortCommand method is primarily concerned with issuing commands to the FTP server and manipulating FTP-specific data. It should be moved to the FTP class to encapsulate FTP command logic within the FTP class."
                        },
                        {
                            "method_name": "getSocket",
                            "method_signature": "public Socket getSocket()",
                            "target_class": "SocketManager",
                            "rationale": "The getSocket method is responsible for managing socket connections and should be moved to a dedicated SocketManager class to separate socket management logic from the FTPThread class."
                        },
                        {
                            "method_name": "waitUntilStarted",
                            "method_signature": "public void waitUntilStarted()",
                            "target_class": "ThreadManager",
                            "rationale": "The waitUntilStarted method is related to thread management and synchronization. It should be moved to a ThreadManager class to better encapsulate thread-related functionality."
                        },
                        {
                            "method_name": "setLocalAddress",
                            "method_signature": "public void setLocalAddress(InetAddress localAddress)",
                            "target_class": "NetworkConfiguration",
                            "rationale": "The setLocalAddress method is responsible for configuring network settings. It should be moved to a NetworkConfiguration class to separate network configuration logic from the FTPThread class."
                        }
                    ],
                    "llm_response_time": 6880
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "issuePortCommand",
                            "method_signature": "public issuePortCommand()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "run",
                            "method_signature": "public run()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": " readObject2(FTP ftp, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject2",
                            "method_signature": " readObject2(FTP ftp, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "issuePortCommand",
                            "method_signature": "public issuePortCommand()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "run",
                            "method_signature": "public run()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    " readObject2(FTP ftp, ObjectInputStream in)": {
                        "first": {
                            "method_name": "readObject2",
                            "method_signature": " readObject2(FTP ftp, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3319218434742098
                    },
                    "public issuePortCommand()": {
                        "first": {
                            "method_name": "issuePortCommand",
                            "method_signature": "public issuePortCommand()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.41818886607709127
                    },
                    "public run()": {
                        "first": {
                            "method_name": "run",
                            "method_signature": "public run()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7773466455585395
                    }
                },
                "voyage": {
                    " readObject2(FTP ftp, ObjectInputStream in)": {
                        "first": {
                            "method_name": "readObject2",
                            "method_signature": " readObject2(FTP ftp, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4593688466086995
                    },
                    "public issuePortCommand()": {
                        "first": {
                            "method_name": "issuePortCommand",
                            "method_signature": "public issuePortCommand()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5039328230472011
                    },
                    "public run()": {
                        "first": {
                            "method_name": "run",
                            "method_signature": "public run()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7205545967223093
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public run()",
                        "public issuePortCommand()"
                    ],
                    "llm_response_time": 849
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public run()",
                        "public issuePortCommand()"
                    ],
                    "llm_response_time": 0
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public run()",
                        "public issuePortCommand()"
                    ],
                    "llm_response_time": 0
                },
                "voyage": {
                    "priority_method_names": [
                        "public run()",
                        "public issuePortCommand()"
                    ],
                    "llm_response_time": 0
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public run()",
                        "public issuePortCommand()"
                    ],
                    "llm_response_time": 0
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public run()",
                        "public issuePortCommand()"
                    ],
                    "llm_response_time": 0
                }
            },
            "targetClassMap": {
                "readObject2": {
                    "target_classes": [
                        {
                            "class_name": "FTP",
                            "similarity_score": 0.44652579790737035
                        },
                        {
                            "class_name": "FTP",
                            "similarity_score": 0.44652579790737035
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "FTP",
                        "FTP"
                    ],
                    "llm_response_time": 3351,
                    "similarity_computation_time": 7,
                    "similarity_metric": "cosine"
                },
                "issuePortCommand": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4196,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "run": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3515,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.vaccess.SQLMetaDataTableModel::readObject(java.io.ObjectInputStream):void need move com.ibm.as400.vaccess.SQLMetaDataTablePane",
        "class_name": "com.ibm.as400.vaccess.SQLMetaDataTableModel",
        "telemetry": {
            "id": "45113cae-f23f-4559-925d-aef21dc40eeb",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 545,
                "lineStart": 34,
                "lineEnd": 578,
                "bodyLineStart": 34,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/large/big/jtopen-7.8/src/com/ibm/as400/vaccess/SQLMetaDataTableModel.java",
                "sourceCode": "/**\nThe SQLMetaDataTableModel class represents the meta data\nabout the columns of a set of database files.  This model\nis used to create a SQLMetaDataTablePane.\nThe rows of this table are the fields of the database files,\nand the columns are the field attributes (field name, length, etc).\nRows can be removed from the table so the table only shows a subset\nof the available database fields.\nThis class is used by SQLQueryBuilderPane and its coworkers.\n\n<p>The data in the model is retrieved from the system only\nwhen <i>load()</i> is called.\n\n<p>SQLMetaDataTableModel objects generate the following events:\n<ul>\n  <li>ErrorEvent\n  <li>TableModelEvent\n  <li>WorkingEvent\n</ul>\n**/\nclass SQLMetaDataTableModel\nextends AbstractTableModel\nimplements Cloneable\n{\n  private static final String copyright = \"Copyright (C) 1997-2000 International Business Machines Corporation and others.\";\n\n\n// Note that none of the JDBC resources are ever explicitly closed,\n// but rather garbage collection is relied upon to close them.\n\n// This class is not meant to be serialized, it should be transient.\n// This class has items marked transient even though it is not\n// serializable because otherwise errors were received when\n// serializing objects that contained this class (even though they\n// were transient instances.  readObject() was added to be safe.\n\n// Number of columns in model.\nstatic private int NUM_COLUMNS_ = 6;\n\n// The columns of the table contains these meta data.\npublic static int FIELD_NAME_ = 0;\npublic static int FIELD_TYPE_ = 1;\npublic static int FIELD_LENGTH_ = 2;\npublic static int FIELD_DECIMALS_ = 3;\npublic static int FIELD_NULLS_ = 4;\npublic static int FIELD_DESC_ = 5;\n\n// What this table represents\ntransient private Connection connection_ = null;\nprivate String[] tables_ = null;  // The DB tables for which this model contains data.\n\n// The table data\ntransient private String[][] data_ = new String[0][NUM_COLUMNS_]; // table data\ntransient private int[] types_ = new int[0];            // sql types\n// Row information\ntransient private int numRows_ = 0;          // Number of rows in the table.\n\n// Flag for if an error event was sent.\ntransient private boolean error_;\n\n// Event support.\ntransient private ErrorEventSupport errorListeners_\n    = new ErrorEventSupport (this);\ntransient private WorkingEventSupport workingListeners_\n    = new WorkingEventSupport (this);\n\n\n\n/**\nConstructs a SQLMetaDataTableModel object.  The query is not done\nuntil <i>load</i> is done.\n\n@param       connection  The SQL connection.\n@param       tables      The database files to retrieve info about.\n                        Tables should be in the form of <library>.<file>.\n**/\npublic SQLMetaDataTableModel (Connection connection,\n                         String[] tables)\n{\n    super();\n    connection_ = connection;\n    tables_ = tables;\n}\n\n\n/**\nAdds a listener to be notified when an error occurs.\nThe listener's errorOccurred method will be called.\n\n@param  listener  The listener.\n**/\npublic void addErrorListener (ErrorListener listener)\n{\n    errorListeners_.addErrorListener (listener);\n}\n\n\n\n/**\nAdds a listener to be notified when work starts and stops\non potentially long-running operations.\n\n@param  listener  The listener.\n**/\npublic void addWorkingListener (WorkingListener listener)\n{\n    workingListeners_.addWorkingListener (listener);\n}\n\n\n\n/**\nMakes a clone (copy) of this table.  No data (references) is shared\nbetween this original and the new object.  Listeners are not copied\nto the new object.\n**/\nsynchronized public Object clone ()\n{\n    // create new object\n    SQLMetaDataTableModel clone =\n        new SQLMetaDataTableModel(connection_, tables_);\n    // copy table data\n    clone.data_ = new String[data_.length][NUM_COLUMNS_];\n    System.arraycopy(data_, 0, clone.data_, 0 , data_.length);\n    clone.numRows_ = numRows_;\n    clone.types_ = new int[types_.length];\n    System.arraycopy(types_, 0, clone.types_, 0 , types_.length);\n\n    return clone;\n}\n\n\n/**\nReturns the number of columns in the table.\n\n@return The number of columns in the table.\n**/\npublic int getColumnCount()\n{\n    return NUM_COLUMNS_;\n}\n\n\n/**\nReturns the number of rows in the table.\n\n@return The number of rows in the result set.\n**/\nsynchronized public int getRowCount()\n{\n    return numRows_;\n}\n\n\n/**\nReturn the SQL type of the field.  Note this is not the same as\nthe data in FIELD_TYPE_, which is the database-dependent type name.\n@see java.sql.Types\n\n@param index The row for which to get the type.\n@return The SQL type of the field.\n**/\nsynchronized int getSQLType(int index)\n{\n    return types_[index];\n}\n\n\n/**\nReturns the database file names this table contains data for.\n\n@return The database file names this table contains data for.\n**/\npublic String[] getTables ()\n{\n    return tables_;\n}\n\n\n/**\nReturns the value at the specifed column and row.\n\n@param  rowIndex            The row index.  Indices start at 0.\n@param  columnIndex    The column index.  Indices start at 0.\n\n@return The value at the specified column and row.\n**/\nsynchronized public Object getValueAt (int rowIndex,\n                          int columnIndex)\n{\n    error_ = false;\n\n    // return the value\n    return data_[rowIndex][columnIndex];\n}\n\n\n\n\n/**\nLoads the table based on the state of the system.\n**/\npublic void load ()\n{\n    synchronized (this)\n    {\n        // Set back fields in case there is an error.\n        data_ = new String[0][0];\n        types_ = new int[0];\n        numRows_ = 0;\n    }\n    // notify listeners that we've changed number of rows.\n    TableModelEvent event = new TableModelEvent(this, -1);\n    fireTableChanged(event);\n    Trace.log(Trace.DIAGNOSTIC, \"Starting load, changed number of rows to:\", numRows_);\n\n    if (tables_ == null || tables_.length == 0 ||\n        connection_ == null)\n    {\n        //If no tables, the panel will be disabled, don't throw\n        //error, just leave table empty.\n        return;\n    }\n\n    synchronized (this)\n    {\n        workingListeners_.fireStartWorking ();\n\n        // Number of rows we create our table with and number of\n        // rows we bump our capacity by each time we run out of room.\n        int ROW_INCREMENT = 50;\n\n        ResultSet resultSet = null;\n        try\n        {\n            // Get database meta data\n            DatabaseMetaData metaData = connection_.getMetaData();\n\n            // Create new array to hold table values.\n            data_ = new String[ROW_INCREMENT][NUM_COLUMNS_];\n            types_ = new int[ROW_INCREMENT];\n\n            // Loop through each database file.\n            String library, table, tprefix;\n            int sepIndex;\n            int curRow;\n            for (int i=0; i<tables_.length; ++i)\n            {\n                // Get meta data.\n                sepIndex = tables_[i].indexOf(\".\");\n                if (sepIndex == -1)\n                {\n                    // Incorrect table specification, send error\n                    // and continue to next table.\n                    // Create generic exception to hold error message\n                    Exception e = new Exception(ResourceLoader.getText(\"EXC_TABLE_SPEC_NOT_VALID\"));\n                    errorListeners_.fireError(e);\n                }\n                else\n                {\n                    library = tables_[i].substring(0, sepIndex);\n                    table = tables_[i].substring(sepIndex+1);\n                    if (tables_.length > 1)\n                        tprefix = table + \".\"; // need to qualify field names\n                    else\n                        tprefix = \"\";  // only 1 table, can just use field names\n                    resultSet = metaData.getColumns(null, library, table, null);\n\n                    // Loop through fields for this database file.\n                    while (resultSet.next())\n                    {\n                        curRow = numRows_; // current row in table\n\n                        // make sure we have room in table for this row.\n                        if (curRow >= data_.length)                         // @D1C\n                        {\n                            String[][] newData =\n                                new String[data_.length + ROW_INCREMENT][NUM_COLUMNS_];\n                            System.arraycopy(data_, 0, newData, 0, data_.length);\n                            data_ = newData;\n                            int[] newTypes =\n                                new int[types_.length + ROW_INCREMENT];\n                            System.arraycopy(types_, 0, newTypes, 0, types_.length);\n                            types_ = newTypes;\n                        }\n\n                        // Store SQL type for use by getSQLType,\n                        // although this is not externalized in the table.\n                        types_[curRow] = resultSet.getInt(5);\n\n                        // Add field info to table\n                        data_[curRow][FIELD_NAME_] = tprefix + resultSet.getString(4).trim();\n                        data_[curRow][FIELD_TYPE_] = resultSet.getString(6);\n                        // The following code should not be necessary when using\n                        // most drivers, but makes the length values correct\n                        // when using the i5/OS JDBC driver.\n                        // These values came from the ODBC description of precision\n                        // (in 2.0 ref, Appendix D page 624).\n                        switch (types_[curRow])\n                        {\n                            case Types.SMALLINT:\n                                data_[curRow][FIELD_LENGTH_] = \"5\";\n                                break;\n                            case Types.INTEGER:\n                                data_[curRow][FIELD_LENGTH_] = \"10\";\n                                break;\n                            case Types.TIME:\n                                data_[curRow][FIELD_LENGTH_] = \"8\";\n                                break;\n                            case Types.TIMESTAMP:\n                                // We always give length = 23, even though\n                                // we should give 19 if there is no decimals.\n                                // In order to not mess up 'correct' values,\n                                // only change it if we know the value is bad.\n                                if (resultSet.getInt(7) == 10)\n                                    data_[curRow][FIELD_LENGTH_] = \"23\";\n                                break;\n                            case Types.DATE:\n                                data_[curRow][FIELD_LENGTH_] = \"10\";\n                                break;\n                            case Types.DOUBLE:\n                                if (resultSet.getInt(7) == 4)\n                                    // single precision (type REAL)\n                                    data_[curRow][FIELD_LENGTH_] = \"7\";\n                                else\n                                    // double precison (type FLOAT)\n                                    data_[curRow][FIELD_LENGTH_] = \"15\";\n                                break;\n                            default:\n                                // Other types are correct.\n                                data_[curRow][FIELD_LENGTH_] = resultSet.getString(7);\n                        }\n                        data_[curRow][FIELD_DECIMALS_] = resultSet.getString(9);\n                        data_[curRow][FIELD_NULLS_] = resultSet.getString(18);\n                        data_[curRow][FIELD_DESC_] = resultSet.getString(12);\n\n                        numRows_++;\n                    }\n                }\n            }\n        }\n        catch (SQLException e)\n        {\n            // In case of error, set fields to init state\n            data_ = new String[0][0];\n            types_ = new int[0];\n            numRows_ = 0;\n            errorListeners_.fireError(e);\n            error_ = true;\n        }\n        finally\n        {\n            if (resultSet != null)\n            {\n                try\n                {\n                    resultSet.close();\n                }\n                catch(SQLException e)\n                {\n                    errorListeners_.fireError(e);\n                }\n            }\n        }\n    }  // end of synchronized block\n\n    // notify listeners that we've changed\n    event = new TableModelEvent(this, -1);\n    fireTableChanged(event);\n    Trace.log(Trace.DIAGNOSTIC, \"Did load, changed number of rows to:\", numRows_);\n\n    workingListeners_.fireStopWorking ();\n}\n\n\n/**\nRestores the state of this object from an object input stream.\nIt is used when deserializing an object.\n@param in The input stream of the object being deserialized.\n@exception IOException\n@exception ClassNotFoundException\n**/\nprivate void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException\n{\n    // Restore the non-static and non-transient fields.\n    in.defaultReadObject();\n    // Initialize the transient fields.\n    connection_ = null;\n    data_ = new String[0][NUM_COLUMNS_];\n    types_ = new int[0];\n    numRows_ = 0;\n    errorListeners_ = new ErrorEventSupport (this);\n    workingListeners_ = new WorkingEventSupport (this);\n}\n\n\n/**\nRemoves a row from the table.\n\n@param  rowIndex  The row index.  Indices start at 0.\n**/\npublic void removeRow (int rowIndex)\n{\n    synchronized (this)\n    {\n        Trace.log(Trace.DIAGNOSTIC, \"Removing row \", rowIndex);\n\n        // array to hold new data\n        String[][] newData = new String[data_.length -1][NUM_COLUMNS_];\n        int[] newTypes = new int[types_.length -1];\n\n        // copy table data to new table less row being removed\n        if (rowIndex == 0)\n        {\n            // remove first row\n            System.arraycopy(data_, 1, newData, 0, newData.length);\n            System.arraycopy(types_, 1, newTypes, 0, newTypes.length);\n        }\n        else if (rowIndex == data_.length - 1)\n        {\n            // remove last row\n            System.arraycopy(data_, 0, newData, 0, newData.length);\n            System.arraycopy(types_, 0, newTypes, 0, newTypes.length);\n        }\n        else\n        {\n            // remove row in middle\n            System.arraycopy(data_, 0, newData, 0, rowIndex);\n            System.arraycopy(data_, rowIndex+1, newData, rowIndex,\n                                newData.length-rowIndex);\n            System.arraycopy(types_, 0, newTypes, 0, rowIndex);\n            System.arraycopy(types_, rowIndex+1, newTypes, rowIndex,\n                                newTypes.length-rowIndex);\n        }\n\n        data_ = newData;\n        numRows_--;\n    }\n\n    // notify listeners that we've changed\n    fireTableRowsDeleted(rowIndex, rowIndex);\n}\n\n\n/**\nRemoves a listener from being notified when an error occurs.\n\n@param  listener  The listener.\n**/\npublic void removeErrorListener (ErrorListener listener)\n{\n    errorListeners_.removeErrorListener (listener);\n}\n\n\n/**\nRemoves a listener from being notified when work starts and stops.\n\n@param  listener  The listener.\n**/\npublic void removeWorkingListener (WorkingListener listener)\n{\n    workingListeners_.removeWorkingListener (listener);\n}\n\n\n/**\nSets the database files this table contains data for.\nThe new value will not be in effect until a <i>load()</i> is done.\n\n@param tables The database files this table will contain data for.\n                        Tables should be in the form of <library>.<file>.\n**/\npublic void setTables (String[] tables)\n{\n    tables_ = tables;\n}\n\n\n/**\nSets the SQL connection this table contains data for.\nThe new value will not be in effect until a <i>load()</i> is done.\n\n@param       connection  The SQL connection.\n**/\npublic void setConnection (Connection connection)\n{\n    connection_ = connection;\n}\n\n\n/**\nRestores the state of this object from an object input stream.\nIt is used when deserializing an object.\n@param sqlMetaDataTablePane TODO\n * @param in The input stream of the object being deserialized.\n * @exception IOException\n@exception ClassNotFoundException\n**/\nvoid readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)\n     throws java.io.IOException, ClassNotFoundException\n{\n    in.defaultReadObject();\n    sqlMetaDataTablePane.addFocusListener(new SerializationListener(sqlMetaDataTablePane)); //@B0A - for safe serialization next time\n\n    //@B0A: The following code is copied from the constructor since\n    // table_ is now transient.\n    sqlMetaDataTablePane.table_ = new JTable();\n    sqlMetaDataTablePane.table_.setAutoCreateColumnsFromModel(false);\n    sqlMetaDataTablePane.table_.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN); //@B0C\n    sqlMetaDataTablePane.table_.setModel(this);\n    sqlMetaDataTablePane.table_.setShowGrid(false);\n    // set up table columns\n    TableColumn column = new TableColumn(SQLMetaDataTableModel.FIELD_NAME_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_NAME\"));\n    column.setPreferredWidth(150); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_TYPE_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_TYPE\"));\n    column.setPreferredWidth(70); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_LENGTH_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_LENGTH\"));\n    column.setPreferredWidth(60); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_DECIMALS_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_DECIMALS\"));\n    column.setPreferredWidth(65); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_NULLS_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_NULL\"));\n    column.setPreferredWidth(80); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_DESC_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_DESCRIPTION\"));\n    column.setPreferredWidth(180); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    // build panel with table and headings\n    sqlMetaDataTablePane.setupPane();\n}\n\n\n\n}",
                "methodCount": 17
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 5,
                "candidates": [
                    {
                        "lineStart": 131,
                        "lineEnd": 140,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method addWorkingListener to class WorkingEventSupport",
                        "description": "Move method addWorkingListener to com.ibm.as400.vaccess.WorkingEventSupport\nRationale: The method addWorkingListener() is responsible for adding a listener to be notified of working events, which is a core functionality of the WorkingEventSupport class. This class is specifically designed to manage a list of WorkingListeners and dispatch events to them. Moving this method to WorkingEventSupport aligns with the Single Responsibility Principle, as it centralizes event listener management within the class that is already handling event dispatching. The WorkingListener interface, on the other hand, is meant to define the contract for listeners, not to manage them.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 489,
                        "lineEnd": 497,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method removeWorkingListener to class WorkingEventSupport",
                        "description": "Move method removeWorkingListener to com.ibm.as400.vaccess.WorkingEventSupport\nRationale: The method removeWorkingListener(WorkingListener listener) is responsible for removing a listener from a collection that manages working events. This functionality is inherently tied to the WorkingEventSupport class, which is designed to manage a list of WorkingListeners and dispatch events to them. Moving this method to WorkingEventSupport aligns with the class's purpose of handling event listener management, ensuring that all related operations (adding, removing, and firing events) are encapsulated within the same class. This promotes better cohesion and adheres to the Single Responsibility Principle, as WorkingEventSupport is specifically meant to support working events and their listeners.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 478,
                        "lineEnd": 486,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method removeErrorListener to class ErrorEventSupport",
                        "description": "Move method removeErrorListener to com.ibm.as400.vaccess.ErrorEventSupport\nRationale: The method removeErrorListener(ErrorListener listener) is responsible for removing a listener from a collection of error listeners. This functionality is directly related to managing the list of listeners and notifying them of events, which is the primary responsibility of the ErrorEventSupport class. Moving this method to ErrorEventSupport aligns with the class's purpose of handling event listener management, making the code more cohesive and easier to maintain. The ErrorListener interface, on the other hand, is meant to define the contract for listeners, not to manage them.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 118,
                        "lineEnd": 127,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method addErrorListener to class ErrorEventSupport",
                        "description": "Move method addErrorListener to com.ibm.as400.vaccess.ErrorEventSupport\nRationale: The method addErrorListener() is responsible for adding listeners that respond to error events. Since ErrorEventSupport is designed to manage a list of ErrorListeners and provide notification services for ErrorEvents, it is the most appropriate class for this method. Moving the method to ErrorEventSupport aligns with the class's purpose of handling event listeners, ensuring better encapsulation and adherence to the single responsibility principle. This change will also enhance code maintainability and clarity, as all listener-related functionality will be centralized within the ErrorEventSupport class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 525,
                        "lineEnd": 573,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method readObject2 to class SQLMetaDataTablePane",
                        "description": "Move method readObject2 to com.ibm.as400.vaccess.SQLMetaDataTablePane\nRationale: The method readObject2() is responsible for restoring the state of an SQLMetaDataTablePane object during deserialization. It directly manipulates the properties of SQLMetaDataTablePane, such as its JTable and its columns. Since the method is closely tied to the functionality of SQLMetaDataTablePane, it is more appropriate for it to reside within this class. Moving it to SQLMetaDataTablePane will enhance cohesion, as the method's purpose aligns with the responsibilities of the class, which is to manage the table representation of SQL metadata.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)",
                            "target_class": "SQLMetaDataTablePane",
                            "rationale": "The readObject2 method is responsible for setting up the SQLMetaDataTablePane and configuring its table. This functionality is more aligned with the responsibilities of the SQLMetaDataTablePane class, making it a better fit there."
                        }
                    ],
                    "llm_response_time": 3032
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)",
                            "target_class": "SQLMetaDataTablePane",
                            "rationale": "The readObject2 method is responsible for setting up the SQLMetaDataTablePane and configuring its JTable. This functionality is closely related to the UI representation of the metadata, making it more appropriate for the SQLMetaDataTablePane class."
                        }
                    ],
                    "llm_response_time": 2946
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)",
                            "target_class": "SQLMetaDataTablePane",
                            "rationale": "The readObject2 method is responsible for setting up the SQLMetaDataTablePane with the SQLMetaDataTableModel. It directly manipulates the UI components of SQLMetaDataTablePane, making it more appropriate for this method to reside within the SQLMetaDataTablePane class."
                        }
                    ],
                    "llm_response_time": 3209
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "addErrorListener",
                            "method_signature": "public addErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addWorkingListener",
                            "method_signature": "public addWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "load",
                            "method_signature": "public load()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeErrorListener",
                            "method_signature": "public removeErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeWorkingListener",
                            "method_signature": "public removeWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": " readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "addWorkingListener",
                            "method_signature": "public addWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeWorkingListener",
                            "method_signature": "public removeWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeErrorListener",
                            "method_signature": "public removeErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addErrorListener",
                            "method_signature": "public addErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": " readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "load",
                            "method_signature": "public load()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public addWorkingListener(WorkingListener listener)": {
                        "first": {
                            "method_name": "addWorkingListener",
                            "method_signature": "public addWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3156159027996529
                    },
                    "public removeWorkingListener(WorkingListener listener)": {
                        "first": {
                            "method_name": "removeWorkingListener",
                            "method_signature": "public removeWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.31940762711737675
                    },
                    "public removeErrorListener(ErrorListener listener)": {
                        "first": {
                            "method_name": "removeErrorListener",
                            "method_signature": "public removeErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.32418741901251585
                    },
                    "public addErrorListener(ErrorListener listener)": {
                        "first": {
                            "method_name": "addErrorListener",
                            "method_signature": "public addErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3771276265172641
                    },
                    " readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)": {
                        "first": {
                            "method_name": "readObject2",
                            "method_signature": " readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5463753601845154
                    },
                    "public load()": {
                        "first": {
                            "method_name": "load",
                            "method_signature": "public load()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6422054466437503
                    }
                },
                "voyage": {
                    "public addWorkingListener(WorkingListener listener)": {
                        "first": {
                            "method_name": "addWorkingListener",
                            "method_signature": "public addWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.22179170716707686
                    },
                    "public removeWorkingListener(WorkingListener listener)": {
                        "first": {
                            "method_name": "removeWorkingListener",
                            "method_signature": "public removeWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2504221587893251
                    },
                    "public addErrorListener(ErrorListener listener)": {
                        "first": {
                            "method_name": "addErrorListener",
                            "method_signature": "public addErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2542723209148102
                    },
                    "public removeErrorListener(ErrorListener listener)": {
                        "first": {
                            "method_name": "removeErrorListener",
                            "method_signature": "public removeErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2572859942887297
                    },
                    "public load()": {
                        "first": {
                            "method_name": "load",
                            "method_signature": "public load()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6703935818870984
                    },
                    " readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)": {
                        "first": {
                            "method_name": "readObject2",
                            "method_signature": " readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.675406589486801
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public load()",
                        "public addErrorListener(ErrorListener listener)",
                        "public removeErrorListener(ErrorListener listener)",
                        "public addWorkingListener(WorkingListener listener)",
                        "public removeWorkingListener(WorkingListener listener)"
                    ],
                    "llm_response_time": 2367
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public addErrorListener(ErrorListener listener)",
                        "public removeErrorListener(ErrorListener listener)",
                        "public addWorkingListener(WorkingListener listener)",
                        "public removeWorkingListener(WorkingListener listener)"
                    ],
                    "llm_response_time": 1445
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public addWorkingListener(WorkingListener listener)",
                        "public removeWorkingListener(WorkingListener listener)",
                        "public removeErrorListener(ErrorListener listener)"
                    ],
                    "llm_response_time": 1168
                },
                "voyage": {
                    "priority_method_names": [
                        "public load()",
                        "public addErrorListener(ErrorListener listener)",
                        "public removeErrorListener(ErrorListener listener)",
                        "public addWorkingListener(WorkingListener listener)",
                        "public removeWorkingListener(WorkingListener listener)"
                    ],
                    "llm_response_time": 1387
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public load()",
                        "public addErrorListener(ErrorListener listener)",
                        "public removeErrorListener(ErrorListener listener)",
                        "public addWorkingListener(WorkingListener listener)",
                        "public removeWorkingListener(WorkingListener listener)"
                    ],
                    "llm_response_time": 1298
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public addErrorListener(ErrorListener listener)",
                        "public addWorkingListener(WorkingListener listener)",
                        "public removeWorkingListener(WorkingListener listener)"
                    ],
                    "llm_response_time": 965
                }
            },
            "targetClassMap": {
                "addWorkingListener": {
                    "target_classes": [
                        {
                            "class_name": "WorkingListener",
                            "similarity_score": 0.4488792012484348
                        },
                        {
                            "class_name": "WorkingEventSupport",
                            "similarity_score": 0.25465442825893786
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "WorkingEventSupport",
                        "WorkingListener"
                    ],
                    "llm_response_time": 3116,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "removeWorkingListener": {
                    "target_classes": [
                        {
                            "class_name": "WorkingListener",
                            "similarity_score": 0.4132231551804141
                        },
                        {
                            "class_name": "WorkingEventSupport",
                            "similarity_score": 0.24473834461387506
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "WorkingEventSupport",
                        "WorkingListener"
                    ],
                    "llm_response_time": 3544,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "removeErrorListener": {
                    "target_classes": [
                        {
                            "class_name": "ErrorListener",
                            "similarity_score": 0.45469886172314167
                        },
                        {
                            "class_name": "ErrorEventSupport",
                            "similarity_score": 0.2503591269539747
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ErrorEventSupport",
                        "ErrorListener"
                    ],
                    "llm_response_time": 3885,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "addErrorListener": {
                    "target_classes": [
                        {
                            "class_name": "ErrorListener",
                            "similarity_score": 0.43803205964459085
                        },
                        {
                            "class_name": "ErrorEventSupport",
                            "similarity_score": 0.2895590000971946
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ErrorEventSupport",
                        "ErrorListener"
                    ],
                    "llm_response_time": 4136,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "readObject2": {
                    "target_classes": [
                        {
                            "class_name": "SQLMetaDataTablePane",
                            "similarity_score": 0.6896865432884054
                        },
                        {
                            "class_name": "ErrorEventSupport",
                            "similarity_score": 0.3310278493971974
                        },
                        {
                            "class_name": "WorkingEventSupport",
                            "similarity_score": 0.3088104758037342
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SQLMetaDataTablePane",
                        "ErrorEventSupport",
                        "WorkingEventSupport"
                    ],
                    "llm_response_time": 4590,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "load": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2513,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.data.ProgramCallDocument::endInternal(int):void need move com.ibm.as400.resource.RJob",
        "class_name": "com.ibm.as400.data.ProgramCallDocument",
        "telemetry": {
            "id": "b33bb953-6f29-4da9-81f9-1db6e36da980",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1977,
                "lineStart": 56,
                "lineEnd": 2032,
                "bodyLineStart": 56,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/large/big/jtopen-7.8/src/com/ibm/as400/data/ProgramCallDocument.java",
                "sourceCode": "/**\n * XML Document based program call.\n *\n * The ProgramCallDocument class uses a Program Call Markup Language (PCML) document to\n * call IBM i system programs.\n * PCML is an XML language for describing the input and output parameters\n * to the IBM i system program.\n *\n * This class parses a PCML document and allows the application to call\n * IBM i system programs described in the PCML document.\n *\n * <h3>Command Line Interface</h3>\n * The command line interface may be used to serialize\n * PCML document definitions. Note that XPCML documents cannot\n * be serialized.\n * <pre>\n * <kbd>java com.ibm.as400.data.ProgramCallDocument\n *     -serialize\n *     <i>PCML document name</i></kbd>\n * </pre>\n * Options:\n * <dl>\n * <dt><kbd>-serialize</kbd>\n * <dd>Parses the PCML document and creates a serialized version of the document.\n * The name of the serialized file will match the document name, and the file extension will be\n * <code><strong>.pcml.ser</code></strong> (lowercase).\n * <p><dt><kbd><i>PCML document name</i></kbd>\n * <dd>The fully-qualified resource name of the PCML document\n * which defines the program interface.\n * </dl>\n */\npublic class ProgramCallDocument implements Serializable, Cloneable\n{                                                                   // @C1C @C3C\n    static final long serialVersionUID = -1836686444079106483L;\t    // @C1A\n\n    /**\n     * Constant indicating a serialized PCML or XPCML document is being streamed.\n     * @see #ProgramCallDocument(AS400,String,InputStream,ClassLoader,InputStream,int)\n    **/\n    public static final int SERIALIZED = 0;\n\n    /**\n     * Constant indicating a source PCML document is being streamed.\n    * @see #ProgramCallDocument(AS400,String,InputStream,ClassLoader,InputStream,int)\n    **/\n    public static final int SOURCE_PCML = 1;\n\n    /**\n     * Constant indicating a source XPCML document is being streamed.\n    * @see #ProgramCallDocument(AS400,String,InputStream,ClassLoader,InputStream,int)\n    **/\n    public static final int SOURCE_XPCML = 2;\n\n    private AS400 m_as400;\n    private PcmlDocument m_pcmlDoc;\n    static boolean exceptionIfParseError_;\n    static\n    {\n      String property = null;\n      try {\n        property = SystemProperties.getProperty(SystemProperties.THROW_SAX_EXCEPTION_IF_PARSE_ERROR);\n      }\n      catch (Throwable t) {}\n      if (property == null) { // Property not set.\n        exceptionIfParseError_ = false;\n      }\n      else if (property.trim().equalsIgnoreCase(\"true\")) {\n        exceptionIfParseError_ = true;\n      }\n      else {\n        exceptionIfParseError_ = false;\n      }\n    }\n\n    /**\n     Constructs a ProgramCallDocument object.\n    The PCML or XPCML document resource will be loaded from the classpath.\n    If the document is a PCML document, the classpath will first be searched for a serialized resource.\n    XPCML documents cannot be serialized.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML or XPCML source file.\n\n    @param sys The system on which to run the program.\n    @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public ProgramCallDocument(AS400 sys, String docName)\n    \tthrows PcmlException\n   \t{\n        if (sys == null)     warnNull(\"sys\");\n        if (docName == null) warnNull(\"docName\");\n\n        m_as400 = sys;\n\n        m_pcmlDoc = loadPcmlDocument(docName, null,null);        // @C8C @E1C\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);\n    }\n\n  /**\n    Constructs a ProgramCallDocument object.\n    The XPCML document resource will be loaded from the classpath and parsed using\n    the XML schema definitions provided in the input XSD stream.\n\n    @param sys The system on which to run the program.\n    @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n\n    public ProgramCallDocument(AS400 sys, String docName, InputStream xsdStream)\n    \tthrows PcmlException\n   \t{\n        if (sys == null)     warnNull(\"sys\");\n        if (docName == null) warnNull(\"docName\");\n\n        m_as400 = sys;\n\n        m_pcmlDoc = loadPcmlDocument(docName, null,xsdStream);        // @C8C\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);\n\n    }\n\n    /**\n     Constructs a ProgramCallDocument object.\n    The PCML or XPCML document resource will be loaded from the classpath.\n    If the document is a PCML document, the classpath will first be searched for a serialized resource.\n    XPCML documents cannot be serialized.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML or XPCML source file.\n\n     @param sys The system on which to run the program.\n    @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public ProgramCallDocument(AS400 sys, String docName, ClassLoader loader)       // @C8A\n    \tthrows PcmlException\n   \t{\n        if (sys == null)     warnNull(\"sys\");\n        if (docName == null) warnNull(\"docName\");\n\n        m_as400 = sys;                                      // @C8A\n\n        m_pcmlDoc = loadPcmlDocument(docName, loader,null);      // @C8A\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);                        // @C8A\n    }\n\n\n  /**\n    Constructs a ProgramCallDocument object.\n    The PCML or XPCML document resource will be loaded from the classpath and parsed using\n    the XML schema definitions provided in the input XSD stream.\n    @param sys The system on which to run the program.\n    @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML.  This parameter can be null.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n    @exception PcmlException when the specified PCML document cannot be found\n    */\n     public ProgramCallDocument(AS400 sys, String docName, ClassLoader loader, InputStream xsdStream)       // @C8A\n    \tthrows PcmlException\n   \t{\n        if (sys == null)     warnNull(\"sys\");\n        if (docName == null) warnNull(\"docName\");\n\n        m_as400 = sys;                                      // @C8A\n\n        m_pcmlDoc = loadPcmlDocument(docName, loader,xsdStream);      // @C8A\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);                        // @C8A\n    }\n\n  /**\n    Constructs a ProgramCallDocument object.\n    The PCML or XPCML document resource will be read from the specified input stream, and parsed using\n    the XML schema definitions provided in the input XSD stream.\n    @param sys The system on which to run the program.\n    @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n    @param docStream The InputStream from which to read the contents of the document.\n    @param loader The ClassLoader that will be used when loading the DTD for PCML. This parameter can be null.\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\".  This parameter can be null.\n    @param type The type of data contained in docStream. Possible values are:\n    <UL>\n    <LI>{@link #SERIALIZED SERIALIZED} - The docStream contains a serialized PCML or XPCML document.\n    <LI>{@link #SOURCE_PCML SOURCE_PCML} - The docStream contains a PCML document.\n    <LI>{@link #SOURCE_XPCML SOURCE_XPCML} - The docStream contains an XPCML document.\n    </UL>\n    @exception PcmlException when the specified PCML document cannot be found\n    */\n     public ProgramCallDocument(AS400 sys, String docName, InputStream docStream, ClassLoader loader, InputStream xsdStream, int type)\n    \tthrows PcmlException\n   \t{\n        if (sys == null)     warnNull(\"sys\");\n        if (docName == null) warnNull(\"docName\");\n\n        if (type == ProgramCallDocument.SERIALIZED)\n        {\n          m_pcmlDoc = loadSerializedPcmlDocumentFromStream(docStream);\n        }\n        else if (type == ProgramCallDocument.SOURCE_PCML)\n        {\n          m_pcmlDoc = loadSourcePcmlDocumentFromStream(docName, docStream, loader, xsdStream, false);\n        }\n        else if (type == ProgramCallDocument.SOURCE_XPCML)\n        {\n          m_pcmlDoc = loadSourcePcmlDocumentFromStream(docName, docStream, loader, xsdStream, true);\n        }\n        else {\n          throw new ExtendedIllegalArgumentException(\"type (\" + type + \")\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        m_as400 = sys;\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);\n    }\n\n     /**\n    Constructs a ProgramCallDocument object.\n    {@link #setSystem setSystem()} and {@link #setDocument setDocument()} must be called prior to using the object.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public ProgramCallDocument()\n    \tthrows PcmlException                                        // @C1A\n   \t{                                                               // @C1A\n        m_as400 = null;                                             // @C1A\n        m_pcmlDoc = null;                                           // @C1A\n    }                                                               // @C1A\n\n    /**\n     Constructs a ProgramCallDocument object.\n     {@link #setSystem setSystem()} must be called prior to using the object.\n     The PCML or XPCML document resource will be loaded from the classpath.\n     If the document is a PCML document, the classpath will first be searched for a serialized resource.\n     XPCML documents cannot be serialized.\n     If a serialized resource is not found, the classpath will be\n     searched for a PCML or XPCML source file.\n\n     @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n     The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n     @exception PcmlException when the specified PCML document cannot be found\n     */\n    public ProgramCallDocument(String docName)\n      throws PcmlException\n    {\n      if (docName == null) {\n        throw new NullPointerException(\"docName\");\n      }\n\n      m_pcmlDoc = loadPcmlDocument(docName, null,null);\n    }\n\n    /**\n     Constructs a ProgramCallDocument object.\n     {@link #setSystem setSystem()} must be called prior to using the object.\n     The PCML or XPCML document resource will be loaded from the classpath of the specified ClassLoader.\n     If the document is a PCML document, the classpath will first be searched for a serialized resource.\n     XPCML documents cannot be serialized.\n     If a serialized resource is not found, the classpath will be\n     searched for a PCML or XPCML source file.\n\n     @param docName The document resource name of the PCML document for the programs to be called.\n     @param loader The ClassLoader that will be used when loading the specified document resource.\n\n     @exception PcmlException when the specified PCML document cannot be found\n     */\n    public ProgramCallDocument(String docName, ClassLoader loader)\n    \tthrows XmlException\n    {\n      if (docName == null) {\n        throw new NullPointerException(\"docName\");\n      }\n      if (loader == null) {\n        throw new NullPointerException(\"loader\");\n      }\n\n      m_pcmlDoc = loadPcmlDocument(docName, loader, null);\n    }\n\n    /**\n    Clones the ProgramCallDocument and the objects contained in it.\n    {@link #setSystem setSystem()} and {@link #setDocument setDocument()} must be called prior to using the object.\n    */\n    public Object clone()\n   \t{                                                               // @C3A\n   \t    ProgramCallDocument newPcml = null;                         // @C3A\n        try                                                         // @C3A\n        {                                                           // @C3A\n            newPcml = (ProgramCallDocument) super.clone();          // @C3A\n            if (m_pcmlDoc != null)                                  // @C3A\n                newPcml.m_pcmlDoc = (PcmlDocument) m_pcmlDoc.clone();   // @C3A\n        }                                                           // @C3A\n        catch (CloneNotSupportedException e)                        // @C3A\n        {}                                                          // @C3A\n\n        return newPcml;                                             // @C3A\n    }                                                               // @C3A\n\n    // Custom serialization\n    private void writeObject(ObjectOutputStream out)\n        throws IOException                                          // @C1A\n    {                                                               // @C1A\n\t\tsynchronized (this)                                         // @C1A\n\t\t{                                                           // @C1A\n            if (m_pcmlDoc != null)                                  // @C1A\n            {                                                       // @C1A\n                m_pcmlDoc.setSerializingWithData(true);             // @C1A\n            }                                                       // @C1A\n\n\t\t\t// Perform default serialization\n\t\t\tout.defaultWriteObject();                               // @C1A\n\n\t\t} // end of synchronized code                               // @C1A\n    }                                                               // @C1A\n\n    /**\n\t * Provides a command line interface to ProgramCallDocument.  See the class description.\n    * Note that XPCML documents cannot be serialized.\n\t *\n     */\n    public static void main(String[] args)\n    {\n\t\tPcmlDocument pd = null;\n\n        System.setErr(System.out);\n        final String errMsg = SystemResourceFinder.format(DAMRI.PCD_ARGUMENTS);\n\n\t\tif (args.length == 2)\n        {\n        \tif (!args[0].equalsIgnoreCase(\"-SERIALIZE\"))\n        \t{\n        \t\tSystem.out.println(errMsg);\n        \t\tSystem.exit(-1);\n        \t}\n\n            // Load the document from source (previously serialized documents are ignored)\n            try\n            {\n\t\t\t\tpd = loadSourcePcmlDocument(args[1], null,null);         // @C8C\n            }\n\t\t\tcatch (PcmlException e)\n\t\t\t{\n\t\t\t\tSystem.out.println(e.getLocalizedMessage());\n\t\t\t\tSystem.exit(-1);\n\t\t\t}\n\n            // Save the document as a serialized file\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsavePcmlDocument(pd);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tSystem.out.println(e.getLocalizedMessage());\n\t\t\t\tSystem.exit(-1);\n\t\t\t}\n\n        }\n\t\telse\n\t\t{\n    \t\tSystem.out.println(errMsg);\n    \t\tSystem.exit(-1);\n\t\t}\n\n    }\n\n\n\n    /**\n     Calls the named program.\n\n     @param name The name of the &lt;program&gt; element in the PCML document.\n     @exception PcmlException\n                If an error occurs.\n    */\n    public boolean callProgram(String name)\n        throws PcmlException\n    {\n        try\n        {\n            return m_pcmlDoc.callProgram(name);\n        }\n        catch (AS400SecurityException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            PcmlException pe = new PcmlException(e);\n            throw pe;\n        }\n        catch (ObjectDoesNotExistException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            PcmlException pe = new PcmlException(e);\n            throw pe;\n        }\n        catch (InterruptedException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            PcmlException pe = new PcmlException(e);\n            throw pe;\n        }\n        catch (ErrorCompletingRequestException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            PcmlException pe = new PcmlException(e);\n            throw pe;\n        }\n        catch (IOException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            throw new PcmlException(e);\n        }\n\n    }\n\n    /**\n    Returns an \"errno\" value for the named service program element.\n    <p>\n    The named program element must be defined as a service program <code>entrypoint</code>.\n    The value returned is the \"errno\" value resulting from the most recent\n    call to the program. If the program has not been called, zero is returned.\n\n    @return The integer \"errno\" value for the named service program element.\n\n    @param name The name of the &lt;program&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getErrno(String name)\n        throws PcmlException                                        // @B1A\n    {                                                               // @B1A\n        return m_pcmlDoc.getErrno(name);                            // @B1A\n    }                                                               // @B1A\n\n    /**\n    Returns a Descriptor for the specified PCML document.\n    The PCML document resource will be loaded from the classpath.\n    The classpath will first be searched for a serialized resource.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML source file.\n\n    @param docName The document resource name of the PCML document for which the Descriptor is returned.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n    @return The Descriptor for the &lt;pcml&gt; element of the named PCML file.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public static Descriptor getDescriptor(String docName)\n        throws PcmlException                                        // @C5A\n    {\n        PcmlDocument pd = null;\n\n        pd = loadPcmlDocument(docName, null,null);                       // @C8C\n\n        return new PcmlDescriptor(pd);\n    }                                                               // @C5A\n\n     /**\n    Returns a Descriptor for the specified XPCML document.\n    The XPCML document resource will be loaded from the classpath.\n\n    @param docName The document resource name of the XPCML document for which the Descriptor is returned.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML\n\n    @return The Descriptor for the &lt;pcml&gt; element of the named PCML file.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public static Descriptor getDescriptor(String docName, InputStream xsdStream)\n        throws PcmlException                                        // @C5A\n    {\n        PcmlDocument pd = null;\n\n        pd = loadPcmlDocument(docName, null, xsdStream);                       // @C8C\n\n        return new PcmlDescriptor(pd);\n    }                                                               // @C5A\n\n    /**\n    Returns a Descriptor for the specified PCML document.\n    The PCML document resource will be loaded from the classpath.\n    The classpath will first be searched for a serialized resource.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML source file.\n\n    @param docName The document resource name of the PCML document for which the Descriptor is returned.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n    @return The Descriptor for the &lt;pcml&gt; element of the named PCML file.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public static Descriptor getDescriptor(String docName, ClassLoader loader)\n        throws PcmlException                                        // @C8A\n    {\n        PcmlDocument pd = null;                                     // @C8A\n\n        pd = loadPcmlDocument(docName, loader,null);                             // @C8A\n\n        return new PcmlDescriptor(pd);                              // @C8A\n    }\n\n    /**\n    Returns a Descriptor for the specified XPCML document.\n    The XPCML document resource will be loaded from the classpath.\n\n    @param docName The document resource name of the PCML document for which the Descriptor is returned.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML.\n\n    @return The Descriptor for the &lt;pcml&gt; element of the named PCML file.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public static Descriptor getDescriptor(String docName, ClassLoader loader, InputStream xsdStream)\n        throws PcmlException                                        // @C8A\n    {\n        PcmlDocument pd = null;                                     // @C8A\n\n        pd = loadPcmlDocument(docName, loader,xsdStream);                             // @C8A\n\n        return new PcmlDescriptor(pd);                              // @C8A\n    }\n\n\n    /**\n    Returns a Descriptor for the current PCML document.\n\n    @return The Descriptor for the &lt;pcml&gt; element of the current PCML file or\n            null if the PCML document has not be set.\n    */\n    public Descriptor getDescriptor()                               // @C5A\n    {\n\n        if (m_pcmlDoc == null)\n            return null;\n        else\n            return new PcmlDescriptor(m_pcmlDoc);\n    }                                                               // @C5A\n\n    /**\n    Returns an int return value for the named service program element.\n    <p>\n    The named program element must be defined as a service program <code>entrypoint</code>.\n    The value returned is the integer return value from the most recent\n    call to the program. If the program has not been called, zero is returned.\n\n    @return The integer return value for the named service program element.\n\n    @param name The name of the &lt;program&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getIntReturnValue(String name) throws PcmlException  // @B1A\n    {                                                               // @B1A\n        return m_pcmlDoc.getIntReturnValue(name);                   // @B1A\n    }                                                               // @B1A\n\n    /**\n    Returns an int value for the named element.\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to an int.\n\n    @return The integer value for the named element.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getIntValue(String name)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getIntValue(name);\n    }\n\n    /**\n    Returns an int value for the named element given indices to the data element.\n    If the data element is an array or is an element in a structure array, an index\n    must be specified for each dimension of the data.\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to an int.\n\n    @return The integer value for the named element.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getIntValue(String name, int[] indices)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getIntValue(name, new PcmlDimensions(indices));\n    }\n\n\n    /**\n     Returns the ProgramCall object that was used in the most recent invocation of {@link #callProgram(String) callProgram()}.\n     @return The ProgramCall object; null if callProgram() has not been called.\n     **/\n    public ProgramCall getProgramCall()\n    {\n      return ( m_pcmlDoc == null ? null : m_pcmlDoc.getProgramCall() );\n    }\n\n\n    /**\n    Returns a String value for the named element.\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to a String.\n    The default bidi string type is assumed ({@link com.ibm.as400.access.BidiStringType#DEFAULT BidiStringType.DEFAULT}).\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @exception PcmlException If an error occurs.\n    */\n    public String getStringValue(String name)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getStringValue(name, BidiStringType.DEFAULT);\n    }\n\n    /**\n    Returns a String value for the named element.\n    <p>\n    This method is used when the string type cannot be determined until\n    run-time.  In those cases, the PCML document cannot be used to indicate\n    the string type so this method is used to get the value using the\n    string type that is specified.\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to a String.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param type The bidi string type, as defined by the CDRA (Character\n                Data Representation Architecture).\n    @exception PcmlException\n               If an error occurs.\n    @see com.ibm.as400.access.BidiStringType\n    */\n    public String getStringValue(String name, int type)\n        throws PcmlException                                            // @C9A\n    {\n        return m_pcmlDoc.getStringValue(name, type);                    // @C9A\n    }\n\n\n    /**\n    Returns a String value for the named element given indices to the data element.\n    If the data element is an array or is an element in a structure array, an index\n    must be specified for each dimension of the data.\n    The default bidi string type is assumed ({@link com.ibm.as400.access.BidiStringType#DEFAULT BidiStringType.DEFAULT}).\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to a String.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for setting the value of an element in an array.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public String getStringValue(String name, int[] indices)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getStringValue(name, new PcmlDimensions(indices), BidiStringType.DEFAULT);\n    }\n\n    /**\n    Returns a String value for the named element given indices to the data element.\n    If the data element is an array or is an element in a structure array, an index\n    must be specified for each dimension of the data.\n    <p>\n    This method is used when the string type cannot be determined until\n    run-time.  In those cases, the PCML document cannot be used to indicate\n    the string type so this method is used to get the value using the\n    string type that is specified.\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to a String.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for setting the value of an element in an array.\n    @param type The bidi string type, as defined by the CDRA (Character\n                Data Representation Architecture).\n    @exception PcmlException\n               If an error occurs.\n    @see com.ibm.as400.access.BidiStringType\n    */\n    public String getStringValue(String name, int[] indices, int type)\n        throws PcmlException                                            // @C9A\n    {\n        return m_pcmlDoc.getStringValue(name, new PcmlDimensions(indices), type);           // @C9A\n    }\n\n    /**\n    Returns the list of IBM i system messages returned from running the\n    program. An empty list is returned if the program has not been run yet.\n\n    @param name The name of the &lt;program&gt; element in the PCML document.\n    @return The array of messages returned by the system for the program.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public AS400Message[] getMessageList(String name)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getMessageList(name);\n    }\n\n    /**\n    Returns the number of bytes reserved for output for the named element.\n\n    @return The number of bytes reserved for output for the named element.\n    @param name The name of the &lt;data&gt; or &lt;struct&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getOutputsize(String name)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getOutputsize(name);\n    }\n\n    /**\n    Returns the number of bytes reserved for output for the named element and indices.\n\n    @return The number of bytes reserved for output for the named element.\n    @param name The name of the &lt;data&gt; or &lt;struct&gt; element in the PCML document.\n    @param indices An array of indices for accessing the output size of an element in an array.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getOutputsize(String name, int[] indices)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getOutputsize(name, new PcmlDimensions(indices));\n    }\n\n    /**\n    Returns the Java object value for the named element.\n    <p>\n    If the named element is an output value of a program, the value will\n    be converted from IBM i system data to a Java Object.\n    <p>\n    The type of object returned depends on the description in the PCML document.\n    <table border=1>\n    <tr valign=top><th>PCML Description</th><th>Object Returned</th></tr>\n    <tr valign=top><td><code>type=char</td><td><code>String</code></td></tr>\n    <tr valign=top><td><code>type=byte</td><td><code>byte[]</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=2<br>\n                             precision=15</td><td><code>Short</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=2<br>\n                             precision=16</td><td><code>Integer</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=4<br>\n                             precision=31</td><td><code>Integer</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=4<br>\n                             precision=32</td><td><code>Long</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=8<br>\n                             precision=63</td><td><code>Long</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=8<br>\n                             precision=64</td><td><code>BigInteger</code></td></tr>\n    <tr valign=top><td><code>type=packed</td><td><code>BigDecimal</code></td></tr>\n    <tr valign=top><td><code>type=zoned</td><td><code>BigDecimal</code></td></tr>\n    <tr valign=top><td><code>type=float<br>\n                             length=4</td><td><code>Float</code></td></tr>\n    <tr valign=top><td><code>type=float<br>\n                             length=8</td><td><code>Double</code></td></tr>\n    <tr valign=top><td><code>type=date</td><td><code>java.sql.Date</code></td></tr>\n    <tr valign=top><td><code>type=time</td><td><code>java.sql.Time</code></td></tr>\n    <tr valign=top><td><code>type=timestamp</td><td><code>java.sql.Timestamp</code></td></tr>\n    </table>\n\n    @return The Java object value for the named &lt;data&gt; element in the PCML document.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public Object getValue(String name)\n        throws PcmlException\n    {\n      if (Trace.isTraceOn()) Trace.log(Trace.PCML, \"Entered method ProgramCallDocument.getValue(\"+name+\")\");\n\n      Object val = m_pcmlDoc.getValue(name);\n\n      if (Trace.isTraceOn()) Trace.log(Trace.PCML, \"Exiting method ProgramCallDocument.getValue(\"+name+\")\");\n\n      return val;\n    }\n\n    /**\n    Returns the Java object value for the named element given indices to the data element.\n    If the data element is an array or is an element in a structure array, an index\n    must be specified for each dimension of the data.\n    <p>\n    If the named element is an output value of a program, the value will\n    be converted from IBM i system data to a Java Object.\n    <p>\n    The type of object returned depends on the description in the PCML document.\n    <table border=1>\n    <tr valign=top><th>PCML Description</th><th>Object Returned</th></tr>\n    <tr valign=top><td><code>type=char</td><td><code>String</code></td></tr>\n    <tr valign=top><td><code>type=byte</td><td><code>byte[]</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=2<br>\n                             precision=15</td><td><code>Short</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=2<br>\n                             precision=16</td><td><code>Integer</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=4<br>\n                             precision=31</td><td><code>Integer</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=4<br>\n                             precision=32</td><td><code>Long</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=8<br>\n                             precision=63</td><td><code>Long</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=8<br>\n                             precision=64</td><td><code>BigInteger</code></td></tr>\n    <tr valign=top><td><code>type=packed</td><td><code>BigDecimal</code></td></tr>\n    <tr valign=top><td><code>type=zoned</td><td><code>BigDecimal</code></td></tr>\n    <tr valign=top><td><code>type=float<br>\n                             length=4</td><td><code>Float</code></td></tr>\n    <tr valign=top><td><code>type=float<br>\n                             length=8</td><td><code>Double</code></td></tr>\n    <tr valign=top><td><code>type=date</td><td><code>java.sql.Date</code></td></tr>\n    <tr valign=top><td><code>type=time</td><td><code>java.sql.Time</code></td></tr>\n    <tr valign=top><td><code>type=timestamp</td><td><code>java.sql.Timestamp</code></td></tr>\n    </table>\n\n    @return The Java object value for the named &lt;data&gt; element in the PCML document.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for accessing the value of an element in an array.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public Object getValue(String name, int[] indices)\n        throws PcmlException\n    {\n      if (Trace.isTraceOn()) Trace.log(Trace.PCML, \"Entered method ProgramCallDocument.getValue(\"+name+\", indices)\");\n\n      Object val = m_pcmlDoc.getValue(name, new PcmlDimensions(indices));\n\n      if (Trace.isTraceOn()) Trace.log(Trace.PCML, \"Exiting method ProgramCallDocument.getValue(\"+name+\", indices)\");\n\n      return val;\n    }\n\n    /**\n    Gets the system on which programs are to be called.\n\n    @return The current system for this ProgramCallDocument.\n\n    @see #setSystem\n    **/\n    public AS400 getSystem()                                        // @C4A\n    {                                                               // @C4A\n        return m_as400;                                             // @C4A\n    }                                                               // @C4A\n\n\n    /**\n     Serializes the ProgramCallDocument. Note that XPCML documents\n     cannot be serialized.\n\n     The filename of the serialized file will be of the form\n     <pre>\n     <kbd><i>docName</i>.pcml.ser</kbd>\n     </pre>\n     where <kbd><i>docName</i>.pcml.ser</kbd> (lowercase) is the name of the document used to\n\t construct this object.\n\n     @exception PcmlException If an error occurs.\n     @deprecated Use {@link #serialize(File) serialize(File)} instead.\n     */\n    public void serialize()\n        throws PcmlException\n    {\n      if (m_pcmlDoc == null) {\n        throw new PcmlException(DAMRI.DOCUMENT_NOT_SET);\n      }\n      try {\n        savePcmlDocument(m_pcmlDoc);\n      }\n      catch (IOException e) {\n        if (Trace.isTraceErrorOn())\n          e.printStackTrace(Trace.getPrintWriter());\n        throw new PcmlException(e);\n      }\n    }\n\n\n    /**\n     Serializes the ProgramCallDocument to a stream.\n\n     @param outputStream The output stream to which to serialize the object.\n     @exception IOException  If an error occurs while writing to the stream.\n     @exception PcmlException  If an error occurs while processing PCML.\n     **/\n    public void serialize(OutputStream outputStream)\n      throws IOException, PcmlException\n    {\n      if (outputStream == null) {\n        throw new NullPointerException(\"outputStream\");\n      }\n      if (m_pcmlDoc == null) {\n        throw new PcmlException(DAMRI.DOCUMENT_NOT_SET);\n      }\n      savePcmlDocument(m_pcmlDoc, outputStream);\n    }\n\n    /**\n     Serializes the ProgramCallDocument to a file.\n\n     @param file The file to which to serialize the object.\n     @exception IOException  If an error occurs while writing to the file.\n     @exception XmlException  If an error occurs while processing RFML.\n     **/\n    public void serialize(File file)\n      throws IOException, XmlException\n    {\n      FileOutputStream fos = null;\n      try\n      {\n        fos = new FileOutputStream(file);\n        serialize(fos);\n      }\n      finally\n      {\n        if (fos != null) fos.close();\n      }\n    }\n\n    /**\n    Sets the Java object value for the named element using a int input.\n    <p>\n    The named element must be able to be set using a Integer object.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param value The int value for the named element.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public void setIntValue(String name, int value)\n        throws PcmlException\n    {\n        setValue(name, new Integer(value));\n    }\n\n    /**\n    Sets the Java object value for the named element using an int input value\n    given indices to the data element.\n    <p>\n    The named element must be able to be set using a Integer object.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for setting the value of an element in an array.\n    @param value The int value for the named element.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public void setIntValue(String name, int[] indices, int value)\n        throws PcmlException\n    {\n        setValue(name, indices, new Integer(value));\n    }\n\n\n    /**\n    Sets the Java object value for the named element using a String input.\n    The default bidi string type is assumed ({@link com.ibm.as400.access.BidiStringType#DEFAULT BidiStringType.DEFAULT}).\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param value The string value for the named element.\n    @exception PcmlException If an error occurs.\n    */\n    public void setStringValue(String name, String value)\n        throws PcmlException\n    {\n        setStringValue(name, value, BidiStringType.DEFAULT);\n    }\n\n    /**\n    Sets the Java object value for the named element using a String input.\n    <p>\n    This method is used when the string type cannot be determined until\n    run-time.  In those cases, the PCML document cannot be used to indicate\n    the string type so this method is used to set the value and the\n    string type of the input value.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param value The string value for the named element.\n    @param type The bidi string type, as defined by the CDRA (Character\n                Data Representation Architecture).\n    @exception PcmlException\n               If an error occurs.\n    @see com.ibm.as400.access.BidiStringType\n    */\n    public void setStringValue(String name, String value, int type)\n        throws PcmlException                                            // @C9A\n    {\n        m_pcmlDoc.setStringValue(name, value, type);                    // @C9A\n    }\n\n    /**\n    Sets the Java object value for the named element using a String input value\n    given indices to the data element.\n    <p>\n    This method is used when the string type cannot be determined until\n    run-time.  In those cases, the PCML document cannot be used to indicate\n    the string type so this method is used to set the value and the\n    string type of the input value.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for setting the value of an element in an array.\n    @param value The string value for the named element.\n    @param type The bidi string type, as defined by the CDRA (Character\n                Data Representation Architecture).\n    @exception PcmlException\n               If an error occurs.\n    @see com.ibm.as400.access.BidiStringType\n    */\n    public void setStringValue(String name, int[] indices, String value, int type)\n        throws PcmlException                                            // @C9A\n    {\n        m_pcmlDoc.setStringValue(name, value, new PcmlDimensions(indices), type);           // @C9A\n    }\n\n    /**\n    Sets the PCML or XPCML document resource.\n    The PCML or XPCML document resource will be loaded from the classpath.\n    The classpath will first be searched for a serialized resource.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML or XPCML source file.\n\n    @param docName The document resource name of the PCML document for the programs to be called.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    **/\n    public void setDocument(String docName)\n        throws PcmlException                                        // @C1A\n    {                                                               // @C1A\n        if (m_pcmlDoc != null)                                      // @C1A\n            throw new PcmlException(DAMRI.DOCUMENT_ALREADY_SET );   // @C1A\n\n        if (docName == null)                                        // @C1A\n            throw new NullPointerException(\"docName\");              // @C1A\n\n        m_pcmlDoc = loadPcmlDocument(docName, null,null);           // @C1A @C8C\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);                                // @C1A\n    }                                                               // @C1A\n\n\n    /**\n    Sets the XPCML document resource.\n    The XPCML document resource will be loaded from the classpath.\n\n    @param docName The document resource name of the PCML document for the programs to be called.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    **/\n    public void setDocument(String docName, InputStream xsdStream)\n        throws PcmlException                                        // @C1A\n    {                                                               // @C1A\n        if (m_pcmlDoc != null)                                      // @C1A\n            throw new PcmlException(DAMRI.DOCUMENT_ALREADY_SET );   // @C1A\n\n        if (docName == null)                                        // @C1A\n            throw new NullPointerException(\"docName\");              // @C1A\n\n        m_pcmlDoc = loadPcmlDocument(docName, null,xsdStream);      // @C1A @C8C\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);                                // @C1A\n    }                                                               // @C1A\n\n\n    /**\n    Sets the PCML or XPCML document resource.\n    The PCML or XPCML document resource will be loaded from the classpath.\n    The classpath will first be searched for a serialized resource.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML or XPCML source file.\n\n    @param docName The document resource name of the PCML document for the programs to be called.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    **/\n    public void setDocument(String docName, ClassLoader loader)     // @C8A\n        throws PcmlException                                        // @C8A\n    {                                                               // @C8A\n        if (m_pcmlDoc != null)                                      // @C8A\n            throw new PcmlException(DAMRI.DOCUMENT_ALREADY_SET );   // @C8A\n\n        if (docName == null)                                        // @C8A\n            throw new NullPointerException(\"docName\");              // @C8A\n\n        m_pcmlDoc = loadPcmlDocument(docName, loader,null);         // @C8A\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);                                // @C8A\n    }                                                               // @C8A\n\n    /**\n    Sets the PCML or XPCML document resource.\n    The document resource will be loaded from the classpath.\n\n    @param docName The document resource name of the PCML or XPCML document for the programs to be called.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    **/\n    public void setDocument(String docName, ClassLoader loader,InputStream xsdStream)     // @C8A\n        throws PcmlException                                        // @C8A\n    {                                                               // @C8A\n        if (m_pcmlDoc != null)                                      // @C8A\n            throw new PcmlException(DAMRI.DOCUMENT_ALREADY_SET );   // @C8A\n\n        if (docName == null)                                        // @C8A\n            throw new NullPointerException(\"docName\");              // @C8A\n\n        m_pcmlDoc = loadPcmlDocument(docName, loader, xsdStream);   // @C8A\n        m_pcmlDoc.setAs400(m_as400);                                // @C8A\n    }                                                               // @C8A\n\n\n    /**\n    Sets the system on which to call programs.\n\n    @param system  The system on which to call programs.\n\n    **/\n    public void setSystem(AS400 system)                             // @C1A\n    {                                                               // @C1A\n        if (system == null)                                         // @C1A\n            throw new NullPointerException(\"system\");               // @C1A\n\n        m_as400 = system;                                           // @C1A\n        m_pcmlDoc.setAs400(m_as400);                                // @C1A\n    }                                                               // @C1A\n\n    /**\n    Sets the Java object value for the named element.\n    <p>\n    If the input value provided is not an instance of the\n    correct Java class for the defined data type, it will be converted\n    to the correct Java class. For example, an element defined as \"<code>type=int length=2 precision=15</code>\",\n    will be converted to a Java Short object. In this case the value specified must be an instance of Number or String.\n    <p>\n    If the named element is an input value to a program, the value will\n    be converted to IBM i system data when {@link #callProgram(String) callProgram()} is called.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param value The java object value for the named element. The type of Object passed must be\n    the correct type for the element definition or a String that can be converted to the correct type.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public void setValue(String name, Object value)\n        throws PcmlException\n    {\n        m_pcmlDoc.setValue(name, value);\n    }\n\n    /**\n    Sets the Java object value for the named element\n    given indices to the data element.\n    If the data element is an array or is an element in a structure array, an index\n    must be specified for each dimension of the data.\n    <p>\n    If the input value provided is not an instance of the\n    correct Java class for the defined data type, it will be converted\n    to the correct Java class. For example, an element defined as \"<code>type=int length=2 precision=15</code>\",\n    will be converted to a Java Short object. In this case the value specified must be an instance of Number or String.\n    <p>\n    If the named element is an input value to a program, the value will\n    be converted to IBM i system data when {@link #callProgram(String) callProgram()} is called.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for setting the value of an element in an array.\n    @param value The java object value for the named element. The type of Object passed must be\n    the correct type for the element definition or a String that can be converted to the correct type.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public void setValue(String name, int[] indices, Object value)\n        throws PcmlException\n    {\n        m_pcmlDoc.setValue(name, value, new PcmlDimensions(indices));\n    }\n\n    /**\n    Allows for dynamically specifying the program path of the program to be called.\n\n    @param program The name of the &lt;program&gt; element in the PCML document.\n    @param path A String containing the path to the program object to be run on the system.\n    @exception PcmlException\n               If an error occurs.\n    @see #setDocument(String)\n    @see #ProgramCallDocument(AS400,String,InputStream,ClassLoader,InputStream,int)\n    */\n    public void setPath(String program, String path)                    // @D1A\n        throws PcmlException                                            // @D1A\n    {\n        m_pcmlDoc.setPath(program, path);                               // @D1A\n    }\n\n    /**\n    Allows the overriding of the threadsafe attribute of a program element.\n\n    @param program The name of the &lt;program&gt; element in the PCML document.\n    @param threadsafe A boolean indicating whether the named program element should be considered\n    thread safe (true) or not (false).\n    @exception PcmlException\n               If an error occurs.\n    */\n    public void setThreadsafeOverride(String program, boolean threadsafe)\n        throws PcmlException\n    {\n        m_pcmlDoc.setThreadsafeOverride(program, threadsafe);           // @C6A\n    }\n\n    /**\n    Gets the value of the override of the threadsafe attribute of a program element.\n\n    @param program The name of the &lt;program&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public boolean getThreadsafeOverride(String program)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getThreadsafeOverride(program);           // @C6A\n    }\n\n\n    /**\n      Saves a PcmlDocument as a serialized resource.\n    **/\n    private static void savePcmlDocument(PcmlDocument pd)\n        throws PcmlException, IOException\n    {\n      String outFileName = pd.getDocName() + SystemResourceFinder.m_pcmlSerializedExtension;\n      BufferedOutputStream fos = null;\n      try\n      {\n        fos = new BufferedOutputStream(new FileOutputStream(outFileName));\n\n        savePcmlDocument(pd, fos);\n      }\n      finally\n      {\n        if (fos != null) fos.close();\n      }\n    }\n\n\n    /**\n      Saves a PcmlDocument as a serialized resource.\n    **/\n    private static void savePcmlDocument(PcmlDocument pd, OutputStream outStream)\n        throws PcmlException, IOException\n    {\n        pd.setSerializingWithData(false);\n        ObjectOutputStream out = null;\n\n        try\n        {\n          out = new ObjectOutputStream(outStream);\n          out.writeObject(pd);\n\n          String outFileName = pd.getDocName() + SystemResourceFinder.m_pcmlSerializedExtension;\n          Trace.log(Trace.PCML, SystemResourceFinder.format(DAMRI.PCML_SERIALIZED, new Object[] {outFileName} )); // @D2C\n        }\n        finally\n        {\n          if (out != null) out.close();\n        }\n    }\n\n\n    /**\n      Loads a serialized PcmlDocument or constructs the document from\n      a PCML source file.\n    **/\n    private static PcmlDocument loadPcmlDocument(String docName, ClassLoader loader, InputStream xsdStream)        // @C8C\n        throws PcmlException\n    {\n        PcmlDocument pd = null;\n\n\t\tpd = loadSerializedPcmlDocument(docName, loader);               // @C8C\n\n        // If a PcmlDocument was successfully loaded from a serialized file\n        // return the document loaded.\n        if (pd != null)\n            return pd;\n\n\t\tpd = loadZippedSerializedPcmlDocument(docName, loader);         // @C7A @C8C\n\n        // If a PcmlDocument was successfully loaded from a zipped serialized file\n        // return the document loaded.\n        if (pd != null)                                         // @C7A\n            return pd;                                          // @C7A\n\n\t\tpd = loadSourcePcmlDocument(docName, loader, xsdStream);                   // @C8C\n\n        return pd;\n    }\n\n    private static PcmlDocument loadSerializedPcmlDocumentFromStream(InputStream docStream)\n        throws PcmlException\n    {\n        PcmlDocument pd = null;\n        ObjectInputStream in = null;\n\n        try\n        {\n            // Try to open the serialized PCML document\n            in = new ObjectInputStream(docStream);\n            pd = (PcmlDocument)in.readObject();\n        }\n        catch (Exception e)\n        {\n          if (Trace.isTraceErrorOn())\n             e.printStackTrace(Trace.getPrintWriter());\n          throw new PcmlException(e);\n        }\n        finally\n        {\n          if (in != null) try { in.close(); } catch (Exception e) {}\n        }\n\n        return pd;\n    }\n\n    private static PcmlDocument loadSourcePcmlDocumentFromStream(String docName, InputStream docStream, ClassLoader loader, InputStream xsdStream, boolean isXPCML) throws PcmlException\n    {\n      PcmlDocument pd = null;\n\n      // Construct the PCML document from a source file\n      try\n      {\n          PcmlSAXParser psp = new PcmlSAXParser(docName, docStream, xsdStream, isXPCML, exceptionIfParseError_);\n          pd = psp.getPcmlDocument();\n      }\n      catch (ParseException pe)\n      {\n          if (Trace.isTraceErrorOn())                         \n            pe.printStackTrace(Trace.getPrintWriter());       \n          pe.reportErrors();\n          throw new PcmlException(pe);\n      }\n      catch (PcmlSpecificationException pse)\n      {\n        if (Trace.isTraceErrorOn())                         \n          pse.printStackTrace(Trace.getPrintWriter());       \n          pse.reportErrors();\n          throw new PcmlException(pse);\n      }\n      catch (RuntimeException e)\n      {\n        if (Trace.isTraceErrorOn())                         \n          e.printStackTrace(Trace.getPrintWriter());       \n        Throwable cause = e.getCause();\n        if (cause instanceof PcmlSpecificationException)\n        {\n          PcmlSpecificationException pse = (PcmlSpecificationException)cause;\n          pse.reportErrors();\n          throw new PcmlException(pse);\n        }\n        else\n        {\n          if (Trace.isTraceErrorOn()) //@E0A\n            e.printStackTrace(Trace.getPrintWriter()); //@E0A\n          throw new PcmlException(e);\n        }\n      }\n      catch (Exception e)\n      {\n        if (Trace.isTraceErrorOn())\n           e.printStackTrace(Trace.getPrintWriter());\n        throw new PcmlException(e);\n      }\n\n      return pd;\n    }\n\n    /**\n      Loads a serialized PcmlDocument from a serialized file.\n    **/\n    private static PcmlDocument loadSerializedPcmlDocument(String docName, ClassLoader loader)  // @C8C\n        throws PcmlException\n    {\n        PcmlDocument pd = null;\n        InputStream is = null;\n        ObjectInputStream in = null;\n\n        // First try to find a serialized PCML document\n        try\n        {\n            // Try to open the serialized PCML document\n            is = SystemResourceFinder.getSerializedPCMLDocument(docName, loader);   // @C8C\n\n            in = new ObjectInputStream(is);\n            pd = (PcmlDocument)in.readObject();\n        }\n        catch (MissingResourceException e)\n        {\n            // Ignore exception and try looking for PCML source (below)\n        }\n        catch (StreamCorruptedException e)\n        {\n            // Ignore exception and try looking for zipped serialized PCML (below)\n        }\n        catch (IOException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            throw new PcmlException(e);\n        }\n        catch (ClassNotFoundException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            throw new PcmlException(e);\n        }\n        finally\n        {\n          if (in != null) try { in.close(); } catch (Exception e) {\n            if (Trace.isTraceErrorOn())                        \n              e.printStackTrace(Trace.getPrintWriter());      \n          }\n          if (is != null) try { is.close(); } catch (Exception e) {\n            if (Trace.isTraceErrorOn())                        \n              e.printStackTrace(Trace.getPrintWriter());      \n            \n          }\n        }\n\n        return pd;\n    }\n\n    /**\n      Loads a serialized PcmlDocument from a serialized file.\n    **/\n    private static PcmlDocument loadZippedSerializedPcmlDocument(String docName, ClassLoader loader)    // @C8C\n        throws PcmlException\n    {\n        PcmlDocument pd = null;\n        InputStream is = null;\n        GZIPInputStream gzis = null;\n        ObjectInputStream in = null;\n\n        // First try to find a serialized PCML document\n        try\n        {\n            // Try to open the serialized PCML document\n            is = SystemResourceFinder.getSerializedPCMLDocument(docName, loader);       // @C8C\n\n            gzis = new GZIPInputStream(is);\n            in = new ObjectInputStream(gzis);\n            pd = (PcmlDocument)in.readObject();\n        }\n        catch (MissingResourceException e)\n        {\n            // Ignore exception and try looking for PCML source (below)\n        }\n        catch (IOException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            throw new PcmlException(e);\n        }\n        catch (ClassNotFoundException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            throw new PcmlException(e);\n        }\n        finally\n        {\n          if (in != null)   try { in.close(); } catch (Exception e) { \n            if (Trace.isTraceErrorOn())                        \n              e.printStackTrace(Trace.getPrintWriter());      \n\n          }\n          if (gzis != null) try { gzis.close(); } catch (Exception e) {\n            if (Trace.isTraceErrorOn())                        \n              e.printStackTrace(Trace.getPrintWriter());      \n\n          }\n          if (is != null)   try { is.close(); } catch (Exception e) {\n            if (Trace.isTraceErrorOn())                        \n              e.printStackTrace(Trace.getPrintWriter());      \n\n          }\n        }\n\n        return pd;\n    }\n\n    /**\n      Loads a PcmlDocument from a PCML source file.\n    **/\n    private static PcmlDocument loadSourcePcmlDocument(String docName, ClassLoader loader, InputStream xsdStream)      // @C8C\n        throws PcmlException\n    {\n\n        PcmlDocument pd = null;\n\n        // Construct the PCML document from a source file\n        try\n        {\n            InputStream docStream = SystemResourceFinder.getPCMLDocument(docName, loader);\n            boolean isXPCML = SystemResourceFinder.isXPCML(docName,loader);\n            PcmlSAXParser psp = new PcmlSAXParser(docName, docStream, xsdStream, isXPCML, exceptionIfParseError_);         // @C2A @C8C\n            pd = psp.getPcmlDocument();                             // @C2A\n        }\n        catch (ParseException pe)\n        {\n            pe.reportErrors();\n            throw new PcmlException(pe);\n        }\n        catch (PcmlSpecificationException pse)\n        {\n            pse.reportErrors();\n            throw new PcmlException(pse);\n        }\n        catch (RuntimeException e)\n        {\n          Throwable cause = e.getCause();\n          if (cause instanceof PcmlSpecificationException)\n          {\n            PcmlSpecificationException pse = (PcmlSpecificationException)cause;\n            pse.reportErrors();\n            throw new PcmlException(pse);\n          }\n          else\n          {\n            if (Trace.isTraceErrorOn()) //@E0A\n              e.printStackTrace(Trace.getPrintWriter()); //@E0A\n            throw new PcmlException(e);\n          }\n        }\n        catch (Exception e) //@E0A\n        {\n          if (Trace.isTraceErrorOn()) //@E0A\n             e.printStackTrace(Trace.getPrintWriter()); //@E0A\n          throw new PcmlException(e);\n        }\n\n        return pd;\n    }\n\n\n    // @E1A -- ALL NEW XPCML methods....\n    /**\n     Generates XPCML representing the data associated with the passed-in program name.\n     Note: XPCML cannot be generated from a serialized PCML file.\n     XPCML is XML based on the XML schema defined in xpcml.xsd.   XPCML is similar\n     to PCML but allows for better validation of parameters and allows parameter\n     data to be input and output within an XML document.  PCML is data-less in\n     that only parameter formats are input via PCML.  In PCML, data values are set using\n     the setValue methods of the ProgramCallDocument class, and data values are\n     gotten using the getValue methods of ProgramCallDocument.  In XPCML, data values\n     can be specified directly within the XPCML source document, and data values can be output\n     as XML using the generateXPCML method.\n     Throws an XmlException if this object contains no data.\n     @param pgmName The program to generate XPCML for\n     @param outputStream The output stream to which to write the text.\n     @exception IOException  If an error occurs while writing the data.\n     @exception XmlException  If an error occurs while processing XPCML.\n     **/\n    public void generateXPCML(String pgmName, OutputStream outputStream)\n      throws IOException, XmlException\n    {\n      if (outputStream == null) {\n        throw new NullPointerException(\"outputStream\");\n      }\n      if (m_pcmlDoc == null) {\n        throw new XmlException(DAMRI.DOCUMENT_NOT_SET );\n      }\n      m_pcmlDoc.generateXPCML(pgmName, outputStream);\n    }\n\n\n    // @E2C -- Added more info on XPCML.  Changed all RFML references to XPCML.\n    /**\n     Generates XPCML representing the data contained in the entire PCML node tree.\n     Note: XPCML cannot be generated from a serialized PCML file.\n     XPCML is XML based on the XML schema defined in xpcml.xsd.   XPCML is similar\n     to PCML but allows for better validation of parameters and allows parameter\n     data to be input and output within an XML document.  PCML is data-less in\n     that only parameter formats are input via PCML.  In PCML, data values are set using\n     the setValue methods of the ProgramCallDocument class and data values are\n     gotten using the getValue methods of ProgramCallDocument.  In XPCML, data values\n     can be specified directly within the XPCML document, and data values can be output\n     as XML using the generateXPCML method.\n\n     Throws an XmlException if this object contains no data.\n\n     @param outputStream The output stream to which to write the text.\n     @exception IOException  If an error occurs while writing the data.\n     @exception XmlException  If an error occurs while processing XPCML.\n     **/\n    public void generateXPCML(OutputStream outputStream)\n      throws IOException, XmlException\n    {\n      if (outputStream == null) {\n        throw new NullPointerException(\"outputStream\");\n      }\n      if (m_pcmlDoc == null) {\n        throw new XmlException(DAMRI.DOCUMENT_NOT_SET );\n      }\n      m_pcmlDoc.generateXPCML(null, outputStream);\n    }\n\n\n    /**\n     Generates XPCML representing the data contained in the entire PCML node tree.\n     Note: XPCML cannot be generated from a serialized PCML file.\n     XPCML is XML based on the XML schema defined in xpcml.xsd.   XPCML is similar\n     to PCML but allows for better validation of parameters and allows parameter\n     data to be input and output within an XML document.  PCML is data-less in\n     that only parameter formats are input via PCML.  In PCML, data values are set using\n     the setValue methods of the ProgramCallDocument class and data values are\n     gotten using the getValue methods of ProgramCallDocument.  In XPCML, data values\n     can be specified directly within the XPCML document, and data values can be output\n     as XML using the generateXPCML method.\n     Throws an XmlException if this object contains no data.\n\n     @param fileName The pathname of the file to which to write the text.\n     @exception IOException  If an error occurs while writing the data.\n     @exception XmlException  If an error occurs while processing XPCML.\n     **/\n    public void generateXPCML(String fileName)\n      throws IOException, XmlException\n    {\n      if (fileName == null) {\n        throw new NullPointerException(\"fileName\");\n      }\n      FileOutputStream fos = null;\n      try\n      {\n        fos = new FileOutputStream(fileName);\n        generateXPCML(null, fos);\n      }\n      finally {\n        if (fos != null) fos.close();\n      }\n    }\n\n    /**\n     Generates XPCML representing the data contained for the passed in program name.\n     Note: XPCML cannot be generated from a serialized PCML file.\n     XPCML is XML based on the XML schema defined in xpcml.xsd.   XPCML is similar\n     to PCML but allows for better validation of parameters and allows parameter\n     data to be input and output within an XML document.  PCML is data-less in\n     that only parameter formats are input via PCML.  In PCML, data values are set using\n     the setValue methods of the ProgramCallDocument class and data values are\n     gotten using the getValue methods of ProgramCallDocument.  In XPCML, data values\n     can be specified directly within the XPCML document, and data values can be output\n     as XML using the generateXPCML method.\n     Throws an XmlException if this object contains no data.\n\n     @param pgmName  The program name to generate XPCML for.\n     @param fileName The pathname of the file to which to write the text.\n     @exception IOException  If an error occurs while writing the data.\n     @exception XmlException  If an error occurs while processing XPCML.\n     **/\n    public void generateXPCML(String pgmName,String fileName)\n      throws IOException, XmlException\n    {\n      if (fileName == null) {\n        throw new NullPointerException(\"fileName\");\n      }\n      if (pgmName == null) {\n        throw new NullPointerException(\"pgmName\");\n      }\n      FileOutputStream fos = null;\n      try\n      {\n        fos = new FileOutputStream(fileName);\n        generateXPCML(pgmName, fos);\n      }\n      finally {\n        if (fos != null) fos.close();\n      }\n    }\n\n     // ******************************\n     // @E0A -- New method           *\n     // ******************************\n     /**\n      Sets the XSD name that will appear in the generated &lt;xpcml&gt; tag from the <tt>generateXPCML()</tt> methods.\n      If name is not set then \"xpcml.xsd\" will appear in &lt;xpcml&gt; tag.  This allows the user\n                     to override the default and put in the name of their own xsd that was\n                     used in condensing the XPCML output.\n\n     @param xsdName  The XSD name to appear in the &lt;xpcml&gt; tag when XPCML is output using the\n                     generateXPCML method.\n    **/\n\n    public void setXsdName(String xsdName)\n    {\n        m_pcmlDoc.setXsdName(xsdName);\n    }\n\n\n     // ******************************\n     // @E0A -- New method           *\n     // ******************************\n     /**\n      Returns the value of the XSD name to be used on the &lt;xpcml&gt; tag when\n                     generating XPCML.\n\n     @return The String \"xsdName\" value for this program object.\n     **/\n\n    public String getXsdName()\n    {\n        return m_pcmlDoc.getXsdName();\n    }\n\n\n    public void endInternal2(RJob rJob, int delayTime)\n\tthrows ResourceException\n\t{\n\t    // Validate the properties.\n\t    if (rJob.name_ == null)\n\t        throw new ExtendedIllegalStateException(\"name\", ExtendedIllegalStateException.PROPERTY_NOT_SET);\n\t    if (rJob.number_ == null)\n\t        throw new ExtendedIllegalStateException(\"number\", ExtendedIllegalStateException.PROPERTY_NOT_SET);\n\t    if (rJob.user_ == null)\n\t        throw new ExtendedIllegalStateException(\"user\", ExtendedIllegalStateException.PROPERTY_NOT_SET);\n\t\n\t    // Establish the connection if needed.\n\t    if (!rJob.isConnectionEstablished())\n\t        rJob.establishConnection();\n\t\n\t    // Issue the ENDJOB CL command.\n\t    AS400 sys = null;\n\t    try {\n\t        StringBuffer buffer = new StringBuffer();\n\t        buffer.append(\"ENDJOB JOB(\");\n\t        buffer.append(rJob.number_);\n\t        buffer.append('/');\n\t        buffer.append(rJob.user_);\n\t        buffer.append('/');\n\t        buffer.append(rJob.name_);\n\t        buffer.append(\") OPTION(\");\n\t        if (delayTime == 0) {\n\t            buffer.append(\"*IMMED)\");\n\t        }\n\t        else {\n\t            buffer.append(\"*CNTRLD)\");\n\t            if (delayTime > 0) {\n\t                buffer.append(\" DELAY(\");\n\t                buffer.append(delayTime);\n\t                buffer.append(\")\");\n\t            }\n\t        }\n\t        String endJob = buffer.toString();\n\t\n\t        if (Trace.isTraceOn())\n\t            Trace.log(Trace.INFORMATION, \"Ending the job:\" + endJob);\n\t\n\t        // Use a separate connection, in case the job we're trying to\n\t        // end is the Remote Command Call host server.             @A1a\n\t        sys = new AS400(rJob.getSystem());                            //@A1a\n\t        CommandCall commandCall = new CommandCall(sys, endJob);  //@A1c\n\t        boolean success = commandCall.run();\n\t        if (!success)\n\t            throw new ResourceException(commandCall.getMessageList());\n\t    }\n\t    catch(Exception e) {\n\t        throw new ResourceException(e);\n\t    }\n\t    finally {\n\t        if (sys != null)  sys.disconnectAllServices();\n\t    }\n\t}\n\n\t/**\n     Transforms a PCML stream to its equivalent XPCML stream.\n     Throws an XmlException if this object contains no data.\n\n     @param pcmlStream The PCML input stream.\n     @param xpcmlStream  The output XPCML stream.\n     @exception IOException  If an error occurs while writing the data.\n     @exception PcmlException  If an error occurs while processing XPCML.\n\n     **/\n\n    public static void transformPCMLToXPCML(InputStream pcmlStream, OutputStream xpcmlStream)\n           throws IOException, PcmlException, TransformerException, SAXException\t\n    \t{\n\n           if (pcmlStream == null) {\n             throw new NullPointerException(\"pcmlStream\");\n           }\n\n           if (xpcmlStream == null) {\n             throw new NullPointerException(\"xpcmlStream\");\n           }\n\n           // Transform the PCML document to its equivalent XPCML document\n           XPCMLHelper.doTransform(\"pcml_xpcml.xsl\",pcmlStream, xpcmlStream); //@CRS\n      }\n\n    /**\n     Transforms a fully specified XPCML stream to a more condensed XPCML stream\n     and an XSD stream representing the new type definitions created while condensing.\n     Throws an XmlException if this object contains no data.\n\n     @param fullStream The full XPCML input stream.\n     @param xsdStream  The output xsd stream.\n     @param condensedStream  The output condensed XPCML stream.\n     @param xsdStreamName  The name of the xsd stream (\"name.xsd\") that will be created\n     @exception IOException  If an error occurs while writing the data.\n     @exception PcmlException  If an error occurs while processing XPCML.\n\n     **/\n\n    public static void condenseXPCML(InputStream fullStream, OutputStream xsdStream, OutputStream condensedStream, String xsdStreamName)\n           throws IOException, PcmlException, TransformerException, SAXException\t\n    \t{\n           String xpcmlName=\"\";\n\n           if (fullStream == null) {\n             throw new NullPointerException(\"fullStream\");\n           }\n\n           if (xsdStream == null) {\n             throw new NullPointerException(\"xsdStream\");\n           }\n\n           if (condensedStream == null) {\n             throw new NullPointerException(\"condensedStream\");\n           }\n\n           if (xsdStreamName == null) {\n             throw new NullPointerException(\"xsdStreamName\");\n           }\n\n           // Copy input stream fullStream into twoOutputStream\n           ByteArrayOutputStream outStream1 = new ByteArrayOutputStream();\n\n           byte[] bytesIn = new byte[1000];\n           int bytesRead = 0;\n           bytesRead = fullStream.read(bytesIn);\n\n           while (bytesRead != -1)\n           {\n              outStream1.write(bytesIn,0,bytesRead);\n              bytesRead = fullStream.read(bytesIn);\n           }\n\n           outStream1.flush();\n           outStream1.close();\n\n           // Cache the line count of the header\n           ByteArrayInputStream inStreamFull = new ByteArrayInputStream(outStream1.toByteArray());\n           LineNumberReader lnr = new LineNumberReader(new InputStreamReader(inStreamFull));\n           try\n           {\n             String line = lnr.readLine();\n             boolean found=false;\n             while (line != null && !found)\n             {\n               // Look for xpcml tag\n               if (line.indexOf(\"xsi:noNamespaceSchemaLocation=\") != -1)\n               {\n                  found = true;\n                  int index1 = line.indexOf(\"xsi:noNamespaceSchemaLocation=\");\n                  int index2=0;\n                  index2 = line.indexOf(\"'\", index1);\n                  int index3=0;\n                  if (index2 == -1)\n                  {\n                     index2 = line.indexOf(\"\\\"\",index1);\n                     if (index2 != -1)\n                       index3 = line.indexOf(\"\\\"\", index2+1);\n                  }\n                  else\n                  {\n                     index3 = line.indexOf(\"'\",index2+1);\n                  }\n                  xpcmlName = line.substring(index2+1,index3);\n                  continue;\n               }\n               if (line.indexOf(\"xsi:noNamespaceSchemaLocation =\") != -1)\n               {\n                  found = true;\n                  int index1 = line.indexOf(\"xsi:noNamespaceSchemaLocation =\");\n                  int index2=0;\n                  index2 = line.indexOf(\"'\", index1);\n                  int index3=0;\n                  if (index2 == -1)\n                  {\n                     index2 = line.indexOf(\"\\\"\",index1);\n                     if (index2 != -1)\n                       index3 = line.indexOf(\"\\\"\", index2+1);\n                  }\n                  else\n                  {\n                     index3 = line.indexOf(\"'\",index2+1);\n                  }\n                  xpcmlName = line.substring(index2+1,index3);\n                  continue;\n               }\n               line = lnr.readLine();\n             }\n           }\n           catch (IOException e)\n           {\n             Trace.log(Trace.PCML, \"Error when reading input stream in condenseXPCML\");\n             if (Trace.isTraceErrorOn())\n               e.printStackTrace(Trace.getPrintWriter());\n             throw new PcmlException(e);\n           }\n           if (xpcmlName == \"\")\n              xpcmlName=\"xpcml.xsd\";\n\n           // Write contents of ByteArrayOutputStream to ByteArrayInputStream\n           ByteArrayInputStream inStream1 = new ByteArrayInputStream(outStream1.toByteArray());  // no need to close byte-array stream\n           ByteArrayInputStream inStream2 = new ByteArrayInputStream(outStream1.toByteArray());  // no need to close byte-array stream\n\n           // Create new XSD type definitions based on full XPCML stream\n           XPCMLHelper.doCondenseTransform(\"xpcml_xsd.xsl\",inStream1, xsdStream, xpcmlName); //@CRS\n           // Create condensed XPCML using XSD and full XPCML stream\n           XPCMLHelper.doCondenseTransform(\"xpcml_basic.xsl\",inStream2, condensedStream, xsdStreamName); //@CRS\n\n      }\n\n\n    // Traces a warning message about a null-valued parameter.\n    private static final void warnNull(String parmName)\n    {\n      if (Trace.isTraceOn()) Trace.log(Trace.WARNING, \"Null value specified for '\" + parmName + \"' parameter on ProgramCallDocument constructor.\");\n    }\n\n\n}",
                "methodCount": 68
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 15,
                "candidates": [
                    {
                        "lineStart": 366,
                        "lineEnd": 381,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method writeObject to class PcmlDocument",
                        "description": "Move method writeObject to com.ibm.as400.data.PcmlDocument\nRationale: The method writeObject() is responsible for custom serialization of the object, which is closely related to the state and behavior of the PcmlDocument class. The method checks if the m_pcmlDoc is not null and sets a flag for serialization, which indicates that it is directly manipulating the state of the PcmlDocument. Since serialization is a core functionality that pertains to how instances of PcmlDocument are serialized, it is more appropriate for this method to reside within the PcmlDocument class rather than its current location.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1345,
                        "lineEnd": 1366,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method savePcmlDocument to class SystemResourceFinder",
                        "description": "move method savePcmlDocument to PsiClass:SystemResourceFinder\nRationale: The method savePcmlDocument() is responsible for saving a PcmlDocument as a serialized resource. This functionality aligns closely with the responsibilities of the SystemResourceFinder class, which deals with resource management and loading. Moving this method to SystemResourceFinder would enhance the cohesion of the class, as it already contains methods related to resource loading and management. Additionally, the method's use of the serialized extension defined in SystemResourceFinder further supports this move.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1423,
                        "lineEnd": 1473,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method loadSourcePcmlDocumentFromStream to class PcmlSAXParser",
                        "description": "move method loadSourcePcmlDocumentFromStream to PsiClass:PcmlSAXParser\nRationale: The method loadSourcePcmlDocumentFromStream() is responsible for parsing a PCML document from an InputStream, which directly relates to the functionality of the PcmlSAXParser class. This class is designed to handle the parsing of PCML documents, and the method's logic aligns with the responsibilities of a SAX parser, including error handling and document structure management. Moving this method to PcmlSAXParser will enhance cohesion by keeping all parsing-related functionality within the same class, thereby improving maintainability and clarity.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1589,
                        "lineEnd": 1640,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method loadSourcePcmlDocument to class SystemResourceFinder",
                        "description": "move method loadSourcePcmlDocument to PsiClass:SystemResourceFinder\nRationale: The method loadSourcePcmlDocument() is responsible for loading a PcmlDocument from a PCML source file, which involves resource loading and parsing. The SystemResourceFinder class already contains methods for loading resources (like getPCMLDocument) and determining if a document is XPCML. Therefore, it is logical to move this method to SystemResourceFinder to centralize resource loading functionality and maintain a cohesive design. This will also help in reducing the responsibilities of the current class, which may be handling too many unrelated tasks.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 436,
                        "lineEnd": 485,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method callProgram to class PcmlDocument",
                        "description": "Move method callProgram to com.ibm.as400.data.PcmlDocument\nRationale: The method callProgram(String name) is responsible for invoking a program defined in the PCML document. This functionality is inherently tied to the PcmlDocument class, which manages the structure and elements of the PCML document, including program nodes. Moving this method to PcmlDocument aligns it with the class's purpose of handling program calls and encapsulates the logic related to program execution within the class that represents the document structure. The existing class, which is not specified, likely does not have the context or responsibility for managing program calls, making it inappropriate for this method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 814,
                        "lineEnd": 870,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getValue to class PcmlDocument",
                        "description": "Move method getValue to com.ibm.as400.data.PcmlDocument\nRationale: The method getValue(String name) is responsible for retrieving the Java object value for a named element in a PCML document. This functionality is inherently tied to the structure and data representation of the PCML document itself, making it more appropriate for the PcmlDocument class. The existing class, ProgramCallDocument, appears to be focused on managing program calls rather than directly handling the data representation and retrieval from the PCML document. By moving getValue to PcmlDocument, we align the method with the class that encapsulates the document's data structure, improving cohesion and maintainability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1813,
                        "lineEnd": 1869,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method endInternal2 to class AS400",
                        "description": "Move method endInternal2 to com.ibm.as400.access.AS400\nRationale: The method 'endInternal2' is responsible for ending a job on the AS400 system, which involves issuing a command to the AS400 server. This functionality is closely related to the AS400 class, which manages connections and commands to the IBM i host servers. Moving this method to the AS400 class will enhance cohesion, as it directly interacts with the AS400 system's command execution and connection management. Additionally, it will allow for better encapsulation of job-related operations within the AS400 class, making the codebase cleaner and more maintainable.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 872,
                        "lineEnd": 931,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getValue to class PcmlDocument",
                        "description": "Move method getValue to com.ibm.as400.data.PcmlDocument\nRationale: The method getValue(String name, int[] indices) is responsible for retrieving the Java object value for a named element in a PCML document, which directly relates to the functionality of the PcmlDocument class. This class is designed to handle the structure and data of PCML documents, making it the appropriate place for this method. Moving it to PcmlDocument will enhance cohesion, as it will reside within a class that manages the data and structure it operates on, rather than being in a class that may not have a direct relationship with the data retrieval process.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1675,
                        "lineEnd": 1703,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method generateXPCML to class PcmlDocument",
                        "description": "Move method generateXPCML to com.ibm.as400.data.PcmlDocument\nRationale: The method generateXPCML() is responsible for generating XPCML from the data contained in a PCML node tree. This functionality is inherently tied to the structure and data of the PCML document, which is represented by the PcmlDocument class. Moving this method to the PcmlDocument class aligns it with the class's purpose of managing and manipulating PCML data. Additionally, the method relies on the m_pcmlDoc attribute, which is likely part of the PcmlDocument class, making it necessary for the method to reside there to access the required data and context for generating XPCML.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 799,
                        "lineEnd": 812,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getOutputsize to class PcmlDocument",
                        "description": "Move method getOutputsize to com.ibm.as400.data.PcmlDocument\nRationale: The method getOutputsize(String name, int[] indices) is responsible for retrieving the output size of a named element in the PCML document. This functionality is closely related to the management and representation of the PCML document itself, which is encapsulated within the PcmlDocument class. Moving this method to PcmlDocument aligns it with other methods that deal with the structure and data of the PCML document, enhancing cohesion. The current class, which is not provided, likely does not have the context or responsibility for managing output sizes, making it inappropriate for this method to reside there.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 651,
                        "lineEnd": 669,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getIntValue to class PcmlDocument",
                        "description": "Move method getIntValue to com.ibm.as400.data.PcmlDocument\nRationale: The method getIntValue(String name, int[] indices) is responsible for retrieving an integer value from a PCML document based on the provided name and indices. This functionality is closely related to the operations performed by the PcmlDocument class, which manages the overall structure and data of a PCML document. Moving this method to the PcmlDocument class enhances cohesion, as it centralizes the logic for accessing and manipulating data within the document. Additionally, the method utilizes the m_pcmlDoc instance variable, which is likely a part of the PcmlDocument class, indicating that it is more appropriate for this class to handle such data retrieval operations.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 743,
                        "lineEnd": 768,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getStringValue to class PcmlDocument",
                        "description": "Move method getStringValue to com.ibm.as400.data.PcmlDocument\nRationale: The method getStringValue(String name, int[] indices, int type) is responsible for retrieving a string value from a data element defined in a PCML document. This functionality is inherently tied to the structure and management of the PCML document itself, which is encapsulated within the PcmlDocument class. Moving this method to PcmlDocument aligns it with other methods that handle data retrieval and manipulation within the document context, ensuring better cohesion and maintainability. The current class lacks the context and data structure necessary for this method to operate effectively, making it a candidate for relocation to PcmlDocument where it can leverage the existing data management capabilities.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 723,
                        "lineEnd": 741,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getStringValue to class PcmlDocument",
                        "description": "Move method getStringValue to com.ibm.as400.data.PcmlDocument\nRationale: The method getStringValue(String name, int[] indices) is responsible for retrieving a string value from a data element in a PCML document, which directly relates to the functionality of the PcmlDocument class. This class already contains methods for accessing and manipulating data nodes, making it the most appropriate location for this method. Moving it to PcmlDocument will enhance cohesion by ensuring that all data retrieval methods are encapsulated within the same class, thereby improving maintainability and readability of the code.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 633,
                        "lineEnd": 649,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getIntValue to class PcmlDocument",
                        "description": "Move method getIntValue to com.ibm.as400.data.PcmlDocument\nRationale: The method getIntValue(String name) is responsible for retrieving an integer value associated with a named element in the PCML document. This functionality is inherently tied to the structure and data management of the PCML document itself, which is encapsulated within the PcmlDocument class. Moving this method to PcmlDocument aligns it with other data retrieval methods that operate on the document's elements, ensuring better cohesion and maintainability. The current class, which is not provided, likely does not have the context or data structure necessary to effectively manage or retrieve integer values from the PCML document, making it an inappropriate location for this method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 785,
                        "lineEnd": 797,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getOutputsize to class PcmlDocument",
                        "description": "Move method getOutputsize to com.ibm.as400.data.PcmlDocument\nRationale: The method getOutputsize(String name) is responsible for retrieving the number of bytes reserved for output for a specific element in the PCML document. This functionality is inherently tied to the structure and data management of the PCML document itself, making it a natural fit for the PcmlDocument class. Moving this method to PcmlDocument will enhance the cohesion of the class, as it will centralize all output size-related functionalities within the document context. The current class where the method resides does not seem to encapsulate the responsibilities related to output size management, which can lead to confusion and a violation of the Single Responsibility Principle.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "endInternal2",
                            "method_signature": "public void endInternal2(RJob rJob, int delayTime) throws ResourceException",
                            "target_class": "JobManager",
                            "rationale": "The method endInternal2 is responsible for managing job termination, which is more aligned with job management functionality rather than the responsibilities of ProgramCallDocument."
                        },
                        {
                            "method_name": "transformPCMLToXPCML",
                            "method_signature": "public static void transformPCMLToXPCML(InputStream pcmlStream, OutputStream xpcmlStream) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLTransformer",
                            "rationale": "The method transformPCMLToXPCML is focused on transforming PCML to XPCML, which is a transformation concern and should be handled by a dedicated transformer class."
                        },
                        {
                            "method_name": "condenseXPCML",
                            "method_signature": "public static void condenseXPCML(InputStream fullStream, OutputStream xsdStream, OutputStream condensedStream, String xsdStreamName) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLCondensor",
                            "rationale": "The method condenseXPCML is responsible for condensing XPCML streams, which is a specific transformation task that should be encapsulated in a dedicated class."
                        }
                    ],
                    "llm_response_time": 9129
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "endInternal2",
                            "method_signature": "public void endInternal2(RJob rJob, int delayTime) throws ResourceException",
                            "target_class": "JobManager",
                            "rationale": "The method endInternal2 is responsible for managing job termination, which is more aligned with job management functionality rather than the responsibilities of the ProgramCallDocument class."
                        },
                        {
                            "method_name": "transformPCMLToXPCML",
                            "method_signature": "public static void transformPCMLToXPCML(InputStream pcmlStream, OutputStream xpcmlStream) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLTransformer",
                            "rationale": "The method transformPCMLToXPCML is focused on transforming PCML to XPCML, which is a transformation concern and should be handled by a dedicated transformer class."
                        },
                        {
                            "method_name": "condenseXPCML",
                            "method_signature": "public static void condenseXPCML(InputStream fullStream, OutputStream xsdStream, OutputStream condensedStream, String xsdStreamName) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLCondensor",
                            "rationale": "The method condenseXPCML is responsible for condensing XPCML streams, which is a specific transformation task that should be encapsulated in a dedicated class."
                        }
                    ],
                    "llm_response_time": 6845
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "endInternal2",
                            "method_signature": "public void endInternal2(RJob rJob, int delayTime) throws ResourceException",
                            "target_class": "JobManager",
                            "rationale": "The method endInternal2 is responsible for managing job termination, which is more aligned with job management responsibilities than with the ProgramCallDocument class."
                        },
                        {
                            "method_name": "transformPCMLToXPCML",
                            "method_signature": "public static void transformPCMLToXPCML(InputStream pcmlStream, OutputStream xpcmlStream) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLTransformer",
                            "rationale": "The method transformPCMLToXPCML is focused on transforming PCML to XPCML, which is a transformation concern and should be handled by a dedicated transformer class."
                        },
                        {
                            "method_name": "condenseXPCML",
                            "method_signature": "public static void condenseXPCML(InputStream fullStream, OutputStream xsdStream, OutputStream condensedStream, String xsdStreamName) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLCondensor",
                            "rationale": "The method condenseXPCML is responsible for condensing XPCML streams, which is a specific transformation task that should be encapsulated in a dedicated class."
                        }
                    ],
                    "llm_response_time": 7950
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "clone",
                            "method_signature": "public clone()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "writeObject",
                            "method_signature": "private writeObject(ObjectOutputStream out)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "main",
                            "method_signature": "public static main(String[] args)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "callProgram",
                            "method_signature": "public callProgram(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getErrno",
                            "method_signature": "public getErrno(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getIntReturnValue",
                            "method_signature": "public getIntReturnValue(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getIntValue",
                            "method_signature": "public getIntValue(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getIntValue",
                            "method_signature": "public getIntValue(String name, int[] indices)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getStringValue",
                            "method_signature": "public getStringValue(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getStringValue",
                            "method_signature": "public getStringValue(String name, int type)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getStringValue",
                            "method_signature": "public getStringValue(String name, int[] indices)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getStringValue",
                            "method_signature": "public getStringValue(String name, int[] indices, int type)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getMessageList",
                            "method_signature": "public getMessageList(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getOutputsize",
                            "method_signature": "public getOutputsize(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getOutputsize",
                            "method_signature": "public getOutputsize(String name, int[] indices)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getValue",
                            "method_signature": "public getValue(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getValue",
                            "method_signature": "public getValue(String name, int[] indices)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setStringValue",
                            "method_signature": "public setStringValue(String name, String value, int type)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setStringValue",
                            "method_signature": "public setStringValue(String name, int[] indices, String value, int type)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setDocument",
                            "method_signature": "public setDocument(String docName, InputStream xsdStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setDocument",
                            "method_signature": "public setDocument(String docName, ClassLoader loader)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setDocument",
                            "method_signature": "public setDocument(String docName, ClassLoader loader,InputStream xsdStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setValue",
                            "method_signature": "public setValue(String name, Object value)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setValue",
                            "method_signature": "public setValue(String name, int[] indices, Object value)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setPath",
                            "method_signature": "public setPath(String program, String path)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setThreadsafeOverride",
                            "method_signature": "public setThreadsafeOverride(String program, boolean threadsafe)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getThreadsafeOverride",
                            "method_signature": "public getThreadsafeOverride(String program)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "savePcmlDocument",
                            "method_signature": "private static savePcmlDocument(PcmlDocument pd)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "savePcmlDocument",
                            "method_signature": "private static savePcmlDocument(PcmlDocument pd, OutputStream outStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "loadSourcePcmlDocumentFromStream",
                            "method_signature": "private static loadSourcePcmlDocumentFromStream(String docName, InputStream docStream, ClassLoader loader, InputStream xsdStream, boolean isXPCML)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "loadSourcePcmlDocument",
                            "method_signature": "private static loadSourcePcmlDocument(String docName, ClassLoader loader, InputStream xsdStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "generateXPCML",
                            "method_signature": "public generateXPCML(String pgmName, OutputStream outputStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "generateXPCML",
                            "method_signature": "public generateXPCML(OutputStream outputStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "endInternal2",
                            "method_signature": "public endInternal2(RJob rJob, int delayTime)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "writeObject",
                            "method_signature": "private writeObject(ObjectOutputStream out)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "savePcmlDocument",
                            "method_signature": "private static savePcmlDocument(PcmlDocument pd)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "savePcmlDocument",
                            "method_signature": "private static savePcmlDocument(PcmlDocument pd, OutputStream outStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "clone",
                            "method_signature": "public clone()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "loadSourcePcmlDocumentFromStream",
                            "method_signature": "private static loadSourcePcmlDocumentFromStream(String docName, InputStream docStream, ClassLoader loader, InputStream xsdStream, boolean isXPCML)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "loadSourcePcmlDocument",
                            "method_signature": "private static loadSourcePcmlDocument(String docName, ClassLoader loader, InputStream xsdStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "main",
                            "method_signature": "public static main(String[] args)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "callProgram",
                            "method_signature": "public callProgram(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getValue",
                            "method_signature": "public getValue(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "endInternal2",
                            "method_signature": "public endInternal2(RJob rJob, int delayTime)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getValue",
                            "method_signature": "public getValue(String name, int[] indices)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "generateXPCML",
                            "method_signature": "public generateXPCML(OutputStream outputStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getOutputsize",
                            "method_signature": "public getOutputsize(String name, int[] indices)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setDocument",
                            "method_signature": "public setDocument(String docName, InputStream xsdStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setDocument",
                            "method_signature": "public setDocument(String docName, ClassLoader loader,InputStream xsdStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getIntValue",
                            "method_signature": "public getIntValue(String name, int[] indices)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getStringValue",
                            "method_signature": "public getStringValue(String name, int[] indices, int type)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getStringValue",
                            "method_signature": "public getStringValue(String name, int[] indices)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getIntValue",
                            "method_signature": "public getIntValue(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getOutputsize",
                            "method_signature": "public getOutputsize(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getStringValue",
                            "method_signature": "public getStringValue(String name, int type)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setStringValue",
                            "method_signature": "public setStringValue(String name, int[] indices, String value, int type)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getIntReturnValue",
                            "method_signature": "public getIntReturnValue(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getErrno",
                            "method_signature": "public getErrno(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setValue",
                            "method_signature": "public setValue(String name, int[] indices, Object value)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setStringValue",
                            "method_signature": "public setStringValue(String name, String value, int type)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "private writeObject(ObjectOutputStream out)": {
                        "first": {
                            "method_name": "writeObject",
                            "method_signature": "private writeObject(ObjectOutputStream out)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.26672869074349326
                    },
                    "private static savePcmlDocument(PcmlDocument pd)": {
                        "first": {
                            "method_name": "savePcmlDocument",
                            "method_signature": "private static savePcmlDocument(PcmlDocument pd)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3388878059095168
                    },
                    "private static savePcmlDocument(PcmlDocument pd, OutputStream outStream)": {
                        "first": {
                            "method_name": "savePcmlDocument",
                            "method_signature": "private static savePcmlDocument(PcmlDocument pd, OutputStream outStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.35015202100751447
                    },
                    "public clone()": {
                        "first": {
                            "method_name": "clone",
                            "method_signature": "public clone()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.36746984507776354
                    },
                    "private static loadSourcePcmlDocumentFromStream(String docName, InputStream docStream, ClassLoader loader, InputStream xsdStream, boolean isXPCML)": {
                        "first": {
                            "method_name": "loadSourcePcmlDocumentFromStream",
                            "method_signature": "private static loadSourcePcmlDocumentFromStream(String docName, InputStream docStream, ClassLoader loader, InputStream xsdStream, boolean isXPCML)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.42042125471612674
                    },
                    "private static loadSourcePcmlDocument(String docName, ClassLoader loader, InputStream xsdStream)": {
                        "first": {
                            "method_name": "loadSourcePcmlDocument",
                            "method_signature": "private static loadSourcePcmlDocument(String docName, ClassLoader loader, InputStream xsdStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4452207221454168
                    },
                    "public static main(String[] args)": {
                        "first": {
                            "method_name": "main",
                            "method_signature": "public static main(String[] args)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5232654230261847
                    },
                    "public callProgram(String name)": {
                        "first": {
                            "method_name": "callProgram",
                            "method_signature": "public callProgram(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5271040077863799
                    },
                    "public getValue(String name)": {
                        "first": {
                            "method_name": "getValue",
                            "method_signature": "public getValue(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.551160960143131
                    },
                    "public endInternal2(RJob rJob, int delayTime)": {
                        "first": {
                            "method_name": "endInternal2",
                            "method_signature": "public endInternal2(RJob rJob, int delayTime)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5671784357774867
                    },
                    "public getValue(String name, int[] indices)": {
                        "first": {
                            "method_name": "getValue",
                            "method_signature": "public getValue(String name, int[] indices)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6335927640074325
                    },
                    "public generateXPCML(OutputStream outputStream)": {
                        "first": {
                            "method_name": "generateXPCML",
                            "method_signature": "public generateXPCML(OutputStream outputStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6689321743725705
                    },
                    "public getOutputsize(String name, int[] indices)": {
                        "first": {
                            "method_name": "getOutputsize",
                            "method_signature": "public getOutputsize(String name, int[] indices)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6694563852002595
                    },
                    "public setDocument(String docName, InputStream xsdStream)": {
                        "first": {
                            "method_name": "setDocument",
                            "method_signature": "public setDocument(String docName, InputStream xsdStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6776284744108155
                    },
                    "public setDocument(String docName, ClassLoader loader,InputStream xsdStream)": {
                        "first": {
                            "method_name": "setDocument",
                            "method_signature": "public setDocument(String docName, ClassLoader loader,InputStream xsdStream)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6812148049821976
                    }
                },
                "voyage": {
                    "public endInternal2(RJob rJob, int delayTime)": {
                        "first": {
                            "method_name": "endInternal2",
                            "method_signature": "public endInternal2(RJob rJob, int delayTime)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.29393967305119484
                    },
                    "public getIntValue(String name, int[] indices)": {
                        "first": {
                            "method_name": "getIntValue",
                            "method_signature": "public getIntValue(String name, int[] indices)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4102700677820497
                    },
                    "public getOutputsize(String name, int[] indices)": {
                        "first": {
                            "method_name": "getOutputsize",
                            "method_signature": "public getOutputsize(String name, int[] indices)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4320861888152503
                    },
                    "public getStringValue(String name, int[] indices, int type)": {
                        "first": {
                            "method_name": "getStringValue",
                            "method_signature": "public getStringValue(String name, int[] indices, int type)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.45368031759568755
                    },
                    "public getStringValue(String name, int[] indices)": {
                        "first": {
                            "method_name": "getStringValue",
                            "method_signature": "public getStringValue(String name, int[] indices)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4714270464657606
                    },
                    "private writeObject(ObjectOutputStream out)": {
                        "first": {
                            "method_name": "writeObject",
                            "method_signature": "private writeObject(ObjectOutputStream out)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.47149579379638784
                    },
                    "public getIntValue(String name)": {
                        "first": {
                            "method_name": "getIntValue",
                            "method_signature": "public getIntValue(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.47337908795311595
                    },
                    "public getOutputsize(String name)": {
                        "first": {
                            "method_name": "getOutputsize",
                            "method_signature": "public getOutputsize(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4774714093490822
                    },
                    "public getStringValue(String name, int type)": {
                        "first": {
                            "method_name": "getStringValue",
                            "method_signature": "public getStringValue(String name, int type)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4816140856706391
                    },
                    "public setStringValue(String name, int[] indices, String value, int type)": {
                        "first": {
                            "method_name": "setStringValue",
                            "method_signature": "public setStringValue(String name, int[] indices, String value, int type)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4835754058027899
                    },
                    "public getIntReturnValue(String name)": {
                        "first": {
                            "method_name": "getIntReturnValue",
                            "method_signature": "public getIntReturnValue(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.49415203788106055
                    },
                    "public getErrno(String name)": {
                        "first": {
                            "method_name": "getErrno",
                            "method_signature": "public getErrno(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4962245889030547
                    },
                    "public setValue(String name, int[] indices, Object value)": {
                        "first": {
                            "method_name": "setValue",
                            "method_signature": "public setValue(String name, int[] indices, Object value)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5057586690263505
                    },
                    "public getValue(String name, int[] indices)": {
                        "first": {
                            "method_name": "getValue",
                            "method_signature": "public getValue(String name, int[] indices)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5101435918314617
                    },
                    "public setStringValue(String name, String value, int type)": {
                        "first": {
                            "method_name": "setStringValue",
                            "method_signature": "public setStringValue(String name, String value, int type)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5140036326763455
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private static savePcmlDocument(PcmlDocument pd)",
                        "private static savePcmlDocument(PcmlDocument pd, OutputStream outStream)",
                        "private static loadSourcePcmlDocument(String docName, ClassLoader loader, InputStream xsdStream)",
                        "private static loadSourcePcmlDocumentFromStream(String docName, InputStream docStream, ClassLoader loader, InputStream xsdStream, boolean isXPCML)",
                        "public getValue(String name)",
                        "public getValue(String name, int[] indices)",
                        "public callProgram(String name)",
                        "public generateXPCML(OutputStream outputStream)",
                        "public getOutputsize(String name, int[] indices)",
                        "public setDocument(String docName, InputStream xsdStream)",
                        "public clone()",
                        "public endInternal2(RJob rJob, int delayTime)",
                        "public static main(String[] args)",
                        "private writeObject(ObjectOutputStream out)"
                    ],
                    "llm_response_time": 3869
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "private static savePcmlDocument(PcmlDocument pd)",
                        "private static savePcmlDocument(PcmlDocument pd, OutputStream outStream)",
                        "private static loadSourcePcmlDocumentFromStream(String docName, InputStream docStream, ClassLoader loader, InputStream xsdStream, boolean isXPCML)",
                        "public clone()",
                        "private writeObject(ObjectOutputStream out)"
                    ],
                    "llm_response_time": 1815
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private static savePcmlDocument(PcmlDocument pd, OutputStream outStream)",
                        "private static savePcmlDocument(PcmlDocument pd)",
                        "private writeObject(ObjectOutputStream out)"
                    ],
                    "llm_response_time": 1346
                },
                "voyage": {
                    "priority_method_names": [
                        "public getValue(String name, int[] indices)",
                        "public getStringValue(String name, int[] indices)",
                        "public getIntValue(String name, int[] indices)",
                        "public getOutputsize(String name, int[] indices)",
                        "public setValue(String name, int[] indices, Object value)",
                        "public setStringValue(String name, int[] indices, String value, int type)",
                        "public getStringValue(String name, int type)",
                        "public getIntValue(String name)",
                        "public getOutputsize(String name)",
                        "public getStringValue(String name, int[] indices, int type)",
                        "public getIntReturnValue(String name)",
                        "public getErrno(String name)",
                        "private writeObject(ObjectOutputStream out)",
                        "public endInternal2(RJob rJob, int delayTime)",
                        "public setStringValue(String name, String value, int type)"
                    ],
                    "llm_response_time": 3119
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public getStringValue(String name, int[] indices, int type)",
                        "public getStringValue(String name, int[] indices)",
                        "public getIntValue(String name, int[] indices)",
                        "public getOutputsize(String name, int[] indices)",
                        "public endInternal2(RJob rJob, int delayTime)"
                    ],
                    "llm_response_time": 1744
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public getOutputsize(String name, int[] indices)",
                        "public getIntValue(String name, int[] indices)",
                        "public endInternal2(RJob rJob, int delayTime)"
                    ],
                    "llm_response_time": 1292
                }
            },
            "targetClassMap": {
                "writeObject": {
                    "target_classes": [
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.46183650186326597
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PcmlDocument"
                    ],
                    "llm_response_time": 4177,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "savePcmlDocument": {
                    "target_classes": [
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.41998138627901943
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.6210675006056233
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.40649954125224985
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.5146959928058552
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.5865222824913301
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.37753398759232126
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.5527211821692902
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.528789844073842
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.48240760589145876
                        },
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.34814045758523376
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.35326389278974557
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.35617215020701765
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.3309360342036676
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.3629107053591953
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.33541019662496846
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.2795084971874737
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.5110625914090948
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.3878358759406698
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.27467513278676786
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.4086740864412269
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.3098601120450079
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.5144332369564982
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.44410825578584195
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.5378092195856157
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.5118921586521444
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.24949878225395983
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.35256831018682244
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.4078236951430928
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.4329922473372164
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.275781717224974
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.48075182157599305
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.5431139108760348
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SystemResourceFinder",
                        "RfmlDocument",
                        "RfmlRecordFormat"
                    ],
                    "llm_response_time": 4880,
                    "similarity_computation_time": 16,
                    "similarity_metric": "cosine"
                },
                "clone": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2998,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "loadSourcePcmlDocumentFromStream": {
                    "target_classes": [
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.6742360323812896
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.3759048268424321
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.40439977786855474
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.6072074714385879
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.6006794212437272
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.44835657848795946
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.5925571182554434
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.5857590594802582
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.5018425446421034
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.35452585064196895
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.4024347493773701
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.5549513724733173
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.445650625885965
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.5606383084446477
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.4425864444449779
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.28731140505258984
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.5930972278230066
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.599908857418347
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.1994435293178931
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.3247306456908757
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.4138144884879379
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.5115287288196935
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.32533791454484434
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.27041073416714334
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.5687825002177442
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.3517613898753338
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.3946938150585416
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.3076579288744018
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.3098682255872808
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.4992144030357204
                        },
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.27027505339789076
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.4689262340857843
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PcmlSAXParser",
                        "SystemResourceFinder",
                        "RfmlRecordFormat"
                    ],
                    "llm_response_time": 7411,
                    "similarity_computation_time": 15,
                    "similarity_metric": "cosine"
                },
                "loadSourcePcmlDocument": {
                    "target_classes": [
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.6789142461246634
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.44330338069839653
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.418842616689509
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.6070904298356815
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.6560134594472129
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.4438645683065531
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.6002032549781967
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.6492924373415782
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.572279589704849
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.378884644699386
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.580289333143053
                        },
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.34750622771955214
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.41784244193060865
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.44989869124661075
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.5476523542558952
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.5272989066530851
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.29036035109749636
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.5917616883865006
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.5946724366314715
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.25625686590267904
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.4424052004879478
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.425863906202402
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.5800546518626606
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.37101600418013425
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.2782620031351007
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.6043665497701342
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.41084536142814826
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.3668603373427502
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.4478536971954898
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.34752867410357474
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.40108197564871406
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.33748428886831094
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SystemResourceFinder",
                        "PcmlDataValues",
                        "RfmlRecordFormat"
                    ],
                    "llm_response_time": 5146,
                    "similarity_computation_time": 14,
                    "similarity_metric": "cosine"
                },
                "main": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4995,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "callProgram": {
                    "target_classes": [
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.6001344571644553
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PcmlDocument"
                    ],
                    "llm_response_time": 4228,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "getValue": {
                    "target_classes": [
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.25677312443360634
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PcmlDocument"
                    ],
                    "llm_response_time": 3745,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "endInternal2": {
                    "target_classes": [
                        {
                            "class_name": "RJob",
                            "similarity_score": 0.3999268311197287
                        },
                        {
                            "class_name": "AS400",
                            "similarity_score": 0.7158544931636377
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.7026322118373899
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "AS400",
                        "RJob",
                        "PcmlDocument"
                    ],
                    "llm_response_time": 22052,
                    "similarity_computation_time": 38,
                    "similarity_metric": "cosine"
                },
                "generateXPCML": {
                    "target_classes": [
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.3684257660723983
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PcmlDocument"
                    ],
                    "llm_response_time": 4648,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                },
                "getOutputsize": {
                    "target_classes": [
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.2829088121071821
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PcmlDocument"
                    ],
                    "llm_response_time": 4395,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "setDocument": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4639,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "getIntValue": {
                    "target_classes": [
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.33035199252531827
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PcmlDocument"
                    ],
                    "llm_response_time": 5942,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "getStringValue": {
                    "target_classes": [
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.3107422576928768
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PcmlDocument"
                    ],
                    "llm_response_time": 3209,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.util.html.HTMLVector::readObject(java.io.ObjectInputStream):void need move com.ibm.as400.util.html.HTMLTree",
        "class_name": "com.ibm.as400.util.html.HTMLVector",
        "telemetry": {
            "id": "05f0c1b2-06ad-45ea-b32f-3b14d55c2ff1",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 57,
                "lineStart": 20,
                "lineEnd": 76,
                "bodyLineStart": 20,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/large/big/jtopen-7.8/src/com/ibm/as400/util/html/HTMLVector.java",
                "sourceCode": "/**\n * This Vector is used internally by the HTML classes for performance reasons.\n**/\npublic class HTMLVector extends Vector\n{\n  /**\n   * This returns the superclass's element data array, which may be longer\n   * than the actual number of elements. Therefore, the objects at the end\n   * of the array could be null. Care should be taken to avoid these when\n   * looping, by using the elementCount returned by getCount().\n  **/\n  public Object[] getData()\n  {\n    return elementData;\n  }\n  \n  /**\n   * This returns the superclass's element count, which is the actual number\n   * of elements that are populated in the array returned by getData().\n   * Use this number for the maximum element count when looping through the\n   * element data, to avoid grabbing the null elements at the end of the\n   * element data array.\n  **/\n  public int getCount()\n  {\n    return elementCount;\n  }\n\n/**\n*  Deserializes and initializes transient data.\n * @param htmlTree TODO\n * @param in TODO\n**/\nvoid readObject(HTMLTree htmlTree, ObjectInputStream in)\nthrows java.io.IOException, ClassNotFoundException\n{\n    // @B2A\n    // If the locale is Korean, then this throws\n    // an ArrayIndexOutOfBoundsException.  This is\n    // a bug in the JDK.  The workarond in that case\n    // is just to use String.compareTo().\n    try                                                                            // @B2A\n    {\n        htmlTree.collator_ = Collator.getInstance ();                           // @B2A\n        htmlTree.collator_.setStrength (Collator.PRIMARY);                // @B2A\n    }\n    catch (Exception e)                                                    // @B2A\n    {\n        htmlTree.collator_ = null;                                                      // @B2A\n    }\n\n    in.defaultReadObject();\n\n    //@P2D changes_ = new PropertyChangeSupport(this);\n    //@P2D elementListeners = new Vector();\n}\n}",
                "methodCount": 3
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 47,
                        "lineEnd": 74,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method readObject to class HTMLTree",
                        "description": "Move method readObject to com.ibm.as400.util.html.HTMLTree\nRationale: The method readObject(HTMLTree htmlTree, ObjectInputStream in) is responsible for deserializing and initializing transient data related to the HTMLTree class. Since it directly manipulates the collator_ field of the HTMLTree instance and is concerned with the state of the HTMLTree during deserialization, it logically belongs within the HTMLTree class. Moving this method to HTMLTree will enhance encapsulation and maintainability, as it will keep all related functionality for managing the state of HTMLTree in one place.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject",
                            "method_signature": "void readObject(HTMLTree htmlTree, ObjectInputStream in) throws java.io.IOException, ClassNotFoundException",
                            "target_class": "HTMLTree",
                            "rationale": "The readObject method is closely tied to the HTMLTree class, as it manipulates its properties and requires an instance of HTMLTree. Moving it to HTMLTree would enhance cohesion and encapsulation."
                        }
                    ],
                    "llm_response_time": 2252
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject",
                            "method_signature": "void readObject(HTMLTree htmlTree, ObjectInputStream in) throws java.io.IOException, ClassNotFoundException",
                            "target_class": "HTMLTree",
                            "rationale": "The readObject method is closely related to the HTMLTree class as it manipulates its properties. Moving it to HTMLTree would enhance cohesion and maintainability."
                        }
                    ],
                    "llm_response_time": 1715
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject",
                            "method_signature": "void readObject(HTMLTree htmlTree, ObjectInputStream in) throws java.io.IOException, ClassNotFoundException",
                            "target_class": "HTMLTree",
                            "rationale": "The readObject method is closely related to the HTMLTree class as it manipulates its properties. Moving it to HTMLTree would enhance cohesion and encapsulation."
                        }
                    ],
                    "llm_response_time": 1681
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject",
                            "method_signature": " readObject(HTMLTree htmlTree, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject",
                            "method_signature": " readObject(HTMLTree htmlTree, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    " readObject(HTMLTree htmlTree, ObjectInputStream in)": {
                        "first": {
                            "method_name": "readObject",
                            "method_signature": " readObject(HTMLTree htmlTree, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2993421700446248
                    }
                },
                "voyage": {
                    " readObject(HTMLTree htmlTree, ObjectInputStream in)": {
                        "first": {
                            "method_name": "readObject",
                            "method_signature": " readObject(HTMLTree htmlTree, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.44985918228285365
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [],
                    "llm_response_time": 676
                },
                "tf-idf-5": {
                    "priority_method_names": [],
                    "llm_response_time": 1
                },
                "tf-df-3": {
                    "priority_method_names": [],
                    "llm_response_time": 0
                },
                "voyage": {
                    "priority_method_names": [],
                    "llm_response_time": 0
                },
                "voyage-5": {
                    "priority_method_names": [],
                    "llm_response_time": 0
                },
                "voyage-3": {
                    "priority_method_names": [],
                    "llm_response_time": 0
                }
            },
            "targetClassMap": {
                "readObject": {
                    "target_classes": [
                        {
                            "class_name": "HTMLTree",
                            "similarity_score": 0.5086590975474009
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HTMLTree"
                    ],
                    "llm_response_time": 4023,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.resource.IntegerValueMap::start():void need move com.ibm.as400.access.NetServer",
        "class_name": "com.ibm.as400.resource.IntegerValueMap",
        "telemetry": {
            "id": "f918562a-b5b5-4ded-ad20-bbb1ed3c3387",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 113,
                "lineStart": 27,
                "lineEnd": 139,
                "bodyLineStart": 27,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/large/big/jtopen-7.8/src/com/ibm/as400/resource/IntegerValueMap.java",
                "sourceCode": "/**\nThe IntegerValueMap class maps between a logical Integer value\nand a physical String value.\n@deprecated Use packages <tt>com.ibm.as400.access</tt> and <tt>com.ibm.as400.access.list</tt> instead. \n**/\npublic class IntegerValueMap\nimplements ValueMap, Serializable\n{\n  private static final String copyright = \"Copyright (C) 1997-2000 International Business Machines Corporation and others.\";\n\n\n\n\n    static final long serialVersionUID = 4L;\n\n\n\n/**\nMaps from a logical value to a physical value.\n\n@param logicalValue     The logical value.\n@param system           The system.\n@return                 The physical value.\n**/\n    public Object ltop(Object logicalValue, AS400 system)\n    {\n        if (logicalValue == null)\n            throw new NullPointerException(\"logicalValue\");\n        if (!(logicalValue instanceof Integer))\n            throw new ExtendedIllegalArgumentException(\"logicalValue\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n\n        return logicalValue.toString();\n    }\n\n\n\n/**\nMaps from a physical value to a logical value.\n\n@param physicalValue    The physical value.\n@param system           The system.\n@return                 The logical value.\n**/\n    public Object ptol(Object physicalValue, AS400 system)\n    {\n        if (physicalValue == null)\n            throw new NullPointerException(\"physicalValue\");\n        if (!(physicalValue instanceof String))\n            throw new ExtendedIllegalArgumentException(\"physicalValue\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n\n        String asString = (String)physicalValue;\n        if (asString.length() == 0)\n            return new Integer(0);\n        else\n            return new Integer(asString.trim());\n    }\n\n\n\n/**\n   Starts the NetServer job on the IBM i system, and (optionally) resets it.\n   If the NetServer is already started, this method does nothing.\n   This method requires *IOSYSCFG special authority on the system.\n   If the QSERVER subsystem is not running, this method will attempt to start it. \n   <p>Note: Reset is used when the NetServer fails to start normally on the system.  It is on the NetServer context menu so an administrator can use it.  The reset does some under-the-covers cleanup, and is used infrequently.  The times it would be used is if the system ended abnormally and there may be jobs or objects hanging around that need to be cleaned up before the system can start again.  The reset does that.\n\n   @param netServer TODO\n * @param reset  Whether or not the system is to be reset when started.\n * @exception ResourceException  If an error occurs.\n   **/\n  public void start2(NetServer netServer, boolean reset)\n    throws ResourceException\n  {\n    if (! netServer.isConnectionEstablished()) {\n      netServer.establishConnection();\n    }\n    if (netServer.isStarted()) return;\n\n    // @A3a\n    // See if the QSERVER subsystem is running.  If it's not running, start it.\n    if (!netServer.isQserverStarted()) {\n      // Attempt to start the QSERVER subsystem.\n      CommandCall cmd = new CommandCall(netServer.getSystem(), \"STRSBS SBSD(QSERVER)\");\n      boolean started = false;\n      try { started = cmd.run(); }\n      catch (Exception e) { throw new ResourceException(e); }\n      if (!started) {\n        Trace.log(Trace.ERROR, \"Error when starting QSERVER subsystem.\");\n        throw new ResourceException(cmd.getMessageList());\n      }\n    }\n\n\n    // Start the NetServer job (QZLSSERVER) on the IBM i system.\n    try {\n      ProgramCallDocument document = (ProgramCallDocument)NetServer.staticDocument_.clone();\n      document.setSystem(netServer.getSystem());\n      document.setValue(\"qzlsstrs.resetQualifier\", (reset ? \"1\" : \"0\"));\n\n      if (document.callProgram(\"qzlsstrs\") == false) {\n        throw new ResourceException(document.getMessageList(\"qzlsstrs\"));\n      }\n\n      // Note: Here is where we would do a fireServerStarted();\n    }\n    catch (PcmlException e) {\n      Trace.log(Trace.ERROR, \"PcmlException when starting the NetServer.\", e);\n      throw new ResourceException(e);\n    }\n  }\n\n\n}",
                "methodCount": 3
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 85,
                        "lineEnd": 135,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method start2 to class NetServer",
                        "description": "Move method start2 to com.ibm.as400.access.NetServer\nRationale: The method 'start2' is responsible for starting the NetServer job on the IBM i system and managing its state, which directly relates to the functionality of the NetServer class. The method checks if the NetServer is already started, establishes a connection if necessary, and attempts to start the QSERVER subsystem if it is not running. This aligns with the responsibilities of the NetServer class, which is designed to represent and manage the state and configuration of the NetServer service. Moving this method to the NetServer class enhances cohesion by keeping all related operations that affect the NetServer's lifecycle within the same class, thereby improving maintainability and clarity of the code.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "start2",
                            "method_signature": "public void start2(NetServer netServer, boolean reset) throws ResourceException",
                            "target_class": "NetServerManager",
                            "rationale": "The start2() method is responsible for starting the NetServer job and managing its state, which is more aligned with a dedicated manager class for NetServer operations rather than the IntegerValueMap class."
                        }
                    ],
                    "llm_response_time": 3459
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "start2",
                            "method_signature": "public void start2(NetServer netServer, boolean reset) throws ResourceException",
                            "target_class": "NetServerManager",
                            "rationale": "The start2() method is responsible for starting the NetServer job and managing its state, which is more aligned with the responsibilities of a NetServerManager class rather than the IntegerValueMap class."
                        }
                    ],
                    "llm_response_time": 4290
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "start2",
                            "method_signature": "public void start2(NetServer netServer, boolean reset) throws ResourceException",
                            "target_class": "NetServerManager",
                            "rationale": "The start2() method is responsible for starting the NetServer job and managing its state, which is more aligned with the responsibilities of a NetServerManager class rather than the IntegerValueMap class."
                        }
                    ],
                    "llm_response_time": 2706
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "start2",
                            "method_signature": "public start2(NetServer netServer, boolean reset)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "start2",
                            "method_signature": "public start2(NetServer netServer, boolean reset)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public start2(NetServer netServer, boolean reset)": {
                        "first": {
                            "method_name": "start2",
                            "method_signature": "public start2(NetServer netServer, boolean reset)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.45048984150384763
                    }
                },
                "voyage": {
                    "public start2(NetServer netServer, boolean reset)": {
                        "first": {
                            "method_name": "start2",
                            "method_signature": "public start2(NetServer netServer, boolean reset)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.23828986781236075
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public start2(NetServer netServer, boolean reset)"
                    ],
                    "llm_response_time": 714
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public start2(NetServer netServer, boolean reset)"
                    ],
                    "llm_response_time": 0
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public start2(NetServer netServer, boolean reset)"
                    ],
                    "llm_response_time": 0
                },
                "voyage": {
                    "priority_method_names": [
                        "public start2(NetServer netServer, boolean reset)"
                    ],
                    "llm_response_time": 0
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public start2(NetServer netServer, boolean reset)"
                    ],
                    "llm_response_time": 0
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public start2(NetServer netServer, boolean reset)"
                    ],
                    "llm_response_time": 0
                }
            },
            "targetClassMap": {
                "start2": {
                    "target_classes": [
                        {
                            "class_name": "NetServer",
                            "similarity_score": 0.7241166673457953
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "NetServer"
                    ],
                    "llm_response_time": 3633,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.vaccess.SQLResultSetTableModel::readObject(java.io.ObjectInputStream):void need move com.ibm.as400.vaccess.SQLResultSetTablePane",
        "class_name": "com.ibm.as400.vaccess.SQLResultSetTableModel",
        "telemetry": {
            "id": "108c2ffc-f777-4749-9728-06fb924d4e80",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1299,
                "lineStart": 38,
                "lineEnd": 1336,
                "bodyLineStart": 38,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/large/big/jtopen-7.8/src/com/ibm/as400/vaccess/SQLResultSetTableModel.java",
                "sourceCode": "/**\nThe SQLResultSetTableModel class represents the data in a JDBC\nresult set generated by an SQL query.  This class implements the\nunderlying model for a table in a graphical user interface.\nUse this class if you want to customize the graphical user interface\nthat presents a table.  If you do not need to customize the graphical user\ninterface, then use <a href=\"SQLResultSetTablePane.html\">\nSQLResultSetTablePane</a> instead.\n\n<p>You must specify an <a href=\"SQLConnection.html\">\nSQLConnection</a> object and SQL query string to use for generating\nthe data.  Alternately, you can specify a ResultSet object directly.\nIf you specify a ResultSet object, it will override any SQLConnection\nor SQL query previously set.  In addition, if you specify a ResultSet,\nthis class will use memory more efficiently if you create the ResultSet as scrollable.\n\n<p>You must explicitly call <a href=\"#load()\">load()</a> to load the information\nfrom the result set.  The model will be empty until load() is called.\nIf the query or result set includes updatable columns, then the respective\ncolumns will be editable.\n\n<p>This class assumes that the necessary JDBC driver(s) are already registered.\n\n<p>Call <a href=\"#close()\">close()</a> to ensure that the result set\nis closed when this table is no longer needed.\n\n<p>Most errors are reported as <a href=\"ErrorEvent.html\">ErrorEvent</a>s\nrather than throwing exceptions.  Listen for ErrorEvents in order to diagnose and recover\nfrom error conditions.\n\n<p>SQLResultSetTableModel objects generate the following events:\n<ul>\n  <li>ErrorEvent\n  <li>PropertyChangeEvent\n  <li>TableModelEvent\n  <li>WorkingEvent\n</ul>\n\n<p>This example creates an SQLResultSetTableModel using an SQLConnection\nand query and displays it using a JTable:\n\n<pre>\n// Register the IBM Toolbox for Java JDBC driver.\nDriverManager.registerDriver(new com.ibm.as400.access.AS400JDBCDriver());\n<br>\n// Create the SQLResultSetTableModel object.\nSQLConnection connection = new SQLConnection(\"jdbc:as400://MySystem\", \"Userid\", \"Password\");\nString query = \"SELECT * FROM MYLIB.MYTABLE\";\nSQLResultSetTableModel model = new SQLResultSetTableModel(connection, query);\n<br>\n// Create the enclosing JTable and put it in a JFrame.\nJTable table = new JTable(model);\nJFrame frame = new JFrame(\"My Window\");\nframe.getContentPane().add(new JScrollPane(table));\n<br>\n// Set up the error dialog adapter.\nmodel.addErrorListener(new ErrorDialogAdapter(frame));\n<br>\n// Display the JFrame.\nframe.pack();\nframe.show();\n<br>\n// Load the contents of the model.\nmodel.load();\n</pre>\n\n<p>This example creates an SQLResultSetTableModel using a ResultSet\nand displays it using a JTable:\n\n<pre>\n// Register the IBM Toolbox for Java JDBC driver.\nDriverManager.registerDriver(new com.ibm.as400.access.AS400JDBCDriver());\n<br>\n// Use JDBC to execute the SQL query directly.\nConnection connection = DriverManager.getConnection(\"MySystem\", \"Userid\", \"Password\");\nStatement statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\nResultSet rs = statement.executeQuery(\"SELECT * FROM MYLIB.MYTABLE\");\n<br>\n// Create the SQLResultSetTableModel object.\nSQLResultSetTableModel model = new SQLResultSetTableModel(rs);\n<br>\n// Create the enclosing JTable and put it in a JFrame.\nJTable table = new JTable(model);\nJFrame frame = new JFrame(\"My Window\");\nframe.getContentPane().add(new JScrollPane(table));\n<br>\n// Set up the error dialog adapter.\nmodel.addErrorListener(new ErrorDialogAdapter(frame));\n<br>\n// Display the JFrame.\nframe.pack();\nframe.show();\n<br>\n// Load the contents of the model.\nmodel.load();\n</pre>\n@deprecated Use Java Swing instead, along with the classes in package <tt>com.ibm.as400.access</tt>\n**/\n//\n// Implementation notes:\n//\n// *  Note that this class throws error and working events from within\n//    synchronized blocks, which could cause hangs if the listeners for\n//    these events do operations from a different thread an attempt to\n//    access another synchronized piece of code.\n//\n//    At this time this seems to be an acceptable risk, since the\n//    events thrown are not likely to need enough processing to\n//    require another thread, and getting having the events thrown\n//    from outside a sychronized block would be nearly impossible.\n//    The other option is to have the firing of the events be done\n//    from another thread, but the overhead of creating another thread\n//    not only takes resources, but also delays the delivery of the event.\n//\n// *  We do two sets of synchronization.  The internalMonitor_\n//    synchronization prevents data corrruption when multiple threads\n//    are accessing the same SQLResultSetTableModel object.\n//    The resultSet_ synchronization prevents data corruption when\n//    multiple SQLResultSetTableModels are accessing the same\n//    ResultSet object.\n//\n// *  The variables which have private commented out had to made\n//    package scope since currently Internet Explorer does not\n//    allow inner class to access private variables in their\n//    containing class.\n//\npublic class SQLResultSetTableModel\n    extends AbstractTableModel\n    implements Serializable\n{\n  private static final String copyright = \"Copyright (C) 1997-2001 International Business Machines Corporation and others.\";\n\n\n\n  // Private data.\n  private boolean                         cacheAll_               = false;\n  private SQLConnection                   sqlConnection_          = null;\n  private String                          query_                  = null;\n  private ResultSet                       explicitResultSet_      = null;\n\n  private transient Vector                cachedRows_;\n  private transient int                   cachedRowCount_;\n  private transient int                   columnCount_;\n  private transient boolean               error_;\n  private transient int                   firstCachedRow_;\n  private transient Object                internalMonitor_;\n  private transient int                   lastCachedRow_;\n  private transient ResultSet             resultSet_;\n  private transient ResultSetMetaData     resultSetMetaData_;\n  private transient int                   rowCount_;\n  private transient boolean               rowCountComplete_;\n  private transient boolean               scrollable_;\n  private transient Statement             statement_;\n  private transient boolean               updatable_;\n\n  private transient JTable                table_;    /* Keep a reference to the table so we can maintain selection information @B6A*/ \n  private static final int                CACHE_SIZE_             = 500;  // In rows.\n  private static final int                READ_INCREMENT_         = 50;   // In rows.\n\n\n\n  // Event support.\n  private transient PropertyChangeSupport     propertyChangeSupport_;\n  private transient VetoableChangeSupport     vetoableChangeSupport_;\n  private transient ErrorEventSupport         errorEventSupport_;\n  private transient WorkingEventSupport       workingEventSupport_;\n\n\n\n  /**\n  Constructs a SQLResultSetTableModel object.\n  **/\n  public SQLResultSetTableModel()\n  {\n    super();\n    initializeTransient();\n  }\n\n\n\n  /**\n  Constructs a SQLResultSetTableModel object.\n  \n  @param connection     The SQL connection.\n  @param query          The SQL query.\n  **/\n  public SQLResultSetTableModel(SQLConnection connection, String query)\n  {\n    super();\n    if(connection == null)\n      throw new NullPointerException(\"connection\");\n    if(query == null)\n      throw new NullPointerException(\"query\");\n\n    sqlConnection_ = connection;\n    query_ = query;\n\n    initializeTransient();\n  }\n\n\n\n  // @D0A\n  /**\n  Constructs a SQLResultSetTableModel object.\n  \n  @param resultSet  The SQL result set.\n  @param cacheAll   true to cache the entire result set when <a href=\"#load()\">load()</a>\n                    is called, false to cache parts of the result set as they are\n                    needed.  Passing true may result in slow initial presentation of\n                    the data.  However, it may be necessary to pass true if the result\n                    set is expected to close when the model is still needed.\n  **/\n  public SQLResultSetTableModel(ResultSet resultSet, boolean cacheAll)\n  {\n    super();\n    if(resultSet == null)\n      throw new NullPointerException(\"resultSet\");\n\n    explicitResultSet_ = resultSet;\n    cacheAll_ = cacheAll;\n\n    initializeTransient();\n  }\n\n\n\n  /**\n  Adds a listener to be notified when an error occurs.\n  \n  @param  listener    The listener.\n  **/\n  public void addErrorListener(ErrorListener listener)\n  {\n    errorEventSupport_.addErrorListener(listener);\n  }\n\n\n\n  /**\n  Adds a listener to be notified when the value of any\n  bound property changes.\n  \n  @param  listener  The listener.\n  **/\n  public void addPropertyChangeListener(PropertyChangeListener listener)\n  {\n    propertyChangeSupport_.addPropertyChangeListener(listener);\n  }\n\n\n\n  /**\n  Adds a listener to be notified when the value of any\n  constrained property changes.\n  \n  @param  listener  The listener.\n  **/\n  public void addVetoableChangeListener(VetoableChangeListener listener)\n  {\n    vetoableChangeSupport_.addVetoableChangeListener(listener);\n  }\n\n\n\n  /**\n  Adds a listener to be notified when work starts and stops\n  on potentially long-running operations.\n  \n  @param  listener  The listener.\n  **/\n  public void addWorkingListener(WorkingListener listener)\n  {\n    workingEventSupport_.addWorkingListener(listener);\n  }\n\n\n\n  /**\n  Clears all SQL warnings.\n  **/\n  public void clearWarnings()\n  {\n    try\n    {\n      if(resultSet_ != null)\n        resultSet_.clearWarnings();\n      if(statement_ != null)\n        statement_.clearWarnings();\n    }\n    catch(SQLException e)\n    {\n      markError(e);\n    }\n  }\n\n\n\n  /**\n  Closes the result set.\n  **/\n  public void close()\n  {\n    try\n    {\n      if(resultSet_ != null)\n      {\n        resultSet_.close();\n        resultSet_ = null;\n      }\n    }\n    catch(SQLException e)\n    {\n      markError(e);\n    }\n\n    try\n    {\n      if(statement_ != null)\n      {\n        statement_.close();\n        statement_ = null;\n      }\n    }\n    catch(SQLException e)\n    {\n      markError(e);\n    }\n  }\n\n\n\n  /**\n  Returns the class of the values in the column.\n  \n  @param columnIndex The column index (0-based).\n  @return            The class of the column values, or null\n                     if an error occurs.\n  **/\n  public Class getColumnClass(int columnIndex)\n  {\n    // Returning Object seems to be sufficient.\n    return Object.class;\n  }\n\n\n\n  /**\n  Returns the number of columns in the table.\n  \n  @return The number of columns in the table, or 0\n          if an error occurs.\n  **/\n  public int getColumnCount()\n  {\n    synchronized(internalMonitor_)\n    {\n      Trace.log(Trace.DIAGNOSTIC, \"SQLResultSetTableModel.getColumnCount() = \" + columnCount_);\n      return columnCount_;\n    }\n  }\n\n\n\n  /**\n  Returns the column identifier.  This corresponds to the\n  field name in the database.\n  \n  @param columnIndex  The column index (0-based).\n  @return             The column identifier, or null\n                      if an error occurs.\n  **/\n  public String getColumnID(int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return null;\n      if(resultSet_ == null)\n        return null;\n\n      try\n      {\n        return resultSetMetaData_.getColumnName(columnIndex+1);\n      }\n      catch(SQLException e)\n      {\n        markError(e);\n        return null;\n      }\n    }\n  }\n\n\n\n  /**\n  Returns the column name.  This corresponds to the column\n  label in the database.\n  \n  @param columnIndex  The column index (0-based).\n  @return             The column name, or null\n                      if an error occurs.\n  **/\n  public String getColumnName(int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return null;\n      if(resultSet_ == null)\n        return null;\n\n      try\n      {\n        String col = resultSetMetaData_.getColumnLabel(columnIndex+1);        //@pdc extended metadata\n        //columnLabel is a concatonation of up to three columns (each 20 length) with the 20 length padded with spaces\n        int colLength = col.length();          //@pda extended metadata\n        if( colLength > 20)                    //@pda  \n        {                                      //@pda  \n            \n            if( colLength > 40)                        //@pda  \n            {                                          //@pda  \n                //contains three column concats\n                String space1 = col.substring(19,20).equals(\" \") ? \" \" : \"\";  //column separator\n                String space2 = col.substring(39,40).equals(\" \") ? \" \" : \"\";  //column separator\n                col = col.substring(0, 20).trim() + space1 + col.substring(20, 40).trim() + space2 + col.substring(40).trim();    //@pda  \n            }                                          //@pda  \n            else                                       //@pda  \n            {                                          //@pda  \n                //contains two column concats\n                String space1 = col.substring(19,20).equals(\" \") ? \" \" : \"\";  //column separator\n                col = col.substring(0, 20).trim() + space1 + col.substring(20).trim();  //@pda  \n            }                                         //@pda  \n        }                                             //@pda  \n        return col;                                   //@pda  \n      }\n      catch(SQLException e)\n      {\n        markError(e);\n        return null;\n      }\n    }\n  }\n\n\n\n  /**\n  Returns the column type.\n  \n  @param columnIndex  The column index (0-based).\n  @return             The column type, or 0 if an error occurs.\n  **/\n  public int getColumnType(int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return 0;\n      if(resultSet_ == null)\n        return 0;\n\n      try\n      {\n        return resultSetMetaData_.getColumnType(columnIndex+1);\n      }\n      catch(SQLException e)\n      {\n        markError(e);\n        return 0;\n      }\n    }\n  }\n\n\n\n  /**\n  Returns the column width.\n  \n  @param columnIndex  The column index (0-based).\n  @return             The column width, in characters, or 0 if an error occurs.\n  **/\n  public int getColumnWidth(int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return 0;\n      if(resultSet_ == null)\n        return 0;\n\n      try\n      {\n        /* @D3D\n        // For most types, we just consult with JDBC.  However, for times, dates, and\n        // timestamps, JDBC reports the display size for the server format.  And these\n        // GUIs actually internationalize the Strings before displaying them.  So for\n        // these types, we need to compute our own display sizes.\n        switch(resultSetMetaData_.getColumnType(columnIndex+1)) {\n        case Types.TIME:\n            return DBDateCellRenderer.getDisplaySize(DBDateCellRenderer.FORMAT_TIME);\n        case Types.DATE:\n            return DBDateCellRenderer.getDisplaySize(DBDateCellRenderer.FORMAT_DATE);\n        case Types.TIMESTAMP:\n            return DBDateCellRenderer.getDisplaySize(DBDateCellRenderer.FORMAT_TIMESTAMP);\n        default:\n        */\n        return Math.min(resultSetMetaData_.getColumnDisplaySize(columnIndex+1), 50);\n        // @D3D }\n      }\n      catch(SQLException e)\n      {\n        markError(e);\n        return 0;\n      }\n    }\n  }\n\n\n\n  /**\n  Returns the SQL connection.\n  \n  @return The SQL connection.\n  **/\n  public SQLConnection getConnection()\n  {\n    return sqlConnection_;\n  }\n\n\n\n  /**\n  Returns the SQL query.\n  \n  @return The SQL query.\n  **/\n  public String getQuery()\n  {\n    return(query_ == null) ? \"\" : query_;\n  }\n\n\n\n  // @D0A\n  /**\n  Returns the SQL result set.\n  \n  @return The SQL result set.\n  **/\n  public ResultSet getResultSet()\n  {\n    return explicitResultSet_;\n  }\n\n\n\n  /**\n  Returns the number of rows in the table.\n  Because of incremental data retrieval, this value may\n  not be accurate.\n  \n  @return The number of rows in the table.\n  **/\n  public int getRowCount()\n  {\n    if(resultSet_ == null)\n      return 0;\n\n    // If we are not complete, report 2 more than actually here.\n    // This will trick JTable into continuing to ask for more.\n    int reportedRowCount = rowCount_;\n    if(!rowCountComplete_)\n      reportedRowCount += 2;\n\n    // This should not be in a synchronized block, otherwise\n    // a hang may occur.\n    Trace.log(Trace.DIAGNOSTIC, \"SQLResultSetTableModel.getRowCount() = \" + reportedRowCount + \"(actually \" + rowCount_ + \")\");\n    return reportedRowCount;\n  }\n\n\n\n  // @D4A\n  private Object getSingleValue(int columnIndex) throws SQLException\n  {\n    int type = resultSetMetaData_.getColumnType(columnIndex);\n    if(type == Types.BINARY\n       || type == Types.VARBINARY\n       || type == Types.LONGVARBINARY)\n    {\n      return resultSet_.getBytes(columnIndex);\n    }\n    else\n    {\n      // Use getString() so that dates and times get converted to strings\n      // by the JDBC driver so that their formats reflect the settings\n      // in the data source.\n      //@KKB return resultSet_.getString(columnIndex);\n      String s = resultSet_.getString(columnIndex);     //@KKB\n      if(checkDataMappingWarning(resultSet_, columnIndex))           //@KKB\n          s=\"++++++++++++++\";                           //@KKB\n      return s;                                         //@KKB\n    }\n  }\n\n\n\n  /**\n  Returns the value at the specifed row and column.\n  \n  @param rowIndex       The row index (0-based).\n  @param columnIndex    The column index (0-based).\n  \n  @return The value at the specified row and column.\n  **/\n  public Object getValueAt(int rowIndex, int columnIndex)\n  {\n    int oldRowCount;\n    int newRowCount;\n    Object[] row = null;\n\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return null;\n      if(rowIndex < 0)\n        return null;\n      if((rowCountComplete_) && (rowIndex >= rowCount_))\n        return null;\n      if(resultSet_ == null)\n        return null;\n\n      oldRowCount = rowCount_;\n\n      // Case 1: If this row is in the cache, just read it from there.\n      // If cacheAll_ is set, then this case should always occur.\n      if((rowIndex >= firstCachedRow_) && (rowIndex <= lastCachedRow_))\n      {\n        row = (Object[])cachedRows_.elementAt(rowIndex - firstCachedRow_);\n      }\n\n      // Case 2: If this row comes before whats in the cache, read the rows\n      // and move the cache window up in the result set.  This will only\n      // occur if the result set is scrollable - if it is not, then the\n      // cache always includes everything read so far.\n      else if((rowIndex < firstCachedRow_) && (error_ == false))\n      {\n        workingEventSupport_.fireStartWorking();\n        for(int i = firstCachedRow_ - 1; i >= rowIndex; --i)\n        {\n          try\n          {\n            row = new Object[columnCount_];\n            synchronized(resultSet_)\n            {\n\n              // If we are just reading the next row since the last\n              // time, it can be significantly faster to call next().\n              // This is especially true when using the Toolbox\n              // JDBC driver since it does record blocking only\n              // when using next().\n              //\n              // I tried keeping the last read row locally, but it\n              // messes things up when result sets are shared\n              // between multiple models.\n              //\n              if(i == resultSet_.getRow())\n                resultSet_.next();\n              else\n                resultSet_.absolute(i+1);\n\n              // Store the contents of the row.\n              for(int j = 0; j < columnCount_; ++j)\n                row[j] = getSingleValue(j+1); // @D4C\n            }\n            cachedRows_.insertElementAt(row, 0);\n            --firstCachedRow_;\n            if(++cachedRowCount_ > CACHE_SIZE_)\n            {\n              cachedRows_.removeElementAt(--cachedRowCount_);\n              --lastCachedRow_;\n            }\n          }\n          catch(SQLException e)\n          {\n            markError(e);\n          }\n        }\n        workingEventSupport_.fireStopWorking();\n      }\n\n      // Case 3: If this row comes after whats in the cache, read the rows\n      // and move the cache window down in the result set.  If we do not\n      // know the final row count, then jump a little bit ahead to discover\n      // this.\n      else if((rowIndex > lastCachedRow_) && (error_ == false))\n      {\n\n        // Determine how far to go.  If we are not complete yet, push it\n        // ahead to force the table to read even further.\n        int endPoint = rowIndex;\n        if(!rowCountComplete_)\n          endPoint = rowIndex + READ_INCREMENT_;\n\n        // Loop through the rows, quit if we get to the end.\n        workingEventSupport_.fireStartWorking();\n        boolean valid = true;\n        for(int i = lastCachedRow_ + 1; (i <= endPoint) && (valid); ++i)\n        {\n          try\n          {\n            synchronized(resultSet_)\n            {\n\n              // If we are just reading the next row since the last\n              // time, it can be significantly faster to call next().\n              // This is especially true when using the Toolbox\n              // JDBC driver since it does record blocking only\n              // when using next().   We also take this route if\n              // the result set is not scrollable.\n              if((i == resultSet_.getRow()) || (!scrollable_))\n                valid = resultSet_.next();\n              else\n                valid = resultSet_.absolute(i+1);\n\n              // If this is a valid row, then add it to the cache.\n              if(valid)\n              {\n                Object[] tempRow = new Object[columnCount_];\n                for(int j = 0; j < columnCount_; ++j)\n                  tempRow[j] = getSingleValue(j+1); // @D4C\n                if(i == rowIndex)\n                  row = tempRow;\n                cachedRows_.insertElementAt(tempRow, cachedRowCount_++);\n                ++lastCachedRow_;\n                if((scrollable_) && (cachedRowCount_ > CACHE_SIZE_))\n                {\n                  cachedRows_.removeElementAt(0);\n                  cachedRowCount_--;\n                  ++firstCachedRow_;\n                }\n\n                // If this is greater than our current count, add record it.\n                if((!rowCountComplete_) && (i >= rowCount_))\n                  rowCount_ = i;\n              }\n\n              // If this is not a valid row, then mark the row count as\n              // complete.\n              else if(!rowCountComplete_)\n              {\n                rowCountComplete_ = true;\n                rowCount_ = i;\n              }\n            }\n          }\n          catch(SQLException e)\n          {\n            markError(e);\n          }\n        }\n        workingEventSupport_.fireStopWorking();\n      }\n\n      // If the row count changed, record the change so we can fire the table\n      // model event (outside of the synchronized block).\n      newRowCount = rowCount_;\n    }\n\n    // If the row count changed, fire the table model event.  If we are\n    // not complete, then add 2 to keep the JTable asking for more.\n    if(oldRowCount != newRowCount)\n    {\n      // In JDK 1.5 and 1.6, there is a problem with the selection in the JTable being cleared. \n      // This causes problems if the user is using the page down key to scroll through the results.\n      //\n      // The call to fireTableRowsInserted may be the code that is clearing the selection.  \n      // For a similar problem see:  http://stackoverflow.com/questions/254212/preserve-jtable-selection-across-tablemodel-change\n      // I tried setting the first parameter to oldRowCount+1 to see if that fixes the problem.\t\n      // That did not fix the problem.  The row at the bottom retains it's highlight, but the next\n      // PageDown jumps to the top of the area. \n      // \n      // Instead we need to remember the selected rows and restore them after. \n      // For now, we'll only handle the simple case where a single cell is selected. \n      //\n      // We also only want to change the selection if the selected row has changed after  \n      // fireTableRowsInserted.  In the case where the use of the scroll bar causes new\n      // entries to be loaded, the selectedRow does not change, so we do not need to \n      // change the selection back to their original values. \n      //\n      // @B6A \n      \n      \n      int  selectedRow = -1; \n      if (table_ != null)   selectedRow = table_.getSelectedRow();\n      int selectedColumn = -1; \n      if (table_ != null)   selectedColumn = table_.getSelectedColumn(); \n      \n      fireTableRowsInserted(oldRowCount, getRowCount());\n      \n      \n      \n      // Restore the selected cell.  @B6A \n     int  afterSelectedRow = -1 ; \n     if (table_ != null)\tafterSelectedRow = table_.getSelectedRow();\n      if ((selectedRow >= 0 && selectedColumn >= 0 ) && \n    \t\t  ((afterSelectedRow != selectedRow) )) {\n      table_.changeSelection(selectedRow, selectedColumn, false /* toggle */ , false /* extend */); \n\t  \n      }\n    }\n\n    // Return the value.\n    if(row == null)\n      return null;\n    else\n      return row[columnIndex];\n  }\n\n\n\n  /**\n  Returns the SQL warnings.\n  \n  @return The SQL warnings.\n  **/\n  public SQLWarning getWarnings()\n  {\n    SQLWarning warnings = null;\n    try\n    {\n      if(resultSet_ != null)\n        warnings = resultSet_.getWarnings();\n      if(statement_ != null)\n      {\n        if(warnings == null)\n          warnings = statement_.getWarnings();\n        else\n          warnings.setNextWarning(statement_.getWarnings());\n      }\n    }\n    catch(SQLException e)\n    {\n      markError(e);\n    }\n    return warnings;\n  }\n\n\n\n  /**\n  Initializes the common data.\n  **/\n  private void initializeCommon()\n  {\n    synchronized(internalMonitor_)\n    {\n      cachedRows_             = new Vector(CACHE_SIZE_);\n      cachedRowCount_         = 0;\n      columnCount_            = 0;\n      error_                  = false;\n      firstCachedRow_         = 0;\n      lastCachedRow_          = -1;\n      rowCount_               = 0;\n      rowCountComplete_       = false;\n    }\n  }\n\n\n\n  /**\n  Initializes the transient data.\n  **/\n  private void initializeTransient()\n  {\n    internalMonitor_                = new Object();\n\n    initializeCommon();\n\n    // Event support.\n    propertyChangeSupport_          = new PropertyChangeSupport(this);\n    vetoableChangeSupport_          = new VetoableChangeSupport(this);\n    errorEventSupport_              = new ErrorEventSupport(this);\n    workingEventSupport_            = new WorkingEventSupport(this);\n  }\n\n\n  //@D6A\n  /**\n   * Used by SQLResultSetTablePane to determine whether or not the default\n   * cell editor should be replaced.\n  **/\n  boolean isUpdatable()\n  {\n    return updatable_;\n  }\n\n\n  // @D2A\n  /**\n  Indicates if the cell is editable.\n  \n  @param rowIndex         The row index (0-based).\n  @param columnIndex      The column index (0-based).\n  @return                 true if the cell is editable, false otherwise\n                          or if an error occurs.\n  **/\n  public boolean isCellEditable(int rowIndex, int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return false;\n      if(rowIndex < 0)\n        return false;\n      if((rowCountComplete_) && (rowIndex >= rowCount_))\n        return false;\n      if(resultSet_ == null)\n        return false;\n\n      //@D6D            try {\n      //@D6D                return (updatable_ && resultSetMetaData_.isWritable(columnIndex+1));\n      //@D6D            }\n      //@D6D            catch(SQLException e) {\n      //@D6D                markError(e);\n      //@D6D                return false;\n      //@D6D            }\n      return true; //@D6A\n    }\n  }\n\n\n\n  /**\n  Loads the data in the table.\n  **/\n  public void load()\n  {\n    Trace.log(Trace.DIAGNOSTIC, \"SQLResultSetTableModel.load()\");\n    workingEventSupport_.fireStartWorking();\n\n    // Make sure we have enough data to load.\n    if(explicitResultSet_ == null)\n    {\n      if(sqlConnection_ == null)\n        throw new IllegalStateException(\"connection\");\n      if(query_ == null)\n        throw new IllegalStateException(\"query\");\n    }\n\n    synchronized(internalMonitor_)\n    {\n\n      // Clear the old data.\n      initializeCommon();\n\n      // Load the new data.\n      try\n      {\n        if(explicitResultSet_ == null)\n        {\n          if(statement_ == null)\n          {\n            Connection connection = sqlConnection_.getConnection();\n            statement_ = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n          }\n\n          resultSet_ = statement_.executeQuery(query_);\n        }\n        else\n          resultSet_ = explicitResultSet_;\n\n        scrollable_ = (resultSet_.getType() != ResultSet.TYPE_FORWARD_ONLY);\n        updatable_ = (resultSet_.getConcurrency() == ResultSet.CONCUR_UPDATABLE);  // @D2A\n        resultSetMetaData_ = resultSet_.getMetaData();\n        columnCount_ = resultSetMetaData_.getColumnCount();\n\n        if(Trace.isTraceOn())\n        {\n          Trace.log(Trace.DIAGNOSTIC, \"SQLResultSetTableModel-scrollable? \" + scrollable_);\n          Trace.log(Trace.DIAGNOSTIC, \"SQLResultSetTableModel-updatable? \" + updatable_); // @D2A\n        }\n\n        //@KBD removed since a stored procedure may or may not return a scrollable cursor\n        // if the user specified ResultSet.TYPE_SCROLL_SENSITIVE or ResultSet.TYPE_SCROLL_INSENSITVE\n        //@KBD if(scrollable_)\n        //@KBD {\n        //@KBD     resultSet_.beforeFirst();\n        //@KBD }\n      }\n      catch(SQLException e)\n      {\n        markError(e);\n        rowCountComplete_ = true;\n      }\n\n      // If we are supposed to, then cache all.\n      if(cacheAll_)\n      {\n        try\n        {\n          while(resultSet_.next())\n          {\n            Object[] tempRow = new Object[columnCount_];\n            for(int j = 0; j < columnCount_; ++j)\n              tempRow[j] = getSingleValue(j+1); // @D4C\n            cachedRows_.addElement(tempRow);\n          }\n        }\n        catch(SQLException e)\n        {\n          markError(e);\n        }\n        lastCachedRow_ = cachedRows_.size();\n        rowCount_ = lastCachedRow_;\n        rowCountComplete_ = true;\n      }\n\n      // Otherwise, try to read 1 row.  This will handle the case where there are no rows.\n      else\n      {\n        getValueAt(0, 0);\n      }\n    }\n\n    // Tell the JTable that we've changed.\n    fireTableStructureChanged();\n\n    workingEventSupport_.fireStopWorking();\n  }\n\n\n\n  /**\n  Marks that an error has occurred.\n  **/\n  private void markError(Exception e)\n  {\n    if(Trace.isTraceOn())\n      Trace.log(Trace.ERROR, \"Error gathering SQLResultSetTableModel data\", e);\n\n    // Only fire if this is the first error.  That way, we don't\n    // barrage the poor user.\n    if(!error_)\n    {\n      error_ = true;\n      errorEventSupport_.fireError(e);\n    }\n  }\n\n\n\n  /**\n  Restores the state of the object from an input stream.\n  This is used when deserializing an object.\n  \n  @param in   The input stream.\n  **/\n  private void readObject(ObjectInputStream in)\n  throws IOException, ClassNotFoundException\n  {\n    in.defaultReadObject();\n    initializeTransient();\n  }\n\n\n\n  /**\n  Removes an error listener.\n  \n  @param  listener    The listener.\n  **/\n  public void removeErrorListener(ErrorListener listener)\n  {\n    errorEventSupport_.removeErrorListener(listener);\n  }\n\n\n\n  /**\n  Removes a property change listener.\n  \n  @param  listener  The listener.\n  **/\n  public void removePropertyChangeListener(PropertyChangeListener listener)\n  {\n    propertyChangeSupport_.removePropertyChangeListener(listener);\n  }\n\n\n\n  /**\n  Removes a vetoable change listener.\n  \n  @param  listener  The listener.\n  **/\n  public void removeVetoableChangeListener(VetoableChangeListener listener)\n  {\n    vetoableChangeSupport_.removeVetoableChangeListener(listener);\n  }                                                    \n\n\n\n  /**\n  Removes a working listener.\n  \n  @param  listener  The listener.\n  **/\n  public void removeWorkingListener(WorkingListener listener)\n  {\n    workingEventSupport_.removeWorkingListener(listener);\n  }\n\n\n\n  /**\n  Sets the SQL connection.\n  The data will not change until <a href=\"#load()\">load()</a> is called.\n  \n  @param       connection              The SQL connection.\n  \n  @exception  PropertyVetoException   If the change is vetoed.\n  **/\n  public void setConnection(SQLConnection connection)\n  throws PropertyVetoException\n  {\n    if(connection == null)\n      throw new NullPointerException(\"connection\");\n\n    SQLConnection oldValue = sqlConnection_;\n    vetoableChangeSupport_.fireVetoableChange(\"connection\", oldValue, connection);\n    sqlConnection_ = connection;\n    statement_ = null;\n    propertyChangeSupport_.firePropertyChange(\"connection\", oldValue, connection);\n  }\n\n\n\n  /**\n  Sets the SQL query.\n  The data will not change until <a href=\"#load()\">load()</a> is called.\n  \n  @param       query                   The SQL query.\n  \n  @exception  PropertyVetoException   If the change is vetoed.\n  **/\n  public void setQuery(String query)\n  throws PropertyVetoException\n  {\n    if(query == null)\n      throw new NullPointerException(\"query\");\n\n    String oldValue = query_;\n    vetoableChangeSupport_.fireVetoableChange(\"query\", oldValue, query);\n    query_ = query;\n    propertyChangeSupport_.firePropertyChange(\"query\", oldValue, query);\n  }\n\n\n\n  // @D0A\n  /**\n  Sets the SQL result set used to build the table.  If this is set,\n  it is used instead of the SQL connection and SQL query.\n  The data will not change until <a href=\"#load()\">load()</a> is called.\n  \n  @param resultSet        The SQL result set.\n  **/\n  public void setResultSet(ResultSet resultSet)\n  {\n    if(resultSet == null)\n      throw new NullPointerException(\"resultSet\");\n\n    ResultSet oldValue = explicitResultSet_;\n    explicitResultSet_ = resultSet;\n    propertyChangeSupport_.firePropertyChange(\"resultSet\", oldValue, resultSet);\n  }\n\n\n\n  // @D2A\n  /**\n  Sets the value at the specifed row and column.\n  \n  @param value          The value.\n  @param rowIndex       The row index (0-based).\n  @param columnIndex    The column index (0-based).\n  **/\n  public void setValueAt(Object value, int rowIndex, int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return;\n      if(rowIndex < 0)\n        return;\n      if((rowCountComplete_) && (rowIndex >= rowCount_))\n        return;\n      if(resultSet_ == null)\n        return;\n\n      if(!updatable_) return; //@D6A\n\n      if(scrollable_)\n      {\n        try\n        {\n          // Update the value in the result set.\n          synchronized(resultSet_)\n          {\n            resultSet_.absolute(rowIndex+1);\n            resultSet_.updateObject(columnIndex+1, value);\n            resultSet_.updateRow();\n          }\n\n          // Update the value in the cache.\n          ((Object[])cachedRows_.elementAt(rowIndex - firstCachedRow_))[columnIndex] = value;\n        }\n        catch(SQLException e)\n        {\n          // Don't set error_ to true, because that will ruin the whole\n          // model.  Just fire an event and do not update the cache.\n          errorEventSupport_.fireError(e);\n        }\n\n      }\n    }\n  }\n\n  //@KKB - Checks if a Data Mapping Warning was issued\n  private boolean checkDataMappingWarning(ResultSet rs, int columnIndex) throws SQLException{\n      boolean dataMapping = false;\n      SQLWarning w = rs.getWarnings();\n      if(w!=null){\n          do{\n              if(w.getSQLState().equals(\"01004\") && ((java.sql.DataTruncation)w).getDataSize() == -1 && ((java.sql.DataTruncation)w).getTransferSize() == -1 && ((java.sql.DataTruncation)w).getIndex() == columnIndex)\n                  dataMapping = true;\n\n              w=w.getNextWarning();\n          }while(w!=null);\n      }\n\n      return dataMapping;\n  }\n\n  \n  \n/**\n * Set a reference to the JTable so that the selected row can be updated after \n * fireTableRowsInserted. \n * \n * @param table\n */\npublic void setTable(JTable table) {\n\ttable_ = table; \n\t\n}\n\n\n\n/**\n  Restore the state of this object from an object input stream.\n  It is used when deserializing an object.\n  @param sqlResultSetTablePane TODO\n * @param in The input stream of the object being deserialized.\n * @exception IOException\n  @exception ClassNotFoundException\n  **/\n  void readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)\n  throws IOException, ClassNotFoundException\n  {\n    // Restore the non-static and non-transient fields.\n    in.defaultReadObject();\n\n    // Initialize the transient fields.\n    sqlResultSetTablePane.changeListeners_ = new PropertyChangeSupport(sqlResultSetTablePane);\n    addPropertyChangeListener(sqlResultSetTablePane.changeListeners_);\n    sqlResultSetTablePane.vetoListeners_ = new VetoableChangeSupport(sqlResultSetTablePane);\n    addVetoableChangeListener(sqlResultSetTablePane.vetoListeners_);\n    sqlResultSetTablePane.errorListeners_ = new ErrorEventSupport(sqlResultSetTablePane);\n    addErrorListener(sqlResultSetTablePane.errorListeners_);\n    sqlResultSetTablePane.worker_ = new WorkingCursorAdapter(sqlResultSetTablePane);\n    addWorkingListener(sqlResultSetTablePane.worker_);\n    sqlResultSetTablePane.selectionListeners_ = new ListSelectionEventSupport(sqlResultSetTablePane);\n\n    sqlResultSetTablePane.initializeTransient(); //@B0A\n    //@B0D table_.getSelectionModel().addListSelectionListener(selectionListeners_);\n\n    //@B0 - table_ is now transient, so we need to reset its attributes.\n    sqlResultSetTablePane.table_.setGridColor(sqlResultSetTablePane.tableColor_); //@B0A\n    sqlResultSetTablePane.table_.setShowHorizontalLines(sqlResultSetTablePane.tableShowHorizontalLines_); //@B0A\n    sqlResultSetTablePane.table_.setShowVerticalLines(sqlResultSetTablePane.tableShowVerticalLines_); //@B0A\n\n  }\n\n\n  \n  \n}",
                "methodCount": 40
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 9,
                "candidates": [
                    {
                        "lineStart": 302,
                        "lineEnd": 311,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method addWorkingListener to class WorkingEventSupport",
                        "description": "Move method addWorkingListener to com.ibm.as400.vaccess.WorkingEventSupport\nRationale: The method addWorkingListener(WorkingListener listener) is responsible for adding a listener to be notified of working events, which is a core functionality of the WorkingEventSupport class. This class is specifically designed to manage a list of WorkingListeners and dispatch events to them. Moving this method to WorkingEventSupport aligns with the Single Responsibility Principle, as it centralizes the event management logic within the class that is already handling listener registration and event firing. The WorkingListener interface, on the other hand, is meant to define the contract for listeners, not to manage them.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1128,
                        "lineEnd": 1136,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method removeVetoableChangeListener to class VetoableChangeSupport",
                        "description": "Move method removeVetoableChangeListener to com.ibm.as400.vaccess.VetoableChangeSupport\nRationale: The method removeVetoableChangeListener(VetoableChangeListener listener) is directly related to managing the list of vetoable change listeners. Since VetoableChangeSupport is specifically designed to handle the addition and removal of such listeners, it is more appropriate for this method to reside within that class. Moving this method to VetoableChangeSupport will enhance the cohesion of the class, as it will centralize all listener management functionality in one place, making the code easier to maintain and understand.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1116,
                        "lineEnd": 1124,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method removePropertyChangeListener to class PropertyChangeSupport",
                        "description": "Move method removePropertyChangeListener to com.ibm.as400.vaccess.PropertyChangeSupport\nRationale: The method removePropertyChangeListener(PropertyChangeListener listener) is directly related to managing property change listeners, which is the primary responsibility of the PropertyChangeSupport class. This class is designed to handle the addition and removal of PropertyChangeListeners, and it already contains a similar method that calls the superclass's implementation. Moving this method to PropertyChangeSupport will enhance cohesion by ensuring that all listener management functionality resides within the same class, thereby adhering to the Single Responsibility Principle. This will also improve code maintainability and clarity, as it will be clear that listener management is encapsulated within the PropertyChangeSupport class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1104,
                        "lineEnd": 1112,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method removeErrorListener to class ErrorEventSupport",
                        "description": "Move method removeErrorListener to com.ibm.as400.vaccess.ErrorEventSupport\nRationale: The method removeErrorListener(ErrorListener listener) is responsible for removing a listener from a collection of error listeners. This functionality is inherently tied to the management of listeners, which is the primary responsibility of the ErrorEventSupport class. Moving this method to ErrorEventSupport aligns with the Single Responsibility Principle, as it centralizes all listener management within the class designed for that purpose. The ErrorListener interface, on the other hand, is meant to define the contract for listeners, not manage them. Therefore, it is more appropriate for the removeErrorListener method to reside in ErrorEventSupport.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1140,
                        "lineEnd": 1148,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method removeWorkingListener to class WorkingEventSupport",
                        "description": "Move method removeWorkingListener to com.ibm.as400.vaccess.WorkingEventSupport\nRationale: The method removeWorkingListener(WorkingListener listener) is responsible for managing the list of listeners that respond to working events. Since WorkingEventSupport is specifically designed to handle the addition and removal of WorkingListeners, it is more appropriate for this method to reside within that class. Moving this method to WorkingEventSupport aligns with the Single Responsibility Principle, as it centralizes the event listener management functionality in one place, making the codebase cleaner and easier to maintain.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 264,
                        "lineEnd": 272,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method addErrorListener to class ErrorEventSupport",
                        "description": "Move method addErrorListener to com.ibm.as400.vaccess.ErrorEventSupport\nRationale: The method addErrorListener(ErrorListener listener) is responsible for adding a listener to be notified of error events. This functionality is inherently tied to the ErrorEventSupport class, which is designed to manage a list of ErrorListeners and provide notification services for error events. Moving this method to ErrorEventSupport aligns with the class's purpose of handling event listeners, ensuring better encapsulation and adherence to the Single Responsibility Principle. The current class, which contains this method, likely does not have the same focus on managing listeners, making it less appropriate for this functionality.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 276,
                        "lineEnd": 285,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method addPropertyChangeListener to class PropertyChangeSupport",
                        "description": "Move method addPropertyChangeListener to com.ibm.as400.vaccess.PropertyChangeSupport\nRationale: The method addPropertyChangeListener(PropertyChangeListener listener) is directly related to managing property change listeners, which is the primary responsibility of the PropertyChangeSupport class. Moving this method to PropertyChangeSupport aligns with the principle of single responsibility, as it centralizes the functionality for adding listeners within the class that is designed to handle property change events. The existing class, which contains this method, likely has other responsibilities that do not pertain to listener management, making it less cohesive. By relocating the method to PropertyChangeSupport, we enhance the clarity and maintainability of the code, ensuring that all listener-related operations are encapsulated within the appropriate class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 289,
                        "lineEnd": 298,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method addVetoableChangeListener to class VetoableChangeSupport",
                        "description": "Move method addVetoableChangeListener to com.ibm.as400.vaccess.VetoableChangeSupport\nRationale: The method addVetoableChangeListener(VetoableChangeListener listener) is responsible for adding a listener that will be notified of changes to constrained properties. This functionality is inherently tied to the management of listeners, which is the primary responsibility of the VetoableChangeSupport class. Moving this method to VetoableChangeSupport aligns with the principle of encapsulation, as it centralizes listener management within the class designed for that purpose. Additionally, the existing class likely has other methods related to listener management, making it a more cohesive and maintainable design.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1297,
                        "lineEnd": 1330,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method readObject2 to class SQLResultSetTablePane",
                        "description": "Move method readObject2 to com.ibm.as400.vaccess.SQLResultSetTablePane\nRationale: The method readObject2() is responsible for restoring the state of an SQLResultSetTablePane object during deserialization. It directly manipulates the transient fields of SQLResultSetTablePane, such as changeListeners_, vetoListeners_, errorListeners_, and worker_. Since these fields are specific to the SQLResultSetTablePane class, it is logical for the method to reside within this class. Moving it here will enhance encapsulation and maintainability, as the method will be closely associated with the class it operates on.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setTable",
                            "method_signature": "public void setTable(JTable table)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The setTable() method is responsible for setting a reference to a JTable, which is more relevant to the SQLResultSetTablePane class that likely manages the UI components. Moving it there would improve cohesion."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The readObject2() method is specifically designed to restore the state of the SQLResultSetTablePane, making it more appropriate to reside within that class for better encapsulation."
                        }
                    ],
                    "llm_response_time": 5810
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "setTable",
                            "method_signature": "public void setTable(JTable table)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The setTable() method is responsible for setting a reference to a JTable, which is more relevant to the SQLResultSetTablePane class that likely manages the UI components. Moving it there would improve cohesion."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The readObject2() method is specifically designed to restore the state of the SQLResultSetTablePane, making it more appropriate to reside within that class for better encapsulation."
                        }
                    ],
                    "llm_response_time": 4099
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "setTable",
                            "method_signature": "public void setTable(JTable table)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The setTable() method is responsible for setting a reference to a JTable, which is more relevant to the SQLResultSetTablePane class that likely manages the UI components."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The readObject2() method is specifically designed to restore the state of the SQLResultSetTablePane, making it more appropriate to reside within that class."
                        }
                    ],
                    "llm_response_time": 3630
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "addErrorListener",
                            "method_signature": "public addErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addPropertyChangeListener",
                            "method_signature": "public addPropertyChangeListener(PropertyChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addVetoableChangeListener",
                            "method_signature": "public addVetoableChangeListener(VetoableChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addWorkingListener",
                            "method_signature": "public addWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getValueAt",
                            "method_signature": "public getValueAt(int rowIndex, int columnIndex)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "load",
                            "method_signature": "public load()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "markError",
                            "method_signature": "private markError(Exception e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeErrorListener",
                            "method_signature": "public removeErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removePropertyChangeListener",
                            "method_signature": "public removePropertyChangeListener(PropertyChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeVetoableChangeListener",
                            "method_signature": "public removeVetoableChangeListener(VetoableChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeWorkingListener",
                            "method_signature": "public removeWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setValueAt",
                            "method_signature": "public setValueAt(Object value, int rowIndex, int columnIndex)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": " readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "addWorkingListener",
                            "method_signature": "public addWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeVetoableChangeListener",
                            "method_signature": "public removeVetoableChangeListener(VetoableChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removePropertyChangeListener",
                            "method_signature": "public removePropertyChangeListener(PropertyChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeErrorListener",
                            "method_signature": "public removeErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeWorkingListener",
                            "method_signature": "public removeWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addErrorListener",
                            "method_signature": "public addErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addPropertyChangeListener",
                            "method_signature": "public addPropertyChangeListener(PropertyChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addVetoableChangeListener",
                            "method_signature": "public addVetoableChangeListener(VetoableChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": " readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "markError",
                            "method_signature": "private markError(Exception e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "load",
                            "method_signature": "public load()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setValueAt",
                            "method_signature": "public setValueAt(Object value, int rowIndex, int columnIndex)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getValueAt",
                            "method_signature": "public getValueAt(int rowIndex, int columnIndex)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public addWorkingListener(WorkingListener listener)": {
                        "first": {
                            "method_name": "addWorkingListener",
                            "method_signature": "public addWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3763736614652519
                    },
                    "public removeVetoableChangeListener(VetoableChangeListener listener)": {
                        "first": {
                            "method_name": "removeVetoableChangeListener",
                            "method_signature": "public removeVetoableChangeListener(VetoableChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3999385353368075
                    },
                    "public removePropertyChangeListener(PropertyChangeListener listener)": {
                        "first": {
                            "method_name": "removePropertyChangeListener",
                            "method_signature": "public removePropertyChangeListener(PropertyChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4010997861299994
                    },
                    "public removeErrorListener(ErrorListener listener)": {
                        "first": {
                            "method_name": "removeErrorListener",
                            "method_signature": "public removeErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.40317909391638995
                    },
                    "public removeWorkingListener(WorkingListener listener)": {
                        "first": {
                            "method_name": "removeWorkingListener",
                            "method_signature": "public removeWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4055615712804905
                    },
                    "public addErrorListener(ErrorListener listener)": {
                        "first": {
                            "method_name": "addErrorListener",
                            "method_signature": "public addErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.42165201002590574
                    },
                    "public addPropertyChangeListener(PropertyChangeListener listener)": {
                        "first": {
                            "method_name": "addPropertyChangeListener",
                            "method_signature": "public addPropertyChangeListener(PropertyChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.48252447779731317
                    },
                    "public addVetoableChangeListener(VetoableChangeListener listener)": {
                        "first": {
                            "method_name": "addVetoableChangeListener",
                            "method_signature": "public addVetoableChangeListener(VetoableChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.48252447779731317
                    },
                    " readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)": {
                        "first": {
                            "method_name": "readObject2",
                            "method_signature": " readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5284903088398075
                    },
                    "private markError(Exception e)": {
                        "first": {
                            "method_name": "markError",
                            "method_signature": "private markError(Exception e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5729407829139317
                    },
                    "public load()": {
                        "first": {
                            "method_name": "load",
                            "method_signature": "public load()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7104810611941907
                    },
                    "public setValueAt(Object value, int rowIndex, int columnIndex)": {
                        "first": {
                            "method_name": "setValueAt",
                            "method_signature": "public setValueAt(Object value, int rowIndex, int columnIndex)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7282289183383774
                    },
                    "public getValueAt(int rowIndex, int columnIndex)": {
                        "first": {
                            "method_name": "getValueAt",
                            "method_signature": "public getValueAt(int rowIndex, int columnIndex)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.8007962233015496
                    }
                },
                "voyage": {
                    "public addWorkingListener(WorkingListener listener)": {
                        "first": {
                            "method_name": "addWorkingListener",
                            "method_signature": "public addWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.23868198644606925
                    },
                    "public removeWorkingListener(WorkingListener listener)": {
                        "first": {
                            "method_name": "removeWorkingListener",
                            "method_signature": "public removeWorkingListener(WorkingListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.27224943373633603
                    },
                    "public removeVetoableChangeListener(VetoableChangeListener listener)": {
                        "first": {
                            "method_name": "removeVetoableChangeListener",
                            "method_signature": "public removeVetoableChangeListener(VetoableChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2728647808029043
                    },
                    "public addVetoableChangeListener(VetoableChangeListener listener)": {
                        "first": {
                            "method_name": "addVetoableChangeListener",
                            "method_signature": "public addVetoableChangeListener(VetoableChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.27481027256098767
                    },
                    "public removePropertyChangeListener(PropertyChangeListener listener)": {
                        "first": {
                            "method_name": "removePropertyChangeListener",
                            "method_signature": "public removePropertyChangeListener(PropertyChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2845074965790847
                    },
                    "public removeErrorListener(ErrorListener listener)": {
                        "first": {
                            "method_name": "removeErrorListener",
                            "method_signature": "public removeErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2885394848997434
                    },
                    "public addPropertyChangeListener(PropertyChangeListener listener)": {
                        "first": {
                            "method_name": "addPropertyChangeListener",
                            "method_signature": "public addPropertyChangeListener(PropertyChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2997865903228911
                    },
                    "public addErrorListener(ErrorListener listener)": {
                        "first": {
                            "method_name": "addErrorListener",
                            "method_signature": "public addErrorListener(ErrorListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3000655948681344
                    },
                    "private markError(Exception e)": {
                        "first": {
                            "method_name": "markError",
                            "method_signature": "private markError(Exception e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5436358502576858
                    },
                    "public setValueAt(Object value, int rowIndex, int columnIndex)": {
                        "first": {
                            "method_name": "setValueAt",
                            "method_signature": "public setValueAt(Object value, int rowIndex, int columnIndex)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5888486515292856
                    },
                    " readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)": {
                        "first": {
                            "method_name": "readObject2",
                            "method_signature": " readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6039050472947767
                    },
                    "public getValueAt(int rowIndex, int columnIndex)": {
                        "first": {
                            "method_name": "getValueAt",
                            "method_signature": "public getValueAt(int rowIndex, int columnIndex)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6506683555680091
                    },
                    "public load()": {
                        "first": {
                            "method_name": "load",
                            "method_signature": "public load()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7261780520019808
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private markError(Exception e)",
                        "public load()",
                        "public setValueAt(Object value, int rowIndex, int columnIndex)",
                        "public getValueAt(int rowIndex, int columnIndex)",
                        "public addErrorListener(ErrorListener listener)",
                        "public removeErrorListener(ErrorListener listener)",
                        "public addPropertyChangeListener(PropertyChangeListener listener)",
                        "public removePropertyChangeListener(PropertyChangeListener listener)",
                        "public addVetoableChangeListener(VetoableChangeListener listener)",
                        "public removeVetoableChangeListener(VetoableChangeListener listener)",
                        "public addWorkingListener(WorkingListener listener)",
                        "public removeWorkingListener(WorkingListener listener)"
                    ],
                    "llm_response_time": 3750
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public addWorkingListener(WorkingListener listener)",
                        "public removeWorkingListener(WorkingListener listener)",
                        "public removeErrorListener(ErrorListener listener)",
                        "public removePropertyChangeListener(PropertyChangeListener listener)",
                        "public removeVetoableChangeListener(VetoableChangeListener listener)"
                    ],
                    "llm_response_time": 1438
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public addWorkingListener(WorkingListener listener)",
                        "public removePropertyChangeListener(PropertyChangeListener listener)",
                        "public removeVetoableChangeListener(VetoableChangeListener listener)"
                    ],
                    "llm_response_time": 1150
                },
                "voyage": {
                    "priority_method_names": [
                        "public load()",
                        "public getValueAt(int rowIndex, int columnIndex)",
                        "public setValueAt(Object value, int rowIndex, int columnIndex)",
                        "private markError(Exception e)",
                        "public addErrorListener(ErrorListener listener)",
                        "public removeErrorListener(ErrorListener listener)",
                        "public addPropertyChangeListener(PropertyChangeListener listener)",
                        "public removePropertyChangeListener(PropertyChangeListener listener)",
                        "public addVetoableChangeListener(VetoableChangeListener listener)",
                        "public removeVetoableChangeListener(VetoableChangeListener listener)",
                        "public addWorkingListener(WorkingListener listener)",
                        "public removeWorkingListener(WorkingListener listener)"
                    ],
                    "llm_response_time": 3246
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public addWorkingListener(WorkingListener listener)",
                        "public removeWorkingListener(WorkingListener listener)",
                        "public addVetoableChangeListener(VetoableChangeListener listener)",
                        "public removeVetoableChangeListener(VetoableChangeListener listener)",
                        "public removePropertyChangeListener(PropertyChangeListener listener)"
                    ],
                    "llm_response_time": 1586
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public addWorkingListener(WorkingListener listener)",
                        "public removeWorkingListener(WorkingListener listener)",
                        "public removeVetoableChangeListener(VetoableChangeListener listener)"
                    ],
                    "llm_response_time": 1317
                }
            },
            "targetClassMap": {
                "addWorkingListener": {
                    "target_classes": [
                        {
                            "class_name": "WorkingListener",
                            "similarity_score": 0.46360044557175345
                        },
                        {
                            "class_name": "WorkingEventSupport",
                            "similarity_score": 0.25105114610159507
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "WorkingEventSupport",
                        "WorkingListener"
                    ],
                    "llm_response_time": 3178,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "removeVetoableChangeListener": {
                    "target_classes": [
                        {
                            "class_name": "VetoableChangeSupport",
                            "similarity_score": 0.6821842146102753
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "VetoableChangeSupport"
                    ],
                    "llm_response_time": 2476,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "removePropertyChangeListener": {
                    "target_classes": [
                        {
                            "class_name": "PropertyChangeSupport",
                            "similarity_score": 0.6858610685885338
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PropertyChangeSupport"
                    ],
                    "llm_response_time": 2574,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "removeErrorListener": {
                    "target_classes": [
                        {
                            "class_name": "ErrorListener",
                            "similarity_score": 0.4646031596277006
                        },
                        {
                            "class_name": "ErrorEventSupport",
                            "similarity_score": 0.2533336724428735
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ErrorEventSupport",
                        "ErrorListener"
                    ],
                    "llm_response_time": 3395,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "removeWorkingListener": {
                    "target_classes": [
                        {
                            "class_name": "WorkingListener",
                            "similarity_score": 0.4045434552364591
                        },
                        {
                            "class_name": "WorkingEventSupport",
                            "similarity_score": 0.2837482243393592
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "WorkingEventSupport",
                        "WorkingListener"
                    ],
                    "llm_response_time": 3963,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "addErrorListener": {
                    "target_classes": [
                        {
                            "class_name": "ErrorListener",
                            "similarity_score": 0.47253691838893
                        },
                        {
                            "class_name": "ErrorEventSupport",
                            "similarity_score": 0.28287102607073333
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ErrorEventSupport",
                        "ErrorListener"
                    ],
                    "llm_response_time": 4536,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "addPropertyChangeListener": {
                    "target_classes": [
                        {
                            "class_name": "PropertyChangeSupport",
                            "similarity_score": 0.5789085723455262
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PropertyChangeSupport"
                    ],
                    "llm_response_time": 2481,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "addVetoableChangeListener": {
                    "target_classes": [
                        {
                            "class_name": "VetoableChangeSupport",
                            "similarity_score": 0.5744569444849087
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "VetoableChangeSupport"
                    ],
                    "llm_response_time": 2457,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "readObject2": {
                    "target_classes": [
                        {
                            "class_name": "SQLResultSetTablePane",
                            "similarity_score": 0.568061770869418
                        },
                        {
                            "class_name": "SQLConnection",
                            "similarity_score": 0.5398874302710917
                        },
                        {
                            "class_name": "PropertyChangeSupport",
                            "similarity_score": 0.31285654688986536
                        },
                        {
                            "class_name": "VetoableChangeSupport",
                            "similarity_score": 0.3301593230334562
                        },
                        {
                            "class_name": "ErrorEventSupport",
                            "similarity_score": 0.38034536781567435
                        },
                        {
                            "class_name": "WorkingEventSupport",
                            "similarity_score": 0.3487555464057905
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SQLResultSetTablePane",
                        "ErrorEventSupport",
                        "SQLConnection"
                    ],
                    "llm_response_time": 14923,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                },
                "markError": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3863,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "load": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 5683,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "setValueAt": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3439,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "getValueAt": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4353,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.access.SpooledFile::applyChanges():void need move com.ibm.as400.vaccess.OutputPropertiesPane",
        "class_name": "com.ibm.as400.access.SpooledFile",
        "telemetry": {
            "id": "40758fb6-bfe4-4f72-af33-ce2aba25ee69",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1306,
                "lineStart": 22,
                "lineEnd": 1327,
                "bodyLineStart": 22,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/large/big/jtopen-7.8/src/com/ibm/as400/access/SpooledFile.java",
                "sourceCode": "/**\n * Represents a spooled file.\n * You can use an instance of this class to manipulate an individual\n * spooled file (hold, release, delete, send, read, and so on).\n * To create new spooled files on the system, use the\n * {@link SpooledFileOutputStream SpooledFileOutputStream} class.\n *\n * See <a href=\"{@docRoot}/com/ibm/as400/access/doc-files/SpooledFileAttrs.html\">Spooled File Attributes</a> for\n * valid attributes.\n *\n * @see PrintObjectInputStream\n * @see PrintObjectPageInputStream\n * @see PrintObjectTransformedInputStream\n **/\n\npublic class SpooledFile extends PrintObject\nimplements java.io.Serializable\n{\n    static final long serialVersionUID = 4L;\n\n    transient boolean fMsgRetrieved_  = false;\n\n    // constructor used internally (not externalized since it takes\n    // an ID code point\n    SpooledFile(AS400 system, NPCPIDSplF id, NPCPAttribute attrs)\n    {\n       super(system, id, attrs, NPConstants.SPOOLED_FILE);\n    }\n\n\n    // We have decide that spooled files are too transient to be JavaBeans.\n\n\n    /**\n     * Constructs a SpooledFile object. It uses the specified system and\n     * spooled file attributes that identify it on that system.\n     *\n     * @param system The system on which this spooled file exists.\n     * @param name The name of the spooled file.\n     * @param number The number of the spooled file.\n     * @param jobName The name of the job that created the spooled file.\n     * @param jobUser The user who created the spooled file.\n     * @param jobNumber The number of the job that created the spooled file.\n     *\n     **/\n    public SpooledFile(AS400 system,\n                       String name,\n                       int    number,\n                       String jobName,\n                       String jobUser,\n                       String jobNumber)\n    {\n        super(system,\n              new NPCPIDSplF(name,\n                             number,\n                             jobName,\n                             jobUser,\n                             jobNumber),\n              null,\n              NPConstants.SPOOLED_FILE);\n\n        // base class constructor checks for null system.\n        if (name == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'name' is null.\");\n            throw new NullPointerException(\"name\");\n        }\n\n        if (number < -1)    // (changed from 1 to -1 to allow 0(=*ONLY) and -1(=*LAST))\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'number' is less than -1.\");\n            throw new ExtendedIllegalArgumentException(\n                \"number(\" + number + \")\",\n                ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        if (jobName == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobName' is null.\");\n            throw new NullPointerException(\"jobName\");\n        }\n\n        if (jobUser == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobUser' is null.\");\n            throw new NullPointerException(\"jobUser\");\n        }\n\n        if (jobNumber == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobNumber' is null.\");\n            throw new NullPointerException(\"jobNumber\");\n        }\n    }\n    \n    // Alternate constructor for spooled files detached from jobs\n    /**\n     * Constructs a SpooledFile object. It uses the specified system and\n     * spooled file attributes that identify it on that system.\n     *\n     * @param system The system on which this spooled file exists.\n     * @param name The name of the spooled file.\n     * @param number The number of the spooled file.\n     * @param jobName The name of the job that created the spooled file.\n     * @param jobUser The user who created the spooled file.\n     * @param jobNumber The number of the job that created the spooled file.\n     * @param jobSysName The name of the system where the spooled file was created.\n     * @param createDate The date the spooled file was created on the system.\n     * <br>\n     * The date is encoded in a character string with the following format,\n     * CYYMMDD where:\n     * <ul>\n     * <li> C is the Century, where 0 indicates years 19xx and 1 indicates years 20xx\n     * <li> YY is the Year\n     * <li> MM is the Month\n     * <li> DD is the Day\n     * </ul>\n     * @param createTime The time the spooled file was created on the system.\n     * <br>\n     * The time is encoded in a character string with the following format,\n     * HHMMSS where:\n     * <ul>\n     * <li> HH - Hour \n     * <li> MM - Minutes \n     * <li> SS - Seconds \n     * </ul>\n     **/\n   \n    public SpooledFile(AS400 system,\n                       String name,\n                       int    number,\n                       String jobName,\n                       String jobUser,\n                       String jobNumber,\n                       String jobSysName,\n                       String createDate,\n                       String createTime)\n    {\n        super(system,\n              new NPCPIDSplF(name,\n                             number,\n                             jobName,\n                             jobUser,\n                             jobNumber,\n                             jobSysName,\n                             createDate,\n                             createTime),\n              null,\n              NPConstants.SPOOLED_FILE);\n\n        // base class constructor checks for null system.\n   \n        if (name == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'name' is null.\");\n            throw new NullPointerException(\"name\");\n        }\n\n        if (number < -1)    // (changed from 1 to -1 to allow 0(=*ONLY) and -1(=*LAST))\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'number' is less than -1.\");\n            throw new ExtendedIllegalArgumentException(\n                \"number(\" + number + \")\",\n                ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        if (jobName == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobName' is null.\");\n            throw new NullPointerException(\"jobName\");\n        }\n\n        if (jobUser == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobUser' is null.\");\n            throw new NullPointerException(\"jobUser\");\n        }\n\n        if (jobNumber == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobNumber' is null.\");\n            throw new NullPointerException(\"jobNumber\");\n        }\n        \n        if (jobSysName == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobSysName' is null.\");\n            throw new NullPointerException(\"jobSysName\");\n        }\n        \n        if (createDate == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'createDate' is null.\");\n            throw new NullPointerException(\"createDate\");\n        }\n        \n        if (createTime == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'createTime' is null.\");\n            throw new NullPointerException(\"createTime\");\n        }\n    }\n\n\n\n    /** Replies to the message that caused the spooled file to wait.\n     *\n     * @param reply The string that contains the reply for the message.\n     *              The default reply can be obtained by calling\n     *              the getMessage() method, and then calling the\n     *              getDefaultReply() method on the message object that is returned.\n     *              Other possible replies are given in the message help,\n     *              which can also be retrieved from the message object returned\n     *              on the getMessage() method.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is\n     *                                            completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                          system is not at the correct level.\n     **/\n    public void answerMessage(String reply)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).answerMessage(reply);\n        // update the spooled file attributes\n        attrs = impl_.getAttrValue();\n        fMsgRetrieved_ = ((SpooledFileImpl) impl_).getFMsgRetrieved();\n    }\n\n\n\n    /**\n     * Chooses the implementation\n     **/\n    void chooseImpl()\n    throws IOException, AS400SecurityException\n    {\n        // We need to get the system to connect to...\n        AS400 system = getSystem();\n        if (system == null) {\n            Trace.log( Trace.ERROR, \"Attempt to use SpooledFile before setting system.\" );\n            throw new ExtendedIllegalStateException(\"system\",\n                                    ExtendedIllegalStateException.PROPERTY_NOT_SET);\n        }\n\n        impl_ = (SpooledFileImpl) system.loadImpl2(\"com.ibm.as400.access.SpooledFileImplRemote\",\n                                                   \"com.ibm.as400.access.SpooledFileImplProxy\");\n        // The connectService(AS400.PRINT) is done in setImpl()\n        // in the Printobject class.\n        super.setImpl();  \n    }\n    \n        \n    \n    /**\n     * Creates a copy of the spooled file this (SpooledFile) object represents.  The\n     * new spooled file is created on the same output queue and on the same system \n     * as the original spooled file. A reference to the new spooled file is returned.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system is not at the correct level.\n     **/\n    public SpooledFile copy()\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        String name = getStringAttribute(ATTR_OUTPUT_QUEUE);\n        OutputQueue outq = new OutputQueue(getSystem(), name);\n        SpooledFile sf = copy(outq);\n        return sf;\n    }\n\n\n\n    /**\n     * Creates a copy of the spooled file this object represents.  The\n     * new spooled file is created on the specified output queue.\n     * A reference to the new spooled file is returned.\n     *\n     * @param outputQueue The output queue location to create the new version of the\n     *       original spooled file.  The spooled file will be created to the first\n     *       position on this output queue.  The output queue and this spooled\n     *       file must reside on the same system.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system is not at the correct level.\n     **/\n    public SpooledFile copy(OutputQueue outputQueue)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        // choose implementations\n        if (impl_ == null) {\n            chooseImpl();\n        }\n        if (outputQueue.getImpl() == null) {     \n            outputQueue.chooseImpl();        \n        }                        \n        \n        NPCPIDSplF spID = \n        ((SpooledFileImpl) impl_).copy((OutputQueueImpl)outputQueue.getImpl()); \n    \t\n        try {\n            spID.setConverter((new Converter(getSystem().getCcsid(), getSystem())).impl);\n        }\n        catch (UnsupportedEncodingException e) {\n            if (Trace.isTraceErrorOn()) {\n                Trace.log(Trace.ERROR, \"Error initializing converter for spooled file.\");\n            }\n        }\n        SpooledFile sf = new SpooledFile(getSystem(), spID, null);\n        return sf;\n    }\n\n\n\n    /**\n      * Deletes the spooled file on the system.\n      *\n      * @exception AS400Exception If the system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      **/\n    public void delete()\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).delete();\n    }\n\n\n    /**\n      * Returns an input stream that can be used to read the contents of the\n      * spooled file.\n      * This method will fail with an AS400Exception if the spooled file is\n      * still being created (ATTR_SPLFSTATUS is *OPEN).\n      * Note that the bytes are returned untransformed, that is, as they are\n      * stored on the server.  To transform the bytes into other forms, use\n      * {@link #getPageInputStream getPageInputStream} or\n      * {@link #getTransformedInputStream getTransformedInputStream}.\n      *\n      * @return The input stream object that can be used to read the contents\n      *         of this spooled file.\n      * @exception AS400Exception If system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception RequestNotSupportedException If the requested function is not supported\n      *                                         because the system is not at the\n      *                                         correct level.\n      * @see #getPageInputStream\n      * @see #getTransformedInputStream\n      **/\n    public PrintObjectInputStream getInputStream()\n        throws AS400Exception,\n               AS400SecurityException,\n               ErrorCompletingRequestException,\n               IOException,\n               InterruptedException,\n               RequestNotSupportedException\n    {\n        PrintObjectInputStream is = new PrintObjectInputStream(this, null);\n        return is;\n    }\n\n\n    /**\n      * Returns an input stream that can be used to read the contents of the\n      * spooled file.\n      * This method will fail with an AS400Exception if the spooled file is\n      * still being created (ATTR_SPLFSTATUS is *OPEN).\n      * Note that the bytes are returned untransformed, that is, as they are\n      * stored on the server.  To transform the bytes into other forms, use\n      * {@link #getPageInputStream getPageInputStream} or\n      * {@link #getTransformedInputStream getTransformedInputStream}.\n      *\n      * @return The input stream object that can be used to read the contents\n      *         of this spooled file.\n      * @exception AS400Exception If system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception RequestNotSupportedException If the requested function is not supported\n      *                                         because the system is not at the\n      *                                         correct level.\n      * @see #getPageInputStream\n      * @see #getTransformedInputStream\n      **/\n    public PrintObjectInputStream getInputStream(PrintParameterList ppl)\n        throws AS400Exception,\n               AS400SecurityException,\n               ErrorCompletingRequestException,\n               IOException,\n               InterruptedException,\n               RequestNotSupportedException\n    {\n        PrintObjectInputStream is = new PrintObjectInputStream(this, ppl);\n        return(is);\n    }\n    \n    \n    /**\n      *  @deprecated Use getAFPInputStream() instead.\n      *  @see #getAFPInputStream\n      **/\n    public PrintObjectInputStream getInputACIFMergedStream(boolean acifB)\n        throws AS400Exception,\n               AS400SecurityException,\n               ErrorCompletingRequestException,\n               IOException,\n               InterruptedException,\n               RequestNotSupportedException\n    {\n        String acifS;\n        // possible open options that we could use -\n        // acifB == true then process ACIF merged data\n        // else normal processing\n        if (acifB){\n            acifS = \"Y\";\n            } else acifS = \"N\"; \n\n        PrintObjectInputStream is = new PrintObjectInputStream(this, null, acifS);\n        return is;\n    }\n\n    /**\n     * Returns an input stream that can be used to read the contents of an \n     * AFP spooled file. The external resources referenced by the original \n     * AFP spooled file will be included in this input stream. If you don't want \n     * the external resources included use \n     * {@link #getInputStream getInputStream} or\n     * {@link #getPageInputStream getPageInputStream}.\n     * This method will fail with an AS400Exception if the spooled file is\n     * still being created (ATTR_SPLFSTATUS is *OPEN) or if the spooled file\n     * doesn't contain AFDS data ie. ATTR_PRTDEVTYPE is not *AFPDS. \n     *\n     * @return The input stream object that can be used to read the contents\n     *         of this spooled file.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported\n     *                                         because the system operating system is not\n     *                                         at the correct level.\n     * @see #getInputStream\n     * @see #getPageInputStream\n     **/\n   public PrintObjectInputStream getAFPInputStream()\n       throws AS400Exception,\n              AS400SecurityException,\n              ErrorCompletingRequestException,\n              IOException,\n              InterruptedException,\n              RequestNotSupportedException\n   {\n       PrintObjectInputStream is = new PrintObjectInputStream(this, null, \"Y\");\n       return is;\n   }\n\n    /**\n      * Returns the name of the job that created the spooled file.\n      * @return The job name.\n      **/\n    public String getJobName()\n    {\n        NPCPID IDCodePoint = getIDCodePoint();\n\n        if( IDCodePoint == null ) {\n            return EMPTY_STRING; // \"\"\n        } else {\n            return IDCodePoint.getStringValue(ATTR_JOBNAME);\n        }\n    }\n\n\n\n    /**\n      * Returns the number of the job that created the spooled file.\n      * @return The job number.\n      **/\n    public String getJobNumber()\n    {\n        NPCPID IDCodePoint = getIDCodePoint();\n\n        if( IDCodePoint == null ) {\n            return EMPTY_STRING; // \"\"\n        } else {\n            return IDCodePoint.getStringValue(ATTR_JOBNUMBER);\n        }\n    }\n\n\n\n    /**\n     * Returns the ID of the user that created the spooled file.\n     * @return The user ID.\n     **/\n    public String getJobUser()\n    {\n        NPCPID IDCodePoint = getIDCodePoint();\n\n        if( IDCodePoint == null ) {\n            return EMPTY_STRING; // \"\"\n        } else {\n            return IDCodePoint.getStringValue(ATTR_JOBUSER);\n        }\n    }\n\n    // The next three attributes are added to provide the\n    // decoupled spooled file identity.\n   \n    /**\n    * Returns the name of the system where the spooled file was created.\n    * @return The name of the system where the spooled file was created.\n    **/\n    public String getJobSysName()\n    {\n        String jobSysName = EMPTY_STRING;\n        NPCPID IDCodePoint = getIDCodePoint();\n        if (IDCodePoint == null) {\n            return(jobSysName);\n        } else {\n            jobSysName = IDCodePoint.getStringValue(ATTR_JOBSYSTEM);\n            if (jobSysName == null) {\n                try {\n                    jobSysName = this.getStringAttribute(ATTR_JOBSYSTEM);\n                }\n                catch (Exception e) {\n                    // ignore exceptions, splf may not have this attr.\n                    jobSysName = EMPTY_STRING;\n                }\n            }\n            return(jobSysName);\n        }\n    }\n    \n    /**\n    * Returns the date of the spooled file creation. \n    * The date is encoded in the CYYMMDD format.\n    * @return The date (CYYMMDD) of the spooled file creation.\n    **/\n    public String getCreateDate()\n    {\n        String createDate = EMPTY_STRING;\n        NPCPID IDCodePoint = getIDCodePoint();\n        if (IDCodePoint == null) {\n            return(createDate);\n        } else {\n            createDate = IDCodePoint.getStringValue(ATTR_DATE);\n            if (createDate == null) {\n                try {\n                    createDate = this.getStringAttribute(ATTR_DATE);\n                }\n                catch (Exception e) {\n                    // ignore exceptions, splf may not have this attr.\n                    createDate = EMPTY_STRING;\n                }\n            }   \n            return(createDate);\n        }\n    }\n    \n    /**\n    * Returns the time of spooled file creation.\n    * The time is encoded in the HHMMSS format.\n    * @return The time (HHMMSS) of the spooled file creation.\n    **/\n    public String getCreateTime()\n    {\n        String createTime = EMPTY_STRING;\n        NPCPID IDCodePoint = getIDCodePoint();\n        if (IDCodePoint == null) {\n            return(createTime);\n        } else {\n            createTime = IDCodePoint.getStringValue(ATTR_TIME);\n            if (createTime == null) {\n                try {\n                    createTime = this.getStringAttribute(ATTR_TIME);\n                }\n                catch (Exception e) {\n                    // ignore exceptions, splf may not have this attr.\n                    createTime = EMPTY_STRING;\n                }\n            }   \n            return(createTime);\n        }\n    }\n    \n    /**\n      * Returns the message that is associated with this spooled file.\n      * A spooled file has a message associated with it if its\n      * ATTR_SPLFSTATUS attribute returns *MESSAGE.\n      *\n      * @return The AS400Message object that contains the message text,\n      *   type, severity, id, date, time, and default reply.\n      * @exception AS400Exception If the system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      **/\n    public AS400Message getMessage()\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        AS400Message msg = ((SpooledFileImpl) impl_).getMessage();\n        fMsgRetrieved_   = ((SpooledFileImpl) impl_).getFMsgRetrieved();\n        return msg;\n    }\n\n\n\n    /**\n     * Returns the name of the spooled file.\n     * @return The name of the spooled file.\n     **/\n    public String getName()\n    {\n        NPCPID IDCodePoint = getIDCodePoint();\n\n        if( IDCodePoint == null )\n        {\n            return EMPTY_STRING; // \"\"\n        } else {\n            return IDCodePoint.getStringValue(ATTR_SPOOLFILE);\n        }\n    }\n\n\n\n    /**\n      * Returns the number of the spooled file.\n      * @return The number of the spooled file.\n      **/\n    public int getNumber()\n    {\n        NPCPID IDCodePoint = getIDCodePoint();\n\n        if( IDCodePoint == null ) {\n            return 0;\n        } else {\n            return IDCodePoint.getIntValue(ATTR_SPLFNUM).intValue();\n        }\n    }\n\n\n\n    /**\n     * Returns a page input stream that can be used to read the contents of the\n     * spooled file, one page at a time.\n     * <br>\n     * See <a href=\"{@docRoot}/com/ibm/as400/access/doc-files/TransInStr.html\">Example using PrintObjectPageInputStream</a>\n     * <br>\n     * @param pageStreamOptions A print parameter list that contains\n     *  parameters for generating the page input stream. <br>\n     * The following attributes are optional:\n     * <UL>\n     *   <LI> ATTR_MFGTYPE                 - Specifies the manufacturer type and model.\n     *   <LI> ATTR_WORKSTATION_CUST_OBJECT - Specifies the integrated file system name of\n     *                                       the workstation customization object to be\n     *                                       used.  The workstation customizing object\n     *                                       associated with the manufacturer, type, and\n     *                                       model is the default.\n     *   <LI> ATTR_PAPER_SOURCE_1          - Specifies the paper size of drawer 1.\n     *   <LI> ATTR_PAPER_SOURCE_2          - Specifies the paper size of drawer 2.\n     *   <LI> ATTR_VIEWING_FIDELITY        - Specifies the fidelity used to process pages.\n     *\n     * </UL>\n     *\n     * @return A page input stream object that can be used to read the contents\n     *         of this spooled file, one page at a time.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed,\n                                                  or the spooled file format is not supported.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported\n     *                                         because the system operating system is not\n     *                                         at the correct level.\n     **/\n    public PrintObjectPageInputStream getPageInputStream(PrintParameterList pageStreamOptions)\n\t    throws AS400Exception,\n\t           AS400SecurityException,\n\t           ErrorCompletingRequestException,\n\t           IOException,\n\t           InterruptedException,\n\t           RequestNotSupportedException\n    {\n        PrintObjectPageInputStream is = new PrintObjectPageInputStream(this, pageStreamOptions);\n        return is;\n    }\n\n\n\n    /**\n     * Returns a transformed input stream that can be used to read the contents of the\n     * spooled file.\n     * <br>\n     * See <a href=\"{@docRoot}/com/ibm/as400/access/doc-files/TransInStr.html\">Example using PrintObjectTransformedInputStream</a>\n     * <br>\n     * @param transformOptions A print parameter list that contains\n     *  parameters for generating the transformed input stream. <br>\n     * The following attribute MUST be set:\n     * <UL>\n     *   <LI> ATTR_MFGTYPE  - Specifies the manufacturer, type, and model.\n     * </UL>\n     * The following attributes are optional:\n     * <UL>\n     *   <LI> ATTR_WORKSTATION_CUST_OBJECT - Specifies the integrated file system name of\n     *                                       the workstation customization object to be\n     *                                       used.  The workstation customizing object\n     *                                       associated with the manufacturer, type, and\n     *                                       model is the default.\n     *   <LI> ATTR_PAPER_SOURCE_1          - Specifies the paper size of drawer 1.\n     *   <LI> ATTR_PAPER_SOURCE_2          - Specifies the paper size of drawer 2.\n     *\n     * </UL>\n     *\n     * @return The transformed input stream object that can be used to read the contents\n     *         of the transformed spooled file.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed,\n     *                                            or the spooled file format is not supported.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported\n     *                                         because the system operating system is not\n     *                                         at the correct level.\n     **/\n    public PrintObjectTransformedInputStream getTransformedInputStream(PrintParameterList transformOptions)\n\t    throws AS400Exception,\n\t           AS400SecurityException,\n\t           ErrorCompletingRequestException,\n\t           IOException,\n\t           InterruptedException,\n\t           RequestNotSupportedException\n    {\n        PrintObjectTransformedInputStream is = new PrintObjectTransformedInputStream(this, transformOptions);\n        return is;\n    }\n\n\n\n    /**\n     * Holds the spooled file.\n     * @param holdType When to hold the spooled file.\n     *  May be any of the following values:\n     * <UL>\n     *   <LI> *IMMED - The spooled file is held immediately.\n     *   <LI> *PAGEEND - The spooled file is held at the end of the current page.\n     * </UL>\n     *  <i>holdType</i> may be null.  If <i>holdType</i> is not specified, the default is\n     * *IMMED.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported\n     *                                         because the system operating system is not\n     *                                         at the correct level.\n     **/\n    public void hold(String holdType)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).hold(holdType);\n        // update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\n    /**\n     * Moves the spooled file to another output queue or to another\n     * position on the same output queue.\n     *\n     * @param targetSpooledFile The spooled file to move this\n     *       spooled file after.  The targetSpooledFile and this spooled file\n     *       must reside on the same system.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system operating system is not at the correct level.\n     **/\n    public void move(SpooledFile targetSpooledFile)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        if (targetSpooledFile.getImpl() == null) {\n            targetSpooledFile.chooseImpl();\n        }\n        ((SpooledFileImpl) impl_).move((SpooledFileImpl)targetSpooledFile.getImpl());\n    \t//update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\n    /**\n     * Moves the spooled file to another output queue.\n     *\n     * @param targetOutputQueue The output queue to move the\n     *       spooled file to.  The spooled file will be moved to the first\n     *       position on this output queue.  The output queue and this spooled\n     *       file must reside on the same system.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system operating system is not at the correct level.\n     **/\n    public void move(OutputQueue targetOutputQueue)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        if (targetOutputQueue.getImpl() == null) {\n            targetOutputQueue.chooseImpl();\n        }\n        ((SpooledFileImpl) impl_).move((OutputQueueImpl)targetOutputQueue.getImpl());\n    \t// update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\n    /**\n     * Moves the spooled file to the first position on the output queue.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system operating system is not at the correct level.\n     **/\n    public void moveToTop()\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).moveToTop();\n    \t// update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\n    /**\n    Restores the state of the object from an input stream.\n    This is used when deserializing an object.\n\n    @param in   The input stream.\n\n    @exception IOException Thrown if an IO error occurs.\n    @exception ClassNotFoundException Thrown if class is not found.\n    **/\n    private void readObject(ObjectInputStream in)\n        throws IOException, ClassNotFoundException\n    {\n        in.defaultReadObject();\n        fMsgRetrieved_ = false;\n    }\n\n\n\n    /**\n     * Releases a held spooled file on the system.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system operating system is not at the correct level.\n     **/\n    public void release()\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).release();\n    \t// update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\n    /**\n      * Sends the spooled file to another user on the same system or to\n      * a remote system on the network.  The equivalent of the system\n      * Send Network Spooled File\n      * (SNDNETSPLF) command will be issued against the spooled file.\n      *\n      * @param sendOptions A print parameter list that contains the\n      *  parameters for the send.  The following attributes MUST be set:\n      * <UL>\n      *   <LI> ATTR_TOUSERID  - Specifies the user ID to send the spooled file to.\n      *   <LI> ATTR_TOADDRESS - Specifies the remote system to send the spooled file to.\n      * </UL>\n      * The following attributes are optional:\n      * <UL>\n      *   <LI> ATTR_DATAFORMAT - Specifies the data format in which to transmit the\n      *                           spooled file.  May be either of *RCDDATA or\n      *                           *ALLDATA.  *RCDDATA is the default.\n      *   <LI> ATTR_VMMVSCLASS - Specifies the VM/MVS SYSOUT class for distributions\n      *                          sent to a VM host system or to an MVS host system.\n      *                          May be A to Z or 0 to 9.  A is the default.\n      *   <LI> ATTR_SENDPTY - Specifies the queueing priority used for this spooled file\n      *                        when it is being routed through a SNADS network.  May be\n      *                        *NORMAL or *HIGH.  *NORMAL is the default.\n      * </UL>\n      *\n      * @exception AS400Exception If the system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      **/\n    public void sendNet(PrintParameterList sendOptions)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).sendNet(sendOptions);\n    }\n\n\n\n    /**\n      * Sends a spooled file to be printed on a remote system.\n      * The equivalent of the Send TCP/IP Spooled File\n      * (SNDTCPSPLF) command will be issued against the spooled file.\n      * This is the system's version of the TCP/IP LPR command.\n      *\n      * @param sendOptions A print parameter list that contains the\n      *  parameters for the send.  The following attributes MUST be set:\n      * <UL>\n      *   <LI> ATTR_RMTSYSTEM - Specifies the remote system to which the print\n      *                          request will be sent.  May be a remote system\n      *                          name or the special value *INTNETADR.\n      *   <LI> ATTR_RMTPRTQ - Specifies the name of the destination print queue.\n      * </UL>\n      * The following attributes are optional:\n      * <UL>\n      *   <LI> ATTR_DELETESPLF - Specifies whether or not to delete the spooled file\n      *                           after it has been successfully sent.  May be *NO\n      *                           or *YES.   *NO is the default.\n      *   <LI> ATTR_DESTOPTION - Specifies a destination-dependant option.  These options will\n      *                          be sent to the remote system with the spooled file.\n      *   <LI> ATTR_DESTINATION - Specifies the type of system to which the spooled file is\n      *                           being sent.  When sending to other IBM i systems, this value\n      *                           should be *AS/400.  May also be *OTHER or *PSF/2.\n      *                           *OTHER is the default.\n      *   <LI> ATTR_INTERNETADDR - Specifies the Internet address of the receiving system.\n      *   <LI> ATTR_MFGTYPE  - Specifies the manufacturer, type, and model when transforming print\n      *                        data from SCS or AFP to ASCII.\n      *   <LI> ATTR_SCS2ASCII - Specifies whether the print data is to be transformed to\n      *                         ASCII.  May be *NO or *YES.  *NO is the default.\n      *   <LI> ATTR_SEPPAGE - Specifies whether to print the separator page.  May be\n      *                        *NO or *YES.  *YES is the default.\n      * </UL>\n      *\n      * @exception AS400Exception If the system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      **/\n    public void sendTCP(PrintParameterList sendOptions)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).sendTCP(sendOptions);\n    }\n\n\n\n    /**\n     * Sets one or more attributes of the object.  See\n     * <a href=\"{@docRoot}/com/ibm/as400/access/doc-files/SpooledFileAttrs.html\">Spooled File Attributes</a> for\n     * a list of valid attributes that can be changed.\n     *\n     * @param attributes A print parameter list that contains the\n     *  attributes to be changed.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system operating system is not at the correct level.\n     **/\n    public void setAttributes(PrintParameterList attributes)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (attributes == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'attributes' is null.\");\n            throw new NullPointerException(\"attributes\");\n        }\n\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).setAttributes(attributes);\n\n        // we changed the spooled file attributes on the system,\n        // merge those changed attributes into our current attributes\n        // here.\n        if (attrs == null)\n        {\n            attrs = new NPCPAttribute();\n        }\n    \t// update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\t/**\n\tApplies the changes made by the user.\n\t\n\t@param outputPropertiesPane TODO\n\t * @throws Exception\n\t**/\n\t    public void applyChanges2 (OutputPropertiesPane outputPropertiesPane)\n\t      throws Exception\n\t    {\n\t        // create a print parameter list to hold the attributes that were updated\n\t        PrintParameterList pList_ = new PrintParameterList();\n\t\n\t        ////////////////\n\t        // user data ///\n\t        ////////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldUserData = getStringAttribute(PrintObject.ATTR_USERDATA).trim();\n\t\n\t        // get the new value from the textfield\n\t        String newUserData = (String)outputPropertiesPane.userData_.getText().trim();\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldUserData.equals(newUserData)) pList_.setParameter(PrintObject.ATTR_USERDATA,newUserData);\n\t\n\t        //////////////////////////\n\t        // save after printing ///\n\t        //////////////////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldSaveData = getStringAttribute(PrintObject.ATTR_SAVE);\n\t\n\t        // get the new value from the combo box\n\t        String newSaveData = (String)outputPropertiesPane.saveBox_.getSelectedItem();\n\t\n\t        // change new value if necessary\n\t        if (newSaveData.equals(OutputPropertiesPane.noText_)) newSaveData = \"*NO\";\n\t        else if (newSaveData.equals(OutputPropertiesPane.yesText_)) newSaveData = \"*YES\";\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldSaveData.equals(newSaveData)) pList_.setParameter(PrintObject.ATTR_SAVE,newSaveData);\n\t\n\t        if (outputPropertiesPane.functionSupported_ == true) // @A2A\n\t        {\n\t            //////////////\n\t            // printer ///\n\t            //////////////\n\t            // get the previous value from the spooled file\n\t            String oldPrinter = getStringAttribute(PrintObject.ATTR_PRINTER).trim();\n\t\n\t            // get the new value from the textfield\n\t            String newPrinter = (String)(outputPropertiesPane.printer_.getText().trim());\n\t\n\t            // compare the values to see if a change is needed, and set as necessary\n\t            if ((!newPrinter.equals(OutputPropertiesPane.notAssignedText_)) && (!oldPrinter.equals(newPrinter))) {\n\t                pList_.setParameter(PrintObject.ATTR_PRINTER,newPrinter);\n\t            }\n\t\n\t            ///////////////////\n\t            // output queue ///\n\t            ///////////////////\n\t\n\t            // extract the output queue path into an object that knows how to parse it.\n\t            QSYSObjectPathName outQPath = new QSYSObjectPathName(getStringAttribute(PrintObject.ATTR_OUTPUT_QUEUE));\n\t\n\t            // get the previous value from the spooled file\n\t            String oldOutQ = outQPath.getObjectName().trim();\n\t\n\t            // get the new value from the textfield\n\t            String newOutQ = (String)outputPropertiesPane.outQ_.getText().trim();\n\t\n\t            // flag to indicate a output queue change\n\t            boolean fNewOutQ = false;\n\t\n\t            // compare the values to see if a change is needed, and set as necessary\n\t            if (!oldOutQ.equals(newOutQ))\n\t                {\n\t                // create a QSYSObjectPathName object to represent the new output queue with the old outq library\n\t                QSYSObjectPathName newOutQPath = new QSYSObjectPathName(outQPath.getLibraryName(), newOutQ, \"OUTQ\");\n\t\n\t                // set the IFS output queue attribute\n\t                pList_.setParameter(PrintObject.ATTR_OUTPUT_QUEUE,newOutQPath.getPath());\n\t\n\t                // set the flag to say that we did have an output queuue change\n\t                fNewOutQ = true;\n\t                }\n\t\n\t            ///////////////////////////\n\t            // output queue library ///\n\t            ///////////////////////////\n\t\n\t            // get the previous value from the spooled file\n\t            String oldOutQLib = outQPath.getLibraryName().trim();\n\t\n\t            // get the new value from the textfield\n\t            String newOutQLib = (String)outputPropertiesPane.outQLib_.getText().trim();\n\t\n\t            // compare the values to see if a change is needed, and set as necessary\n\t            if (!oldOutQLib.equals(newOutQLib))\n\t                {\n\t                QSYSObjectPathName newOutQPath;\n\t\n\t                // check to see if we had a output queue name change also\n\t                if (fNewOutQ)\n\t                    // create a QSYSObjectPathName object to represent the new output queue library and new output queue name\n\t                    newOutQPath = new QSYSObjectPathName(newOutQLib, newOutQ, \"OUTQ\");\n\t                else\n\t                    // create a QSYSObjectPathName object to represent the new output queue library and old output queue name\n\t                    newOutQPath = new QSYSObjectPathName(newOutQLib, oldOutQ, \"OUTQ\");\n\t\n\t                // set the IFS output queue attribute\n\t                pList_.setParameter(PrintObject.ATTR_OUTPUT_QUEUE,newOutQPath.getPath());\n\t                }\n\t        }\n\t\n\t        ////////////////////////////\n\t        // output queue priority ///\n\t        ////////////////////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldOutQPty = getStringAttribute(PrintObject.ATTR_OUTPTY);\n\t\n\t        // get the new value from the combo box\n\t        String newOutQPty = (String)outputPropertiesPane.outQPtyBox_.getSelectedItem();\n\t\n\t        // check to see if user selected Job Value if so set priority to *JOB\n\t        if (newOutQPty.equals(OutputPropertiesPane.jobValueText_)) newOutQPty = \"*JOB\";\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldOutQPty.equals(newOutQPty)) pList_.setParameter(PrintObject.ATTR_OUTPTY,newOutQPty);\n\t\n\t        ///////////////////\n\t        // Total copies ///\n\t        ///////////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldTotalCopies = getIntegerAttribute(PrintObject.ATTR_COPIES).toString();\n\t\n\t        // get the new value from the textfield\n\t        String newTotalCopies = (String)outputPropertiesPane.totalCopies_.getText().trim();\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldTotalCopies.equals(newTotalCopies))\n\t            pList_.setParameter(PrintObject.ATTR_COPIES,Integer.parseInt(newTotalCopies));\n\t\n\t        //////////////////\n\t        // Copies left ///\n\t        //////////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldCopiesLeft = getIntegerAttribute(PrintObject.ATTR_COPIESLEFT).toString();\n\t\n\t        // get the new value from the textfield\n\t        String newCopiesLeft = (String)outputPropertiesPane.copiesLeft_.getText().trim();\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldCopiesLeft.equals(newCopiesLeft))\n\t            pList_.setParameter(PrintObject.ATTR_COPIESLEFT,Integer.parseInt(newCopiesLeft));\n\t\n\t        ///////////////\n\t        // Form type //\n\t        ///////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldFormType = getStringAttribute(PrintObject.ATTR_FORMTYPE).trim();\n\t\n\t        // get the new value from the textfield\n\t        String newFormType = (String)outputPropertiesPane.formType_.getText().trim();\n\t        if (newFormType.equals(OutputPropertiesPane.standardText_)) newFormType = \"*STD\";\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldFormType.equals(newFormType)) pList_.setParameter(PrintObject.ATTR_FORMTYPE,newFormType);\n\t\n\t\n\t        // fire started working event\n\t        outputPropertiesPane.workingEventSupport_.fireStartWorking();\n\t\n\t        //////////////////////////////////////////////////////\n\t        // Set the requested attributes of the spooled file //\n\t        //////////////////////////////////////////////////////\n\t        setAttributes(pList_);\n\t\n\t        // fire stopped working event\n\t        outputPropertiesPane.workingEventSupport_.fireStopWorking();\n\t\n\t        // notify object that there have been changes\n\t        outputPropertiesPane.objectEventSupport_.fireObjectChanged(outputPropertiesPane.object_);\n\t     }\n\n} // SpooledFile class",
                "methodCount": 33
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 3,
                "candidates": [
                    {
                        "lineStart": 1137,
                        "lineEnd": 1324,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method applyChanges2 to class OutputPropertiesPane",
                        "description": "Move method applyChanges2 to com.ibm.as400.vaccess.OutputPropertiesPane\nRationale: The method applyChanges2() is responsible for applying user changes to various properties related to printing, such as user data, printer settings, output queue, and more. Since OutputPropertiesPane is designed to represent the property pane for the VOutput object, it is logical for this method to reside within it. The method interacts directly with the UI components of OutputPropertiesPane, such as userData_, saveBox_, printer_, and others, which are essential for capturing user input. Moving this method to OutputPropertiesPane will enhance cohesion by keeping related functionality together, making the codebase easier to maintain and understand.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 884,
                        "lineEnd": 916,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method move to class OutputQueue",
                        "description": "Move method move to com.ibm.as400.access.OutputQueue\nRationale: The move() method is responsible for moving a spooled file to a specified output queue. This operation is inherently related to the OutputQueue class, which represents an output queue and provides methods to manipulate it. By moving the method to the OutputQueue class, we align the functionality of moving spooled files with the class that represents the target of that operation. This enhances cohesion, as the OutputQueue class will now encapsulate all operations related to output queues, including moving spooled files to them. Additionally, the method's parameters and exceptions are directly relevant to the OutputQueue's responsibilities, making it a more logical fit within that class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 315,
                        "lineEnd": 362,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method copy to class OutputQueue",
                        "description": "Move method copy to com.ibm.as400.access.OutputQueue\nRationale: The method 'copy(OutputQueue outputQueue)' is responsible for creating a copy of a spooled file and requires an output queue as a parameter. This indicates a strong relationship between the spooled file and the output queue, as the output queue is essential for the operation being performed. Moving this method to the OutputQueue class aligns with the principle of encapsulation, where methods that operate on a specific class's data should reside within that class. Additionally, the OutputQueue class already contains methods for manipulating output queues, making it a logical place for this functionality. By relocating the method, we enhance the cohesion of the OutputQueue class and ensure that all operations related to output queues are centralized, improving maintainability and readability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "applyChanges2",
                            "method_signature": "public void applyChanges2(OutputPropertiesPane outputPropertiesPane) throws Exception",
                            "target_class": "OutputPropertiesPane",
                            "rationale": "The applyChanges2 method is tightly coupled with the OutputPropertiesPane class, as it directly manipulates its properties. Moving this method to OutputPropertiesPane would enhance cohesion and encapsulation."
                        }
                    ],
                    "llm_response_time": 3898
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "applyChanges2",
                            "method_signature": "public void applyChanges2(OutputPropertiesPane outputPropertiesPane) throws Exception",
                            "target_class": "OutputPropertiesPane",
                            "rationale": "The method applyChanges2() is heavily dependent on the OutputPropertiesPane class for its functionality. It should be moved to that class to maintain cohesion and encapsulate related functionality."
                        }
                    ],
                    "llm_response_time": 3572
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "applyChanges2",
                            "method_signature": "public void applyChanges2(OutputPropertiesPane outputPropertiesPane) throws Exception",
                            "target_class": "OutputPropertiesPane",
                            "rationale": "The applyChanges2 method is heavily dependent on the OutputPropertiesPane class, making it more appropriate for it to reside within that class."
                        }
                    ],
                    "llm_response_time": 2772
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "answerMessage",
                            "method_signature": "public answerMessage(String reply)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "copy",
                            "method_signature": "public copy(OutputQueue outputQueue)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "hold",
                            "method_signature": "public hold(String holdType)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "move",
                            "method_signature": "public move(SpooledFile targetSpooledFile)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "move",
                            "method_signature": "public move(OutputQueue targetOutputQueue)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "moveToTop",
                            "method_signature": "public moveToTop()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "release",
                            "method_signature": "public release()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "applyChanges2",
                            "method_signature": "public applyChanges2(OutputPropertiesPane outputPropertiesPane)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "applyChanges2",
                            "method_signature": "public applyChanges2(OutputPropertiesPane outputPropertiesPane)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "release",
                            "method_signature": "public release()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "moveToTop",
                            "method_signature": "public moveToTop()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "move",
                            "method_signature": "public move(SpooledFile targetSpooledFile)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "answerMessage",
                            "method_signature": "public answerMessage(String reply)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "move",
                            "method_signature": "public move(OutputQueue targetOutputQueue)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "hold",
                            "method_signature": "public hold(String holdType)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "copy",
                            "method_signature": "public copy(OutputQueue outputQueue)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public applyChanges2(OutputPropertiesPane outputPropertiesPane)": {
                        "first": {
                            "method_name": "applyChanges2",
                            "method_signature": "public applyChanges2(OutputPropertiesPane outputPropertiesPane)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4924834451561407
                    },
                    "public release()": {
                        "first": {
                            "method_name": "release",
                            "method_signature": "public release()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.8643328556512382
                    },
                    "public moveToTop()": {
                        "first": {
                            "method_name": "moveToTop",
                            "method_signature": "public moveToTop()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.8856531121161748
                    },
                    "public move(SpooledFile targetSpooledFile)": {
                        "first": {
                            "method_name": "move",
                            "method_signature": "public move(SpooledFile targetSpooledFile)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.9050146708417703
                    },
                    "public answerMessage(String reply)": {
                        "first": {
                            "method_name": "answerMessage",
                            "method_signature": "public answerMessage(String reply)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.9139384949676729
                    },
                    "public move(OutputQueue targetOutputQueue)": {
                        "first": {
                            "method_name": "move",
                            "method_signature": "public move(OutputQueue targetOutputQueue)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.9169206092589556
                    },
                    "public hold(String holdType)": {
                        "first": {
                            "method_name": "hold",
                            "method_signature": "public hold(String holdType)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.9248090877931813
                    },
                    "public copy(OutputQueue outputQueue)": {
                        "first": {
                            "method_name": "copy",
                            "method_signature": "public copy(OutputQueue outputQueue)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.926064624724139
                    }
                },
                "voyage": {
                    "public applyChanges2(OutputPropertiesPane outputPropertiesPane)": {
                        "first": {
                            "method_name": "applyChanges2",
                            "method_signature": "public applyChanges2(OutputPropertiesPane outputPropertiesPane)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5224326683820841
                    },
                    "public answerMessage(String reply)": {
                        "first": {
                            "method_name": "answerMessage",
                            "method_signature": "public answerMessage(String reply)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5627298809369363
                    },
                    "public hold(String holdType)": {
                        "first": {
                            "method_name": "hold",
                            "method_signature": "public hold(String holdType)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5939109169466894
                    },
                    "public release()": {
                        "first": {
                            "method_name": "release",
                            "method_signature": "public release()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.60445468259323
                    },
                    "public moveToTop()": {
                        "first": {
                            "method_name": "moveToTop",
                            "method_signature": "public moveToTop()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6400383881763406
                    },
                    "public move(OutputQueue targetOutputQueue)": {
                        "first": {
                            "method_name": "move",
                            "method_signature": "public move(OutputQueue targetOutputQueue)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6412953509349767
                    },
                    "public move(SpooledFile targetSpooledFile)": {
                        "first": {
                            "method_name": "move",
                            "method_signature": "public move(SpooledFile targetSpooledFile)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6606464096161855
                    },
                    "public copy(OutputQueue outputQueue)": {
                        "first": {
                            "method_name": "copy",
                            "method_signature": "public copy(OutputQueue outputQueue)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6693564373633679
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public move(SpooledFile targetSpooledFile)",
                        "public move(OutputQueue targetOutputQueue)",
                        "public moveToTop()",
                        "public applyChanges2(OutputPropertiesPane outputPropertiesPane)",
                        "public release()",
                        "public hold(String holdType)",
                        "public answerMessage(String reply)",
                        "public copy(OutputQueue outputQueue)"
                    ],
                    "llm_response_time": 3064
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public move(SpooledFile targetSpooledFile)",
                        "public moveToTop()",
                        "public release()",
                        "public answerMessage(String reply)",
                        "public applyChanges2(OutputPropertiesPane outputPropertiesPane)"
                    ],
                    "llm_response_time": 3740
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public applyChanges2(OutputPropertiesPane outputPropertiesPane)",
                        "public moveToTop()",
                        "public release()"
                    ],
                    "llm_response_time": 1901
                },
                "voyage": {
                    "priority_method_names": [
                        "public move(SpooledFile targetSpooledFile)",
                        "public move(OutputQueue targetOutputQueue)",
                        "public moveToTop()",
                        "public copy(OutputQueue outputQueue)",
                        "public applyChanges2(OutputPropertiesPane outputPropertiesPane)",
                        "public answerMessage(String reply)",
                        "public hold(String holdType)",
                        "public release()"
                    ],
                    "llm_response_time": 2172
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public moveToTop()",
                        "public hold(String holdType)",
                        "public release()",
                        "public answerMessage(String reply)",
                        "public applyChanges2(OutputPropertiesPane outputPropertiesPane)"
                    ],
                    "llm_response_time": 1637
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public applyChanges2(OutputPropertiesPane outputPropertiesPane)",
                        "public hold(String holdType)",
                        "public answerMessage(String reply)"
                    ],
                    "llm_response_time": 1457
                }
            },
            "targetClassMap": {
                "applyChanges2": {
                    "target_classes": [
                        {
                            "class_name": "OutputPropertiesPane",
                            "similarity_score": 0.5562371558833118
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OutputPropertiesPane"
                    ],
                    "llm_response_time": 3892,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "release": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4541,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "moveToTop": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4981,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "move": {
                    "target_classes": [
                        {
                            "class_name": "OutputQueue",
                            "similarity_score": 0.8458377923126509
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OutputQueue"
                    ],
                    "llm_response_time": 3381,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "answerMessage": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3996,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "hold": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4560,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "copy": {
                    "target_classes": [
                        {
                            "class_name": "OutputQueue",
                            "similarity_score": 0.8580992483161837
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OutputQueue"
                    ],
                    "llm_response_time": 3862,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.access.AS400JDBCDataSource::applyChanges():boolean need move com.ibm.as400.vaccess.AS400JDBCDataSourcePane",
        "class_name": "com.ibm.as400.access.AS400JDBCDataSource",
        "telemetry": {
            "id": "9f343476-4f82-49b5-bffd-c1dc1d1645ec",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 5250,
                "lineStart": 46,
                "lineEnd": 5295,
                "bodyLineStart": 46,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/large/big/jtopen-7.8/src/com/ibm/as400/access/AS400JDBCDataSource.java",
                "sourceCode": "/**\n*  The AS400JDBCDataSource class represents a factory for IBM i database connections.\n*\n*  <P>The following is an example that creates an AS400JDBCDataSource object and creates a\n*  connection to the database.\n*\n*  <pre><blockquote>\n*  // Create a data source for making the connection.\n*  AS400JDBCDataSource datasource = new AS400JDBCDataSource(\"myAS400\");\n*  datasource.setUser(\"myUser\");\n*  datasource.setPassword(\"MYPWD\");\n\n*  // Create a database connection to the system.\n*  Connection connection = datasource.getConnection();\n*  </blockquote></pre>\n*\n*  <P>The following example registers an AS400JDBCDataSource object with JNDI and then\n*  uses the object returned from JNDI to obtain a database connection.\n*  <pre><blockquote>\n*  // Create a data source to the IBM i database.\n*  AS400JDBCDataSource dataSource = new AS400JDBCDataSource();\n*  dataSource.setServerName(\"myAS400\");\n*\n*  // Register the datasource with the Java Naming and Directory Interface (JNDI).\n*  Hashtable env = new Hashtable();\n*  env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.fscontext.RefFSContextFactory\");\n*  Context context = new InitialContext(env);\n*  context.bind(\"jdbc/customer\", dataSource);\n*\n*  // Return an AS400JDBCDataSource object from JNDI and get a connection.\n*  AS400JDBCDataSource datasource = (AS400JDBCDataSource) context.lookup(\"jdbc/customer\");\n*  Connection connection = datasource.getConnection(\"myUser\", \"MYPWD\");\n*  </pre></blockquote>\n**/\npublic class AS400JDBCDataSource \n/* ifdef JDBC40 */\nextends ToolboxWrapper\n/* endif */ \n\nimplements DataSource, Referenceable, Serializable, Cloneable //@PDC 550\n{\n    static final long serialVersionUID = 4L;\n\n\n\n    /**\n    *  Implementation notes:\n    *  The properties listed in com.ibm.as400.access.JDProperties should also be included here.\n    **/\n\n    // Constants\n    private static final String DATABASE_NAME = \"databaseName\";\n    private static final String DATASOURCE_NAME = \"dataSourceName\";\n    private static final String DESCRIPTION = \"description\";\n    private static final String SERVER_NAME = \"serverName\";\n    private static final String USER = \"userName\";\n    private static final String KEY_RING_NAME = \"keyring\";       // @F0A\n    private static final String PASSWORD = \"pw\";                 // @F0A\n    private static final String KEY_RING_PASSWORD = \"keyringpw\"; // @F0A\n    private static final String SECURE = \"secure\";               // @F0A\n    private static final String SAVE_PASSWORD = \"savepw\";        // @F0A\n    private static final String PLAIN_TEXT_PASSWORD = \"pwd\";     //@K1A\n    private static final String TRUE_ = \"true\";\n    private static final String FALSE_ = \"false\";\n    private static final String TOOLBOX_DRIVER = \"jdbc:as400:\";\n    private static final int MAX_THRESHOLD = 16777216;                  // Maximum threshold (bytes). @A3C, @A4A\n    static final int MAX_SCALE = 63;                            // Maximum decimal scale\n\n    // socket options to store away in JNDI\n    private static final String SOCKET_KEEP_ALIVE = \"soKeepAlive\"; // @F1A\n    private static final String SOCKET_RECEIVE_BUFFER_SIZE = \"soReceiveBufferSize\"; // @F1A\n    private static final String SOCKET_SEND_BUFFER_SIZE = \"soSendBufferSize\"; // @F1A\n    private static final String SOCKET_LINGER = \"soLinger\"; // @F1A\n    private static final String SOCKET_TIMEOUT = \"soTimeout\"; // @F1A\n    private static final String SOCKET_LOGIN_TIMEOUT = \"loginTimeout\"; // @st3\n    private static final String SOCKET_TCP_NO_DELAY = \"soTCPNoDelay\"; // @F1A\n\n    // Data source properties.\n    transient private AS400 as400_;                           // AS400 object used to store and encrypt the password.\n    // @J2d private String databaseName_ = \"\";                // Database name. @A6C\n    private String dataSourceName_ = \"\";                      // Data source name. @A6C\n    private String description_ = \"\";                         // Data source description. @A6C\n    private JDProperties properties_;                         // IBM i connection properties.\n    private SocketProperties sockProps_;                      // IBM i socket properties @F1A\n    transient private PrintWriter writer_;                    // The EventLog print writer.  @C7c\n    transient private EventLog log_;       //@C7c\n\n    private String serialServerName_;                         // system name used in serialization.\n    private String serialUserName_;                           // User used in serialization.\n    private String serialKeyRingName_;     //@B4A             // Key ring name used in serialization.\n    transient PropertyChangeSupport changes_; //@B0C\n    private boolean isSecure_ = false;  //@B4A\n\n    // Handles loading the appropriate resource bundle\n    // private static ResourceBundleLoader loader_;      //@A9A\n\n\n    // In mod 5 support was added to optionally serialize the password with the\n    // rest of the properties.  By default this is off.  setSavePasswordWhenSerialized(true)\n    // must be called to save the password.  By calling this the application takes\n    // responsibility for protecting the serialized bytes.  The password is not saved in the \n    // clear.  The password string is confused so that something more than just looking at the \n    // serialized bytes must be done to see the password.  \n    private char[]  serialPWBytes_ = null;               //@J3a\n    private char[]  serialKeyRingPWBytes_ = null;        //@J3a\n    private boolean savePasswordWhenSerialized_ = false; //@J3a   by default, don't save password!!!!\n\n    /**\n     * The maximum storage space in megabytes, that can be used to execute a query.\n    **/\n    public static final int MAX_STORAGE_LIMIT = 2147352578;                    // Maximum query storage limit @550\n\n\n    /**\n      Start tracing the JDBC client.  This is the same as setting\n      property \"trace=true\";  Note the constant is not public.\n      It is defined only to be compatible with ODBC\n      The numeric value of this constant is 1.\n     **/\n    static final int TRACE_CLIENT = 1;                // @j1a\n\n    /**\n      Start the database monitor on the JDBC server job.\n      This constant is used when setting the level of tracing for the JDBC server job.\n      The numeric value of this constant is 2.\n     **/\n    public static final int SERVER_TRACE_START_DATABASE_MONITOR = 2;           // @j1a\n\n    /**\n      Start debug on the JDBC server job.\n      This constant is used when setting the level of tracing for the JDBC server job.\n      The numeric value of this constant is 4.\n     **/\n    public static final int SERVER_TRACE_DEBUG_SERVER_JOB = 4;           // @j1a\n\n    /**\n      Save the joblog when the JDBC server job ends.\n      This constant is used when setting the level of tracing for the JDBC server job.\n      The numeric value of this constant is 8.\n     **/\n    public static final int SERVER_TRACE_SAVE_SERVER_JOBLOG = 8;           // @j1a\n\n    /**\n      Start job trace on the JDBC server job.\n      This constant is used when setting the level of tracing for the JDBC server job.\n      The numeric value of this constant is 16.\n     **/\n    public static final int SERVER_TRACE_TRACE_SERVER_JOB = 16;           // @j1a\n\n    /**\n      Save SQL information.\n      This constant is used when setting the level of tracing for the JDBC server job.\n      The numeric value of this constant is 32.\n     **/\n    public static final int SERVER_TRACE_SAVE_SQL_INFORMATION = 32;           // @j1a\n\n\n    //@cc1\n    /**\n     * CONCURRENTACCESS_NOT_SET - Indicates that currently committed behavior is not \n     * requested explicitly by the client.     \n     */\n    public final static int CONCURRENTACCESS_NOT_SET = 0;\n    //@cc1\n    /**\n     * CONCURRENTACCESS_USE_CURRENTLY_COMMITTED - Indicates that the currently committed \n     * behavior is requested at the server.\n     */\n    public final static int CONCURRENTACCESS_USE_CURRENTLY_COMMITTED = 1;\n    //@cc1\n    /**\n     * CONCURRENTACCESS_WAIT_FOR_OUTCOME - Indicates that the readers will \n     * wait on the writers during lock contention.      \n     */\n    public final static int CONCURRENTACCESS_WAIT_FOR_OUTCOME = 2;\n    //@cc1\n    /**\n     * CONCURRENTACCESS_SKIP_LOCKS - Indicates that the readers will \n     * skip locks.      \n     */\n    public final static int CONCURRENTACCESS_SKIP_LOCKS = 3;\n\n    \n    /**\n    *  Constructs a default AS400JDBCDataSource object.\n    **/\n    public AS400JDBCDataSource()\n    {\n        initializeTransient();\n        properties_ = new JDProperties(null, null);\n        sockProps_ = new SocketProperties();\n    }\n\n    /**\n    *  Constructs an AS400JDBCDataSource object to the specified <i>serverName</i>.\n    *  @param serverName The name of the IBM i system.\n    **/\n    public AS400JDBCDataSource(String serverName)\n    {\n        this();\n\n        setServerName(serverName);\n    }\n\n    /**\n    *  Constructs an AS400JDBCDataSource object with the specified signon information.\n    *  @param serverName The name of the IBM i system.\n    *  @param user The user id.\n    *  @param password The user password.\n    **/\n    public AS400JDBCDataSource(String serverName, String user, String password)\n    {\n        this();\n\n        setServerName(serverName);\n        setUser(user);\n        setPassword(password);\n    }\n\n    //@K1A\n    /**\n    * Constructs an AS400JDBCDataSource object with the specified AS400 object\n    * @param as400 The AS400 object\n    **/\n    public AS400JDBCDataSource(AS400 as400)\n    {\n        this();\n\n        as400_ = as400;\n        if( as400 instanceof SecureAS400 )\n            setSecure(true);\n\n    }\n\n    //@B4A\n    /**\n    *  Constructs an AS400JDBCDataSource object with the specified signon information\n    *  to use for SSL communications with the system.\n    *  @param serverName The name of the IBM i system.\n    *  @param user The user id.\n    *  @param password The user password.\n       *  @param keyRingName The key ring class name to be used for SSL communications with the system.\n       *  @param keyRingPassword The password for the key ring class to be used for SSL communications with the system.\n    **/\n    public AS400JDBCDataSource(String serverName, String user, String password,\n                               String keyRingName, String keyRingPassword)\n    {\n        this();\n\n        setSecure(true);  // @F0M\n\n        try\n        {\n            as400_ = new SecureAS400(as400_);\n            ((SecureAS400)as400_).setKeyRingName(keyRingName, keyRingPassword);\n        }\n        catch (PropertyVetoException pe)\n        { /* will never happen */\n        }\n        serialKeyRingName_ = keyRingName;\n\n        // @J3 There is no get/set keyring name / password methods so they really aren't bean\n        // properties, but in v5r1 the keyring name is saved as if it is a property.  Since\n        // the code saved the name we will also save the password. \n        serialKeyRingPWBytes_ = xpwConfuse(keyRingPassword);     //@J3a  // @F0M  (changed from keyRingName to keyRingPassword)\n\n        setServerName(serverName);\n        setUser(user);\n        setPassword(password);\n    }\n\n    // @F0A - Added the following constructor to avoid creating some extra objects\n    /**\n    * Constructs an AS400JDBCDataSource object from the specified Reference object\n    * @param reference to retrieve the DataSource properties from\n    **/\n    AS400JDBCDataSource(Reference reference) {\n        /*\n        *  Implementation note:  This method is called from AS400JDBCObjectFactory.getObjectInstance\n        */\n\n        // check to make sure our reference is not null\n        if (reference == null)\n            throw new NullPointerException(\"reference\");\n\n        // set up property change support\n        changes_ = new PropertyChangeSupport(this);\n\n        // set up the as400 object\n        if (((String)reference.get(SECURE).getContent()).equalsIgnoreCase(TRUE_)) {\n            isSecure_ = true;\n            as400_ = new SecureAS400();\n\n            // since the as400 object is secure, get the key ring info\n            serialKeyRingName_ = (String)reference.get(KEY_RING_NAME).getContent();\n            if (reference.get(KEY_RING_PASSWORD) != null)\n                serialKeyRingPWBytes_ = ((String)reference.get(KEY_RING_PASSWORD).getContent()).toCharArray();\n            else\n                serialKeyRingPWBytes_ = null;\n\n            try {\n                if (serialKeyRingPWBytes_ != null && serialKeyRingPWBytes_.length > 0)\n                    ((SecureAS400)as400_).setKeyRingName(serialKeyRingName_, xpwDeconfuse(serialKeyRingPWBytes_));\n                else\n                    ((SecureAS400)as400_).setKeyRingName(serialKeyRingName_);\n            } catch (PropertyVetoException pve) { /* Will never happen */ }\n\n        } else {\n            isSecure_ = false;\n            as400_ = new AS400();\n        }\n\n        // must initialize the JDProperties so the property change checks dont get a NullPointerException\n        properties_ = new JDProperties(null, null);\n\n        Properties properties = new Properties();\n        sockProps_ = new SocketProperties();\n\n        Enumeration list = reference.getAll();\n        while (list.hasMoreElements())\n        {\n            StringRefAddr refAddr = (StringRefAddr)list.nextElement();\n            String property = refAddr.getType();\n            String value = (String)reference.get(property).getContent();\n\n            // constant identifiers were used to store in JNDI\n            // all of these were handled already so do not put them in the properties\n            if (property.equals(DATABASE_NAME))                         \n                setDatabaseName(value);\n            else if (property.equals(DATASOURCE_NAME))\n                setDataSourceName(value);\n            else if (property.equals(DESCRIPTION))\n                setDescription(value);\n            else if (property.equals(SERVER_NAME))\n                setServerName(value);\n            else if (property.equals(USER))\n                setUser(value);\n            else if(property.equals(PLAIN_TEXT_PASSWORD)) {         //@K1A\n                //set the password                                  //@K1A\n                setPassword(value);                                 //@K1A\n            }\n            else if (property.equals(PASSWORD)) {\n                if(reference.get(PLAIN_TEXT_PASSWORD) != null)      //@K1A\n                {                                                   //@K1A\n                    setPassword((String)reference.get(PLAIN_TEXT_PASSWORD).getContent());       //@K1A\n                }                                                                               //@K1A\n                else                                                                            //@K1A\n                {                                                                               //@K1A\n                    // get the password back from the serialized char[]\n                    serialPWBytes_ = value.toCharArray();\n                    // decode the password and set it on the as400\n                    as400_.setPassword(xpwDeconfuse(serialPWBytes_));\n                }                                                                               //@K1A\n            }\n            else if (property.equals(SAVE_PASSWORD)) {\n                // set the savePasswordWhenSerialized_ flag\n                savePasswordWhenSerialized_ = value.equals(TRUE_) ? true : false;\n            } else if (property.equals(SECURE) || property.equals(KEY_RING_NAME) || property.equals(KEY_RING_PASSWORD)) {\n                // do nothing for these keys, they have already been handled\n            }\n            else if (property.equals(SOCKET_KEEP_ALIVE)) {\n                sockProps_.setKeepAlive((value.equals(TRUE_)? true : false));\n            }\n            else if (property.equals(SOCKET_RECEIVE_BUFFER_SIZE)) {\n                sockProps_.setReceiveBufferSize(Integer.parseInt(value));\n            }\n            else if (property.equals(SOCKET_SEND_BUFFER_SIZE)) {\n                sockProps_.setSendBufferSize(Integer.parseInt(value));\n            }\n            else if (property.equals(SOCKET_LINGER)) {\n                sockProps_.setSoLinger(Integer.parseInt(value));\n            }\n            else if (property.equals(SOCKET_TIMEOUT)) {\n                sockProps_.setSoTimeout(Integer.parseInt(value));\n            }\n            else if (property.equals(SOCKET_LOGIN_TIMEOUT)) {        //@st3\n                sockProps_.setLoginTimeout(Integer.parseInt(value)); //@st3\n            }\n            else if (property.equals(SOCKET_TCP_NO_DELAY)) {\n                sockProps_.setTcpNoDelay((value.equals(TRUE_)? true : false));\n            }\n            else\n            {\n                properties.put(property, value);\n            }\n        }\n        properties_ = new JDProperties(properties, null);\n\n        // get the prompt property and set it back in the as400 object\n        String prmpt = properties_.getString(JDProperties.PROMPT);\n        if (prmpt != null && prmpt.equalsIgnoreCase(FALSE_))\n            setPrompt(false);\n        else if (prmpt != null && prmpt.equalsIgnoreCase(TRUE_))\n            setPrompt(true);\n\n    }\n\n    /**\n    *  Adds a PropertyChangeListener.  The specified PropertyChangeListener's\n    *  <b>propertyChange</b> method is called each time the value of any bound\n    *  property is changed.\n    *  @see #removePropertyChangeListener\n    *  @param listener The PropertyChangeListener.\n    **/\n    public void addPropertyChangeListener(PropertyChangeListener listener)\n    {\n        if (listener == null)\n            throw new NullPointerException(\"listener\");\n        changes_.addPropertyChangeListener(listener);\n\n        as400_.addPropertyChangeListener(listener);\n    }\n\n    //@PDA 550 - clone\n    /**\n     * Method to create a clone of AS400JDBCDataSource. This does a shallow\n     * copy, with the exception of JDProperties, which also gets cloned.\n     */\n    public Object clone()\n    {\n        try\n        {\n            Trace.log(Trace.INFORMATION, \"AS400JDBCDataSource.close()\"); \n            AS400JDBCDataSource clone = (AS400JDBCDataSource) super.clone();\n            clone.properties_ = (JDProperties) this.properties_.clone();\n            return clone;\n        } catch (CloneNotSupportedException e)\n        { // This should never happen.\n            Trace.log(Trace.ERROR, e);\n            throw new UnsupportedOperationException(\"clone()\");\n        }\n    }\n    \n    /**\n    *  Returns the level of database access for the connection.\n    *  @return The access level.  Valid values include: \"all\" (all SQL statements allowed),\n    *  \"read call\" (SELECT and CALL statements allowed), and \"read only\" (SELECT statements only).\n    *  The default value is \"all\".\n    **/\n    public String getAccess()\n    {\n        return properties_.getString(JDProperties.ACCESS);\n    }\n     \n    // @C9 new method\n    /**\n    *  Returns what behaviors of the Toolbox JDBC driver have been overridden.\n    *  Multiple behaviors can be overridden in combination by adding \n    *  the constants and passing that sum on the setBehaviorOverride() method.  \n    *  @return The behaviors that have been overridden. \n    *  <p>The return value is a combination of the following:\n    *  <ul>\n    *  <li>1 - Do not throw an exception if Statement.executeQuery() or\n    *          PreparedStatement.executeQuery() do not return a result set.\n    *          Instead, return null for the result set.\n    *  </ul>\n    *\n    **/\n    public int getBehaviorOverride()\n    {\n        return properties_.getInt(JDProperties.BEHAVIOR_OVERRIDE);\n    }\n\n    //@B2A\n    /**\n    *  Returns the output string type of bidi data. See <a href=\"BidiStringType.html\">\n    *  BidiStringType</a> for more information and valid values.  -1 will be returned\n    *  if the value has not been set.\n    **/\n    public int getBidiStringType()                                                               //@B3C\n    {\n        String value = properties_.getString(JDProperties.BIDI_STRING_TYPE);     //@B3C\n        try\n        {                                                                                          //@B3A                                                                                            //@B3A\n            return Integer.parseInt (value);                                              //@B3A\n        }                                                                                            //@B3A\n        catch (NumberFormatException nfe)  // if value is \"\", that is, not set        //@B3A\n        {                                                                                            //@B3A\n            return -1;                                                                              //@B3A\n        }                                                                                            //@B3A\n    }\n\n\n    /**\n    *  Returns the criteria for retrieving data from the system in\n    *  blocks of records.  Specifying a non-zero value for this property\n    *  will reduce the frequency of communication to the system, and\n    *  therefore increase performance.\n    *  @return The block criteria.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> 0 (no record blocking)\n    *    <li> 1 (block if FOR FETCH ONLY is specified)\n    *    <li> 2 (block if FOR UPDATE is specified) - The default value.\n    *  </ul>\n    **/\n    public int getBlockCriteria()\n    {\n        return properties_.getInt(JDProperties.BLOCK_CRITERIA);\n    }\n\n    /**\n    *  Returns the block size in kilobytes to retrieve from the system and\n    *  cache on the client.  This property has no effect unless the block criteria\n    *  property is non-zero.  Larger block sizes reduce the frequency of\n    *  communication to the system, and therefore may increase performance.\n    *  @return The block size in kilobytes.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> 0\n    *    <li> 8\n    *    <li> 16\n    *    <li> 32   - The default value.\n    *    <li> 64\n    *    <li> 128\n    *    <li> 256\n    *    <li> 512\n    *  </ul>\n    **/\n    public int getBlockSize()\n    {\n        return properties_.getInt(JDProperties.BLOCK_SIZE);\n    }\n\n\n    /**\n    *  Returns the database connection.\n    *  @return The connection.\n    *  @exception SQLException If a database error occurs.\n    **/\n    public Connection getConnection() throws SQLException\n    {    \n        //if the object was created with a keyring, or if the user asks for the object\n        //to be secure, clone a SecureAS400 object; otherwise, clone an AS400 object\n        if (isSecure_ || isSecure())                     //@B4A  //@C2C\n            return getConnection(new SecureAS400(as400_));   //@B4A\n        else                               //@B4A\n            return getConnection(new AS400(as400_));\n    }\n\n\n    // @J3 Nothing to change here.  The password is serialized only when passed on the c'tor \n    //     or via the settors.  That is, \"bean properties\" are affected only when using the \n    //     c'tor specifying system, uid, and pwd, or the settors are used.  The bean properties\n    //     are not affected if this method is used, or if the default c'tor is used such\n    //     that our sign-on dialog is used to get system, uid and pwd from the user.  \n    /**\n    *  Returns the database connection using the specified <i>user</i> and <i>password</i>.\n    *  @param user The database user.\n    *  @param password The database password.\n    *  @return The connection\n    *  @exception SQLException If a database error occurs.\n    **/\n    public Connection getConnection(String user, String password) throws SQLException\n    {\n        // Validate the parameters.\n        //@pw3 Add way to get old behavior allowing \"\" (!but also need to allow new behavior of allowing null is/passwd so customers can slowly migrate)\n        String secureCurrentUser = SystemProperties.getProperty (SystemProperties.JDBC_SECURE_CURRENT_USER); //@pw3\n        boolean isSecureCurrentUser = true;                                                                  //@pw3\n        //if system property or jdbc property is set to false then secure current user code is not used\n        //null value for system property means not specified...so true by default\n        if(((secureCurrentUser != null) && (Boolean.valueOf(secureCurrentUser).booleanValue() == false)) || !isSecureCurrentUser())            //@pw3\n            isSecureCurrentUser = false;                                                                      //@pw3\n            \n        boolean forcePrompt = false;     //@prompt\n        \n        //check if \"\".  \n        if (\"\".equals(user))                                              //@pw1\n        {                                                                 //@pw1\n            if(isSecureCurrentUser)//@pw3\n            {  //@pw3\n                if (JDTrace.isTraceOn()) //jdbc category trace                //@pw1\n                    JDTrace.logInformation (this, \"Userid/password cannot be \\\"\\\" or *CURRENT due to security constraints.  Use null instead\");  //@pw1\n                //JDError.throwSQLException(JDError.EXC_CONNECTION_REJECTED);   //@pw1\n                forcePrompt = true;  //@prompt\n            }  //@pw3\n        }                                                                 //@pw1\n        if (\"\".equals(password))                                          //@pw1\n        {                                                                 //@pw1\n            if(isSecureCurrentUser)//@pw3\n            {  //@pw3\n                if (JDTrace.isTraceOn()) //jdbc category trace                //@pw1\n                    JDTrace.logInformation (this, \"Userid/password cannot be \\\"\\\" or *CURRENT due to security constraints.  Use null instead\");  //@pw1\n                //JDError.throwSQLException(JDError.EXC_CONNECTION_REJECTED);   //@pw1\n                forcePrompt = true;  //@prompt\n            }  //@pw3\n        }                                                                 //@pw1\n        \n        //Next, hack for nulls to work on IBM i\n        //New security: replace null with \"\" to mimic old behavior to allow null logons...disallowing \"\" above.\n        if (user == null)                                                         //@pw1\n            user = \"\";                                                            //@pw1\n        if (password == null)                                                     //@pw1\n            password = \"\";                                                        //@pw1\n        \n        //check for *current\n        if (user.compareToIgnoreCase(\"*CURRENT\") == 0)                    //@pw1\n        {                                                                 //@pw1\n            if(isSecureCurrentUser)//@pw3\n            {  //@pw3\n                if (JDTrace.isTraceOn()) //jdbc category trace                //@pw1\n                    JDTrace.logInformation (this, \"Userid/password cannot be \\\"\\\" or *CURRENT due to security constraints.  Use null instead\");  //@pw1\n                //JDError.throwSQLException(JDError.EXC_CONNECTION_REJECTED);   //@pw1\n                forcePrompt = true;  //@prompt\n            }  //@pw3\n            \n        }                                                                 //@pw1\n        if (password.compareToIgnoreCase(\"*CURRENT\") == 0)                //@pw1\n        {                                                                 //@pw1\n            if(isSecureCurrentUser)//@pw3\n            {  //@pw3\n                if (JDTrace.isTraceOn()) //jdbc category trace                //@pw1\n                    JDTrace.logInformation (this, \"Userid/password cannot be \\\"\\\" or *CURRENT due to security constraints.  Use null instead\");  //@pw1\n                //JDError.throwSQLException(JDError.EXC_CONNECTION_REJECTED);   //@pw1\n                forcePrompt = true;  //@prompt\n            }  //@pw3\n        }                                                                 //@pw1\n\n        AS400 as400Object;\n\n        //if the object was created with a keyring, or if the user asks for the object\n        //to be secure, clone a SecureAS400 object; otherwise, clone an AS400 object\n        if (isSecure_ || isSecure())                                        //@C2A\n        {                                                                   //@C2A\n            as400Object = new SecureAS400(getServerName(), user, password); //@C2A\n        }                                                                   //@C2A\n        else\n        {                                                                //@C2A                                                                   //@C2A     \n            as400Object = new AS400(getServerName(), user, password);       //@C2A\n        }                                                                   //@C2A\n\n        try                                                                 //@PDA\n        {                                                                   //@PDA\n            if(!as400_.isThreadUsed())                                      //@PDA\n                as400Object.setThreadUsed(false);  //true by default        //@PDA\n        } catch (PropertyVetoException pve)                                 //@PDA\n        { /*ignore*/                                                        //@PDA\n        }                                                                   //@PDA\n        \n        //set gui available on the new object to false if user turned prompting off\n        try\n        {                                                                   //@C2A                                \n            if (!isPrompt())                                                //@C2A\n                as400Object.setGuiAvailable(false);                         //@C2A\n        }                                                                   //@C2A\n        catch (PropertyVetoException pve)                                   //@C2A\n        { /*ignore*/                                                        //@C2A\n        }                                                                   //@C2A\n        \n        if(forcePrompt)                  //@prompt\n            as400Object.forcePrompt();   //@prompt\n        \n        return getConnection(as400Object);                                  //@C2A\n\n        //@C2D return getConnection(new AS400(getServerName(), user, password));\n    }\n\n\n    /**\n    *  Creates the database connection based on the signon and property information.\n    *  @param as400 The AS400 object used to make the connection.\n    *  @exception SQLException If a database error occurs.\n    **/\n    private Connection getConnection(AS400 as400) throws SQLException\n    {\n        // Set the socket properties, if there are any, on the AS400 object before making a connection.\n        if(sockProps_ != null){\n            as400.setSocketProperties(sockProps_);\n        }else\n        {\n            if(JDTrace.isTraceOn())\n                JDTrace.logInformation(this, \"sockProps_:  null\");\n        }\n\n        AS400JDBCConnection connection = null;\n\n        connection = new AS400JDBCConnection();    \n\n        connection.setSystem(as400);\n        connection.setProperties(new JDDataSourceURL(TOOLBOX_DRIVER + \"//\" + as400.getSystemName()), properties_, as400); //@C1C\n\n        log(ResourceBundleLoader.getText(\"AS400_JDBC_DS_CONN_CREATED\"));     //@A9C\n        return connection;\n    }\n    \n    //@cc1\n    /**\n     * This method returns the concurrent access resolution setting.\n     * This method has no effect on IBM i V6R1 or earlier.\n     * The possible values for this property are {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_NOT_SET}, \n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_USE_CURRENTLY_COMMITTED}, \n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_WAIT_FOR_OUTCOME} and\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_SKIP_LOCKS}, \n     * with the property defaulting to {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_NOT_SET}.  \n     * Setting this property to default exhibits the default behavior on the servers  \n     * i.e., the semantic applied for read \n     * transactions to avoid locks will be determined by the server.          \n     *\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_USE_CURRENTLY_COMMITTED} specifies that driver will flow USE CURRENTLY COMMITTED \n     * to server.  Whether CURRENTLY COMMITTED will actually be in effect is\n     * ultimately determined by server. \n     *\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_WAIT_FOR_OUTCOME} specifies that driver will flow WAIT FOR OUTCOME\n     * to server.  This will disable the CURRENTLY COMMITTED behavior at the server,\n     * if enabled, and the server will wait for the commit or rollback of data in the process of\n     * being updated.  \n     * \n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_SKIP_LOCKS} specifies that driver will flow SKIP LOCKS\n     * to server.  This directs the database manager to skip records in the case of record lock conflicts. \n     *   \n     * @return  The concurrent access resolution setting.    Possible return valuse:\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_NOT_SET}, \n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_USE_CURRENTLY_COMMITTED},\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_WAIT_FOR_OUTCOME}, or\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_SKIP_LOCKS}\n     */\n    public int getConcurrentAccessResolution ()\n    {\n        return properties_.getInt(JDProperties.CONCURRENT_ACCESS_RESOLUTION);\n    }\n\n    //@C8A\n    /**\n    *  Returns the value of the cursor sensitivity property.  If the resultSetType is \n    *  ResultSet.TYPE_FORWARD_ONLY or ResultSet.TYPE_SCROLL_SENSITIVE, the value of this property\n    *  will control what cursor sensitivity is requested from the database.  If the resultSetType\n    *  is ResultSet.TYPE_SCROLL_INSENSITIVE, this property will be ignored.\n    *  @return The cursor sensitivity.  \n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \"asensitive\"\n    *    <li> \"insensitive\"\n    *    <li> \"sensitive\"\n    *  </ul>\n    *  The default is \"asensitive\".\n    *\n    *  This property is ignored when connecting to systems\n    *  running OS/400 V5R1 and earlier.   \n    **/\n    public String getCursorSensitivity()\n    {\n        return properties_.getString(JDProperties.CURSOR_SENSITIVITY);      \n    }\n\n\n    /**\n    *  Returns the database name property.  For more information see\n    *  the documentation for the setDatabaseName() method in this class.\n    *  @return The database name.\n    **/\n    public String getDatabaseName()\n    {\n        // @J2d return databaseName_;\n        return properties_.getString(JDProperties.DATABASE_NAME);      // @J2a\n    }\n\n    /**\n    *  Returns the data source name property.\n    *  This property is used to name an underlying data source when connection pooling is used.\n    *  @return The data source name.\n    **/\n    public String getDataSourceName()\n    {\n        return dataSourceName_;\n    }\n\n    /**\n    *  Returns the IBM i date format used in date literals within SQL statements.\n    *  @return The date format.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \"mdy\"\n    *    <li> \"dmy\"\n    *    <li> \"ymd\"\n    *    <li> \"usa\"\n    *    <li> \"iso\"\n    *    <li> \"eur\"\n    *    <li> \"jis\"\n    *    <li> \"julian\"\n    *    <li> \"\"  (server job value) - default.\n    *  </ul>\n    *  The default is based on the server job.\n    **/\n    public String getDateFormat()\n    {\n        return properties_.getString(JDProperties.DATE_FORMAT);\n    }\n\n    /**\n    *  Returns the IBM i date separator used in date literals within SQL statements.\n    *  This property has no effect unless the \"data format\" property is set to:\n    *  \"julian\", \"mdy\", \"dmy\", or \"ymd\".\n    *  @return The date separator.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \"/\" (slash)\n    *    <li> \"-\" (dash)\n    *    <li> \".\" (period)\n    *    <li> \",\" (comma)\n    *    <li> \" \" (space)\n    *    <li> \"\"  (server job value) - default.\n    *  </ul>\n    *  The default value is based on the server job.\n    **/\n    public String getDateSeparator()\n    {\n        return properties_.getString(JDProperties.DATE_SEPARATOR);\n    }\n\n    //@DFA\n    /**\n    *  Returns the decfloat rounding mode.\n    *  @return The decfloat rounding mode.\n    *   <p>Valid values include:\n    *   <ul>\n    *   <li>\"half even\" - default\n    *   <li>\"half up\" \n    *   <li>\"down\" \n    *   <li>\"ceiling\" \n    *   <li>\"floor\" \n    *   <li>\"half down\" \n    *   <li>\"up\" \n    *   </ul>\n    **/\n    public String getDecfloatRoundingMode()\n    {\n        return properties_.getString(JDProperties.DECFLOAT_ROUNDING_MODE);\n    }\n     \n    /**\n    *  Returns the IBM i decimal separator used in numeric literals within SQL statements.\n    *  @return The decimal separator.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \".\" (period)\n    *    <li> \",\" (comma)\n    *    <li> \"\"  (server job value) - default.\n    *  </ul>\n    *  The default value is based on the server job.\n    **/\n    public String getDecimalSeparator()\n    {\n        return properties_.getString(JDProperties.DECIMAL_SEPARATOR);\n    }\n\n    //@igwrn\n    /**\n    *  Returns the ignore warnings property.\n    *  Specifies a list of SQL states for which the driver should not create warning objects.\n    *  @return The ignore warnings.\n    **/\n    public String getIgnoreWarnings()\n    {\n        return properties_.getString(JDProperties.IGNORE_WARNINGS);\n    }\n    \n    \n    /**\n    *  Returns the description of the data source.\n    *  @return The description.\n    **/\n    public String getDescription()\n    {\n        return description_;\n    }\n\n    // @A2A\n    /**\n    * Returns the JDBC driver implementation.\n    * This property has no\n    * effect if the \"secondary URL\" property is set.\n    * This property cannot be set to \"native\" if the\n    * environment is not an IBM i Java Virtual Machine.\n    *  <p>Valid values include:\n    *  <ul>\n    *  <li>\"toolbox\" (use the IBM Toolbox for Java JDBC driver)\n    *  <li>\"native\" (use the IBM Developer Kit for Java JDBC driver)\n    *  </ul>\n    *  The default value is \"toolbox\".\n    *  Note:  Not supported in a connection pool.\n    **/\n    public String getDriver()\n    {\n        return properties_.getString(JDProperties.DRIVER);\n    }\n\n    /**\n    *  Returns the amount of detail for error messages originating from\n    *  the IBM i system.\n    *  @return The error message level.\n    *  Valid values include: \"basic\" and \"full\".  The default value is \"basic\".\n    **/\n    public String getErrors()\n    {\n        return properties_.getString(JDProperties.ERRORS);\n    }\n\n    /**\n    *  Returns the IBM i system libraries to add to the server job's library list.\n    *  The libraries are delimited by commas or spaces, and\n    *  \"*LIBL\" may be used as a place holder for the server job's\n    *  current library list.  The library list is used for resolving\n    *  unqualified stored procedure calls and finding schemas in\n    *  DatabaseMetaData catalog methods.  If \"*LIBL\" is not specified,\n    *  the specified libraries will replace the server job's current library list.\n    *  @return The library list.\n    **/\n    public String getLibraries()\n    {\n        return properties_.getString(JDProperties.LIBRARIES);\n    }\n\n    /**\n    *  Returns the maximum LOB (large object) size in bytes that\n    *  can be retrieved as part of a result set.  LOBs that are larger\n    *  than this threshold will be retrieved in pieces using extra\n    *  communication to the system.  Larger LOB thresholds will reduce\n    *  the frequency of communication to the system, but will download\n    *  more LOB data, even if it is not used.  Smaller LOB thresholds may\n    *  increase frequency of communication to the system, but will only\n    *  download LOB data as it is needed.\n    *  @return The lob threshold.  Valid range is 0-16777216.\n    *  The default value is 32768.\n    **/\n    public int getLobThreshold()\n    {\n        return properties_.getInt(JDProperties.LOB_THRESHOLD);\n    }\n\n    /**\n    *  Returns the timeout value in seconds.\n    *  Note: This value is not used or supported.\n    *  The timeout value is determined by the IBM i system.\n    *  @return the maximum time in seconds that this data source can wait while attempting to connect to a database. \n    **/\n    public int getLoginTimeout()\n    {\n        return properties_.getInt(JDProperties.LOGIN_TIMEOUT);\n    }\n\n    /**\n    *  Returns the log writer for this data source.\n    *  @return The log writer for this data source.\n    *  @exception SQLException If a database error occurs.\n    **/\n    public PrintWriter getLogWriter() throws SQLException\n    {\n        return writer_;\n    }\n\n    //@PDA\n    /**                                                               \n    *  Indicates how to retrieve DatabaseMetaData.\n    *  If set to 0, database metadata will be retrieved through the ROI data flow.  \n    *  If set to 1, database metadata will be retrieved by calling system stored procedures. \n    *  The methods that currently are available through stored procedures are:\n    *  getColumnPrivileges\n    *  @return the metadata setting.\n    *  The default value is 1.\n    **/\n    public int getMetaDataSource()\n    {\n        return properties_.getInt(JDProperties.METADATA_SOURCE);\n    }\n    \n    //@dup\n    /**                                                               \n     *  Indicates how to retrieve DatabaseMetaData.\n     *  If set to 0, database metadata will be retrieved through the ROI data flow.  \n     *  If set to 1, database metadata will be retrieved by calling system stored procedures. \n     *  The methods that currently are available through stored procedures are:\n     *  getColumnPrivileges\n     *  @return the metadata setting.\n     *  The default value is 1.\n     *  Note:  this method is the same as getMetaDataSource() so that it corresponds to the connection property name\n     **/\n    public int getMetadataSource()\n    {\n        return getMetaDataSource();\n    }\n    \n    /**\n    *  Returns the naming convention used when referring to tables.\n    *  @return The naming convention.  Valid values include: \"sql\" (e.g. schema.table)\n    *  and \"system\" (e.g. schema/table).  The default value is \"sql\".\n    **/\n    public String getNaming()\n    {\n        return properties_.getString(JDProperties.NAMING);\n    }\n\n    /**\n    *  Returns the base name of the SQL package.  Note that only the\n    *  first six characters are used to generate the name of the SQL package on the system.  \n    *  This property has no effect unless\n    *  the extended dynamic property is set to true.  In addition, this property\n    *  must be set if the extended dynamic property is set to true.\n    *  @return The base name of the SQL package.\n    **/\n    public String getPackage()\n    {\n        return properties_.getString(JDProperties.PACKAGE);\n    }\n\n    /**\n    *  Returns the type of SQL statement to be stored in the SQL package.  This can\n    *  be useful to improve the performance of complex join conditions.  This\n    *  property has no effect unless the extended dynamic property is set to true.\n    *  @return The type of SQL statement.\n    *  Valid values include: \"default\" (only store SQL statements with parameter\n    *  markers in the package) and \"select\" (store all SQL SELECT statements\n    *  in the package).  The default value is \"default\".\n    **/\n    public String getPackageCriteria()\n    {\n        return properties_.getString(JDProperties.PACKAGE_CRITERIA);\n    }\n\n    /**\n    *  Returns the action to take when SQL package errors occur.  When an SQL package\n    *  error occurs, the driver will optionally throw an SQLException or post a\n    *  warning to the Connection, based on the value of this property.  This property\n    *  has no effect unless the extended dynamic property is set to true.\n    *  @return The action to take when SQL errors occur.\n    *  Valid values include: \"exception\", \"warning\", and \"none\".  The default value is \"warning\".\n    **/\n    public String getPackageError()\n    {\n        return properties_.getString(JDProperties.PACKAGE_ERROR);\n    }\n    /**\n    *  Returns the library for the SQL package.  This property has no effect unless\n    *  the extended dynamic property is set to true.\n    *  @return The SQL package library.  The default package library is \"QGPL\".\n    **/\n    public String getPackageLibrary()\n    {\n        return properties_.getString(JDProperties.PACKAGE_LIBRARY);\n    }\n\n    /**\n    *  Returns the name of the proxy server.\n    *  @return The proxy server.\n    **/\n    public String getProxyServer()\n    {\n        return properties_.getString(JDProperties.PROXY_SERVER);\n    }\n\n    /**\n    *  Returns the Reference object for the data source object.\n    *  This is used by JNDI when bound in a JNDI naming service.\n    *  Contains the information necessary to reconstruct the data source\n    *  object when it is later retrieved from JNDI via an object factory.\n    *\n    *  @return A Reference object of the data source object.\n    *  @exception NamingException If a naming error occurs in resolving the object.\n    **/\n    public Reference getReference() throws NamingException\n    {\n    \t\n    \tTrace.log(Trace.INFORMATION, \"AS400JDBCDataSource.getReference\"); \n\n        Reference ref = new Reference(this.getClass().getName(),\n                                      \"com.ibm.as400.access.AS400JDBCObjectFactory\",\n                                      null);\n\n        // Add the JDBC properties.\n        DriverPropertyInfo[] propertyList = properties_.getInfo();\n        for (int i=0; i< propertyList.length; i++)\n        {\n            if (propertyList[i].value != null)\n                ref.add(new StringRefAddr(propertyList[i].name, propertyList[i].value));\n        }\n\n        // Add the Socket options\n        if (sockProps_.keepAliveSet_) ref.add(new StringRefAddr(SOCKET_KEEP_ALIVE, (sockProps_.keepAlive_ ? \"true\" : \"false\")));\n        if (sockProps_.receiveBufferSizeSet_) ref.add(new StringRefAddr(SOCKET_RECEIVE_BUFFER_SIZE, Integer.toString(sockProps_.receiveBufferSize_)));\n        if (sockProps_.sendBufferSizeSet_) ref.add(new StringRefAddr(SOCKET_SEND_BUFFER_SIZE, Integer.toString(sockProps_.sendBufferSize_)));\n        if (sockProps_.soLingerSet_) ref.add(new StringRefAddr(SOCKET_LINGER, Integer.toString(sockProps_.soLinger_)));\n        if (sockProps_.soTimeoutSet_) ref.add(new StringRefAddr(SOCKET_TIMEOUT, Integer.toString(sockProps_.soTimeout_)));\n        if (sockProps_.loginTimeoutSet_) ref.add(new StringRefAddr(SOCKET_LOGIN_TIMEOUT, Integer.toString(sockProps_.loginTimeout_))); //@st3\n        if (sockProps_.tcpNoDelaySet_) ref.add(new StringRefAddr(SOCKET_TCP_NO_DELAY, (sockProps_.tcpNoDelay_ ? \"true\" : \"false\")));\n\n        // Add the data source properties.  (unique constant identifiers for storing in JNDI).\n        if (getDatabaseName() != null)\n            ref.add(new StringRefAddr(DATABASE_NAME, getDatabaseName()));\n        if (getDataSourceName() != null)\n            ref.add(new StringRefAddr(DATASOURCE_NAME, getDataSourceName()));\n        if (getDescription() != null)\n            ref.add(new StringRefAddr(DESCRIPTION, getDescription()));\n        ref.add(new StringRefAddr(SERVER_NAME, getServerName()));\n        ref.add(new StringRefAddr(USER, getUser()));\n        ref.add(new StringRefAddr(KEY_RING_NAME, serialKeyRingName_));                             // @F0A\n        if (savePasswordWhenSerialized_) {                                                         // @F0A\n            ref.add(new StringRefAddr(PASSWORD, new String(serialPWBytes_)));                      // @F0A\n            if (serialKeyRingPWBytes_ != null)                                                     // @F0A\n                ref.add(new StringRefAddr(KEY_RING_PASSWORD, new String(serialKeyRingPWBytes_)));  // @F0A\n            else                                                                                   // @F0A\n                ref.add(new StringRefAddr(KEY_RING_PASSWORD, null));                               // @F0A\n        }                                                                                          // @F0A\n        ref.add(new StringRefAddr(SECURE, (isSecure_ ? TRUE_ : FALSE_)));                          // @F0A\n        ref.add(new StringRefAddr(SAVE_PASSWORD, (savePasswordWhenSerialized_ ? TRUE_ : FALSE_))); // @F0A\n\n        return ref;\n    }\n\n    /**\n    *  Returns the source of the text for REMARKS columns in ResultSets returned\n    *  by DatabaseMetaData methods.\n    *  @return The text source.\n    *  Valid values include: \"sql\" (SQL object comment) and \"system\" (IBM i object description).\n    *  The default value is \"system\".\n    **/\n    public String getRemarks()\n    {\n        return properties_.getString(JDProperties.REMARKS);\n    }\n\n    /**\n    *  Returns the secondary URL.\n    *  @return The secondary URL.\n    **/\n    public String getSecondaryUrl()\n    {\n        return properties_.getString(JDProperties.SECONDARY_URL);\n    }\n\n    //@dup\n    /**\n     *  Returns the secondary URL.\n     *  @return The secondary URL.\n     *  Note:  this method is the same as setSecondaryUrl() so that it corresponds to the connection property name\n     **/\n    public String getSecondaryURL()\n    {\n        return getSecondaryUrl();\n    }\n    \n     \n    /**\n    *  Returns the name of the IBM i system.\n    *  @return The system name.\n    **/\n    public String getServerName()\n    {\n        return as400_.getSystemName();\n    }\n\n\n    // @j1 new method\n    /**\n    *  Returns the level of tracing started on the JDBC server job.\n    *  If tracing is enabled, tracing is started when\n    *  the client connects to the system and ends when the connection\n    *  is disconnected.  Tracing must be started before connecting to\n    *  the system since the client enables system tracing only at connect time.\n    *  Trace data is collected in spooled files on the system.  Multiple\n    *  levels of tracing can be turned on in combination by adding\n    *  the constants and passing that sum on the set method.  For example,\n    *  <pre>\n    *  dataSource.setServerTraceCategories(AS400JDBCDataSource.SERVER_TRACE_START_DATABASE_MONITOR + AS400JDBCDataSource.SERVER_TRACE_SAVE_SERVER_JOBLOG);\n    *  </pre>\n    *  @return The tracing level.\n    *  <p>The value is a combination of the following:\n    *  <ul>\n    *  <li>SERVER_TRACE_START_DATABASE_MONITOR - Start the database monitor on the JDBC server job.\n    *                               The numeric value of this constant is 2.\n    *  <LI>SERVER_TRACE_DEBUG_SERVER_JOB - Start debug on the JDBC server job.\n    *                         The numeric value of this constant is 4.\n    *  <LI>SERVER_TRACE_SAVE_SERVER_JOBLOG - Save the joblog when the JDBC server job ends.\n    *                           The numeric value of this constant is 8.\n    *  <LI>SERVER_TRACE_TRACE_SERVER_JOB - Start job trace on the JDBC server job.\n    *                         The numeric value of this constant is 16.\n    *  <LI>SERVER_TRACE_SAVE_SQL_INFORMATION - Save SQL information.\n    *                             The numeric value of this constant is 32.\n    *  </ul>\n    *\n    *  <P>\n    *  Tracing the JDBC server job will use significant amounts of system resources.\n    *  Additional processor resource is used to collect the data, and additional\n    *  storage is used to save the data.  Turn on tracing only to debug\n    *  a problem as directed by IBM service.\n    *\n    **/\n    public int getServerTraceCategories()\n    {\n        return properties_.getInt(JDProperties.TRACE_SERVER);\n    }\n    \n    //@dup\n    /**\n     *  Returns the level of tracing started on the JDBC server job.\n     *  If tracing is enabled, tracing is started when\n     *  the client connects to the system and ends when the connection\n     *  is disconnected.  Tracing must be started before connecting to\n     *  the system since the client enables system tracing only at connect time.\n     *  Trace data is collected in spooled files on the system.  Multiple\n     *  levels of tracing can be turned on in combination by adding\n     *  the constants and passing that sum on the set method.  For example,\n     *  <pre>\n     *  dataSource.setServerTraceCategories(AS400JDBCDataSource.SERVER_TRACE_START_DATABASE_MONITOR + AS400JDBCDataSource.SERVER_TRACE_SAVE_SERVER_JOBLOG);\n     *  </pre>\n     *  @return The tracing level.\n     *  <p>The value is a combination of the following:\n     *  <ul>\n     *  <li>SERVER_TRACE_START_DATABASE_MONITOR - Start the database monitor on the JDBC server job.\n     *                               The numeric value of this constant is 2.\n     *  <LI>SERVER_TRACE_DEBUG_SERVER_JOB - Start debug on the JDBC server job.\n     *                         The numeric value of this constant is 4.\n     *  <LI>SERVER_TRACE_SAVE_SERVER_JOBLOG - Save the joblog when the JDBC server job ends.\n     *                           The numeric value of this constant is 8.\n     *  <LI>SERVER_TRACE_TRACE_SERVER_JOB - Start job trace on the JDBC server job.\n     *                         The numeric value of this constant is 16.\n     *  <LI>SERVER_TRACE_SAVE_SQL_INFORMATION - Save SQL information.\n     *                             The numeric value of this constant is 32.\n     *  </ul>\n     *\n     *  <P>\n     *  Tracing the JDBC server job will use significant amounts of system resources.\n     *  Additional processor resource is used to collect the data, and additional\n     *  storage is used to save the data.  Turn on tracing only to debug\n     *  a problem as directed by IBM service.\n     *\n     *  Note:  this method is the same as getServerTraceCategories() so that it corresponds to the connection property name\n     **/\n     public int getServerTrace()\n     {\n         return getServerTraceCategories();\n     }\n\n     //@STIMEOUT\n     /**\n      * Gets the socket timeout option in milliseconds.\n      * @return The value of the socket timeout option.\n      **/\n     public int getSocketTimeout()\n     {\n         return getSoTimeout(); \n     }\n      \n    /**\n    *  Returns how the system sorts records before sending them to the \n    *  client.\n    *  @return The sort value.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li>\"hex\" (base the sort on hexadecimal values)\n    *    <li>\"language\" (base the sort on the language set in the sort language property)\n    *    <li> \"table\" (base the sort on the sort sequence table set in the sort table property)\n    *  </ul>\n    *  The default value is \"hex\".\n    **/\n    public String getSort()\n    {\n        return properties_.getString(JDProperties.SORT);\n    }\n\n    /**\n    *  Returns the three-character language id to use for selection of a sort sequence.\n    *  @return The three-character language id.\n    *  The default value is ENU.\n    **/\n    public String getSortLanguage()\n    {\n        return properties_.getString(JDProperties.SORT_LANGUAGE);\n    }\n\n    /**\n    *  Returns the library and file name of a sort sequence table stored on the\n    *  system.\n    *  @return The qualified sort table name.\n    **/\n    public String getSortTable()\n    {\n        return properties_.getString(JDProperties.SORT_TABLE);\n    }\n\n    /**\n    *  Returns how the system treats case while sorting records.\n    *  @return The sort weight.\n    *  Valid values include: \"shared\" (upper- and lower-case characters are sorted as the\n    *  same character) and \"unique\" (upper- and lower-case characters are sorted as\n    *  different characters).  The default value is \"shared\".\n    **/\n    public String getSortWeight()\n    {\n        return properties_.getString(JDProperties.SORT_WEIGHT);\n    }\n\n    /**\n    *  Returns the time format used in time literals with SQL statements.\n    *  @return The time format.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \"hms\"\n    *    <li> \"usa\"\n    *    <li> \"iso\"\n    *    <li> \"eur\"\n    *    <li> \"jis\"\n    *    <li> \"\"  (server job value) - default.\n    *  </ul>\n    *  The default value is based on the server job.\n    **/\n    public String getTimeFormat()\n    {\n        return properties_.getString(JDProperties.TIME_FORMAT);\n    }\n\n    /**\n    *  Returns the time separator used in time literals within SQL \n    *  statements.\n    *  @return The time separator.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \":\" (colon)\n    *    <li> \".\" (period)\n    *    <li> \",\" (comma)\n    *    <li> \" \" (space)\n    *    <li> \"\"  (server job value) - default.\n    *  </ul>\n    *  The default value is based on the server job.\n    **/\n    public String getTimeSeparator()\n    {\n        return properties_.getString(JDProperties.TIME_SEPARATOR);\n    }\n\n\n    /**\n    *  Returns the system's transaction isolation.\n    *  @return The transaction isolation level.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \"none\"\n    *    <li> \"read uncommitted\"  - The default value.\n    *    <li> \"read committed\"\n    *    <li> \"repeatable read\"\n    *    <li> \"serializable\"\n    *  </ul>\n    **/\n    public String getTransactionIsolation()\n    {\n        return properties_.getString(JDProperties.TRANSACTION_ISOLATION);\n    }\n\n\n    // @J3 No change needeadd code here.  UID already properly serialized\n    /**\n    *  Returns the database user property.\n    *  @return The user.\n    **/\n    public String getUser()\n    {\n        return as400_.getUserId();\n    }\n\n    // @K3A\n    /**\n    *  Returns the QAQQINI library name.\n    *  @return The QAQQINI library name.\n    **/\n    public String getQaqqiniLibrary()\n    {\n        return properties_.getString(JDProperties.QAQQINILIB);\n    }\n    \n    //@dup\n    /**\n     *  Returns the QAQQINI library name.\n     *  @return The QAQQINI library name.\n     *  Note:  this method is the same as getQaqqiniLibrary() so that it corresponds to the connection property name\n     **/\n    public String getQaqqinilib()\n    {\n        return getQaqqiniLibrary();\n    }\n     \n\n    //@540\n    /**                                                               \n    *  Returns the goal the IBM i system should use with optimization of queries.  \n    *  @return the goal the IBM i system should use with optimization of queries.\n    *  <p>Valid values include:\n    *  <ul>\n    *  <li>0 = Optimize query for first block of data (*ALLIO) when extended dynamic packages are used; Optimize query for entire result set (*FIRSTIO) when packages are not used</li>\n    *  <li>1 = Optimize query for first block of data (*FIRSTIO)</li>\n    *  <li>2 = Optimize query for entire result set (*ALLIO) </li>\n    *  </ul>\n    *  The default value is 0.\n    **/\n    public int getQueryOptimizeGoal()\n    {\n        return properties_.getInt(JDProperties.QUERY_OPTIMIZE_GOAL);\n    }\n\n    //@550\n    /**\n    * Returns the storage limit in megabytes, that should be used for statements executing a query in a connection.\n    * Note, this setting is ignored when running to i5/OS V5R4 or earlier\n    * You must have *JOBCTL special authority to use query storage limit with Version 6 Release 1 of IBM i.\n    * <p> Valid values are -1 to MAX_STORAGE_LIMIT megabytes.  \n    * The default value is -1 meaning there is no limit.\n    **/\n    public int getQueryStorageLimit()\n    {\n        return properties_.getInt(JDProperties.QUERY_STORAGE_LIMIT);\n    }\n\n   /*@D4A*/\n    /**                                                               \n    *  Returns the mechanism used to implement query timeout. \n    *  @return the mechanism used to implement query timeout.\n    *  <p>Valid values include:\n    *  <ul>\n    *  <li>qqrytimlmt = The QQRYTIMLMT will be used. \n    *  <li>cancel     = A long running statement will be cancelled.\n    *  </ul>\n    *  The default value is 0.\n    **/\n    public String getQueryTimeoutMechanism()\n    {\n        return properties_.getString(JDProperties.QUERY_TIMEOUT_MECHANISM);\n    }\n\n    //@540\n    /**                                                               \n    *  Indicates whether lock sharing is allowed for loosely coupled transaction branches.\n    *  @return the lock sharing setting.\n    *  <p>Valid values include:\n    *  <ul>\n    *  <li>0 = Locks cannot be shared</li>\n    *  <li>1 = Locks can be shared</li>\n    *  </ul>\n    *  The default value is 0.\n    **/\n    public int getXALooselyCoupledSupport()\n    {\n        return properties_.getInt(JDProperties.XA_LOOSELY_COUPLED_SUPPORT);\n    }\n\n    /**\n    *  Initializes the transient data for object de-serialization.\n    **/\n    private void initializeTransient()\n    {\n    \tTrace.log(Trace.INFORMATION, \"AS400JDBCDataSource.initializeTransient\"); \n\n        changes_ = new PropertyChangeSupport(this);\n\n        if (isSecure_)            //@B4A  \n            as400_ = new SecureAS400();         //@B4A\n        else                     //@B4A\n            as400_ = new AS400();\n\n        // Reinitialize the serverName, user, password, keyRingName, etc.\n        if (serialServerName_ != null)\n            setServerName(serialServerName_);\n\n        if (serialUserName_ != null)\n        {                                                               // @J3a\n            setUser(serialUserName_);\n\n            if ((serialPWBytes_ != null) &&                             // @J3a\n                (serialPWBytes_.length > 0))                            // @J3a\n            {                                                           // @J3a\n                as400_.setPassword(xpwDeconfuse(serialPWBytes_));        // @J3a\n            }                                                           // @J3a\n        }\n\n        try\n        {\n            if (serialKeyRingName_ != null && isSecure_)                  //@B4A\n            {                                                             //@J3a\n                if ((serialKeyRingPWBytes_ != null) &&                    //@J3a      \n                    (serialKeyRingPWBytes_.length > 0))                   //@J3a      \n                {                                                         //@J3a\n                    String keyRingPassword = xpwDeconfuse(serialKeyRingPWBytes_);  // @J3a\n                    ((SecureAS400)as400_).setKeyRingName(serialKeyRingName_, keyRingPassword); //@J3A\n                }                                                            //@J3a\n                else\n                {                                                         //@J3a                                                            //@J3a\n                    ((SecureAS400)as400_).setKeyRingName(serialKeyRingName_); //@B4A\n                }                                                            //@J3a\n            }                                                                //@J3a\n        }\n        catch (PropertyVetoException pve)\n        { /* Will never happen */\n        }\n\n        // @J4 Make sure the prompt flag is correctly de-serialized.  The problem was\n        //     the flag would get serialized with the rest of the properties \n        //     (in the properties_ object), but the flag would never be applied\n        //     to the AS400 object when de-serialzed.  De-serialization puts the\n        //     flag back in properties_ but that does no good unless the value\n        //     is passed on to the AS400 object.  That is what the new code does. \n        //     There is no affect on normal \"new\" objects since at the time this \n        //     method is called properties_ is null.\n        try\n        {                                                           //@J4A                                                             //@J4A\n            if (properties_ != null)                                   //@J4A\n                if (!isPrompt())                                        //@J4A\n                    as400_.setGuiAvailable(false);                       //@J4A\n        }                                                             //@J4A\n        catch (PropertyVetoException pve)                             //@J4A\n        { /* Will never happen */                                     //@J4A\n        }                                                             //@J4A\n\n    }\n\n    //@KBA\n    /**\n    *  Indicates whether true auto commit support is used.\n    *  @return true if true auto commit support is used; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isTrueAutoCommit()\n    {\n        return properties_.getBoolean(JDProperties.TRUE_AUTO_COMMIT); //@true\n    }\n    \n    //@dup\n    /**\n     *  Indicates whether true auto commit support is used.\n     *  @return true if true auto commit support is used; false otherwise.\n     *  The default value is false.\n     *  Note:  this method is the same as isTrueAutoCommit() so that it corresponds to the connection property name\n     **/\n    public boolean isTrueAutocommit()\n    {\n        return isTrueAutoCommit();\n    }\n     \n\n    //@K54\n    /**\n    *  Indicates whether variable-length fields are compressed.\n    *  @return true if variable-length fields are compressed; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isVariableFieldCompression()\n    {\n        return properties_.getBoolean(JDProperties.VARIABLE_FIELD_COMPRESSION);\n    }\n\n    //@AC1\n    /**\n     *  Returns whether auto-commit mode is the default connection mode for new connections.\n     *  @return Auto commit.\n     *  The default value is true.\n     **/\n     public boolean isAutoCommit()\n     {\n         return properties_.getBoolean(JDProperties.AUTO_COMMIT);\n     }\n     \n    //@CE1\n    /**\n     *  Returns whether commit or rollback throws SQLException when autocommit is enabled.\n     *  @return Autocommit Exception.\n     *  The default value is false.\n     **/\n     public boolean isAutocommitException()\n     {\n         return properties_.getBoolean(JDProperties.AUTOCOMMIT_EXCEPTION);\n     }\n     \n    //@K24\n    /**\n    *  Indicates whether bidi implicit reordering is used.\n    *  @return true if bidi implicit reordering is used; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isBidiImplicitReordering()\n    {\n        return properties_.getBoolean(JDProperties.BIDI_IMPLICIT_REORDERING);\n    }\n\n    //@K24\n    /**\n    *  Indicates whether bidi numeric ordering round trip is used.\n    *  @return true if bidi numeric ordering round trip is used; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isBidiNumericOrdering()\n    {\n        return properties_.getBoolean(JDProperties.BIDI_NUMERIC_ORDERING);\n    }\n\n    /**\n    *  Indicates whether a big decimal value is returned.\n    *  @return true if a big decimal is returned; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isBigDecimal()\n    {\n        return properties_.getBoolean(JDProperties.BIG_DECIMAL);\n    }\n\n    /**\n    *  Indicates whether the cursor is held.\n    *  @return true if the cursor is held; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isCursorHold()\n    {\n        return properties_.getBoolean(JDProperties.CURSOR_HOLD);\n    }\n\n    /**\n    *  Indicates whether data compression is used.\n    *  @return true if data compression is used; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isDataCompression()\n    {\n        return properties_.getBoolean(JDProperties.DATA_COMPRESSION);\n    }\n\n    /**\n    *  Indicates whether data truncation is used.\n    *  @return true if data truncation is used; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isDataTruncation()\n    {\n        return properties_.getBoolean(JDProperties.DATA_TRUNCATION);\n    }\n\n    /**\n    *  Indicates whether extended dynamic support is used.  Extended dynamic\n    *  support provides a mechanism for caching dynamic SQL statements on\n    *  the system.  The first time a particular SQL statement is prepared, it is\n    *  stored in an SQL package on the system.  \n    *  If the package does not exist, it will be automatically created.\n    *  On subsequent prepares of the\n    *  same SQL statement, the system can skip a significant part of the\n    *  processing by using information stored in the SQL package.\n    *  @return true if extended dynamic support is used; false otherwise.\n    *  The default value is not to use extended dynamic support.\n    **/\n    public boolean isExtendedDynamic()\n    {\n        return properties_.getBoolean(JDProperties.EXTENDED_DYNAMIC);\n    }\n\n\n    // @C3A\n    /**\n    *  Indicates whether the driver should request extended metadata from the\n    *  IBM i system.  If this property is set to true, the accuracy of the information \n    *  that is returned from ResultSetMetaData methods getColumnLabel(int),\n    *  isReadOnly(int), isSearchable(int), and isWriteable(int) will be increased.\n    *  In addition, the ResultSetMetaData method getSchemaName(int) will be supported with this \n    *  property set to true.  However, performance will be slower with this \n    *  property on.  Leave this property set to its default (false) unless you\n    *  need more specific information from those methods.\n    *\n    *  For example, without this property turned on, isSearchable(int) will \n    *  always return true even though the correct answer may be false because \n    *  the driver does not have enough information from the system to make a judgment.  Setting \n    *  this property to true forces the driver to get the correct data from the IBM i system.\n    *\n    *  @return true if extended metadata will be requested; false otherwise.\n    *  The default value is false.\n    **/\n\n    public boolean isExtendedMetaData()\n    {\n        return properties_.getBoolean(JDProperties.EXTENDED_METADATA);\n    }\n    \n    //@dup\n    /**\n     *  Indicates whether the driver should request extended metadata from the\n     *  IBM i system.  If this property is set to true, the accuracy of the information \n     *  that is returned from ResultSetMetaData methods getColumnLabel(int),\n     *  isReadOnly(int), isSearchable(int), and isWriteable(int) will be increased.\n     *  In addition, the ResultSetMetaData method getSchemaName(int) will be supported with this \n     *  property set to true.  However, performance will be slower with this \n     *  property on.  Leave this property set to its default (false) unless you\n     *  need more specific information from those methods.\n     *\n     *  For example, without this property turned on, isSearchable(int) will \n     *  always return true even though the correct answer may be false because \n     *  the driver does not have enough information from the system to make a judgment.  Setting \n     *  this property to true forces the driver to get the correct data from the IBM i system.\n     *\n     *  @return true if extended metadata will be requested; false otherwise.\n     *  The default value is false.\n     *  Note:  this method is the same as isExtendedMetaData() so that it corresponds to the connection property name\n     **/\n\n    public boolean isExtendedMetadata()\n    {\n        return isExtendedMetaData();\n    }\n\n\n    // @W1a\n    /**\n    *  Indicates whether the IBM i system fully opens a file when performing a query.\n    *  By default the system optimizes opens so they perform better.  In\n    *  certain cases an optimized open will fail.  In some\n    *  cases a query will fail when a database performance monitor\n    *  is turned on even though the same query works with the monitor\n    *  turned off.  In this case set the full open property to true.\n    *  This disables optimization on the system.\n    *  @return true if files are fully opened; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isFullOpen()\n    {\n        return properties_.getBoolean(JDProperties.FULL_OPEN);\n    }\n\n    //@dmy\n    /**\n    *  Indicates whether the temporary fix for JVM 1.6 is enabled.\n    *  @return true if enabled; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isJvm16Synchronize()\n    {\n        return properties_.getBoolean(JDProperties.JVM16_SYNCHRONIZE);\n    }\n\n    // @A1A\n    /**\n    *  Indicates whether to delay closing cursors until subsequent requests.\n    *  @return true to delay closing cursors until subsequent requests; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isLazyClose()\n    {\n        return properties_.getBoolean(JDProperties.LAZY_CLOSE);\n    }\n\n    //@KBL\n    /**\n    *  Indicates whether input locators are of type hold.\n    *  @return true if input locators are of type hold; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isHoldInputLocators()\n    {\n        return properties_.getBoolean(JDProperties.HOLD_LOCATORS);\n    }\n\n    /**\n    *  Indicates whether to add newly prepared statements to the   \n    *  SQL package specified on the \"package\" property.  This property\n    *  has no effect unless the extended dynamic property is set to true;\n    *  @return true If newly prepared statements should be added to the SQL package specified \n    *  on the \"package\" property; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isPackageAdd()\n    {\n        return properties_.getBoolean(JDProperties.PACKAGE_ADD);\n    }\n\n    /**\n    *  Indicates whether a subset of the SQL package information is cached in client memory.  \n    *  Caching SQL packages locally\n    *  reduces the amount of communication to the IBM i system for prepares and describes.  This\n    *  property has no effect unless the extended dynamic property is set to true.\n    *  @return true if caching is used; false otherwise.\n    *  The defalut value is false.\n    **/\n    public boolean isPackageCache()\n    {\n        return properties_.getBoolean(JDProperties.PACKAGE_CACHE);\n    }\n\n    //@C6D Deprecated method.\n    /**\n    *  Indicates whether SQL packages are cleared when they become full.  This method\n    *  has been deprecated.  Package clearing and the decision for the \n    *  threshold where package clearing is needed is now handled\n    *  automatically by the database.  \n    *  @return Always false.  This method is deprecated.\n    *  @deprecated\n    **/\n    public boolean isPackageClear()\n    {\n        //@C6D return properties_.getBoolean(JDProperties.PACKAGE_CLEAR);\n        return false;  //@C6A\n    }\n\n    /**\n    *  Indicates whether data is prefetched upon executing a SELECT statement.\n    *  This will increase performance when accessing the initial rows in the result set.\n    *  @return If prefetch is used; false otherwise.\n    *  The default value is prefetch data.\n    **/\n    public boolean isPrefetch()\n    {\n        return properties_.getBoolean(JDProperties.PREFETCH);\n    }\n\n    /**\n    *  Indicates whether the user is prompted if a user name or password is\n    *  needed to connect to the IBM i system.  If a connection can not be made\n    *  without prompting the user, and this property is set to false, then an\n    *  attempt to connect will fail throwing an exception.\n    *  @return true if the user is prompted for signon information; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isPrompt()\n    {\n        return properties_.getBoolean(JDProperties.PROMPT);\n    }\n\n    //@K94\n    /**\n    *  Indicates whether the cursor is held after a rollback.\n    *  @return true if the cursor is held; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isRollbackCursorHold()\n    {\n        return properties_.getBoolean(JDProperties.ROLLBACK_CURSOR_HOLD);\n    }\n\n    //@KBL\n    /**\n    *  Indicates whether statements remain open until a transaction boundary when autocommit is off and they\n    *  are associated with Lob locators.\n    *  @return true if statements are only closed at transaction boundaries; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isHoldStatements()\n    {\n        return properties_.getBoolean(JDProperties.HOLD_STATEMENTS);\n    }\n\n    // @J3 new method\n    /**\n    *  Indicates whether the password is saved locally with the rest of\n    *  the properties when this data source object is serialized.\n    *  <P>\n    *  If the password is saved, it is up to the application to protect\n    *  the serialized form of the object because it contains all necessary\n    *  information to connect to the IBM i system.  The default is false.  It\n    *  is a security risk to save the password with the rest of the\n    *  properties so by default the password is not saved.  If the programmer\n    *  chooses to accept this risk, call setSavePasswordWhenSerialized(true)\n    *  to force the Toolbox to save the password with the other properties\n    *  when the data source object is serialized.   \n    *  @return true if the password is saved with the rest of the properties when the\n    *          data source object is serialized; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isSavePasswordWhenSerialized()\n    {\n        return savePasswordWhenSerialized_;\n    }\n\n\n\n\n\n    /**\n    *  Indicates whether a Secure Socket Layer (SSL) connection is used to communicate\n    *  with the IBM i system.  SSL connections are only available when connecting to systems\n    *  at V4R4 or later.\n    *  @return true if Secure Socket Layer connection is used; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isSecure()\n    {\n        return properties_.getBoolean(JDProperties.SECURE);\n    }\n\n    //@pw3\n    /**\n     *  Returns the secure current user setting.  True indicates to disallow \"\" and *current for user name and password.\n     *  @return The secure current user setting.\n     **/\n    public boolean isSecureCurrentUser()\n    {\n        return  properties_.getBoolean(JDProperties.SECURE_CURRENT_USER);\n    }\n\n    /**\n    *  Indicates whether a thread is used.\n    *  @return true if a thread is used; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isThreadUsed()\n    {\n        return properties_.getBoolean(JDProperties.THREAD_USED);\n    }\n\n    /**\n    *  Indicates whether trace messages should be logged.\n    *  @return true if trace message are logged; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isTrace()\n    {\n        return properties_.getBoolean(JDProperties.TRACE);\n    }\n\n    /**\n    *  Indicates whether binary data is translated.  If this property is set\n    *  to true, then BINARY and VARBINARY fields are treated as CHAR and\n    *  VARCHAR fields.\n    *  @return true if binary data is translated; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isTranslateBinary()\n    {\n        return properties_.getBoolean(JDProperties.TRANSLATE_BINARY);\n    }\n\n    //@PDA\n    /**\n    *  Indicates how Boolean objects are interpreted when setting the value \n    *  for a character field/parameter using the PreparedStatement.setObject(), \n    *  CallableStatement.setObject() or ResultSet.updateObject() methods.  Setting the \n    *  property to \"true\", would store the Boolean object in the character field as either \n    *  \"true\" or \"false\".  Setting the property to \"false\", would store the Boolean object \n    *  in the character field as either \"1\" or \"0\".\n    *  @return true if boolean data is translated; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isTranslateBoolean()\n    {\n        return properties_.getBoolean(JDProperties.TRANSLATE_BOOLEAN);\n    }\n     \n    \n    /**\n     *  Indicates whether blocking is used for update and delete operations\n     *  @return true if enabled; false otherwise.\n     *  The default value is false.\n     **/\n     public boolean isUseBlockUpdate()\n     {\n         return properties_.getBoolean(JDProperties.DO_UPDATE_DELETE_BLOCKING);\n     }\n\n\n    /**\n    *  Logs a message to the event log.\n    *  @param message The message to log.\n    **/\n    void log(String message)\n    {\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, message);\n\n        if (log_ != null)\n            log_.log(message);\n    }\n\n    /**\n    *  Logs an exception and message to the event log.\n    *  @param property The property to log.\n    *  @param value The property value to log.\n    **/\n    private void logProperty(String property, String value)\n    {\n        if (Trace.isTraceOn())\n            JDTrace.logProperty (this, property, value);\n\n        //@A8D if (log_ != null)\n        //@A8D log_.log(property + \": \" + value);\n    }\n\n    /**\n    *  Deserializes and initializes transient data.\n    *  @exception ClassNotFoundException If the class cannot be found.\n    *  @exception IOException If an I/O exception occurs.\n    **/\n    private void readObject(ObjectInputStream in) throws ClassNotFoundException, IOException\n    {\n        in.defaultReadObject();\n        initializeTransient();\n    }\n\n    /**\n    *  Removes the PropertyChangeListener.\n    *  If the PropertyChangeListener is not in the list, nothing is done.\n    *  @param listener The PropertyChangeListener.\n    *  @see #addPropertyChangeListener\n    **/\n    public void removePropertyChangeListener(PropertyChangeListener listener)\n    {\n        if (listener == null)\n            throw new NullPointerException(\"listener\");\n        changes_.removePropertyChangeListener(listener);\n\n        as400_.removePropertyChangeListener(listener);                 //@K1C  changed to removePropertyChangeListener instead of addPropertyChangeListener\n    }\n\n    /**\n    *  Sets the level of database access for the connection.\n    *  @param access The access level.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \"all\" (all SQL statements allowed)\n    *    <li> \"read call\" (SELECT and CALL statements allowed)\n    *    <li> \"read only\" (SELECT statements only)\n    *  </ul>\n    *  The default value is \"all\".\n    **/\n    public void setAccess(String access)\n    {\n        String property = \"access\";\n\n        if (access == null)\n            throw new NullPointerException(property);\n        validateProperty(property, access, JDProperties.ACCESS);\n\n        String old = getAccess();\n        properties_.setString(JDProperties.ACCESS, access);\n\n        changes_.firePropertyChange(property, old, access);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + access);  //@A8C\n    }\n \n      //@AC1\n      /**\n      *  Sets whether auto-commit mode is the default connection mode for new connections.\n      *  @param value\n      *  The default value is true.\n      **/\n      public void setAutoCommit(boolean value)\n      {\n          String property = \"autoCommit\";\n          Boolean oldValue = new Boolean(isAutoCommit());\n          Boolean newValue = new Boolean(value);\n\n          if (value)\n              properties_.setString(JDProperties.AUTO_COMMIT, TRUE_);\n          else\n              properties_.setString(JDProperties.AUTO_COMMIT, FALSE_);\n\n          changes_.firePropertyChange(property, oldValue, newValue);\n\n          if (JDTrace.isTraceOn()) \n              JDTrace.logInformation (this, property + \": \" + value);   \n      }\n     \n    //@CE1\n    /**\n     *  Sets whether commit or rollback throws SQLException when autocommit is enabled.\n     *  @param value\n     *  The default value is false.\n     **/\n     public void setAutocommitException(boolean value)\n     {\n         String property = \"autocommitException\";\n         Boolean oldValue = new Boolean(isAutocommitException());\n         Boolean newValue = new Boolean(value);\n\n         if (value)\n             properties_.setString(JDProperties.AUTOCOMMIT_EXCEPTION, TRUE_);\n         else\n             properties_.setString(JDProperties.AUTOCOMMIT_EXCEPTION, FALSE_);\n\n         changes_.firePropertyChange(property, oldValue, newValue);\n\n         if (JDTrace.isTraceOn()) \n             JDTrace.logInformation (this, property + \": \" + value);   \n     }\n     \n    //@KBA\n    /**\n    *  Sets whether true auto commit support is used.\n    *  @param value true if true auto commit support should be used; false otherwise.\n    *  The default value is false.\n    **/\n    public void setTrueAutoCommit(boolean value)\n    {\n        String property = \"trueAutoCommit\";\n        Boolean oldValue = new Boolean(isTrueAutoCommit());\n        Boolean newValue = new Boolean(value);\n\n        if (value)\n            properties_.setString(JDProperties.TRUE_AUTO_COMMIT, TRUE_); //@true\n        else\n            properties_.setString(JDProperties.TRUE_AUTO_COMMIT, FALSE_); //@true\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + value);      \n    }\n    \n    //@dup\n    /**\n     *  Sets whether true auto commit support is used.\n     *  @param value true if true auto commit support should be used; false otherwise.\n     *  The default value is false.\n     *  Note:  this method is the same as setTrueAutoCommit() so that it corresponds to the connection property nameproperty name\n     **/\n    public void setTrueAutocommit(boolean value)\n    {\n        setTrueAutoCommit(value); \n    }\n\n\n    // @C9 new method\n    /**                                                               \n    *  Sets the Toolbox JDBC Driver behaviors to override.  Multiple\n    *  behaviors can be changed in combination by adding\n    *  the constants and passing that sum on the this method. \n    *  @param behaviors The driver behaviors to override.\n    *  <p>Valid values include:\n    *  <ul>\n    *  <li>1 - Do not throw an exception if Statement.executeQuery() or\n    *          PreparedStatement.executeQuery() do not return a result set.\n    *          Instead, return null for the result set.\n    *  </ul>\n    *\n    *  Carefully consider the result of overriding the default behavior of the\n    *  driver.  For example, setting the value of this property to 1 means\n    *  the driver will no longer throw an exception even though the JDBC 3.0\n    *  specification states throwing an exception is the correct behavior.  \n    *  Be sure your application correctly handles the altered behavior.  \n    *\n    **/\n    public void setBehaviorOverride(int behaviors)\n    {\n        String property = \"behaviorOverride\";\n\n        Integer oldValue = new Integer(getBehaviorOverride());\n        Integer newValue = new Integer(behaviors);\n\n        properties_.setString(JDProperties.BEHAVIOR_OVERRIDE, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + behaviors);\n    }\n\n\n\n\n    //@B2A\n    /**\n     *  Sets the output string type of bidi data. See <a href=\"BidiStringType.html\">\n     *  BidiStringType</a> for more information and valid values.\n     **/\n    public void setBidiStringType(int bidiStringType)                          //@B3C\n    {\n        String property = \"bidiStringType\";                                             //@B3C\n\n        //@B3D if (bidiStringType == null)\n        //@B3D    throw new NullPointerException(property);\n        Integer oldBidiStringType = new Integer(getBidiStringType());         //@B3A\n        Integer newBidiStringType = new Integer(bidiStringType);              //@B3A\n\n        validateProperty(property, newBidiStringType.toString(), JDProperties.BIDI_STRING_TYPE); //@B3C\n\n        properties_.setString(JDProperties.BIDI_STRING_TYPE, newBidiStringType.toString());   //@B3C\n\n        changes_.firePropertyChange(property, oldBidiStringType, newBidiStringType);  //@B3C\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + bidiStringType);\n    }\n\n    //@K24\n    /**\n    *  Sets whether bidi implicit reordering is used.\n    *  In this version, the parameter is used to determine whether Bidi layout \n    *  transformation should be applied to meta-data such as columns names.\n    *  @param value true if implicit reordering should be used; false otherwise.\n    *  The default value is true.\n    **/\n    public void setBidiImplicitReordering(boolean value)\n    {\n        String property = \"bidiImplicitReordering\";\n        Boolean oldValue = new Boolean(isBidiImplicitReordering());\n        Boolean newValue = new Boolean(value);\n\n        if (value)\n            properties_.setString(JDProperties.BIDI_IMPLICIT_REORDERING, TRUE_);\n        else\n            properties_.setString(JDProperties.BIDI_IMPLICIT_REORDERING, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + value);      \n    }\n\n    //@K24\n    /**\n    *  Sets whether bidi numeric ordering round trip is used.\n    *  @param value true if numeric ordering round trip should be used; false otherwise.\n    *  The default value is false.\n    **/\n    public void setBidiNumericOrdering(boolean value)\n    {\n        String property = \"bidiNumericOrdering\";\n        Boolean oldValue = new Boolean(isBidiNumericOrdering());\n        Boolean newValue = new Boolean(value);\n\n        if (value)\n            properties_.setString(JDProperties.BIDI_NUMERIC_ORDERING, TRUE_);\n        else\n            properties_.setString(JDProperties.BIDI_NUMERIC_ORDERING, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + value);      \n    }\n\n    /**\n    *  Sets whether a big decimal value is returned.\n    *  @param value true if a big decimal is returned; false otherwise.\n    *  The default value is true.\n    **/\n    public void setBigDecimal(boolean value)\n    {\n        String property = \"bigDecimal\";\n        Boolean oldValue = new Boolean(isBigDecimal());\n        Boolean newValue = new Boolean(value);\n\n        if (value)\n            properties_.setString(JDProperties.BIG_DECIMAL, TRUE_);\n        else\n            properties_.setString(JDProperties.BIG_DECIMAL, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + value);      //@A8C\n    }\n\n    /**\n    *  Sets the criteria for retrieving data from the IBM i system in\n    *  blocks of records.  Specifying a non-zero value for this property\n    *  will reduce the frequency of communication to the system, and\n    *  therefore increase performance.\n    *  @param blockCriteria The block criteria.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> 0 (no record blocking)\n    *    <li> 1 (block if FOR FETCH ONLY is specified)\n    *    <li> 2 (block if FOR UPDATE is specified) - The default value.\n    *  </ul>\n    **/\n    public void setBlockCriteria(int blockCriteria)\n    {\n        String property = \"blockCriteria\";\n        Integer oldCriteria = new Integer(getBlockCriteria());\n        Integer newCriteria = new Integer(blockCriteria);\n\n        validateProperty(property, newCriteria.toString(), JDProperties.BLOCK_CRITERIA);\n\n        properties_.setString(JDProperties.BLOCK_CRITERIA, newCriteria.toString());\n        changes_.firePropertyChange(property, oldCriteria, newCriteria);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + blockCriteria);   //@A8C\n    }\n\n    /**\n    *  Sets the block size in kilobytes to retrieve from the IBM i system and\n    *  cache on the client.  This property has no effect unless the block criteria\n    *  property is non-zero.  Larger block sizes reduce the frequency of\n    *  communication to the system, and therefore may increase performance.\n    *  @param blockSize The block size in kilobytes.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> 0\n    *    <li> 8\n    *    <li> 16\n    *    <li> 32  - The default value.\n    *    <li> 64\n    *    <li> 128\n    *    <li> 256\n    *    <li> 512\n    *  </ul>\n    **/\n    public void setBlockSize(int blockSize)\n    {\n        String property = \"blockSize\";\n\n        Integer oldBlockSize = new Integer(getBlockSize());\n        Integer newBlockSize = new Integer(blockSize);\n\n        validateProperty(property, newBlockSize.toString(), JDProperties.BLOCK_SIZE);\n\n        properties_.setString(JDProperties.BLOCK_SIZE, new Integer(blockSize).toString());\n        changes_.firePropertyChange(property, oldBlockSize, newBlockSize);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + blockSize);  //@A8C\n    }\n\n    //@cc1\n    /**\n     * This method sets concurrent access resolution.  This method overrides the setting of ConcurrentAccessResolution on the datasource or connection\n     * URL properties.  This method has no effect on\n     * IBM i V6R1 or earlier.\n     * The possible values for this property are {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_NOT_SET}, \n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_USE_CURRENTLY_COMMITTED}, \n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_WAIT_FOR_OUTCOME} and\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_SKIP_LOCKS}, \n     * with the property defaulting to {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_NOT_SET}.  \n     * Setting this property to default exhibits the default behavior on the servers  \n     * i.e., the semantic applied for read \n     * transactions to avoid locks will be determined by the server.          \n     *\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_USE_CURRENTLY_COMMITTED} specifies that driver will flow USE CURRENTLY COMMITTED \n     * to server.  Whether CURRENTLY COMMITTED will actually be in effect is\n     * ultimately determined by server. \n     *\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_WAIT_FOR_OUTCOME} specifies that driver will flow WAIT FOR OUTCOME\n     * to server.  This will disable the CURRENTLY COMMITTED behavior at the server,\n     * if enabled, and the server will wait for the commit or rollback of data in the process of\n     * being updated.  \n     *   \n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_SKIP_LOCKS} specifies that driver will flow SKIP LOCKS\n     * to server.  This directs the database manager to skip records in the case of record lock conflicts. \n     * \n     *  @param concurrentAccessResolution The current access resolution setting.  Possible valuse:\n     *  {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_NOT_SET}, \n     *  {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_USE_CURRENTLY_COMMITTED},\n     *  {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_WAIT_FOR_OUTCOME}, or\n     *  {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_SKIP_LOCKS}\n     */\n    public void setConcurrentAccessResolution (int concurrentAccessResolution)\n    {\n        String property = \"concurrentAccessResolution\";\n\n        Integer oldValue = new Integer(getConcurrentAccessResolution());\n        Integer newValue = new Integer(concurrentAccessResolution);\n\n        validateProperty(property, newValue.toString(), JDProperties.CONCURRENT_ACCESS_RESOLUTION);\n\n        properties_.setString(JDProperties.CONCURRENT_ACCESS_RESOLUTION, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + concurrentAccessResolution );   \n    }\n    \n    //@C8A\n    /**\n    *  Sets the cursor sensitivity to be requested from the database.  If the resultSetType is \n    *  ResultSet.TYPE_FORWARD_ONLY or ResultSet.TYPE_SCROLL_SENSITIVE, the value of this property\n    *  will control what cursor sensitivity is requested from the database.  If the resultSetType\n    *  is ResultSet.TYPE_SCROLL_INSENSITIVE, this property will be ignored.\n    *\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \"asensitive\"\n    *    <li> \"insensitive\"\n    *    <li> \"sensitive\"\n    *  </ul>\n    *  The default is \"asensitive\".\n    *\n    *  This property is ignored when connecting to systems\n    *  running OS/400 V5R1 and earlier. \n    **/\n    public void setCursorSensitivity(String cursorSensitivity)\n    {\n        String property = \"cursorSensitivity\";\n\n        String oldCursorSensitivity = getCursorSensitivity();\n        String newCursorSensitivity = cursorSensitivity;\n\n        validateProperty(property, newCursorSensitivity, JDProperties.CURSOR_SENSITIVITY);\n\n        properties_.setString(JDProperties.CURSOR_SENSITIVITY, cursorSensitivity);\n        changes_.firePropertyChange(property, oldCursorSensitivity, newCursorSensitivity);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + cursorSensitivity);\n    }\n\n\n    /**\n    *  Sets whether the cursor is held.\n    *  @param cursorHold true if the cursor is held; false otherwise.  The default value is true.\n    **/\n    public void setCursorHold(boolean cursorHold)\n    {\n        String property = \"cursorHold\";\n        Boolean oldHold = new Boolean(isCursorHold());\n        Boolean newHold = new Boolean(cursorHold);\n\n        if (cursorHold)\n            properties_.setString(JDProperties.CURSOR_HOLD, TRUE_);\n        else\n            properties_.setString(JDProperties.CURSOR_HOLD, FALSE_);\n\n        changes_.firePropertyChange(property, oldHold, newHold);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + cursorHold);  //@A8C\n    }\n\n    /**\n    *  Sets the database name.  \n    *  This property is ignored when connecting to systems\n    *  running OS/400 V5R1 and earlier.  \n    *  If a database name is specified it must exist in the relational \n    *  database directory on the system.  Use CL command WRKRDBDIRE \n    *  to view the directory.\n    *  The following criteria are used to determine\n    *  which database is accessed:  \n    *  <OL>\n    *  <LI>If a database name is specified, that database is used.  Attempts\n    *      to connect will fail if the database does not exist.\n    *  <LI>If special value *SYSBAS is specified, the system default database is used.\n    *  <LI>If a database name is not specified, the database specified\n    *      in the job description for the user profile is used.\n    *  <LI>If a database name is not specified and a database is not specified\n    *      in the job description for the user profile, the system default\n    *      database is used.   \n    *  </OL>\n    *  @param databaseName The database name or *SYSBAS.\n    **/\n    public void setDatabaseName(String databaseName)\n    {\n        String property = DATABASE_NAME;\n\n        if (databaseName == null)\n            throw new NullPointerException(property);\n\n        String old = getDatabaseName();\n\n        // @J2d databaseName_ = databaseName;\n        // @J2d changes_.firePropertyChange(property, old, databaseName);\n        // @J2d logProperty(\"database\", databaseName_);\n\n        properties_.setString(JDProperties.DATABASE_NAME, databaseName);      // @J2a\n        changes_.firePropertyChange(property, old, databaseName);             // @J2a\n                                                                              // @J2a\n        if (JDTrace.isTraceOn())                                              // @J2a\n            JDTrace.logInformation (this, property + \": \" + databaseName);   // @J2a \n    }\n\n    /**\n    *  Sets whether to use data compression.  The default value is true.\n    *  @param compression true if data compression is used; false otherwise.\n    **/\n    public void setDataCompression(boolean compression)\n    {\n        Boolean oldCompression = new Boolean(isDataCompression());\n        Boolean newCompression = new Boolean(compression);\n\n        if (compression)\n            properties_.setString(JDProperties.DATA_COMPRESSION, TRUE_);\n        else\n            properties_.setString(JDProperties.DATA_COMPRESSION, FALSE_);\n\n        changes_.firePropertyChange(\"dataCompression\", oldCompression, newCompression);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"dataCompression: \" + compression);  //@A8C\n    }\n\n    /**\n    *  Sets the data source name.\n    *  This property can be used for connection pooling implementations.\n    *  @param dataSourceName The data source name.\n    **/\n    public void setDataSourceName(String dataSourceName)\n    {\n        String property = DATASOURCE_NAME;\n\n        if (dataSourceName == null)\n            throw new NullPointerException(property);\n\n        String old = getDataSourceName();\n\n        dataSourceName_ = dataSourceName;\n\n        changes_.firePropertyChange(property, old, dataSourceName);\n\n        logProperty(\"dataSource\", dataSourceName_);\n    }\n\n    /**\n    *  Sets whether to use data truncation.  The default value is true.\n    *  @param truncation true if data truncation is used; false otherwise.\n    **/\n    public void setDataTruncation(boolean truncation)\n    {\n        Boolean oldTruncation = new Boolean(isDataTruncation());\n        Boolean newTruncation = new Boolean(truncation);\n\n        if (truncation)\n            properties_.setString(JDProperties.DATA_TRUNCATION, TRUE_);\n        else\n            properties_.setString(JDProperties.DATA_TRUNCATION, FALSE_);\n\n        changes_.firePropertyChange(\"dataTruncation\", oldTruncation, newTruncation);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"dataTruncation: \" + truncation);   //@A8C\n    }\n\n    /**\n    *  Sets the date format used in date literals within SQL statements.\n    *  @param dateFormat The date format.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \"mdy\"\n    *    <li> \"dmy\"\n    *    <li> \"ymd\"\n    *    <li> \"usa\"\n    *    <li> \"iso\"\n    *    <li> \"eur\"\n    *    <li> \"jis\"\n    *    <li> \"julian\"\n    *    <li> \"\"  (server job value) - default.\n    *  </ul>\n    *  The default is based on the server job.\n    **/\n    public void setDateFormat(String dateFormat)\n    {\n        String property = \"dateFormat\";\n\n        if (dateFormat == null)\n            throw new NullPointerException(property);\n        validateProperty(property, dateFormat, JDProperties.DATE_FORMAT);\n\n        String old = getDateFormat();\n\n        properties_.setString(JDProperties.DATE_FORMAT, dateFormat);\n\n        changes_.firePropertyChange(property, old, dateFormat);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + dateFormat);  //@A8C\n    }\n\n    /**\n    *  Sets the date separator used in date literals within SQL statements.\n    *  This property has no effect unless the \"data format\" property is set to:\n    *  \"julian\", \"mdy\", \"dmy\", or \"ymd\".\n    *  @param dateSeparator The date separator.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \"/\" (slash)\n    *    <li> \"-\" (dash)\n    *    <li> \".\" (period)\n    *    <li> \",\" (comma)\n    *    <li> \" \" (space)\n    *    <li> \"\"  (server job value) - default.\n    *  </ul>\n    *  The default value is based on the server job.\n    **/\n    public void setDateSeparator(String dateSeparator)\n    {\n        String property = \"dateSeparator\";\n        if (dateSeparator == null)\n            throw new NullPointerException(property);\n        validateProperty(property, dateSeparator, JDProperties.DATE_SEPARATOR);\n\n        String old = getDateSeparator();\n\n        properties_.setString(JDProperties.DATE_SEPARATOR, dateSeparator);\n\n        changes_.firePropertyChange(property, old, dateSeparator);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + dateSeparator);   //@A8C\n    }\n\n    //@DFA\n    /**\n    *  Sets the decfloat rounding mode.\n    *  @param decfloatRoundingMode The decfloat rounding mode.\n    *   <p>Valid values include:\n    *   <ul>\n    *   <li>\"half even\" - default\n    *   <li>\"half up\" \n    *   <li>\"down\" \n    *   <li>\"ceiling\" \n    *   <li>\"floor\" \n    *   <li>\"half down\" \n    *   <li>\"up\" \n    *   </ul>\n    **/\n    public void setDecfloatRoundingMode(String decfloatRoundingMode)\n    {\n        String property = \"decfloatRoundingMode\";\n        if (decfloatRoundingMode == null)\n            throw new NullPointerException(property);\n        validateProperty(property, decfloatRoundingMode, JDProperties.DECFLOAT_ROUNDING_MODE);\n\n        String old = getDecfloatRoundingMode();\n\n        properties_.setString(JDProperties.DECFLOAT_ROUNDING_MODE, decfloatRoundingMode);\n\n        changes_.firePropertyChange(property, old, decfloatRoundingMode);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + decfloatRoundingMode);\n    }\n     \n    /**\n    *  Sets the decimal separator used in numeric literals within SQL \n    *  statements.\n    *  @param decimalSeparator The decimal separator.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \".\" (period)\n    *    <li> \",\" (comma)\n    *    <li> \"\"  (server job value) - default.\n    *  </ul>\n    *  The default value is based on the server job.\n    **/\n    public void setDecimalSeparator(String decimalSeparator)\n    {\n        String property = \"decimalSeparator\";\n        if (decimalSeparator == null)\n            throw new NullPointerException(property);\n        validateProperty(property, decimalSeparator, JDProperties.DECIMAL_SEPARATOR);\n\n        String old = getDecimalSeparator();\n\n        properties_.setString(JDProperties.DECIMAL_SEPARATOR, decimalSeparator);\n\n        changes_.firePropertyChange(property, old, decimalSeparator);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + decimalSeparator);    //@A8C\n    }\n\n    //@igwrn\n    /**\n    *  Sets the ignore warnings property.\n    *  @param ignoreWarnings Specifies a list of SQL states for which the driver should not create warning objects.\n    **/\n    public void setIgnoreWarnings(String ignoreWarnings)\n    {\n        String property = \"ignoreWarnings\";\n        if (ignoreWarnings == null)\n            throw new NullPointerException(property);\n \n        String old = getIgnoreWarnings();\n\n        properties_.setString(JDProperties.IGNORE_WARNINGS, ignoreWarnings);\n\n        changes_.firePropertyChange(property, old, ignoreWarnings);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + ignoreWarnings);\n    }\n    \n    /**\n    *  Sets the data source description.\n    *  @param description The description.\n    **/\n    public void setDescription(String description)\n    {\n        String property = DESCRIPTION;\n        if (description == null)\n            throw new NullPointerException(property);\n\n        String old = getDescription();\n\n        description_ = description;\n\n        changes_.firePropertyChange(property, old, description);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + description);  //@A8C\n    }\n\n    /**\n    *  Sets how the IBM i system sorts records before sending them to the client.\n    *  @param sort The sort value.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \"hex\" (base the sort on hexadecimal values)\n    *    <li> \"language\" (base the sort on the language set in the sort language property)\n    *    <li> \"table\" (base the sort on the sort sequence table set in the sort table property).\n    *  </ul>\n    *  The default value is \"hex\".\n    **/\n    public void setSort(String sort)\n    {\n        String property = \"sort\";\n        if (sort == null)\n            throw new NullPointerException(property);\n\n        //@JOB fix to allow \"sort=job\" but use default value\n        if(sort.equals(\"job\"))                 //@JOB\n        {                                      //@JOB\n            if (JDTrace.isTraceOn())           //@JOB\n                JDTrace.logInformation (this, property + \": \" + getSort() + \" (warning: \" + getSort() + \" will be used since sort=job is not valid)\");  //@JOB \n            return; //return and allow default setting to be used                                                  //@JOB\n        }                                     //@JOB\n\n\n        validateProperty(property, sort, JDProperties.SORT);\n        String old = getSort();\n\n        properties_.setString(JDProperties.SORT, sort);\n\n        changes_.firePropertyChange(property, old, sort);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + sort); //@A8C\n    }\n\n    /**\n    *  Sets the amount of detail to be returned in the message for errors\n    *  occurring on the IBM i system.\n    *  @param errors The error message level.\n    *  Valid values include: \"basic\" and \"full\".  The default value is \"basic\".\n    **/\n    public void setErrors(String errors)\n    {\n        String property = \"errors\";\n        if (errors == null)\n            throw new NullPointerException(property);\n        validateProperty(property, errors, JDProperties.ERRORS);\n\n        String old = getErrors();\n        properties_.setString(JDProperties.ERRORS, errors);\n\n        changes_.firePropertyChange(property, old, errors);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + errors);  //@A8C\n    }\n\n    /**\n    *  Sets whether to use extended dynamic support.  Extended dynamic\n    *  support provides a mechanism for caching dynamic SQL statements on\n    *  the IBM i system.  The first time a particular SQL statement is prepared, it is\n    *  stored in an SQL package on the system.  \n    *  If the package does not exist, it will be automatically created.\n    *  On subsequent prepares of the\n    *  same SQL statement, the system can skip a significant part of the\n    *  processing by using information stored in the SQL package.  If this\n    *  is set to \"true\", then a package name must be set using the \"package\"\n    *  property.\n    *  @param extendedDynamic If extended dynamic support is used; false otherwise.\n    *  The default value is not to use extended dynamic support.\n    **/\n    public void setExtendedDynamic(boolean extendedDynamic)\n    {\n        Boolean oldValue = new Boolean(isExtendedDynamic());\n        Boolean newValue = new Boolean(extendedDynamic);\n\n        if (extendedDynamic)\n            properties_.setString(JDProperties.EXTENDED_DYNAMIC, TRUE_);\n        else\n            properties_.setString(JDProperties.EXTENDED_DYNAMIC, FALSE_);\n\n        changes_.firePropertyChange(\"extendedDynamic\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"extendedDynamic: \" + extendedDynamic);  //@A8C\n    }\n\n    // @C3A\n    /**\n    *  Sets whether the driver should request extended metadata from the\n    *  IBM i system.  This property is ignored when connecting to systems\n    *  running OS/400 V5R1 and earlier. \n    *  If this property is set to true and connecting to a system running\n    *  OS/400 V5R2 or IBM i, the accuracy of the information \n    *  that is returned from ResultSetMetaData methods getColumnLabel(int),\n    *  isReadOnly(int), isSearchable(int), and isWriteable(int) will be increased.\n    *  In addition, the ResultSetMetaData method getSchemaName(int) will be supported with this \n    *  property set to true.  However, performance will be slower with this \n    *  property on.  Leave this property set to its default (false) unless you\n    *  need more specific information from those methods.\n    *\n    *  For example, without this property turned on, isSearchable(int) will \n    *  always return true even though the correct answer may be false because \n    *  the driver does not have enough information from the system to make a judgment.  Setting \n    *  this property to true forces the driver to get the correct data from the system.\n    *\n    *  @param extendedMetaData True to request extended metadata from the system, false otherwise.\n    *  The default value is false.\n    **/\n    public void setExtendedMetaData(boolean extendedMetaData)\n    {\n        Boolean oldValue = new Boolean(isExtendedMetaData());\n        Boolean newValue = new Boolean(extendedMetaData);\n\n        if (extendedMetaData)\n            properties_.setString(JDProperties.EXTENDED_METADATA, TRUE_);\n        else\n            properties_.setString(JDProperties.EXTENDED_METADATA, FALSE_);\n\n        changes_.firePropertyChange(\"extendedMetaData\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, \"extendedMetaData: \" + extendedMetaData);\n    }\n    \n    //@dup\n    /**\n     *  Sets whether the driver should request extended metadata from the\n     *  IBM i system.  This property is ignored when connecting to systems\n     *  running OS/400 V5R1 and earlier. \n     *  If this property is set to true and connecting to a system running\n     *  OS/400 V5R2 or IBM i, the accuracy of the information \n     *  that is returned from ResultSetMetaData methods getColumnLabel(int),\n     *  isReadOnly(int), isSearchable(int), and isWriteable(int) will be increased.\n     *  In addition, the ResultSetMetaData method getSchemaName(int) will be supported with this \n     *  property set to true.  However, performance will be slower with this \n     *  property on.  Leave this property set to its default (false) unless you\n     *  need more specific information from those methods.\n     *\n     *  For example, without this property turned on, isSearchable(int) will \n     *  always return true even though the correct answer may be false because \n     *  the driver does not have enough information from the system to make a judgment.  Setting \n     *  this property to true forces the driver to get the correct data from the system.\n     *\n     *  @param extendedMetaData True to request extended metadata from the system, false otherwise.\n     *  The default value is false.\n     *  Note:  this method is the same as setExtendedMetaData() so that it corresponds to the connection property name\n     **/\n    public void setExtendedMetadata(boolean extendedMetaData)\n    {\n        setExtendedMetaData(extendedMetaData);\n    }\n\n\n    // @W1a new method\n    /**\n    *  Sets whether to fully open a file when performing a query.\n    *  By default the IBM i system optimizes opens so they perform better.\n    *  In most cases optimization functions correctly and improves\n    *  performance.  Running a query repeatedly\n    *  when a database performance monitor is turned on may fail\n    *  because of the optimization, however.\n    *  Leave this property set to its default (false) until\n    *  you experience errors running queries with monitors\n    *  turned on.  At that time set the property to true which\n    *  will disable the optimization.\n    *  @param fullOpen True to fully open a file (turn off optimizations), false\n    *          to allow optimizations.  The default value is false.\n    **/\n    public void setFullOpen(boolean fullOpen)\n    {\n        Boolean oldValue = new Boolean(isFullOpen());\n        Boolean newValue = new Boolean(fullOpen);\n\n        if (fullOpen)\n            properties_.setString(JDProperties.FULL_OPEN, TRUE_);\n        else\n            properties_.setString(JDProperties.FULL_OPEN, FALSE_);\n\n        changes_.firePropertyChange(\"fullOpen\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, \"fullOpen: \" + fullOpen);\n    }\n\n    //@KBL\n    /**\n    *  Sets whether input locators are allocated as hold locators.\n    *  @param value true if locators should be allocated as hold locators; false otherwise.\n    *  The default value is true.\n    **/\n    public void setHoldInputLocators(boolean value)\n    {\n        String property = \"holdInputLocators\";\n        Boolean oldValue = new Boolean(isHoldInputLocators());\n        Boolean newValue = new Boolean(value);\n\n        if (value)\n            properties_.setString(JDProperties.HOLD_LOCATORS, TRUE_);\n        else\n            properties_.setString(JDProperties.HOLD_LOCATORS, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + value);      \n    }   \n       \n    //@KBL\n    /**\n    *  Sets whether statements should remain open until a transaction boundary when autocommit is off\n    *  and they are associated with Lob locators.\n    *  @param value true if statements should remain open; false otherwise.\n    *  The default value is false.\n    **/\n    public void setHoldStatements(boolean value)\n    {\n        String property = \"holdStatements\";\n        Boolean oldValue = new Boolean(isHoldStatements());\n        Boolean newValue = new Boolean(value);\n\n        if (value)\n            properties_.setString(JDProperties.HOLD_STATEMENTS, TRUE_);\n        else\n            properties_.setString(JDProperties.HOLD_STATEMENTS, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + value);      \n    }\n    \n    //@dmy\n    /**\n    *  Indicates whether the temporary fix for JVM 1.6 is enabled.\n    *  @param value true if JVM 1.6 fix is enabled; false otherwise.\n    *  The default value is true.\n    **/\n    public void setJvm16Synchronize(boolean value)\n    {\n        String property = \"jvm16 synchronize\";\n        Boolean oldValue = new Boolean(isJvm16Synchronize());\n        Boolean newValue = new Boolean(value);\n\n        if (value)\n            properties_.setString(JDProperties.JVM16_SYNCHRONIZE, TRUE_);\n        else\n            properties_.setString(JDProperties.JVM16_SYNCHRONIZE, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + value);      \n    }\n\n    // @A1A\n    /**\n    *  Sets whether to delay closing cursors until subsequent requests.\n    *  @param lazyClose true to delay closing cursors until subsequent requests; false otherwise.\n               The default value is false.\n    **/\n    public void setLazyClose(boolean lazyClose)\n    {\n        Boolean oldValue = new Boolean(isLazyClose());\n        Boolean newValue = new Boolean(lazyClose);\n\n        if (lazyClose)\n            properties_.setString(JDProperties.LAZY_CLOSE, TRUE_);\n        else\n            properties_.setString(JDProperties.LAZY_CLOSE, FALSE_);\n\n        changes_.firePropertyChange(\"lazyClose\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"lazyClose: \" + lazyClose);  //@A8C\n    }\n\n    /**\n    *  Sets the libraries to add to the server job's library list.\n    *  The libraries are delimited by commas or spaces, and\n    *  \"*LIBL\" may be used as a place holder for the server job's\n    *  current library list.  The library list is used for resolving\n    *  unqualified stored procedure calls and finding schemas in\n    *  DatabaseMetaData catalog methods.  If \"*LIBL\" is not specified,\n    *  the specified libraries will replace the server job's\n    *  current library list.\n    *  @param libraries The library list.\n    **/\n    public void setLibraries(String libraries)\n    {\n        String property = \"libraries\";\n        if (libraries == null)\n            throw new NullPointerException(\"libraries\");\n\n        String old = getLibraries();\n        properties_.setString(JDProperties.LIBRARIES, libraries);\n\n        changes_.firePropertyChange(property, old, libraries);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + libraries);  //@A8C\n    }\n\n    /**\n    *  Sets the maximum LOB (large object) size in bytes that\n    *  can be retrieved as part of a result set.  LOBs that are larger\n    *  than this threshold will be retrieved in pieces using extra\n    *  communication to the IBM i system.  Larger LOB thresholds will reduce\n    *  the frequency of communication to the system, but will download\n    *  more LOB data, even if it is not used.  Smaller LOB thresholds may\n    *  increase frequency of communication to the system, but will only\n    *  download LOB data as it is needed.\n    *\n    *  @param threshold The lob threshold.  Valid range is 0-16777216.\n    *  The default value is 32768.\n    **/\n    public void setLobThreshold(int threshold)\n    {\n        String property = \"threshold\";\n        if (threshold < 0 || threshold > MAX_THRESHOLD)\n            throw new ExtendedIllegalArgumentException(property, ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n\n        Integer oldValue = new Integer(getLobThreshold());\n        Integer newValue = new Integer(threshold);\n\n        properties_.setString(JDProperties.LOB_THRESHOLD, new Integer(threshold).toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + threshold);  //@A8C\n    }\n\n    /**\n    *  Sets the maximum time in seconds that this data source can wait while attempting to connect to a database.\n    *  A value of zero specifies that the timeout is the system default if one exists; otherwise it specifies that\n    *  there is no timeout. The default value is initially zero.\n    *  @param timeout The login timeout in seconds.\n    **/\n    public void setLoginTimeout(int timeout) throws SQLException\n    {\n        \n        //@STIMEOUT setSoTimeout(timeout * 1000);    //@K5A  setSoTimeout takes milliseconds as a parameter //@STIMEOUT separate login and socket timeout into two separtate properties\n        sockProps_.setLoginTimeout(timeout * 1000); //@st3\n        String property = \"loginTimeout\";                                               //@K5A\n\n        Integer oldValue = new Integer(getLoginTimeout());                              //@K5A\n        Integer newValue = new Integer(timeout);                                        //@K5A\n\n        properties_.setString(JDProperties.LOGIN_TIMEOUT, newValue.toString());         //@K5A\n\n        changes_.firePropertyChange(property, oldValue, newValue);                      //@K5A\n\n        if (JDTrace.isTraceOn())                                                        //@K5A\n            JDTrace.logInformation (this, property + \": \" + timeout);                   //@K5A\n\n        //@K5D JDError.throwSQLException (this, JDError.EXC_FUNCTION_NOT_SUPPORTED);\n    }\n\n    /**\n    *  Sets the log writer for this data source.\n    *  @param writer The log writer; to disable, set to null.\n    *  @exception SQLException If a database error occurs.\n    **/\n    public void setLogWriter(PrintWriter writer) throws SQLException\n    {\n        String property = \"writer\";\n\n        //@C4D if (writer == null)\n        //@C4D    throw new NullPointerException(property);\n\n        PrintWriter old = getLogWriter();\n        writer_ = writer;\n        changes_.firePropertyChange(property, old, writer);\n\n        if (writer == null)         //@C4A\n        {                           //@C4A\n            log_ = null;            //@C4A\n            return;                 //@C4A\n        }                           //@C4A\n\n        log_ = new EventLog(writer);\n    }\n\n    //@PDA\n    /**                                                               \n    *  Sets how to retrieve DatabaseMetaData.\n    *  If set to 0, database metadata will be retrieved through the ROI data flow.  \n    *  If set to 1, database metadata will be retrieved by calling system stored procedures. \n    *  The methods that currently are available through stored procedures are:\n    *  getColumnPrivileges\n    *  @param mds The setting for metadata source\n    *  The default value is 1.\n    **/\n    public void setMetaDataSource(int mds)\n    {\n        String property = \"metaDataSource\";\n\n        Integer oldValue = new Integer(getMetaDataSource());\n        Integer newValue = new Integer(mds);\n\n        properties_.setString(JDProperties.METADATA_SOURCE, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + mds);\n    }\n    \n    \n    //@dup\n    /**                                                               \n     *  Sets how to retrieve DatabaseMetaData.\n     *  If set to 0, database metadata will be retrieved through the ROI data flow.  \n     *  If set to 1, database metadata will be retrieved by calling system stored procedures. \n     *  The methods that currently are available through stored procedures are:\n     *  getColumnPrivileges\n     *  @param mds The setting for metadata source\n     *  The default value is 1.\n     *  Note:  this method is the same as setMetaDataSource() so that it corresponds to the connection property name\n     **/\n    public void setMetadataSource(int mds)\n    {\n        setMetaDataSource(mds);\n    }\n     \n    \n    /**\n    *  Sets the naming convention used when referring to tables.\n    *  @param naming The naming convention.  Valid values include: \"sql\" (e.g. schema.table)\n    *  and \"system\" (e.g. schema/table).  The default value is \"sql\".\n    **/\n    public void setNaming(String naming)\n    {\n        String property = \"naming\";\n        if (naming == null)\n            throw new NullPointerException(\"naming\");\n        validateProperty(property, naming, JDProperties.NAMING);\n\n        String old = getNaming();\n        properties_.setString(JDProperties.NAMING, naming);\n\n        changes_.firePropertyChange(property, old, naming);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + naming);  //@A8C\n    }\n\n    /**\n    *  Sets the base name of the SQL package.  Note that only the\n    *  first six characters are used to generate the name of the SQL package on the IBM i system.  \n    *  This property has no effect unless\n    *  the extended dynamic property is set to true.  In addition, this property\n    *  must be set if the extended dynamic property is set to true.\n    *  @param packageName The base name of the SQL package.\n    **/\n    public void setPackage(String packageName)\n    {\n        String property = \"packageName\";\n        if (packageName == null)\n            throw new NullPointerException(property);\n\n        String old = getPackage();\n        properties_.setString(JDProperties.PACKAGE, packageName);\n\n        changes_.firePropertyChange(property, old, packageName);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + packageName);  //@A8C\n    }\n\n    /**\n    *  Sets whether to add newly prepared statements to the SQL package \n    *  specified on the \"package\" property.  This property\n    *  has no effect unless the extended dynamic property is set to true.\n    *  @param add If newly prepared statements should be added to the SQL package specified on \n    *  the \"package\" property; false otherwise.\n    *  The default value is true.\n    **/\n    public void setPackageAdd(boolean add)\n    {\n        Boolean oldValue = new Boolean(isPackageAdd());\n        Boolean newValue = new Boolean(add);\n\n        if (add)\n            properties_.setString(JDProperties.PACKAGE_ADD, TRUE_);\n        else\n            properties_.setString(JDProperties.PACKAGE_ADD, FALSE_);\n\n        changes_.firePropertyChange(\"packageAdd\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"packageAdd: \" + add);  //@A8C\n    }\n\n    /**\n    *  Sets whether to cache a subset of the SQL package information in client memory.  \n    *  Caching SQL packages locally\n    *  reduces the amount of communication to the IBM i system for prepares and describes.  This\n    *  property has no effect unless the extended dynamic property is set to true.\n    *  @param cache If caching is used; false otherwise.  The default value is false.\n    **/\n    public void setPackageCache(boolean cache)\n    {\n        Boolean oldValue = new Boolean(isPackageCache());\n        Boolean newValue = new Boolean(cache);\n\n        if (cache)\n            properties_.setString(JDProperties.PACKAGE_CACHE, TRUE_);\n        else\n            properties_.setString(JDProperties.PACKAGE_CACHE, FALSE_);\n\n        changes_.firePropertyChange(\"packageCache\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"packageCache: \" + cache);  //@A8C\n    }\n\n\n    //@C6C Changed javadoc since package clearing is now done automatically\n    //@C6C by the database.\n    /**\n    *  Sets whether to clear SQL packages when they become full.  This method\n    *  has been deprecated.  Package clearing and the decision for the \n    *  threshold where package clearing is needed is now handled\n    *  automatically by the database.  \n    *  @param clear If the SQL package are cleared when full; false otherwise.\n    *  @deprecated\n    **/\n    public void setPackageClear(boolean clear)\n    {\n        //@C6D Package clearing and the decision for the \n        //@C6D threshold where package clearing is needed is now handled\n        //@C6D automatically by the database.\n\n        //@C6D Boolean oldValue = new Boolean(isPackageClear());\n        //@C6D Boolean newValue = new Boolean(clear);\n\n        //@C6D String value = null;\n        //@C6D if (clear)\n        //@C6D     properties_.setString(JDProperties.PACKAGE_CLEAR, TRUE_);\n        //@C6D else\n        //@C6D     properties_.setString(JDProperties.PACKAGE_CLEAR, FALSE_);\n\n        //@C6D changes_.firePropertyChange(\"packageClear\", oldValue, newValue);\n\n        //@C6D if (JDTrace.isTraceOn()) //@A8C\n        //@C6D     JDTrace.logInformation (this, \"packageClear: \" + clear);  //@A8C\n    }\n\n\n    /**\n    *  Sets the type of SQL statement to be stored in the SQL package.  This can\n    *  be useful to improve the performance of complex join conditions.  This\n    *  property has no effect unless the extended dynamic property is set to true.\n    *  @param packageCriteria The type of SQL statement.\n    *  Valid values include: \"default\" (only store SQL statements with parameter\n    *  markers in the package), and \"select\" (store all SQL SELECT statements\n    *  in the package).  The default value is \"default\".\n    **/\n    public void setPackageCriteria(String packageCriteria)\n    {\n        String property = \"packageCriteria\";\n\n        if (packageCriteria == null)\n            throw new NullPointerException(property);\n        validateProperty(property, packageCriteria, JDProperties.PACKAGE_CRITERIA);\n\n        String old = getPackageCriteria();\n        properties_.setString(JDProperties.PACKAGE_CRITERIA, packageCriteria);\n\n        changes_.firePropertyChange(property, old, packageCriteria);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + packageCriteria);  //@A8C\n    }\n\n    /**\n    *  Sets the action to take when SQL package errors occur.  When an SQL package\n    *  error occurs, the driver will optionally throw an SQLException or post a\n    *  warning to the Connection, based on the value of this property.  This property\n    *  has no effect unless the extended dynamic property is set to true.\n    *  @param packageError The action when SQL errors occur.\n    *  Valid values include: \"exception\", \"warning\", and \"none\".  The default value is \"warning\".\n    **/\n    public void setPackageError(String packageError)\n    {\n        String property = \"packageError\";\n        if (packageError == null)\n            throw new NullPointerException(property);\n        validateProperty(property, packageError, JDProperties.PACKAGE_ERROR);\n\n        String old = getPackageError();\n        properties_.setString(JDProperties.PACKAGE_ERROR, packageError);\n\n        changes_.firePropertyChange(property, old, packageError);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + packageError);   //@A8C\n    }\n    /**\n    *  Sets the library for the SQL package.  This property has no effect unless\n    *  the extended dynamic property is set to true.\n    *  @param packageLibrary The SQL package library.  The default package library is \"QGPL\".\n    **/\n    public void setPackageLibrary(String packageLibrary)\n    {\n        String property = \"packageLibrary\";\n        if (packageLibrary == null)\n            throw new NullPointerException(property);\n\n        String old = getPackageLibrary();\n        properties_.setString(JDProperties.PACKAGE_LIBRARY, packageLibrary);\n\n        changes_.firePropertyChange(property, old, packageLibrary);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + packageLibrary);  //@A8C\n    }\n\n    /**\n    *  Sets the database password.\n    *  @param password The password.\n    **/\n    public void setPassword(String password)\n    {\n        as400_.setPassword(password);\n        serialPWBytes_ = xpwConfuse(password);                  //@J3a\n        log(ResourceBundleLoader.getText(\"AS400_JDBC_DS_PASSWORD_SET\"));     //@A9C\n    }\n\n    /**\n    *  Sets whether to prefetch data upon executing a SELECT statement.\n    *  This will increase performance when accessing the initial rows in the result set.\n    *  @param prefetch If prefetch is used; false otherwise.\n    *  The default value is to prefectch data.\n    **/\n    public void setPrefetch(boolean prefetch)\n    {\n        Boolean oldValue = new Boolean(isPrefetch());\n        Boolean newValue = new Boolean(prefetch);\n\n        if (prefetch)\n            properties_.setString(JDProperties.PREFETCH, TRUE_);\n        else\n            properties_.setString(JDProperties.PREFETCH, FALSE_);\n\n        changes_.firePropertyChange(\"prefetch\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"prefetch: \" + prefetch);      //@A8C\n    }\n\n    /**\n    *  Sets whether the user should be prompted if a user name or password is\n    *  needed to connect to the IBM i system.  If a connection can not be made\n    *  without prompting the user, and this property is set to false, then an\n    *  attempt to connect will fail.\n    *  @param prompt true if the user is prompted for signon information; false otherwise.\n    *  The default value is false.\n    **/\n    public void setPrompt(boolean prompt)\n    {\n        Boolean oldValue = new Boolean(isPrompt());\n        Boolean newValue = new Boolean(prompt);\n\n        if (prompt)\n            properties_.setString(JDProperties.PROMPT, TRUE_);\n        else\n            properties_.setString(JDProperties.PROMPT, FALSE_);\n\n        try\n        {                                     //@C2A  \n            as400_.setGuiAvailable(prompt);   //@C2A\n        }                                     //@C2A\n        catch (PropertyVetoException vp)      //@C2A\n        { /* ignore */                        //@C2A\n        }                                     //@C2A\n\n        changes_.firePropertyChange(\"prompt\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"prompt: \" + prompt);     //@A8C\n    }\n\n    // @F0D - Removed unused method\n    ///**\n    //*  Sets the JDBC properties.\n    //*  @param Properties The JDBC properties list.\n    //**/\n    //void setProperties(Reference reference)\n    //{\n    //    /*\n    //    *  Implementation note:  This method is called from AS400JDBCObjectFactory.getObjectInstance\n    //    */\n    //    if (reference == null)\n    //        throw new NullPointerException(\"reference\");\n    // \n    //    Properties properties = new Properties();\n    //\n    //    Enumeration list = reference.getAll();\n    //    while (list.hasMoreElements())\n    //    {\n    //        StringRefAddr refAddr = (StringRefAddr)list.nextElement();\n    //        String property = refAddr.getType();\n    //        String value = (String)reference.get(property).getContent();\n    //\n    //        if (property.equals(DATABASE_NAME))                         // constant identifiers were used to store in JNDI.\n    //            setDatabaseName(value);\n    //        else if (property.equals(DATASOURCE_NAME))\n    //            setDataSourceName(value);\n    //        else if (property.equals(DESCRIPTION))\n    //            setDescription(value);\n    //        else if (property.equals(SERVER_NAME))\n    //            setServerName(value);\n    //        else if (property.equals(USER))\n    //            setUser(value);\n    //        else if (property.equals(PASSWORD)) {\n    //            // get the password back from the serialized char[]\n    //            serialPWBytes_ = value.toCharArray();\n    //            // decode the password and set it on the as400\n    //            as400_.setPassword(xpwDeconfuse(serialPWBytes_));\n    //        }\n    //        else if (property.equals(KEY_RING_NAME)) {\n    //            // set the key ring name\n    //            serialKeyRingName_ = value;\n    //        }\n    //        else if (property.equals(KEY_RING_PASSWORD)) {\n    //            // get the key ring password back from the serialized char[]\n    //            if (value != null)\n    //                serialKeyRingPWBytes_ = value.toCharArray();\n    //        }\n    //        else if (property.equals(SECURE)) {\n    //            // set the isSecure_ flag\n    //            isSecure_ = value.equals(TRUE_) ? true : false;\n    //        }\n    //        else if (property.equals(SAVE_PASSWORD)) {\n    //            // set the savePasswordWhenSerialized_ flag\n    //            savePasswordWhenSerialized_ = value.equals(TRUE_) ? true : false;\n    //        }\n    //        else\n    //        {\n    //            properties.put(property, value);\n    //        }\n    //    }\n    //    properties_ = new JDProperties(properties, null);\n    //\n    //    // get the prompt property and set it back in the as400 object\n    //    String prmpt = properties_.getString(JDProperties.PROMPT);\n    //    if (prmpt != null && prmpt.equalsIgnoreCase(FALSE_))\n    //        setPrompt(false);\n    //    else if (prmpt != null && prmpt.equalsIgnoreCase(TRUE_))\n    //        setPrompt(true);\n    //\n    //    // if the system is secure create a SecureAS400 object\n    //    if (isSecure_) {\n    //        try\n    //        {\n    //            as400_ = new SecureAS400(as400_);\n    //            ((SecureAS400)as400_).setKeyRingName(serialKeyRingName_, xpwDeconfuse(serialKeyRingPWBytes_));\n    //        }\n    //        catch (PropertyVetoException pe)\n    //        { /* will never happen */\n    //        }\n    //    }\n    //}\n    \n    //@PDA\n    /**\n     * Sets the properties based on \";\" delimited string of properties, in same\n     * fashion as URL properties specified with\n     * DriverManager.getConnection(urlProperties). This method simply parses\n     * property string and then calls setPropertes(Properties). This method is\n     * intended as an enhancement so that the user does not have to write new\n     * code to call the setters for new/deleted properties.\n     * \n     * @param propertiesString list of \";\" delimited properties\n     */\n    public void setProperties(String propertiesString)\n    {\n        //use existing JDDatasourceURL to parse properties string like Connection does\n        //but first have to add dummy protocol so we can re-use parsing code\n        propertiesString = \"jdbc:as400://dummyhost;\" + propertiesString;\n        JDDataSourceURL dsURL = new JDDataSourceURL(propertiesString);\n        //returns only properties specified in propertyString.. (none of\n        // JDProperties defaults)\n        Properties properties = dsURL.getProperties();\n        setProperties(properties);\n    }\n\n    //@PDA\n    /**\n     * Sets the properties for this datasource. This method is intended as an\n     * enhancement so that the user does not have to write new code to call the\n     * setters for new/deleted properties.\n     * \n     * @param newProperties object containing updated property values\n     */\n    public void setProperties(Properties newProperties)\n    {\n        //1. turn on/off tracing per new props\n        //2. set needed AS400JDBCDataSource instance variables\n        //3. set socket props\n        //4. propagate newProperties to existing properties_ object\n\n        // Check first thing to see if the trace property is\n        // turned on. This way we can trace everything, including\n        // the important stuff like loading the properties.\n\n        // If trace property was set to true, turn on tracing. If trace property\n        // was set to false,\n        // turn off tracing. If trace property was not set, do not change.\n        if (JDProperties.isTraceSet(newProperties, null) == JDProperties.TRACE_SET_ON)\n        {\n            if (!JDTrace.isTraceOn())\n                JDTrace.setTraceOn(true);\n        } else if (JDProperties.isTraceSet(newProperties, null) == JDProperties.TRACE_SET_OFF)\n        {\n            if (JDTrace.isTraceOn())\n                JDTrace.setTraceOn(false);\n        }\n\n        // If toolbox trace is set to datastream. Turn on datastream tracing.\n        if (JDProperties.isToolboxTraceSet(newProperties, null) == JDProperties.TRACE_TOOLBOX_DATASTREAM)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceDatastreamOn(true);\n        }\n        // If toolbox trace is set to diagnostic. Turn on diagnostic tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) == JDProperties.TRACE_TOOLBOX_DIAGNOSTIC)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceDiagnosticOn(true);\n        }\n        // If toolbox trace is set to error. Turn on error tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) == JDProperties.TRACE_TOOLBOX_ERROR)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceErrorOn(true);\n        }\n        // If toolbox trace is set to information. Turn on information tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) == JDProperties.TRACE_TOOLBOX_INFORMATION)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceInformationOn(true);\n        }\n        // If toolbox trace is set to warning. Turn on warning tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) == JDProperties.TRACE_TOOLBOX_WARNING)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceWarningOn(true);\n        }\n        // If toolbox trace is set to conversion. Turn on conversion tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) == JDProperties.TRACE_TOOLBOX_CONVERSION)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceConversionOn(true);\n        }\n        // If toolbox trace is set to proxy. Turn on proxy tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) == JDProperties.TRACE_TOOLBOX_PROXY)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceProxyOn(true);\n        }\n        // If toolbox trace is set to pcml. Turn on pcml tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) == JDProperties.TRACE_TOOLBOX_PCML)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTracePCMLOn(true);\n        }\n        // If toolbox trace is set to jdbc. Turn on jdbc tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) == JDProperties.TRACE_TOOLBOX_JDBC)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceJDBCOn(true);\n        }\n        // If toolbox trace is set to all. Turn on tracing for all categories.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) == JDProperties.TRACE_TOOLBOX_ALL)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceAllOn(true);\n        }\n        // If toolbox trace is set to thread. Turn on thread tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) == JDProperties.TRACE_TOOLBOX_THREAD)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceThreadOn(true);\n        }\n        // If toolbox trace is set to none. Turn off tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) == JDProperties.TRACE_TOOLBOX_NONE)\n        {\n            if (Trace.isTraceOn())\n            {\n                Trace.setTraceOn(false);\n            }\n        }\n\n        //next we need to set instance vars (via setX() methods)\n        //or setup socket properties or set in properties_\n        //Note: this is similar to AS400JDBCDataSource(Reference reference)logic\n\n        Enumeration e = newProperties.keys();\n        while (e.hasMoreElements())\n        {\n            String propertyName = (String) e.nextElement();\n            String propertyValue = (String) newProperties.getProperty(propertyName);\n\n            int propIndex = JDProperties.getPropertyIndex(propertyName);\n\n            //some of the setter methods also set the properties_ below\n            if (propIndex == JDProperties.DATABASE_NAME)\n                setDatabaseName(propertyValue);\n            else if (propIndex == JDProperties.USER)\n                setUser(propertyValue);\n            else if (propIndex == JDProperties.PASSWORD)\n                setPassword(properties_.getString(JDProperties.PASSWORD));\n            else if (propIndex == JDProperties.SECURE)\n                setSecure(propertyValue.equals(TRUE_) ? true : false);\n            else if (propIndex == JDProperties.KEEP_ALIVE)\n                setKeepAlive(propertyValue.equals(TRUE_) ? true : false);\n            else if (propIndex == JDProperties.RECEIVE_BUFFER_SIZE)\n                setReceiveBufferSize(Integer.parseInt(propertyValue));\n            else if (propIndex == JDProperties.SEND_BUFFER_SIZE)\n                setSendBufferSize(Integer.parseInt(propertyValue));\n            else if (propIndex == JDProperties.PROMPT)\n                setPrompt(propertyValue.equals(TRUE_) ? true : false);\n            else if (propIndex == JDProperties.KEY_RING_NAME){\n                //at this time, decided to not allow this due to security and fact that there is no setKeyRingName() method\n                if (JDTrace.isTraceOn())\n                    JDTrace.logInformation(this, \"Property: \" + propertyName + \" can only be changed in AS400JDBCDataSource constructor\");  \n            } else if (propIndex == JDProperties.KEY_RING_PASSWORD){\n                //at this time, decided to not allow this due to security and fact that there is no setKeyRingPassword() method\n                if (JDTrace.isTraceOn())\n                    JDTrace.logInformation(this, \"Property: \" + propertyName + \" can only be changed in AS400JDBCDataSource constructor\");  \n            } else if (propIndex != -1)\n            {\n                properties_.setString(propIndex, propertyValue);\n            }\n        } \n\n    }\n    \n    /**\n    *  Sets the name of the proxy server.\n    *  @param proxyServer The proxy server.\n    **/\n    public void setProxyServer(String proxyServer)\n    {\n        String property = \"proxyServer\";\n        if (proxyServer == null)\n            throw new NullPointerException(property);\n\n        String old = getProxyServer();\n        properties_.setString(JDProperties.PROXY_SERVER, proxyServer);\n\n        changes_.firePropertyChange(property, old, proxyServer);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + proxyServer);  //@A8C\n    }\n\n    /**\n    *  Sets the source of the text for REMARKS columns in ResultSets returned\n    *  by DatabaseMetaData methods.\n    *  @param remarks The text source.\n    *  Valid values include: \"sql\" (SQL object comment) and \"system\" (IBM i object description).\n    *  The default value is \"system\".\n    **/\n    public void setRemarks(String remarks)\n    {\n        String property = \"remarks\";\n        if (remarks == null)\n            throw new NullPointerException(\"remarks\");\n        validateProperty(property, remarks, JDProperties.REMARKS);\n\n        String old = getRemarks();\n        properties_.setString(JDProperties.REMARKS, remarks);\n\n        changes_.firePropertyChange(property, old, remarks);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + remarks);  //@A8C\n    }\n\n    //@K94\n    /**\n    *  Sets whether the cursor is held after a rollback.\n    *  @param cursorHold true if the cursor is held; false otherwise.  The default value is false.\n    **/\n    public void setRollbackCursorHold(boolean cursorHold)\n    {\n        String property = \"rollbackCursorHold\";\n        Boolean oldHold = new Boolean(isRollbackCursorHold());\n        Boolean newHold = new Boolean(cursorHold);\n\n        if (cursorHold)\n            properties_.setString(JDProperties.ROLLBACK_CURSOR_HOLD, TRUE_);\n        else\n            properties_.setString(JDProperties.ROLLBACK_CURSOR_HOLD, FALSE_);\n\n        changes_.firePropertyChange(property, oldHold, newHold);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + cursorHold);  \n    }\n\n    /**\n    *  Sets the secondary URL to be used for a connection on the middle-tier's\n    *  DriverManager in a multiple tier environment, if it is different than\n    *  already specified.  This property allows you to use this driver to connect\n    *  to databases other than DB2 for IBM i. Use a backslash as an escape character\n    *  before backslashes and semicolons in the URL.\n    *  @param url The secondary URL.\n    **/\n    public void setSecondaryUrl(String url)\n    {\n        if (url == null)\n            throw new NullPointerException(\"url\");\n\n        String old = getSecondaryUrl();\n        properties_.setString(JDProperties.SECONDARY_URL, url);\n\n        changes_.firePropertyChange(\"secondaryUrl\", old, url);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"secondaryUrl: \" + url); //@A8C\n    }\n    \n    //@dup\n    /**\n     *  Sets the secondary URL to be used for a connection on the middle-tier's\n     *  DriverManager in a multiple tier environment, if it is different than\n     *  already specified.  This property allows you to use this driver to connect\n     *  to databases other than DB2 for IBM i. Use a backslash as an escape character\n     *  before backslashes and semicolons in the URL.\n     *  @param url The secondary URL.\n     *  Note:  this method is the same as setSecondaryUrl() so that it corresponds to the connection property name\n     **/\n    public void setSecondaryURL(String url)\n    {\n        setSecondaryUrl(url);\n    }\n\n    /**\n    *  Sets whether a Secure Socket Layer (SSL) connection is used to communicate\n    *  with the IBM i system.  SSL connections are only available when connecting to systems\n    *  at V4R4 or later.\n    *  @param secure true if Secure Socket Layer connection is used; false otherwise.\n    *  The default value is false.\n    **/\n    public void setSecure(boolean secure)\n    {\n        Boolean oldValue = new Boolean(isSecure());\n        Boolean newValue = new Boolean(secure);\n\n        //Do not allow user to change to not secure if they constructed the data source with \n        //a keyring.\n        if (!secure && isSecure_)                //@C2A\n        {                                        //@C2A\n            throw new ExtendedIllegalStateException(\"secure\", \n                                                    ExtendedIllegalStateException.PROPERTY_NOT_CHANGED);  //@C2A\n        }                                        //@C2A\n\n        // keep away the secure flag  // @F0A\n        isSecure_ = secure;           // @F0A\n\n        if (secure)\n            properties_.setString(JDProperties.SECURE, TRUE_);\n        else\n            properties_.setString(JDProperties.SECURE, FALSE_);\n\n        changes_.firePropertyChange(\"secure\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"secure: \" + secure);     //@A8C\n    }\n\n    //@pw3\n    /**\n     *  Sets whether to disallow \"\" and *current as user name and password.  \n     *  True indicates to disallow \"\" and *current for user name and password.\n     *  @param secureCurrentUser The secure current user setting.\n     **/\n    public void setSecureCurrentUser(boolean secureCurrentUser)\n    {\n        String property = \"secureCurrentUser\";\n        Boolean oldVal = new Boolean(isSecureCurrentUser());\n        Boolean newVal = new Boolean(secureCurrentUser);\n\n        if (secureCurrentUser)\n            properties_.setString(JDProperties.SECURE_CURRENT_USER, TRUE_);\n        else\n            properties_.setString(JDProperties.SECURE_CURRENT_USER, FALSE_);\n\n        changes_.firePropertyChange(property, oldVal, newVal);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + secureCurrentUser);  \n    }\n    \n    \n    /**\n    *  Sets the IBM i system name.\n    *  @param serverName The system name.\n    **/\n    public void setServerName(String serverName)\n    {\n        String property = SERVER_NAME;\n        if (serverName == null)\n            throw new NullPointerException(property);\n\n        String old = getServerName();\n        \n        // keep away the name to serialize    // @F0A\n        serialServerName_ = serverName;       // @F0A\n\n        try\n        {\n            as400_.setSystemName(serverName);\n        }\n        catch (PropertyVetoException pv)\n        { /* ignore */\n        }\n\n        changes_.firePropertyChange(property, old, serverName);\n\n        logProperty (\"server name\", as400_.getSystemName());\n    }\n\n\n    // @j1 new method\n    /**\n    *  Enables tracing of the JDBC server job.\n    *  If tracing is enabled, tracing is started when\n    *  the client connects to the IBM i system, and ends when the connection\n    *  is disconnected.  Tracing must be started before connecting to\n    *  the system since the client enables tracing only at connect time.\n    *\n    *  <P>\n    *  Trace data is collected in spooled files on the system.  Multiple\n    *  levels of tracing can be turned on in combination by adding\n    *  the constants and passing that sum on the set method.  For example,\n    *  <pre>\n    *  dataSource.setServerTraceCategories(AS400JDBCDataSource.SERVER_TRACE_START_DATABASE_MONITOR + AS400JDBCDataSource.SERVER_TRACE_SAVE_SERVER_JOBLOG);\n    *  </pre>\n    *  @param traceCategories level of tracing to start.\n    *  <p>Valid values include:\n    *  <ul>\n    *  <li>SERVER_TRACE_START_DATABASE_MONITOR - Start the database monitor on the JDBC server job.\n    *                               The numeric value of this constant is 2.\n    *  <LI>SERVER_TRACE_DEBUG_SERVER_JOB - Start debug on the JDBC server job.\n    *                         The numeric value of this constant is 4.\n    *  <LI>SERVER_TRACE_SAVE_SERVER_JOBLOG - Save the joblog when the JDBC server job ends.\n    *                           The numeric value of this constant is 8.\n    *  <LI>SERVER_TRACE_TRACE_SERVER_JOB - Start job trace on the JDBC server job.\n    *                         The numeric value of this constant is 16.\n    *  <LI>SERVER_TRACE_SAVE_SQL_INFORMATION - Save SQL information.\n    *                             The numeric value of this constant is 32.\n    *  </ul>\n    *  <P>\n    *  Tracing the JDBC server job will use significant amounts of system resources.\n    *  Additional processor resource is used to collect the data, and additional\n    *  storage is used to save the data.  Turn on tracing only to debug\n    *  a problem as directed by IBM service.\n    *\n    *\n    **/\n    public void setServerTraceCategories(int traceCategories)\n    {\n        String property = \"serverTrace\";\n\n        Integer oldValue = new Integer(getServerTraceCategories());\n        Integer newValue = new Integer(traceCategories);\n\n        properties_.setString(JDProperties.TRACE_SERVER, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + traceCategories);\n    }\n    \n    //@dup\n    /**\n     *  Enables tracing of the JDBC server job.\n     *  If tracing is enabled, tracing is started when\n     *  the client connects to the IBM i system, and ends when the connection\n     *  is disconnected.  Tracing must be started before connecting to\n     *  the system since the client enables tracing only at connect time.\n     *\n     *  <P>\n     *  Trace data is collected in spooled files on the system.  Multiple\n     *  levels of tracing can be turned on in combination by adding\n     *  the constants and passing that sum on the set method.  For example,\n     *  <pre>\n     *  dataSource.setServerTraceCategories(AS400JDBCDataSource.SERVER_TRACE_START_DATABASE_MONITOR + AS400JDBCDataSource.SERVER_TRACE_SAVE_SERVER_JOBLOG);\n     *  </pre>\n     *  @param traceCategories level of tracing to start.\n     *  <p>Valid values include:\n     *  <ul>\n     *  <li>SERVER_TRACE_START_DATABASE_MONITOR - Start the database monitor on the JDBC server job.\n     *                               The numeric value of this constant is 2.\n     *  <LI>SERVER_TRACE_DEBUG_SERVER_JOB - Start debug on the JDBC server job.\n     *                         The numeric value of this constant is 4.\n     *  <LI>SERVER_TRACE_SAVE_SERVER_JOBLOG - Save the joblog when the JDBC server job ends.\n     *                           The numeric value of this constant is 8.\n     *  <LI>SERVER_TRACE_TRACE_SERVER_JOB - Start job trace on the JDBC server job.\n     *                         The numeric value of this constant is 16.\n     *  <LI>SERVER_TRACE_SAVE_SQL_INFORMATION - Save SQL information.\n     *                             The numeric value of this constant is 32.\n     *  </ul>\n     *  <P>\n     *  Tracing the JDBC server job will use significant amounts of system resources.\n     *  Additional processor resource is used to collect the data, and additional\n     *  storage is used to save the data.  Turn on tracing only to debug\n     *  a problem as directed by IBM service.\n     *\n     * Note:  this method is the same as setServerTraceCategories() so that it corresponds to the connection property name\n     **/\n     public void setServerTrace(int traceCategories)\n     {\n         setServerTraceCategories(traceCategories);\n     }\n\n\n    // @A2A\n    /**\n    * Sets the JDBC driver implementation.\n    * This property has no\n    * effect if the \"secondary URL\" property is set.\n    * This property cannot be set to \"native\" if the\n    * environment is not an IBM i Java Virtual Machine.\n    * param driver The driver value.\n    *  <p>Valid values include:\n    *  <ul>\n    *  <li>\"toolbox\" (use the IBM Toolbox for Java JDBC driver)\n    *  <li>\"native\" (use the IBM Developer Kit for Java JDBC driver)\n    *  </ul>\n    *  The default value is \"toolbox\".\n    *  Note:  Not supported in a connection pool.\n    **/\n    public void setDriver(String driver)\n    {\n        String property = \"driver\";\n        if (driver == null)\n            throw new NullPointerException(property);\n\n        validateProperty(property, driver, JDProperties.DRIVER);\n        String old = getDriver();\n\n        properties_.setString(JDProperties.DRIVER, driver);\n\n        changes_.firePropertyChange(property, old, driver);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + driver);  //@A8C\n    }\n\n    // @J3 new method\n    /**\n    *  Sets whether to save the password locally with the rest of the properties when \n    *  this data source object is serialized.\n    *  <P>  \n    *  If the password is saved, it is up to the application to protect\n    *  the serialized form of the object because it contains all necessary\n    *  information to connect to the IBM i system.  The default is false.  It\n    *  is a security risk to save the password with the rest of the\n    *  properties so by default the password is not saved.  If the application\n    *  programmer chooses to accept this risk, set this property to true\n    *  to force the Toolbox to save the password with the other properties\n    *  when the data source object is serialized.  \n    *\n    *  @param savePassword true if the password is saved; false otherwise.\n    *  The default value is false\n    **/\n    public void setSavePasswordWhenSerialized(boolean savePassword)\n    {                                             \n        String property = \"savePasswordWhenSerialized\";            //@C5A\n\n        boolean oldValue = isSavePasswordWhenSerialized();         //@C5A\n        boolean newValue = savePassword;                           //@C5A\n\n        savePasswordWhenSerialized_ = savePassword;                        \n\n        changes_.firePropertyChange(property, oldValue, newValue); //@C5A\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, \"save password: \" + savePassword);\n    }\n\n\n    /**\n    *  Sets the three-character language id to use for selection of a sort sequence.\n    *  This property has no effect unless the sort property is set to \"language\".\n    *  @param language The three-character language id.\n    *  The default value is ENU.\n    **/\n    public void setSortLanguage(String language)\n    {\n        if (language == null)\n            throw new NullPointerException(\"language\");\n\n        String old = getSortLanguage();\n        properties_.setString(JDProperties.SORT_LANGUAGE, language);\n\n        changes_.firePropertyChange(\"sortLanguage\", old, language);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"sortLanguage: \" + language);  //@A8C\n    }\n\n    /**\n    *  Sets the library and file name of a sort sequence table stored on the\n    *  IBM i system.\n    *  This property has no effect unless the sort property is set to \"table\".\n    *  The default is an empty String (\"\").\n    *  @param table The qualified sort table name.\n    **/\n    public void setSortTable(String table)\n    {\n        if (table == null)\n            throw new NullPointerException(\"table\");\n\n        String old = getSortTable();\n        properties_.setString(JDProperties.SORT_TABLE, table);\n\n        changes_.firePropertyChange(\"sortTable\", old, table);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"sortTable: \" + table);  //@A8C\n    }\n\n    /**\n    *  Sets how the IBM i system treats case while sorting records.  This property \n    *  has no effect unless the sort property is set to \"language\".\n    *  @param sortWeight The sort weight.\n    *  Valid values include: \"shared\" (upper- and lower-case characters are sorted as the\n    *  same character) and \"unique\" (upper- and lower-case characters are sorted as\n    *  different characters).  The default value is \"shared\".\n    **/\n    public void setSortWeight(String sortWeight)\n    {\n        String property = \"sortWeight\";\n        if (sortWeight == null)\n            throw new NullPointerException(property);\n\n        validateProperty(property, sortWeight, JDProperties.SORT_WEIGHT);\n\n        String old = getSortWeight();\n        properties_.setString(JDProperties.SORT_WEIGHT, sortWeight);\n\n        changes_.firePropertyChange(property, old, sortWeight);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + sortWeight);  //@A8C\n    }\n\n    /**\n    *  Sets whether a thread is used.\n    *  @param threadUsed true if a thread is used; false otherwise.\n    *  The default value is true.\n    **/\n    public void setThreadUsed(boolean threadUsed)\n    {\n        Boolean oldValue = new Boolean(isThreadUsed());\n        Boolean newValue = new Boolean(threadUsed);\n\n        if (threadUsed)\n            properties_.setString(JDProperties.THREAD_USED, TRUE_);\n        else\n            properties_.setString(JDProperties.THREAD_USED, FALSE_);\n\n        try\n        {                                     \n            as400_.setThreadUsed(threadUsed);                       \n        }                                                            \n        catch (PropertyVetoException pve)                            \n        { /* Will never happen */                                    \n        }\n        \n        changes_.firePropertyChange(\"threadUsed\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"threadUsed: \" + threadUsed);  //@A8C\n    }\n\n    /**\n    *  Sets the time format used in time literals with SQL statements.\n    *  @param timeFormat The time format.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \"hms\"\n    *    <li> \"usa\"\n    *    <li> \"iso\"\n    *    <li> \"eur\"\n    *    <li> \"jis\"\n    *    <li> \"\"  (server job value) - default.\n    *  </ul>\n    *  The default value is based on the server job.\n    **/\n    public void setTimeFormat(String timeFormat)\n    {\n        String property = \"timeFormat\";\n        if (timeFormat == null)\n            throw new NullPointerException(property);\n        validateProperty(property, timeFormat, JDProperties.TIME_FORMAT);\n\n        String old = getTimeFormat();\n        properties_.setString(JDProperties.TIME_FORMAT, timeFormat);\n\n        changes_.firePropertyChange(property, old, timeFormat);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + timeFormat);  //@A8C\n    }\n\n    /**\n    *  Sets the time separator used in time literals within SQL statements.\n    *  This property has no effect unless the time format property is set to \"hms\".\n    *  @param timeSeparator The time separator.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \":\" (colon)\n    *    <li> \".\" (period)\n    *    <li> \",\" (comma)\n    *    <li> \" \" (space)\n    *    <li> \"\"  (server job value) - default.\n    *  </ul>\n    *  The default value is based on the server job.\n    **/\n    public void setTimeSeparator(String timeSeparator)\n    {\n        String property = \"timeSeparator\";\n        if (timeSeparator == null)\n            throw new NullPointerException(property);\n        validateProperty(property, timeSeparator, JDProperties.TIME_SEPARATOR);\n\n        String old = getTimeSeparator();\n        properties_.setString(JDProperties.TIME_SEPARATOR, timeSeparator);\n\n        changes_.firePropertyChange(property, old, timeSeparator);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + timeSeparator);   //@A8C\n    }\n\n    /**\n    *  Sets whether trace messages should be logged.  Trace messages are\n    *  useful for debugging programs that call JDBC.  However, there is a\n    *  performance penalty associated with logging trace messages, so this\n    *  property should only be set to true for debugging.  Trace messages\n    *  are logged to System.out.\n    *  @param trace true if trace message are logged; false otherwise.\n    *  The default value is false.\n    **/\n    public void setTrace(boolean trace)\n    {\n        Boolean oldValue = new Boolean(isTrace());\n        Boolean newValue = new Boolean(trace);\n\n        if (trace)\n            properties_.setString(JDProperties.TRACE, TRUE_);\n        else\n            properties_.setString(JDProperties.TRACE, FALSE_);\n\n        changes_.firePropertyChange(\"trace\", oldValue, newValue);\n\n        if (trace)\n        {\n            if (!JDTrace.isTraceOn ())\n                JDTrace.setTraceOn (true);\n        }\n        else\n            JDTrace.setTraceOn (false);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"trace: \" + trace);  //@A8C\n    }\n\n\n    /**\n    *  Sets the IBM i system's transaction isolation.\n    *  @param transactionIsolation The transaction isolation level.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \"none\"\n    *    <li> \"read uncommitted\"  - The default value.\n    *    <li> \"read committed\"\n    *    <li> \"repeatable read\"\n    *    <li> \"serializable\"\n    *  </ul>\n    **/\n    public void setTransactionIsolation(String transactionIsolation)\n    {\n        String property = \"transactionIsolation\";\n\n        if (transactionIsolation == null)\n            throw new NullPointerException(property);\n        validateProperty(property, transactionIsolation, JDProperties.TRANSACTION_ISOLATION);\n\n        String old = getTransactionIsolation();\n\n        properties_.setString(JDProperties.TRANSACTION_ISOLATION, transactionIsolation);\n\n        changes_.firePropertyChange(property, old, transactionIsolation);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + transactionIsolation);     //@A8C\n    }\n\n    /**\n    *  Sets whether binary data is translated.  If this property is set\n    *  to true, then BINARY and VARBINARY fields are treated as CHAR and\n    *  VARCHAR fields.\n    *  @param translate true if binary data is translated; false otherwise.\n    *  The default value is false.\n    **/\n    public void setTranslateBinary(boolean translate)\n    {\n        String property = \"translateBinary\";\n\n        Boolean oldValue = new Boolean(isTranslateBinary());\n        Boolean newValue = new Boolean(translate);\n\n        if (translate)\n            properties_.setString(JDProperties.TRANSLATE_BINARY, TRUE_);\n        else\n            properties_.setString(JDProperties.TRANSLATE_BINARY, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + translate);  //@A8C\n    }\n    \n    //@PDA\n    /**\n    *  Sets how Boolean objects are interpreted when setting the value \n    *  for a character field/parameter using the PreparedStatement.setObject(), \n    *  CallableStatement.setObject() or ResultSet.updateObject() methods.  Setting the \n    *  property to \"true\", would store the Boolean object in the character field as either \n    *  \"true\" or \"false\".  Setting the property to \"false\", would store the Boolean object \n    *  in the character field as either \"1\" or \"0\".\n    *  @param translate true if boolean data is translated; false otherwise.\n    *  The default value is true.\n    **/\n    public void setTranslateBoolean(boolean translate)\n    {\n        String property = \"translateBoolean\";\n\n        Boolean oldValue = new Boolean(isTranslateBoolean());\n        Boolean newValue = new Boolean(translate);\n\n        if (translate)\n            properties_.setString(JDProperties.TRANSLATE_BOOLEAN, TRUE_);\n        else\n            properties_.setString(JDProperties.TRANSLATE_BOOLEAN, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + translate);\n    }\n    \n\n    /**\n     *  Indicates whether blocking should be used for updates and delete.\n     *  @param value true if blocking is used for updates and deletes.\n     *  The default value is false.\n     **/\n     public void setUseBlockUpdate(boolean value)\n     {\n         String property = JDProperties.DO_UPDATE_DELETE_BLOCKING_  ;\n         Boolean oldValue = new Boolean(isUseBlockUpdate());\n         Boolean newValue = new Boolean(value);\n\n         if (value)\n             properties_.setString(JDProperties.DO_UPDATE_DELETE_BLOCKING, TRUE_);\n         else\n             properties_.setString(JDProperties.DO_UPDATE_DELETE_BLOCKING, FALSE_);\n\n         changes_.firePropertyChange(property, oldValue, newValue);\n\n         if (JDTrace.isTraceOn()) \n             JDTrace.logInformation (this, property + \": \" + value);      \n     }\n\n    \n    /**\n    *  Sets the database user.\n    *  @param user The user.\n    **/\n    public void setUser(String user)\n    {\n        String property = \"user\";\n\n        String old = getUser();\n\n        // save away the user to serialize    // @F0A\n        serialUserName_ = user;               // @F0A\n\n        try\n        {\n            as400_.setUserId(user);\n        }\n        catch (PropertyVetoException vp)\n        { /* ignore */\n        }\n\n        changes_.firePropertyChange(property, old, user);\n\n        logProperty (\"user\", as400_.getUserId());\n    }\n\n    //@K54\n    /**\n    *  Specifies whether variable-length fields should be compressed. \n    *  @param compress true if variable-length fields should be compressed; false otherwise.\n    *  The default value is true.\n    **/\n    public void setVariableFieldCompression(boolean compress)\n    {\n        String property = \"variableFieldCompression\";\n\n        Boolean oldValue = new Boolean(isVariableFieldCompression());\n        Boolean newValue = new Boolean(compress);\n\n        if (compress)\n            properties_.setString(JDProperties.VARIABLE_FIELD_COMPRESSION, TRUE_);\n        else\n            properties_.setString(JDProperties.VARIABLE_FIELD_COMPRESSION, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + compress);  \n    }\n\n    // @F1A Added the below methods to set socket options\n    /**\n    * Gets the socket keepalive option.\n    * @return The value of the socket keepalive option.\n    **/\n    public boolean getKeepAlive()\n    {\n        return sockProps_.isKeepAlive();\n    }\n\n    /**\n    * Gets the socket receive buffer size option.  NOTE: This does not get\n    * the actual receive buffer size, only the option which is used as a hint\n    * by the underlying socket code.\n    * @return The value of the socket receive buffer size option.\n    **/\n    public int getReceiveBufferSize()\n    {\n        return sockProps_.getReceiveBufferSize();\n    }\n\n    /**\n    * Gets the socket send buffer size option.  NOTE: This does not get\n    * the actual send buffer size, only the option which is used as a hint\n    * by the underlying socket code.\n    * @return The value of the socket send buffer size option.\n    **/\n    public int getSendBufferSize()\n    {\n        return sockProps_.getSendBufferSize();\n    }\n\n    /**\n    * Gets the socket linger option in seconds.\n    * @return The value of the socket linger option.\n    **/\n    public int getSoLinger()\n    {\n        return sockProps_.getSoLinger();\n    }\n\n    /**\n    * Gets the socket timeout option in milliseconds.\n    * @return The value of the socket timeout option.\n    **/\n    public int getSoTimeout()\n    {\n        return sockProps_.getSoTimeout();\n    }\n\n    /**\n    * Gets the socket TCP no delay option.\n    * @return The value of the socket TCP no delay option.\n    **/\n    public boolean getTcpNoDelay()\n    {\n        return sockProps_.isTcpNoDelay();\n    }\n\n    /**\n    * This property allows the turning on of socket keep alive.\n    * @param keepAlive The keepalive option value.\n    **/\n    public void setKeepAlive(boolean keepAlive)\n    {\n        sockProps_.setKeepAlive(keepAlive);\n    }\n\n    /**\n    * This property sets the receive buffer size socket option to the\n    * specified value. The receive buffer size option is used as a hint\n    * for the size to set the underlying network I/O buffers. Increasing\n    * the receive buffer size can increase the performance of network\n    * I/O for high-volume connection, while decreasing it can help reduce\n    * the backlog of incoming data.  This value must be greater than 0.\n    * @param size The socket receive buffer size option value.\n    **/\n    public void setReceiveBufferSize(int size)\n    {\n        sockProps_.setReceiveBufferSize(size);\n    }\n\n    /**\n    * This property sets the send buffer size socket option to the\n    * specified value. The send buffer size option is used by the\n    * platform's networking code as a hint for the size to set the\n    * underlying network I/O buffers.  This value must be greater\n    * than 0.\n    * @param size The socket send buffer size option value.\n    **/\n    public void setSendBufferSize(int size)\n    {\n        sockProps_.setSendBufferSize(size);\n    }\n\n    /**\n    * This property allows the turning on of socket linger with the\n    * specified linger time in seconds.  The maxium value for this\n    * property is platform specific.\n    * @param seconds The socket linger option value.\n    **/\n    public void setSoLinger(int seconds)\n    {\n        sockProps_.setSoLinger(seconds);\n    }\n\n    /**\n    * This property enables/disables socket timeout with the\n    * specified value in milliseconds.  A timeout value must be\n    * greater than zero, a value of zero for this property indicates\n    * infinite timeout.\n    * @param milliseconds The socket timeout option value.\n    **/\n    public void setSoTimeout(int milliseconds)\n    {\n        sockProps_.setSoTimeout(milliseconds);\n    }\n\n    //@STIMEOUT\n    /**\n     * This property enables/disables socket timeout with the\n     * specified value in milliseconds.  A timeout value must be\n     * greater than zero, a value of zero for this property indicates\n     * infinite timeout.\n     * @param milliseconds The socket timeout option value.\n     **/\n     public void setSocketTimeout(int milliseconds)\n     {\n         setSoTimeout(milliseconds);\n     }\n     \n    /**\n    * This property allows the turning on of the TCP no delay socket option.\n    * @param noDelay The socket TCP no delay option value.\n    **/\n    public void setTcpNoDelay(boolean noDelay)\n    {\n        sockProps_.setTcpNoDelay(noDelay);\n    }\n    // @F1A End of new socket option methods\n\n    // @M0A - added support for sending statements in UTF-16 and storing them in a UTF-16 package\n    /**\n    * Gets the package CCSID property, which indicates the\n    * CCSID in which statements are sent to the IBM i system and\n    * also the CCSID of the package they are stored in.\n    * Default value: 13488\n    * @return The value of the package CCSID property.\n    **/\n    public int getPackageCCSID()\n    {\n        return properties_.getInt(JDProperties.PACKAGE_CCSID);\n    }\n    \n    //@dup\n    /**\n     * Gets the package CCSID property, which indicates the\n     * CCSID in which statements are sent to the IBM i system and\n     * also the CCSID of the package they are stored in.\n     * Default value: 13488\n     * @return The value of the package CCSID property.\n     * Note:  this method is the same as getPackageCCSID() so that it corresponds to the connection property name\n     **/\n    public int getPackageCcsid()\n    {\n        return getPackageCCSID();\n    }\n\n    // @M0A\n    /**\n    * Sets the package CCSID property, which indicates the\n    * CCSID in which statements are sent to the IBM i system and\n    * also the CCSID of the package they are stored in.\n    * Recommended values:  1200(UTF-16)  and 13488 (UCS-2).  \n    * See <a href=\"BidiStringType.html\">BidiStringType</a> for Bidi considerations.\n    * Default value: 13488\n    * @param ccsid The package CCSID.\n    **/\n    public void setPackageCCSID(int ccsid)\n    {\n        String property = \"packageCCSID\";\n\n        Integer oldPackageCCSID = new Integer(getPackageCCSID());\n        Integer newPackageCCSID = new Integer(ccsid);\n\n        validateProperty(property, newPackageCCSID.toString(), JDProperties.PACKAGE_CCSID);\n\n        properties_.setString(JDProperties.PACKAGE_CCSID, newPackageCCSID.toString());\n\n        changes_.firePropertyChange(property, oldPackageCCSID, newPackageCCSID);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + ccsid);\n    }\n\n    //@dup\n    /**\n     * Sets the package CCSID property, which indicates the\n     * CCSID in which statements are sent to the IBM i system and\n     * also the CCSID of the package they are stored in.\n     * Recommended values:  1200(UTF-16)  and 13488 (UCS-2).  \n     * See <a href=\"BidiStringType.html\">BidiStringType</a> for Bidi considerations.\n     * Default value: 13488\n     * @param ccsid The package CCSID.\n     * Note:  this method is the same as setPackageCCSID() so that it corresponds to the connection property name\n     **/\n    public void setPackageCcsid(int ccsid)\n    {\n        setPackageCCSID(ccsid);\n    }\n     \n    // @M0A - added support for 63 digit decimal precision\n    /**\n    * Gets the minimum divide scale property.  This property ensures the scale\n    * of the result of decimal division is never less than its specified value.\n    * Valid values: 0-9.  0 is default.\n    * @return The minimum divide scale.\n    **/\n    public int getMinimumDivideScale()\n    {\n        return properties_.getInt(JDProperties.MINIMUM_DIVIDE_SCALE);\n    }\n\n    /** \n     * Gets the maximum block input rows.  This property indicates the\n     * number of rows sent to the database engine for a block insert\n     * operation.  Valid values: 1-32000.  32000 is default. \n     * @return The maximum block input rows \n     */\n    public int getMaximumBlockedInputRows() {\n    \treturn properties_.getInt(JDProperties.MAXIMUM_BLOCKED_INPUT_ROWS); \n    }\n    \n    // @M0A\n    /**\n    * Gets the maximum precision property. This property indicates the \n    * maximum decimal precision the IBM i system should use.\n    * Valid values: 31 or 63.  31 is default.\n    * @return The maximum precision.\n    **/\n    public int getMaximumPrecision()\n    {\n        return properties_.getInt(JDProperties.MAXIMUM_PRECISION);\n    }\n\n    // @M0A\n    /**\n    * Gets the maximum scale property.  This property indicates the\n    * maximum decimal scale the IBM i system should use.\n    * Valid values: 0-63.  31 is default.\n    * @return The maximum scale.\n    **/\n    public int getMaximumScale()\n    {\n        return properties_.getInt(JDProperties.MAXIMUM_SCALE);\n    }\n\n    // @M0A\n    /**\n    * Sets the minimum divide scale property.  This property ensures the scale\n    * of the result of decimal division is never less than its specified value.\n    * Valid values: 0-9.  0 is default.\n    * @param scale The minimum divide scale.\n    **/\n    public void setMinimumDivideScale(int scale)\n    {\n        String property = \"minimumDivideScale\";\n\n        Integer oldValue = new Integer(getMinimumDivideScale());\n        Integer newValue = new Integer(scale);\n\n        validateProperty(property, newValue.toString(), JDProperties.MINIMUM_DIVIDE_SCALE);\n\n        properties_.setString(JDProperties.MINIMUM_DIVIDE_SCALE, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + scale);\n    }\n\n    // @A6A \n    /**\n     * Sets the maximum blocked input rows.  This property indicates the \n     * maximum number of rows sent to the database engine for a blocked\n     * input operation.  Valid values:  1-32000.  32000 is the default\n     * @param maximumBlockedInputRows  The maximum number of input rows \n     */\n    public void setMaximumBlockedInputRows(int maximumBlockedInputRows)\n    {\n        String property = \"maximumBlockedInputRows\"; \n\n        Integer oldValue = new Integer(getMaximumBlockedInputRows());\n        Integer newValue = new Integer(maximumBlockedInputRows);\n\n        if (maximumBlockedInputRows < 0 || maximumBlockedInputRows > 32000) {\n        \tthrow new ExtendedIllegalArgumentException(property, ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n        if (maximumBlockedInputRows == 0) {\n        \tmaximumBlockedInputRows = 32000; \n        }\n\n        properties_.setString(JDProperties.MAXIMUM_BLOCKED_INPUT_ROWS, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + maximumBlockedInputRows);\n    }\n    \n    \n    // @M0A\n    /**\n    * Sets the maximum precision property. This property indicates the \n    * maximum decimal precision the IBM i system should use.\n    * Valid values: 31 or 63.  31 is default.\n    * @param precision The maximum precision.\n    **/\n    public void setMaximumPrecision(int precision)\n    {\n        String property = \"maximumPrecision\";\n\n        Integer oldValue = new Integer(getMaximumPrecision());\n        Integer newValue = new Integer(precision);\n\n        validateProperty(property, newValue.toString(), JDProperties.MAXIMUM_PRECISION);\n\n        properties_.setString(JDProperties.MAXIMUM_PRECISION, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + precision);\n    }\n\n    // @M0A\n    /**\n    * Sets the maximum scale property.  This property indicates the\n    * maximum decimal scale the IBM i system should use.\n    * Valid values: 0-63.  31 is default.\n    * @param scale The maximum scale.\n    **/\n    public void setMaximumScale(int scale)\n    {\n        String property = \"maximumScale\";\n\n        Integer oldValue = new Integer(getMaximumScale());\n        Integer newValue = new Integer(scale);\n\n        // validate the new value\n        validateProperty(property, newValue.toString(), JDProperties.MAXIMUM_SCALE);\n        \n        properties_.setString(JDProperties.MAXIMUM_SCALE, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + scale);\n    }\n\n    // @M0A - added support for hex constant parser option\n    /**\n    * Gets the translate hex property, which indicates how\n    * the parser will treat hexadecimal literals.\n    * @return The value of the translate hex property.\n    * <p>Valid values include:\n    * <ul>\n    *   <li>\"character\" (Interpret hexadecimal constants as character data)\n    *   <li>\"binary\" (Interpret hexadecimal constants as binary data)\n    * </ul>\n    * The default value is \"character\".\n    **/\n    public String getTranslateHex()\n    {\n        return properties_.getString(JDProperties.TRANSLATE_HEX);\n    }\n\n    // @M0A\n    /**\n    * Sets the translate hex property, which indicates how\n    * the parser will treat hexadecimal literals.\n    * @param parseOption The hex constant parser option.\n    * <p>Valid values include:\n    * <ul>\n    *   <li>\"character\" (Interpret hexadecimal constants as character data)\n    *   <li>\"binary\" (Interpret hexadecimal constants as binary data)\n    * </ul>\n    * The default value is \"character\".\n    **/\n    public void setTranslateHex(String parseOption)\n    {\n        String property = \"translateHex\";\n\n        String oldOption = getTranslateHex();\n        String newOption = parseOption;\n\n        validateProperty(property, newOption, JDProperties.TRANSLATE_HEX);\n\n        properties_.setString(JDProperties.TRANSLATE_HEX, newOption);\n\n        changes_.firePropertyChange(property, oldOption, newOption);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + parseOption);\n    }\n\n    //@K3A\n    /**\n    *  Sets the QAQQINI library name.  \n    *  @param libraryName The QAQQINI library name.\n    **/\n    public void setQaqqiniLibrary(String libraryName)\n    {\n        String property = \"qaqqiniLibrary\";\n        if (libraryName == null)\n            throw new NullPointerException(property);\n\n        String old = getQaqqiniLibrary();\n        properties_.setString(JDProperties.QAQQINILIB, libraryName);\n\n        changes_.firePropertyChange(property, old, libraryName);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + libraryName);  \n    }\n\n    //@dup\n    /**\n     *  Sets the QAQQINI library name.  \n     *  @param libraryName The QAQQINI library name.\n     *  Note:  this method is the same as setQaqqiniLibrary() so that it corresponds to the connection property name\n     **/\n    public void setQaqqinilib(String libraryName)\n    {\n        setQaqqiniLibrary(libraryName);\n    }\n     \n    /**                                                               \n    *  Sets the goal the IBM i system should use with optimization of queries.  \n    *  This setting corresponds with the system's QAQQINI option called OPTIMIZATION_GOAL.  \n    *  Note, this setting is ignored when running to V5R3 IBM i or earlier  \n    *  @param goal - the optimization goal \n    *  <p>Valid values include:\n    *  <ul>\n    *  <li>0 = Optimize query for first block of data (*ALLIO) when extended dynamic packages are used; Optimize query for entire result set (*FIRSTIO) when packages are not used</li>\n    *  <li>1 = Optimize query for first block of data (*FIRSTIO)</li>\n    *  <li>2 = Optimize query for entire result set (*ALLIO) </li>\n    *  </ul>\n    *  The default value is 0.\n    **/\n    public void setQueryOptimizeGoal(int goal)\n    {\n        String property = \"queryOptimizeGoal\";\n\n        Integer oldValue = new Integer(getQueryOptimizeGoal());\n        Integer newValue = new Integer(goal);\n\n        properties_.setString(JDProperties.QUERY_OPTIMIZE_GOAL, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + goal);\n    }\n\n    //@550\n    /**\n    * Sets the storage limit in megabytes, that should be used for statements executing a query in a connection.\n    * Note, this setting is ignored when running to i5/OS V5R4 or earlier\n    * You must have *JOBCTL special authority to use query storage limit with Version 6 Release 1 of IBM i.\n    * @param limit the storage limit (in megabytes)\n    * <p> Valid values are -1 to MAX_STORAGE_LIMIT megabytes.  \n    * The default value is -1 meaning there is no limit.\n    **/\n    public void setQueryStorageLimit(int limit)\n    {\n        String property = \"queryStorageLimit\";\n\n        if (limit < -1 || limit > MAX_STORAGE_LIMIT)\n            throw new ExtendedIllegalArgumentException(property, ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n\n        Integer oldValue = new Integer(getQueryStorageLimit());\n        Integer newValue = new Integer(limit);\n\n        properties_.setString(JDProperties.QUERY_STORAGE_LIMIT, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if(JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + limit);\n    }\n\n   /*@D4A*/\n    /**\n     * Sets the query timeout mechanism property, which indicates how\n     * the toolbox will enforce the query timeout specified on the statement. \n     * @param timeoutMechanism The timeout mechanism to use. \n     * <p>Valid values include:\n     * <ul>\n     *   <li>\"qqrytimlmt\" (QQRTIMLMT will be used)\n     *   <li>\"cancel\" (cancel will be used)\n     * </ul>\n     * The default value is \"character\".\n     **/\n     public void setQueryTimeoutMechanism(String timeoutMechanism)\n     {\n         String property = \"queryTimeoutMechanism\";\n\n         String oldOption = getQueryTimeoutMechanism();\n         String newOption = timeoutMechanism;\n\n         validateProperty(property, newOption, JDProperties.QUERY_TIMEOUT_MECHANISM);\n\n         properties_.setString(JDProperties.QUERY_TIMEOUT_MECHANISM, newOption);\n\n         changes_.firePropertyChange(property, oldOption, newOption);\n\n         if (JDTrace.isTraceOn())\n             JDTrace.logInformation (this, property + \": \" + timeoutMechanism);\n     }\n\n    \n    \n    //@540\n    /**                                                               \n    *  Sets whether lock sharing is allowed for loosely coupled transaction branches.\n    *  Note, this setting is ignored when running to V5R3 IBM i or earlier.  \n    *  @param lcs - the \"loosely coupled support\" setting \n    *  <p>Valid values include:\n    *  <ul>\n    *  <li>0 = Locks cannot be shared</li>\n    *  <li>1 = Locks can be shared</li>\n    *  </ul>\n    *  The default value is 0.\n    **/\n    public void setXALooselyCoupledSupport(int lcs)\n    {\n        String property = \"xaLooselyCoupledSupport\";\n\n        Integer oldValue = new Integer(getXALooselyCoupledSupport());\n        Integer newValue = new Integer(lcs);\n\n        properties_.setString(JDProperties.XA_LOOSELY_COUPLED_SUPPORT, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + lcs);\n    }\n\n    //K2A\n    /**\n    *  Returns the toolbox trace category.\n    *  @return The toolbox trace category.\n    *  <p>Valid values include:\n    *  <ul>\n    *    <li> \"none\" - The default value.\n    *    <li> \"datastream\"\n    *    <li> \"diagnostic\"\n    *    <li> \"error\"\n    *    <li> \"information\"\n    *    <li> \"warning\"\n    *    <li> \"conversion\"\n    *    <li> \"proxy\"\n    *    <li> \"pcml\"\n    *    <li> \"jdbc\"\n    *    <li> \"all\"\n    *    <li> \"thread\"\n    *  </ul>\n    **/\n    public String getToolboxTraceCategory()\n    {\n        return properties_.getString(JDProperties.TRACE_TOOLBOX);\n    }\n    \n    //@dup\n    /**\n     *  Returns the toolbox trace category.\n     *  @return The toolbox trace category.\n     *  <p>Valid values include:\n     *  <ul>\n     *    <li> \"none\" - The default value.\n     *    <li> \"datastream\"\n     *    <li> \"diagnostic\"\n     *    <li> \"error\"\n     *    <li> \"information\"\n     *    <li> \"warning\"\n     *    <li> \"conversion\"\n     *    <li> \"proxy\"\n     *    <li> \"pcml\"\n     *    <li> \"jdbc\"\n     *    <li> \"all\"\n     *    <li> \"thread\"\n     *  </ul>\n     *  Note:  this method is the same as getToolboxTraceCategory() so that it corresponds to the connection property name\n     **/\n    public String getToolboxTrace()\n    {\n        return getToolboxTraceCategory();\n    }\n\n    // @K2A\n    /**\n    * Sets the toolbox trace category, which indicates \n    * what trace points and diagnostic messages should be logged.\n    * @param traceCategory The category option.\n    * <p>Valid values include:\n    * <ul>\n    *    <li> \"none\" \n    *    <li> \"datastream\"\n    *    <li> \"diagnostic\"\n    *    <li> \"error\"\n    *    <li> \"information\"\n    *    <li> \"warning\"\n    *    <li> \"conversion\"\n    *    <li> \"proxy\"\n    *    <li> \"pcml\"\n    *    <li> \"jdbc\"\n    *    <li> \"all\"\n    *    <li> \"thread\"    \n    * </ul>\n    * The default value is \"none\".\n    **/\n    public void setToolboxTraceCategory(String traceCategory)\n    {\n        String property = \"toolboxTrace\";\n\n        String oldOption = getToolboxTraceCategory();\n        String newOption = traceCategory;\n\n        validateProperty(property, newOption, JDProperties.TRACE_TOOLBOX);\n\n        properties_.setString(JDProperties.TRACE_TOOLBOX, newOption);\n\n        changes_.firePropertyChange(property, oldOption, newOption);\n\n        if(!traceCategory.equals(\"\") && !traceCategory.equals(\"none\"))\n        {\n            if (! Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            if(traceCategory.equals(\"datastream\"))\n                Trace.setTraceDatastreamOn(true);\n            else if(traceCategory.equals(\"diagnostic\"))\n                Trace.setTraceDiagnosticOn(true);\n            else if(traceCategory.equals(\"error\"))\n                Trace.setTraceErrorOn(true);\n            else if(traceCategory.equals(\"information\"))\n                Trace.setTraceInformationOn(true);\n            else if(traceCategory.equals(\"warning\"))\n                Trace.setTraceWarningOn(true);\n            else if(traceCategory.equals(\"conversion\"))\n                Trace.setTraceConversionOn(true);\n            else if(traceCategory.equals(\"proxy\"))\n                Trace.setTraceProxyOn(true);\n            else if(traceCategory.equals(\"pcml\"))\n                Trace.setTracePCMLOn(true);\n            else if(traceCategory.equals(\"jdbc\"))\n                Trace.setTraceJDBCOn(true);\n            else if(traceCategory.equals(\"all\"))\n                Trace.setTraceAllOn(true);\n            else if(traceCategory.equals(\"thread\"))\n                Trace.setTraceThreadOn(true);\n        }\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + traceCategory);\n    }\n\n    //@dup\n    /**\n     * Sets the toolbox trace category, which indicates \n     * what trace points and diagnostic messages should be logged.\n     * @param traceCategory The category option.\n     * <p>Valid values include:\n     * <ul>\n     *    <li> \"none\" \n     *    <li> \"datastream\"\n     *    <li> \"diagnostic\"\n     *    <li> \"error\"\n     *    <li> \"information\"\n     *    <li> \"warning\"\n     *    <li> \"conversion\"\n     *    <li> \"proxy\"\n     *    <li> \"pcml\"\n     *    <li> \"jdbc\"\n     *    <li> \"all\"\n     *    <li> \"thread\"    \n     * </ul>\n     * The default value is \"none\".\n     * Note:  this method is the same as setToolboxTraceCategory() so that it corresponds to the connection property name\n     **/\n    public void setToolboxTrace(String traceCategory)\n    {\n        setToolboxTraceCategory(traceCategory);\n    }\n    \n    /**\n    *  Validates the property value.\n    *  @param property The property name.\n    *  @param value The property value.\n    *  @param index The property index.\n    **/\n    private void validateProperty(String property, String value, int index)\n    {\n        if (value.length() != 0)\n        {                                                      // @A7A\n            DriverPropertyInfo[] info = properties_.getInfo();\n            String[] choices = info[index].choices;\n                        \n            //Bidi-HCG start\n            //exception for \"package ccsid\" - it can accept any integer\n            if(index == JDProperties.PACKAGE_CCSID){            \t            \t            \t\n            \ttry{            \t\n            \t\tint ccsid = Integer.valueOf(value).intValue();\n            \t\tif(ccsid < 1)\n            \t\t\tthrow new ExtendedIllegalArgumentException(property, ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID); \n            \t\treturn;\n            \t}catch(NumberFormatException e){\n            \t\tthrow new ExtendedIllegalArgumentException(property, ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);            \t\t\n            \t}\n            }                 \n            //Bidi-HCG end\n            \n            boolean notValid = true;\n            int current = 0;\n            while (notValid && current < choices.length)\n            {\n                if (value.equalsIgnoreCase(choices[current]))\n                    notValid = false;\n                else\n                    current++;\n            }\n            if (notValid)\n                throw new ExtendedIllegalArgumentException(property, ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }                                                                                    // @A7A\n    }\n\n    /**\n    *  Serializes the IBM i system and user information.\n    *  @param out The output stream.\n    *  @exception IOException If a file I/O error occurs.\n    **/\n    private void writeObject(ObjectOutputStream out) throws IOException\n    {\n    \tTrace.log(Trace.INFORMATION, \"AS400JDBCDataSource.writeObject\"); \n        // @F0D String server = getServerName();\n        // @F0D if (!server.equals(\"\"))\n        // @F0D     serialServerName_ = server;\n\n        // @F0D String user = getUser();\n        // @F0D if (!user.equals(\"\"))\n        // @F0D     serialUserName_ = user;\n\n        if (!savePasswordWhenSerialized_)                        //@J3a\n        {                                                        //@J3a\n            serialPWBytes_ = null;                                //@J3a\n            serialKeyRingPWBytes_ = null;                         //@J3a\n        }                                                        //@J3a\n\n        // Serialize the object.\n        out.defaultWriteObject();\n    }\n\n    /**\n    *  Returns the string representation of the object.\n    *  @return The string representation.\n    **/\n    public String toString()\n    {\n        /*\n        * Implementation note: Used only for tracing information.\n        */\n        String name = getDataSourceName();\n        if (name == null)\n            name = \"\";\n        return name;\n    }\n\n    // @J3 new method.\n    // Twiddle password bytes.\n    private static char[] xpwConfuse(String info)\n    {\n        Random rng = new Random();\n        byte[] adderBytes = new byte[18];\n        rng.nextBytes(adderBytes);\n        char[] adder = BinaryConverter.byteArrayToCharArray(adderBytes);\n\n        byte[] maskBytes = new byte[14];\n        rng.nextBytes(maskBytes);\n        char[] mask = BinaryConverter.byteArrayToCharArray(maskBytes);\n\n        char[] infoBytes = xencode(adder, mask, info.toCharArray());\n        char[] returnBytes = new char[info.length() + 16];\n        System.arraycopy(adder, 0, returnBytes, 0, 9);\n        System.arraycopy(mask, 0, returnBytes, 9, 7);\n        System.arraycopy(infoBytes, 0, returnBytes, 16, info.length());\n\n        return returnBytes;\n    }\n\n    // @J3 new method.\n    // Get clear password bytes back.\n    private static String xpwDeconfuse(char[] info)\n    {\n        char[] adder = new char[9];\n        System.arraycopy(info, 0, adder, 0, 9);\n        char[] mask = new char[7];\n        System.arraycopy(info, 9, mask, 0, 7);\n        char[] infoBytes = new char[info.length - 16];\n        System.arraycopy(info, 16, infoBytes, 0, info.length - 16);\n\n        return new String(xdecode(adder, mask, infoBytes));\n    }\n\n    // @J3 new method    \n    // Scramble some bytes.\n    private static char[] xencode(char[] adder, char[] mask, char[] bytes)\n    {\n        if (bytes == null) return null;\n        int length = bytes.length;\n        char[] buf = new char[length];\n        for (int i = 0; i < length; ++i)\n        {\n            buf[i] = (char)(bytes[i] + adder[i % 9]);\n        }\n        for (int i = 0; i < length; ++i)\n        {\n            buf[i] = (char)(buf[i] ^ mask[i % 7]);\n        }\n        return buf;\n    }\n\n\n    // @J3 new method.       \n    private static char[] xdecode(char[] adder, char[] mask, char[] bytes)\n    {\n        int length = bytes.length;\n        char[] buf = new char[length];\n        for (int i = 0; i < length; ++i)\n        {\n            buf[i] = (char)(mask[i % 7] ^ bytes[i]);\n        }\n        for (int i = 0; i < length; ++i)\n        {\n            buf[i] = (char)(buf[i] - adder[i % 9]);\n        }\n        return buf;\n    }\n    \n    \n    //@pda jdbc40\n    protected String[] getValidWrappedList()\n    {\n        return new String[] {  \"com.ibm.as400.access.AS400JDBCDataSource\", \"javax.sql.DataSource\" };\n    } \n/* ifdef JDBC40 */\n    public Logger getParentLogger() throws SQLFeatureNotSupportedException {\n    throw new SQLFeatureNotSupportedException(); \n      \n    } \n/* endif */\n\n\t/**\n\tCommits the JDBC property values being displayed to the data source.\n\t\n\t@param as400jdbcDataSourcePane TODO\n\t * @return true if changes were applied successfully; false otherwise.\n\t**/\n\t\n\tpublic boolean applyChanges(AS400JDBCDataSourcePane as400jdbcDataSourcePane)\n\t{\n\t    // The following try/catch block calls the applyChanges method on the tabbed pane and handles the\n\t    // IllegalUserDataExceptions that occur.  An IllegalUserDataException exception is thrown when\n\t    // a rule defined by the GUI builder is broken.  For instance, if a field is defined to be\n\t    // required and no value is provided the exception will be thrown.\n\t    // Assuming no exceptions are thrown, our databean will be updated with the current GUI values\n\t    // when the tabPaneManager applyChanges method returns.  That is, the tabPaneManager applyChanges\n\t    // method calls all of the databean settor methods.\n\t    \n\t    try\n\t    {\n\t\t    as400jdbcDataSourcePane.m_tabbedPaneManager.applyChanges();\n\t    }\n\t    catch (IllegalUserDataException  e) \n\t    {   // This will put up the error message and put focus on the offending control\n\t        Container c = (Container)e.getComponent();\n\t\t    PanelManager.handleDataException(e,c);\n\t\t    return false;\n\t    }\n\t        \n\t    as400jdbcDataSourcePane.applyChangesToCurrentDataSource(this);    \n\t    return true;\n\t} \n    \n    \n}",
                "methodCount": 226
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 15,
                "candidates": [
                    {
                        "lineStart": 1921,
                        "lineEnd": 1928,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method isSecureCurrentUser to class JDProperties",
                        "description": "Move method isSecureCurrentUser to com.ibm.as400.access.JDProperties\nRationale: The method isSecureCurrentUser() is directly related to the property SECURE_CURRENT_USER, which is defined within the JDProperties class. This method retrieves the boolean value of this property, indicating whether the current user settings are secure. Since the JDProperties class is responsible for managing various properties, including security-related ones, it is logical to move this method there. This will enhance the cohesion of the class by keeping all related functionalities together, making the codebase easier to maintain and understand.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1990,
                        "lineEnd": 2001,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method log to class EventLog",
                        "description": "Move method log to com.ibm.as400.access.EventLog\nRationale: The log(String message) method is responsible for logging messages, which directly aligns with the purpose of the EventLog class. The EventLog class is designed specifically for logging messages and exceptions, making it the most appropriate target for this method. Moving the log method to EventLog will enhance the cohesion of the class, as it will centralize all logging functionality within a dedicated logging class. This separation of concerns will also improve maintainability and readability of the code, as the EventLog class will handle all aspects of logging, including formatting and output management.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1624,
                        "lineEnd": 1632,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method isBidiNumericOrdering to class JDProperties",
                        "description": "Move method isBidiNumericOrdering to com.ibm.as400.access.JDProperties\nRationale: The method isBidiNumericOrdering() is directly related to the property BIDI_NUMERIC_ORDERING, which is defined within the JDProperties class. This method checks whether the bidi numeric ordering round trip is used by retrieving the corresponding boolean value from the properties. Since the JDProperties class is responsible for managing various properties, including BIDI_NUMERIC_ORDERING, it is logical for this method to reside within JDProperties. Moving it there will enhance cohesion, as the method will be closely associated with the properties it manipulates, making the codebase easier to understand and maintain.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1556,
                        "lineEnd": 1564,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method isTrueAutoCommit to class JDProperties",
                        "description": "Move method isTrueAutoCommit to com.ibm.as400.access.JDProperties\nRationale: The method isTrueAutoCommit() checks the value of a specific property (TRUE_AUTO_COMMIT) from the properties_ object, which is a core part of the JDProperties class. Since this method directly relates to the management and retrieval of properties, it is more appropriate for it to reside within the JDProperties class. Moving it there will enhance cohesion, as it will allow all property-related methods to be encapsulated within the same class, making the codebase cleaner and easier to maintain.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1784,
                        "lineEnd": 1792,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method isHoldInputLocators to class JDProperties",
                        "description": "Move method isHoldInputLocators to com.ibm.as400.access.JDProperties\nRationale: The method isHoldInputLocators() checks if the input locators are of type 'hold' by retrieving a boolean property from the JDProperties class. Since this method directly interacts with the properties defined in JDProperties, it is more appropriate for it to reside within this class. Moving it to JDProperties will enhance cohesion, as it will encapsulate the logic related to property management and retrieval, making the codebase cleaner and more maintainable.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 5095,
                        "lineEnd": 5134,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method validateProperty to class JDProperties",
                        "description": "Move method validateProperty to com.ibm.as400.access.JDProperties\nRationale: The method validateProperty() is responsible for validating property values based on their names and choices, which directly relates to the functionality of the JDProperties class. This class manages various properties and their associated metadata, including valid choices for each property. Moving validateProperty() to JDProperties will enhance cohesion, as it will allow the class to encapsulate both the properties and their validation logic, making the codebase cleaner and more maintainable.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1580,
                        "lineEnd": 1588,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method isVariableFieldCompression to class JDProperties",
                        "description": "Move method isVariableFieldCompression to com.ibm.as400.access.JDProperties\nRationale: The method isVariableFieldCompression() checks if variable-length fields are compressed by accessing a property defined in the JDProperties class. Since this method directly relates to the properties managed by JDProperties, it is more appropriate for it to reside within this class. Moving it to JDProperties will enhance cohesion, as the method will be part of the class that manages the properties it operates on, making the codebase cleaner and easier to maintain.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1613,
                        "lineEnd": 1621,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method isBidiImplicitReordering to class JDProperties",
                        "description": "Move method isBidiImplicitReordering to com.ibm.as400.access.JDProperties\nRationale: The method isBidiImplicitReordering() checks a specific property related to bidirectional (bidi) implicit reordering, which is defined as a constant in the JDProperties class. Since this method directly interacts with the properties_ object to retrieve the value of BIDI_IMPLICIT_REORDERING, it logically belongs in the JDProperties class. Moving it there will enhance cohesion by keeping all property-related methods within the same class, making the codebase easier to maintain and understand.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1871,
                        "lineEnd": 1880,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method isHoldStatements to class JDProperties",
                        "description": "Move method isHoldStatements to com.ibm.as400.access.JDProperties\nRationale: The method isHoldStatements() is directly related to the properties of the JDBC driver, specifically the HOLD_STATEMENTS property. Since JDProperties is responsible for managing various properties related to the JDBC connection, it is logical for this method to reside within JDProperties. Moving it there will enhance the cohesion of the class, as it will encapsulate all functionality related to property management, including the handling of statement hold behavior.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 5261,
                        "lineEnd": 5291,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method applyChanges to class AS400",
                        "description": "Move method applyChanges to com.ibm.as400.access.AS400\nRationale: The applyChanges() method is responsible for committing JDBC property values to the data source, which is directly related to the AS400 class's functionality of managing connections and interactions with the IBM i host servers. Moving this method to the AS400 class aligns it with the class's purpose of handling database connections and configurations, ensuring that all related functionalities are encapsulated within the same class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 2028,
                        "lineEnd": 2041,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method removePropertyChangeListener to class AS400",
                        "description": "Move method removePropertyChangeListener to com.ibm.as400.access.AS400\nRationale: The method removePropertyChangeListener(PropertyChangeListener listener) is responsible for removing a PropertyChangeListener from the AS400 class. Since the AS400 class maintains a list of property change listeners, it is logical for this method to reside within the AS400 class. The method interacts directly with the propertyChangeListeners_ field, which is a member of the AS400 class, ensuring that the listener management is encapsulated within the class that owns the listener list.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1979,
                        "lineEnd": 1987,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method isUseBlockUpdate to class JDProperties",
                        "description": "Move method isUseBlockUpdate to com.ibm.as400.access.JDProperties\nRationale: The method isUseBlockUpdate() checks a specific property (DO_UPDATE_DELETE_BLOCKING) from the properties_ object, which is a core part of the JDProperties class. Since this method directly relates to the configuration of properties that JDProperties manages, it is more appropriate for it to reside within JDProperties. Moving it there will enhance the cohesion of the class, as it will encapsulate all related property access methods, making the codebase cleaner and easier to maintain.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 442,
                        "lineEnd": 456,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method addPropertyChangeListener to class AS400",
                        "description": "Move method addPropertyChangeListener to com.ibm.as400.access.AS400\nRationale: The method addPropertyChangeListener() is responsible for adding a PropertyChangeListener to the AS400 class, which is likely to be monitoring changes in properties related to the AS400 system. Since the method interacts directly with the AS400 instance's property change support, it is more appropriate for it to reside within the AS400 class rather than in a different class. This ensures that property change events are managed in the context of the AS400 system's state and behavior.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1644,
                        "lineEnd": 1652,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method isCursorHold to class JDProperties",
                        "description": "Move method isCursorHold to com.ibm.as400.access.JDProperties\nRationale: The method isCursorHold() checks the value of the CURSOR_HOLD property, which is defined within the JDProperties class. Since this method directly interacts with the properties managed by JDProperties, it is more appropriate for it to reside within this class. Moving it to JDProperties will enhance cohesion, as it will allow for better encapsulation of property-related logic, making it easier to manage and maintain the code.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1930,
                        "lineEnd": 1938,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method isThreadUsed to class JDProperties",
                        "description": "Move method isThreadUsed to com.ibm.as400.access.JDProperties\nRationale: The method isThreadUsed() checks if a specific property (THREAD_USED) is set in the properties of the JDProperties class. Since this method directly interacts with the properties defined in JDProperties, it is more appropriate for it to reside within this class. Moving it to JDProperties will enhance cohesion, as the method's functionality is closely tied to the management of properties, making it easier to maintain and understand.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "log",
                            "method_signature": "void log(String message)",
                            "target_class": "Logger",
                            "rationale": "The log method is responsible for logging messages, which is a concern that belongs to a logging utility class rather than the AS400JDBCDataSource class."
                        },
                        {
                            "method_name": "logProperty",
                            "method_signature": "private void logProperty(String property, String value)",
                            "target_class": "Logger",
                            "rationale": "The logProperty method is also related to logging and should be moved to a dedicated logging utility class to separate concerns."
                        },
                        {
                            "method_name": "initializeTransient",
                            "method_signature": "private void initializeTransient()",
                            "target_class": "AS400",
                            "rationale": "The method initializes transient properties related to the AS400 object, which suggests that it should be part of the AS400 class to encapsulate its initialization logic."
                        },
                        {
                            "method_name": "xpwConfuse",
                            "method_signature": "private static char[] xpwConfuse(String info)",
                            "target_class": "PasswordUtils",
                            "rationale": "The xpwConfuse method is related to password handling and should be moved to a utility class dedicated to password operations."
                        },
                        {
                            "method_name": "xpwDeconfuse",
                            "method_signature": "private static String xpwDeconfuse(char[] info)",
                            "target_class": "PasswordUtils",
                            "rationale": "Similar to xpwConfuse, this method deals with password handling and should be part of a dedicated utility class for better organization."
                        },
                        {
                            "method_name": "xencode",
                            "method_signature": "private static char[] xencode(char[] adder, char[] mask, char[] bytes)",
                            "target_class": "PasswordUtils",
                            "rationale": "This method is also related to encoding passwords and should be moved to a utility class focused on password operations."
                        },
                        {
                            "method_name": "xdecode",
                            "method_signature": "private static char[] xdecode(char[] adder, char[] mask, char[] bytes)",
                            "target_class": "PasswordUtils",
                            "rationale": "This method is related to decoding passwords and should be part of a dedicated utility class for password operations."
                        }
                    ],
                    "llm_response_time": 20496
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "log",
                            "method_signature": "void log(String message)",
                            "target_class": "Logger",
                            "rationale": "The log method is responsible for logging messages, which is a concern that belongs in a dedicated logging class rather than in a data source class."
                        },
                        {
                            "method_name": "logProperty",
                            "method_signature": "private void logProperty(String property, String value)",
                            "target_class": "Logger",
                            "rationale": "The logProperty method is also related to logging and should be moved to a dedicated logging class to separate concerns."
                        },
                        {
                            "method_name": "initializeTransient",
                            "method_signature": "private void initializeTransient()",
                            "target_class": "TransientInitializer",
                            "rationale": "The method initializes transient data and could be better organized in a separate class that handles initialization logic."
                        },
                        {
                            "method_name": "xpwConfuse",
                            "method_signature": "private static char[] xpwConfuse(String info)",
                            "target_class": "PasswordUtils",
                            "rationale": "The method is responsible for password manipulation and should be moved to a utility class dedicated to password handling."
                        },
                        {
                            "method_name": "xpwDeconfuse",
                            "method_signature": "private static String xpwDeconfuse(char[] info)",
                            "target_class": "PasswordUtils",
                            "rationale": "Similar to xpwConfuse, this method deals with password manipulation and should reside in a utility class for better organization."
                        },
                        {
                            "method_name": "xencode",
                            "method_signature": "private static char[] xencode(char[] adder, char[] mask, char[] bytes)",
                            "target_class": "PasswordUtils",
                            "rationale": "This method is part of the password encoding logic and should be moved to a dedicated utility class for password operations."
                        },
                        {
                            "method_name": "xdecode",
                            "method_signature": "private static char[] xdecode(char[] adder, char[] mask, char[] bytes)",
                            "target_class": "PasswordUtils",
                            "rationale": "This method is part of the password decoding logic and should be moved to a dedicated utility class for password operations."
                        }
                    ],
                    "llm_response_time": 18000
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "log",
                            "method_signature": "void log(String message)",
                            "target_class": "Logger",
                            "rationale": "The log method is responsible for logging messages, which is a concern that belongs in a dedicated logging class rather than in a data source class."
                        },
                        {
                            "method_name": "logProperty",
                            "method_signature": "private void logProperty(String property, String value)",
                            "target_class": "Logger",
                            "rationale": "The logProperty method is also related to logging and should be moved to a dedicated logging class to separate concerns."
                        },
                        {
                            "method_name": "initializeTransient",
                            "method_signature": "private void initializeTransient()",
                            "target_class": "TransientInitializer",
                            "rationale": "The method initializes transient data and could be better organized in a separate class that handles initialization logic."
                        },
                        {
                            "method_name": "xpwConfuse",
                            "method_signature": "private static char[] xpwConfuse(String info)",
                            "target_class": "PasswordUtils",
                            "rationale": "The method is responsible for password manipulation and should be moved to a utility class dedicated to password handling."
                        },
                        {
                            "method_name": "xpwDeconfuse",
                            "method_signature": "private static String xpwDeconfuse(char[] info)",
                            "target_class": "PasswordUtils",
                            "rationale": "Similar to xpwConfuse, this method deals with password manipulation and should reside in a utility class for better organization."
                        },
                        {
                            "method_name": "xencode",
                            "method_signature": "private static char[] xencode(char[] adder, char[] mask, char[] bytes)",
                            "target_class": "PasswordUtils",
                            "rationale": "This method is part of the password encoding logic and should be moved to a dedicated utility class for password operations."
                        },
                        {
                            "method_name": "xdecode",
                            "method_signature": "private static char[] xdecode(char[] adder, char[] mask, char[] bytes)",
                            "target_class": "PasswordUtils",
                            "rationale": "This method is part of the password decoding logic and should be moved to a dedicated utility class for password operations."
                        }
                    ],
                    "llm_response_time": 19213
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "addPropertyChangeListener",
                            "method_signature": "public addPropertyChangeListener(PropertyChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "clone",
                            "method_signature": "public clone()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getConnection",
                            "method_signature": "public getConnection(String user, String password)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getConnection",
                            "method_signature": "private getConnection(AS400 as400)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "initializeTransient",
                            "method_signature": "private initializeTransient()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isTrueAutoCommit",
                            "method_signature": "public isTrueAutoCommit()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isVariableFieldCompression",
                            "method_signature": "public isVariableFieldCompression()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isAutoCommit",
                            "method_signature": "public isAutoCommit()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isAutocommitException",
                            "method_signature": "public isAutocommitException()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isBidiImplicitReordering",
                            "method_signature": "public isBidiImplicitReordering()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isBidiNumericOrdering",
                            "method_signature": "public isBidiNumericOrdering()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isBigDecimal",
                            "method_signature": "public isBigDecimal()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isCursorHold",
                            "method_signature": "public isCursorHold()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isDataCompression",
                            "method_signature": "public isDataCompression()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isDataTruncation",
                            "method_signature": "public isDataTruncation()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isExtendedDynamic",
                            "method_signature": "public isExtendedDynamic()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isExtendedMetaData",
                            "method_signature": "public isExtendedMetaData()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isFullOpen",
                            "method_signature": "public isFullOpen()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isJvm16Synchronize",
                            "method_signature": "public isJvm16Synchronize()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isLazyClose",
                            "method_signature": "public isLazyClose()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isHoldInputLocators",
                            "method_signature": "public isHoldInputLocators()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isPackageAdd",
                            "method_signature": "public isPackageAdd()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isPackageCache",
                            "method_signature": "public isPackageCache()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isPrefetch",
                            "method_signature": "public isPrefetch()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isPrompt",
                            "method_signature": "public isPrompt()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isRollbackCursorHold",
                            "method_signature": "public isRollbackCursorHold()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isHoldStatements",
                            "method_signature": "public isHoldStatements()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isSecure",
                            "method_signature": "public isSecure()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isSecureCurrentUser",
                            "method_signature": "public isSecureCurrentUser()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isThreadUsed",
                            "method_signature": "public isThreadUsed()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isTrace",
                            "method_signature": "public isTrace()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isTranslateBinary",
                            "method_signature": "public isTranslateBinary()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isTranslateBoolean",
                            "method_signature": "public isTranslateBoolean()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isUseBlockUpdate",
                            "method_signature": "public isUseBlockUpdate()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "log",
                            "method_signature": " log(String message)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removePropertyChangeListener",
                            "method_signature": "public removePropertyChangeListener(PropertyChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "validateProperty",
                            "method_signature": "private validateProperty(String property, String value, int index)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "applyChanges",
                            "method_signature": "public applyChanges(AS400JDBCDataSourcePane as400jdbcDataSourcePane)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "getConnection",
                            "method_signature": "public getConnection(String user, String password)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "clone",
                            "method_signature": "public clone()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isSecureCurrentUser",
                            "method_signature": "public isSecureCurrentUser()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "initializeTransient",
                            "method_signature": "private initializeTransient()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isLazyClose",
                            "method_signature": "public isLazyClose()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "log",
                            "method_signature": " log(String message)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isBidiNumericOrdering",
                            "method_signature": "public isBidiNumericOrdering()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isTrueAutoCommit",
                            "method_signature": "public isTrueAutoCommit()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isHoldInputLocators",
                            "method_signature": "public isHoldInputLocators()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "validateProperty",
                            "method_signature": "private validateProperty(String property, String value, int index)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isVariableFieldCompression",
                            "method_signature": "public isVariableFieldCompression()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isBidiImplicitReordering",
                            "method_signature": "public isBidiImplicitReordering()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isHoldStatements",
                            "method_signature": "public isHoldStatements()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getConnection",
                            "method_signature": "private getConnection(AS400 as400)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "applyChanges",
                            "method_signature": "public applyChanges(AS400JDBCDataSourcePane as400jdbcDataSourcePane)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removePropertyChangeListener",
                            "method_signature": "public removePropertyChangeListener(PropertyChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isUseBlockUpdate",
                            "method_signature": "public isUseBlockUpdate()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addPropertyChangeListener",
                            "method_signature": "public addPropertyChangeListener(PropertyChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isCursorHold",
                            "method_signature": "public isCursorHold()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isThreadUsed",
                            "method_signature": "public isThreadUsed()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isPackageAdd",
                            "method_signature": "public isPackageAdd()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isBigDecimal",
                            "method_signature": "public isBigDecimal()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public getConnection(String user, String password)": {
                        "first": {
                            "method_name": "getConnection",
                            "method_signature": "public getConnection(String user, String password)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4133732538736185
                    },
                    "public clone()": {
                        "first": {
                            "method_name": "clone",
                            "method_signature": "public clone()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4490790076245934
                    },
                    "public isSecureCurrentUser()": {
                        "first": {
                            "method_name": "isSecureCurrentUser",
                            "method_signature": "public isSecureCurrentUser()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4765186088569641
                    },
                    "private initializeTransient()": {
                        "first": {
                            "method_name": "initializeTransient",
                            "method_signature": "private initializeTransient()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.49539406211754317
                    },
                    "public isLazyClose()": {
                        "first": {
                            "method_name": "isLazyClose",
                            "method_signature": "public isLazyClose()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5291753368949343
                    },
                    " log(String message)": {
                        "first": {
                            "method_name": "log",
                            "method_signature": " log(String message)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5342157872965241
                    },
                    "public isBidiNumericOrdering()": {
                        "first": {
                            "method_name": "isBidiNumericOrdering",
                            "method_signature": "public isBidiNumericOrdering()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5466607859763565
                    },
                    "public isTrueAutoCommit()": {
                        "first": {
                            "method_name": "isTrueAutoCommit",
                            "method_signature": "public isTrueAutoCommit()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5498746341765054
                    },
                    "public isHoldInputLocators()": {
                        "first": {
                            "method_name": "isHoldInputLocators",
                            "method_signature": "public isHoldInputLocators()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5559997253705264
                    },
                    "private validateProperty(String property, String value, int index)": {
                        "first": {
                            "method_name": "validateProperty",
                            "method_signature": "private validateProperty(String property, String value, int index)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5581512687762902
                    },
                    "public isVariableFieldCompression()": {
                        "first": {
                            "method_name": "isVariableFieldCompression",
                            "method_signature": "public isVariableFieldCompression()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5804759783406139
                    },
                    "public isBidiImplicitReordering()": {
                        "first": {
                            "method_name": "isBidiImplicitReordering",
                            "method_signature": "public isBidiImplicitReordering()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5838427846649298
                    },
                    "public isHoldStatements()": {
                        "first": {
                            "method_name": "isHoldStatements",
                            "method_signature": "public isHoldStatements()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5851825757498502
                    },
                    "private getConnection(AS400 as400)": {
                        "first": {
                            "method_name": "getConnection",
                            "method_signature": "private getConnection(AS400 as400)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5897556721957034
                    },
                    "public applyChanges(AS400JDBCDataSourcePane as400jdbcDataSourcePane)": {
                        "first": {
                            "method_name": "applyChanges",
                            "method_signature": "public applyChanges(AS400JDBCDataSourcePane as400jdbcDataSourcePane)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5913702220522707
                    }
                },
                "voyage": {
                    "public isHoldInputLocators()": {
                        "first": {
                            "method_name": "isHoldInputLocators",
                            "method_signature": "public isHoldInputLocators()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3080102551499267
                    },
                    " log(String message)": {
                        "first": {
                            "method_name": "log",
                            "method_signature": " log(String message)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3103193842201783
                    },
                    "public removePropertyChangeListener(PropertyChangeListener listener)": {
                        "first": {
                            "method_name": "removePropertyChangeListener",
                            "method_signature": "public removePropertyChangeListener(PropertyChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.34781092575078293
                    },
                    "private validateProperty(String property, String value, int index)": {
                        "first": {
                            "method_name": "validateProperty",
                            "method_signature": "private validateProperty(String property, String value, int index)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3613341723442194
                    },
                    "public isBidiImplicitReordering()": {
                        "first": {
                            "method_name": "isBidiImplicitReordering",
                            "method_signature": "public isBidiImplicitReordering()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3642324948330944
                    },
                    "public isUseBlockUpdate()": {
                        "first": {
                            "method_name": "isUseBlockUpdate",
                            "method_signature": "public isUseBlockUpdate()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3721639207458151
                    },
                    "public addPropertyChangeListener(PropertyChangeListener listener)": {
                        "first": {
                            "method_name": "addPropertyChangeListener",
                            "method_signature": "public addPropertyChangeListener(PropertyChangeListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.37895647417655487
                    },
                    "public isBidiNumericOrdering()": {
                        "first": {
                            "method_name": "isBidiNumericOrdering",
                            "method_signature": "public isBidiNumericOrdering()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3795529752571174
                    },
                    "public isVariableFieldCompression()": {
                        "first": {
                            "method_name": "isVariableFieldCompression",
                            "method_signature": "public isVariableFieldCompression()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.38089908559569996
                    },
                    "public isCursorHold()": {
                        "first": {
                            "method_name": "isCursorHold",
                            "method_signature": "public isCursorHold()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.39362355499504914
                    },
                    "public isThreadUsed()": {
                        "first": {
                            "method_name": "isThreadUsed",
                            "method_signature": "public isThreadUsed()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.39505224933275357
                    },
                    "public isHoldStatements()": {
                        "first": {
                            "method_name": "isHoldStatements",
                            "method_signature": "public isHoldStatements()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.41714348801835194
                    },
                    "public isLazyClose()": {
                        "first": {
                            "method_name": "isLazyClose",
                            "method_signature": "public isLazyClose()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.417918317734315
                    },
                    "public isPackageAdd()": {
                        "first": {
                            "method_name": "isPackageAdd",
                            "method_signature": "public isPackageAdd()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4202146099738219
                    },
                    "public isBigDecimal()": {
                        "first": {
                            "method_name": "isBigDecimal",
                            "method_signature": "public isBigDecimal()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.43161479120692037
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private initializeTransient()",
                        "private validateProperty(String property, String value, int index)",
                        "private getConnection(AS400 as400)",
                        "public getConnection(String user, String password)",
                        "public clone()",
                        "public applyChanges(AS400JDBCDataSourcePane as400jdbcDataSourcePane)",
                        "public isSecureCurrentUser()",
                        "public isTrueAutoCommit()",
                        "public isLazyClose()",
                        "public isHoldInputLocators()",
                        "public isVariableFieldCompression()",
                        "public isBidiImplicitReordering()",
                        "public isBidiNumericOrdering()",
                        "public isHoldStatements()"
                    ],
                    "llm_response_time": 5031
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public getConnection(String user, String password)",
                        "public clone()",
                        "private initializeTransient()",
                        "public isSecureCurrentUser()",
                        "public isLazyClose()"
                    ],
                    "llm_response_time": 2020
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public getConnection(String user, String password)",
                        "public clone()",
                        "public isSecureCurrentUser()"
                    ],
                    "llm_response_time": 1549
                },
                "voyage": {
                    "priority_method_names": [
                        "private validateProperty(String property, String value, int index)",
                        "public removePropertyChangeListener(PropertyChangeListener listener)",
                        "public addPropertyChangeListener(PropertyChangeListener listener)",
                        "public isHoldInputLocators()",
                        "public isBidiImplicitReordering()",
                        "public isBidiNumericOrdering()",
                        "public isVariableFieldCompression()",
                        "public isCursorHold()",
                        "public isThreadUsed()",
                        "public isHoldStatements()",
                        "public isLazyClose()",
                        "public isPackageAdd()",
                        "public isBigDecimal()",
                        "public isUseBlockUpdate()"
                    ],
                    "llm_response_time": 10472
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private validateProperty(String property, String value, int index)",
                        "public isHoldInputLocators()",
                        "public isBidiImplicitReordering()",
                        "public removePropertyChangeListener(PropertyChangeListener listener)"
                    ],
                    "llm_response_time": 6795
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public removePropertyChangeListener(PropertyChangeListener listener)",
                        "public isHoldInputLocators()"
                    ],
                    "llm_response_time": 1558
                }
            },
            "targetClassMap": {
                "getConnection": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4338,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "clone": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2639,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "isSecureCurrentUser": {
                    "target_classes": [
                        {
                            "class_name": "JDProperties",
                            "similarity_score": 0.06053711041289285
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JDProperties"
                    ],
                    "llm_response_time": 4027,
                    "similarity_computation_time": 7,
                    "similarity_metric": "cosine"
                },
                "initializeTransient": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4344,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "isLazyClose": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2859,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "log": {
                    "target_classes": [
                        {
                            "class_name": "EventLog",
                            "similarity_score": 0.6038795256110688
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "EventLog"
                    ],
                    "llm_response_time": 2487,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "isBidiNumericOrdering": {
                    "target_classes": [
                        {
                            "class_name": "JDProperties",
                            "similarity_score": 0.04727344160244222
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JDProperties"
                    ],
                    "llm_response_time": 4333,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "isTrueAutoCommit": {
                    "target_classes": [
                        {
                            "class_name": "JDProperties",
                            "similarity_score": 0.04975671471931925
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JDProperties"
                    ],
                    "llm_response_time": 2913,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "isHoldInputLocators": {
                    "target_classes": [
                        {
                            "class_name": "JDProperties",
                            "similarity_score": 0.05379048340227054
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JDProperties"
                    ],
                    "llm_response_time": 3083,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "validateProperty": {
                    "target_classes": [
                        {
                            "class_name": "JDProperties",
                            "similarity_score": 0.4519784738376248
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JDProperties"
                    ],
                    "llm_response_time": 3095,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "isVariableFieldCompression": {
                    "target_classes": [
                        {
                            "class_name": "JDProperties",
                            "similarity_score": 0.05105777017947954
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JDProperties"
                    ],
                    "llm_response_time": 4540,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "isBidiImplicitReordering": {
                    "target_classes": [
                        {
                            "class_name": "JDProperties",
                            "similarity_score": 0.05088017739729695
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JDProperties"
                    ],
                    "llm_response_time": 3259,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "isHoldStatements": {
                    "target_classes": [
                        {
                            "class_name": "JDProperties",
                            "similarity_score": 0.048350961765453365
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JDProperties"
                    ],
                    "llm_response_time": 2777,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "applyChanges": {
                    "target_classes": [
                        {
                            "class_name": "AS400JDBCDataSourcePane",
                            "similarity_score": 0.5105444451433406
                        },
                        {
                            "class_name": "AS400",
                            "similarity_score": 0.6577849845328546
                        },
                        {
                            "class_name": "JDProperties",
                            "similarity_score": 0.23660815486052775
                        },
                        {
                            "class_name": "SocketProperties",
                            "similarity_score": 0.5518644355343794
                        },
                        {
                            "class_name": "EventLog",
                            "similarity_score": 0.5351106572472822
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "AS400",
                        "SocketProperties",
                        "EventLog"
                    ],
                    "llm_response_time": 9025,
                    "similarity_computation_time": 9,
                    "similarity_metric": "cosine"
                },
                "removePropertyChangeListener": {
                    "target_classes": [
                        {
                            "class_name": "AS400",
                            "similarity_score": 0.5523983287164115
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "AS400"
                    ],
                    "llm_response_time": 5189,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "isUseBlockUpdate": {
                    "target_classes": [
                        {
                            "class_name": "JDProperties",
                            "similarity_score": 0.05537917491708821
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JDProperties"
                    ],
                    "llm_response_time": 4046,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "addPropertyChangeListener": {
                    "target_classes": [
                        {
                            "class_name": "AS400",
                            "similarity_score": 0.4350816653743888
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "AS400"
                    ],
                    "llm_response_time": 10647,
                    "similarity_computation_time": 6,
                    "similarity_metric": "cosine"
                },
                "isCursorHold": {
                    "target_classes": [
                        {
                            "class_name": "JDProperties",
                            "similarity_score": 0.0814885681392606
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JDProperties"
                    ],
                    "llm_response_time": 2718,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "isThreadUsed": {
                    "target_classes": [
                        {
                            "class_name": "JDProperties",
                            "similarity_score": 0.05713589529399683
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JDProperties"
                    ],
                    "llm_response_time": 3133,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.access.Permission::removeRow(int):void need move com.ibm.as400.vaccess.PermissionTableModelQSYS",
        "class_name": "com.ibm.as400.access.Permission",
        "telemetry": {
            "id": "ee0c018c-0220-40d3-9e4e-bd6b6e6a0ae3",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1256,
                "lineStart": 47,
                "lineEnd": 1302,
                "bodyLineStart": 47,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/large/big/jtopen-7.8/src/com/ibm/as400/access/Permission.java",
                "sourceCode": "/**\n * Retrieves a user's authority to an object.<br>\n * To improve performance, the Permission object caches authority changes \n * until the <i>commit()</i> method is called. When <i>commit()</i>is called, \n * all changes up to that point are sent to the system.<br>\n * The permission of an object is a collection of many users' authority to that object,\n * and the UserPermission class is used to represent a user's authority to a object. \n * Because there are three kinds of objects on the system, three subclasses of \n * UserPermission are defined:\n * <ul>\n *      <li> DLOPermission  - Represents a user's authority to a Document Library Objects (DLO)\n *                            stored in QDLS.\n *      <li> QSYSPermission - Represents a user's authority to the object which is contained in the system library\n *                            structure and stored in QSYS.LIB.\n *      <li> RootPermission - Represents a user's authority to the object which is contained in the root directory \n *                            structure. This includes everything that is not in QSYS.LIB or QDLS.\n * </ul>\n * Here is a simple example:\n * <p><blockquote><pre>\n * AS400 as400 = new AS400();\n * Permission permission = new Permission(as400,\"/QSYS.LIB/QJAVA.LIB\");\n * permission.addAuthorizedUser(\"user1\");\n * QSYSPermission userPermission = (QSYSPermission)permission.getUserPermission(\"user1\");\n * userPermission.setObjectAuthority(\"*CHANGE\");\n * permission.commit();\n * </pre></blockquote></p>\n * @see UserPermission\n * @see DLOPermission\n * @see QSYSPermission\n * @see RootPermission\n**/\npublic class Permission\n       implements Serializable\n{\n    static final long serialVersionUID = 4L;\n\n\n    /**\n     * Constant indicating the object is a Document Library Objects (DLO)\n     * stored in QDLS.\n     *\n    **/\n    public static final int TYPE_DLO = 0;\n\n    /**\n     * Constant indicating the object is contained in the system library\n     * structure and stored in QSYS.LIB.\n     *\n    **/\n    public static final int TYPE_QSYS = 1;\n\n\n    /**\n     * Constant indicating that the object is contained in the root directory \n     * structure. This includes everything that is not in QSYS.LIB or QDLS.\n     *\n    **/\n    public static final int TYPE_ROOT = 2;\n\n    private AS400 as400_;\n    private String authorizationList_;\n    private String autListBackup_;\n    private boolean autListChanged_;\n    private String name_;\n    private String owner_;\n    private boolean ownerChanged_;                        // @B2a\n    private boolean revokeOldAuthority_;                  // @B2a\n    private boolean revokeOldGroupAuthority_;\n    private boolean followSymbolicLinks_ = true;\n\n    // @B6 The name supplied by the application for QSYS objects on IASPs is\n    //     \"/aspName/QSYS.LIB/...\".  For QSYS objects the asp name will \n    //     be stripped.  path_ will start with /QSYS.LIB, asp_ will hold\n    //     the asp name.  Most pemission APIs dealing with QSYS objects \n    //     need a traditional QSYS name so path_ will be used as before.\n    //     One API and a couple commands, however, needs an IFS-style name.  \n    //     For them the name will be put back together.  Note the extra     \n    //     processing is done only for QSYS objects.  The extra\n    //     processing is not needed for QDLS objects since they cannot be on  \n    //     ASPs.  path_ will contain the entire path for root file system objects. \n    //     \n    private String path_;\n    private String asp_ = null;                           // @B6a\n\n    private String primaryGroup_;\n    private boolean primaryGroupChanged_;\n    private boolean sensitivityChanged_;\n    private int sensitivityLevel_;\n    private int type_;\n\n    private transient Vector userPermissionsBuffer_;\n    private transient Vector userPermissions_;\n    private transient Object userPermissionsLock_ = new Object();\n\n    private transient PermissionAccess access_;\n    private transient PropertyChangeSupport changes_;\n    \n    \n\n    /**\n     * Constructs a Permission object.\n     * @param file The IFSFile object. For example, The IFSFile object which represents the object \"QSYS.LIB/FRED.LIB\".\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ConnectionDroppedException If the connection is dropped unexpectedly.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception ObjectDoesNotExistException If the system object does not exist.\n     *\n    **/\n    public Permission(IFSFile file)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n    {\n        this(file.getSystem(),file.getPath(), false, true);                  // @B6c\n    }\n\n    \n    \n    // @B6a new method                                                                                 \n    /**\n     * Constructs a Permission object.  \n     * <P>\n     *    Use the independent auxiliary storage pool (IASP) parameter to indicate \n     *    if the path name can contain an IASP name.\n     *    If true, the name will be parsed as if the name starts with an IASP name.\n     *    If false, the name is treated as an ordinary path.  For example, suppose\n     *    the path is \"/myIASP/QSYS.LIB/MYLIB.LIB\".  If the IASP parameter is true\n     *    the object is treated as library \"MYLIB\" on IASP \"myIASP\".  If the IASP\n     *    parameter is false the object is treated as object \"MYLIB.LIB\" in\n     *    directory \"/myIASP/QSYS.LIB\" in the root file system.  Note the IASP\n     *    parameter is used only if the second component of the path is QSYS.LIB.\n     *    If the second component of the path is not QSYS.LIB, the parameter is ignored.\n     *        \n     * @param file The IFSFile object. For example, The IFSFile object which represents the object \"QSYS.LIB/FRED.LIB\".\n     * @param pathMayStartWithIASP True if the path may start with an  \n     *                independent auxiliary storage pool (IASP) name; false otherwise.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ConnectionDroppedException If the connection is dropped unexpectedly.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception ObjectDoesNotExistException If the system object does not exist.\n     *\n    **/\n    public Permission(IFSFile file, boolean pathMayStartWithIASP)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n    {\n        this(file.getSystem(),file.getPath(), pathMayStartWithIASP, true);               \n    }\n\n    \n    \n    /**\n     * Constructs a Permission object.  \n     * <P>\n     *    Use the independent auxiliary storage pool (IASP) parameter to indicate \n     *    if the path name can contain an IASP name.\n     *    If true, the name will be parsed as if the name starts with an IASP name.\n     *    If false, the name is treated as an ordinary path.  For example, suppose\n     *    the path is \"/myIASP/QSYS.LIB/MYLIB.LIB\".  If the IASP parameter is true\n     *    the object is treated as library \"MYLIB\" on IASP \"myIASP\".  If the IASP\n     *    parameter is false the object is treated as object \"MYLIB.LIB\" in\n     *    directory \"/myIASP/QSYS.LIB\" in the root file system.  Note the IASP\n     *    parameter is used only if the second component of the path is QSYS.LIB.\n     *    If the second component of the path is not QSYS.LIB, the parameter is ignored.\n     *        \n     * @param file The IFSFile object. For example, The IFSFile object which represents the object \"QSYS.LIB/FRED.LIB\".\n     * @param pathMayStartWithIASP True if the path may start with an  \n     *                independent auxiliary storage pool (IASP) name; false otherwise.\n     * @param followLinks Whether symbolic links are resolved.\n     * The default value is <tt>true</tt>; that is, symbolic links are always resolved.\n     * By default, if the IBM i object is a symbolic link, then the requested action\n     * is performed on the object that is ultimately <em>pointed to</em> by the symbolic link,\n     * rather than on the symbolic link itself.\n     * <br>Note: This parameter is effective only for IBM i release V5R4 and higher.\n     * For earlier releases, symbolic links are always resolved and this parameter is ignored.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ConnectionDroppedException If the connection is dropped unexpectedly.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception ObjectDoesNotExistException If the system object does not exist.\n     *\n    **/\n    public Permission(IFSFile file, boolean pathMayStartWithIASP, boolean followLinks)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n    {\n        this(file.getSystem(),file.getPath(), pathMayStartWithIASP, followLinks);               \n    }\n                                                                                 \n\n    /**\n     * Constructs a Permission object.\n     * @param as400 The system.\n     * @param fileName The full path of the object. For example, \"/QSYS.LIB/FRED.LIB\".\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ConnectionDroppedException If the connection is dropped unexpectedly.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception ObjectDoesNotExistException If the system object does not exist.\n     *\n    **/\n    public Permission(AS400 as400, String fileName)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n    {   \n        this(as400, fileName, false, true);                    // @B6c logic moved to next c'tor\n    }\n\n\n    /**                                                                     \n     * Constructs a Permission object.     \n     * <P>\n     *    Use the independent auxiliary storage pool (IASP) parameter to indicate \n     *    if the path name can contain an IASP name.\n     *    If true, the name will be parsed as if the name starts with an IASP name.\n     *    If false, the name is treated as an ordinary path.  For example, suppose\n     *    the path is \"/myIASP/QSYS.LIB/MYLIB.LIB\".  If the IASP parameter is true\n     *    the object is treated as library \"MYLIB\" on IASP \"myIASP\".  If the IASP\n     *    parameter is false the object is treated as object \"MYLIB.LIB\" in\n     *    directory \"/myIASP/QSYS.LIB\" in the root file system.  Note the IASP\n     *    parameter is used only if the second component of the path is QSYS.LIB.\n     *    If the second component of the path is not QSYS.LIB, the parameter is ignored.\n     *        \n     * \n     * @param as400 The system.\n     * @param fileName The full path of the object. For example, \"/QSYS.LIB/FRED.LIB\".\n     * @param pathMayStartWithIASP True if the path may start with an  \n     *                independent auxiliary storage pool (IASP) name; false otherwise.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ConnectionDroppedException If the connection is dropped unexpectedly.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception ObjectDoesNotExistException If the system object does not exist.\n     *\n    **/\n    public Permission(AS400 as400, String fileName, boolean pathMayStartWithIASP)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n    {   \n        this(as400, fileName, pathMayStartWithIASP, true);\n    }\n\n\n    /**                                                                     \n     * Constructs a Permission object.     \n     * <P>\n     *    Use the independent auxiliary storage pool (IASP) parameter to indicate \n     *    if the path name can contain an IASP name.\n     *    If true, the name will be parsed as if the name starts with an IASP name.\n     *    If false, the name is treated as an ordinary path.  For example, suppose\n     *    the path is \"/myIASP/QSYS.LIB/MYLIB.LIB\".  If the IASP parameter is true\n     *    the object is treated as library \"MYLIB\" on IASP \"myIASP\".  If the IASP\n     *    parameter is false the object is treated as object \"MYLIB.LIB\" in\n     *    directory \"/myIASP/QSYS.LIB\" in the root file system.  Note the IASP\n     *    parameter is used only if the second component of the path is QSYS.LIB.\n     *    If the second component of the path is not QSYS.LIB, the parameter is ignored.\n     *        \n     * \n     * @param as400 The system.\n     * @param fileName The full path of the object. For example, \"/QSYS.LIB/FRED.LIB\".\n     * @param pathMayStartWithIASP True if the path may start with an  \n     *                independent auxiliary storage pool (IASP) name; false otherwise.\n     * @param followLinks Whether symbolic links are resolved.\n     * The default value is <tt>true</tt>; that is, symbolic links are always resolved.\n     * By default, if the IBM i object is a symbolic link, then the requested action\n     * is performed on the object that is ultimately <em>pointed to</em> by the symbolic link,\n     * rather than on the symbolic link itself.\n     * <br>Note: This parameter is effective only for IBM i release V5R4 and higher.\n     * For earlier releases, symbolic links are always resolved and this parameter is ignored.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ConnectionDroppedException If the connection is dropped unexpectedly.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception ObjectDoesNotExistException If the system object does not exist.\n     *\n    **/\n    public Permission(AS400 as400, String fileName, boolean pathMayStartWithIASP, boolean followLinks)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n    {   \n        if (as400 == null) throw new NullPointerException(\"system\");\n        if (fileName == null) throw new NullPointerException(\"fileName\");\n\n        as400_ = as400;\n        int separator;\n        path_ = fileName;\n        separator = path_.lastIndexOf('/');\n        name_ = path_.substring(separator+1);\n        type_ = parseType(path_, pathMayStartWithIASP);              // @B6c\n\n        // If 'followLinks' is false, check VRM, and if pre-V5R4 issue warning (and don't change flag).\n        if (!followLinks && (as400_.getVRM() < 0x050400))\n        {\n          if (Trace.traceOn_) {\n            Trace.log(Trace.WARNING, \"followLinks(false): Parameter is ignored because system is not V5R4 or higher.\");\n          }\n        }\n        else followSymbolicLinks_ = followLinks;\n\n        switch(type_)\n        {\n            case TYPE_QSYS :\n                access_ = new PermissionAccessQSYS(as400_);\n                break;\n            case TYPE_DLO :\n                access_ = new PermissionAccessDLO(as400_);\n                break;\n            case TYPE_ROOT :\n            default :\n                access_ = new PermissionAccessRoot(as400_);\n                break;\n        }\n        access_.setFollowSymbolicLinks(followSymbolicLinks_);\n\n        Vector perms = null; \n        try \n        {\n          // @B6 If the QSYS object is on an ASP, prepend the ASP name\n          //     to correctly fully qualify the path.\n          // @A3 The ASP is already part of the path. (e.g. /iasp123/QSYS.LIB/xyz.lib)\n          // String path = path_;                          // @B6a //@A3D\n          // if (asp_ != null)                             // @B6a //@A3D\n          //    path = asp_ + path;                        // @B6a //@A3D\n          perms = access_.getAuthority(path_);             // @B6c\n          changes_ = new PropertyChangeSupport(this);\n\n          synchronized (userPermissionsLock_)\n          {\n            owner_ = (String)perms.elementAt(0);\n            primaryGroup_ = (String)perms.elementAt(1);\n            authorizationList_ = (String)perms.elementAt(2);\n            //autListChanged_ = false;                       // @B2d\n            sensitivityLevel_ = ((Integer)perms.elementAt(3)).intValue();\n            //sensitivityChanged_ = false;                   // @B2d\n\n            userPermissionsBuffer_ = new Vector ();\n            userPermissions_ = new Vector();\n            int count = perms.size();\n            for (int i=4;i<count;i++)\n            {\n              UserPermission userPermission = (UserPermission)perms.elementAt(i);\n              if (userPermission != null)\n              {\n                userPermission.setCommitted(UserPermission.COMMIT_NONE);\n                userPermissionsBuffer_.addElement(userPermission);\n                userPermissions_.addElement(userPermission);\n              }\n            }\n          }\n        }\n        catch (PropertyVetoException e) { // should never happen\n          Trace.log(Trace.ERROR, e);\n        }\n    }\n\n\n    /**\n     * Adds an authorized user. The user added will have \"*EXCLUDE\" authorities \n     * on the object.\n     * @param userProfileName The authorized user profile name.\n     *\n    **/\n    public void addAuthorizedUser(String userProfileName)\n    {\n        if (userProfileName == null) throw new NullPointerException(\"userProfileName\");\n        int index;\n        String userName = userProfileName.trim().toUpperCase();\n\n        synchronized (userPermissionsLock_)\n        {\n          if (getUserIndex(userName,userPermissions_) != -1)\n          {\n            Trace.log(Trace.ERROR, \"Permission already exists for user \" + userProfileName);  // @B2a\n            throw new ExtendedIllegalArgumentException(\"userProfileName (\"+userName+\")\",\n                                                       ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n          } \n          else\n          {\n            index=getUserIndex(userName,userPermissionsBuffer_);\n            if (index != -1)\n            {\n              UserPermission usrAut = (UserPermission)\n                userPermissionsBuffer_.elementAt(index);\n              usrAut.setCommitted(UserPermission.COMMIT_CHANGE);\n              userPermissions_.addElement(usrAut);\n            } \n            else\n            {\n              UserPermission userPermission;\n              switch (type_)\n              {\n                case TYPE_DLO : \n                  userPermission = new DLOPermission(userName);\n                  break;\n                case TYPE_QSYS : \n                  userPermission = new QSYSPermission(userName);\n                  break;\n                case TYPE_ROOT :\n                default : \n                  userPermission = new RootPermission(userName);\n                  break;\n              }\n              userPermission.setGroupIndicator(UserPermission.GROUPINDICATOR_USER);\n              userPermission.setCommitted(UserPermission.COMMIT_ADD);\n              userPermissionsBuffer_.addElement(userPermission);\n              userPermissions_.addElement(userPermission);\n            }\n          }\n        }\n    }\n\n   /**\n    *  Adds a property change listener.\n    *  @param listener The property change listener to add.\n    **/\n    public void addPropertyChangeListener(PropertyChangeListener listener)\n    {\n       if (listener == null)\n       {\n          Trace.log(Trace.ERROR, \"Parameter 'listener' is null.\");\n          throw new NullPointerException(\"listener\");\n       }\n       \n       changes_.addPropertyChangeListener(listener);\n    }\n  \n    /**\n     * Adds a user permission.\n     * @param userPermission The UserPermission object.\n     *\n    **/\n    public void addUserPermission(UserPermission userPermission)\n    {\n        if (userPermission == null) throw new NullPointerException(\"userPermission\");\n\n        switch (type_)\n        {\n            case TYPE_DLO : \n                if (userPermission instanceof com.ibm.as400.access.DLOPermission)\n                    break;\n            case TYPE_QSYS : \n                if (userPermission instanceof com.ibm.as400.access.QSYSPermission)\n                    break;\n            case TYPE_ROOT : \n                if (userPermission instanceof com.ibm.as400.access.RootPermission)\n                    break;\n            default :\n                throw new ExtendedIllegalArgumentException(\"userPermission\",\n                          ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        String user = userPermission.getUserID();\n\n        synchronized (userPermissionsLock_)\n        {\n          if (getUserIndex(user,userPermissions_) != -1)\n          {\n            Trace.log(Trace.ERROR, \"Permission already exists for user \" + user);  // @B2a\n            throw new ExtendedIllegalArgumentException(\"userProfileName (\"+user+\")\",\n                                                       ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n          } \n          else\n          {\n            int index=getUserIndex(user,userPermissionsBuffer_);\n            if (index != -1)\n            {\n              //UserPermission usrAut = (UserPermission)userPermissionsBuffer_.elementAt(index);\n              userPermission.setCommitted(UserPermission.COMMIT_CHANGE);\n              userPermissionsBuffer_.setElementAt(userPermission,index);\n              userPermissions_.addElement(userPermission);\n            } \n            else\n            {\n              userPermission.setCommitted(UserPermission.COMMIT_ADD);\n              userPermissionsBuffer_.addElement(userPermission);\n              userPermissions_.addElement(userPermission);\n            }\n          }\n        }\n    }\n\n    /**\n     * Commits the permission changes to the system.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ConnectionDroppedException If the connection is dropped unexpectedly.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception ObjectDoesNotExistException If the system object does not exist.\n     * @exception ServerStartupException If the host server cannot be started.\n     *\n    **/\n    public synchronized void commit()\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   ServerStartupException\n    {\n      if (isCommitted())\n        return;\n      // Add loop to allow for the fact that there are cases where UserPermission @A1A\n      // changes must occur before the sensitivityLevel_ changes.                 @A1A\n      for (int numberOfCommitAttempts=1; numberOfCommitAttempts <= 2; numberOfCommitAttempts++) // @A1A\n      {                                                                        // @A1A\n        try \n        {\n          try                                                                  // @A1A\n          {                                                                    // @A1A\n            if (autListChanged_)\n            {\n              access_.setAuthorizationList(path_,authorizationList_,autListBackup_);\n              autListChanged_ = false;\n            }\n            if (sensitivityChanged_)\n            {\n              access_.setSensitivity(path_,sensitivityLevel_);\n              sensitivityChanged_ = false;\n            }\n            if (ownerChanged_)               // @B2a\n            {\n              // Removed code which prepended asp since the asp is already in the path_  @A4D\n              access_.setOwner(path_, owner_, revokeOldAuthority_); // @B6c // @A4C\n              ownerChanged_ = false;\n            }\n            if (primaryGroupChanged_)\n            {\n              access_.setPrimaryGroup(path_,primaryGroup_,revokeOldGroupAuthority_);\n              primaryGroupChanged_ = false;\n            }\n          }                                               // End try-block @A1A\n          catch (AS400Exception e)                                      // @A1A\n          {                                                             // @A1A\n            Trace.log(Trace.ERROR, e);\n            if (numberOfCommitAttempts == 2)                            // @A1A\n            {\n              // Failure on second attempt... throw error.\n              throw e;                                                  // @A1A\n            }\n            else                                                        // @A1A\n            {\n              // Failure on first attempt... ignore error...\n              // Let's keep going and try to perform potential userPermission \n              // changes, and then reattempt the above changes.  Some changes\n              // require the UserPermission change to occur first.\n            }\n          }                                                   // end-catch @A1A\n\n          synchronized (userPermissionsLock_)\n          {\n            int count = userPermissionsBuffer_.size();\n            for (int i=count-1;i>=0;i--)\n            {\n              UserPermission userPermission = (UserPermission)\n                userPermissionsBuffer_.elementAt(i);\n              switch(userPermission.getCommitted())\n              {\n                case UserPermission.COMMIT_FROM_AUTL :\n                  access_.setFromAuthorizationList(path_,userPermission.isFromAuthorizationList());\n                  userPermission.setCommitted(UserPermission.COMMIT_NONE);\n                  break;\n                case UserPermission.COMMIT_ADD :\n                  access_.addUser(path_,userPermission);\n                  userPermission.setCommitted(UserPermission.COMMIT_NONE);\n                  break;\n                case UserPermission.COMMIT_CHANGE :\n                  access_.setAuthority(path_,userPermission);\n                  userPermission.setCommitted(UserPermission.COMMIT_NONE);\n                  break;\n                case UserPermission.COMMIT_REMOVE :\n                  // Removed code which prepended asp since the asp is already in the path_  @A4D\n                  access_.removeUser(path_,userPermission.getUserID());     // @B6c //@A4C\n                  userPermission.setCommitted(UserPermission.COMMIT_NONE);\n                  userPermissionsBuffer_.removeElement(userPermission);\n                  break;\n                case UserPermission.COMMIT_NONE :\n                default :\n                  break;\n              }\n            }\n          }\n        }\n        catch (PropertyVetoException e) { // should never happen\n          Trace.log(Trace.ERROR, e);\n        }\n      }                                 //end numberOfCommitAttempts loop @A1A\n\n      changes_.firePropertyChange(\"permission\",null,this);\n    }\n\n    /**\n     * Returns the authorizations list of the object.\n     * @return The authorizations list of the object.\n     * @see #setAuthorizationList(String)\n     *\n    **/\n    public String getAuthorizationList()\n    {\n        return authorizationList_;\n    }\n\n    /**\n     * Returns an enumeration of authorized users.\n     * @return An enumeration of authorized users.\n     *\n    **/\n    public Enumeration getAuthorizedUsers()\n    {\n      synchronized (userPermissionsLock_)\n      {\n        int count = userPermissions_.size();\n        Vector names = new Vector();\n        for (int i=0;i<count;i++)\n        {\n          UserPermission userPermission = (UserPermission)userPermissions_.elementAt(i);\n          names.addElement(userPermission.getUserID());\n        }\n        return names.elements();\n      }\n    }\n\n    \n    /** \n     * Returns the path of the integrated file system object whose permission is represented by this object.\n     * @return The integrated file system path name.\n     *\n    **/\n    public String getObjectPath()\n    {          \n      // @A3 The ASP is already part of the path. (e.g. /iasp123/QSYS.LIB/xyz.lib)\n      // String fullPath;                                 //@A3D\n      // if (asp_.equals(\"\"))                             //@A3D\n      //   fullPath = path_;                              //@A3D\n      // else                                             //@A3D\n      //   fullPath = \"/\"+ asp_ + \"/\" + path_;            //@A3D\n        return (path_);\n    }\n\n    /**\n     * Returns the name of the object whose permission is represented by this object.\n     * @return The name of the object.\n     *\n    **/\n    public String getName()\n    {\n        return name_;\n    }\n\n    /**\n     * Returns the object owner.\n     * @return The object owner.\n     *\n    **/\n    public String getOwner()\n    {\n        return owner_;\n    }\n\n    /**\n     * Returns the primary group of the object.\n     * @return The primary group of the object.\n     *\n    **/\n    public String getPrimaryGroup()\n    {\n        return primaryGroup_;\n    }\n\n    /**\n     * Returns the sensitivity level of the object.\n     * @return The sensitivity level of the object.\n     * <UL>\n     * <LI>0 : This value does not apply to this object.\n     * <LI>1 : (*NONE) The document has no sensitivity restrictions.\n     * <LI>2 : (*PERSONAL) The document is intended for the user as an\n     *      individual.\n     * <LI>3 : (*PRIVATE) The document contains information that should be\n     *      accessed only by the owner.  This value cannot be\n     *      specified if the access code zero (0) is assigned to\n     *      the object.\n     * <LI>4 : (*CONFIDENTIAL) The document contains information that should\n     *      be handled according to company procedures.\n     * </UL>\n     * @see #setSensitivityLevel\n     *\n    **/\n    public int getSensitivityLevel()\n    {\n        return sensitivityLevel_;\n    }\n\n    /**\n     * Returns the system\n     * @return The system instance. \n     *\n    **/\n    public AS400 getSystem()\n    {\n        return as400_;\n    }\n\n    /**\n     * Returns the object type.\n     * @return The object type. The possible values are:\n     * <ul>\n     *    <li> TYPE_DLO - Indicating the object is a Document Library Objects (DLO)\n     * stored in QDLS.\n     *    <li> TYPE_QSYS - Indicating the object is contained in the system library\n     * structure and stored in QSYS.LIB.\n     *    <li> TYPE_ROOT - Indicating the object is contained in the root directory \n     * structure. This includes everything that is not in QSYS.LIB or QDLS.\n     * </ul>\n     *\n    **/\n    public int getType()\n    {\n        return type_;\n    }\n\n    /*\n     Searches a user in specified vector.\n    */\n    private int getUserIndex(String userProfileName,Vector vector)\n    {\n        int count = vector.size();\n        for (int i=0;i<count;i++)\n        {\n            UserPermission userPermission =\n                           (UserPermission)vector.elementAt(i);\n            if (userPermission.getUserID().equals(userProfileName))\n                return i;\n        }\n        return -1;\n    }\n\n\n    /**\n     * Returns a UserPermission object for the specified user.\n     * If the specified user profile has no explicit authority to the object,\n     * returns null.\n     * @param userProfileName The name of the user profile.\n     * @return The specific Permission object.\n     *\n    **/\n    public UserPermission getUserPermission(String userProfileName)\n    {\n      if (userProfileName == null) throw new NullPointerException(\"userProfileName\");\n\n        String userName = userProfileName.toUpperCase();\n        synchronized (userPermissionsLock_)\n        {\n          int index = getUserIndex(userName,userPermissions_);\n\n          if (index != -1)\n          {\n            return (UserPermission)userPermissions_.elementAt(index);\n          }\n          return null;\n        }\n    }\n\n    /**\n     * Returns an enumeration of UserPermission objects.\n     * @return An enumeration of UserPermission objects.\n     *\n    **/\n    public Enumeration getUserPermissions()\n    {\n      synchronized (userPermissionsLock_)\n      {\n        return userPermissions_.elements();\n      }\n    }\n\n    \n    /**\n     * Returns a flag indicating whether the change has been committed.\n     * @return The flag indicating whether the change has been committed.\n    **/\n    public boolean isCommitted()\n    {\n        boolean committed = true;\n        synchronized (userPermissionsLock_)\n        {\n          int count = userPermissionsBuffer_.size();\n          if (sensitivityChanged_ == true)\n          {\n            return false;\n          }\n          if (autListChanged_ == true)\n          {\n            return false;\n          }\n          if (ownerChanged_ == true)               // @B2a\n          {\n            return false;\n          }\n          if (primaryGroupChanged_ == true)\n          {\n            return false;\n          }\n          for (int i=0;i<count;i++)\n          {\n            UserPermission userPermission = (UserPermission)\n              userPermissionsBuffer_.elementAt(i);\n            if (userPermission.getCommitted() !=\n                UserPermission.COMMIT_NONE)\n            {\n              committed = false;\n              break;\n            }\n          }\n          return committed;\n        }\n    }\n\n\n    /**\n     * Returns whether symbolic links are resolved when changing or retrieving permissions.\n     * @return Whether symbolic links are resolved.\n     *\n    **/\n    public boolean isFollowSymbolicLinks()\n    {\n      return followSymbolicLinks_;\n    }\n\n    /*\n     Parses object's type by full path name.\n    */\n    private int parseType(String objectName, boolean pathMayStartWithIASP)      // @B6c\n    {\n       if (Trace.traceOn_) {\n         Trace.log(Trace.INFORMATION, \"IASP flag is: \" + pathMayStartWithIASP + \", object name: \" + objectName);\n       }\n\n       if (pathMayStartWithIASP)                                                // @B6a\n       {                                                                        // @B6a\n          String name = objectName.toUpperCase();                               // @B6a\n                                                                                // @B6a\n          // make sure local copy of name ends with \"/\".  That way we           // @B6a\n          // can easily tell the difference between /QDLS and                   // @B6a\n          // /QDLS_for_me.                                                      // @B6a                                                                             \n          if (! name.endsWith(\"/\"))                                             // @B6a\n             name = name + \"/\";                                                 // @B6a\n                                                                                // @B6a\n          int locationOfQSYS = name.indexOf(\"/QSYS.LIB/\");                      // @B6a\n                                                                                // @B6a\n          if (locationOfQSYS >= 0)  // if QSYS.LIB is someplace in the name     // @B6a\n          {                                                                     // @B6a\n              if (locationOfQSYS > 0)  // if the name starts with QSYS.LIB      // @B6a\n              {                                                                 // @B6a\n                 // QSYS.LIB is not the first component of the path.  First,    // @B6a\n                 // set \"asp\" to everything before /QSYS.LIB\" except the        // @B6a\n                 // first and last slash.                                       // @B6a\n                 String asp = name.substring(1, locationOfQSYS);                // @B6a\n                                                                                // @B6a\n                 // does 'asp' contain a slash?  If yes then it is not an ASP   // @B6a\n                 // name, just the name of an object in the root file system.   // @B6a\n                 // If asp does not contain a slash then it is an ASP name.     // @B6a\n                 // Set class variable asp_ to \"/aspName\".  Set class variable  // @B6a\n                 // path_ to \"/QSYS.LIB/...\".                                   // @B6a\n                 if (asp.indexOf('/') < 0)                                      // @B6a\n                 {                                                              // @B6a\n                    asp_  = objectName.substring(0, locationOfQSYS);            // @B6a\n                    // @A3 Leave the ASP in the path. (e.g. /iasp123/QSYS.LIB/xyz.lib)\n                    // path_ = objectName.substring(locationOfQSYS);            // @B6a //@A3D\n                    return TYPE_QSYS;                                           // @B6a\n                 }                                                              // @B6a\n                 else                                                           // @B6a\n                    ;  // Don't do anything.  QSYS.LIB is not the second        // @B6a\n                       // component of the name so this object is not a QSYS    // @B6a\n                       // object on an ASP, it is a normal root file            // @B6a\n                       // system object.                                        // @B6a\n              }                                                                 // @B6a\n              else     // The name starts with QSYS                             // @B6a\n                 return TYPE_QSYS;                                              // @B6a\n          }                                                                     // @B6a\n                                                                                // @B6a\n          if (name.startsWith(\"/QDLS/\"))                                        // @B6a\n          {                                                                     // @B6a\n             return TYPE_DLO;                                                   // @B6a\n          }                                                                     // @B6a\n                                                                                // @B6a\n          return  TYPE_ROOT;                                                    // @B6a\n       }                                                                        // @B6a\n       else                                                                     // @B6a\n       {                                                                        // @B6a\n         String name = objectName.toUpperCase();                                // @A2A\n        if(name.startsWith(\"/QSYS.LIB/\") || name.equals(\"/QSYS.LIB\"))           // @A2C\n        {\n            return TYPE_QSYS;\n        }\n//      if(objectName.toUpperCase().startsWith(\"/QDLS/\") || objectName.toUpperCase().equals(\"/QDLS\"))   // @1JUC check to see if it is the qdls root folder\n        if(name.startsWith(\"/QDLS/\") || name.equals(\"/QDLS\"))   // @A2C @1JUC check to see if it is the qdls root folder\n        {\n            return TYPE_DLO;\n        }\n        return  TYPE_ROOT;\n       }                                                                        // @B6a   \n    }\n\n\n    /**\n     * Serialization support.  \n     * @exception Thrown when an application tries to load in a class through its string name,\n     *            but no definition for the class with the specifed name could be found. \n     * @exception IOException If an error occurs while communicating with the system.\n     *\n    **/\n    private void readObject(ObjectInputStream s)\n      throws ClassNotFoundException, IOException \n    {   \n        int size;\n        s.defaultReadObject();\n        switch(type_)\n        {\n            case TYPE_QSYS :\n                access_ = new PermissionAccessQSYS(as400_);\n                break;\n            case TYPE_DLO :\n                access_ = new PermissionAccessDLO(as400_);\n                break;\n            case TYPE_ROOT :\n            default :\n                access_ = new PermissionAccessRoot(as400_);\n                break;\n        }\n        access_.setFollowSymbolicLinks(followSymbolicLinks_);\n\n        userPermissionsLock_ = new Object();\n        userPermissionsBuffer_ = new Vector ();\n        userPermissions_ = new Vector();\n        size = ((Integer)s.readObject()).intValue();\n        for (int i=0;i<size;i++)\n        {\n            userPermissionsBuffer_.addElement(s.readObject());\n        }\n        size = ((Integer)s.readObject()).intValue();\n        for (int i=0;i<size;i++)\n        {\n            userPermissions_.addElement(s.readObject());\n        }\n        changes_ = new PropertyChangeSupport(this);\n        s.readObject();\n    }\n\n    /**\n     * Removes an authorized user.\n     * @param userProfileName The authorized user profile name.\n     *\n    **/\n    public void removeAuthorizedUser(String userProfileName)\n    {\n        if (userProfileName == null) throw new NullPointerException(\"userProfileName\");\n\n        String userName = userProfileName.trim().toUpperCase();\n        UserPermission userPermission = getUserPermission(userName);\n        if (userPermission != null)\n        {\n            removeUserPermission(userPermission);\n        }else\n        {\n            Trace.log(Trace.ERROR, \"Permission does not exist for user \" + userProfileName);  // @B2a\n            throw new ExtendedIllegalArgumentException(\"userProfileName (\"+userName+\")\",\n                  ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n    }\n\n   \n\n   /**\n    *  Removes a property change listener.\n    *  @param listener The property change listener to remove.\n   **/\n   public void removePropertyChangeListener(PropertyChangeListener listener)\n   {\n     if (listener == null)\n     {\n       Trace.log(Trace.ERROR, \"Parameter 'listener' is null.\");\n       throw new NullPointerException(\"listener\");\n     }\n\n     changes_.removePropertyChangeListener(listener);\n   }\n   \n    /**\n     * Removes a user permission.\n     * @param permission The UserPermission object.\n     *\n    **/\n    public void removeUserPermission(UserPermission permission)\n    {   \n        if (permission == null) throw new NullPointerException(\"permission\");\n\n        synchronized (userPermissionsLock_)\n        {\n          if (userPermissions_.indexOf(permission) == -1)\n          {\n            Trace.log(Trace.ERROR, \"Permission does not exist for user \" + permission.getUserID());  // @B2a\n            throw new ExtendedIllegalArgumentException\n              (\"permission\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID); // @B2c\n          } \n          else\n          {\n            switch (permission.getCommitted())\n            {\n              case UserPermission.COMMIT_ADD :\n                userPermissions_.removeElement(permission);\n                userPermissionsBuffer_.removeElement(permission);\n                permission.setCommitted(UserPermission.COMMIT_NONE);\n                break;\n              case UserPermission.COMMIT_REMOVE :\n              case UserPermission.COMMIT_CHANGE :\n              case UserPermission.COMMIT_NONE :\n              default :\n                permission.setCommitted(UserPermission.COMMIT_REMOVE);\n                userPermissions_.removeElement(permission);\n                break;\n            }\n          }\n        }\n    }\n\n    /**\n     * Sets the authorizations list of the object. For example:\n     * <p><blockquote><pre>\n     * Permission permisson = new Permisson(new AS400(),\"/QSYS.LIB/FRED.LIB\";\n     * permission.setAuthorizationList(\"testautl\");\n     * System.out.println(\"The authorization list of fred.lib is \" + permissin.geAuthorizationList();\n     * permission.setAuthorizationList(\"*NONE\");\n     * System.out.println(\"The authorization list of fred.lib is \" + permissin.geAuthorizationList();\n     * </pre></blockquote></p>\n     * @param autList The authorizations list of the object.\n     *\n    **/\n    public synchronized void setAuthorizationList(String autList)\n    {\n        if (autList == null) throw new NullPointerException(\"autList\");\n        if (autList.trim().equalsIgnoreCase(authorizationList_))\n            return;\n        if (autListChanged_== false)\n            autListBackup_ = authorizationList_;\n        authorizationList_ = autList.trim().toUpperCase();\n        autListChanged_ = true;\n    }\n\n    // @B2a\n    /**\n     * Sets the owner of the object.\n     * @param owner The owner of the object.\n     * @param revokeOldAuthority Specifies whether the authorities for the current\n     * owner are revoked when ownership is transferred to the new owner. \n     *\n     * @see #getOwner\n    **/\n    public synchronized void setOwner(String owner, boolean revokeOldAuthority)\n    {\n        if (owner == null) throw new NullPointerException(\"owner\");\n\n        owner_ = owner;\n        revokeOldAuthority_ = revokeOldAuthority;\n        ownerChanged_ = true;\n    }\n\n    /**\n     * Sets the primary group of the object.\n     * @param primaryGroup The primary group of the object.\n     * @param revokeOldAuthority Specifies whether the authorities for the current\n     * primary group are revoked when the primary group is changed to the new value.\n     *\n    **/\n    public void setPrimaryGroup(String primaryGroup, boolean revokeOldAuthority)\n    {\n        if (primaryGroup == null) throw new NullPointerException(\"primaryGroup\");\n        primaryGroup_ = primaryGroup;\n        revokeOldGroupAuthority_ = revokeOldAuthority;\n        primaryGroupChanged_ = true;\n    }\n\n\n    /**\n     * Sets the sensitivity level of the object.\n     * @param sensitivityLevel The sensitivity level of the object.  The\n     * possible values :\n     * <UL>\n     * <LI>0 : This value does not apply to this object.\n     * <LI>1 : (*NONE) The document has no sensitivity restrictions.\n     * <LI>2 : (*PERSONAL) The document is intended for the user as an\n     *      individual.\n     * <LI>3 : (*PRIVATE) The document contains information that should be\n     *      accessed only by the owner.  This value cannot be\n     *      specified if the access code zero (0) is assigned to\n     *      the object.\n     * <LI>4 : (*CONFIDENTIAL) The document contains information that should\n     *      be handled according to company procedures.\n     * </UL>\n     *\n     * @see #getSensitivityLevel\n    **/\n    public synchronized void setSensitivityLevel(int sensitivityLevel)\n    {\n        if (sensitivityLevel < 0 || sensitivityLevel > 4)\n        {\n            throw new ExtendedIllegalArgumentException(\"sensitivityLevel (\"+sensitivityLevel+\")\",\n                  ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID );\n        }\n        sensitivityLevel_ = sensitivityLevel;\n        sensitivityChanged_ = true;\n    }\n\n    /**\n     * Sets the system where system value is retrieved.\n     *\n     * @param   system The system object.\n     * @see     #getSystem\n     * @deprecated This method is of little (or no) known usefulness. If you require this method, please notify the Toolbox support team.\n    **/\n    public synchronized void setSystem(AS400 system)\n    {   \n        if (system == null) throw new NullPointerException(\"system\");\n        \n        if (as400_ == null)                        //$B1C\n           as400_ = system;                        //$B1C\n        else                                       //$B1C\n        {  \n            if (as400_.isConnected())\n            {\n                throw new ExtendedIllegalStateException(\"system\",\n                    ExtendedIllegalStateException.PROPERTY_NOT_CHANGED);\n            }\n            if (as400_.equals(system)==true)\n               return;\n        }\n\n        switch(type_)\n        {\n            case TYPE_QSYS :\n                access_ = new PermissionAccessQSYS(as400_);\n                break;\n            case TYPE_DLO :\n                access_ = new PermissionAccessDLO(as400_);\n                break;\n            case TYPE_ROOT :\n            default :\n                access_ = new PermissionAccessRoot(as400_);\n                break;\n        }\n        access_.setFollowSymbolicLinks(followSymbolicLinks_);\n        // Assume that, since we're (re)connecting to the same system we were originally connected to, that none of the permissions information needs to be re-retrieved.\n    }\n    \n    /**\n     * Serialization support.  \n     * @exception IOException If an error occurs while communicating with the system.\n     *\n    **/\n    private void writeObject(ObjectOutputStream s) \n                 throws IOException\n    {\n        s.defaultWriteObject();\n\n        synchronized (userPermissionsLock_)\n        {\n          s.writeObject(new Integer(userPermissionsBuffer_.size()));\n          for (int i=0;i<userPermissionsBuffer_.size();i++)\n          {\n            s.writeObject(userPermissionsBuffer_.elementAt(i));\n          }\n          s.writeObject(new Integer(userPermissions_.size()));\n          for (int i=0;i<userPermissions_.size();i++)\n          {\n            s.writeObject(userPermissions_.elementAt(i));\n          }\n\n          s.writeObject(null);\n        }\n    }\n\n\n\n\t/**\n\t * Removes the specified record from the table.\n\t * @param permissionTableModelQSYS TODO\n\t * @param  row  The index of row.\n\t */\n\tpublic void removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)\n\t{\n\t     permissionTableModelQSYS.table_.clearSelection();   \n\t     QSYSPermission user = (QSYSPermission)permissionTableModelQSYS.userPermissions_.elementAt(row);\n\t     removeAuthorizedUser(user.getUserID());\n\t\n\t     // Gets the new data after removing the specified user.\n\t     Enumeration userPermissions = getUserPermissions();\n\t     permissionTableModelQSYS.userPermissions_ = new Vector();\n\t     while(userPermissions.hasMoreElements())\n\t     {\n\t        permissionTableModelQSYS.userPermissions_.addElement(userPermissions.nextElement());\n\t     }\n\t     permissionTableModelQSYS.fireTableRowsDeleted(row, row);\n\t}\n    \n}",
                "methodCount": 36
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 1280,
                        "lineEnd": 1299,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method removeRow2 to class PermissionTableModelQSYS",
                        "description": "Move method removeRow2 to com.ibm.as400.vaccess.PermissionTableModelQSYS\nRationale: The method removeRow2() is responsible for removing a user permission from the table model, which directly relates to the functionality of the PermissionTableModelQSYS class. This class is designed to manage user permissions in a table format, and the method's operations, such as clearing selections, updating user permissions, and firing table row deletion events, are all actions that should logically reside within this class. Moving this method to PermissionTableModelQSYS will enhance cohesion by keeping related functionality together, as it deals with the internal state of the permission table model.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "removeRow2",
                            "method_signature": "public void removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)",
                            "target_class": "PermissionTableModelQSYS",
                            "rationale": "The removeRow2 method is directly manipulating the PermissionTableModelQSYS and its user permissions, which indicates that it belongs in the PermissionTableModelQSYS class rather than the Permission class."
                        }
                    ],
                    "llm_response_time": 4907
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "removeRow2",
                            "method_signature": "public void removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)",
                            "target_class": "PermissionTableModelQSYS",
                            "rationale": "The removeRow2 method is directly manipulating the PermissionTableModelQSYS and its user permissions, which indicates it is more related to the table model's functionality rather than the Permission class itself."
                        }
                    ],
                    "llm_response_time": 3948
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "removeRow2",
                            "method_signature": "public void removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)",
                            "target_class": "PermissionTableModelQSYS",
                            "rationale": "The removeRow2 method is directly manipulating the PermissionTableModelQSYS and should logically belong to that class, as it deals with the table model's data and its representation."
                        }
                    ],
                    "llm_response_time": 3680
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "addUserPermission",
                            "method_signature": "public addUserPermission(UserPermission userPermission)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "commit",
                            "method_signature": "public synchronized commit()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "readObject",
                            "method_signature": "private readObject(ObjectInputStream s)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeUserPermission",
                            "method_signature": "public removeUserPermission(UserPermission permission)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeRow2",
                            "method_signature": "public removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "addUserPermission",
                            "method_signature": "public addUserPermission(UserPermission userPermission)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeUserPermission",
                            "method_signature": "public removeUserPermission(UserPermission permission)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "readObject",
                            "method_signature": "private readObject(ObjectInputStream s)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeRow2",
                            "method_signature": "public removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "commit",
                            "method_signature": "public synchronized commit()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public addUserPermission(UserPermission userPermission)": {
                        "first": {
                            "method_name": "addUserPermission",
                            "method_signature": "public addUserPermission(UserPermission userPermission)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.49612247093656486
                    },
                    "public removeUserPermission(UserPermission permission)": {
                        "first": {
                            "method_name": "removeUserPermission",
                            "method_signature": "public removeUserPermission(UserPermission permission)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5030651039276104
                    },
                    "private readObject(ObjectInputStream s)": {
                        "first": {
                            "method_name": "readObject",
                            "method_signature": "private readObject(ObjectInputStream s)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5349058735751265
                    },
                    "public removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)": {
                        "first": {
                            "method_name": "removeRow2",
                            "method_signature": "public removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6213046700957583
                    },
                    "public synchronized commit()": {
                        "first": {
                            "method_name": "commit",
                            "method_signature": "public synchronized commit()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7123262360886672
                    }
                },
                "voyage": {
                    "public removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)": {
                        "first": {
                            "method_name": "removeRow2",
                            "method_signature": "public removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.45884343557864116
                    },
                    "public removeUserPermission(UserPermission permission)": {
                        "first": {
                            "method_name": "removeUserPermission",
                            "method_signature": "public removeUserPermission(UserPermission permission)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5771861984806715
                    },
                    "public synchronized commit()": {
                        "first": {
                            "method_name": "commit",
                            "method_signature": "public synchronized commit()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6526789525476469
                    },
                    "public addUserPermission(UserPermission userPermission)": {
                        "first": {
                            "method_name": "addUserPermission",
                            "method_signature": "public addUserPermission(UserPermission userPermission)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6887851733768661
                    },
                    "private readObject(ObjectInputStream s)": {
                        "first": {
                            "method_name": "readObject",
                            "method_signature": "private readObject(ObjectInputStream s)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6983520926625572
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public synchronized commit()",
                        "public addUserPermission(UserPermission userPermission)",
                        "public removeUserPermission(UserPermission permission)",
                        "public removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)",
                        "private readObject(ObjectInputStream s)"
                    ],
                    "llm_response_time": 1637
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public synchronized commit()",
                        "public addUserPermission(UserPermission userPermission)",
                        "public removeUserPermission(UserPermission permission)",
                        "public removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)",
                        "private readObject(ObjectInputStream s)"
                    ],
                    "llm_response_time": 1
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public addUserPermission(UserPermission userPermission)",
                        "public removeUserPermission(UserPermission permission)",
                        "private readObject(ObjectInputStream s)"
                    ],
                    "llm_response_time": 914
                },
                "voyage": {
                    "priority_method_names": [
                        "public synchronized commit()",
                        "public removeUserPermission(UserPermission permission)",
                        "public addUserPermission(UserPermission userPermission)",
                        "public removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)",
                        "private readObject(ObjectInputStream s)"
                    ],
                    "llm_response_time": 1209
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public synchronized commit()",
                        "public removeUserPermission(UserPermission permission)",
                        "public addUserPermission(UserPermission userPermission)",
                        "public removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)",
                        "private readObject(ObjectInputStream s)"
                    ],
                    "llm_response_time": 1
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public synchronized commit()",
                        "public removeUserPermission(UserPermission permission)",
                        "public removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)"
                    ],
                    "llm_response_time": 1064
                }
            },
            "targetClassMap": {
                "addUserPermission": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 5579,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "removeUserPermission": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3177,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "readObject": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4361,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "removeRow2": {
                    "target_classes": [
                        {
                            "class_name": "PermissionTableModelQSYS",
                            "similarity_score": 0.6764280756176033
                        },
                        {
                            "class_name": "AS400",
                            "similarity_score": 0.5464941191201543
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PermissionTableModelQSYS",
                        "AS400"
                    ],
                    "llm_response_time": 10290,
                    "similarity_computation_time": 12,
                    "similarity_metric": "cosine"
                },
                "commit": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3189,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.access.AS400ZonedDecimal::addToHashtable(PcmlDocNode):void need move com.ibm.as400.data.PcmlDocument",
        "class_name": "com.ibm.as400.access.AS400ZonedDecimal",
        "telemetry": {
            "id": "73ca1d29-8185-458a-80af-38823e9a9429",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 546,
                "lineStart": 25,
                "lineEnd": 570,
                "bodyLineStart": 25,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/large/big/jtopen-7.8/src/com/ibm/as400/access/AS400ZonedDecimal.java",
                "sourceCode": "/**\n *  The AS400ZonedDecimal class provides a converter between a BigDecimal object and a zoned decimal format floating point number.\n **/\npublic class AS400ZonedDecimal implements AS400DataType\n{\n    static final long serialVersionUID = 4L;\n\n    private int digits;\n    private int scale;\n    private static final long defaultValue = 0;\n    private static final boolean HIGH_NIBBLE = AS400PackedDecimal.HIGH_NIBBLE;\n    private static final boolean LOW_NIBBLE  = AS400PackedDecimal.LOW_NIBBLE;\n\n    private boolean useDouble_ = false;\n\n    /**\n     * Constructs an AS400ZonedDecimal object.\n     * @param numDigits The number of digits in the zoned decimal number. It must be greater than or equal to one and less than or equal to thirty-one.\n     * @param numDecimalPositions The number of decimal positions in the zoned decimal number. It must be greater than or equal to zero and less than or equal to <i>numDigits</i>.\n     */\n    public AS400ZonedDecimal(int numDigits, int numDecimalPositions)\n    {\n     // check for valid input\n     if (numDigits < 1 || numDigits > 63) // @M0C - changed the upper limit here from 31 for JDBC support\n     {\n         throw new ExtendedIllegalArgumentException(\"numDigits (\" + String.valueOf(numDigits) + \")\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n     }\n     if (numDecimalPositions < 0 || numDecimalPositions > numDigits)\n     {\n         throw new ExtendedIllegalArgumentException(\"numDecimalPositions (\" + String.valueOf(numDecimalPositions) + \")\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n     }\n\n     // set instance variables\n     this.digits = numDigits;\n     this.scale = numDecimalPositions;\n    }\n\n    /**\n     * Creates a new AS400ZonedDecimal object that is identical to the current instance.\n     * @return The new object.\n     **/\n    public Object clone()\n    {\n     try\n     {\n         return super.clone();  // Object.clone does not throw exception\n     }\n     catch (CloneNotSupportedException e)\n     {\n         Trace.log(Trace.ERROR, \"Unexpected cloning error\", e);\n         throw new InternalErrorException(InternalErrorException.UNKNOWN);\n     }\n    }\n\n    /**\n     * Returns the byte length of the data type.\n     * @return The number of bytes in the IBM i representation of the data type.\n     **/\n    public int getByteLength()\n    {\n     return this.digits;\n    }\n\n    /**\n     * Returns a Java object representing the default value of the data type.\n     * @return The BigDecimal object with a value of zero.\n     **/\n    public Object getDefaultValue()\n    {\n     return BigDecimal.valueOf(defaultValue);\n    }\n\n    /**\n     * Returns {@link com.ibm.as400.access.AS400DataType#TYPE_ZONED TYPE_ZONED}.\n     * @return <tt>AS400DataType.TYPE_ZONED</tt>.\n    **/\n    public int getInstanceType()\n    {\n      return AS400DataType.TYPE_ZONED;\n    }\n\n    /**\n     * Returns the Java class that corresponds with this data type.\n     * @return <tt>BigDecimal.class</tt>.\n     **/\n    public Class getJavaType()\n    {\n      return BigDecimal.class;\n    }\n\n    /**\n     * Returns the total number of digits in the zoned decimal number.\n     * @return The number of digits.\n     **/\n    public int getNumberOfDigits()\n    {\n     return this.digits;\n    }\n\n    /**\n     * Returns the number of decimal positions in the zoned decimal number.\n     * @return The number of decimal positions.\n     **/\n    public int getNumberOfDecimalPositions()\n    {\n     return this.scale;\n    }\n\n    /**\n     * Indicates if a {@link java.lang.Double Double} object or a\n     * {@link java.math.BigDecimal BigDecimal} object will be returned\n     * on a call to {@link #toObject toObject()}.\n     * @return true if a Double will be returned, false if a BigDecimal\n     * will be returned.  The default is false.\n    **/\n    public boolean isUseDouble()\n    {\n      return useDouble_;\n    }\n\n    /**\n     * Sets whether to return a {@link java.lang.Double Double} object or a\n     * {@link java.math.BigDecimal BigDecimal} object on a call to\n     * {@link #toObject toObject()}.\n     * @see com.ibm.as400.access.AS400PackedDecimal#setUseDouble\n    **/\n    public void setUseDouble(boolean b)\n    {\n      useDouble_ = b;\n    }\n\n    /**\n     * Converts the specified Java object to IBM i format.\n     * @param javaValue The object corresponding to the data type.  It must be an instance of BigDecimal and the BigDecimal must have a less than or equal to number of digits and a less than or equal to number of decimal places.\n     * @return The IBM i representation of the data type.\n     **/\n    public byte[] toBytes(Object javaValue)\n    {\n     byte[] as400Value = new byte[this.digits];\n     this.toBytes(javaValue, as400Value, 0);\n     return as400Value;\n    }\n\n    /**\n     * Converts the specified Java object into IBM i format in the specified byte array.\n     * @param javaValue The object corresponding to the data type.  It must be an instance of BigDecimal and the BigDecimal must have a less than or equal to number of digits and a less than or equal to number of decimal places.\n     * @param as400Value The array to receive the data type in IBM i format.  There must be enough space to hold the IBM i value.\n     * @return The number of bytes in the IBM i representation of the data type.\n     **/\n    public int toBytes(Object javaValue, byte[] as400Value)\n    {\n     return this.toBytes(javaValue, as400Value, 0);\n    }\n\n    /**\n     * Converts the specified Java object into IBM i format in the specified byte array.\n     * @param javaValue The object corresponding to the data type. It must be an instance of BigDecimal and the BigDecimal must have a less than or equal to number of digits and a less than or equal to number of decimal places.\n     * @param as400Value The array to receive the data type in IBM i format.  There must be enough space to hold the IBM i value.\n     * @param offset The offset into the byte array for the start of the IBM i value. It must be greater than or equal to zero.\n     * @return The number of bytes in the IBM i representation of the data type.\n     **/\n    public int toBytes(Object javaValue, byte[] as400Value, int offset)\n    {\n     int outDigits = this.digits;\n     int outDecimalPlaces = this.scale;\n\n     // verify input\n     BigDecimal inValue = (BigDecimal)javaValue; // Let this line throw ClassCastException\n     if (inValue.scale() > outDecimalPlaces)  // Let this line throw NullPointerException\n     {\n         throw new ExtendedIllegalArgumentException(\"javaValue (\" + javaValue.toString() + \")\", ExtendedIllegalArgumentException.LENGTH_NOT_VALID);\n     }\n\n     // read the sign\n     int sign = inValue.signum();\n\n     // get just the digits from BigDecimal, \"normalize\" away sign, decimal place etc.\n     char[] inChars = inValue.abs().movePointRight(outDecimalPlaces).toBigInteger().toString().toCharArray();\n\n     // Check overall length\n     int inLength = inChars.length;\n     if (inLength > outDigits)\n     {\n         throw new ExtendedIllegalArgumentException(\"javaValue (\" + javaValue.toString() + \")\", ExtendedIllegalArgumentException.LENGTH_NOT_VALID);\n     }\n\n     int inPosition = 0; // position in char[]\n\n     // write correct number of leading zero's\n     for (int i=0; i<outDigits-inLength; ++i)\n     {\n         as400Value[offset++] = (byte)0xF0;\n     }\n\n     // place all the digits except the last one\n     while (inPosition < inChars.length-1)\n     {\n         as400Value[offset++] = (byte)((inChars[inPosition++] & 0x000F) | 0x00F0);\n     }\n\n     // place the sign and last digit\n     if (sign != -1)\n     {\n         as400Value[offset] = (byte)((inChars[inPosition] & 0x000F) | 0x00F0);\n     }\n     else\n     {\n         as400Value[offset] = (byte)((inChars[inPosition] & 0x000F) | 0x00D0);\n     }\n     return outDigits;\n    }\n\n    // @E0A\n    /**\n     * Converts the specified Java object to IBM i format.\n     *\n     * @param doubleValue   The value to be converted to IBM i format.  If the decimal part\n     *                      of this value needs to be truncated, it will be rounded towards\n     *                      zero.  If the integral part of this value needs to be truncated,\n     *                      an exception will be thrown.\n     * @return              The IBM i representation of the data type.\n     **/\n    public byte[] toBytes(double doubleValue)\n    {\n        byte[] as400Value = new byte[digits];\n        toBytes(doubleValue, as400Value, 0);\n        return as400Value;\n    }\n\n    // @E0A\n    /**\n     * Converts the specified Java object into IBM i format in\n     * the specified byte array.\n     *\n     * @param doubleValue   The value to be converted to IBM i format.  If the decimal part\n     *                      of this value needs to be truncated, it will be rounded towards\n     *                      zero.  If the integral part of this value needs to be truncated,\n     *                      an exception will be thrown.\n     * @param as400Value    The array to receive the data type in IBM i format.  There must\n     *                      be enough space to hold the IBM i value.\n     * @return              The number of bytes in the IBM i representation of the data type.\n     **/\n    public int toBytes(double doubleValue, byte[] as400Value)\n    {\n        return toBytes(doubleValue, as400Value, 0);\n    }\n\n    // @E0A\n    /**\n     * Converts the specified Java object into IBM i format in\n     * the specified byte array.\n     *\n     * @param doubleValue   The value to be converted to IBM i format.  If the decimal part\n     *                      of this value needs to be truncated, it will be rounded towards\n     *                      zero.  If the integral part of this value needs to be truncated,\n     *                      an exception will be thrown.\n     * @param as400Value    The array to receive the data type in IBM i format.\n     *                      There must be enough space to hold the IBM i value.\n     * @param offset        The offset into the byte array for the start of the IBM i value.\n     *                      It must be greater than or equal to zero.\n     * @return              The number of bytes in the IBM i representation of the data type.\n     **/\n    public int toBytes(double doubleValue, byte[] as400Value, int offset)\n    {\n        // GOAL:  For performance reasons, we need to do this conversion\n        //        without creating any Java objects (e.g., BigDecimals,\n        //        Strings).\n\n        // If the number is too big, we can't do anything with it.\n        double absValue = Math.abs(doubleValue);\n        if (absValue > Long.MAX_VALUE)\n            throw new ExtendedIllegalArgumentException(\"doubleValue\", ExtendedIllegalArgumentException.LENGTH_NOT_VALID);\n\n        // Extract the normalized value.  This is the value represented by\n        // two longs (one for each side of the decimal point).  Using longs\n        // here improves the quality of the algorithm as well as the\n        // performance of arithmetic operations.  We may need to use an\n        // \"effective\" scale due to the lack of precision representable\n        // by a long.\n        long leftSide = (long)absValue;\n        int effectiveScale = (scale > 15) ? 15 : scale;\n        long rightSide = (long)Math.round((absValue - (double)leftSide) * Math.pow(10, effectiveScale));\n\n        // Ok, now we are done with any double arithmetic!\n\n        // If the effective scale is different than the actual scale,\n        // then pad with zeros.\n        int rightmostOffset = offset + digits - 1;\n        int padOffset = rightmostOffset - (scale - effectiveScale);\n        for (int i = rightmostOffset; i > padOffset; --i)\n            as400Value[i] = (byte)0x00F0;\n\n        // Compute the bytes for the right side of the decimal point.\n        int decimalOffset = rightmostOffset - scale;\n        int nextDigit;\n        for (int i = padOffset; i > decimalOffset; --i) {\n            nextDigit = (int)(rightSide % 10);\n            as400Value[i] = (byte)(0x00F0 | nextDigit);\n            rightSide /= 10;\n        }\n\n        // Compute the bytes for the left side of the decimal point.\n        for (int i = decimalOffset; i >= offset; --i) {\n            nextDigit = (int)(leftSide % 10);\n            as400Value[i] = (byte)(0x00F0 | nextDigit);\n            leftSide /= 10;\n        }\n\n        // Fix the sign, if negative.\n        if (doubleValue < 0)\n            as400Value[rightmostOffset] = (byte)(as400Value[rightmostOffset] & 0x00DF);\n\n        // If left side still has digits, then the value was too big\n        // to fit.\n        if (leftSide > 0)\n            throw new ExtendedIllegalArgumentException(\"doubleValue\", ExtendedIllegalArgumentException.LENGTH_NOT_VALID);\n\n        return digits;\n    }\n\n    // @E0A\n    /**\n     * Converts the specified IBM i data type to a Java double value.  If the\n     * decimal part of the value needs to be truncated to be represented by a\n     * Java double value, then it is rounded towards zero.  If the integral\n     * part of the value needs to be truncated to be represented by a Java\n     * double value, then it converted to either Double.POSITIVE_INFINITY\n     * or Double.NEGATIVE_INFINITY.\n     *\n     * @param as400Value The array containing the data type in IBM i format.\n     *                   The entire data type must be represented.\n     * @return           The Java double value corresponding to the data type.\n     **/\n    public double toDouble(byte[] as400Value)\n    {\n        return toDouble(as400Value, 0);\n    }\n\n    // @E0A\n    /**\n     * Converts the specified IBM i data type to a Java double value.  If the\n     * decimal part of the value needs to be truncated to be represented by a\n     * Java double value, then it is rounded towards zero.  If the integral\n     * part of the value needs to be truncated to be represented by a Java\n     * double value, then it converted to either Double.POSITIVE_INFINITY\n     * or Double.NEGATIVE_INFINITY.\n     *\n     * @param as400Value The array containing the data type in IBM i format.\n     *                   The entire data type must be represented.\n     * @param offset     The offset into the byte array for the start of the IBM i value.\n     *                   It must be greater than or equal to zero.\n     * @return           The Java double value corresponding to the data type.\n     **/\n    public double toDouble(byte[] as400Value, int offset)\n    {\n        // Check the offset to prevent bogus NumberFormatException message.\n        if (offset < 0)\n            throw new ArrayIndexOutOfBoundsException(String.valueOf(offset));\n\n        // Compute the value.\n        /*\n         * This old code had a bug in that it can produce\n         * inexact answers. For example\n         * 10.10105 is turned into -10.101049999999999\n\n        double doubleValue = 0;\n        double multiplier = Math.pow(10, digits - scale - 1);\n        int rightMostOffset = offset + digits - 1;\n        for(int i = offset; i <= rightMostOffset; ++i) {\n            doubleValue += ((byte)(as400Value[i] & 0x000F)) * multiplier;\n            multiplier /= 10;\n        }\n        */\n\n        /*\n         * Instead we gather the digits using a long, then divide by the scale.\n         * Note:  Using a multiply by Math.pow(10, -scale) gives a worse answer.\n         * Math.pow(10,-scale) is a less accurate number than Math.pow(10,scale)\n         */\n\n        int rightMostOffset = offset + digits - 1;\n        double doubleValue = 0;\n        \n        if(digits < 18){//long type has a maximum value: 9223372036854775807\n        \tlong   longValue = 0;\n            double divisor = Math.pow(10, scale);\n            for(int i = offset; i <= rightMostOffset; ++i) {\n                longValue = longValue * 10 + (byte)(as400Value[i] & 0x000F);\n            }\n            doubleValue = longValue / divisor;\n        } else {\n        \tdouble multiplier = Math.pow(10, digits - scale - 1);\n            for(int i = offset; i <= rightMostOffset; ++i) {\n                doubleValue += ((byte)(as400Value[i] & 0x000F)) * multiplier;\n                multiplier /= 10;\n            }\n        }\n\n        // Determine the sign.\n        switch(as400Value[rightMostOffset] & 0x00F0) {\n            case 0x00B0:\n            case 0x00D0:\n                // Negative.\n                doubleValue *= -1;\n                break;\n            case 0x00A0:\n            case 0x00C0:\n            case 0x00E0:\n            case 0x00F0:\n                // Positive.\n                break;\n            default:\n                throwNumberFormatException(HIGH_NIBBLE, rightMostOffset,\n                                           as400Value[rightMostOffset] & 0x00FF,\n                                           as400Value);\n        }\n\n        return doubleValue;\n    }\n\n    /**\n     * Converts the specified IBM i data type to a Java object.\n     * @param as400Value The array containing the data type in IBM i format.  The entire data type must be represented.\n     * @return The BigDecimal object corresponding to the data type.\n     **/\n    public Object toObject(byte[] as400Value)\n    {\n     return this.toObject(as400Value, 0);\n    }\n\n    /**\n     * Converts the specified IBM i data type to a Java object.\n     * @param as400Value The array containing the data type in IBM i format.  The entire data type must be represented.\n     * @param offset The offset into the byte array for the start of the IBM i value.  It must be greater than or equal to zero.\n     * @return The BigDecimal object corresponding to the data type.\n     **/\n    public Object toObject(byte[] as400Value, int offset)\n    {\n      if (useDouble_) return new Double(toDouble(as400Value, offset));\n\n     // Check offset to prevent bogus NumberFormatException message\n     if (offset < 0)\n     {\n         throw new ArrayIndexOutOfBoundsException(String.valueOf(offset));\n     }\n\n     int size = this.digits;\n\n     int outputPosition = 0; // position in char[]\n     int digitsPlaced = 0; // number of digits moved from input to output\n\n     char[] outputData = null;\n     // read the sign bit, allow ArrayIndexException to be thrown\n     int nibble = (as400Value[offset+size-1] & 0xFF) >>> 4;\n     switch (nibble)\n     {\n         case 0x000B: // valid negative sign bits\n         case 0x000D:\n          outputData = new char[size+1];\n          outputData[outputPosition++] = '-';\n          break;\n         case 0x000A: // valid positive sign bits\n         case 0x000C:\n         case 0x000E:\n         case 0x000F:\n          outputData = new char[size];\n          break;\n         default: // others invalid\n          throwNumberFormatException(HIGH_NIBBLE, offset+size-1,\n                                     as400Value[offset+size-1] & 0xFF,\n                                     as400Value);\n     }\n\n     // place the digits\n     while (outputPosition < outputData.length)\n     {\n         nibble = as400Value[offset++] & 0x000F;\n         if (nibble > 0x0009)\n           throwNumberFormatException(LOW_NIBBLE, offset-1,\n                                      as400Value[offset-1] & 0x00FF,\n                                      as400Value);\n         outputData[outputPosition++] = (char)(nibble | 0x0030);\n     }\n\n     // construct New BigDecimal object\n     return new BigDecimal(new BigInteger(new String(outputData)), this.scale);\n    }\n\n    public void addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)                       // @C5A\n\t{                                                               // @C5A\n\t    String qName; // Qualified name of child                    // @C5A\n\t    Enumeration children;                                       // @C5A\n\t    PcmlDocNode child;                                          // @C5A\n\t\n\t    children = newChild.getChildren();                          // @C5A\n\t    if (children == null)                                       // @C5A\n\t        return;                                                 // @C5A\n\t\n\t    LinkedList queue = new LinkedList(); //@F4\n\t\tqueue.add(newChild);//@F4\n\t\twhile (!queue.isEmpty()) {//@F4\n\t\t\tchild = (PcmlDocNode) queue.getFirst();//@F4\n\t\t\tqueue.removeFirst();//@F4\n\t\n\t\t\tchildren = child.getChildren();//@F4\n\t\t\twhile (children.hasMoreElements()) {//@F4\n\t\t\t\tchild = (PcmlDocNode) children.nextElement();//@F4\n\t\t\t\tqName = child.getQualifiedName();//@F4\n\t\t\t\tif (!qName.equals(\"\")) {//@F4\n\t\t\t\t\tif (pcmlDocument.addElement(child) != null) {//@F4\n\t\t\t\t\t\tpcmlDocument.addPcmlSpecificationError(DAMRI.MULTIPLE_DEFINE, new Object[] { qName });//@F4\n\t\t\t\t\t}//@F4\n\t\t\t\t}//@F4\n\t\t\t\tqueue.add(child);//@F4\n\t\t\t}//@F4\n\t\n\t\t}\n\t\n\t\n\t}\n\n\tstatic final void throwNumberFormatException(boolean highNibble, int byteOffset, int byteValue, byte[] fieldBytes) throws NumberFormatException\n    {\n      String text;\n      if (highNibble) {\n        text = ResourceBundleLoader.getText(\"EXC_HIGH_NIBBLE_NOT_VALID\", Integer.toString(byteOffset), byteToString(byteValue));\n      }\n      else {\n        text = ResourceBundleLoader.getText(\"EXC_LOW_NIBBLE_NOT_VALID\", Integer.toString(byteOffset), byteToString(byteValue));\n      }\n      Trace.log(Trace.ERROR, \"Byte sequence is not valid for a field of type 'zoned decimal':\", fieldBytes);\n      throw new NumberFormatException(text);\n    }\n\n    private static final String byteToString(int byteVal)\n    {\n      int leftDigitValue = (byteVal >>> 4) & 0x0F;\n      int rightDigitValue = byteVal & 0x0F;\n      char[] digitChars = new char[2];\n      // 0x30 = '0', 0x41 = 'A'\n      digitChars[0] = leftDigitValue < 0x0A ? (char)(0x30 + leftDigitValue) : (char)(leftDigitValue - 0x0A + 0x41);\n      digitChars[1] = rightDigitValue < 0x0A ? (char)(0x30 + rightDigitValue) : (char)(rightDigitValue - 0x0A + 0x41);\n      return new String(digitChars);\n    }\n\n}",
                "methodCount": 23
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 512,
                        "lineEnd": 543,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method addToHashtable to class PcmlDocument",
                        "description": "Move method addToHashtable to com.ibm.as400.data.PcmlDocument\nRationale: The method addToHashtable() is primarily concerned with adding elements to a hashtable within the context of a PCML document. It interacts directly with the PcmlDocument instance by calling methods like addElement() and addPcmlSpecificationError(), which are specific to the PcmlDocument class. Moving this method to PcmlDocument will enhance cohesion, as it will reside in the class that manages the document's state and errors, making it more intuitive and maintainable.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "addToHashtable",
                            "method_signature": "public void addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)",
                            "target_class": "PcmlDocument",
                            "rationale": "The addToHashtable method is primarily concerned with adding elements to a PcmlDocument, which suggests that it belongs in the PcmlDocument class rather than AS400ZonedDecimal."
                        },
                        {
                            "method_name": "throwNumberFormatException",
                            "method_signature": "static final void throwNumberFormatException(boolean highNibble, int byteOffset, int byteValue, byte[] fieldBytes)",
                            "target_class": "NumberFormatExceptionHandler",
                            "rationale": "This method is responsible for throwing a NumberFormatException with a specific message, which is a utility function that could be better placed in a dedicated exception handling class."
                        },
                        {
                            "method_name": "byteToString",
                            "method_signature": "private static final String byteToString(int byteVal)",
                            "target_class": "ByteUtils",
                            "rationale": "The byteToString method is a utility function that converts a byte value to a string representation, which is a common utility operation that could be better placed in a utility class."
                        }
                    ],
                    "llm_response_time": 6740
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "addToHashtable",
                            "method_signature": "public void addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)",
                            "target_class": "PcmlDocument",
                            "rationale": "The addToHashtable method is responsible for adding elements to a PcmlDocument, which indicates that it is more related to the PcmlDocument class than the AS400ZonedDecimal class."
                        },
                        {
                            "method_name": "throwNumberFormatException",
                            "method_signature": "static final void throwNumberFormatException(boolean highNibble, int byteOffset, int byteValue, byte[] fieldBytes)",
                            "target_class": "NumberFormatExceptionHandler",
                            "rationale": "The throwNumberFormatException method is a utility function for handling number format exceptions and should be moved to a dedicated exception handling class for better separation of concerns."
                        },
                        {
                            "method_name": "byteToString",
                            "method_signature": "private static final String byteToString(int byteVal)",
                            "target_class": "ByteUtils",
                            "rationale": "The byteToString method is a utility function for converting byte values to strings and should be moved to a utility class dedicated to byte operations."
                        }
                    ],
                    "llm_response_time": 7319
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "addToHashtable",
                            "method_signature": "public void addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)",
                            "target_class": "PcmlDocument",
                            "rationale": "The addToHashtable method is primarily concerned with adding elements to a PcmlDocument, which suggests that it belongs in the PcmlDocument class rather than AS400ZonedDecimal."
                        },
                        {
                            "method_name": "throwNumberFormatException",
                            "method_signature": "static final void throwNumberFormatException(boolean highNibble, int byteOffset, int byteValue, byte[] fieldBytes)",
                            "target_class": "NumberFormatExceptionHandler",
                            "rationale": "The throwNumberFormatException method is a utility function for handling exceptions related to number formatting, which would be better suited in a dedicated exception handling class."
                        },
                        {
                            "method_name": "byteToString",
                            "method_signature": "private static final String byteToString(int byteVal)",
                            "target_class": "ByteUtils",
                            "rationale": "The byteToString method is a utility function for converting byte values to strings, which is a general-purpose operation that would be more appropriately placed in a utility class."
                        }
                    ],
                    "llm_response_time": 6265
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "addToHashtable",
                            "method_signature": "public addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "addToHashtable",
                            "method_signature": "public addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)": {
                        "first": {
                            "method_name": "addToHashtable",
                            "method_signature": "public addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2621179463165029
                    }
                },
                "voyage": {
                    "public addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)": {
                        "first": {
                            "method_name": "addToHashtable",
                            "method_signature": "public addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.1415473883577922
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)"
                    ],
                    "llm_response_time": 4294
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)"
                    ],
                    "llm_response_time": 0
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)"
                    ],
                    "llm_response_time": 1
                },
                "voyage": {
                    "priority_method_names": [
                        "public addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)"
                    ],
                    "llm_response_time": 0
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)"
                    ],
                    "llm_response_time": 1
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)"
                    ],
                    "llm_response_time": 0
                }
            },
            "targetClassMap": {
                "addToHashtable": {
                    "target_classes": [
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.459345106713597
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.6011347215769316
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PcmlDocument",
                        "PcmlDocNode"
                    ],
                    "llm_response_time": 4905,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                }
            }
        }
    }
]