[
    {
        "oracle": "method com.ibm.as400.access.FTPThread::readObject(java.io.ObjectInputStream):void need move com.ibm.as400.access.FTP",
        "class_name": "com.ibm.as400.access.FTPThread",
        "telemetry": {
            "id": "40b39bbd-5f3f-4e0d-be9b-20d4044673b8",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 214,
                "lineStart": 20,
                "lineEnd": 233,
                "bodyLineStart": 20,
                "language": "java",
                "sourceCode": "class FTPThread implements Runnable\n{\n  private FTP ftp_;\n  \n  private int port_;\n  private Socket socket_;\n  private boolean running_ = false;\n  private final Object runLock_ = new Object();\n\n  private InetAddress localAddress_;\n\n  FTPThread(FTP ftp)\n  {\n    ftp_ = ftp;\n  }\n\n  // This must be called before the thread is started.\n  public void setLocalAddress(InetAddress localAddress)\n  {\n    localAddress_ = localAddress;\n    if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"FTP thread's local address set to: \"+localAddress_.toString());\n  }\n\n  public void waitUntilStarted()\n  {\n    try\n    {\n      while (!running_)\n      {\n        synchronized (runLock_)\n        {\n          if (!running_) runLock_.wait();\n        }\n      }\n    }\n    catch (Exception e)\n    {\n      Trace.log(Trace.ERROR, \"Error while waiting for FTP thread to start.\", e);\n    }\n  }\n\n  public int getLocalPort()\n  {\n    return port_;\n  }\n\n  public Socket getSocket()\n  {\n    if (socket_ == null)\n    {\n      try\n      {\n        synchronized(this)\n        {\n          if (socket_ == null) wait(60000); // Wait 60 seconds to prevent hanging.\n        }\n      }\n      catch (Exception e)\n      {\n        Trace.log(Trace.ERROR, \"Error while getting socket from FTP thread.\", e);\n        return null;\n      }\n    }\n    Socket s = socket_;\n    socket_ = null;\n    if (Trace.traceOn_)\n    {\n      Trace.log(Trace.DIAGNOSTIC, \"FTP thread returned previously accepted socket.\");\n      if (s == null) Trace.log(Trace.DIAGNOSTIC, \"FTPThread.getSocket() is returning null.\");\n    }\n    return s;\n  }\n\n  public void issuePortCommand() throws IOException\n  {\n      String addr = localAddress_.getHostAddress();\n      // Try the extended port command.\n      String response = ftp_.issueCommand(\"EPRT |\" + (addr.indexOf(':') == -1 ? \"1\" : \"2\") + \"|\" + addr + \"|\" + port_ + \"|\");\n      if (response.startsWith(\"200\")) return;\n\n      // System may not support EPRT, fallback to the port command.\n    StringTokenizer st = new StringTokenizer(addr, \".\");\n    StringBuffer cmd = new StringBuffer(\"PORT \");\n    while (st.hasMoreTokens())\n    {\n      cmd.append(st.nextToken());\n      cmd.append(\",\");\n    }\n    cmd.append(port_/256);\n    cmd.append(\",\");\n    cmd.append(port_ % 256);\n    response = ftp_.issueCommand(cmd.toString());\n    // A \"successful\" response will begin with 200.\n    if (!response.startsWith(\"200\"))\n    {\n      Trace.log(Trace.ERROR, \"Unexpected response to \" + cmd + \": \" + response);\n    }\n  }\n\n  public void run()\n  {\n    ServerSocket ss = null;\n    try\n    {\n      if (ftp_.isReuseSocket())\n      {\n        if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"FTP thread will reuse socket if multiple transfers.\");\n        ss = new ServerSocket(0, 50, localAddress_);\n        port_ = ss.getLocalPort();\n        while (true)\n        {\n          if (Trace.traceOn_)\n          {\n            Trace.log(Trace.DIAGNOSTIC, \"FTP thread waiting for new active mode socket.\");\n          }\n          if (!running_)\n          {\n            running_ = true;\n            synchronized (runLock_)\n            {\n              runLock_.notifyAll();\n            }\n          }\n          socket_ = ss.accept();\n          if (Trace.traceOn_)\n          {\n            Trace.log(Trace.DIAGNOSTIC, \"FTP thread accepted active mode socket: \"+socket_);\n          }\n          synchronized (this)\n          {\n            notifyAll();\n          }\n        }\n      }\n      else  // don't reuse socket\n      {\n        if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"FTP thread create new socket if multiple transfers.\");\n        while (true)\n        {\n          if (ss == null)\n          {\n            ss = new ServerSocket(0, 1, localAddress_);\n            port_ = ss.getLocalPort();\n          }\n          if (!running_)\n          {\n            running_ = true;\n            synchronized (runLock_)\n            {\n              runLock_.notifyAll();\n            }\n          }\n          if (Trace.traceOn_)\n          {\n            Trace.log(Trace.DIAGNOSTIC, \"FTP thread waiting for new active mode socket.\");\n          }\n          socket_ = ss.accept();\n          if (Trace.traceOn_)\n          {\n            Trace.log(Trace.DIAGNOSTIC, \"FTP thread accepted active mode socket: \"+socket_);\n          }\n          synchronized (this)\n          {\n            notifyAll();\n          }\n          // Get a new server socket each time to avoid bug on AIX.\n          // We create the server socket with only 1 connection in the backlog\n          // so any other incoming requests will have to wait until we can get them\n          // a new server socket.  This bottlenecks a multi-threaded client that is\n          // sharing an FTP object across threads, but they shouldn't be doing that anyway.\n          ss.close();\n          ss = null;\n        }\n      }\n    }\n    catch (Throwable e)\n    {\n      Trace.log(Trace.ERROR, \"Exception in FTP thread.\", e);\n    }\n    finally\n    {\n      if (socket_ != null) {\n        try { socket_.close(); }\n        catch (Throwable e) { Trace.log(Trace.ERROR, e); }\n      }\n      if (ss != null) {\n        try { ss.close(); }\n        catch (Throwable e) { Trace.log(Trace.ERROR, e); }\n      }\n    }\n  }\n\n/**\n    * During object deserialization, this method is called.  When it is called\n    * we need to initialize transient data.\n * @param ftp TODO\n * @param in TODO\n   **/\n\n    void readObject2(FTP ftp, ObjectInputStream in)\n        throws IOException, ClassNotFoundException\n    {\n        in.defaultReadObject();\n\n        ftp.connectionState_     = FTP.PARKED;\n        ftp.inConnect_           = false;\n        ftp.lastMessage_         = \"\";\n        ftp.changes_             = null;\n        ftp.vetos_               = null;\n        ftp.listeners_           = null;\n        ftp.listenerLock_        = new Object();\n        ftp.externallyConnected_ = false;                              // @D2a\n    }\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 211,
                        "lineEnd": 231,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to com.ibm.as400.access.FTP\nRationale: The method readObject2 directly manipulates the internal state of the FTP class, initializing its transient fields during deserialization, making it logical for this method to reside within the FTP class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 9073
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "issuePortCommand",
                            "method_signature": "public void issuePortCommand() throws IOException",
                            "target_class": "FTP",
                            "rationale": "The issuePortCommand() method directly interacts with the FTP class to issue commands and handle responses. It would be more appropriate for this method to reside within the FTP class, where it can manage its own command issuing logic."
                        },
                        {
                            "method_name": "getSocket",
                            "method_signature": "public Socket getSocket()",
                            "target_class": "SocketManager",
                            "rationale": "The getSocket() method is responsible for managing socket connections and should be moved to a dedicated SocketManager class that handles socket lifecycle and management, separating concerns from the FTPThread class."
                        },
                        {
                            "method_name": "waitUntilStarted",
                            "method_signature": "public void waitUntilStarted()",
                            "target_class": "ThreadManager",
                            "rationale": "The waitUntilStarted() method is related to thread management and synchronization. It would be better suited in a ThreadManager class that handles thread states and synchronization logic."
                        }
                    ],
                    "llm_response_time": 2539
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "issuePortCommand",
                            "method_signature": "public void issuePortCommand() throws IOException",
                            "target_class": "FTP",
                            "rationale": "The issuePortCommand method is primarily concerned with issuing commands to the FTP server and manipulating FTP-specific data. It should be moved to the FTP class to encapsulate FTP command logic within the FTP class."
                        },
                        {
                            "method_name": "getSocket",
                            "method_signature": "public Socket getSocket()",
                            "target_class": "SocketManager",
                            "rationale": "The getSocket method is responsible for managing socket connections and should be moved to a dedicated SocketManager class to separate socket management logic from the FTPThread class."
                        },
                        {
                            "method_name": "waitUntilStarted",
                            "method_signature": "public void waitUntilStarted()",
                            "target_class": "ThreadManager",
                            "rationale": "The waitUntilStarted method is related to thread management and synchronization. It should be moved to a ThreadManager class to better encapsulate thread-related functionality."
                        },
                        {
                            "method_name": "setLocalAddress",
                            "method_signature": "public void setLocalAddress(InetAddress localAddress)",
                            "target_class": "NetworkConfiguration",
                            "rationale": "The setLocalAddress method is responsible for configuring network settings. It should be moved to a NetworkConfiguration class to separate network configuration logic from the FTPThread class."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(FTP ftp, ObjectInputStream in) throws IOException, ClassNotFoundException",
                            "target_class": "FTP",
                            "rationale": "The readObject2 method is related to the deserialization of FTP objects and should be moved to the FTP class to keep serialization logic within the FTP context."
                        }
                    ],
                    "llm_response_time": 3384
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "issuePortCommand",
                            "method_signature": "public void issuePortCommand() throws IOException",
                            "target_class": "FTP",
                            "rationale": "The issuePortCommand() method directly interacts with the FTP instance to issue commands and handle responses. It should be moved to the FTP class to encapsulate FTP command handling logic."
                        },
                        {
                            "method_name": "getSocket",
                            "method_signature": "public Socket getSocket()",
                            "target_class": "SocketManager",
                            "rationale": "The getSocket() method is responsible for managing socket connections and should be moved to a dedicated SocketManager class to separate concerns related to socket handling from the FTPThread class."
                        },
                        {
                            "method_name": "waitUntilStarted",
                            "method_signature": "public void waitUntilStarted()",
                            "target_class": "ThreadManager",
                            "rationale": "The waitUntilStarted() method is related to thread management and synchronization. It should be moved to a ThreadManager class to better organize thread-related functionality."
                        }
                    ],
                    "llm_response_time": 2450
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "issuePortCommand",
                            "method_signature": "public void issuePortCommand() throws IOException",
                            "target_class": "FTP",
                            "rationale": "The issuePortCommand() method directly interacts with the FTP class to issue commands and handle responses. It would be more appropriate for this method to reside within the FTP class, where it can manage its own command issuing logic."
                        },
                        {
                            "method_name": "getSocket",
                            "method_signature": "public Socket getSocket()",
                            "target_class": "SocketManager",
                            "rationale": "The getSocket() method is responsible for managing socket connections and should be moved to a dedicated SocketManager class that handles socket lifecycle and management, separating concerns from the FTPThread class."
                        },
                        {
                            "method_name": "waitUntilStarted",
                            "method_signature": "public void waitUntilStarted()",
                            "target_class": "ThreadManager",
                            "rationale": "The waitUntilStarted() method is related to thread management and synchronization. It would be better suited in a ThreadManager class that handles thread states and synchronization logic."
                        },
                        {
                            "method_name": "setLocalAddress",
                            "method_signature": "public void setLocalAddress(InetAddress localAddress)",
                            "target_class": "NetworkConfiguration",
                            "rationale": "The setLocalAddress method is responsible for configuring network settings. It should be moved to a NetworkConfiguration class to separate network configuration logic from the FTPThread class."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(FTP ftp, ObjectInputStream in) throws IOException, ClassNotFoundException",
                            "target_class": "FTP",
                            "rationale": "The readObject2 method is related to the deserialization of FTP objects and should be moved to the FTP class to keep serialization logic within the FTP context."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "issuePortCommand",
                    "setLocalAddress",
                    "waitUntilStarted",
                    "getSocket",
                    "readObject2"
                ],
                "llm_response_time": 619
            },
            "targetClassMap": {
                "issuePortCommand": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1283,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "setLocalAddress": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1145,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "waitUntilStarted": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1185,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "getSocket": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1450,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "readObject2": {
                    "target_classes": [
                        {
                            "class_name": "FTP",
                            "similarity_score": 0.44652579790737035
                        },
                        {
                            "class_name": "FTP",
                            "similarity_score": 0.44652579790737035
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "FTP",
                        "FTP"
                    ],
                    "llm_response_time": 804,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.vaccess.SQLMetaDataTableModel::readObject(java.io.ObjectInputStream):void need move com.ibm.as400.vaccess.SQLMetaDataTablePane",
        "class_name": "com.ibm.as400.vaccess.SQLMetaDataTableModel",
        "telemetry": {
            "id": "4039dbcb-f6a7-4615-834c-a27ece279e01",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 545,
                "lineStart": 34,
                "lineEnd": 578,
                "bodyLineStart": 34,
                "language": "java",
                "sourceCode": "/**\nThe SQLMetaDataTableModel class represents the meta data\nabout the columns of a set of database files.  This model\nis used to create a SQLMetaDataTablePane.\nThe rows of this table are the fields of the database files,\nand the columns are the field attributes (field name, length, etc).\nRows can be removed from the table so the table only shows a subset\nof the available database fields.\nThis class is used by SQLQueryBuilderPane and its coworkers.\n\n<p>The data in the model is retrieved from the system only\nwhen <i>load()</i> is called.\n\n<p>SQLMetaDataTableModel objects generate the following events:\n<ul>\n  <li>ErrorEvent\n  <li>TableModelEvent\n  <li>WorkingEvent\n</ul>\n**/\nclass SQLMetaDataTableModel\nextends AbstractTableModel\nimplements Cloneable\n{\n  private static final String copyright = \"Copyright (C) 1997-2000 International Business Machines Corporation and others.\";\n\n\n// Note that none of the JDBC resources are ever explicitly closed,\n// but rather garbage collection is relied upon to close them.\n\n// This class is not meant to be serialized, it should be transient.\n// This class has items marked transient even though it is not\n// serializable because otherwise errors were received when\n// serializing objects that contained this class (even though they\n// were transient instances.  readObject() was added to be safe.\n\n// Number of columns in model.\nstatic private int NUM_COLUMNS_ = 6;\n\n// The columns of the table contains these meta data.\npublic static int FIELD_NAME_ = 0;\npublic static int FIELD_TYPE_ = 1;\npublic static int FIELD_LENGTH_ = 2;\npublic static int FIELD_DECIMALS_ = 3;\npublic static int FIELD_NULLS_ = 4;\npublic static int FIELD_DESC_ = 5;\n\n// What this table represents\ntransient private Connection connection_ = null;\nprivate String[] tables_ = null;  // The DB tables for which this model contains data.\n\n// The table data\ntransient private String[][] data_ = new String[0][NUM_COLUMNS_]; // table data\ntransient private int[] types_ = new int[0];            // sql types\n// Row information\ntransient private int numRows_ = 0;          // Number of rows in the table.\n\n// Flag for if an error event was sent.\ntransient private boolean error_;\n\n// Event support.\ntransient private ErrorEventSupport errorListeners_\n    = new ErrorEventSupport (this);\ntransient private WorkingEventSupport workingListeners_\n    = new WorkingEventSupport (this);\n\n\n\n/**\nConstructs a SQLMetaDataTableModel object.  The query is not done\nuntil <i>load</i> is done.\n\n@param       connection  The SQL connection.\n@param       tables      The database files to retrieve info about.\n                        Tables should be in the form of <library>.<file>.\n**/\npublic SQLMetaDataTableModel (Connection connection,\n                         String[] tables)\n{\n    super();\n    connection_ = connection;\n    tables_ = tables;\n}\n\n\n/**\nAdds a listener to be notified when an error occurs.\nThe listener's errorOccurred method will be called.\n\n@param  listener  The listener.\n**/\npublic void addErrorListener (ErrorListener listener)\n{\n    errorListeners_.addErrorListener (listener);\n}\n\n\n\n/**\nAdds a listener to be notified when work starts and stops\non potentially long-running operations.\n\n@param  listener  The listener.\n**/\npublic void addWorkingListener (WorkingListener listener)\n{\n    workingListeners_.addWorkingListener (listener);\n}\n\n\n\n/**\nMakes a clone (copy) of this table.  No data (references) is shared\nbetween this original and the new object.  Listeners are not copied\nto the new object.\n**/\nsynchronized public Object clone ()\n{\n    // create new object\n    SQLMetaDataTableModel clone =\n        new SQLMetaDataTableModel(connection_, tables_);\n    // copy table data\n    clone.data_ = new String[data_.length][NUM_COLUMNS_];\n    System.arraycopy(data_, 0, clone.data_, 0 , data_.length);\n    clone.numRows_ = numRows_;\n    clone.types_ = new int[types_.length];\n    System.arraycopy(types_, 0, clone.types_, 0 , types_.length);\n\n    return clone;\n}\n\n\n/**\nReturns the number of columns in the table.\n\n@return The number of columns in the table.\n**/\npublic int getColumnCount()\n{\n    return NUM_COLUMNS_;\n}\n\n\n/**\nReturns the number of rows in the table.\n\n@return The number of rows in the result set.\n**/\nsynchronized public int getRowCount()\n{\n    return numRows_;\n}\n\n\n/**\nReturn the SQL type of the field.  Note this is not the same as\nthe data in FIELD_TYPE_, which is the database-dependent type name.\n@see java.sql.Types\n\n@param index The row for which to get the type.\n@return The SQL type of the field.\n**/\nsynchronized int getSQLType(int index)\n{\n    return types_[index];\n}\n\n\n/**\nReturns the database file names this table contains data for.\n\n@return The database file names this table contains data for.\n**/\npublic String[] getTables ()\n{\n    return tables_;\n}\n\n\n/**\nReturns the value at the specifed column and row.\n\n@param  rowIndex            The row index.  Indices start at 0.\n@param  columnIndex    The column index.  Indices start at 0.\n\n@return The value at the specified column and row.\n**/\nsynchronized public Object getValueAt (int rowIndex,\n                          int columnIndex)\n{\n    error_ = false;\n\n    // return the value\n    return data_[rowIndex][columnIndex];\n}\n\n\n\n\n/**\nLoads the table based on the state of the system.\n**/\npublic void load ()\n{\n    synchronized (this)\n    {\n        // Set back fields in case there is an error.\n        data_ = new String[0][0];\n        types_ = new int[0];\n        numRows_ = 0;\n    }\n    // notify listeners that we've changed number of rows.\n    TableModelEvent event = new TableModelEvent(this, -1);\n    fireTableChanged(event);\n    Trace.log(Trace.DIAGNOSTIC, \"Starting load, changed number of rows to:\", numRows_);\n\n    if (tables_ == null || tables_.length == 0 ||\n        connection_ == null)\n    {\n        //If no tables, the panel will be disabled, don't throw\n        //error, just leave table empty.\n        return;\n    }\n\n    synchronized (this)\n    {\n        workingListeners_.fireStartWorking ();\n\n        // Number of rows we create our table with and number of\n        // rows we bump our capacity by each time we run out of room.\n        int ROW_INCREMENT = 50;\n\n        ResultSet resultSet = null;\n        try\n        {\n            // Get database meta data\n            DatabaseMetaData metaData = connection_.getMetaData();\n\n            // Create new array to hold table values.\n            data_ = new String[ROW_INCREMENT][NUM_COLUMNS_];\n            types_ = new int[ROW_INCREMENT];\n\n            // Loop through each database file.\n            String library, table, tprefix;\n            int sepIndex;\n            int curRow;\n            for (int i=0; i<tables_.length; ++i)\n            {\n                // Get meta data.\n                sepIndex = tables_[i].indexOf(\".\");\n                if (sepIndex == -1)\n                {\n                    // Incorrect table specification, send error\n                    // and continue to next table.\n                    // Create generic exception to hold error message\n                    Exception e = new Exception(ResourceLoader.getText(\"EXC_TABLE_SPEC_NOT_VALID\"));\n                    errorListeners_.fireError(e);\n                }\n                else\n                {\n                    library = tables_[i].substring(0, sepIndex);\n                    table = tables_[i].substring(sepIndex+1);\n                    if (tables_.length > 1)\n                        tprefix = table + \".\"; // need to qualify field names\n                    else\n                        tprefix = \"\";  // only 1 table, can just use field names\n                    resultSet = metaData.getColumns(null, library, table, null);\n\n                    // Loop through fields for this database file.\n                    while (resultSet.next())\n                    {\n                        curRow = numRows_; // current row in table\n\n                        // make sure we have room in table for this row.\n                        if (curRow >= data_.length)                         // @D1C\n                        {\n                            String[][] newData =\n                                new String[data_.length + ROW_INCREMENT][NUM_COLUMNS_];\n                            System.arraycopy(data_, 0, newData, 0, data_.length);\n                            data_ = newData;\n                            int[] newTypes =\n                                new int[types_.length + ROW_INCREMENT];\n                            System.arraycopy(types_, 0, newTypes, 0, types_.length);\n                            types_ = newTypes;\n                        }\n\n                        // Store SQL type for use by getSQLType,\n                        // although this is not externalized in the table.\n                        types_[curRow] = resultSet.getInt(5);\n\n                        // Add field info to table\n                        data_[curRow][FIELD_NAME_] = tprefix + resultSet.getString(4).trim();\n                        data_[curRow][FIELD_TYPE_] = resultSet.getString(6);\n                        // The following code should not be necessary when using\n                        // most drivers, but makes the length values correct\n                        // when using the i5/OS JDBC driver.\n                        // These values came from the ODBC description of precision\n                        // (in 2.0 ref, Appendix D page 624).\n                        switch (types_[curRow])\n                        {\n                            case Types.SMALLINT:\n                                data_[curRow][FIELD_LENGTH_] = \"5\";\n                                break;\n                            case Types.INTEGER:\n                                data_[curRow][FIELD_LENGTH_] = \"10\";\n                                break;\n                            case Types.TIME:\n                                data_[curRow][FIELD_LENGTH_] = \"8\";\n                                break;\n                            case Types.TIMESTAMP:\n                                // We always give length = 23, even though\n                                // we should give 19 if there is no decimals.\n                                // In order to not mess up 'correct' values,\n                                // only change it if we know the value is bad.\n                                if (resultSet.getInt(7) == 10)\n                                    data_[curRow][FIELD_LENGTH_] = \"23\";\n                                break;\n                            case Types.DATE:\n                                data_[curRow][FIELD_LENGTH_] = \"10\";\n                                break;\n                            case Types.DOUBLE:\n                                if (resultSet.getInt(7) == 4)\n                                    // single precision (type REAL)\n                                    data_[curRow][FIELD_LENGTH_] = \"7\";\n                                else\n                                    // double precison (type FLOAT)\n                                    data_[curRow][FIELD_LENGTH_] = \"15\";\n                                break;\n                            default:\n                                // Other types are correct.\n                                data_[curRow][FIELD_LENGTH_] = resultSet.getString(7);\n                        }\n                        data_[curRow][FIELD_DECIMALS_] = resultSet.getString(9);\n                        data_[curRow][FIELD_NULLS_] = resultSet.getString(18);\n                        data_[curRow][FIELD_DESC_] = resultSet.getString(12);\n\n                        numRows_++;\n                    }\n                }\n            }\n        }\n        catch (SQLException e)\n        {\n            // In case of error, set fields to init state\n            data_ = new String[0][0];\n            types_ = new int[0];\n            numRows_ = 0;\n            errorListeners_.fireError(e);\n            error_ = true;\n        }\n        finally\n        {\n            if (resultSet != null)\n            {\n                try\n                {\n                    resultSet.close();\n                }\n                catch(SQLException e)\n                {\n                    errorListeners_.fireError(e);\n                }\n            }\n        }\n    }  // end of synchronized block\n\n    // notify listeners that we've changed\n    event = new TableModelEvent(this, -1);\n    fireTableChanged(event);\n    Trace.log(Trace.DIAGNOSTIC, \"Did load, changed number of rows to:\", numRows_);\n\n    workingListeners_.fireStopWorking ();\n}\n\n\n/**\nRestores the state of this object from an object input stream.\nIt is used when deserializing an object.\n@param in The input stream of the object being deserialized.\n@exception IOException\n@exception ClassNotFoundException\n**/\nprivate void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException\n{\n    // Restore the non-static and non-transient fields.\n    in.defaultReadObject();\n    // Initialize the transient fields.\n    connection_ = null;\n    data_ = new String[0][NUM_COLUMNS_];\n    types_ = new int[0];\n    numRows_ = 0;\n    errorListeners_ = new ErrorEventSupport (this);\n    workingListeners_ = new WorkingEventSupport (this);\n}\n\n\n/**\nRemoves a row from the table.\n\n@param  rowIndex  The row index.  Indices start at 0.\n**/\npublic void removeRow (int rowIndex)\n{\n    synchronized (this)\n    {\n        Trace.log(Trace.DIAGNOSTIC, \"Removing row \", rowIndex);\n\n        // array to hold new data\n        String[][] newData = new String[data_.length -1][NUM_COLUMNS_];\n        int[] newTypes = new int[types_.length -1];\n\n        // copy table data to new table less row being removed\n        if (rowIndex == 0)\n        {\n            // remove first row\n            System.arraycopy(data_, 1, newData, 0, newData.length);\n            System.arraycopy(types_, 1, newTypes, 0, newTypes.length);\n        }\n        else if (rowIndex == data_.length - 1)\n        {\n            // remove last row\n            System.arraycopy(data_, 0, newData, 0, newData.length);\n            System.arraycopy(types_, 0, newTypes, 0, newTypes.length);\n        }\n        else\n        {\n            // remove row in middle\n            System.arraycopy(data_, 0, newData, 0, rowIndex);\n            System.arraycopy(data_, rowIndex+1, newData, rowIndex,\n                                newData.length-rowIndex);\n            System.arraycopy(types_, 0, newTypes, 0, rowIndex);\n            System.arraycopy(types_, rowIndex+1, newTypes, rowIndex,\n                                newTypes.length-rowIndex);\n        }\n\n        data_ = newData;\n        numRows_--;\n    }\n\n    // notify listeners that we've changed\n    fireTableRowsDeleted(rowIndex, rowIndex);\n}\n\n\n/**\nRemoves a listener from being notified when an error occurs.\n\n@param  listener  The listener.\n**/\npublic void removeErrorListener (ErrorListener listener)\n{\n    errorListeners_.removeErrorListener (listener);\n}\n\n\n/**\nRemoves a listener from being notified when work starts and stops.\n\n@param  listener  The listener.\n**/\npublic void removeWorkingListener (WorkingListener listener)\n{\n    workingListeners_.removeWorkingListener (listener);\n}\n\n\n/**\nSets the database files this table contains data for.\nThe new value will not be in effect until a <i>load()</i> is done.\n\n@param tables The database files this table will contain data for.\n                        Tables should be in the form of <library>.<file>.\n**/\npublic void setTables (String[] tables)\n{\n    tables_ = tables;\n}\n\n\n/**\nSets the SQL connection this table contains data for.\nThe new value will not be in effect until a <i>load()</i> is done.\n\n@param       connection  The SQL connection.\n**/\npublic void setConnection (Connection connection)\n{\n    connection_ = connection;\n}\n\n\n/**\nRestores the state of this object from an object input stream.\nIt is used when deserializing an object.\n@param sqlMetaDataTablePane TODO\n * @param in The input stream of the object being deserialized.\n * @exception IOException\n@exception ClassNotFoundException\n**/\nvoid readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)\n     throws java.io.IOException, ClassNotFoundException\n{\n    in.defaultReadObject();\n    sqlMetaDataTablePane.addFocusListener(new SerializationListener(sqlMetaDataTablePane)); //@B0A - for safe serialization next time\n\n    //@B0A: The following code is copied from the constructor since\n    // table_ is now transient.\n    sqlMetaDataTablePane.table_ = new JTable();\n    sqlMetaDataTablePane.table_.setAutoCreateColumnsFromModel(false);\n    sqlMetaDataTablePane.table_.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN); //@B0C\n    sqlMetaDataTablePane.table_.setModel(this);\n    sqlMetaDataTablePane.table_.setShowGrid(false);\n    // set up table columns\n    TableColumn column = new TableColumn(SQLMetaDataTableModel.FIELD_NAME_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_NAME\"));\n    column.setPreferredWidth(150); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_TYPE_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_TYPE\"));\n    column.setPreferredWidth(70); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_LENGTH_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_LENGTH\"));\n    column.setPreferredWidth(60); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_DECIMALS_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_DECIMALS\"));\n    column.setPreferredWidth(65); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_NULLS_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_NULL\"));\n    column.setPreferredWidth(80); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_DESC_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_DESCRIPTION\"));\n    column.setPreferredWidth(180); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    // build panel with table and headings\n    sqlMetaDataTablePane.setupPane();\n}\n\n\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 525,
                        "lineEnd": 573,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to com.ibm.as400.vaccess.SQLMetaDataTablePane\nRationale: The method readObject2 directly manipulates the SQLMetaDataTablePane instance, setting up its JTable and adding columns, which indicates that it is closely related to the functionality of SQLMetaDataTablePane.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 6064
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)",
                            "target_class": "SQLMetaDataTablePane",
                            "rationale": "The readObject2 method is responsible for setting up the SQLMetaDataTablePane with the table model and its columns, which is directly related to the UI representation of the data. It should be moved to the SQLMetaDataTablePane class to maintain separation of concerns."
                        }
                    ],
                    "llm_response_time": 1965
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)",
                            "target_class": "SQLMetaDataTablePane",
                            "rationale": "The readObject2 method is responsible for setting up the SQLMetaDataTablePane with the table model and its columns, which is directly related to the UI representation of the data. It should be moved to the SQLMetaDataTablePane class to maintain separation of concerns."
                        }
                    ],
                    "llm_response_time": 1886
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)",
                            "target_class": "SQLMetaDataTablePane",
                            "rationale": "The readObject2 method is responsible for setting up the SQLMetaDataTablePane with the SQLMetaDataTableModel, which indicates that it is closely related to the UI component. Moving it to SQLMetaDataTablePane would improve cohesion and maintainability."
                        }
                    ],
                    "llm_response_time": 1535
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)",
                            "target_class": "SQLMetaDataTablePane",
                            "rationale": "The readObject2 method is responsible for setting up the SQLMetaDataTablePane with the table model and its columns, which is directly related to the UI representation of the data. It should be moved to the SQLMetaDataTablePane class to maintain separation of concerns."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "readObject2"
                ],
                "llm_response_time": 612
            },
            "targetClassMap": {
                "readObject2": {
                    "target_classes": [
                        {
                            "class_name": "SQLMetaDataTablePane",
                            "similarity_score": 0.6896865432884054
                        },
                        {
                            "class_name": "ErrorEventSupport",
                            "similarity_score": 0.3310278493971974
                        },
                        {
                            "class_name": "WorkingEventSupport",
                            "similarity_score": 0.3088104758037342
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SQLMetaDataTablePane",
                        "ErrorEventSupport",
                        "WorkingEventSupport"
                    ],
                    "llm_response_time": 2290,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.data.ProgramCallDocument::endInternal(int):void need move com.ibm.as400.resource.RJob",
        "class_name": "com.ibm.as400.data.ProgramCallDocument",
        "telemetry": {
            "id": "fae3827f-f0d1-45f7-a379-b281649fcbf3",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1977,
                "lineStart": 56,
                "lineEnd": 2032,
                "bodyLineStart": 56,
                "language": "java",
                "sourceCode": "/**\n * XML Document based program call.\n *\n * The ProgramCallDocument class uses a Program Call Markup Language (PCML) document to\n * call IBM i system programs.\n * PCML is an XML language for describing the input and output parameters\n * to the IBM i system program.\n *\n * This class parses a PCML document and allows the application to call\n * IBM i system programs described in the PCML document.\n *\n * <h3>Command Line Interface</h3>\n * The command line interface may be used to serialize\n * PCML document definitions. Note that XPCML documents cannot\n * be serialized.\n * <pre>\n * <kbd>java com.ibm.as400.data.ProgramCallDocument\n *     -serialize\n *     <i>PCML document name</i></kbd>\n * </pre>\n * Options:\n * <dl>\n * <dt><kbd>-serialize</kbd>\n * <dd>Parses the PCML document and creates a serialized version of the document.\n * The name of the serialized file will match the document name, and the file extension will be\n * <code><strong>.pcml.ser</code></strong> (lowercase).\n * <p><dt><kbd><i>PCML document name</i></kbd>\n * <dd>The fully-qualified resource name of the PCML document\n * which defines the program interface.\n * </dl>\n */\npublic class ProgramCallDocument implements Serializable, Cloneable\n{                                                                   // @C1C @C3C\n    static final long serialVersionUID = -1836686444079106483L;\t    // @C1A\n\n    /**\n     * Constant indicating a serialized PCML or XPCML document is being streamed.\n     * @see #ProgramCallDocument(AS400,String,InputStream,ClassLoader,InputStream,int)\n    **/\n    public static final int SERIALIZED = 0;\n\n    /**\n     * Constant indicating a source PCML document is being streamed.\n    * @see #ProgramCallDocument(AS400,String,InputStream,ClassLoader,InputStream,int)\n    **/\n    public static final int SOURCE_PCML = 1;\n\n    /**\n     * Constant indicating a source XPCML document is being streamed.\n    * @see #ProgramCallDocument(AS400,String,InputStream,ClassLoader,InputStream,int)\n    **/\n    public static final int SOURCE_XPCML = 2;\n\n    private AS400 m_as400;\n    private PcmlDocument m_pcmlDoc;\n    static boolean exceptionIfParseError_;\n    static\n    {\n      String property = null;\n      try {\n        property = SystemProperties.getProperty(SystemProperties.THROW_SAX_EXCEPTION_IF_PARSE_ERROR);\n      }\n      catch (Throwable t) {}\n      if (property == null) { // Property not set.\n        exceptionIfParseError_ = false;\n      }\n      else if (property.trim().equalsIgnoreCase(\"true\")) {\n        exceptionIfParseError_ = true;\n      }\n      else {\n        exceptionIfParseError_ = false;\n      }\n    }\n\n    /**\n     Constructs a ProgramCallDocument object.\n    The PCML or XPCML document resource will be loaded from the classpath.\n    If the document is a PCML document, the classpath will first be searched for a serialized resource.\n    XPCML documents cannot be serialized.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML or XPCML source file.\n\n    @param sys The system on which to run the program.\n    @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public ProgramCallDocument(AS400 sys, String docName)\n    \tthrows PcmlException\n   \t{\n        if (sys == null)     warnNull(\"sys\");\n        if (docName == null) warnNull(\"docName\");\n\n        m_as400 = sys;\n\n        m_pcmlDoc = loadPcmlDocument(docName, null,null);        // @C8C @E1C\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);\n    }\n\n  /**\n    Constructs a ProgramCallDocument object.\n    The XPCML document resource will be loaded from the classpath and parsed using\n    the XML schema definitions provided in the input XSD stream.\n\n    @param sys The system on which to run the program.\n    @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n\n    public ProgramCallDocument(AS400 sys, String docName, InputStream xsdStream)\n    \tthrows PcmlException\n   \t{\n        if (sys == null)     warnNull(\"sys\");\n        if (docName == null) warnNull(\"docName\");\n\n        m_as400 = sys;\n\n        m_pcmlDoc = loadPcmlDocument(docName, null,xsdStream);        // @C8C\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);\n\n    }\n\n    /**\n     Constructs a ProgramCallDocument object.\n    The PCML or XPCML document resource will be loaded from the classpath.\n    If the document is a PCML document, the classpath will first be searched for a serialized resource.\n    XPCML documents cannot be serialized.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML or XPCML source file.\n\n     @param sys The system on which to run the program.\n    @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public ProgramCallDocument(AS400 sys, String docName, ClassLoader loader)       // @C8A\n    \tthrows PcmlException\n   \t{\n        if (sys == null)     warnNull(\"sys\");\n        if (docName == null) warnNull(\"docName\");\n\n        m_as400 = sys;                                      // @C8A\n\n        m_pcmlDoc = loadPcmlDocument(docName, loader,null);      // @C8A\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);                        // @C8A\n    }\n\n\n  /**\n    Constructs a ProgramCallDocument object.\n    The PCML or XPCML document resource will be loaded from the classpath and parsed using\n    the XML schema definitions provided in the input XSD stream.\n    @param sys The system on which to run the program.\n    @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML.  This parameter can be null.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n    @exception PcmlException when the specified PCML document cannot be found\n    */\n     public ProgramCallDocument(AS400 sys, String docName, ClassLoader loader, InputStream xsdStream)       // @C8A\n    \tthrows PcmlException\n   \t{\n        if (sys == null)     warnNull(\"sys\");\n        if (docName == null) warnNull(\"docName\");\n\n        m_as400 = sys;                                      // @C8A\n\n        m_pcmlDoc = loadPcmlDocument(docName, loader,xsdStream);      // @C8A\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);                        // @C8A\n    }\n\n  /**\n    Constructs a ProgramCallDocument object.\n    The PCML or XPCML document resource will be read from the specified input stream, and parsed using\n    the XML schema definitions provided in the input XSD stream.\n    @param sys The system on which to run the program.\n    @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n    @param docStream The InputStream from which to read the contents of the document.\n    @param loader The ClassLoader that will be used when loading the DTD for PCML. This parameter can be null.\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\".  This parameter can be null.\n    @param type The type of data contained in docStream. Possible values are:\n    <UL>\n    <LI>{@link #SERIALIZED SERIALIZED} - The docStream contains a serialized PCML or XPCML document.\n    <LI>{@link #SOURCE_PCML SOURCE_PCML} - The docStream contains a PCML document.\n    <LI>{@link #SOURCE_XPCML SOURCE_XPCML} - The docStream contains an XPCML document.\n    </UL>\n    @exception PcmlException when the specified PCML document cannot be found\n    */\n     public ProgramCallDocument(AS400 sys, String docName, InputStream docStream, ClassLoader loader, InputStream xsdStream, int type)\n    \tthrows PcmlException\n   \t{\n        if (sys == null)     warnNull(\"sys\");\n        if (docName == null) warnNull(\"docName\");\n\n        if (type == ProgramCallDocument.SERIALIZED)\n        {\n          m_pcmlDoc = loadSerializedPcmlDocumentFromStream(docStream);\n        }\n        else if (type == ProgramCallDocument.SOURCE_PCML)\n        {\n          m_pcmlDoc = loadSourcePcmlDocumentFromStream(docName, docStream, loader, xsdStream, false);\n        }\n        else if (type == ProgramCallDocument.SOURCE_XPCML)\n        {\n          m_pcmlDoc = loadSourcePcmlDocumentFromStream(docName, docStream, loader, xsdStream, true);\n        }\n        else {\n          throw new ExtendedIllegalArgumentException(\"type (\" + type + \")\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        m_as400 = sys;\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);\n    }\n\n     /**\n    Constructs a ProgramCallDocument object.\n    {@link #setSystem setSystem()} and {@link #setDocument setDocument()} must be called prior to using the object.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public ProgramCallDocument()\n    \tthrows PcmlException                                        // @C1A\n   \t{                                                               // @C1A\n        m_as400 = null;                                             // @C1A\n        m_pcmlDoc = null;                                           // @C1A\n    }                                                               // @C1A\n\n    /**\n     Constructs a ProgramCallDocument object.\n     {@link #setSystem setSystem()} must be called prior to using the object.\n     The PCML or XPCML document resource will be loaded from the classpath.\n     If the document is a PCML document, the classpath will first be searched for a serialized resource.\n     XPCML documents cannot be serialized.\n     If a serialized resource is not found, the classpath will be\n     searched for a PCML or XPCML source file.\n\n     @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n     The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n     @exception PcmlException when the specified PCML document cannot be found\n     */\n    public ProgramCallDocument(String docName)\n      throws PcmlException\n    {\n      if (docName == null) {\n        throw new NullPointerException(\"docName\");\n      }\n\n      m_pcmlDoc = loadPcmlDocument(docName, null,null);\n    }\n\n    /**\n     Constructs a ProgramCallDocument object.\n     {@link #setSystem setSystem()} must be called prior to using the object.\n     The PCML or XPCML document resource will be loaded from the classpath of the specified ClassLoader.\n     If the document is a PCML document, the classpath will first be searched for a serialized resource.\n     XPCML documents cannot be serialized.\n     If a serialized resource is not found, the classpath will be\n     searched for a PCML or XPCML source file.\n\n     @param docName The document resource name of the PCML document for the programs to be called.\n     @param loader The ClassLoader that will be used when loading the specified document resource.\n\n     @exception PcmlException when the specified PCML document cannot be found\n     */\n    public ProgramCallDocument(String docName, ClassLoader loader)\n    \tthrows XmlException\n    {\n      if (docName == null) {\n        throw new NullPointerException(\"docName\");\n      }\n      if (loader == null) {\n        throw new NullPointerException(\"loader\");\n      }\n\n      m_pcmlDoc = loadPcmlDocument(docName, loader, null);\n    }\n\n    /**\n    Clones the ProgramCallDocument and the objects contained in it.\n    {@link #setSystem setSystem()} and {@link #setDocument setDocument()} must be called prior to using the object.\n    */\n    public Object clone()\n   \t{                                                               // @C3A\n   \t    ProgramCallDocument newPcml = null;                         // @C3A\n        try                                                         // @C3A\n        {                                                           // @C3A\n            newPcml = (ProgramCallDocument) super.clone();          // @C3A\n            if (m_pcmlDoc != null)                                  // @C3A\n                newPcml.m_pcmlDoc = (PcmlDocument) m_pcmlDoc.clone();   // @C3A\n        }                                                           // @C3A\n        catch (CloneNotSupportedException e)                        // @C3A\n        {}                                                          // @C3A\n\n        return newPcml;                                             // @C3A\n    }                                                               // @C3A\n\n    // Custom serialization\n    private void writeObject(ObjectOutputStream out)\n        throws IOException                                          // @C1A\n    {                                                               // @C1A\n\t\tsynchronized (this)                                         // @C1A\n\t\t{                                                           // @C1A\n            if (m_pcmlDoc != null)                                  // @C1A\n            {                                                       // @C1A\n                m_pcmlDoc.setSerializingWithData(true);             // @C1A\n            }                                                       // @C1A\n\n\t\t\t// Perform default serialization\n\t\t\tout.defaultWriteObject();                               // @C1A\n\n\t\t} // end of synchronized code                               // @C1A\n    }                                                               // @C1A\n\n    /**\n\t * Provides a command line interface to ProgramCallDocument.  See the class description.\n    * Note that XPCML documents cannot be serialized.\n\t *\n     */\n    public static void main(String[] args)\n    {\n\t\tPcmlDocument pd = null;\n\n        System.setErr(System.out);\n        final String errMsg = SystemResourceFinder.format(DAMRI.PCD_ARGUMENTS);\n\n\t\tif (args.length == 2)\n        {\n        \tif (!args[0].equalsIgnoreCase(\"-SERIALIZE\"))\n        \t{\n        \t\tSystem.out.println(errMsg);\n        \t\tSystem.exit(-1);\n        \t}\n\n            // Load the document from source (previously serialized documents are ignored)\n            try\n            {\n\t\t\t\tpd = loadSourcePcmlDocument(args[1], null,null);         // @C8C\n            }\n\t\t\tcatch (PcmlException e)\n\t\t\t{\n\t\t\t\tSystem.out.println(e.getLocalizedMessage());\n\t\t\t\tSystem.exit(-1);\n\t\t\t}\n\n            // Save the document as a serialized file\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsavePcmlDocument(pd);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tSystem.out.println(e.getLocalizedMessage());\n\t\t\t\tSystem.exit(-1);\n\t\t\t}\n\n        }\n\t\telse\n\t\t{\n    \t\tSystem.out.println(errMsg);\n    \t\tSystem.exit(-1);\n\t\t}\n\n    }\n\n\n\n    /**\n     Calls the named program.\n\n     @param name The name of the &lt;program&gt; element in the PCML document.\n     @exception PcmlException\n                If an error occurs.\n    */\n    public boolean callProgram(String name)\n        throws PcmlException\n    {\n        try\n        {\n            return m_pcmlDoc.callProgram(name);\n        }\n        catch (AS400SecurityException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            PcmlException pe = new PcmlException(e);\n            throw pe;\n        }\n        catch (ObjectDoesNotExistException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            PcmlException pe = new PcmlException(e);\n            throw pe;\n        }\n        catch (InterruptedException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            PcmlException pe = new PcmlException(e);\n            throw pe;\n        }\n        catch (ErrorCompletingRequestException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            PcmlException pe = new PcmlException(e);\n            throw pe;\n        }\n        catch (IOException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            throw new PcmlException(e);\n        }\n\n    }\n\n    /**\n    Returns an \"errno\" value for the named service program element.\n    <p>\n    The named program element must be defined as a service program <code>entrypoint</code>.\n    The value returned is the \"errno\" value resulting from the most recent\n    call to the program. If the program has not been called, zero is returned.\n\n    @return The integer \"errno\" value for the named service program element.\n\n    @param name The name of the &lt;program&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getErrno(String name)\n        throws PcmlException                                        // @B1A\n    {                                                               // @B1A\n        return m_pcmlDoc.getErrno(name);                            // @B1A\n    }                                                               // @B1A\n\n    /**\n    Returns a Descriptor for the specified PCML document.\n    The PCML document resource will be loaded from the classpath.\n    The classpath will first be searched for a serialized resource.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML source file.\n\n    @param docName The document resource name of the PCML document for which the Descriptor is returned.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n    @return The Descriptor for the &lt;pcml&gt; element of the named PCML file.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public static Descriptor getDescriptor(String docName)\n        throws PcmlException                                        // @C5A\n    {\n        PcmlDocument pd = null;\n\n        pd = loadPcmlDocument(docName, null,null);                       // @C8C\n\n        return new PcmlDescriptor(pd);\n    }                                                               // @C5A\n\n     /**\n    Returns a Descriptor for the specified XPCML document.\n    The XPCML document resource will be loaded from the classpath.\n\n    @param docName The document resource name of the XPCML document for which the Descriptor is returned.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML\n\n    @return The Descriptor for the &lt;pcml&gt; element of the named PCML file.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public static Descriptor getDescriptor(String docName, InputStream xsdStream)\n        throws PcmlException                                        // @C5A\n    {\n        PcmlDocument pd = null;\n\n        pd = loadPcmlDocument(docName, null, xsdStream);                       // @C8C\n\n        return new PcmlDescriptor(pd);\n    }                                                               // @C5A\n\n    /**\n    Returns a Descriptor for the specified PCML document.\n    The PCML document resource will be loaded from the classpath.\n    The classpath will first be searched for a serialized resource.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML source file.\n\n    @param docName The document resource name of the PCML document for which the Descriptor is returned.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n    @return The Descriptor for the &lt;pcml&gt; element of the named PCML file.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public static Descriptor getDescriptor(String docName, ClassLoader loader)\n        throws PcmlException                                        // @C8A\n    {\n        PcmlDocument pd = null;                                     // @C8A\n\n        pd = loadPcmlDocument(docName, loader,null);                             // @C8A\n\n        return new PcmlDescriptor(pd);                              // @C8A\n    }\n\n    /**\n    Returns a Descriptor for the specified XPCML document.\n    The XPCML document resource will be loaded from the classpath.\n\n    @param docName The document resource name of the PCML document for which the Descriptor is returned.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML.\n\n    @return The Descriptor for the &lt;pcml&gt; element of the named PCML file.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public static Descriptor getDescriptor(String docName, ClassLoader loader, InputStream xsdStream)\n        throws PcmlException                                        // @C8A\n    {\n        PcmlDocument pd = null;                                     // @C8A\n\n        pd = loadPcmlDocument(docName, loader,xsdStream);                             // @C8A\n\n        return new PcmlDescriptor(pd);                              // @C8A\n    }\n\n\n    /**\n    Returns a Descriptor for the current PCML document.\n\n    @return The Descriptor for the &lt;pcml&gt; element of the current PCML file or\n            null if the PCML document has not be set.\n    */\n    public Descriptor getDescriptor()                               // @C5A\n    {\n\n        if (m_pcmlDoc == null)\n            return null;\n        else\n            return new PcmlDescriptor(m_pcmlDoc);\n    }                                                               // @C5A\n\n    /**\n    Returns an int return value for the named service program element.\n    <p>\n    The named program element must be defined as a service program <code>entrypoint</code>.\n    The value returned is the integer return value from the most recent\n    call to the program. If the program has not been called, zero is returned.\n\n    @return The integer return value for the named service program element.\n\n    @param name The name of the &lt;program&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getIntReturnValue(String name) throws PcmlException  // @B1A\n    {                                                               // @B1A\n        return m_pcmlDoc.getIntReturnValue(name);                   // @B1A\n    }                                                               // @B1A\n\n    /**\n    Returns an int value for the named element.\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to an int.\n\n    @return The integer value for the named element.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getIntValue(String name)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getIntValue(name);\n    }\n\n    /**\n    Returns an int value for the named element given indices to the data element.\n    If the data element is an array or is an element in a structure array, an index\n    must be specified for each dimension of the data.\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to an int.\n\n    @return The integer value for the named element.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getIntValue(String name, int[] indices)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getIntValue(name, new PcmlDimensions(indices));\n    }\n\n\n    /**\n     Returns the ProgramCall object that was used in the most recent invocation of {@link #callProgram(String) callProgram()}.\n     @return The ProgramCall object; null if callProgram() has not been called.\n     **/\n    public ProgramCall getProgramCall()\n    {\n      return ( m_pcmlDoc == null ? null : m_pcmlDoc.getProgramCall() );\n    }\n\n\n    /**\n    Returns a String value for the named element.\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to a String.\n    The default bidi string type is assumed ({@link com.ibm.as400.access.BidiStringType#DEFAULT BidiStringType.DEFAULT}).\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @exception PcmlException If an error occurs.\n    */\n    public String getStringValue(String name)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getStringValue(name, BidiStringType.DEFAULT);\n    }\n\n    /**\n    Returns a String value for the named element.\n    <p>\n    This method is used when the string type cannot be determined until\n    run-time.  In those cases, the PCML document cannot be used to indicate\n    the string type so this method is used to get the value using the\n    string type that is specified.\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to a String.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param type The bidi string type, as defined by the CDRA (Character\n                Data Representation Architecture).\n    @exception PcmlException\n               If an error occurs.\n    @see com.ibm.as400.access.BidiStringType\n    */\n    public String getStringValue(String name, int type)\n        throws PcmlException                                            // @C9A\n    {\n        return m_pcmlDoc.getStringValue(name, type);                    // @C9A\n    }\n\n\n    /**\n    Returns a String value for the named element given indices to the data element.\n    If the data element is an array or is an element in a structure array, an index\n    must be specified for each dimension of the data.\n    The default bidi string type is assumed ({@link com.ibm.as400.access.BidiStringType#DEFAULT BidiStringType.DEFAULT}).\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to a String.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for setting the value of an element in an array.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public String getStringValue(String name, int[] indices)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getStringValue(name, new PcmlDimensions(indices), BidiStringType.DEFAULT);\n    }\n\n    /**\n    Returns a String value for the named element given indices to the data element.\n    If the data element is an array or is an element in a structure array, an index\n    must be specified for each dimension of the data.\n    <p>\n    This method is used when the string type cannot be determined until\n    run-time.  In those cases, the PCML document cannot be used to indicate\n    the string type so this method is used to get the value using the\n    string type that is specified.\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to a String.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for setting the value of an element in an array.\n    @param type The bidi string type, as defined by the CDRA (Character\n                Data Representation Architecture).\n    @exception PcmlException\n               If an error occurs.\n    @see com.ibm.as400.access.BidiStringType\n    */\n    public String getStringValue(String name, int[] indices, int type)\n        throws PcmlException                                            // @C9A\n    {\n        return m_pcmlDoc.getStringValue(name, new PcmlDimensions(indices), type);           // @C9A\n    }\n\n    /**\n    Returns the list of IBM i system messages returned from running the\n    program. An empty list is returned if the program has not been run yet.\n\n    @param name The name of the &lt;program&gt; element in the PCML document.\n    @return The array of messages returned by the system for the program.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public AS400Message[] getMessageList(String name)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getMessageList(name);\n    }\n\n    /**\n    Returns the number of bytes reserved for output for the named element.\n\n    @return The number of bytes reserved for output for the named element.\n    @param name The name of the &lt;data&gt; or &lt;struct&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getOutputsize(String name)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getOutputsize(name);\n    }\n\n    /**\n    Returns the number of bytes reserved for output for the named element and indices.\n\n    @return The number of bytes reserved for output for the named element.\n    @param name The name of the &lt;data&gt; or &lt;struct&gt; element in the PCML document.\n    @param indices An array of indices for accessing the output size of an element in an array.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getOutputsize(String name, int[] indices)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getOutputsize(name, new PcmlDimensions(indices));\n    }\n\n    /**\n    Returns the Java object value for the named element.\n    <p>\n    If the named element is an output value of a program, the value will\n    be converted from IBM i system data to a Java Object.\n    <p>\n    The type of object returned depends on the description in the PCML document.\n    <table border=1>\n    <tr valign=top><th>PCML Description</th><th>Object Returned</th></tr>\n    <tr valign=top><td><code>type=char</td><td><code>String</code></td></tr>\n    <tr valign=top><td><code>type=byte</td><td><code>byte[]</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=2<br>\n                             precision=15</td><td><code>Short</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=2<br>\n                             precision=16</td><td><code>Integer</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=4<br>\n                             precision=31</td><td><code>Integer</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=4<br>\n                             precision=32</td><td><code>Long</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=8<br>\n                             precision=63</td><td><code>Long</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=8<br>\n                             precision=64</td><td><code>BigInteger</code></td></tr>\n    <tr valign=top><td><code>type=packed</td><td><code>BigDecimal</code></td></tr>\n    <tr valign=top><td><code>type=zoned</td><td><code>BigDecimal</code></td></tr>\n    <tr valign=top><td><code>type=float<br>\n                             length=4</td><td><code>Float</code></td></tr>\n    <tr valign=top><td><code>type=float<br>\n                             length=8</td><td><code>Double</code></td></tr>\n    <tr valign=top><td><code>type=date</td><td><code>java.sql.Date</code></td></tr>\n    <tr valign=top><td><code>type=time</td><td><code>java.sql.Time</code></td></tr>\n    <tr valign=top><td><code>type=timestamp</td><td><code>java.sql.Timestamp</code></td></tr>\n    </table>\n\n    @return The Java object value for the named &lt;data&gt; element in the PCML document.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public Object getValue(String name)\n        throws PcmlException\n    {\n      if (Trace.isTraceOn()) Trace.log(Trace.PCML, \"Entered method ProgramCallDocument.getValue(\"+name+\")\");\n\n      Object val = m_pcmlDoc.getValue(name);\n\n      if (Trace.isTraceOn()) Trace.log(Trace.PCML, \"Exiting method ProgramCallDocument.getValue(\"+name+\")\");\n\n      return val;\n    }\n\n    /**\n    Returns the Java object value for the named element given indices to the data element.\n    If the data element is an array or is an element in a structure array, an index\n    must be specified for each dimension of the data.\n    <p>\n    If the named element is an output value of a program, the value will\n    be converted from IBM i system data to a Java Object.\n    <p>\n    The type of object returned depends on the description in the PCML document.\n    <table border=1>\n    <tr valign=top><th>PCML Description</th><th>Object Returned</th></tr>\n    <tr valign=top><td><code>type=char</td><td><code>String</code></td></tr>\n    <tr valign=top><td><code>type=byte</td><td><code>byte[]</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=2<br>\n                             precision=15</td><td><code>Short</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=2<br>\n                             precision=16</td><td><code>Integer</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=4<br>\n                             precision=31</td><td><code>Integer</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=4<br>\n                             precision=32</td><td><code>Long</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=8<br>\n                             precision=63</td><td><code>Long</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=8<br>\n                             precision=64</td><td><code>BigInteger</code></td></tr>\n    <tr valign=top><td><code>type=packed</td><td><code>BigDecimal</code></td></tr>\n    <tr valign=top><td><code>type=zoned</td><td><code>BigDecimal</code></td></tr>\n    <tr valign=top><td><code>type=float<br>\n                             length=4</td><td><code>Float</code></td></tr>\n    <tr valign=top><td><code>type=float<br>\n                             length=8</td><td><code>Double</code></td></tr>\n    <tr valign=top><td><code>type=date</td><td><code>java.sql.Date</code></td></tr>\n    <tr valign=top><td><code>type=time</td><td><code>java.sql.Time</code></td></tr>\n    <tr valign=top><td><code>type=timestamp</td><td><code>java.sql.Timestamp</code></td></tr>\n    </table>\n\n    @return The Java object value for the named &lt;data&gt; element in the PCML document.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for accessing the value of an element in an array.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public Object getValue(String name, int[] indices)\n        throws PcmlException\n    {\n      if (Trace.isTraceOn()) Trace.log(Trace.PCML, \"Entered method ProgramCallDocument.getValue(\"+name+\", indices)\");\n\n      Object val = m_pcmlDoc.getValue(name, new PcmlDimensions(indices));\n\n      if (Trace.isTraceOn()) Trace.log(Trace.PCML, \"Exiting method ProgramCallDocument.getValue(\"+name+\", indices)\");\n\n      return val;\n    }\n\n    /**\n    Gets the system on which programs are to be called.\n\n    @return The current system for this ProgramCallDocument.\n\n    @see #setSystem\n    **/\n    public AS400 getSystem()                                        // @C4A\n    {                                                               // @C4A\n        return m_as400;                                             // @C4A\n    }                                                               // @C4A\n\n\n    /**\n     Serializes the ProgramCallDocument. Note that XPCML documents\n     cannot be serialized.\n\n     The filename of the serialized file will be of the form\n     <pre>\n     <kbd><i>docName</i>.pcml.ser</kbd>\n     </pre>\n     where <kbd><i>docName</i>.pcml.ser</kbd> (lowercase) is the name of the document used to\n\t construct this object.\n\n     @exception PcmlException If an error occurs.\n     @deprecated Use {@link #serialize(File) serialize(File)} instead.\n     */\n    public void serialize()\n        throws PcmlException\n    {\n      if (m_pcmlDoc == null) {\n        throw new PcmlException(DAMRI.DOCUMENT_NOT_SET);\n      }\n      try {\n        savePcmlDocument(m_pcmlDoc);\n      }\n      catch (IOException e) {\n        if (Trace.isTraceErrorOn())\n          e.printStackTrace(Trace.getPrintWriter());\n        throw new PcmlException(e);\n      }\n    }\n\n\n    /**\n     Serializes the ProgramCallDocument to a stream.\n\n     @param outputStream The output stream to which to serialize the object.\n     @exception IOException  If an error occurs while writing to the stream.\n     @exception PcmlException  If an error occurs while processing PCML.\n     **/\n    public void serialize(OutputStream outputStream)\n      throws IOException, PcmlException\n    {\n      if (outputStream == null) {\n        throw new NullPointerException(\"outputStream\");\n      }\n      if (m_pcmlDoc == null) {\n        throw new PcmlException(DAMRI.DOCUMENT_NOT_SET);\n      }\n      savePcmlDocument(m_pcmlDoc, outputStream);\n    }\n\n    /**\n     Serializes the ProgramCallDocument to a file.\n\n     @param file The file to which to serialize the object.\n     @exception IOException  If an error occurs while writing to the file.\n     @exception XmlException  If an error occurs while processing RFML.\n     **/\n    public void serialize(File file)\n      throws IOException, XmlException\n    {\n      FileOutputStream fos = null;\n      try\n      {\n        fos = new FileOutputStream(file);\n        serialize(fos);\n      }\n      finally\n      {\n        if (fos != null) fos.close();\n      }\n    }\n\n    /**\n    Sets the Java object value for the named element using a int input.\n    <p>\n    The named element must be able to be set using a Integer object.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param value The int value for the named element.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public void setIntValue(String name, int value)\n        throws PcmlException\n    {\n        setValue(name, new Integer(value));\n    }\n\n    /**\n    Sets the Java object value for the named element using an int input value\n    given indices to the data element.\n    <p>\n    The named element must be able to be set using a Integer object.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for setting the value of an element in an array.\n    @param value The int value for the named element.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public void setIntValue(String name, int[] indices, int value)\n        throws PcmlException\n    {\n        setValue(name, indices, new Integer(value));\n    }\n\n\n    /**\n    Sets the Java object value for the named element using a String input.\n    The default bidi string type is assumed ({@link com.ibm.as400.access.BidiStringType#DEFAULT BidiStringType.DEFAULT}).\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param value The string value for the named element.\n    @exception PcmlException If an error occurs.\n    */\n    public void setStringValue(String name, String value)\n        throws PcmlException\n    {\n        setStringValue(name, value, BidiStringType.DEFAULT);\n    }\n\n    /**\n    Sets the Java object value for the named element using a String input.\n    <p>\n    This method is used when the string type cannot be determined until\n    run-time.  In those cases, the PCML document cannot be used to indicate\n    the string type so this method is used to set the value and the\n    string type of the input value.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param value The string value for the named element.\n    @param type The bidi string type, as defined by the CDRA (Character\n                Data Representation Architecture).\n    @exception PcmlException\n               If an error occurs.\n    @see com.ibm.as400.access.BidiStringType\n    */\n    public void setStringValue(String name, String value, int type)\n        throws PcmlException                                            // @C9A\n    {\n        m_pcmlDoc.setStringValue(name, value, type);                    // @C9A\n    }\n\n    /**\n    Sets the Java object value for the named element using a String input value\n    given indices to the data element.\n    <p>\n    This method is used when the string type cannot be determined until\n    run-time.  In those cases, the PCML document cannot be used to indicate\n    the string type so this method is used to set the value and the\n    string type of the input value.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for setting the value of an element in an array.\n    @param value The string value for the named element.\n    @param type The bidi string type, as defined by the CDRA (Character\n                Data Representation Architecture).\n    @exception PcmlException\n               If an error occurs.\n    @see com.ibm.as400.access.BidiStringType\n    */\n    public void setStringValue(String name, int[] indices, String value, int type)\n        throws PcmlException                                            // @C9A\n    {\n        m_pcmlDoc.setStringValue(name, value, new PcmlDimensions(indices), type);           // @C9A\n    }\n\n    /**\n    Sets the PCML or XPCML document resource.\n    The PCML or XPCML document resource will be loaded from the classpath.\n    The classpath will first be searched for a serialized resource.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML or XPCML source file.\n\n    @param docName The document resource name of the PCML document for the programs to be called.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    **/\n    public void setDocument(String docName)\n        throws PcmlException                                        // @C1A\n    {                                                               // @C1A\n        if (m_pcmlDoc != null)                                      // @C1A\n            throw new PcmlException(DAMRI.DOCUMENT_ALREADY_SET );   // @C1A\n\n        if (docName == null)                                        // @C1A\n            throw new NullPointerException(\"docName\");              // @C1A\n\n        m_pcmlDoc = loadPcmlDocument(docName, null,null);           // @C1A @C8C\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);                                // @C1A\n    }                                                               // @C1A\n\n\n    /**\n    Sets the XPCML document resource.\n    The XPCML document resource will be loaded from the classpath.\n\n    @param docName The document resource name of the PCML document for the programs to be called.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    **/\n    public void setDocument(String docName, InputStream xsdStream)\n        throws PcmlException                                        // @C1A\n    {                                                               // @C1A\n        if (m_pcmlDoc != null)                                      // @C1A\n            throw new PcmlException(DAMRI.DOCUMENT_ALREADY_SET );   // @C1A\n\n        if (docName == null)                                        // @C1A\n            throw new NullPointerException(\"docName\");              // @C1A\n\n        m_pcmlDoc = loadPcmlDocument(docName, null,xsdStream);      // @C1A @C8C\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);                                // @C1A\n    }                                                               // @C1A\n\n\n    /**\n    Sets the PCML or XPCML document resource.\n    The PCML or XPCML document resource will be loaded from the classpath.\n    The classpath will first be searched for a serialized resource.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML or XPCML source file.\n\n    @param docName The document resource name of the PCML document for the programs to be called.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    **/\n    public void setDocument(String docName, ClassLoader loader)     // @C8A\n        throws PcmlException                                        // @C8A\n    {                                                               // @C8A\n        if (m_pcmlDoc != null)                                      // @C8A\n            throw new PcmlException(DAMRI.DOCUMENT_ALREADY_SET );   // @C8A\n\n        if (docName == null)                                        // @C8A\n            throw new NullPointerException(\"docName\");              // @C8A\n\n        m_pcmlDoc = loadPcmlDocument(docName, loader,null);         // @C8A\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);                                // @C8A\n    }                                                               // @C8A\n\n    /**\n    Sets the PCML or XPCML document resource.\n    The document resource will be loaded from the classpath.\n\n    @param docName The document resource name of the PCML or XPCML document for the programs to be called.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    **/\n    public void setDocument(String docName, ClassLoader loader,InputStream xsdStream)     // @C8A\n        throws PcmlException                                        // @C8A\n    {                                                               // @C8A\n        if (m_pcmlDoc != null)                                      // @C8A\n            throw new PcmlException(DAMRI.DOCUMENT_ALREADY_SET );   // @C8A\n\n        if (docName == null)                                        // @C8A\n            throw new NullPointerException(\"docName\");              // @C8A\n\n        m_pcmlDoc = loadPcmlDocument(docName, loader, xsdStream);   // @C8A\n        m_pcmlDoc.setAs400(m_as400);                                // @C8A\n    }                                                               // @C8A\n\n\n    /**\n    Sets the system on which to call programs.\n\n    @param system  The system on which to call programs.\n\n    **/\n    public void setSystem(AS400 system)                             // @C1A\n    {                                                               // @C1A\n        if (system == null)                                         // @C1A\n            throw new NullPointerException(\"system\");               // @C1A\n\n        m_as400 = system;                                           // @C1A\n        m_pcmlDoc.setAs400(m_as400);                                // @C1A\n    }                                                               // @C1A\n\n    /**\n    Sets the Java object value for the named element.\n    <p>\n    If the input value provided is not an instance of the\n    correct Java class for the defined data type, it will be converted\n    to the correct Java class. For example, an element defined as \"<code>type=int length=2 precision=15</code>\",\n    will be converted to a Java Short object. In this case the value specified must be an instance of Number or String.\n    <p>\n    If the named element is an input value to a program, the value will\n    be converted to IBM i system data when {@link #callProgram(String) callProgram()} is called.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param value The java object value for the named element. The type of Object passed must be\n    the correct type for the element definition or a String that can be converted to the correct type.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public void setValue(String name, Object value)\n        throws PcmlException\n    {\n        m_pcmlDoc.setValue(name, value);\n    }\n\n    /**\n    Sets the Java object value for the named element\n    given indices to the data element.\n    If the data element is an array or is an element in a structure array, an index\n    must be specified for each dimension of the data.\n    <p>\n    If the input value provided is not an instance of the\n    correct Java class for the defined data type, it will be converted\n    to the correct Java class. For example, an element defined as \"<code>type=int length=2 precision=15</code>\",\n    will be converted to a Java Short object. In this case the value specified must be an instance of Number or String.\n    <p>\n    If the named element is an input value to a program, the value will\n    be converted to IBM i system data when {@link #callProgram(String) callProgram()} is called.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for setting the value of an element in an array.\n    @param value The java object value for the named element. The type of Object passed must be\n    the correct type for the element definition or a String that can be converted to the correct type.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public void setValue(String name, int[] indices, Object value)\n        throws PcmlException\n    {\n        m_pcmlDoc.setValue(name, value, new PcmlDimensions(indices));\n    }\n\n    /**\n    Allows for dynamically specifying the program path of the program to be called.\n\n    @param program The name of the &lt;program&gt; element in the PCML document.\n    @param path A String containing the path to the program object to be run on the system.\n    @exception PcmlException\n               If an error occurs.\n    @see #setDocument(String)\n    @see #ProgramCallDocument(AS400,String,InputStream,ClassLoader,InputStream,int)\n    */\n    public void setPath(String program, String path)                    // @D1A\n        throws PcmlException                                            // @D1A\n    {\n        m_pcmlDoc.setPath(program, path);                               // @D1A\n    }\n\n    /**\n    Allows the overriding of the threadsafe attribute of a program element.\n\n    @param program The name of the &lt;program&gt; element in the PCML document.\n    @param threadsafe A boolean indicating whether the named program element should be considered\n    thread safe (true) or not (false).\n    @exception PcmlException\n               If an error occurs.\n    */\n    public void setThreadsafeOverride(String program, boolean threadsafe)\n        throws PcmlException\n    {\n        m_pcmlDoc.setThreadsafeOverride(program, threadsafe);           // @C6A\n    }\n\n    /**\n    Gets the value of the override of the threadsafe attribute of a program element.\n\n    @param program The name of the &lt;program&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public boolean getThreadsafeOverride(String program)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getThreadsafeOverride(program);           // @C6A\n    }\n\n\n    /**\n      Saves a PcmlDocument as a serialized resource.\n    **/\n    private static void savePcmlDocument(PcmlDocument pd)\n        throws PcmlException, IOException\n    {\n      String outFileName = pd.getDocName() + SystemResourceFinder.m_pcmlSerializedExtension;\n      BufferedOutputStream fos = null;\n      try\n      {\n        fos = new BufferedOutputStream(new FileOutputStream(outFileName));\n\n        savePcmlDocument(pd, fos);\n      }\n      finally\n      {\n        if (fos != null) fos.close();\n      }\n    }\n\n\n    /**\n      Saves a PcmlDocument as a serialized resource.\n    **/\n    private static void savePcmlDocument(PcmlDocument pd, OutputStream outStream)\n        throws PcmlException, IOException\n    {\n        pd.setSerializingWithData(false);\n        ObjectOutputStream out = null;\n\n        try\n        {\n          out = new ObjectOutputStream(outStream);\n          out.writeObject(pd);\n\n          String outFileName = pd.getDocName() + SystemResourceFinder.m_pcmlSerializedExtension;\n          Trace.log(Trace.PCML, SystemResourceFinder.format(DAMRI.PCML_SERIALIZED, new Object[] {outFileName} )); // @D2C\n        }\n        finally\n        {\n          if (out != null) out.close();\n        }\n    }\n\n\n    /**\n      Loads a serialized PcmlDocument or constructs the document from\n      a PCML source file.\n    **/\n    private static PcmlDocument loadPcmlDocument(String docName, ClassLoader loader, InputStream xsdStream)        // @C8C\n        throws PcmlException\n    {\n        PcmlDocument pd = null;\n\n\t\tpd = loadSerializedPcmlDocument(docName, loader);               // @C8C\n\n        // If a PcmlDocument was successfully loaded from a serialized file\n        // return the document loaded.\n        if (pd != null)\n            return pd;\n\n\t\tpd = loadZippedSerializedPcmlDocument(docName, loader);         // @C7A @C8C\n\n        // If a PcmlDocument was successfully loaded from a zipped serialized file\n        // return the document loaded.\n        if (pd != null)                                         // @C7A\n            return pd;                                          // @C7A\n\n\t\tpd = loadSourcePcmlDocument(docName, loader, xsdStream);                   // @C8C\n\n        return pd;\n    }\n\n    private static PcmlDocument loadSerializedPcmlDocumentFromStream(InputStream docStream)\n        throws PcmlException\n    {\n        PcmlDocument pd = null;\n        ObjectInputStream in = null;\n\n        try\n        {\n            // Try to open the serialized PCML document\n            in = new ObjectInputStream(docStream);\n            pd = (PcmlDocument)in.readObject();\n        }\n        catch (Exception e)\n        {\n          if (Trace.isTraceErrorOn())\n             e.printStackTrace(Trace.getPrintWriter());\n          throw new PcmlException(e);\n        }\n        finally\n        {\n          if (in != null) try { in.close(); } catch (Exception e) {}\n        }\n\n        return pd;\n    }\n\n    private static PcmlDocument loadSourcePcmlDocumentFromStream(String docName, InputStream docStream, ClassLoader loader, InputStream xsdStream, boolean isXPCML) throws PcmlException\n    {\n      PcmlDocument pd = null;\n\n      // Construct the PCML document from a source file\n      try\n      {\n          PcmlSAXParser psp = new PcmlSAXParser(docName, docStream, xsdStream, isXPCML, exceptionIfParseError_);\n          pd = psp.getPcmlDocument();\n      }\n      catch (ParseException pe)\n      {\n          if (Trace.isTraceErrorOn())                         \n            pe.printStackTrace(Trace.getPrintWriter());       \n          pe.reportErrors();\n          throw new PcmlException(pe);\n      }\n      catch (PcmlSpecificationException pse)\n      {\n        if (Trace.isTraceErrorOn())                         \n          pse.printStackTrace(Trace.getPrintWriter());       \n          pse.reportErrors();\n          throw new PcmlException(pse);\n      }\n      catch (RuntimeException e)\n      {\n        if (Trace.isTraceErrorOn())                         \n          e.printStackTrace(Trace.getPrintWriter());       \n        Throwable cause = e.getCause();\n        if (cause instanceof PcmlSpecificationException)\n        {\n          PcmlSpecificationException pse = (PcmlSpecificationException)cause;\n          pse.reportErrors();\n          throw new PcmlException(pse);\n        }\n        else\n        {\n          if (Trace.isTraceErrorOn()) //@E0A\n            e.printStackTrace(Trace.getPrintWriter()); //@E0A\n          throw new PcmlException(e);\n        }\n      }\n      catch (Exception e)\n      {\n        if (Trace.isTraceErrorOn())\n           e.printStackTrace(Trace.getPrintWriter());\n        throw new PcmlException(e);\n      }\n\n      return pd;\n    }\n\n    /**\n      Loads a serialized PcmlDocument from a serialized file.\n    **/\n    private static PcmlDocument loadSerializedPcmlDocument(String docName, ClassLoader loader)  // @C8C\n        throws PcmlException\n    {\n        PcmlDocument pd = null;\n        InputStream is = null;\n        ObjectInputStream in = null;\n\n        // First try to find a serialized PCML document\n        try\n        {\n            // Try to open the serialized PCML document\n            is = SystemResourceFinder.getSerializedPCMLDocument(docName, loader);   // @C8C\n\n            in = new ObjectInputStream(is);\n            pd = (PcmlDocument)in.readObject();\n        }\n        catch (MissingResourceException e)\n        {\n            // Ignore exception and try looking for PCML source (below)\n        }\n        catch (StreamCorruptedException e)\n        {\n            // Ignore exception and try looking for zipped serialized PCML (below)\n        }\n        catch (IOException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            throw new PcmlException(e);\n        }\n        catch (ClassNotFoundException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            throw new PcmlException(e);\n        }\n        finally\n        {\n          if (in != null) try { in.close(); } catch (Exception e) {\n            if (Trace.isTraceErrorOn())                        \n              e.printStackTrace(Trace.getPrintWriter());      \n          }\n          if (is != null) try { is.close(); } catch (Exception e) {\n            if (Trace.isTraceErrorOn())                        \n              e.printStackTrace(Trace.getPrintWriter());      \n            \n          }\n        }\n\n        return pd;\n    }\n\n    /**\n      Loads a serialized PcmlDocument from a serialized file.\n    **/\n    private static PcmlDocument loadZippedSerializedPcmlDocument(String docName, ClassLoader loader)    // @C8C\n        throws PcmlException\n    {\n        PcmlDocument pd = null;\n        InputStream is = null;\n        GZIPInputStream gzis = null;\n        ObjectInputStream in = null;\n\n        // First try to find a serialized PCML document\n        try\n        {\n            // Try to open the serialized PCML document\n            is = SystemResourceFinder.getSerializedPCMLDocument(docName, loader);       // @C8C\n\n            gzis = new GZIPInputStream(is);\n            in = new ObjectInputStream(gzis);\n            pd = (PcmlDocument)in.readObject();\n        }\n        catch (MissingResourceException e)\n        {\n            // Ignore exception and try looking for PCML source (below)\n        }\n        catch (IOException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            throw new PcmlException(e);\n        }\n        catch (ClassNotFoundException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            throw new PcmlException(e);\n        }\n        finally\n        {\n          if (in != null)   try { in.close(); } catch (Exception e) { \n            if (Trace.isTraceErrorOn())                        \n              e.printStackTrace(Trace.getPrintWriter());      \n\n          }\n          if (gzis != null) try { gzis.close(); } catch (Exception e) {\n            if (Trace.isTraceErrorOn())                        \n              e.printStackTrace(Trace.getPrintWriter());      \n\n          }\n          if (is != null)   try { is.close(); } catch (Exception e) {\n            if (Trace.isTraceErrorOn())                        \n              e.printStackTrace(Trace.getPrintWriter());      \n\n          }\n        }\n\n        return pd;\n    }\n\n    /**\n      Loads a PcmlDocument from a PCML source file.\n    **/\n    private static PcmlDocument loadSourcePcmlDocument(String docName, ClassLoader loader, InputStream xsdStream)      // @C8C\n        throws PcmlException\n    {\n\n        PcmlDocument pd = null;\n\n        // Construct the PCML document from a source file\n        try\n        {\n            InputStream docStream = SystemResourceFinder.getPCMLDocument(docName, loader);\n            boolean isXPCML = SystemResourceFinder.isXPCML(docName,loader);\n            PcmlSAXParser psp = new PcmlSAXParser(docName, docStream, xsdStream, isXPCML, exceptionIfParseError_);         // @C2A @C8C\n            pd = psp.getPcmlDocument();                             // @C2A\n        }\n        catch (ParseException pe)\n        {\n            pe.reportErrors();\n            throw new PcmlException(pe);\n        }\n        catch (PcmlSpecificationException pse)\n        {\n            pse.reportErrors();\n            throw new PcmlException(pse);\n        }\n        catch (RuntimeException e)\n        {\n          Throwable cause = e.getCause();\n          if (cause instanceof PcmlSpecificationException)\n          {\n            PcmlSpecificationException pse = (PcmlSpecificationException)cause;\n            pse.reportErrors();\n            throw new PcmlException(pse);\n          }\n          else\n          {\n            if (Trace.isTraceErrorOn()) //@E0A\n              e.printStackTrace(Trace.getPrintWriter()); //@E0A\n            throw new PcmlException(e);\n          }\n        }\n        catch (Exception e) //@E0A\n        {\n          if (Trace.isTraceErrorOn()) //@E0A\n             e.printStackTrace(Trace.getPrintWriter()); //@E0A\n          throw new PcmlException(e);\n        }\n\n        return pd;\n    }\n\n\n    // @E1A -- ALL NEW XPCML methods....\n    /**\n     Generates XPCML representing the data associated with the passed-in program name.\n     Note: XPCML cannot be generated from a serialized PCML file.\n     XPCML is XML based on the XML schema defined in xpcml.xsd.   XPCML is similar\n     to PCML but allows for better validation of parameters and allows parameter\n     data to be input and output within an XML document.  PCML is data-less in\n     that only parameter formats are input via PCML.  In PCML, data values are set using\n     the setValue methods of the ProgramCallDocument class, and data values are\n     gotten using the getValue methods of ProgramCallDocument.  In XPCML, data values\n     can be specified directly within the XPCML source document, and data values can be output\n     as XML using the generateXPCML method.\n     Throws an XmlException if this object contains no data.\n     @param pgmName The program to generate XPCML for\n     @param outputStream The output stream to which to write the text.\n     @exception IOException  If an error occurs while writing the data.\n     @exception XmlException  If an error occurs while processing XPCML.\n     **/\n    public void generateXPCML(String pgmName, OutputStream outputStream)\n      throws IOException, XmlException\n    {\n      if (outputStream == null) {\n        throw new NullPointerException(\"outputStream\");\n      }\n      if (m_pcmlDoc == null) {\n        throw new XmlException(DAMRI.DOCUMENT_NOT_SET );\n      }\n      m_pcmlDoc.generateXPCML(pgmName, outputStream);\n    }\n\n\n    // @E2C -- Added more info on XPCML.  Changed all RFML references to XPCML.\n    /**\n     Generates XPCML representing the data contained in the entire PCML node tree.\n     Note: XPCML cannot be generated from a serialized PCML file.\n     XPCML is XML based on the XML schema defined in xpcml.xsd.   XPCML is similar\n     to PCML but allows for better validation of parameters and allows parameter\n     data to be input and output within an XML document.  PCML is data-less in\n     that only parameter formats are input via PCML.  In PCML, data values are set using\n     the setValue methods of the ProgramCallDocument class and data values are\n     gotten using the getValue methods of ProgramCallDocument.  In XPCML, data values\n     can be specified directly within the XPCML document, and data values can be output\n     as XML using the generateXPCML method.\n\n     Throws an XmlException if this object contains no data.\n\n     @param outputStream The output stream to which to write the text.\n     @exception IOException  If an error occurs while writing the data.\n     @exception XmlException  If an error occurs while processing XPCML.\n     **/\n    public void generateXPCML(OutputStream outputStream)\n      throws IOException, XmlException\n    {\n      if (outputStream == null) {\n        throw new NullPointerException(\"outputStream\");\n      }\n      if (m_pcmlDoc == null) {\n        throw new XmlException(DAMRI.DOCUMENT_NOT_SET );\n      }\n      m_pcmlDoc.generateXPCML(null, outputStream);\n    }\n\n\n    /**\n     Generates XPCML representing the data contained in the entire PCML node tree.\n     Note: XPCML cannot be generated from a serialized PCML file.\n     XPCML is XML based on the XML schema defined in xpcml.xsd.   XPCML is similar\n     to PCML but allows for better validation of parameters and allows parameter\n     data to be input and output within an XML document.  PCML is data-less in\n     that only parameter formats are input via PCML.  In PCML, data values are set using\n     the setValue methods of the ProgramCallDocument class and data values are\n     gotten using the getValue methods of ProgramCallDocument.  In XPCML, data values\n     can be specified directly within the XPCML document, and data values can be output\n     as XML using the generateXPCML method.\n     Throws an XmlException if this object contains no data.\n\n     @param fileName The pathname of the file to which to write the text.\n     @exception IOException  If an error occurs while writing the data.\n     @exception XmlException  If an error occurs while processing XPCML.\n     **/\n    public void generateXPCML(String fileName)\n      throws IOException, XmlException\n    {\n      if (fileName == null) {\n        throw new NullPointerException(\"fileName\");\n      }\n      FileOutputStream fos = null;\n      try\n      {\n        fos = new FileOutputStream(fileName);\n        generateXPCML(null, fos);\n      }\n      finally {\n        if (fos != null) fos.close();\n      }\n    }\n\n    /**\n     Generates XPCML representing the data contained for the passed in program name.\n     Note: XPCML cannot be generated from a serialized PCML file.\n     XPCML is XML based on the XML schema defined in xpcml.xsd.   XPCML is similar\n     to PCML but allows for better validation of parameters and allows parameter\n     data to be input and output within an XML document.  PCML is data-less in\n     that only parameter formats are input via PCML.  In PCML, data values are set using\n     the setValue methods of the ProgramCallDocument class and data values are\n     gotten using the getValue methods of ProgramCallDocument.  In XPCML, data values\n     can be specified directly within the XPCML document, and data values can be output\n     as XML using the generateXPCML method.\n     Throws an XmlException if this object contains no data.\n\n     @param pgmName  The program name to generate XPCML for.\n     @param fileName The pathname of the file to which to write the text.\n     @exception IOException  If an error occurs while writing the data.\n     @exception XmlException  If an error occurs while processing XPCML.\n     **/\n    public void generateXPCML(String pgmName,String fileName)\n      throws IOException, XmlException\n    {\n      if (fileName == null) {\n        throw new NullPointerException(\"fileName\");\n      }\n      if (pgmName == null) {\n        throw new NullPointerException(\"pgmName\");\n      }\n      FileOutputStream fos = null;\n      try\n      {\n        fos = new FileOutputStream(fileName);\n        generateXPCML(pgmName, fos);\n      }\n      finally {\n        if (fos != null) fos.close();\n      }\n    }\n\n     // ******************************\n     // @E0A -- New method           *\n     // ******************************\n     /**\n      Sets the XSD name that will appear in the generated &lt;xpcml&gt; tag from the <tt>generateXPCML()</tt> methods.\n      If name is not set then \"xpcml.xsd\" will appear in &lt;xpcml&gt; tag.  This allows the user\n                     to override the default and put in the name of their own xsd that was\n                     used in condensing the XPCML output.\n\n     @param xsdName  The XSD name to appear in the &lt;xpcml&gt; tag when XPCML is output using the\n                     generateXPCML method.\n    **/\n\n    public void setXsdName(String xsdName)\n    {\n        m_pcmlDoc.setXsdName(xsdName);\n    }\n\n\n     // ******************************\n     // @E0A -- New method           *\n     // ******************************\n     /**\n      Returns the value of the XSD name to be used on the &lt;xpcml&gt; tag when\n                     generating XPCML.\n\n     @return The String \"xsdName\" value for this program object.\n     **/\n\n    public String getXsdName()\n    {\n        return m_pcmlDoc.getXsdName();\n    }\n\n\n    public void endInternal2(RJob rJob, int delayTime)\n\tthrows ResourceException\n\t{\n\t    // Validate the properties.\n\t    if (rJob.name_ == null)\n\t        throw new ExtendedIllegalStateException(\"name\", ExtendedIllegalStateException.PROPERTY_NOT_SET);\n\t    if (rJob.number_ == null)\n\t        throw new ExtendedIllegalStateException(\"number\", ExtendedIllegalStateException.PROPERTY_NOT_SET);\n\t    if (rJob.user_ == null)\n\t        throw new ExtendedIllegalStateException(\"user\", ExtendedIllegalStateException.PROPERTY_NOT_SET);\n\t\n\t    // Establish the connection if needed.\n\t    if (!rJob.isConnectionEstablished())\n\t        rJob.establishConnection();\n\t\n\t    // Issue the ENDJOB CL command.\n\t    AS400 sys = null;\n\t    try {\n\t        StringBuffer buffer = new StringBuffer();\n\t        buffer.append(\"ENDJOB JOB(\");\n\t        buffer.append(rJob.number_);\n\t        buffer.append('/');\n\t        buffer.append(rJob.user_);\n\t        buffer.append('/');\n\t        buffer.append(rJob.name_);\n\t        buffer.append(\") OPTION(\");\n\t        if (delayTime == 0) {\n\t            buffer.append(\"*IMMED)\");\n\t        }\n\t        else {\n\t            buffer.append(\"*CNTRLD)\");\n\t            if (delayTime > 0) {\n\t                buffer.append(\" DELAY(\");\n\t                buffer.append(delayTime);\n\t                buffer.append(\")\");\n\t            }\n\t        }\n\t        String endJob = buffer.toString();\n\t\n\t        if (Trace.isTraceOn())\n\t            Trace.log(Trace.INFORMATION, \"Ending the job:\" + endJob);\n\t\n\t        // Use a separate connection, in case the job we're trying to\n\t        // end is the Remote Command Call host server.             @A1a\n\t        sys = new AS400(rJob.getSystem());                            //@A1a\n\t        CommandCall commandCall = new CommandCall(sys, endJob);  //@A1c\n\t        boolean success = commandCall.run();\n\t        if (!success)\n\t            throw new ResourceException(commandCall.getMessageList());\n\t    }\n\t    catch(Exception e) {\n\t        throw new ResourceException(e);\n\t    }\n\t    finally {\n\t        if (sys != null)  sys.disconnectAllServices();\n\t    }\n\t}\n\n\t/**\n     Transforms a PCML stream to its equivalent XPCML stream.\n     Throws an XmlException if this object contains no data.\n\n     @param pcmlStream The PCML input stream.\n     @param xpcmlStream  The output XPCML stream.\n     @exception IOException  If an error occurs while writing the data.\n     @exception PcmlException  If an error occurs while processing XPCML.\n\n     **/\n\n    public static void transformPCMLToXPCML(InputStream pcmlStream, OutputStream xpcmlStream)\n           throws IOException, PcmlException, TransformerException, SAXException\t\n    \t{\n\n           if (pcmlStream == null) {\n             throw new NullPointerException(\"pcmlStream\");\n           }\n\n           if (xpcmlStream == null) {\n             throw new NullPointerException(\"xpcmlStream\");\n           }\n\n           // Transform the PCML document to its equivalent XPCML document\n           XPCMLHelper.doTransform(\"pcml_xpcml.xsl\",pcmlStream, xpcmlStream); //@CRS\n      }\n\n    /**\n     Transforms a fully specified XPCML stream to a more condensed XPCML stream\n     and an XSD stream representing the new type definitions created while condensing.\n     Throws an XmlException if this object contains no data.\n\n     @param fullStream The full XPCML input stream.\n     @param xsdStream  The output xsd stream.\n     @param condensedStream  The output condensed XPCML stream.\n     @param xsdStreamName  The name of the xsd stream (\"name.xsd\") that will be created\n     @exception IOException  If an error occurs while writing the data.\n     @exception PcmlException  If an error occurs while processing XPCML.\n\n     **/\n\n    public static void condenseXPCML(InputStream fullStream, OutputStream xsdStream, OutputStream condensedStream, String xsdStreamName)\n           throws IOException, PcmlException, TransformerException, SAXException\t\n    \t{\n           String xpcmlName=\"\";\n\n           if (fullStream == null) {\n             throw new NullPointerException(\"fullStream\");\n           }\n\n           if (xsdStream == null) {\n             throw new NullPointerException(\"xsdStream\");\n           }\n\n           if (condensedStream == null) {\n             throw new NullPointerException(\"condensedStream\");\n           }\n\n           if (xsdStreamName == null) {\n             throw new NullPointerException(\"xsdStreamName\");\n           }\n\n           // Copy input stream fullStream into twoOutputStream\n           ByteArrayOutputStream outStream1 = new ByteArrayOutputStream();\n\n           byte[] bytesIn = new byte[1000];\n           int bytesRead = 0;\n           bytesRead = fullStream.read(bytesIn);\n\n           while (bytesRead != -1)\n           {\n              outStream1.write(bytesIn,0,bytesRead);\n              bytesRead = fullStream.read(bytesIn);\n           }\n\n           outStream1.flush();\n           outStream1.close();\n\n           // Cache the line count of the header\n           ByteArrayInputStream inStreamFull = new ByteArrayInputStream(outStream1.toByteArray());\n           LineNumberReader lnr = new LineNumberReader(new InputStreamReader(inStreamFull));\n           try\n           {\n             String line = lnr.readLine();\n             boolean found=false;\n             while (line != null && !found)\n             {\n               // Look for xpcml tag\n               if (line.indexOf(\"xsi:noNamespaceSchemaLocation=\") != -1)\n               {\n                  found = true;\n                  int index1 = line.indexOf(\"xsi:noNamespaceSchemaLocation=\");\n                  int index2=0;\n                  index2 = line.indexOf(\"'\", index1);\n                  int index3=0;\n                  if (index2 == -1)\n                  {\n                     index2 = line.indexOf(\"\\\"\",index1);\n                     if (index2 != -1)\n                       index3 = line.indexOf(\"\\\"\", index2+1);\n                  }\n                  else\n                  {\n                     index3 = line.indexOf(\"'\",index2+1);\n                  }\n                  xpcmlName = line.substring(index2+1,index3);\n                  continue;\n               }\n               if (line.indexOf(\"xsi:noNamespaceSchemaLocation =\") != -1)\n               {\n                  found = true;\n                  int index1 = line.indexOf(\"xsi:noNamespaceSchemaLocation =\");\n                  int index2=0;\n                  index2 = line.indexOf(\"'\", index1);\n                  int index3=0;\n                  if (index2 == -1)\n                  {\n                     index2 = line.indexOf(\"\\\"\",index1);\n                     if (index2 != -1)\n                       index3 = line.indexOf(\"\\\"\", index2+1);\n                  }\n                  else\n                  {\n                     index3 = line.indexOf(\"'\",index2+1);\n                  }\n                  xpcmlName = line.substring(index2+1,index3);\n                  continue;\n               }\n               line = lnr.readLine();\n             }\n           }\n           catch (IOException e)\n           {\n             Trace.log(Trace.PCML, \"Error when reading input stream in condenseXPCML\");\n             if (Trace.isTraceErrorOn())\n               e.printStackTrace(Trace.getPrintWriter());\n             throw new PcmlException(e);\n           }\n           if (xpcmlName == \"\")\n              xpcmlName=\"xpcml.xsd\";\n\n           // Write contents of ByteArrayOutputStream to ByteArrayInputStream\n           ByteArrayInputStream inStream1 = new ByteArrayInputStream(outStream1.toByteArray());  // no need to close byte-array stream\n           ByteArrayInputStream inStream2 = new ByteArrayInputStream(outStream1.toByteArray());  // no need to close byte-array stream\n\n           // Create new XSD type definitions based on full XPCML stream\n           XPCMLHelper.doCondenseTransform(\"xpcml_xsd.xsl\",inStream1, xsdStream, xpcmlName); //@CRS\n           // Create condensed XPCML using XSD and full XPCML stream\n           XPCMLHelper.doCondenseTransform(\"xpcml_basic.xsl\",inStream2, condensedStream, xsdStreamName); //@CRS\n\n      }\n\n\n    // Traces a warning message about a null-valued parameter.\n    private static final void warnNull(String parmName)\n    {\n      if (Trace.isTraceOn()) Trace.log(Trace.WARNING, \"Null value specified for '\" + parmName + \"' parameter on ProgramCallDocument constructor.\");\n    }\n\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 3,
                "candidates": [
                    {
                        "lineStart": 1898,
                        "lineEnd": 2021,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "description": "move method to com.ibm.as400.data.XPCMLHelper\nRationale: The method condenseXPCML is responsible for transforming XPCML streams and creating XSD definitions, which aligns with the functionality typically associated with a helper class like XPCMLHelper that deals with XPCML processing.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1871,
                        "lineEnd": 1896,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "description": "move method to com.ibm.as400.data.XPCMLHelper\nRationale: The method transformPCMLToXPCML directly calls XPCMLHelper.doTransform, indicating that it is closely related to the functionality provided by the XPCMLHelper class, making it a suitable candidate for relocation.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1813,
                        "lineEnd": 1869,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to com.ibm.as400.resource.RJob\nRationale: The method endInternal2 operates directly on the properties of the RJob instance, validating its state and establishing a connection if needed. It is closely tied to the job's attributes and behavior, making RJob the most appropriate class for this method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 20057
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "endInternal2",
                            "method_signature": "public void endInternal2(RJob rJob, int delayTime) throws ResourceException",
                            "target_class": "JobManager",
                            "rationale": "The method endInternal2 is responsible for managing job termination, which is more aligned with job management responsibilities than with the ProgramCallDocument class."
                        },
                        {
                            "method_name": "transformPCMLToXPCML",
                            "method_signature": "public static void transformPCMLToXPCML(InputStream pcmlStream, OutputStream xpcmlStream) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLTransformer",
                            "rationale": "This method is focused on transforming PCML to XPCML, which is a transformation concern and should be handled by a dedicated transformer class."
                        },
                        {
                            "method_name": "condenseXPCML",
                            "method_signature": "public static void condenseXPCML(InputStream fullStream, OutputStream xsdStream, OutputStream condensedStream, String xsdStreamName) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLCondensor",
                            "rationale": "The condenseXPCML method is specifically about condensing XPCML, which should be the responsibility of a dedicated class that handles XPCML processing."
                        }
                    ],
                    "llm_response_time": 6176
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "endInternal2",
                            "method_signature": "public void endInternal2(RJob rJob, int delayTime) throws ResourceException",
                            "target_class": "JobManager",
                            "rationale": "The method endInternal2 is responsible for managing job termination, which is more aligned with job management functionality rather than the responsibilities of the ProgramCallDocument class."
                        },
                        {
                            "method_name": "transformPCMLToXPCML",
                            "method_signature": "public static void transformPCMLToXPCML(InputStream pcmlStream, OutputStream xpcmlStream) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLTransformer",
                            "rationale": "The method transformPCMLToXPCML is focused on transforming PCML to XPCML, which is a transformation concern and should be handled by a dedicated transformer class."
                        },
                        {
                            "method_name": "condenseXPCML",
                            "method_signature": "public static void condenseXPCML(InputStream fullStream, OutputStream xsdStream, OutputStream condensedStream, String xsdStreamName) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLCondensor",
                            "rationale": "The method condenseXPCML is responsible for condensing XPCML streams, which is a specific transformation task that should be encapsulated in a dedicated class."
                        }
                    ],
                    "llm_response_time": 5616
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "endInternal2",
                            "method_signature": "public void endInternal2(RJob rJob, int delayTime) throws ResourceException",
                            "target_class": "JobManager",
                            "rationale": "The method endInternal2 is responsible for managing job termination, which is more aligned with job management functionality than with the purpose of the ProgramCallDocument class."
                        },
                        {
                            "method_name": "transformPCMLToXPCML",
                            "method_signature": "public static void transformPCMLToXPCML(InputStream pcmlStream, OutputStream xpcmlStream) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLTransformer",
                            "rationale": "The method transformPCMLToXPCML is focused on transforming PCML to XPCML, which is a transformation concern and should be handled by a dedicated transformer class."
                        },
                        {
                            "method_name": "condenseXPCML",
                            "method_signature": "public static void condenseXPCML(InputStream fullStream, OutputStream xsdStream, OutputStream condensedStream, String xsdStreamName) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLCondensor",
                            "rationale": "The method condenseXPCML is responsible for condensing XPCML streams, which is a specific transformation task that should be encapsulated in a dedicated class."
                        }
                    ],
                    "llm_response_time": 5842
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "endInternal2",
                            "method_signature": "public void endInternal2(RJob rJob, int delayTime) throws ResourceException",
                            "target_class": "JobManager",
                            "rationale": "The method endInternal2 is responsible for managing job termination, which is more aligned with job management responsibilities than with the ProgramCallDocument class."
                        },
                        {
                            "method_name": "transformPCMLToXPCML",
                            "method_signature": "public static void transformPCMLToXPCML(InputStream pcmlStream, OutputStream xpcmlStream) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLTransformer",
                            "rationale": "This method is focused on transforming PCML to XPCML, which is a transformation concern and should be handled by a dedicated transformer class."
                        },
                        {
                            "method_name": "condenseXPCML",
                            "method_signature": "public static void condenseXPCML(InputStream fullStream, OutputStream xsdStream, OutputStream condensedStream, String xsdStreamName) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLCondensor",
                            "rationale": "The condenseXPCML method is specifically about condensing XPCML, which should be the responsibility of a dedicated class that handles XPCML processing."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "condenseXPCML",
                    "transformPCMLToXPCML",
                    "endInternal2"
                ],
                "llm_response_time": 2346
            },
            "targetClassMap": {
                "condenseXPCML": {
                    "target_classes": [
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.3765672909746007
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.6172580559706903
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.6271049581116438
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.38067818673885007
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.19367285212982108
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.628744623002583
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.40972800660333825
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.6105358687552762
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.45105752222311163
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.4734928388898259
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.5186220097597671
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.6536583705843837
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.33383037620596717
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.7015697590450435
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.3783904412449756
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.414738970188735
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.23465270060995655
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.6898516386024158
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.6880670131809189
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.4582813556480455
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.6251201956855112
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.6728291356274912
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.5248462387194186
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.316511470546188
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.5413232647944841
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.49896583177960724
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.36537224179341954
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.322495931123742
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.46745000271225334
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.7445309154299529
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.504514783857638
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.48243499106011617
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.5066390806343564
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.40244886693777915
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.29970353721825804
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.5895171262998592
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.7553509600554871
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.407144427919143
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.4556894178449329
                        },
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.2717443762988976
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.6947767207118349
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.6197416191570789
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.3534724183404498
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.14054782482444636
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.6901218682333052
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.4100313965054079
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.6592743056955005
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.4971845101816648
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.7456412901555219
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.5670731609771889
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.643948183783359
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.35089652829916407
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.6540522949672394
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.5034698542618196
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.4219131521474504
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.3547964997610225
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.7323943646032743
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.7005012341783255
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.48838137089892986
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.6129218271545027
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.7153348878337686
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.6126779391097601
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.3217984950428556
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.5527329517452261
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.5946673917782455
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.470188926272963
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.30975237299504105
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.5667098431495033
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.7527823320710303
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.518728384865005
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.5899508871404848
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.5159236077594765
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.45967364147002276
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.32774830213475725
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.6682636753154775
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.677521808473057
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.44662848687336815
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.5527585943448606
                        },
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.2716802354522363
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.6966347991669658
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.586462789926043
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.37614690276728696
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.14054782482444636
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.6902801623120879
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.4046311907097656
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.6583512365879538
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.5130034750969357
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.745820947034839
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.5694817678446785
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.6527944809470644
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.3528268312182898
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.6572564909478467
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.5116733534331043
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.4204467174999459
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.3890689522115828
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.7305171149187962
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.7005182918761156
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.5065957537636652
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.619508140996124
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.7234651346165792
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.6166755895391479
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.35492653911236266
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.5599976182596097
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.6111650292898236
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.48432049714111974
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.342250141659371
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.5700947775271181
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.7433363283271502
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.5273267990410989
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.5974256129808101
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.4956360939871625
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.47681093917305933
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.3638312766005801
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.6698405905262299
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.6830110789019732
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.4664958567887974
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.5621517557020906
                        },
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.2717443762988976
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.6947767207118349
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.6197416191570789
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.3534724183404498
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.14054782482444636
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.6901218682333052
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.4100313965054079
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.6592743056955005
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.4971845101816648
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.7456412901555219
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.5670731609771889
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.643948183783359
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.35089652829916407
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.6540522949672394
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.5034698542618196
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.4219131521474504
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.3547964997610225
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.7323943646032743
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.7005012341783255
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.48838137089892986
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.6129218271545027
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.7153348878337686
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.6126779391097601
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.3217984950428556
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.5527329517452261
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.5946673917782455
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.470188926272963
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.30975237299504105
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.5667098431495033
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.7527823320710303
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.518728384865005
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.5899508871404848
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.5159236077594765
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.45967364147002276
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.32774830213475725
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.6682636753154775
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.677521808473057
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.44662848687336815
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.5527585943448606
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "XPCMLHelper",
                        "SystemResourceFinder",
                        "RfmlRecordFormat",
                        "PcmlProgram",
                        "PcmlSAXParser",
                        "PcmlDataValues",
                        "RfmlDocument",
                        "RfmlSAXParser",
                        "PcmlData",
                        "PcmlStruct",
                        "RecordFormatDocument",
                        "PcmlDocNode",
                        "PcmlDocument",
                        "PcmlNode",
                        "ParseException",
                        "PcmlDataVector",
                        "PcmlMessageLog",
                        "DocNodeDescriptor",
                        "XMLErrorHandler",
                        "PcmlSpecificationException",
                        "PcmlDimensions",
                        "StructDescriptor",
                        "PcmlAttributeList",
                        "PcmlDocRoot",
                        "XmlException",
                        "DataDescriptor",
                        "ResourceLoader",
                        "ProgramDescriptor",
                        "RecordFormatDescriptor",
                        "PcmlAttribute",
                        "RfmlStruct",
                        "PcmlException",
                        "RfmlData",
                        "DAMRI",
                        "SystemClassLoader",
                        "PcmlDescriptor",
                        "PcmlNodeType",
                        "RfmlDescriptor",
                        "Descriptor"
                    ],
                    "llm_response_time": 1299,
                    "similarity_computation_time": 5930,
                    "similarity_metric": "cosine"
                },
                "transformPCMLToXPCML": {
                    "target_classes": [
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.21179589015887929
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.4168172493733724
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.3088935890544522
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.31709818672283435
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.26772851592051233
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.42307303236086674
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.3014854404285189
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.3511839459315007
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.22459751605507472
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.2825533755885794
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.3430341221632166
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.4889516967646544
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.10153461651336192
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.6195815291269746
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.33682604570185554
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.1881034716665781
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.24711661107888894
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.47007911287727866
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.5369438872551562
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.3324017810063613
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.38290465686620706
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.4258122514306636
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.3067386515957241
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.3302607529641595
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.31469182370318033
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.3981630907896169
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.3509171039242196
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.34701310999857343
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.3223133756761372
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.4713255023362331
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.3580033815589712
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.40986142728527303
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.27909962285327905
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.3716247331497075
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.2917148778444757
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.6216072554433176
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.4919710452271076
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.37990774789048
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.3339079571763121
                        },
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.13062970971673757
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.40072349951857167
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.25104279302257243
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.20710018887451917
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.08047572011413082
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.38760498971549767
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.24974213505257487
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.312170007795351
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.24809106804563402
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.3444165228742817
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.2793968480157845
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.3950025402761049
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.1186632443173688
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.4099273068623479
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.2787760720267345
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.18747070998966744
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.2754211041653693
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.3700731671826021
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.4173220508220457
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.3587375953973916
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.35486262749945957
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.4028522474463793
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.3237641852291173
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.2333664145937279
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.29026730229985415
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.3609008432428234
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.33205735647907086
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.2164725297554095
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.2597670357064914
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.3783277482131607
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.33596468182426004
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.372537975699926
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.2836880022264773
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.3523848455463737
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.2587516028631446
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.4720524695661405
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.39872916841090117
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.3174619397427218
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.3003749930442465
                        },
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.1285398626524534
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.39765488677586724
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.2204461592667235
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.1861467969411635
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.08047572011413082
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.38664192329988367
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.20804471908288188
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.31062521327445675
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.23952739961867842
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.3403828379826318
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.2700304541283765
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.3981845667060667
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.11193324221211003
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.4095774904807194
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.2690359146090172
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.1712054070549991
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.2587516028631446
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.36793162446212374
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.4139255190973813
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.3616726978772017
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.3483873867950317
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.4002252242170566
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.3197708261460665
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.21677437400579747
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.2876676498426658
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.34029332315067345
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.3297146518383836
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.1930427573587431
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.25443688194419717
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.3661138501066452
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.33483898145921054
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.3699271880721806
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.2485239779830632
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.3490862036288189
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.24640556370331668
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.47510256894966
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.38479105002790337
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.3070118225813345
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.2950568851507872
                        },
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.13062970971673757
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.40072349951857167
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.25104279302257243
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.20710018887451917
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.08047572011413082
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.38760498971549767
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.24974213505257487
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.312170007795351
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.24809106804563402
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.3444165228742817
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.2793968480157845
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.3950025402761049
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.1186632443173688
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.4099273068623479
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.2787760720267345
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.18747070998966744
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.2754211041653693
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.3700731671826021
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.4173220508220457
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.3587375953973916
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.35486262749945957
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.4028522474463793
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.3237641852291173
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.2333664145937279
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.29026730229985415
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.3609008432428234
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.33205735647907086
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.2164725297554095
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.2597670357064914
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.3783277482131607
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.33596468182426004
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.372537975699926
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.2836880022264773
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.3523848455463737
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.2587516028631446
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.4720524695661405
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.39872916841090117
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.3174619397427218
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.3003749930442465
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "XPCMLHelper",
                        "PcmlDocument",
                        "RecordFormatDocument",
                        "RfmlDocument",
                        "RfmlSAXParser",
                        "SystemResourceFinder",
                        "RfmlRecordFormat",
                        "PcmlSAXParser",
                        "PcmlDataValues",
                        "PcmlStruct",
                        "PcmlData",
                        "DocNodeDescriptor",
                        "PcmlMessageLog",
                        "ParseException",
                        "RecordFormatDescriptor",
                        "ProgramDescriptor",
                        "DataDescriptor",
                        "StructDescriptor",
                        "PcmlDocNode",
                        "ResourceLoader",
                        "RfmlDescriptor",
                        "PcmlProgram",
                        "XmlException",
                        "PcmlSpecificationException",
                        "PcmlDescriptor",
                        "PcmlDataVector",
                        "XMLErrorHandler",
                        "RfmlData",
                        "PcmlDimensions",
                        "PcmlNode",
                        "RfmlStruct",
                        "SystemClassLoader",
                        "PcmlAttributeList",
                        "PcmlException",
                        "Descriptor",
                        "PcmlDocRoot",
                        "DAMRI",
                        "PcmlAttribute",
                        "PcmlNodeType"
                    ],
                    "llm_response_time": 1241,
                    "similarity_computation_time": 91,
                    "similarity_metric": "cosine"
                },
                "endInternal2": {
                    "target_classes": [
                        {
                            "class_name": "RJob",
                            "similarity_score": 0.3999268311197287
                        },
                        {
                            "class_name": "AS400",
                            "similarity_score": 0.7158544931636377
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.7026322118373899
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "RJob",
                        "AS400",
                        "PcmlDocument"
                    ],
                    "llm_response_time": 2204,
                    "similarity_computation_time": 14,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.util.html.HTMLVector::readObject(java.io.ObjectInputStream):void need move com.ibm.as400.util.html.HTMLTree",
        "class_name": "com.ibm.as400.util.html.HTMLVector",
        "telemetry": {
            "id": "13a9ce5f-a42a-4c1d-9421-db60b9487408",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 57,
                "lineStart": 20,
                "lineEnd": 76,
                "bodyLineStart": 20,
                "language": "java",
                "sourceCode": "/**\n * This Vector is used internally by the HTML classes for performance reasons.\n**/\npublic class HTMLVector extends Vector\n{\n  /**\n   * This returns the superclass's element data array, which may be longer\n   * than the actual number of elements. Therefore, the objects at the end\n   * of the array could be null. Care should be taken to avoid these when\n   * looping, by using the elementCount returned by getCount().\n  **/\n  public Object[] getData()\n  {\n    return elementData;\n  }\n  \n  /**\n   * This returns the superclass's element count, which is the actual number\n   * of elements that are populated in the array returned by getData().\n   * Use this number for the maximum element count when looping through the\n   * element data, to avoid grabbing the null elements at the end of the\n   * element data array.\n  **/\n  public int getCount()\n  {\n    return elementCount;\n  }\n\n/**\n*  Deserializes and initializes transient data.\n * @param htmlTree TODO\n * @param in TODO\n**/\nvoid readObject(HTMLTree htmlTree, ObjectInputStream in)\nthrows java.io.IOException, ClassNotFoundException\n{\n    // @B2A\n    // If the locale is Korean, then this throws\n    // an ArrayIndexOutOfBoundsException.  This is\n    // a bug in the JDK.  The workarond in that case\n    // is just to use String.compareTo().\n    try                                                                            // @B2A\n    {\n        htmlTree.collator_ = Collator.getInstance ();                           // @B2A\n        htmlTree.collator_.setStrength (Collator.PRIMARY);                // @B2A\n    }\n    catch (Exception e)                                                    // @B2A\n    {\n        htmlTree.collator_ = null;                                                      // @B2A\n    }\n\n    in.defaultReadObject();\n\n    //@P2D changes_ = new PropertyChangeSupport(this);\n    //@P2D elementListeners = new Vector();\n}\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 47,
                        "lineEnd": 74,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to com.ibm.as400.util.html.HTMLTree\nRationale: The method readObject() directly manipulates the properties of the HTMLTree instance, specifically initializing the collator_ field. It is responsible for deserializing and initializing transient data related to the HTMLTree, making it logical for this method to reside within the HTMLTree class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 5097
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject",
                            "method_signature": "void readObject(HTMLTree htmlTree, ObjectInputStream in) throws java.io.IOException, ClassNotFoundException",
                            "target_class": "HTMLTree",
                            "rationale": "The readObject method is responsible for deserializing and initializing transient data related to HTMLTree. It should be moved to the HTMLTree class to encapsulate the logic that directly pertains to its state."
                        }
                    ],
                    "llm_response_time": 1531
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject",
                            "method_signature": "void readObject(HTMLTree htmlTree, ObjectInputStream in) throws java.io.IOException, ClassNotFoundException",
                            "target_class": "HTMLTree",
                            "rationale": "The readObject method is responsible for deserializing and initializing transient data related to HTMLTree. It should be moved to the HTMLTree class to encapsulate the deserialization logic within the class that it primarily affects."
                        }
                    ],
                    "llm_response_time": 1211
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject",
                            "method_signature": "void readObject(HTMLTree htmlTree, ObjectInputStream in) throws java.io.IOException, ClassNotFoundException",
                            "target_class": "HTMLTree",
                            "rationale": "The readObject method is responsible for deserializing and initializing transient data related to HTMLTree. It should be moved to the HTMLTree class to encapsulate the deserialization logic within the class that it primarily affects."
                        }
                    ],
                    "llm_response_time": 1740
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject",
                            "method_signature": "void readObject(HTMLTree htmlTree, ObjectInputStream in) throws java.io.IOException, ClassNotFoundException",
                            "target_class": "HTMLTree",
                            "rationale": "The readObject method is responsible for deserializing and initializing transient data related to HTMLTree. It should be moved to the HTMLTree class to encapsulate the logic that directly pertains to its state."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "readObject"
                ],
                "llm_response_time": 504
            },
            "targetClassMap": {
                "readObject": {
                    "target_classes": [
                        {
                            "class_name": "HTMLTree",
                            "similarity_score": 0.5086590975474009
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HTMLTree"
                    ],
                    "llm_response_time": 885,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.resource.IntegerValueMap::start():void need move com.ibm.as400.access.NetServer",
        "class_name": "com.ibm.as400.resource.IntegerValueMap",
        "telemetry": {
            "id": "9d38007b-2871-4cdd-a655-2d160fac4361",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 113,
                "lineStart": 27,
                "lineEnd": 139,
                "bodyLineStart": 27,
                "language": "java",
                "sourceCode": "/**\nThe IntegerValueMap class maps between a logical Integer value\nand a physical String value.\n@deprecated Use packages <tt>com.ibm.as400.access</tt> and <tt>com.ibm.as400.access.list</tt> instead. \n**/\npublic class IntegerValueMap\nimplements ValueMap, Serializable\n{\n  private static final String copyright = \"Copyright (C) 1997-2000 International Business Machines Corporation and others.\";\n\n\n\n\n    static final long serialVersionUID = 4L;\n\n\n\n/**\nMaps from a logical value to a physical value.\n\n@param logicalValue     The logical value.\n@param system           The system.\n@return                 The physical value.\n**/\n    public Object ltop(Object logicalValue, AS400 system)\n    {\n        if (logicalValue == null)\n            throw new NullPointerException(\"logicalValue\");\n        if (!(logicalValue instanceof Integer))\n            throw new ExtendedIllegalArgumentException(\"logicalValue\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n\n        return logicalValue.toString();\n    }\n\n\n\n/**\nMaps from a physical value to a logical value.\n\n@param physicalValue    The physical value.\n@param system           The system.\n@return                 The logical value.\n**/\n    public Object ptol(Object physicalValue, AS400 system)\n    {\n        if (physicalValue == null)\n            throw new NullPointerException(\"physicalValue\");\n        if (!(physicalValue instanceof String))\n            throw new ExtendedIllegalArgumentException(\"physicalValue\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n\n        String asString = (String)physicalValue;\n        if (asString.length() == 0)\n            return new Integer(0);\n        else\n            return new Integer(asString.trim());\n    }\n\n\n\n/**\n   Starts the NetServer job on the IBM i system, and (optionally) resets it.\n   If the NetServer is already started, this method does nothing.\n   This method requires *IOSYSCFG special authority on the system.\n   If the QSERVER subsystem is not running, this method will attempt to start it. \n   <p>Note: Reset is used when the NetServer fails to start normally on the system.  It is on the NetServer context menu so an administrator can use it.  The reset does some under-the-covers cleanup, and is used infrequently.  The times it would be used is if the system ended abnormally and there may be jobs or objects hanging around that need to be cleaned up before the system can start again.  The reset does that.\n\n   @param netServer TODO\n * @param reset  Whether or not the system is to be reset when started.\n * @exception ResourceException  If an error occurs.\n   **/\n  public void start2(NetServer netServer, boolean reset)\n    throws ResourceException\n  {\n    if (! netServer.isConnectionEstablished()) {\n      netServer.establishConnection();\n    }\n    if (netServer.isStarted()) return;\n\n    // @A3a\n    // See if the QSERVER subsystem is running.  If it's not running, start it.\n    if (!netServer.isQserverStarted()) {\n      // Attempt to start the QSERVER subsystem.\n      CommandCall cmd = new CommandCall(netServer.getSystem(), \"STRSBS SBSD(QSERVER)\");\n      boolean started = false;\n      try { started = cmd.run(); }\n      catch (Exception e) { throw new ResourceException(e); }\n      if (!started) {\n        Trace.log(Trace.ERROR, \"Error when starting QSERVER subsystem.\");\n        throw new ResourceException(cmd.getMessageList());\n      }\n    }\n\n\n    // Start the NetServer job (QZLSSERVER) on the IBM i system.\n    try {\n      ProgramCallDocument document = (ProgramCallDocument)NetServer.staticDocument_.clone();\n      document.setSystem(netServer.getSystem());\n      document.setValue(\"qzlsstrs.resetQualifier\", (reset ? \"1\" : \"0\"));\n\n      if (document.callProgram(\"qzlsstrs\") == false) {\n        throw new ResourceException(document.getMessageList(\"qzlsstrs\"));\n      }\n\n      // Note: Here is where we would do a fireServerStarted();\n    }\n    catch (PcmlException e) {\n      Trace.log(Trace.ERROR, \"PcmlException when starting the NetServer.\", e);\n      throw new ResourceException(e);\n    }\n  }\n\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 85,
                        "lineEnd": 135,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to com.ibm.as400.access.NetServer\nRationale: The method 'start2' directly interacts with the NetServer instance, checking its connection and state, and is responsible for starting the NetServer job. It logically belongs to the NetServer class as it operates on its properties and methods.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 4822
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "start2",
                            "method_signature": "public void start2(NetServer netServer, boolean reset) throws ResourceException",
                            "target_class": "NetServerManager",
                            "rationale": "The start2() method is responsible for starting the NetServer job and managing its state, which is more aligned with the responsibilities of a NetServerManager class rather than the IntegerValueMap class."
                        }
                    ],
                    "llm_response_time": 1672
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "start2",
                            "method_signature": "public void start2(NetServer netServer, boolean reset) throws ResourceException",
                            "target_class": "NetServerManager",
                            "rationale": "The start2() method is responsible for starting the NetServer job and managing its state, which is more aligned with the responsibilities of a NetServerManager class rather than the IntegerValueMap class."
                        }
                    ],
                    "llm_response_time": 1260
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "start2",
                            "method_signature": "public void start2(NetServer netServer, boolean reset) throws ResourceException",
                            "target_class": "NetServerManager",
                            "rationale": "The start2() method is responsible for starting the NetServer job and managing its state, which is more aligned with the responsibilities of a NetServerManager class rather than the IntegerValueMap class."
                        }
                    ],
                    "llm_response_time": 1144
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "start2",
                            "method_signature": "public void start2(NetServer netServer, boolean reset) throws ResourceException",
                            "target_class": "NetServerManager",
                            "rationale": "The start2() method is responsible for starting the NetServer job and managing its state, which is more aligned with the responsibilities of a NetServerManager class rather than the IntegerValueMap class."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "start2"
                ],
                "llm_response_time": 652
            },
            "targetClassMap": {
                "start2": {
                    "target_classes": [
                        {
                            "class_name": "NetServer",
                            "similarity_score": 0.7241166673457953
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "NetServer"
                    ],
                    "llm_response_time": 1577,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.vaccess.SQLResultSetTableModel::readObject(java.io.ObjectInputStream):void need move com.ibm.as400.vaccess.SQLResultSetTablePane",
        "class_name": "com.ibm.as400.vaccess.SQLResultSetTableModel",
        "telemetry": {
            "id": "bb3181f8-e21b-4fb4-b198-0995bd1f6ecc",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1299,
                "lineStart": 38,
                "lineEnd": 1336,
                "bodyLineStart": 38,
                "language": "java",
                "sourceCode": "/**\nThe SQLResultSetTableModel class represents the data in a JDBC\nresult set generated by an SQL query.  This class implements the\nunderlying model for a table in a graphical user interface.\nUse this class if you want to customize the graphical user interface\nthat presents a table.  If you do not need to customize the graphical user\ninterface, then use <a href=\"SQLResultSetTablePane.html\">\nSQLResultSetTablePane</a> instead.\n\n<p>You must specify an <a href=\"SQLConnection.html\">\nSQLConnection</a> object and SQL query string to use for generating\nthe data.  Alternately, you can specify a ResultSet object directly.\nIf you specify a ResultSet object, it will override any SQLConnection\nor SQL query previously set.  In addition, if you specify a ResultSet,\nthis class will use memory more efficiently if you create the ResultSet as scrollable.\n\n<p>You must explicitly call <a href=\"#load()\">load()</a> to load the information\nfrom the result set.  The model will be empty until load() is called.\nIf the query or result set includes updatable columns, then the respective\ncolumns will be editable.\n\n<p>This class assumes that the necessary JDBC driver(s) are already registered.\n\n<p>Call <a href=\"#close()\">close()</a> to ensure that the result set\nis closed when this table is no longer needed.\n\n<p>Most errors are reported as <a href=\"ErrorEvent.html\">ErrorEvent</a>s\nrather than throwing exceptions.  Listen for ErrorEvents in order to diagnose and recover\nfrom error conditions.\n\n<p>SQLResultSetTableModel objects generate the following events:\n<ul>\n  <li>ErrorEvent\n  <li>PropertyChangeEvent\n  <li>TableModelEvent\n  <li>WorkingEvent\n</ul>\n\n<p>This example creates an SQLResultSetTableModel using an SQLConnection\nand query and displays it using a JTable:\n\n<pre>\n// Register the IBM Toolbox for Java JDBC driver.\nDriverManager.registerDriver(new com.ibm.as400.access.AS400JDBCDriver());\n<br>\n// Create the SQLResultSetTableModel object.\nSQLConnection connection = new SQLConnection(\"jdbc:as400://MySystem\", \"Userid\", \"Password\");\nString query = \"SELECT * FROM MYLIB.MYTABLE\";\nSQLResultSetTableModel model = new SQLResultSetTableModel(connection, query);\n<br>\n// Create the enclosing JTable and put it in a JFrame.\nJTable table = new JTable(model);\nJFrame frame = new JFrame(\"My Window\");\nframe.getContentPane().add(new JScrollPane(table));\n<br>\n// Set up the error dialog adapter.\nmodel.addErrorListener(new ErrorDialogAdapter(frame));\n<br>\n// Display the JFrame.\nframe.pack();\nframe.show();\n<br>\n// Load the contents of the model.\nmodel.load();\n</pre>\n\n<p>This example creates an SQLResultSetTableModel using a ResultSet\nand displays it using a JTable:\n\n<pre>\n// Register the IBM Toolbox for Java JDBC driver.\nDriverManager.registerDriver(new com.ibm.as400.access.AS400JDBCDriver());\n<br>\n// Use JDBC to execute the SQL query directly.\nConnection connection = DriverManager.getConnection(\"MySystem\", \"Userid\", \"Password\");\nStatement statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\nResultSet rs = statement.executeQuery(\"SELECT * FROM MYLIB.MYTABLE\");\n<br>\n// Create the SQLResultSetTableModel object.\nSQLResultSetTableModel model = new SQLResultSetTableModel(rs);\n<br>\n// Create the enclosing JTable and put it in a JFrame.\nJTable table = new JTable(model);\nJFrame frame = new JFrame(\"My Window\");\nframe.getContentPane().add(new JScrollPane(table));\n<br>\n// Set up the error dialog adapter.\nmodel.addErrorListener(new ErrorDialogAdapter(frame));\n<br>\n// Display the JFrame.\nframe.pack();\nframe.show();\n<br>\n// Load the contents of the model.\nmodel.load();\n</pre>\n@deprecated Use Java Swing instead, along with the classes in package <tt>com.ibm.as400.access</tt>\n**/\n//\n// Implementation notes:\n//\n// *  Note that this class throws error and working events from within\n//    synchronized blocks, which could cause hangs if the listeners for\n//    these events do operations from a different thread an attempt to\n//    access another synchronized piece of code.\n//\n//    At this time this seems to be an acceptable risk, since the\n//    events thrown are not likely to need enough processing to\n//    require another thread, and getting having the events thrown\n//    from outside a sychronized block would be nearly impossible.\n//    The other option is to have the firing of the events be done\n//    from another thread, but the overhead of creating another thread\n//    not only takes resources, but also delays the delivery of the event.\n//\n// *  We do two sets of synchronization.  The internalMonitor_\n//    synchronization prevents data corrruption when multiple threads\n//    are accessing the same SQLResultSetTableModel object.\n//    The resultSet_ synchronization prevents data corruption when\n//    multiple SQLResultSetTableModels are accessing the same\n//    ResultSet object.\n//\n// *  The variables which have private commented out had to made\n//    package scope since currently Internet Explorer does not\n//    allow inner class to access private variables in their\n//    containing class.\n//\npublic class SQLResultSetTableModel\n    extends AbstractTableModel\n    implements Serializable\n{\n  private static final String copyright = \"Copyright (C) 1997-2001 International Business Machines Corporation and others.\";\n\n\n\n  // Private data.\n  private boolean                         cacheAll_               = false;\n  private SQLConnection                   sqlConnection_          = null;\n  private String                          query_                  = null;\n  private ResultSet                       explicitResultSet_      = null;\n\n  private transient Vector                cachedRows_;\n  private transient int                   cachedRowCount_;\n  private transient int                   columnCount_;\n  private transient boolean               error_;\n  private transient int                   firstCachedRow_;\n  private transient Object                internalMonitor_;\n  private transient int                   lastCachedRow_;\n  private transient ResultSet             resultSet_;\n  private transient ResultSetMetaData     resultSetMetaData_;\n  private transient int                   rowCount_;\n  private transient boolean               rowCountComplete_;\n  private transient boolean               scrollable_;\n  private transient Statement             statement_;\n  private transient boolean               updatable_;\n\n  private transient JTable                table_;    /* Keep a reference to the table so we can maintain selection information @B6A*/ \n  private static final int                CACHE_SIZE_             = 500;  // In rows.\n  private static final int                READ_INCREMENT_         = 50;   // In rows.\n\n\n\n  // Event support.\n  private transient PropertyChangeSupport     propertyChangeSupport_;\n  private transient VetoableChangeSupport     vetoableChangeSupport_;\n  private transient ErrorEventSupport         errorEventSupport_;\n  private transient WorkingEventSupport       workingEventSupport_;\n\n\n\n  /**\n  Constructs a SQLResultSetTableModel object.\n  **/\n  public SQLResultSetTableModel()\n  {\n    super();\n    initializeTransient();\n  }\n\n\n\n  /**\n  Constructs a SQLResultSetTableModel object.\n  \n  @param connection     The SQL connection.\n  @param query          The SQL query.\n  **/\n  public SQLResultSetTableModel(SQLConnection connection, String query)\n  {\n    super();\n    if(connection == null)\n      throw new NullPointerException(\"connection\");\n    if(query == null)\n      throw new NullPointerException(\"query\");\n\n    sqlConnection_ = connection;\n    query_ = query;\n\n    initializeTransient();\n  }\n\n\n\n  // @D0A\n  /**\n  Constructs a SQLResultSetTableModel object.\n  \n  @param resultSet  The SQL result set.\n  @param cacheAll   true to cache the entire result set when <a href=\"#load()\">load()</a>\n                    is called, false to cache parts of the result set as they are\n                    needed.  Passing true may result in slow initial presentation of\n                    the data.  However, it may be necessary to pass true if the result\n                    set is expected to close when the model is still needed.\n  **/\n  public SQLResultSetTableModel(ResultSet resultSet, boolean cacheAll)\n  {\n    super();\n    if(resultSet == null)\n      throw new NullPointerException(\"resultSet\");\n\n    explicitResultSet_ = resultSet;\n    cacheAll_ = cacheAll;\n\n    initializeTransient();\n  }\n\n\n\n  /**\n  Adds a listener to be notified when an error occurs.\n  \n  @param  listener    The listener.\n  **/\n  public void addErrorListener(ErrorListener listener)\n  {\n    errorEventSupport_.addErrorListener(listener);\n  }\n\n\n\n  /**\n  Adds a listener to be notified when the value of any\n  bound property changes.\n  \n  @param  listener  The listener.\n  **/\n  public void addPropertyChangeListener(PropertyChangeListener listener)\n  {\n    propertyChangeSupport_.addPropertyChangeListener(listener);\n  }\n\n\n\n  /**\n  Adds a listener to be notified when the value of any\n  constrained property changes.\n  \n  @param  listener  The listener.\n  **/\n  public void addVetoableChangeListener(VetoableChangeListener listener)\n  {\n    vetoableChangeSupport_.addVetoableChangeListener(listener);\n  }\n\n\n\n  /**\n  Adds a listener to be notified when work starts and stops\n  on potentially long-running operations.\n  \n  @param  listener  The listener.\n  **/\n  public void addWorkingListener(WorkingListener listener)\n  {\n    workingEventSupport_.addWorkingListener(listener);\n  }\n\n\n\n  /**\n  Clears all SQL warnings.\n  **/\n  public void clearWarnings()\n  {\n    try\n    {\n      if(resultSet_ != null)\n        resultSet_.clearWarnings();\n      if(statement_ != null)\n        statement_.clearWarnings();\n    }\n    catch(SQLException e)\n    {\n      markError(e);\n    }\n  }\n\n\n\n  /**\n  Closes the result set.\n  **/\n  public void close()\n  {\n    try\n    {\n      if(resultSet_ != null)\n      {\n        resultSet_.close();\n        resultSet_ = null;\n      }\n    }\n    catch(SQLException e)\n    {\n      markError(e);\n    }\n\n    try\n    {\n      if(statement_ != null)\n      {\n        statement_.close();\n        statement_ = null;\n      }\n    }\n    catch(SQLException e)\n    {\n      markError(e);\n    }\n  }\n\n\n\n  /**\n  Returns the class of the values in the column.\n  \n  @param columnIndex The column index (0-based).\n  @return            The class of the column values, or null\n                     if an error occurs.\n  **/\n  public Class getColumnClass(int columnIndex)\n  {\n    // Returning Object seems to be sufficient.\n    return Object.class;\n  }\n\n\n\n  /**\n  Returns the number of columns in the table.\n  \n  @return The number of columns in the table, or 0\n          if an error occurs.\n  **/\n  public int getColumnCount()\n  {\n    synchronized(internalMonitor_)\n    {\n      Trace.log(Trace.DIAGNOSTIC, \"SQLResultSetTableModel.getColumnCount() = \" + columnCount_);\n      return columnCount_;\n    }\n  }\n\n\n\n  /**\n  Returns the column identifier.  This corresponds to the\n  field name in the database.\n  \n  @param columnIndex  The column index (0-based).\n  @return             The column identifier, or null\n                      if an error occurs.\n  **/\n  public String getColumnID(int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return null;\n      if(resultSet_ == null)\n        return null;\n\n      try\n      {\n        return resultSetMetaData_.getColumnName(columnIndex+1);\n      }\n      catch(SQLException e)\n      {\n        markError(e);\n        return null;\n      }\n    }\n  }\n\n\n\n  /**\n  Returns the column name.  This corresponds to the column\n  label in the database.\n  \n  @param columnIndex  The column index (0-based).\n  @return             The column name, or null\n                      if an error occurs.\n  **/\n  public String getColumnName(int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return null;\n      if(resultSet_ == null)\n        return null;\n\n      try\n      {\n        String col = resultSetMetaData_.getColumnLabel(columnIndex+1);        //@pdc extended metadata\n        //columnLabel is a concatonation of up to three columns (each 20 length) with the 20 length padded with spaces\n        int colLength = col.length();          //@pda extended metadata\n        if( colLength > 20)                    //@pda  \n        {                                      //@pda  \n            \n            if( colLength > 40)                        //@pda  \n            {                                          //@pda  \n                //contains three column concats\n                String space1 = col.substring(19,20).equals(\" \") ? \" \" : \"\";  //column separator\n                String space2 = col.substring(39,40).equals(\" \") ? \" \" : \"\";  //column separator\n                col = col.substring(0, 20).trim() + space1 + col.substring(20, 40).trim() + space2 + col.substring(40).trim();    //@pda  \n            }                                          //@pda  \n            else                                       //@pda  \n            {                                          //@pda  \n                //contains two column concats\n                String space1 = col.substring(19,20).equals(\" \") ? \" \" : \"\";  //column separator\n                col = col.substring(0, 20).trim() + space1 + col.substring(20).trim();  //@pda  \n            }                                         //@pda  \n        }                                             //@pda  \n        return col;                                   //@pda  \n      }\n      catch(SQLException e)\n      {\n        markError(e);\n        return null;\n      }\n    }\n  }\n\n\n\n  /**\n  Returns the column type.\n  \n  @param columnIndex  The column index (0-based).\n  @return             The column type, or 0 if an error occurs.\n  **/\n  public int getColumnType(int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return 0;\n      if(resultSet_ == null)\n        return 0;\n\n      try\n      {\n        return resultSetMetaData_.getColumnType(columnIndex+1);\n      }\n      catch(SQLException e)\n      {\n        markError(e);\n        return 0;\n      }\n    }\n  }\n\n\n\n  /**\n  Returns the column width.\n  \n  @param columnIndex  The column index (0-based).\n  @return             The column width, in characters, or 0 if an error occurs.\n  **/\n  public int getColumnWidth(int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return 0;\n      if(resultSet_ == null)\n        return 0;\n\n      try\n      {\n        /* @D3D\n        // For most types, we just consult with JDBC.  However, for times, dates, and\n        // timestamps, JDBC reports the display size for the server format.  And these\n        // GUIs actually internationalize the Strings before displaying them.  So for\n        // these types, we need to compute our own display sizes.\n        switch(resultSetMetaData_.getColumnType(columnIndex+1)) {\n        case Types.TIME:\n            return DBDateCellRenderer.getDisplaySize(DBDateCellRenderer.FORMAT_TIME);\n        case Types.DATE:\n            return DBDateCellRenderer.getDisplaySize(DBDateCellRenderer.FORMAT_DATE);\n        case Types.TIMESTAMP:\n            return DBDateCellRenderer.getDisplaySize(DBDateCellRenderer.FORMAT_TIMESTAMP);\n        default:\n        */\n        return Math.min(resultSetMetaData_.getColumnDisplaySize(columnIndex+1), 50);\n        // @D3D }\n      }\n      catch(SQLException e)\n      {\n        markError(e);\n        return 0;\n      }\n    }\n  }\n\n\n\n  /**\n  Returns the SQL connection.\n  \n  @return The SQL connection.\n  **/\n  public SQLConnection getConnection()\n  {\n    return sqlConnection_;\n  }\n\n\n\n  /**\n  Returns the SQL query.\n  \n  @return The SQL query.\n  **/\n  public String getQuery()\n  {\n    return(query_ == null) ? \"\" : query_;\n  }\n\n\n\n  // @D0A\n  /**\n  Returns the SQL result set.\n  \n  @return The SQL result set.\n  **/\n  public ResultSet getResultSet()\n  {\n    return explicitResultSet_;\n  }\n\n\n\n  /**\n  Returns the number of rows in the table.\n  Because of incremental data retrieval, this value may\n  not be accurate.\n  \n  @return The number of rows in the table.\n  **/\n  public int getRowCount()\n  {\n    if(resultSet_ == null)\n      return 0;\n\n    // If we are not complete, report 2 more than actually here.\n    // This will trick JTable into continuing to ask for more.\n    int reportedRowCount = rowCount_;\n    if(!rowCountComplete_)\n      reportedRowCount += 2;\n\n    // This should not be in a synchronized block, otherwise\n    // a hang may occur.\n    Trace.log(Trace.DIAGNOSTIC, \"SQLResultSetTableModel.getRowCount() = \" + reportedRowCount + \"(actually \" + rowCount_ + \")\");\n    return reportedRowCount;\n  }\n\n\n\n  // @D4A\n  private Object getSingleValue(int columnIndex) throws SQLException\n  {\n    int type = resultSetMetaData_.getColumnType(columnIndex);\n    if(type == Types.BINARY\n       || type == Types.VARBINARY\n       || type == Types.LONGVARBINARY)\n    {\n      return resultSet_.getBytes(columnIndex);\n    }\n    else\n    {\n      // Use getString() so that dates and times get converted to strings\n      // by the JDBC driver so that their formats reflect the settings\n      // in the data source.\n      //@KKB return resultSet_.getString(columnIndex);\n      String s = resultSet_.getString(columnIndex);     //@KKB\n      if(checkDataMappingWarning(resultSet_, columnIndex))           //@KKB\n          s=\"++++++++++++++\";                           //@KKB\n      return s;                                         //@KKB\n    }\n  }\n\n\n\n  /**\n  Returns the value at the specifed row and column.\n  \n  @param rowIndex       The row index (0-based).\n  @param columnIndex    The column index (0-based).\n  \n  @return The value at the specified row and column.\n  **/\n  public Object getValueAt(int rowIndex, int columnIndex)\n  {\n    int oldRowCount;\n    int newRowCount;\n    Object[] row = null;\n\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return null;\n      if(rowIndex < 0)\n        return null;\n      if((rowCountComplete_) && (rowIndex >= rowCount_))\n        return null;\n      if(resultSet_ == null)\n        return null;\n\n      oldRowCount = rowCount_;\n\n      // Case 1: If this row is in the cache, just read it from there.\n      // If cacheAll_ is set, then this case should always occur.\n      if((rowIndex >= firstCachedRow_) && (rowIndex <= lastCachedRow_))\n      {\n        row = (Object[])cachedRows_.elementAt(rowIndex - firstCachedRow_);\n      }\n\n      // Case 2: If this row comes before whats in the cache, read the rows\n      // and move the cache window up in the result set.  This will only\n      // occur if the result set is scrollable - if it is not, then the\n      // cache always includes everything read so far.\n      else if((rowIndex < firstCachedRow_) && (error_ == false))\n      {\n        workingEventSupport_.fireStartWorking();\n        for(int i = firstCachedRow_ - 1; i >= rowIndex; --i)\n        {\n          try\n          {\n            row = new Object[columnCount_];\n            synchronized(resultSet_)\n            {\n\n              // If we are just reading the next row since the last\n              // time, it can be significantly faster to call next().\n              // This is especially true when using the Toolbox\n              // JDBC driver since it does record blocking only\n              // when using next().\n              //\n              // I tried keeping the last read row locally, but it\n              // messes things up when result sets are shared\n              // between multiple models.\n              //\n              if(i == resultSet_.getRow())\n                resultSet_.next();\n              else\n                resultSet_.absolute(i+1);\n\n              // Store the contents of the row.\n              for(int j = 0; j < columnCount_; ++j)\n                row[j] = getSingleValue(j+1); // @D4C\n            }\n            cachedRows_.insertElementAt(row, 0);\n            --firstCachedRow_;\n            if(++cachedRowCount_ > CACHE_SIZE_)\n            {\n              cachedRows_.removeElementAt(--cachedRowCount_);\n              --lastCachedRow_;\n            }\n          }\n          catch(SQLException e)\n          {\n            markError(e);\n          }\n        }\n        workingEventSupport_.fireStopWorking();\n      }\n\n      // Case 3: If this row comes after whats in the cache, read the rows\n      // and move the cache window down in the result set.  If we do not\n      // know the final row count, then jump a little bit ahead to discover\n      // this.\n      else if((rowIndex > lastCachedRow_) && (error_ == false))\n      {\n\n        // Determine how far to go.  If we are not complete yet, push it\n        // ahead to force the table to read even further.\n        int endPoint = rowIndex;\n        if(!rowCountComplete_)\n          endPoint = rowIndex + READ_INCREMENT_;\n\n        // Loop through the rows, quit if we get to the end.\n        workingEventSupport_.fireStartWorking();\n        boolean valid = true;\n        for(int i = lastCachedRow_ + 1; (i <= endPoint) && (valid); ++i)\n        {\n          try\n          {\n            synchronized(resultSet_)\n            {\n\n              // If we are just reading the next row since the last\n              // time, it can be significantly faster to call next().\n              // This is especially true when using the Toolbox\n              // JDBC driver since it does record blocking only\n              // when using next().   We also take this route if\n              // the result set is not scrollable.\n              if((i == resultSet_.getRow()) || (!scrollable_))\n                valid = resultSet_.next();\n              else\n                valid = resultSet_.absolute(i+1);\n\n              // If this is a valid row, then add it to the cache.\n              if(valid)\n              {\n                Object[] tempRow = new Object[columnCount_];\n                for(int j = 0; j < columnCount_; ++j)\n                  tempRow[j] = getSingleValue(j+1); // @D4C\n                if(i == rowIndex)\n                  row = tempRow;\n                cachedRows_.insertElementAt(tempRow, cachedRowCount_++);\n                ++lastCachedRow_;\n                if((scrollable_) && (cachedRowCount_ > CACHE_SIZE_))\n                {\n                  cachedRows_.removeElementAt(0);\n                  cachedRowCount_--;\n                  ++firstCachedRow_;\n                }\n\n                // If this is greater than our current count, add record it.\n                if((!rowCountComplete_) && (i >= rowCount_))\n                  rowCount_ = i;\n              }\n\n              // If this is not a valid row, then mark the row count as\n              // complete.\n              else if(!rowCountComplete_)\n              {\n                rowCountComplete_ = true;\n                rowCount_ = i;\n              }\n            }\n          }\n          catch(SQLException e)\n          {\n            markError(e);\n          }\n        }\n        workingEventSupport_.fireStopWorking();\n      }\n\n      // If the row count changed, record the change so we can fire the table\n      // model event (outside of the synchronized block).\n      newRowCount = rowCount_;\n    }\n\n    // If the row count changed, fire the table model event.  If we are\n    // not complete, then add 2 to keep the JTable asking for more.\n    if(oldRowCount != newRowCount)\n    {\n      // In JDK 1.5 and 1.6, there is a problem with the selection in the JTable being cleared. \n      // This causes problems if the user is using the page down key to scroll through the results.\n      //\n      // The call to fireTableRowsInserted may be the code that is clearing the selection.  \n      // For a similar problem see:  http://stackoverflow.com/questions/254212/preserve-jtable-selection-across-tablemodel-change\n      // I tried setting the first parameter to oldRowCount+1 to see if that fixes the problem.\t\n      // That did not fix the problem.  The row at the bottom retains it's highlight, but the next\n      // PageDown jumps to the top of the area. \n      // \n      // Instead we need to remember the selected rows and restore them after. \n      // For now, we'll only handle the simple case where a single cell is selected. \n      //\n      // We also only want to change the selection if the selected row has changed after  \n      // fireTableRowsInserted.  In the case where the use of the scroll bar causes new\n      // entries to be loaded, the selectedRow does not change, so we do not need to \n      // change the selection back to their original values. \n      //\n      // @B6A \n      \n      \n      int  selectedRow = -1; \n      if (table_ != null)   selectedRow = table_.getSelectedRow();\n      int selectedColumn = -1; \n      if (table_ != null)   selectedColumn = table_.getSelectedColumn(); \n      \n      fireTableRowsInserted(oldRowCount, getRowCount());\n      \n      \n      \n      // Restore the selected cell.  @B6A \n     int  afterSelectedRow = -1 ; \n     if (table_ != null)\tafterSelectedRow = table_.getSelectedRow();\n      if ((selectedRow >= 0 && selectedColumn >= 0 ) && \n    \t\t  ((afterSelectedRow != selectedRow) )) {\n      table_.changeSelection(selectedRow, selectedColumn, false /* toggle */ , false /* extend */); \n\t  \n      }\n    }\n\n    // Return the value.\n    if(row == null)\n      return null;\n    else\n      return row[columnIndex];\n  }\n\n\n\n  /**\n  Returns the SQL warnings.\n  \n  @return The SQL warnings.\n  **/\n  public SQLWarning getWarnings()\n  {\n    SQLWarning warnings = null;\n    try\n    {\n      if(resultSet_ != null)\n        warnings = resultSet_.getWarnings();\n      if(statement_ != null)\n      {\n        if(warnings == null)\n          warnings = statement_.getWarnings();\n        else\n          warnings.setNextWarning(statement_.getWarnings());\n      }\n    }\n    catch(SQLException e)\n    {\n      markError(e);\n    }\n    return warnings;\n  }\n\n\n\n  /**\n  Initializes the common data.\n  **/\n  private void initializeCommon()\n  {\n    synchronized(internalMonitor_)\n    {\n      cachedRows_             = new Vector(CACHE_SIZE_);\n      cachedRowCount_         = 0;\n      columnCount_            = 0;\n      error_                  = false;\n      firstCachedRow_         = 0;\n      lastCachedRow_          = -1;\n      rowCount_               = 0;\n      rowCountComplete_       = false;\n    }\n  }\n\n\n\n  /**\n  Initializes the transient data.\n  **/\n  private void initializeTransient()\n  {\n    internalMonitor_                = new Object();\n\n    initializeCommon();\n\n    // Event support.\n    propertyChangeSupport_          = new PropertyChangeSupport(this);\n    vetoableChangeSupport_          = new VetoableChangeSupport(this);\n    errorEventSupport_              = new ErrorEventSupport(this);\n    workingEventSupport_            = new WorkingEventSupport(this);\n  }\n\n\n  //@D6A\n  /**\n   * Used by SQLResultSetTablePane to determine whether or not the default\n   * cell editor should be replaced.\n  **/\n  boolean isUpdatable()\n  {\n    return updatable_;\n  }\n\n\n  // @D2A\n  /**\n  Indicates if the cell is editable.\n  \n  @param rowIndex         The row index (0-based).\n  @param columnIndex      The column index (0-based).\n  @return                 true if the cell is editable, false otherwise\n                          or if an error occurs.\n  **/\n  public boolean isCellEditable(int rowIndex, int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return false;\n      if(rowIndex < 0)\n        return false;\n      if((rowCountComplete_) && (rowIndex >= rowCount_))\n        return false;\n      if(resultSet_ == null)\n        return false;\n\n      //@D6D            try {\n      //@D6D                return (updatable_ && resultSetMetaData_.isWritable(columnIndex+1));\n      //@D6D            }\n      //@D6D            catch(SQLException e) {\n      //@D6D                markError(e);\n      //@D6D                return false;\n      //@D6D            }\n      return true; //@D6A\n    }\n  }\n\n\n\n  /**\n  Loads the data in the table.\n  **/\n  public void load()\n  {\n    Trace.log(Trace.DIAGNOSTIC, \"SQLResultSetTableModel.load()\");\n    workingEventSupport_.fireStartWorking();\n\n    // Make sure we have enough data to load.\n    if(explicitResultSet_ == null)\n    {\n      if(sqlConnection_ == null)\n        throw new IllegalStateException(\"connection\");\n      if(query_ == null)\n        throw new IllegalStateException(\"query\");\n    }\n\n    synchronized(internalMonitor_)\n    {\n\n      // Clear the old data.\n      initializeCommon();\n\n      // Load the new data.\n      try\n      {\n        if(explicitResultSet_ == null)\n        {\n          if(statement_ == null)\n          {\n            Connection connection = sqlConnection_.getConnection();\n            statement_ = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n          }\n\n          resultSet_ = statement_.executeQuery(query_);\n        }\n        else\n          resultSet_ = explicitResultSet_;\n\n        scrollable_ = (resultSet_.getType() != ResultSet.TYPE_FORWARD_ONLY);\n        updatable_ = (resultSet_.getConcurrency() == ResultSet.CONCUR_UPDATABLE);  // @D2A\n        resultSetMetaData_ = resultSet_.getMetaData();\n        columnCount_ = resultSetMetaData_.getColumnCount();\n\n        if(Trace.isTraceOn())\n        {\n          Trace.log(Trace.DIAGNOSTIC, \"SQLResultSetTableModel-scrollable? \" + scrollable_);\n          Trace.log(Trace.DIAGNOSTIC, \"SQLResultSetTableModel-updatable? \" + updatable_); // @D2A\n        }\n\n        //@KBD removed since a stored procedure may or may not return a scrollable cursor\n        // if the user specified ResultSet.TYPE_SCROLL_SENSITIVE or ResultSet.TYPE_SCROLL_INSENSITVE\n        //@KBD if(scrollable_)\n        //@KBD {\n        //@KBD     resultSet_.beforeFirst();\n        //@KBD }\n      }\n      catch(SQLException e)\n      {\n        markError(e);\n        rowCountComplete_ = true;\n      }\n\n      // If we are supposed to, then cache all.\n      if(cacheAll_)\n      {\n        try\n        {\n          while(resultSet_.next())\n          {\n            Object[] tempRow = new Object[columnCount_];\n            for(int j = 0; j < columnCount_; ++j)\n              tempRow[j] = getSingleValue(j+1); // @D4C\n            cachedRows_.addElement(tempRow);\n          }\n        }\n        catch(SQLException e)\n        {\n          markError(e);\n        }\n        lastCachedRow_ = cachedRows_.size();\n        rowCount_ = lastCachedRow_;\n        rowCountComplete_ = true;\n      }\n\n      // Otherwise, try to read 1 row.  This will handle the case where there are no rows.\n      else\n      {\n        getValueAt(0, 0);\n      }\n    }\n\n    // Tell the JTable that we've changed.\n    fireTableStructureChanged();\n\n    workingEventSupport_.fireStopWorking();\n  }\n\n\n\n  /**\n  Marks that an error has occurred.\n  **/\n  private void markError(Exception e)\n  {\n    if(Trace.isTraceOn())\n      Trace.log(Trace.ERROR, \"Error gathering SQLResultSetTableModel data\", e);\n\n    // Only fire if this is the first error.  That way, we don't\n    // barrage the poor user.\n    if(!error_)\n    {\n      error_ = true;\n      errorEventSupport_.fireError(e);\n    }\n  }\n\n\n\n  /**\n  Restores the state of the object from an input stream.\n  This is used when deserializing an object.\n  \n  @param in   The input stream.\n  **/\n  private void readObject(ObjectInputStream in)\n  throws IOException, ClassNotFoundException\n  {\n    in.defaultReadObject();\n    initializeTransient();\n  }\n\n\n\n  /**\n  Removes an error listener.\n  \n  @param  listener    The listener.\n  **/\n  public void removeErrorListener(ErrorListener listener)\n  {\n    errorEventSupport_.removeErrorListener(listener);\n  }\n\n\n\n  /**\n  Removes a property change listener.\n  \n  @param  listener  The listener.\n  **/\n  public void removePropertyChangeListener(PropertyChangeListener listener)\n  {\n    propertyChangeSupport_.removePropertyChangeListener(listener);\n  }\n\n\n\n  /**\n  Removes a vetoable change listener.\n  \n  @param  listener  The listener.\n  **/\n  public void removeVetoableChangeListener(VetoableChangeListener listener)\n  {\n    vetoableChangeSupport_.removeVetoableChangeListener(listener);\n  }                                                    \n\n\n\n  /**\n  Removes a working listener.\n  \n  @param  listener  The listener.\n  **/\n  public void removeWorkingListener(WorkingListener listener)\n  {\n    workingEventSupport_.removeWorkingListener(listener);\n  }\n\n\n\n  /**\n  Sets the SQL connection.\n  The data will not change until <a href=\"#load()\">load()</a> is called.\n  \n  @param       connection              The SQL connection.\n  \n  @exception  PropertyVetoException   If the change is vetoed.\n  **/\n  public void setConnection(SQLConnection connection)\n  throws PropertyVetoException\n  {\n    if(connection == null)\n      throw new NullPointerException(\"connection\");\n\n    SQLConnection oldValue = sqlConnection_;\n    vetoableChangeSupport_.fireVetoableChange(\"connection\", oldValue, connection);\n    sqlConnection_ = connection;\n    statement_ = null;\n    propertyChangeSupport_.firePropertyChange(\"connection\", oldValue, connection);\n  }\n\n\n\n  /**\n  Sets the SQL query.\n  The data will not change until <a href=\"#load()\">load()</a> is called.\n  \n  @param       query                   The SQL query.\n  \n  @exception  PropertyVetoException   If the change is vetoed.\n  **/\n  public void setQuery(String query)\n  throws PropertyVetoException\n  {\n    if(query == null)\n      throw new NullPointerException(\"query\");\n\n    String oldValue = query_;\n    vetoableChangeSupport_.fireVetoableChange(\"query\", oldValue, query);\n    query_ = query;\n    propertyChangeSupport_.firePropertyChange(\"query\", oldValue, query);\n  }\n\n\n\n  // @D0A\n  /**\n  Sets the SQL result set used to build the table.  If this is set,\n  it is used instead of the SQL connection and SQL query.\n  The data will not change until <a href=\"#load()\">load()</a> is called.\n  \n  @param resultSet        The SQL result set.\n  **/\n  public void setResultSet(ResultSet resultSet)\n  {\n    if(resultSet == null)\n      throw new NullPointerException(\"resultSet\");\n\n    ResultSet oldValue = explicitResultSet_;\n    explicitResultSet_ = resultSet;\n    propertyChangeSupport_.firePropertyChange(\"resultSet\", oldValue, resultSet);\n  }\n\n\n\n  // @D2A\n  /**\n  Sets the value at the specifed row and column.\n  \n  @param value          The value.\n  @param rowIndex       The row index (0-based).\n  @param columnIndex    The column index (0-based).\n  **/\n  public void setValueAt(Object value, int rowIndex, int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return;\n      if(rowIndex < 0)\n        return;\n      if((rowCountComplete_) && (rowIndex >= rowCount_))\n        return;\n      if(resultSet_ == null)\n        return;\n\n      if(!updatable_) return; //@D6A\n\n      if(scrollable_)\n      {\n        try\n        {\n          // Update the value in the result set.\n          synchronized(resultSet_)\n          {\n            resultSet_.absolute(rowIndex+1);\n            resultSet_.updateObject(columnIndex+1, value);\n            resultSet_.updateRow();\n          }\n\n          // Update the value in the cache.\n          ((Object[])cachedRows_.elementAt(rowIndex - firstCachedRow_))[columnIndex] = value;\n        }\n        catch(SQLException e)\n        {\n          // Don't set error_ to true, because that will ruin the whole\n          // model.  Just fire an event and do not update the cache.\n          errorEventSupport_.fireError(e);\n        }\n\n      }\n    }\n  }\n\n  //@KKB - Checks if a Data Mapping Warning was issued\n  private boolean checkDataMappingWarning(ResultSet rs, int columnIndex) throws SQLException{\n      boolean dataMapping = false;\n      SQLWarning w = rs.getWarnings();\n      if(w!=null){\n          do{\n              if(w.getSQLState().equals(\"01004\") && ((java.sql.DataTruncation)w).getDataSize() == -1 && ((java.sql.DataTruncation)w).getTransferSize() == -1 && ((java.sql.DataTruncation)w).getIndex() == columnIndex)\n                  dataMapping = true;\n\n              w=w.getNextWarning();\n          }while(w!=null);\n      }\n\n      return dataMapping;\n  }\n\n  \n  \n/**\n * Set a reference to the JTable so that the selected row can be updated after \n * fireTableRowsInserted. \n * \n * @param table\n */\npublic void setTable(JTable table) {\n\ttable_ = table; \n\t\n}\n\n\n\n/**\n  Restore the state of this object from an object input stream.\n  It is used when deserializing an object.\n  @param sqlResultSetTablePane TODO\n * @param in The input stream of the object being deserialized.\n * @exception IOException\n  @exception ClassNotFoundException\n  **/\n  void readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)\n  throws IOException, ClassNotFoundException\n  {\n    // Restore the non-static and non-transient fields.\n    in.defaultReadObject();\n\n    // Initialize the transient fields.\n    sqlResultSetTablePane.changeListeners_ = new PropertyChangeSupport(sqlResultSetTablePane);\n    addPropertyChangeListener(sqlResultSetTablePane.changeListeners_);\n    sqlResultSetTablePane.vetoListeners_ = new VetoableChangeSupport(sqlResultSetTablePane);\n    addVetoableChangeListener(sqlResultSetTablePane.vetoListeners_);\n    sqlResultSetTablePane.errorListeners_ = new ErrorEventSupport(sqlResultSetTablePane);\n    addErrorListener(sqlResultSetTablePane.errorListeners_);\n    sqlResultSetTablePane.worker_ = new WorkingCursorAdapter(sqlResultSetTablePane);\n    addWorkingListener(sqlResultSetTablePane.worker_);\n    sqlResultSetTablePane.selectionListeners_ = new ListSelectionEventSupport(sqlResultSetTablePane);\n\n    sqlResultSetTablePane.initializeTransient(); //@B0A\n    //@B0D table_.getSelectionModel().addListSelectionListener(selectionListeners_);\n\n    //@B0 - table_ is now transient, so we need to reset its attributes.\n    sqlResultSetTablePane.table_.setGridColor(sqlResultSetTablePane.tableColor_); //@B0A\n    sqlResultSetTablePane.table_.setShowHorizontalLines(sqlResultSetTablePane.tableShowHorizontalLines_); //@B0A\n    sqlResultSetTablePane.table_.setShowVerticalLines(sqlResultSetTablePane.tableShowVerticalLines_); //@B0A\n\n  }\n\n\n  \n  \n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 1297,
                        "lineEnd": 1330,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to com.ibm.as400.vaccess.SQLResultSetTablePane\nRationale: The method readObject2 directly manipulates the fields and properties of the SQLResultSetTablePane instance, indicating that it is closely tied to the state and behavior of this class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 8856
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setTable",
                            "method_signature": "public void setTable(JTable table)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The setTable() method is responsible for setting a reference to a JTable, which is more relevant to the SQLResultSetTablePane class that likely manages the UI components. Moving it there would improve cohesion."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The readObject2() method is specifically designed to restore the state of the SQLResultSetTablePane, making it more appropriate to reside within that class to maintain better encapsulation."
                        }
                    ],
                    "llm_response_time": 2929
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "setTable",
                            "method_signature": "public void setTable(JTable table)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The setTable() method is responsible for setting a reference to a JTable, which is more relevant to the SQLResultSetTablePane class that likely manages the UI components. Moving it there would improve cohesion."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The readObject2() method is specifically designed to restore the state of the SQLResultSetTablePane, making it more appropriate to reside within that class to maintain encapsulation and clarity."
                        }
                    ],
                    "llm_response_time": 2194
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "setTable",
                            "method_signature": "public void setTable(JTable table)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The setTable() method is responsible for setting a reference to a JTable, which is more relevant to the SQLResultSetTablePane class that likely manages the UI components. Moving it there would improve cohesion."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The readObject2() method is specifically designed to restore the state of the SQLResultSetTablePane, making it more appropriate to reside within that class for better encapsulation."
                        }
                    ],
                    "llm_response_time": 2707
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setTable",
                            "method_signature": "public void setTable(JTable table)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The setTable() method is responsible for setting a reference to a JTable, which is more relevant to the SQLResultSetTablePane class that likely manages the UI components. Moving it there would improve cohesion."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The readObject2() method is specifically designed to restore the state of the SQLResultSetTablePane, making it more appropriate to reside within that class to maintain better encapsulation."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "setTable",
                    "readObject2"
                ],
                "llm_response_time": 925
            },
            "targetClassMap": {
                "setTable": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1652,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "readObject2": {
                    "target_classes": [
                        {
                            "class_name": "SQLResultSetTablePane",
                            "similarity_score": 0.568061770869418
                        },
                        {
                            "class_name": "SQLConnection",
                            "similarity_score": 0.5398874302710917
                        },
                        {
                            "class_name": "PropertyChangeSupport",
                            "similarity_score": 0.31285654688986536
                        },
                        {
                            "class_name": "VetoableChangeSupport",
                            "similarity_score": 0.3301593230334562
                        },
                        {
                            "class_name": "ErrorEventSupport",
                            "similarity_score": 0.38034536781567435
                        },
                        {
                            "class_name": "WorkingEventSupport",
                            "similarity_score": 0.3487555464057905
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SQLResultSetTablePane",
                        "PropertyChangeSupport",
                        "VetoableChangeSupport",
                        "ErrorEventSupport",
                        "WorkingEventSupport",
                        "SQLConnection"
                    ],
                    "llm_response_time": 3047,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.access.SpooledFile::applyChanges():void need move com.ibm.as400.vaccess.OutputPropertiesPane",
        "class_name": "com.ibm.as400.access.SpooledFile",
        "telemetry": {
            "id": "060fe944-28f7-407e-ae07-efa464266b0d",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1306,
                "lineStart": 22,
                "lineEnd": 1327,
                "bodyLineStart": 22,
                "language": "java",
                "sourceCode": "/**\n * Represents a spooled file.\n * You can use an instance of this class to manipulate an individual\n * spooled file (hold, release, delete, send, read, and so on).\n * To create new spooled files on the system, use the\n * {@link SpooledFileOutputStream SpooledFileOutputStream} class.\n *\n * See <a href=\"{@docRoot}/com/ibm/as400/access/doc-files/SpooledFileAttrs.html\">Spooled File Attributes</a> for\n * valid attributes.\n *\n * @see PrintObjectInputStream\n * @see PrintObjectPageInputStream\n * @see PrintObjectTransformedInputStream\n **/\n\npublic class SpooledFile extends PrintObject\nimplements java.io.Serializable\n{\n    static final long serialVersionUID = 4L;\n\n    transient boolean fMsgRetrieved_  = false;\n\n    // constructor used internally (not externalized since it takes\n    // an ID code point\n    SpooledFile(AS400 system, NPCPIDSplF id, NPCPAttribute attrs)\n    {\n       super(system, id, attrs, NPConstants.SPOOLED_FILE);\n    }\n\n\n    // We have decide that spooled files are too transient to be JavaBeans.\n\n\n    /**\n     * Constructs a SpooledFile object. It uses the specified system and\n     * spooled file attributes that identify it on that system.\n     *\n     * @param system The system on which this spooled file exists.\n     * @param name The name of the spooled file.\n     * @param number The number of the spooled file.\n     * @param jobName The name of the job that created the spooled file.\n     * @param jobUser The user who created the spooled file.\n     * @param jobNumber The number of the job that created the spooled file.\n     *\n     **/\n    public SpooledFile(AS400 system,\n                       String name,\n                       int    number,\n                       String jobName,\n                       String jobUser,\n                       String jobNumber)\n    {\n        super(system,\n              new NPCPIDSplF(name,\n                             number,\n                             jobName,\n                             jobUser,\n                             jobNumber),\n              null,\n              NPConstants.SPOOLED_FILE);\n\n        // base class constructor checks for null system.\n        if (name == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'name' is null.\");\n            throw new NullPointerException(\"name\");\n        }\n\n        if (number < -1)    // (changed from 1 to -1 to allow 0(=*ONLY) and -1(=*LAST))\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'number' is less than -1.\");\n            throw new ExtendedIllegalArgumentException(\n                \"number(\" + number + \")\",\n                ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        if (jobName == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobName' is null.\");\n            throw new NullPointerException(\"jobName\");\n        }\n\n        if (jobUser == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobUser' is null.\");\n            throw new NullPointerException(\"jobUser\");\n        }\n\n        if (jobNumber == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobNumber' is null.\");\n            throw new NullPointerException(\"jobNumber\");\n        }\n    }\n    \n    // Alternate constructor for spooled files detached from jobs\n    /**\n     * Constructs a SpooledFile object. It uses the specified system and\n     * spooled file attributes that identify it on that system.\n     *\n     * @param system The system on which this spooled file exists.\n     * @param name The name of the spooled file.\n     * @param number The number of the spooled file.\n     * @param jobName The name of the job that created the spooled file.\n     * @param jobUser The user who created the spooled file.\n     * @param jobNumber The number of the job that created the spooled file.\n     * @param jobSysName The name of the system where the spooled file was created.\n     * @param createDate The date the spooled file was created on the system.\n     * <br>\n     * The date is encoded in a character string with the following format,\n     * CYYMMDD where:\n     * <ul>\n     * <li> C is the Century, where 0 indicates years 19xx and 1 indicates years 20xx\n     * <li> YY is the Year\n     * <li> MM is the Month\n     * <li> DD is the Day\n     * </ul>\n     * @param createTime The time the spooled file was created on the system.\n     * <br>\n     * The time is encoded in a character string with the following format,\n     * HHMMSS where:\n     * <ul>\n     * <li> HH - Hour \n     * <li> MM - Minutes \n     * <li> SS - Seconds \n     * </ul>\n     **/\n   \n    public SpooledFile(AS400 system,\n                       String name,\n                       int    number,\n                       String jobName,\n                       String jobUser,\n                       String jobNumber,\n                       String jobSysName,\n                       String createDate,\n                       String createTime)\n    {\n        super(system,\n              new NPCPIDSplF(name,\n                             number,\n                             jobName,\n                             jobUser,\n                             jobNumber,\n                             jobSysName,\n                             createDate,\n                             createTime),\n              null,\n              NPConstants.SPOOLED_FILE);\n\n        // base class constructor checks for null system.\n   \n        if (name == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'name' is null.\");\n            throw new NullPointerException(\"name\");\n        }\n\n        if (number < -1)    // (changed from 1 to -1 to allow 0(=*ONLY) and -1(=*LAST))\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'number' is less than -1.\");\n            throw new ExtendedIllegalArgumentException(\n                \"number(\" + number + \")\",\n                ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        if (jobName == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobName' is null.\");\n            throw new NullPointerException(\"jobName\");\n        }\n\n        if (jobUser == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobUser' is null.\");\n            throw new NullPointerException(\"jobUser\");\n        }\n\n        if (jobNumber == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobNumber' is null.\");\n            throw new NullPointerException(\"jobNumber\");\n        }\n        \n        if (jobSysName == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobSysName' is null.\");\n            throw new NullPointerException(\"jobSysName\");\n        }\n        \n        if (createDate == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'createDate' is null.\");\n            throw new NullPointerException(\"createDate\");\n        }\n        \n        if (createTime == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'createTime' is null.\");\n            throw new NullPointerException(\"createTime\");\n        }\n    }\n\n\n\n    /** Replies to the message that caused the spooled file to wait.\n     *\n     * @param reply The string that contains the reply for the message.\n     *              The default reply can be obtained by calling\n     *              the getMessage() method, and then calling the\n     *              getDefaultReply() method on the message object that is returned.\n     *              Other possible replies are given in the message help,\n     *              which can also be retrieved from the message object returned\n     *              on the getMessage() method.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is\n     *                                            completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                          system is not at the correct level.\n     **/\n    public void answerMessage(String reply)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).answerMessage(reply);\n        // update the spooled file attributes\n        attrs = impl_.getAttrValue();\n        fMsgRetrieved_ = ((SpooledFileImpl) impl_).getFMsgRetrieved();\n    }\n\n\n\n    /**\n     * Chooses the implementation\n     **/\n    void chooseImpl()\n    throws IOException, AS400SecurityException\n    {\n        // We need to get the system to connect to...\n        AS400 system = getSystem();\n        if (system == null) {\n            Trace.log( Trace.ERROR, \"Attempt to use SpooledFile before setting system.\" );\n            throw new ExtendedIllegalStateException(\"system\",\n                                    ExtendedIllegalStateException.PROPERTY_NOT_SET);\n        }\n\n        impl_ = (SpooledFileImpl) system.loadImpl2(\"com.ibm.as400.access.SpooledFileImplRemote\",\n                                                   \"com.ibm.as400.access.SpooledFileImplProxy\");\n        // The connectService(AS400.PRINT) is done in setImpl()\n        // in the Printobject class.\n        super.setImpl();  \n    }\n    \n        \n    \n    /**\n     * Creates a copy of the spooled file this (SpooledFile) object represents.  The\n     * new spooled file is created on the same output queue and on the same system \n     * as the original spooled file. A reference to the new spooled file is returned.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system is not at the correct level.\n     **/\n    public SpooledFile copy()\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        String name = getStringAttribute(ATTR_OUTPUT_QUEUE);\n        OutputQueue outq = new OutputQueue(getSystem(), name);\n        SpooledFile sf = copy(outq);\n        return sf;\n    }\n\n\n\n    /**\n     * Creates a copy of the spooled file this object represents.  The\n     * new spooled file is created on the specified output queue.\n     * A reference to the new spooled file is returned.\n     *\n     * @param outputQueue The output queue location to create the new version of the\n     *       original spooled file.  The spooled file will be created to the first\n     *       position on this output queue.  The output queue and this spooled\n     *       file must reside on the same system.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system is not at the correct level.\n     **/\n    public SpooledFile copy(OutputQueue outputQueue)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        // choose implementations\n        if (impl_ == null) {\n            chooseImpl();\n        }\n        if (outputQueue.getImpl() == null) {     \n            outputQueue.chooseImpl();        \n        }                        \n        \n        NPCPIDSplF spID = \n        ((SpooledFileImpl) impl_).copy((OutputQueueImpl)outputQueue.getImpl()); \n    \t\n        try {\n            spID.setConverter((new Converter(getSystem().getCcsid(), getSystem())).impl);\n        }\n        catch (UnsupportedEncodingException e) {\n            if (Trace.isTraceErrorOn()) {\n                Trace.log(Trace.ERROR, \"Error initializing converter for spooled file.\");\n            }\n        }\n        SpooledFile sf = new SpooledFile(getSystem(), spID, null);\n        return sf;\n    }\n\n\n\n    /**\n      * Deletes the spooled file on the system.\n      *\n      * @exception AS400Exception If the system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      **/\n    public void delete()\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).delete();\n    }\n\n\n    /**\n      * Returns an input stream that can be used to read the contents of the\n      * spooled file.\n      * This method will fail with an AS400Exception if the spooled file is\n      * still being created (ATTR_SPLFSTATUS is *OPEN).\n      * Note that the bytes are returned untransformed, that is, as they are\n      * stored on the server.  To transform the bytes into other forms, use\n      * {@link #getPageInputStream getPageInputStream} or\n      * {@link #getTransformedInputStream getTransformedInputStream}.\n      *\n      * @return The input stream object that can be used to read the contents\n      *         of this spooled file.\n      * @exception AS400Exception If system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception RequestNotSupportedException If the requested function is not supported\n      *                                         because the system is not at the\n      *                                         correct level.\n      * @see #getPageInputStream\n      * @see #getTransformedInputStream\n      **/\n    public PrintObjectInputStream getInputStream()\n        throws AS400Exception,\n               AS400SecurityException,\n               ErrorCompletingRequestException,\n               IOException,\n               InterruptedException,\n               RequestNotSupportedException\n    {\n        PrintObjectInputStream is = new PrintObjectInputStream(this, null);\n        return is;\n    }\n\n\n    /**\n      * Returns an input stream that can be used to read the contents of the\n      * spooled file.\n      * This method will fail with an AS400Exception if the spooled file is\n      * still being created (ATTR_SPLFSTATUS is *OPEN).\n      * Note that the bytes are returned untransformed, that is, as they are\n      * stored on the server.  To transform the bytes into other forms, use\n      * {@link #getPageInputStream getPageInputStream} or\n      * {@link #getTransformedInputStream getTransformedInputStream}.\n      *\n      * @return The input stream object that can be used to read the contents\n      *         of this spooled file.\n      * @exception AS400Exception If system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception RequestNotSupportedException If the requested function is not supported\n      *                                         because the system is not at the\n      *                                         correct level.\n      * @see #getPageInputStream\n      * @see #getTransformedInputStream\n      **/\n    public PrintObjectInputStream getInputStream(PrintParameterList ppl)\n        throws AS400Exception,\n               AS400SecurityException,\n               ErrorCompletingRequestException,\n               IOException,\n               InterruptedException,\n               RequestNotSupportedException\n    {\n        PrintObjectInputStream is = new PrintObjectInputStream(this, ppl);\n        return(is);\n    }\n    \n    \n    /**\n      *  @deprecated Use getAFPInputStream() instead.\n      *  @see #getAFPInputStream\n      **/\n    public PrintObjectInputStream getInputACIFMergedStream(boolean acifB)\n        throws AS400Exception,\n               AS400SecurityException,\n               ErrorCompletingRequestException,\n               IOException,\n               InterruptedException,\n               RequestNotSupportedException\n    {\n        String acifS;\n        // possible open options that we could use -\n        // acifB == true then process ACIF merged data\n        // else normal processing\n        if (acifB){\n            acifS = \"Y\";\n            } else acifS = \"N\"; \n\n        PrintObjectInputStream is = new PrintObjectInputStream(this, null, acifS);\n        return is;\n    }\n\n    /**\n     * Returns an input stream that can be used to read the contents of an \n     * AFP spooled file. The external resources referenced by the original \n     * AFP spooled file will be included in this input stream. If you don't want \n     * the external resources included use \n     * {@link #getInputStream getInputStream} or\n     * {@link #getPageInputStream getPageInputStream}.\n     * This method will fail with an AS400Exception if the spooled file is\n     * still being created (ATTR_SPLFSTATUS is *OPEN) or if the spooled file\n     * doesn't contain AFDS data ie. ATTR_PRTDEVTYPE is not *AFPDS. \n     *\n     * @return The input stream object that can be used to read the contents\n     *         of this spooled file.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported\n     *                                         because the system operating system is not\n     *                                         at the correct level.\n     * @see #getInputStream\n     * @see #getPageInputStream\n     **/\n   public PrintObjectInputStream getAFPInputStream()\n       throws AS400Exception,\n              AS400SecurityException,\n              ErrorCompletingRequestException,\n              IOException,\n              InterruptedException,\n              RequestNotSupportedException\n   {\n       PrintObjectInputStream is = new PrintObjectInputStream(this, null, \"Y\");\n       return is;\n   }\n\n    /**\n      * Returns the name of the job that created the spooled file.\n      * @return The job name.\n      **/\n    public String getJobName()\n    {\n        NPCPID IDCodePoint = getIDCodePoint();\n\n        if( IDCodePoint == null ) {\n            return EMPTY_STRING; // \"\"\n        } else {\n            return IDCodePoint.getStringValue(ATTR_JOBNAME);\n        }\n    }\n\n\n\n    /**\n      * Returns the number of the job that created the spooled file.\n      * @return The job number.\n      **/\n    public String getJobNumber()\n    {\n        NPCPID IDCodePoint = getIDCodePoint();\n\n        if( IDCodePoint == null ) {\n            return EMPTY_STRING; // \"\"\n        } else {\n            return IDCodePoint.getStringValue(ATTR_JOBNUMBER);\n        }\n    }\n\n\n\n    /**\n     * Returns the ID of the user that created the spooled file.\n     * @return The user ID.\n     **/\n    public String getJobUser()\n    {\n        NPCPID IDCodePoint = getIDCodePoint();\n\n        if( IDCodePoint == null ) {\n            return EMPTY_STRING; // \"\"\n        } else {\n            return IDCodePoint.getStringValue(ATTR_JOBUSER);\n        }\n    }\n\n    // The next three attributes are added to provide the\n    // decoupled spooled file identity.\n   \n    /**\n    * Returns the name of the system where the spooled file was created.\n    * @return The name of the system where the spooled file was created.\n    **/\n    public String getJobSysName()\n    {\n        String jobSysName = EMPTY_STRING;\n        NPCPID IDCodePoint = getIDCodePoint();\n        if (IDCodePoint == null) {\n            return(jobSysName);\n        } else {\n            jobSysName = IDCodePoint.getStringValue(ATTR_JOBSYSTEM);\n            if (jobSysName == null) {\n                try {\n                    jobSysName = this.getStringAttribute(ATTR_JOBSYSTEM);\n                }\n                catch (Exception e) {\n                    // ignore exceptions, splf may not have this attr.\n                    jobSysName = EMPTY_STRING;\n                }\n            }\n            return(jobSysName);\n        }\n    }\n    \n    /**\n    * Returns the date of the spooled file creation. \n    * The date is encoded in the CYYMMDD format.\n    * @return The date (CYYMMDD) of the spooled file creation.\n    **/\n    public String getCreateDate()\n    {\n        String createDate = EMPTY_STRING;\n        NPCPID IDCodePoint = getIDCodePoint();\n        if (IDCodePoint == null) {\n            return(createDate);\n        } else {\n            createDate = IDCodePoint.getStringValue(ATTR_DATE);\n            if (createDate == null) {\n                try {\n                    createDate = this.getStringAttribute(ATTR_DATE);\n                }\n                catch (Exception e) {\n                    // ignore exceptions, splf may not have this attr.\n                    createDate = EMPTY_STRING;\n                }\n            }   \n            return(createDate);\n        }\n    }\n    \n    /**\n    * Returns the time of spooled file creation.\n    * The time is encoded in the HHMMSS format.\n    * @return The time (HHMMSS) of the spooled file creation.\n    **/\n    public String getCreateTime()\n    {\n        String createTime = EMPTY_STRING;\n        NPCPID IDCodePoint = getIDCodePoint();\n        if (IDCodePoint == null) {\n            return(createTime);\n        } else {\n            createTime = IDCodePoint.getStringValue(ATTR_TIME);\n            if (createTime == null) {\n                try {\n                    createTime = this.getStringAttribute(ATTR_TIME);\n                }\n                catch (Exception e) {\n                    // ignore exceptions, splf may not have this attr.\n                    createTime = EMPTY_STRING;\n                }\n            }   \n            return(createTime);\n        }\n    }\n    \n    /**\n      * Returns the message that is associated with this spooled file.\n      * A spooled file has a message associated with it if its\n      * ATTR_SPLFSTATUS attribute returns *MESSAGE.\n      *\n      * @return The AS400Message object that contains the message text,\n      *   type, severity, id, date, time, and default reply.\n      * @exception AS400Exception If the system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      **/\n    public AS400Message getMessage()\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        AS400Message msg = ((SpooledFileImpl) impl_).getMessage();\n        fMsgRetrieved_   = ((SpooledFileImpl) impl_).getFMsgRetrieved();\n        return msg;\n    }\n\n\n\n    /**\n     * Returns the name of the spooled file.\n     * @return The name of the spooled file.\n     **/\n    public String getName()\n    {\n        NPCPID IDCodePoint = getIDCodePoint();\n\n        if( IDCodePoint == null )\n        {\n            return EMPTY_STRING; // \"\"\n        } else {\n            return IDCodePoint.getStringValue(ATTR_SPOOLFILE);\n        }\n    }\n\n\n\n    /**\n      * Returns the number of the spooled file.\n      * @return The number of the spooled file.\n      **/\n    public int getNumber()\n    {\n        NPCPID IDCodePoint = getIDCodePoint();\n\n        if( IDCodePoint == null ) {\n            return 0;\n        } else {\n            return IDCodePoint.getIntValue(ATTR_SPLFNUM).intValue();\n        }\n    }\n\n\n\n    /**\n     * Returns a page input stream that can be used to read the contents of the\n     * spooled file, one page at a time.\n     * <br>\n     * See <a href=\"{@docRoot}/com/ibm/as400/access/doc-files/TransInStr.html\">Example using PrintObjectPageInputStream</a>\n     * <br>\n     * @param pageStreamOptions A print parameter list that contains\n     *  parameters for generating the page input stream. <br>\n     * The following attributes are optional:\n     * <UL>\n     *   <LI> ATTR_MFGTYPE                 - Specifies the manufacturer type and model.\n     *   <LI> ATTR_WORKSTATION_CUST_OBJECT - Specifies the integrated file system name of\n     *                                       the workstation customization object to be\n     *                                       used.  The workstation customizing object\n     *                                       associated with the manufacturer, type, and\n     *                                       model is the default.\n     *   <LI> ATTR_PAPER_SOURCE_1          - Specifies the paper size of drawer 1.\n     *   <LI> ATTR_PAPER_SOURCE_2          - Specifies the paper size of drawer 2.\n     *   <LI> ATTR_VIEWING_FIDELITY        - Specifies the fidelity used to process pages.\n     *\n     * </UL>\n     *\n     * @return A page input stream object that can be used to read the contents\n     *         of this spooled file, one page at a time.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed,\n                                                  or the spooled file format is not supported.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported\n     *                                         because the system operating system is not\n     *                                         at the correct level.\n     **/\n    public PrintObjectPageInputStream getPageInputStream(PrintParameterList pageStreamOptions)\n\t    throws AS400Exception,\n\t           AS400SecurityException,\n\t           ErrorCompletingRequestException,\n\t           IOException,\n\t           InterruptedException,\n\t           RequestNotSupportedException\n    {\n        PrintObjectPageInputStream is = new PrintObjectPageInputStream(this, pageStreamOptions);\n        return is;\n    }\n\n\n\n    /**\n     * Returns a transformed input stream that can be used to read the contents of the\n     * spooled file.\n     * <br>\n     * See <a href=\"{@docRoot}/com/ibm/as400/access/doc-files/TransInStr.html\">Example using PrintObjectTransformedInputStream</a>\n     * <br>\n     * @param transformOptions A print parameter list that contains\n     *  parameters for generating the transformed input stream. <br>\n     * The following attribute MUST be set:\n     * <UL>\n     *   <LI> ATTR_MFGTYPE  - Specifies the manufacturer, type, and model.\n     * </UL>\n     * The following attributes are optional:\n     * <UL>\n     *   <LI> ATTR_WORKSTATION_CUST_OBJECT - Specifies the integrated file system name of\n     *                                       the workstation customization object to be\n     *                                       used.  The workstation customizing object\n     *                                       associated with the manufacturer, type, and\n     *                                       model is the default.\n     *   <LI> ATTR_PAPER_SOURCE_1          - Specifies the paper size of drawer 1.\n     *   <LI> ATTR_PAPER_SOURCE_2          - Specifies the paper size of drawer 2.\n     *\n     * </UL>\n     *\n     * @return The transformed input stream object that can be used to read the contents\n     *         of the transformed spooled file.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed,\n     *                                            or the spooled file format is not supported.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported\n     *                                         because the system operating system is not\n     *                                         at the correct level.\n     **/\n    public PrintObjectTransformedInputStream getTransformedInputStream(PrintParameterList transformOptions)\n\t    throws AS400Exception,\n\t           AS400SecurityException,\n\t           ErrorCompletingRequestException,\n\t           IOException,\n\t           InterruptedException,\n\t           RequestNotSupportedException\n    {\n        PrintObjectTransformedInputStream is = new PrintObjectTransformedInputStream(this, transformOptions);\n        return is;\n    }\n\n\n\n    /**\n     * Holds the spooled file.\n     * @param holdType When to hold the spooled file.\n     *  May be any of the following values:\n     * <UL>\n     *   <LI> *IMMED - The spooled file is held immediately.\n     *   <LI> *PAGEEND - The spooled file is held at the end of the current page.\n     * </UL>\n     *  <i>holdType</i> may be null.  If <i>holdType</i> is not specified, the default is\n     * *IMMED.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported\n     *                                         because the system operating system is not\n     *                                         at the correct level.\n     **/\n    public void hold(String holdType)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).hold(holdType);\n        // update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\n    /**\n     * Moves the spooled file to another output queue or to another\n     * position on the same output queue.\n     *\n     * @param targetSpooledFile The spooled file to move this\n     *       spooled file after.  The targetSpooledFile and this spooled file\n     *       must reside on the same system.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system operating system is not at the correct level.\n     **/\n    public void move(SpooledFile targetSpooledFile)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        if (targetSpooledFile.getImpl() == null) {\n            targetSpooledFile.chooseImpl();\n        }\n        ((SpooledFileImpl) impl_).move((SpooledFileImpl)targetSpooledFile.getImpl());\n    \t//update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\n    /**\n     * Moves the spooled file to another output queue.\n     *\n     * @param targetOutputQueue The output queue to move the\n     *       spooled file to.  The spooled file will be moved to the first\n     *       position on this output queue.  The output queue and this spooled\n     *       file must reside on the same system.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system operating system is not at the correct level.\n     **/\n    public void move(OutputQueue targetOutputQueue)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        if (targetOutputQueue.getImpl() == null) {\n            targetOutputQueue.chooseImpl();\n        }\n        ((SpooledFileImpl) impl_).move((OutputQueueImpl)targetOutputQueue.getImpl());\n    \t// update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\n    /**\n     * Moves the spooled file to the first position on the output queue.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system operating system is not at the correct level.\n     **/\n    public void moveToTop()\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).moveToTop();\n    \t// update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\n    /**\n    Restores the state of the object from an input stream.\n    This is used when deserializing an object.\n\n    @param in   The input stream.\n\n    @exception IOException Thrown if an IO error occurs.\n    @exception ClassNotFoundException Thrown if class is not found.\n    **/\n    private void readObject(ObjectInputStream in)\n        throws IOException, ClassNotFoundException\n    {\n        in.defaultReadObject();\n        fMsgRetrieved_ = false;\n    }\n\n\n\n    /**\n     * Releases a held spooled file on the system.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system operating system is not at the correct level.\n     **/\n    public void release()\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).release();\n    \t// update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\n    /**\n      * Sends the spooled file to another user on the same system or to\n      * a remote system on the network.  The equivalent of the system\n      * Send Network Spooled File\n      * (SNDNETSPLF) command will be issued against the spooled file.\n      *\n      * @param sendOptions A print parameter list that contains the\n      *  parameters for the send.  The following attributes MUST be set:\n      * <UL>\n      *   <LI> ATTR_TOUSERID  - Specifies the user ID to send the spooled file to.\n      *   <LI> ATTR_TOADDRESS - Specifies the remote system to send the spooled file to.\n      * </UL>\n      * The following attributes are optional:\n      * <UL>\n      *   <LI> ATTR_DATAFORMAT - Specifies the data format in which to transmit the\n      *                           spooled file.  May be either of *RCDDATA or\n      *                           *ALLDATA.  *RCDDATA is the default.\n      *   <LI> ATTR_VMMVSCLASS - Specifies the VM/MVS SYSOUT class for distributions\n      *                          sent to a VM host system or to an MVS host system.\n      *                          May be A to Z or 0 to 9.  A is the default.\n      *   <LI> ATTR_SENDPTY - Specifies the queueing priority used for this spooled file\n      *                        when it is being routed through a SNADS network.  May be\n      *                        *NORMAL or *HIGH.  *NORMAL is the default.\n      * </UL>\n      *\n      * @exception AS400Exception If the system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      **/\n    public void sendNet(PrintParameterList sendOptions)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).sendNet(sendOptions);\n    }\n\n\n\n    /**\n      * Sends a spooled file to be printed on a remote system.\n      * The equivalent of the Send TCP/IP Spooled File\n      * (SNDTCPSPLF) command will be issued against the spooled file.\n      * This is the system's version of the TCP/IP LPR command.\n      *\n      * @param sendOptions A print parameter list that contains the\n      *  parameters for the send.  The following attributes MUST be set:\n      * <UL>\n      *   <LI> ATTR_RMTSYSTEM - Specifies the remote system to which the print\n      *                          request will be sent.  May be a remote system\n      *                          name or the special value *INTNETADR.\n      *   <LI> ATTR_RMTPRTQ - Specifies the name of the destination print queue.\n      * </UL>\n      * The following attributes are optional:\n      * <UL>\n      *   <LI> ATTR_DELETESPLF - Specifies whether or not to delete the spooled file\n      *                           after it has been successfully sent.  May be *NO\n      *                           or *YES.   *NO is the default.\n      *   <LI> ATTR_DESTOPTION - Specifies a destination-dependant option.  These options will\n      *                          be sent to the remote system with the spooled file.\n      *   <LI> ATTR_DESTINATION - Specifies the type of system to which the spooled file is\n      *                           being sent.  When sending to other IBM i systems, this value\n      *                           should be *AS/400.  May also be *OTHER or *PSF/2.\n      *                           *OTHER is the default.\n      *   <LI> ATTR_INTERNETADDR - Specifies the Internet address of the receiving system.\n      *   <LI> ATTR_MFGTYPE  - Specifies the manufacturer, type, and model when transforming print\n      *                        data from SCS or AFP to ASCII.\n      *   <LI> ATTR_SCS2ASCII - Specifies whether the print data is to be transformed to\n      *                         ASCII.  May be *NO or *YES.  *NO is the default.\n      *   <LI> ATTR_SEPPAGE - Specifies whether to print the separator page.  May be\n      *                        *NO or *YES.  *YES is the default.\n      * </UL>\n      *\n      * @exception AS400Exception If the system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      **/\n    public void sendTCP(PrintParameterList sendOptions)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).sendTCP(sendOptions);\n    }\n\n\n\n    /**\n     * Sets one or more attributes of the object.  See\n     * <a href=\"{@docRoot}/com/ibm/as400/access/doc-files/SpooledFileAttrs.html\">Spooled File Attributes</a> for\n     * a list of valid attributes that can be changed.\n     *\n     * @param attributes A print parameter list that contains the\n     *  attributes to be changed.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system operating system is not at the correct level.\n     **/\n    public void setAttributes(PrintParameterList attributes)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (attributes == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'attributes' is null.\");\n            throw new NullPointerException(\"attributes\");\n        }\n\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).setAttributes(attributes);\n\n        // we changed the spooled file attributes on the system,\n        // merge those changed attributes into our current attributes\n        // here.\n        if (attrs == null)\n        {\n            attrs = new NPCPAttribute();\n        }\n    \t// update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\t/**\n\tApplies the changes made by the user.\n\t\n\t@param outputPropertiesPane TODO\n\t * @throws Exception\n\t**/\n\t    public void applyChanges2 (OutputPropertiesPane outputPropertiesPane)\n\t      throws Exception\n\t    {\n\t        // create a print parameter list to hold the attributes that were updated\n\t        PrintParameterList pList_ = new PrintParameterList();\n\t\n\t        ////////////////\n\t        // user data ///\n\t        ////////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldUserData = getStringAttribute(PrintObject.ATTR_USERDATA).trim();\n\t\n\t        // get the new value from the textfield\n\t        String newUserData = (String)outputPropertiesPane.userData_.getText().trim();\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldUserData.equals(newUserData)) pList_.setParameter(PrintObject.ATTR_USERDATA,newUserData);\n\t\n\t        //////////////////////////\n\t        // save after printing ///\n\t        //////////////////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldSaveData = getStringAttribute(PrintObject.ATTR_SAVE);\n\t\n\t        // get the new value from the combo box\n\t        String newSaveData = (String)outputPropertiesPane.saveBox_.getSelectedItem();\n\t\n\t        // change new value if necessary\n\t        if (newSaveData.equals(OutputPropertiesPane.noText_)) newSaveData = \"*NO\";\n\t        else if (newSaveData.equals(OutputPropertiesPane.yesText_)) newSaveData = \"*YES\";\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldSaveData.equals(newSaveData)) pList_.setParameter(PrintObject.ATTR_SAVE,newSaveData);\n\t\n\t        if (outputPropertiesPane.functionSupported_ == true) // @A2A\n\t        {\n\t            //////////////\n\t            // printer ///\n\t            //////////////\n\t            // get the previous value from the spooled file\n\t            String oldPrinter = getStringAttribute(PrintObject.ATTR_PRINTER).trim();\n\t\n\t            // get the new value from the textfield\n\t            String newPrinter = (String)(outputPropertiesPane.printer_.getText().trim());\n\t\n\t            // compare the values to see if a change is needed, and set as necessary\n\t            if ((!newPrinter.equals(OutputPropertiesPane.notAssignedText_)) && (!oldPrinter.equals(newPrinter))) {\n\t                pList_.setParameter(PrintObject.ATTR_PRINTER,newPrinter);\n\t            }\n\t\n\t            ///////////////////\n\t            // output queue ///\n\t            ///////////////////\n\t\n\t            // extract the output queue path into an object that knows how to parse it.\n\t            QSYSObjectPathName outQPath = new QSYSObjectPathName(getStringAttribute(PrintObject.ATTR_OUTPUT_QUEUE));\n\t\n\t            // get the previous value from the spooled file\n\t            String oldOutQ = outQPath.getObjectName().trim();\n\t\n\t            // get the new value from the textfield\n\t            String newOutQ = (String)outputPropertiesPane.outQ_.getText().trim();\n\t\n\t            // flag to indicate a output queue change\n\t            boolean fNewOutQ = false;\n\t\n\t            // compare the values to see if a change is needed, and set as necessary\n\t            if (!oldOutQ.equals(newOutQ))\n\t                {\n\t                // create a QSYSObjectPathName object to represent the new output queue with the old outq library\n\t                QSYSObjectPathName newOutQPath = new QSYSObjectPathName(outQPath.getLibraryName(), newOutQ, \"OUTQ\");\n\t\n\t                // set the IFS output queue attribute\n\t                pList_.setParameter(PrintObject.ATTR_OUTPUT_QUEUE,newOutQPath.getPath());\n\t\n\t                // set the flag to say that we did have an output queuue change\n\t                fNewOutQ = true;\n\t                }\n\t\n\t            ///////////////////////////\n\t            // output queue library ///\n\t            ///////////////////////////\n\t\n\t            // get the previous value from the spooled file\n\t            String oldOutQLib = outQPath.getLibraryName().trim();\n\t\n\t            // get the new value from the textfield\n\t            String newOutQLib = (String)outputPropertiesPane.outQLib_.getText().trim();\n\t\n\t            // compare the values to see if a change is needed, and set as necessary\n\t            if (!oldOutQLib.equals(newOutQLib))\n\t                {\n\t                QSYSObjectPathName newOutQPath;\n\t\n\t                // check to see if we had a output queue name change also\n\t                if (fNewOutQ)\n\t                    // create a QSYSObjectPathName object to represent the new output queue library and new output queue name\n\t                    newOutQPath = new QSYSObjectPathName(newOutQLib, newOutQ, \"OUTQ\");\n\t                else\n\t                    // create a QSYSObjectPathName object to represent the new output queue library and old output queue name\n\t                    newOutQPath = new QSYSObjectPathName(newOutQLib, oldOutQ, \"OUTQ\");\n\t\n\t                // set the IFS output queue attribute\n\t                pList_.setParameter(PrintObject.ATTR_OUTPUT_QUEUE,newOutQPath.getPath());\n\t                }\n\t        }\n\t\n\t        ////////////////////////////\n\t        // output queue priority ///\n\t        ////////////////////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldOutQPty = getStringAttribute(PrintObject.ATTR_OUTPTY);\n\t\n\t        // get the new value from the combo box\n\t        String newOutQPty = (String)outputPropertiesPane.outQPtyBox_.getSelectedItem();\n\t\n\t        // check to see if user selected Job Value if so set priority to *JOB\n\t        if (newOutQPty.equals(OutputPropertiesPane.jobValueText_)) newOutQPty = \"*JOB\";\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldOutQPty.equals(newOutQPty)) pList_.setParameter(PrintObject.ATTR_OUTPTY,newOutQPty);\n\t\n\t        ///////////////////\n\t        // Total copies ///\n\t        ///////////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldTotalCopies = getIntegerAttribute(PrintObject.ATTR_COPIES).toString();\n\t\n\t        // get the new value from the textfield\n\t        String newTotalCopies = (String)outputPropertiesPane.totalCopies_.getText().trim();\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldTotalCopies.equals(newTotalCopies))\n\t            pList_.setParameter(PrintObject.ATTR_COPIES,Integer.parseInt(newTotalCopies));\n\t\n\t        //////////////////\n\t        // Copies left ///\n\t        //////////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldCopiesLeft = getIntegerAttribute(PrintObject.ATTR_COPIESLEFT).toString();\n\t\n\t        // get the new value from the textfield\n\t        String newCopiesLeft = (String)outputPropertiesPane.copiesLeft_.getText().trim();\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldCopiesLeft.equals(newCopiesLeft))\n\t            pList_.setParameter(PrintObject.ATTR_COPIESLEFT,Integer.parseInt(newCopiesLeft));\n\t\n\t        ///////////////\n\t        // Form type //\n\t        ///////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldFormType = getStringAttribute(PrintObject.ATTR_FORMTYPE).trim();\n\t\n\t        // get the new value from the textfield\n\t        String newFormType = (String)outputPropertiesPane.formType_.getText().trim();\n\t        if (newFormType.equals(OutputPropertiesPane.standardText_)) newFormType = \"*STD\";\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldFormType.equals(newFormType)) pList_.setParameter(PrintObject.ATTR_FORMTYPE,newFormType);\n\t\n\t\n\t        // fire started working event\n\t        outputPropertiesPane.workingEventSupport_.fireStartWorking();\n\t\n\t        //////////////////////////////////////////////////////\n\t        // Set the requested attributes of the spooled file //\n\t        //////////////////////////////////////////////////////\n\t        setAttributes(pList_);\n\t\n\t        // fire stopped working event\n\t        outputPropertiesPane.workingEventSupport_.fireStopWorking();\n\t\n\t        // notify object that there have been changes\n\t        outputPropertiesPane.objectEventSupport_.fireObjectChanged(outputPropertiesPane.object_);\n\t     }\n\n} // SpooledFile class"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 1137,
                        "lineEnd": 1324,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to com.ibm.as400.vaccess.OutputPropertiesPane\nRationale: The method applyChanges2 directly interacts with the OutputPropertiesPane instance, accessing its fields and components to retrieve user input values. It is responsible for applying changes based on user interactions within the OutputPropertiesPane, making it logical for this method to reside within that class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 7450
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "applyChanges2",
                            "method_signature": "public void applyChanges2(OutputPropertiesPane outputPropertiesPane) throws Exception",
                            "target_class": "OutputPropertiesPane",
                            "rationale": "The method applyChanges2() is heavily dependent on the OutputPropertiesPane class for its functionality. It should be moved to that class to maintain cohesion and encapsulate related functionality."
                        }
                    ],
                    "llm_response_time": 2051
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "applyChanges2",
                            "method_signature": "public void applyChanges2(OutputPropertiesPane outputPropertiesPane) throws Exception",
                            "target_class": "OutputPropertiesPane",
                            "rationale": "The method applyChanges2() is heavily dependent on the OutputPropertiesPane class for its functionality. It should be moved to that class to maintain cohesion and encapsulate the logic related to output properties."
                        }
                    ],
                    "llm_response_time": 1630
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "applyChanges2",
                            "method_signature": "public void applyChanges2(OutputPropertiesPane outputPropertiesPane) throws Exception",
                            "target_class": "OutputPropertiesPane",
                            "rationale": "The method applyChanges2() is heavily dependent on the OutputPropertiesPane class for its functionality. It should be moved to that class to maintain cohesion and encapsulate related functionality."
                        }
                    ],
                    "llm_response_time": 2542
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "applyChanges2",
                            "method_signature": "public void applyChanges2(OutputPropertiesPane outputPropertiesPane) throws Exception",
                            "target_class": "OutputPropertiesPane",
                            "rationale": "The method applyChanges2() is heavily dependent on the OutputPropertiesPane class for its functionality. It should be moved to that class to maintain cohesion and encapsulate related functionality."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "applyChanges2"
                ],
                "llm_response_time": 1089
            },
            "targetClassMap": {
                "applyChanges2": {
                    "target_classes": [
                        {
                            "class_name": "OutputPropertiesPane",
                            "similarity_score": 0.5562371558833118
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OutputPropertiesPane"
                    ],
                    "llm_response_time": 1552,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.access.AS400JDBCDataSource::applyChanges():boolean need move com.ibm.as400.vaccess.AS400JDBCDataSourcePane",
        "class_name": "com.ibm.as400.access.AS400JDBCDataSource",
        "telemetry": {"id":"35e959d9-30d8-4b30-bb52-5effe8d8b601","hostFunctionTelemetryData":{"hostFunctionSize":5250,"lineStart":46,"lineEnd":5295,"bodyLineStart":46,"language":"java","filePath":"/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/large/big/jtopen-7.8/src/com/ibm/as400/access/AS400JDBCDataSource.java","sourceCode":"/**\n*  The AS400JDBCDataSource class represents a factory for IBM i database connections.\n*\n*  \u003cP\u003eThe following is an example that creates an AS400JDBCDataSource object and creates a\n*  connection to the database.\n*\n*  \u003cpre\u003e\u003cblockquote\u003e\n*  // Create a data source for making the connection.\n*  AS400JDBCDataSource datasource \u003d new AS400JDBCDataSource(\"myAS400\");\n*  datasource.setUser(\"myUser\");\n*  datasource.setPassword(\"MYPWD\");\n\n*  // Create a database connection to the system.\n*  Connection connection \u003d datasource.getConnection();\n*  \u003c/blockquote\u003e\u003c/pre\u003e\n*\n*  \u003cP\u003eThe following example registers an AS400JDBCDataSource object with JNDI and then\n*  uses the object returned from JNDI to obtain a database connection.\n*  \u003cpre\u003e\u003cblockquote\u003e\n*  // Create a data source to the IBM i database.\n*  AS400JDBCDataSource dataSource \u003d new AS400JDBCDataSource();\n*  dataSource.setServerName(\"myAS400\");\n*\n*  // Register the datasource with the Java Naming and Directory Interface (JNDI).\n*  Hashtable env \u003d new Hashtable();\n*  env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.fscontext.RefFSContextFactory\");\n*  Context context \u003d new InitialContext(env);\n*  context.bind(\"jdbc/customer\", dataSource);\n*\n*  // Return an AS400JDBCDataSource object from JNDI and get a connection.\n*  AS400JDBCDataSource datasource \u003d (AS400JDBCDataSource) context.lookup(\"jdbc/customer\");\n*  Connection connection \u003d datasource.getConnection(\"myUser\", \"MYPWD\");\n*  \u003c/pre\u003e\u003c/blockquote\u003e\n**/\npublic class AS400JDBCDataSource \n/* ifdef JDBC40 */\nextends ToolboxWrapper\n/* endif */ \n\nimplements DataSource, Referenceable, Serializable, Cloneable //@PDC 550\n{\n    static final long serialVersionUID \u003d 4L;\n\n\n\n    /**\n    *  Implementation notes:\n    *  The properties listed in com.ibm.as400.access.JDProperties should also be included here.\n    **/\n\n    // Constants\n    private static final String DATABASE_NAME \u003d \"databaseName\";\n    private static final String DATASOURCE_NAME \u003d \"dataSourceName\";\n    private static final String DESCRIPTION \u003d \"description\";\n    private static final String SERVER_NAME \u003d \"serverName\";\n    private static final String USER \u003d \"userName\";\n    private static final String KEY_RING_NAME \u003d \"keyring\";       // @F0A\n    private static final String PASSWORD \u003d \"pw\";                 // @F0A\n    private static final String KEY_RING_PASSWORD \u003d \"keyringpw\"; // @F0A\n    private static final String SECURE \u003d \"secure\";               // @F0A\n    private static final String SAVE_PASSWORD \u003d \"savepw\";        // @F0A\n    private static final String PLAIN_TEXT_PASSWORD \u003d \"pwd\";     //@K1A\n    private static final String TRUE_ \u003d \"true\";\n    private static final String FALSE_ \u003d \"false\";\n    private static final String TOOLBOX_DRIVER \u003d \"jdbc:as400:\";\n    private static final int MAX_THRESHOLD \u003d 16777216;                  // Maximum threshold (bytes). @A3C, @A4A\n    static final int MAX_SCALE \u003d 63;                            // Maximum decimal scale\n\n    // socket options to store away in JNDI\n    private static final String SOCKET_KEEP_ALIVE \u003d \"soKeepAlive\"; // @F1A\n    private static final String SOCKET_RECEIVE_BUFFER_SIZE \u003d \"soReceiveBufferSize\"; // @F1A\n    private static final String SOCKET_SEND_BUFFER_SIZE \u003d \"soSendBufferSize\"; // @F1A\n    private static final String SOCKET_LINGER \u003d \"soLinger\"; // @F1A\n    private static final String SOCKET_TIMEOUT \u003d \"soTimeout\"; // @F1A\n    private static final String SOCKET_LOGIN_TIMEOUT \u003d \"loginTimeout\"; // @st3\n    private static final String SOCKET_TCP_NO_DELAY \u003d \"soTCPNoDelay\"; // @F1A\n\n    // Data source properties.\n    transient private AS400 as400_;                           // AS400 object used to store and encrypt the password.\n    // @J2d private String databaseName_ \u003d \"\";                // Database name. @A6C\n    private String dataSourceName_ \u003d \"\";                      // Data source name. @A6C\n    private String description_ \u003d \"\";                         // Data source description. @A6C\n    private JDProperties properties_;                         // IBM i connection properties.\n    private SocketProperties sockProps_;                      // IBM i socket properties @F1A\n    transient private PrintWriter writer_;                    // The EventLog print writer.  @C7c\n    transient private EventLog log_;       //@C7c\n\n    private String serialServerName_;                         // system name used in serialization.\n    private String serialUserName_;                           // User used in serialization.\n    private String serialKeyRingName_;     //@B4A             // Key ring name used in serialization.\n    transient PropertyChangeSupport changes_; //@B0C\n    private boolean isSecure_ \u003d false;  //@B4A\n\n    // Handles loading the appropriate resource bundle\n    // private static ResourceBundleLoader loader_;      //@A9A\n\n\n    // In mod 5 support was added to optionally serialize the password with the\n    // rest of the properties.  By default this is off.  setSavePasswordWhenSerialized(true)\n    // must be called to save the password.  By calling this the application takes\n    // responsibility for protecting the serialized bytes.  The password is not saved in the \n    // clear.  The password string is confused so that something more than just looking at the \n    // serialized bytes must be done to see the password.  \n    private char[]  serialPWBytes_ \u003d null;               //@J3a\n    private char[]  serialKeyRingPWBytes_ \u003d null;        //@J3a\n    private boolean savePasswordWhenSerialized_ \u003d false; //@J3a   by default, don\u0027t save password!!!!\n\n    /**\n     * The maximum storage space in megabytes, that can be used to execute a query.\n    **/\n    public static final int MAX_STORAGE_LIMIT \u003d 2147352578;                    // Maximum query storage limit @550\n\n\n    /**\n      Start tracing the JDBC client.  This is the same as setting\n      property \"trace\u003dtrue\";  Note the constant is not public.\n      It is defined only to be compatible with ODBC\n      The numeric value of this constant is 1.\n     **/\n    static final int TRACE_CLIENT \u003d 1;                // @j1a\n\n    /**\n      Start the database monitor on the JDBC server job.\n      This constant is used when setting the level of tracing for the JDBC server job.\n      The numeric value of this constant is 2.\n     **/\n    public static final int SERVER_TRACE_START_DATABASE_MONITOR \u003d 2;           // @j1a\n\n    /**\n      Start debug on the JDBC server job.\n      This constant is used when setting the level of tracing for the JDBC server job.\n      The numeric value of this constant is 4.\n     **/\n    public static final int SERVER_TRACE_DEBUG_SERVER_JOB \u003d 4;           // @j1a\n\n    /**\n      Save the joblog when the JDBC server job ends.\n      This constant is used when setting the level of tracing for the JDBC server job.\n      The numeric value of this constant is 8.\n     **/\n    public static final int SERVER_TRACE_SAVE_SERVER_JOBLOG \u003d 8;           // @j1a\n\n    /**\n      Start job trace on the JDBC server job.\n      This constant is used when setting the level of tracing for the JDBC server job.\n      The numeric value of this constant is 16.\n     **/\n    public static final int SERVER_TRACE_TRACE_SERVER_JOB \u003d 16;           // @j1a\n\n    /**\n      Save SQL information.\n      This constant is used when setting the level of tracing for the JDBC server job.\n      The numeric value of this constant is 32.\n     **/\n    public static final int SERVER_TRACE_SAVE_SQL_INFORMATION \u003d 32;           // @j1a\n\n\n    //@cc1\n    /**\n     * CONCURRENTACCESS_NOT_SET - Indicates that currently committed behavior is not \n     * requested explicitly by the client.     \n     */\n    public final static int CONCURRENTACCESS_NOT_SET \u003d 0;\n    //@cc1\n    /**\n     * CONCURRENTACCESS_USE_CURRENTLY_COMMITTED - Indicates that the currently committed \n     * behavior is requested at the server.\n     */\n    public final static int CONCURRENTACCESS_USE_CURRENTLY_COMMITTED \u003d 1;\n    //@cc1\n    /**\n     * CONCURRENTACCESS_WAIT_FOR_OUTCOME - Indicates that the readers will \n     * wait on the writers during lock contention.      \n     */\n    public final static int CONCURRENTACCESS_WAIT_FOR_OUTCOME \u003d 2;\n    //@cc1\n    /**\n     * CONCURRENTACCESS_SKIP_LOCKS - Indicates that the readers will \n     * skip locks.      \n     */\n    public final static int CONCURRENTACCESS_SKIP_LOCKS \u003d 3;\n\n    \n    /**\n    *  Constructs a default AS400JDBCDataSource object.\n    **/\n    public AS400JDBCDataSource()\n    {\n        initializeTransient();\n        properties_ \u003d new JDProperties(null, null);\n        sockProps_ \u003d new SocketProperties();\n    }\n\n    /**\n    *  Constructs an AS400JDBCDataSource object to the specified \u003ci\u003eserverName\u003c/i\u003e.\n    *  @param serverName The name of the IBM i system.\n    **/\n    public AS400JDBCDataSource(String serverName)\n    {\n        this();\n\n        setServerName(serverName);\n    }\n\n    /**\n    *  Constructs an AS400JDBCDataSource object with the specified signon information.\n    *  @param serverName The name of the IBM i system.\n    *  @param user The user id.\n    *  @param password The user password.\n    **/\n    public AS400JDBCDataSource(String serverName, String user, String password)\n    {\n        this();\n\n        setServerName(serverName);\n        setUser(user);\n        setPassword(password);\n    }\n\n    //@K1A\n    /**\n    * Constructs an AS400JDBCDataSource object with the specified AS400 object\n    * @param as400 The AS400 object\n    **/\n    public AS400JDBCDataSource(AS400 as400)\n    {\n        this();\n\n        as400_ \u003d as400;\n        if( as400 instanceof SecureAS400 )\n            setSecure(true);\n\n    }\n\n    //@B4A\n    /**\n    *  Constructs an AS400JDBCDataSource object with the specified signon information\n    *  to use for SSL communications with the system.\n    *  @param serverName The name of the IBM i system.\n    *  @param user The user id.\n    *  @param password The user password.\n       *  @param keyRingName The key ring class name to be used for SSL communications with the system.\n       *  @param keyRingPassword The password for the key ring class to be used for SSL communications with the system.\n    **/\n    public AS400JDBCDataSource(String serverName, String user, String password,\n                               String keyRingName, String keyRingPassword)\n    {\n        this();\n\n        setSecure(true);  // @F0M\n\n        try\n        {\n            as400_ \u003d new SecureAS400(as400_);\n            ((SecureAS400)as400_).setKeyRingName(keyRingName, keyRingPassword);\n        }\n        catch (PropertyVetoException pe)\n        { /* will never happen */\n        }\n        serialKeyRingName_ \u003d keyRingName;\n\n        // @J3 There is no get/set keyring name / password methods so they really aren\u0027t bean\n        // properties, but in v5r1 the keyring name is saved as if it is a property.  Since\n        // the code saved the name we will also save the password. \n        serialKeyRingPWBytes_ \u003d xpwConfuse(keyRingPassword);     //@J3a  // @F0M  (changed from keyRingName to keyRingPassword)\n\n        setServerName(serverName);\n        setUser(user);\n        setPassword(password);\n    }\n\n    // @F0A - Added the following constructor to avoid creating some extra objects\n    /**\n    * Constructs an AS400JDBCDataSource object from the specified Reference object\n    * @param reference to retrieve the DataSource properties from\n    **/\n    AS400JDBCDataSource(Reference reference) {\n        /*\n        *  Implementation note:  This method is called from AS400JDBCObjectFactory.getObjectInstance\n        */\n\n        // check to make sure our reference is not null\n        if (reference \u003d\u003d null)\n            throw new NullPointerException(\"reference\");\n\n        // set up property change support\n        changes_ \u003d new PropertyChangeSupport(this);\n\n        // set up the as400 object\n        if (((String)reference.get(SECURE).getContent()).equalsIgnoreCase(TRUE_)) {\n            isSecure_ \u003d true;\n            as400_ \u003d new SecureAS400();\n\n            // since the as400 object is secure, get the key ring info\n            serialKeyRingName_ \u003d (String)reference.get(KEY_RING_NAME).getContent();\n            if (reference.get(KEY_RING_PASSWORD) !\u003d null)\n                serialKeyRingPWBytes_ \u003d ((String)reference.get(KEY_RING_PASSWORD).getContent()).toCharArray();\n            else\n                serialKeyRingPWBytes_ \u003d null;\n\n            try {\n                if (serialKeyRingPWBytes_ !\u003d null \u0026\u0026 serialKeyRingPWBytes_.length \u003e 0)\n                    ((SecureAS400)as400_).setKeyRingName(serialKeyRingName_, xpwDeconfuse(serialKeyRingPWBytes_));\n                else\n                    ((SecureAS400)as400_).setKeyRingName(serialKeyRingName_);\n            } catch (PropertyVetoException pve) { /* Will never happen */ }\n\n        } else {\n            isSecure_ \u003d false;\n            as400_ \u003d new AS400();\n        }\n\n        // must initialize the JDProperties so the property change checks dont get a NullPointerException\n        properties_ \u003d new JDProperties(null, null);\n\n        Properties properties \u003d new Properties();\n        sockProps_ \u003d new SocketProperties();\n\n        Enumeration list \u003d reference.getAll();\n        while (list.hasMoreElements())\n        {\n            StringRefAddr refAddr \u003d (StringRefAddr)list.nextElement();\n            String property \u003d refAddr.getType();\n            String value \u003d (String)reference.get(property).getContent();\n\n            // constant identifiers were used to store in JNDI\n            // all of these were handled already so do not put them in the properties\n            if (property.equals(DATABASE_NAME))                         \n                setDatabaseName(value);\n            else if (property.equals(DATASOURCE_NAME))\n                setDataSourceName(value);\n            else if (property.equals(DESCRIPTION))\n                setDescription(value);\n            else if (property.equals(SERVER_NAME))\n                setServerName(value);\n            else if (property.equals(USER))\n                setUser(value);\n            else if(property.equals(PLAIN_TEXT_PASSWORD)) {         //@K1A\n                //set the password                                  //@K1A\n                setPassword(value);                                 //@K1A\n            }\n            else if (property.equals(PASSWORD)) {\n                if(reference.get(PLAIN_TEXT_PASSWORD) !\u003d null)      //@K1A\n                {                                                   //@K1A\n                    setPassword((String)reference.get(PLAIN_TEXT_PASSWORD).getContent());       //@K1A\n                }                                                                               //@K1A\n                else                                                                            //@K1A\n                {                                                                               //@K1A\n                    // get the password back from the serialized char[]\n                    serialPWBytes_ \u003d value.toCharArray();\n                    // decode the password and set it on the as400\n                    as400_.setPassword(xpwDeconfuse(serialPWBytes_));\n                }                                                                               //@K1A\n            }\n            else if (property.equals(SAVE_PASSWORD)) {\n                // set the savePasswordWhenSerialized_ flag\n                savePasswordWhenSerialized_ \u003d value.equals(TRUE_) ? true : false;\n            } else if (property.equals(SECURE) || property.equals(KEY_RING_NAME) || property.equals(KEY_RING_PASSWORD)) {\n                // do nothing for these keys, they have already been handled\n            }\n            else if (property.equals(SOCKET_KEEP_ALIVE)) {\n                sockProps_.setKeepAlive((value.equals(TRUE_)? true : false));\n            }\n            else if (property.equals(SOCKET_RECEIVE_BUFFER_SIZE)) {\n                sockProps_.setReceiveBufferSize(Integer.parseInt(value));\n            }\n            else if (property.equals(SOCKET_SEND_BUFFER_SIZE)) {\n                sockProps_.setSendBufferSize(Integer.parseInt(value));\n            }\n            else if (property.equals(SOCKET_LINGER)) {\n                sockProps_.setSoLinger(Integer.parseInt(value));\n            }\n            else if (property.equals(SOCKET_TIMEOUT)) {\n                sockProps_.setSoTimeout(Integer.parseInt(value));\n            }\n            else if (property.equals(SOCKET_LOGIN_TIMEOUT)) {        //@st3\n                sockProps_.setLoginTimeout(Integer.parseInt(value)); //@st3\n            }\n            else if (property.equals(SOCKET_TCP_NO_DELAY)) {\n                sockProps_.setTcpNoDelay((value.equals(TRUE_)? true : false));\n            }\n            else\n            {\n                properties.put(property, value);\n            }\n        }\n        properties_ \u003d new JDProperties(properties, null);\n\n        // get the prompt property and set it back in the as400 object\n        String prmpt \u003d properties_.getString(JDProperties.PROMPT);\n        if (prmpt !\u003d null \u0026\u0026 prmpt.equalsIgnoreCase(FALSE_))\n            setPrompt(false);\n        else if (prmpt !\u003d null \u0026\u0026 prmpt.equalsIgnoreCase(TRUE_))\n            setPrompt(true);\n\n    }\n\n    /**\n    *  Adds a PropertyChangeListener.  The specified PropertyChangeListener\u0027s\n    *  \u003cb\u003epropertyChange\u003c/b\u003e method is called each time the value of any bound\n    *  property is changed.\n    *  @see #removePropertyChangeListener\n    *  @param listener The PropertyChangeListener.\n    **/\n    public void addPropertyChangeListener(PropertyChangeListener listener)\n    {\n        if (listener \u003d\u003d null)\n            throw new NullPointerException(\"listener\");\n        changes_.addPropertyChangeListener(listener);\n\n        as400_.addPropertyChangeListener(listener);\n    }\n\n    //@PDA 550 - clone\n    /**\n     * Method to create a clone of AS400JDBCDataSource. This does a shallow\n     * copy, with the exception of JDProperties, which also gets cloned.\n     */\n    public Object clone()\n    {\n        try\n        {\n            Trace.log(Trace.INFORMATION, \"AS400JDBCDataSource.close()\"); \n            AS400JDBCDataSource clone \u003d (AS400JDBCDataSource) super.clone();\n            clone.properties_ \u003d (JDProperties) this.properties_.clone();\n            return clone;\n        } catch (CloneNotSupportedException e)\n        { // This should never happen.\n            Trace.log(Trace.ERROR, e);\n            throw new UnsupportedOperationException(\"clone()\");\n        }\n    }\n    \n    /**\n    *  Returns the level of database access for the connection.\n    *  @return The access level.  Valid values include: \"all\" (all SQL statements allowed),\n    *  \"read call\" (SELECT and CALL statements allowed), and \"read only\" (SELECT statements only).\n    *  The default value is \"all\".\n    **/\n    public String getAccess()\n    {\n        return properties_.getString(JDProperties.ACCESS);\n    }\n     \n    // @C9 new method\n    /**\n    *  Returns what behaviors of the Toolbox JDBC driver have been overridden.\n    *  Multiple behaviors can be overridden in combination by adding \n    *  the constants and passing that sum on the setBehaviorOverride() method.  \n    *  @return The behaviors that have been overridden. \n    *  \u003cp\u003eThe return value is a combination of the following:\n    *  \u003cul\u003e\n    *  \u003cli\u003e1 - Do not throw an exception if Statement.executeQuery() or\n    *          PreparedStatement.executeQuery() do not return a result set.\n    *          Instead, return null for the result set.\n    *  \u003c/ul\u003e\n    *\n    **/\n    public int getBehaviorOverride()\n    {\n        return properties_.getInt(JDProperties.BEHAVIOR_OVERRIDE);\n    }\n\n    //@B2A\n    /**\n    *  Returns the output string type of bidi data. See \u003ca href\u003d\"BidiStringType.html\"\u003e\n    *  BidiStringType\u003c/a\u003e for more information and valid values.  -1 will be returned\n    *  if the value has not been set.\n    **/\n    public int getBidiStringType()                                                               //@B3C\n    {\n        String value \u003d properties_.getString(JDProperties.BIDI_STRING_TYPE);     //@B3C\n        try\n        {                                                                                          //@B3A                                                                                            //@B3A\n            return Integer.parseInt (value);                                              //@B3A\n        }                                                                                            //@B3A\n        catch (NumberFormatException nfe)  // if value is \"\", that is, not set        //@B3A\n        {                                                                                            //@B3A\n            return -1;                                                                              //@B3A\n        }                                                                                            //@B3A\n    }\n\n\n    /**\n    *  Returns the criteria for retrieving data from the system in\n    *  blocks of records.  Specifying a non-zero value for this property\n    *  will reduce the frequency of communication to the system, and\n    *  therefore increase performance.\n    *  @return The block criteria.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e 0 (no record blocking)\n    *    \u003cli\u003e 1 (block if FOR FETCH ONLY is specified)\n    *    \u003cli\u003e 2 (block if FOR UPDATE is specified) - The default value.\n    *  \u003c/ul\u003e\n    **/\n    public int getBlockCriteria()\n    {\n        return properties_.getInt(JDProperties.BLOCK_CRITERIA);\n    }\n\n    /**\n    *  Returns the block size in kilobytes to retrieve from the system and\n    *  cache on the client.  This property has no effect unless the block criteria\n    *  property is non-zero.  Larger block sizes reduce the frequency of\n    *  communication to the system, and therefore may increase performance.\n    *  @return The block size in kilobytes.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e 0\n    *    \u003cli\u003e 8\n    *    \u003cli\u003e 16\n    *    \u003cli\u003e 32   - The default value.\n    *    \u003cli\u003e 64\n    *    \u003cli\u003e 128\n    *    \u003cli\u003e 256\n    *    \u003cli\u003e 512\n    *  \u003c/ul\u003e\n    **/\n    public int getBlockSize()\n    {\n        return properties_.getInt(JDProperties.BLOCK_SIZE);\n    }\n\n\n    /**\n    *  Returns the database connection.\n    *  @return The connection.\n    *  @exception SQLException If a database error occurs.\n    **/\n    public Connection getConnection() throws SQLException\n    {    \n        //if the object was created with a keyring, or if the user asks for the object\n        //to be secure, clone a SecureAS400 object; otherwise, clone an AS400 object\n        if (isSecure_ || isSecure())                     //@B4A  //@C2C\n            return getConnection(new SecureAS400(as400_));   //@B4A\n        else                               //@B4A\n            return getConnection(new AS400(as400_));\n    }\n\n\n    // @J3 Nothing to change here.  The password is serialized only when passed on the c\u0027tor \n    //     or via the settors.  That is, \"bean properties\" are affected only when using the \n    //     c\u0027tor specifying system, uid, and pwd, or the settors are used.  The bean properties\n    //     are not affected if this method is used, or if the default c\u0027tor is used such\n    //     that our sign-on dialog is used to get system, uid and pwd from the user.  \n    /**\n    *  Returns the database connection using the specified \u003ci\u003euser\u003c/i\u003e and \u003ci\u003epassword\u003c/i\u003e.\n    *  @param user The database user.\n    *  @param password The database password.\n    *  @return The connection\n    *  @exception SQLException If a database error occurs.\n    **/\n    public Connection getConnection(String user, String password) throws SQLException\n    {\n        // Validate the parameters.\n        //@pw3 Add way to get old behavior allowing \"\" (!but also need to allow new behavior of allowing null is/passwd so customers can slowly migrate)\n        String secureCurrentUser \u003d SystemProperties.getProperty (SystemProperties.JDBC_SECURE_CURRENT_USER); //@pw3\n        boolean isSecureCurrentUser \u003d true;                                                                  //@pw3\n        //if system property or jdbc property is set to false then secure current user code is not used\n        //null value for system property means not specified...so true by default\n        if(((secureCurrentUser !\u003d null) \u0026\u0026 (Boolean.valueOf(secureCurrentUser).booleanValue() \u003d\u003d false)) || !isSecureCurrentUser())            //@pw3\n            isSecureCurrentUser \u003d false;                                                                      //@pw3\n            \n        boolean forcePrompt \u003d false;     //@prompt\n        \n        //check if \"\".  \n        if (\"\".equals(user))                                              //@pw1\n        {                                                                 //@pw1\n            if(isSecureCurrentUser)//@pw3\n            {  //@pw3\n                if (JDTrace.isTraceOn()) //jdbc category trace                //@pw1\n                    JDTrace.logInformation (this, \"Userid/password cannot be \\\"\\\" or *CURRENT due to security constraints.  Use null instead\");  //@pw1\n                //JDError.throwSQLException(JDError.EXC_CONNECTION_REJECTED);   //@pw1\n                forcePrompt \u003d true;  //@prompt\n            }  //@pw3\n        }                                                                 //@pw1\n        if (\"\".equals(password))                                          //@pw1\n        {                                                                 //@pw1\n            if(isSecureCurrentUser)//@pw3\n            {  //@pw3\n                if (JDTrace.isTraceOn()) //jdbc category trace                //@pw1\n                    JDTrace.logInformation (this, \"Userid/password cannot be \\\"\\\" or *CURRENT due to security constraints.  Use null instead\");  //@pw1\n                //JDError.throwSQLException(JDError.EXC_CONNECTION_REJECTED);   //@pw1\n                forcePrompt \u003d true;  //@prompt\n            }  //@pw3\n        }                                                                 //@pw1\n        \n        //Next, hack for nulls to work on IBM i\n        //New security: replace null with \"\" to mimic old behavior to allow null logons...disallowing \"\" above.\n        if (user \u003d\u003d null)                                                         //@pw1\n            user \u003d \"\";                                                            //@pw1\n        if (password \u003d\u003d null)                                                     //@pw1\n            password \u003d \"\";                                                        //@pw1\n        \n        //check for *current\n        if (user.compareToIgnoreCase(\"*CURRENT\") \u003d\u003d 0)                    //@pw1\n        {                                                                 //@pw1\n            if(isSecureCurrentUser)//@pw3\n            {  //@pw3\n                if (JDTrace.isTraceOn()) //jdbc category trace                //@pw1\n                    JDTrace.logInformation (this, \"Userid/password cannot be \\\"\\\" or *CURRENT due to security constraints.  Use null instead\");  //@pw1\n                //JDError.throwSQLException(JDError.EXC_CONNECTION_REJECTED);   //@pw1\n                forcePrompt \u003d true;  //@prompt\n            }  //@pw3\n            \n        }                                                                 //@pw1\n        if (password.compareToIgnoreCase(\"*CURRENT\") \u003d\u003d 0)                //@pw1\n        {                                                                 //@pw1\n            if(isSecureCurrentUser)//@pw3\n            {  //@pw3\n                if (JDTrace.isTraceOn()) //jdbc category trace                //@pw1\n                    JDTrace.logInformation (this, \"Userid/password cannot be \\\"\\\" or *CURRENT due to security constraints.  Use null instead\");  //@pw1\n                //JDError.throwSQLException(JDError.EXC_CONNECTION_REJECTED);   //@pw1\n                forcePrompt \u003d true;  //@prompt\n            }  //@pw3\n        }                                                                 //@pw1\n\n        AS400 as400Object;\n\n        //if the object was created with a keyring, or if the user asks for the object\n        //to be secure, clone a SecureAS400 object; otherwise, clone an AS400 object\n        if (isSecure_ || isSecure())                                        //@C2A\n        {                                                                   //@C2A\n            as400Object \u003d new SecureAS400(getServerName(), user, password); //@C2A\n        }                                                                   //@C2A\n        else\n        {                                                                //@C2A                                                                   //@C2A     \n            as400Object \u003d new AS400(getServerName(), user, password);       //@C2A\n        }                                                                   //@C2A\n\n        try                                                                 //@PDA\n        {                                                                   //@PDA\n            if(!as400_.isThreadUsed())                                      //@PDA\n                as400Object.setThreadUsed(false);  //true by default        //@PDA\n        } catch (PropertyVetoException pve)                                 //@PDA\n        { /*ignore*/                                                        //@PDA\n        }                                                                   //@PDA\n        \n        //set gui available on the new object to false if user turned prompting off\n        try\n        {                                                                   //@C2A                                \n            if (!isPrompt())                                                //@C2A\n                as400Object.setGuiAvailable(false);                         //@C2A\n        }                                                                   //@C2A\n        catch (PropertyVetoException pve)                                   //@C2A\n        { /*ignore*/                                                        //@C2A\n        }                                                                   //@C2A\n        \n        if(forcePrompt)                  //@prompt\n            as400Object.forcePrompt();   //@prompt\n        \n        return getConnection(as400Object);                                  //@C2A\n\n        //@C2D return getConnection(new AS400(getServerName(), user, password));\n    }\n\n\n    /**\n    *  Creates the database connection based on the signon and property information.\n    *  @param as400 The AS400 object used to make the connection.\n    *  @exception SQLException If a database error occurs.\n    **/\n    private Connection getConnection(AS400 as400) throws SQLException\n    {\n        // Set the socket properties, if there are any, on the AS400 object before making a connection.\n        if(sockProps_ !\u003d null){\n            as400.setSocketProperties(sockProps_);\n        }else\n        {\n            if(JDTrace.isTraceOn())\n                JDTrace.logInformation(this, \"sockProps_:  null\");\n        }\n\n        AS400JDBCConnection connection \u003d null;\n\n        connection \u003d new AS400JDBCConnection();    \n\n        connection.setSystem(as400);\n        connection.setProperties(new JDDataSourceURL(TOOLBOX_DRIVER + \"//\" + as400.getSystemName()), properties_, as400); //@C1C\n\n        log(ResourceBundleLoader.getText(\"AS400_JDBC_DS_CONN_CREATED\"));     //@A9C\n        return connection;\n    }\n    \n    //@cc1\n    /**\n     * This method returns the concurrent access resolution setting.\n     * This method has no effect on IBM i V6R1 or earlier.\n     * The possible values for this property are {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_NOT_SET}, \n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_USE_CURRENTLY_COMMITTED}, \n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_WAIT_FOR_OUTCOME} and\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_SKIP_LOCKS}, \n     * with the property defaulting to {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_NOT_SET}.  \n     * Setting this property to default exhibits the default behavior on the servers  \n     * i.e., the semantic applied for read \n     * transactions to avoid locks will be determined by the server.          \n     *\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_USE_CURRENTLY_COMMITTED} specifies that driver will flow USE CURRENTLY COMMITTED \n     * to server.  Whether CURRENTLY COMMITTED will actually be in effect is\n     * ultimately determined by server. \n     *\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_WAIT_FOR_OUTCOME} specifies that driver will flow WAIT FOR OUTCOME\n     * to server.  This will disable the CURRENTLY COMMITTED behavior at the server,\n     * if enabled, and the server will wait for the commit or rollback of data in the process of\n     * being updated.  \n     * \n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_SKIP_LOCKS} specifies that driver will flow SKIP LOCKS\n     * to server.  This directs the database manager to skip records in the case of record lock conflicts. \n     *   \n     * @return  The concurrent access resolution setting.    Possible return valuse:\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_NOT_SET}, \n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_USE_CURRENTLY_COMMITTED},\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_WAIT_FOR_OUTCOME}, or\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_SKIP_LOCKS}\n     */\n    public int getConcurrentAccessResolution ()\n    {\n        return properties_.getInt(JDProperties.CONCURRENT_ACCESS_RESOLUTION);\n    }\n\n    //@C8A\n    /**\n    *  Returns the value of the cursor sensitivity property.  If the resultSetType is \n    *  ResultSet.TYPE_FORWARD_ONLY or ResultSet.TYPE_SCROLL_SENSITIVE, the value of this property\n    *  will control what cursor sensitivity is requested from the database.  If the resultSetType\n    *  is ResultSet.TYPE_SCROLL_INSENSITIVE, this property will be ignored.\n    *  @return The cursor sensitivity.  \n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \"asensitive\"\n    *    \u003cli\u003e \"insensitive\"\n    *    \u003cli\u003e \"sensitive\"\n    *  \u003c/ul\u003e\n    *  The default is \"asensitive\".\n    *\n    *  This property is ignored when connecting to systems\n    *  running OS/400 V5R1 and earlier.   \n    **/\n    public String getCursorSensitivity()\n    {\n        return properties_.getString(JDProperties.CURSOR_SENSITIVITY);      \n    }\n\n\n    /**\n    *  Returns the database name property.  For more information see\n    *  the documentation for the setDatabaseName() method in this class.\n    *  @return The database name.\n    **/\n    public String getDatabaseName()\n    {\n        // @J2d return databaseName_;\n        return properties_.getString(JDProperties.DATABASE_NAME);      // @J2a\n    }\n\n    /**\n    *  Returns the data source name property.\n    *  This property is used to name an underlying data source when connection pooling is used.\n    *  @return The data source name.\n    **/\n    public String getDataSourceName()\n    {\n        return dataSourceName_;\n    }\n\n    /**\n    *  Returns the IBM i date format used in date literals within SQL statements.\n    *  @return The date format.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \"mdy\"\n    *    \u003cli\u003e \"dmy\"\n    *    \u003cli\u003e \"ymd\"\n    *    \u003cli\u003e \"usa\"\n    *    \u003cli\u003e \"iso\"\n    *    \u003cli\u003e \"eur\"\n    *    \u003cli\u003e \"jis\"\n    *    \u003cli\u003e \"julian\"\n    *    \u003cli\u003e \"\"  (server job value) - default.\n    *  \u003c/ul\u003e\n    *  The default is based on the server job.\n    **/\n    public String getDateFormat()\n    {\n        return properties_.getString(JDProperties.DATE_FORMAT);\n    }\n\n    /**\n    *  Returns the IBM i date separator used in date literals within SQL statements.\n    *  This property has no effect unless the \"data format\" property is set to:\n    *  \"julian\", \"mdy\", \"dmy\", or \"ymd\".\n    *  @return The date separator.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \"/\" (slash)\n    *    \u003cli\u003e \"-\" (dash)\n    *    \u003cli\u003e \".\" (period)\n    *    \u003cli\u003e \",\" (comma)\n    *    \u003cli\u003e \" \" (space)\n    *    \u003cli\u003e \"\"  (server job value) - default.\n    *  \u003c/ul\u003e\n    *  The default value is based on the server job.\n    **/\n    public String getDateSeparator()\n    {\n        return properties_.getString(JDProperties.DATE_SEPARATOR);\n    }\n\n    //@DFA\n    /**\n    *  Returns the decfloat rounding mode.\n    *  @return The decfloat rounding mode.\n    *   \u003cp\u003eValid values include:\n    *   \u003cul\u003e\n    *   \u003cli\u003e\"half even\" - default\n    *   \u003cli\u003e\"half up\" \n    *   \u003cli\u003e\"down\" \n    *   \u003cli\u003e\"ceiling\" \n    *   \u003cli\u003e\"floor\" \n    *   \u003cli\u003e\"half down\" \n    *   \u003cli\u003e\"up\" \n    *   \u003c/ul\u003e\n    **/\n    public String getDecfloatRoundingMode()\n    {\n        return properties_.getString(JDProperties.DECFLOAT_ROUNDING_MODE);\n    }\n     \n    /**\n    *  Returns the IBM i decimal separator used in numeric literals within SQL statements.\n    *  @return The decimal separator.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \".\" (period)\n    *    \u003cli\u003e \",\" (comma)\n    *    \u003cli\u003e \"\"  (server job value) - default.\n    *  \u003c/ul\u003e\n    *  The default value is based on the server job.\n    **/\n    public String getDecimalSeparator()\n    {\n        return properties_.getString(JDProperties.DECIMAL_SEPARATOR);\n    }\n\n    //@igwrn\n    /**\n    *  Returns the ignore warnings property.\n    *  Specifies a list of SQL states for which the driver should not create warning objects.\n    *  @return The ignore warnings.\n    **/\n    public String getIgnoreWarnings()\n    {\n        return properties_.getString(JDProperties.IGNORE_WARNINGS);\n    }\n    \n    \n    /**\n    *  Returns the description of the data source.\n    *  @return The description.\n    **/\n    public String getDescription()\n    {\n        return description_;\n    }\n\n    // @A2A\n    /**\n    * Returns the JDBC driver implementation.\n    * This property has no\n    * effect if the \"secondary URL\" property is set.\n    * This property cannot be set to \"native\" if the\n    * environment is not an IBM i Java Virtual Machine.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *  \u003cli\u003e\"toolbox\" (use the IBM Toolbox for Java JDBC driver)\n    *  \u003cli\u003e\"native\" (use the IBM Developer Kit for Java JDBC driver)\n    *  \u003c/ul\u003e\n    *  The default value is \"toolbox\".\n    *  Note:  Not supported in a connection pool.\n    **/\n    public String getDriver()\n    {\n        return properties_.getString(JDProperties.DRIVER);\n    }\n\n    /**\n    *  Returns the amount of detail for error messages originating from\n    *  the IBM i system.\n    *  @return The error message level.\n    *  Valid values include: \"basic\" and \"full\".  The default value is \"basic\".\n    **/\n    public String getErrors()\n    {\n        return properties_.getString(JDProperties.ERRORS);\n    }\n\n    /**\n    *  Returns the IBM i system libraries to add to the server job\u0027s library list.\n    *  The libraries are delimited by commas or spaces, and\n    *  \"*LIBL\" may be used as a place holder for the server job\u0027s\n    *  current library list.  The library list is used for resolving\n    *  unqualified stored procedure calls and finding schemas in\n    *  DatabaseMetaData catalog methods.  If \"*LIBL\" is not specified,\n    *  the specified libraries will replace the server job\u0027s current library list.\n    *  @return The library list.\n    **/\n    public String getLibraries()\n    {\n        return properties_.getString(JDProperties.LIBRARIES);\n    }\n\n    /**\n    *  Returns the maximum LOB (large object) size in bytes that\n    *  can be retrieved as part of a result set.  LOBs that are larger\n    *  than this threshold will be retrieved in pieces using extra\n    *  communication to the system.  Larger LOB thresholds will reduce\n    *  the frequency of communication to the system, but will download\n    *  more LOB data, even if it is not used.  Smaller LOB thresholds may\n    *  increase frequency of communication to the system, but will only\n    *  download LOB data as it is needed.\n    *  @return The lob threshold.  Valid range is 0-16777216.\n    *  The default value is 32768.\n    **/\n    public int getLobThreshold()\n    {\n        return properties_.getInt(JDProperties.LOB_THRESHOLD);\n    }\n\n    /**\n    *  Returns the timeout value in seconds.\n    *  Note: This value is not used or supported.\n    *  The timeout value is determined by the IBM i system.\n    *  @return the maximum time in seconds that this data source can wait while attempting to connect to a database. \n    **/\n    public int getLoginTimeout()\n    {\n        return properties_.getInt(JDProperties.LOGIN_TIMEOUT);\n    }\n\n    /**\n    *  Returns the log writer for this data source.\n    *  @return The log writer for this data source.\n    *  @exception SQLException If a database error occurs.\n    **/\n    public PrintWriter getLogWriter() throws SQLException\n    {\n        return writer_;\n    }\n\n    //@PDA\n    /**                                                               \n    *  Indicates how to retrieve DatabaseMetaData.\n    *  If set to 0, database metadata will be retrieved through the ROI data flow.  \n    *  If set to 1, database metadata will be retrieved by calling system stored procedures. \n    *  The methods that currently are available through stored procedures are:\n    *  getColumnPrivileges\n    *  @return the metadata setting.\n    *  The default value is 1.\n    **/\n    public int getMetaDataSource()\n    {\n        return properties_.getInt(JDProperties.METADATA_SOURCE);\n    }\n    \n    //@dup\n    /**                                                               \n     *  Indicates how to retrieve DatabaseMetaData.\n     *  If set to 0, database metadata will be retrieved through the ROI data flow.  \n     *  If set to 1, database metadata will be retrieved by calling system stored procedures. \n     *  The methods that currently are available through stored procedures are:\n     *  getColumnPrivileges\n     *  @return the metadata setting.\n     *  The default value is 1.\n     *  Note:  this method is the same as getMetaDataSource() so that it corresponds to the connection property name\n     **/\n    public int getMetadataSource()\n    {\n        return getMetaDataSource();\n    }\n    \n    /**\n    *  Returns the naming convention used when referring to tables.\n    *  @return The naming convention.  Valid values include: \"sql\" (e.g. schema.table)\n    *  and \"system\" (e.g. schema/table).  The default value is \"sql\".\n    **/\n    public String getNaming()\n    {\n        return properties_.getString(JDProperties.NAMING);\n    }\n\n    /**\n    *  Returns the base name of the SQL package.  Note that only the\n    *  first six characters are used to generate the name of the SQL package on the system.  \n    *  This property has no effect unless\n    *  the extended dynamic property is set to true.  In addition, this property\n    *  must be set if the extended dynamic property is set to true.\n    *  @return The base name of the SQL package.\n    **/\n    public String getPackage()\n    {\n        return properties_.getString(JDProperties.PACKAGE);\n    }\n\n    /**\n    *  Returns the type of SQL statement to be stored in the SQL package.  This can\n    *  be useful to improve the performance of complex join conditions.  This\n    *  property has no effect unless the extended dynamic property is set to true.\n    *  @return The type of SQL statement.\n    *  Valid values include: \"default\" (only store SQL statements with parameter\n    *  markers in the package) and \"select\" (store all SQL SELECT statements\n    *  in the package).  The default value is \"default\".\n    **/\n    public String getPackageCriteria()\n    {\n        return properties_.getString(JDProperties.PACKAGE_CRITERIA);\n    }\n\n    /**\n    *  Returns the action to take when SQL package errors occur.  When an SQL package\n    *  error occurs, the driver will optionally throw an SQLException or post a\n    *  warning to the Connection, based on the value of this property.  This property\n    *  has no effect unless the extended dynamic property is set to true.\n    *  @return The action to take when SQL errors occur.\n    *  Valid values include: \"exception\", \"warning\", and \"none\".  The default value is \"warning\".\n    **/\n    public String getPackageError()\n    {\n        return properties_.getString(JDProperties.PACKAGE_ERROR);\n    }\n    /**\n    *  Returns the library for the SQL package.  This property has no effect unless\n    *  the extended dynamic property is set to true.\n    *  @return The SQL package library.  The default package library is \"QGPL\".\n    **/\n    public String getPackageLibrary()\n    {\n        return properties_.getString(JDProperties.PACKAGE_LIBRARY);\n    }\n\n    /**\n    *  Returns the name of the proxy server.\n    *  @return The proxy server.\n    **/\n    public String getProxyServer()\n    {\n        return properties_.getString(JDProperties.PROXY_SERVER);\n    }\n\n    /**\n    *  Returns the Reference object for the data source object.\n    *  This is used by JNDI when bound in a JNDI naming service.\n    *  Contains the information necessary to reconstruct the data source\n    *  object when it is later retrieved from JNDI via an object factory.\n    *\n    *  @return A Reference object of the data source object.\n    *  @exception NamingException If a naming error occurs in resolving the object.\n    **/\n    public Reference getReference() throws NamingException\n    {\n    \t\n    \tTrace.log(Trace.INFORMATION, \"AS400JDBCDataSource.getReference\"); \n\n        Reference ref \u003d new Reference(this.getClass().getName(),\n                                      \"com.ibm.as400.access.AS400JDBCObjectFactory\",\n                                      null);\n\n        // Add the JDBC properties.\n        DriverPropertyInfo[] propertyList \u003d properties_.getInfo();\n        for (int i\u003d0; i\u003c propertyList.length; i++)\n        {\n            if (propertyList[i].value !\u003d null)\n                ref.add(new StringRefAddr(propertyList[i].name, propertyList[i].value));\n        }\n\n        // Add the Socket options\n        if (sockProps_.keepAliveSet_) ref.add(new StringRefAddr(SOCKET_KEEP_ALIVE, (sockProps_.keepAlive_ ? \"true\" : \"false\")));\n        if (sockProps_.receiveBufferSizeSet_) ref.add(new StringRefAddr(SOCKET_RECEIVE_BUFFER_SIZE, Integer.toString(sockProps_.receiveBufferSize_)));\n        if (sockProps_.sendBufferSizeSet_) ref.add(new StringRefAddr(SOCKET_SEND_BUFFER_SIZE, Integer.toString(sockProps_.sendBufferSize_)));\n        if (sockProps_.soLingerSet_) ref.add(new StringRefAddr(SOCKET_LINGER, Integer.toString(sockProps_.soLinger_)));\n        if (sockProps_.soTimeoutSet_) ref.add(new StringRefAddr(SOCKET_TIMEOUT, Integer.toString(sockProps_.soTimeout_)));\n        if (sockProps_.loginTimeoutSet_) ref.add(new StringRefAddr(SOCKET_LOGIN_TIMEOUT, Integer.toString(sockProps_.loginTimeout_))); //@st3\n        if (sockProps_.tcpNoDelaySet_) ref.add(new StringRefAddr(SOCKET_TCP_NO_DELAY, (sockProps_.tcpNoDelay_ ? \"true\" : \"false\")));\n\n        // Add the data source properties.  (unique constant identifiers for storing in JNDI).\n        if (getDatabaseName() !\u003d null)\n            ref.add(new StringRefAddr(DATABASE_NAME, getDatabaseName()));\n        if (getDataSourceName() !\u003d null)\n            ref.add(new StringRefAddr(DATASOURCE_NAME, getDataSourceName()));\n        if (getDescription() !\u003d null)\n            ref.add(new StringRefAddr(DESCRIPTION, getDescription()));\n        ref.add(new StringRefAddr(SERVER_NAME, getServerName()));\n        ref.add(new StringRefAddr(USER, getUser()));\n        ref.add(new StringRefAddr(KEY_RING_NAME, serialKeyRingName_));                             // @F0A\n        if (savePasswordWhenSerialized_) {                                                         // @F0A\n            ref.add(new StringRefAddr(PASSWORD, new String(serialPWBytes_)));                      // @F0A\n            if (serialKeyRingPWBytes_ !\u003d null)                                                     // @F0A\n                ref.add(new StringRefAddr(KEY_RING_PASSWORD, new String(serialKeyRingPWBytes_)));  // @F0A\n            else                                                                                   // @F0A\n                ref.add(new StringRefAddr(KEY_RING_PASSWORD, null));                               // @F0A\n        }                                                                                          // @F0A\n        ref.add(new StringRefAddr(SECURE, (isSecure_ ? TRUE_ : FALSE_)));                          // @F0A\n        ref.add(new StringRefAddr(SAVE_PASSWORD, (savePasswordWhenSerialized_ ? TRUE_ : FALSE_))); // @F0A\n\n        return ref;\n    }\n\n    /**\n    *  Returns the source of the text for REMARKS columns in ResultSets returned\n    *  by DatabaseMetaData methods.\n    *  @return The text source.\n    *  Valid values include: \"sql\" (SQL object comment) and \"system\" (IBM i object description).\n    *  The default value is \"system\".\n    **/\n    public String getRemarks()\n    {\n        return properties_.getString(JDProperties.REMARKS);\n    }\n\n    /**\n    *  Returns the secondary URL.\n    *  @return The secondary URL.\n    **/\n    public String getSecondaryUrl()\n    {\n        return properties_.getString(JDProperties.SECONDARY_URL);\n    }\n\n    //@dup\n    /**\n     *  Returns the secondary URL.\n     *  @return The secondary URL.\n     *  Note:  this method is the same as setSecondaryUrl() so that it corresponds to the connection property name\n     **/\n    public String getSecondaryURL()\n    {\n        return getSecondaryUrl();\n    }\n    \n     \n    /**\n    *  Returns the name of the IBM i system.\n    *  @return The system name.\n    **/\n    public String getServerName()\n    {\n        return as400_.getSystemName();\n    }\n\n\n    // @j1 new method\n    /**\n    *  Returns the level of tracing started on the JDBC server job.\n    *  If tracing is enabled, tracing is started when\n    *  the client connects to the system and ends when the connection\n    *  is disconnected.  Tracing must be started before connecting to\n    *  the system since the client enables system tracing only at connect time.\n    *  Trace data is collected in spooled files on the system.  Multiple\n    *  levels of tracing can be turned on in combination by adding\n    *  the constants and passing that sum on the set method.  For example,\n    *  \u003cpre\u003e\n    *  dataSource.setServerTraceCategories(AS400JDBCDataSource.SERVER_TRACE_START_DATABASE_MONITOR + AS400JDBCDataSource.SERVER_TRACE_SAVE_SERVER_JOBLOG);\n    *  \u003c/pre\u003e\n    *  @return The tracing level.\n    *  \u003cp\u003eThe value is a combination of the following:\n    *  \u003cul\u003e\n    *  \u003cli\u003eSERVER_TRACE_START_DATABASE_MONITOR - Start the database monitor on the JDBC server job.\n    *                               The numeric value of this constant is 2.\n    *  \u003cLI\u003eSERVER_TRACE_DEBUG_SERVER_JOB - Start debug on the JDBC server job.\n    *                         The numeric value of this constant is 4.\n    *  \u003cLI\u003eSERVER_TRACE_SAVE_SERVER_JOBLOG - Save the joblog when the JDBC server job ends.\n    *                           The numeric value of this constant is 8.\n    *  \u003cLI\u003eSERVER_TRACE_TRACE_SERVER_JOB - Start job trace on the JDBC server job.\n    *                         The numeric value of this constant is 16.\n    *  \u003cLI\u003eSERVER_TRACE_SAVE_SQL_INFORMATION - Save SQL information.\n    *                             The numeric value of this constant is 32.\n    *  \u003c/ul\u003e\n    *\n    *  \u003cP\u003e\n    *  Tracing the JDBC server job will use significant amounts of system resources.\n    *  Additional processor resource is used to collect the data, and additional\n    *  storage is used to save the data.  Turn on tracing only to debug\n    *  a problem as directed by IBM service.\n    *\n    **/\n    public int getServerTraceCategories()\n    {\n        return properties_.getInt(JDProperties.TRACE_SERVER);\n    }\n    \n    //@dup\n    /**\n     *  Returns the level of tracing started on the JDBC server job.\n     *  If tracing is enabled, tracing is started when\n     *  the client connects to the system and ends when the connection\n     *  is disconnected.  Tracing must be started before connecting to\n     *  the system since the client enables system tracing only at connect time.\n     *  Trace data is collected in spooled files on the system.  Multiple\n     *  levels of tracing can be turned on in combination by adding\n     *  the constants and passing that sum on the set method.  For example,\n     *  \u003cpre\u003e\n     *  dataSource.setServerTraceCategories(AS400JDBCDataSource.SERVER_TRACE_START_DATABASE_MONITOR + AS400JDBCDataSource.SERVER_TRACE_SAVE_SERVER_JOBLOG);\n     *  \u003c/pre\u003e\n     *  @return The tracing level.\n     *  \u003cp\u003eThe value is a combination of the following:\n     *  \u003cul\u003e\n     *  \u003cli\u003eSERVER_TRACE_START_DATABASE_MONITOR - Start the database monitor on the JDBC server job.\n     *                               The numeric value of this constant is 2.\n     *  \u003cLI\u003eSERVER_TRACE_DEBUG_SERVER_JOB - Start debug on the JDBC server job.\n     *                         The numeric value of this constant is 4.\n     *  \u003cLI\u003eSERVER_TRACE_SAVE_SERVER_JOBLOG - Save the joblog when the JDBC server job ends.\n     *                           The numeric value of this constant is 8.\n     *  \u003cLI\u003eSERVER_TRACE_TRACE_SERVER_JOB - Start job trace on the JDBC server job.\n     *                         The numeric value of this constant is 16.\n     *  \u003cLI\u003eSERVER_TRACE_SAVE_SQL_INFORMATION - Save SQL information.\n     *                             The numeric value of this constant is 32.\n     *  \u003c/ul\u003e\n     *\n     *  \u003cP\u003e\n     *  Tracing the JDBC server job will use significant amounts of system resources.\n     *  Additional processor resource is used to collect the data, and additional\n     *  storage is used to save the data.  Turn on tracing only to debug\n     *  a problem as directed by IBM service.\n     *\n     *  Note:  this method is the same as getServerTraceCategories() so that it corresponds to the connection property name\n     **/\n     public int getServerTrace()\n     {\n         return getServerTraceCategories();\n     }\n\n     //@STIMEOUT\n     /**\n      * Gets the socket timeout option in milliseconds.\n      * @return The value of the socket timeout option.\n      **/\n     public int getSocketTimeout()\n     {\n         return getSoTimeout(); \n     }\n      \n    /**\n    *  Returns how the system sorts records before sending them to the \n    *  client.\n    *  @return The sort value.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e\"hex\" (base the sort on hexadecimal values)\n    *    \u003cli\u003e\"language\" (base the sort on the language set in the sort language property)\n    *    \u003cli\u003e \"table\" (base the sort on the sort sequence table set in the sort table property)\n    *  \u003c/ul\u003e\n    *  The default value is \"hex\".\n    **/\n    public String getSort()\n    {\n        return properties_.getString(JDProperties.SORT);\n    }\n\n    /**\n    *  Returns the three-character language id to use for selection of a sort sequence.\n    *  @return The three-character language id.\n    *  The default value is ENU.\n    **/\n    public String getSortLanguage()\n    {\n        return properties_.getString(JDProperties.SORT_LANGUAGE);\n    }\n\n    /**\n    *  Returns the library and file name of a sort sequence table stored on the\n    *  system.\n    *  @return The qualified sort table name.\n    **/\n    public String getSortTable()\n    {\n        return properties_.getString(JDProperties.SORT_TABLE);\n    }\n\n    /**\n    *  Returns how the system treats case while sorting records.\n    *  @return The sort weight.\n    *  Valid values include: \"shared\" (upper- and lower-case characters are sorted as the\n    *  same character) and \"unique\" (upper- and lower-case characters are sorted as\n    *  different characters).  The default value is \"shared\".\n    **/\n    public String getSortWeight()\n    {\n        return properties_.getString(JDProperties.SORT_WEIGHT);\n    }\n\n    /**\n    *  Returns the time format used in time literals with SQL statements.\n    *  @return The time format.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \"hms\"\n    *    \u003cli\u003e \"usa\"\n    *    \u003cli\u003e \"iso\"\n    *    \u003cli\u003e \"eur\"\n    *    \u003cli\u003e \"jis\"\n    *    \u003cli\u003e \"\"  (server job value) - default.\n    *  \u003c/ul\u003e\n    *  The default value is based on the server job.\n    **/\n    public String getTimeFormat()\n    {\n        return properties_.getString(JDProperties.TIME_FORMAT);\n    }\n\n    /**\n    *  Returns the time separator used in time literals within SQL \n    *  statements.\n    *  @return The time separator.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \":\" (colon)\n    *    \u003cli\u003e \".\" (period)\n    *    \u003cli\u003e \",\" (comma)\n    *    \u003cli\u003e \" \" (space)\n    *    \u003cli\u003e \"\"  (server job value) - default.\n    *  \u003c/ul\u003e\n    *  The default value is based on the server job.\n    **/\n    public String getTimeSeparator()\n    {\n        return properties_.getString(JDProperties.TIME_SEPARATOR);\n    }\n\n\n    /**\n    *  Returns the system\u0027s transaction isolation.\n    *  @return The transaction isolation level.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \"none\"\n    *    \u003cli\u003e \"read uncommitted\"  - The default value.\n    *    \u003cli\u003e \"read committed\"\n    *    \u003cli\u003e \"repeatable read\"\n    *    \u003cli\u003e \"serializable\"\n    *  \u003c/ul\u003e\n    **/\n    public String getTransactionIsolation()\n    {\n        return properties_.getString(JDProperties.TRANSACTION_ISOLATION);\n    }\n\n\n    // @J3 No change needeadd code here.  UID already properly serialized\n    /**\n    *  Returns the database user property.\n    *  @return The user.\n    **/\n    public String getUser()\n    {\n        return as400_.getUserId();\n    }\n\n    // @K3A\n    /**\n    *  Returns the QAQQINI library name.\n    *  @return The QAQQINI library name.\n    **/\n    public String getQaqqiniLibrary()\n    {\n        return properties_.getString(JDProperties.QAQQINILIB);\n    }\n    \n    //@dup\n    /**\n     *  Returns the QAQQINI library name.\n     *  @return The QAQQINI library name.\n     *  Note:  this method is the same as getQaqqiniLibrary() so that it corresponds to the connection property name\n     **/\n    public String getQaqqinilib()\n    {\n        return getQaqqiniLibrary();\n    }\n     \n\n    //@540\n    /**                                                               \n    *  Returns the goal the IBM i system should use with optimization of queries.  \n    *  @return the goal the IBM i system should use with optimization of queries.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *  \u003cli\u003e0 \u003d Optimize query for first block of data (*ALLIO) when extended dynamic packages are used; Optimize query for entire result set (*FIRSTIO) when packages are not used\u003c/li\u003e\n    *  \u003cli\u003e1 \u003d Optimize query for first block of data (*FIRSTIO)\u003c/li\u003e\n    *  \u003cli\u003e2 \u003d Optimize query for entire result set (*ALLIO) \u003c/li\u003e\n    *  \u003c/ul\u003e\n    *  The default value is 0.\n    **/\n    public int getQueryOptimizeGoal()\n    {\n        return properties_.getInt(JDProperties.QUERY_OPTIMIZE_GOAL);\n    }\n\n    //@550\n    /**\n    * Returns the storage limit in megabytes, that should be used for statements executing a query in a connection.\n    * Note, this setting is ignored when running to i5/OS V5R4 or earlier\n    * You must have *JOBCTL special authority to use query storage limit with Version 6 Release 1 of IBM i.\n    * \u003cp\u003e Valid values are -1 to MAX_STORAGE_LIMIT megabytes.  \n    * The default value is -1 meaning there is no limit.\n    **/\n    public int getQueryStorageLimit()\n    {\n        return properties_.getInt(JDProperties.QUERY_STORAGE_LIMIT);\n    }\n\n   /*@D4A*/\n    /**                                                               \n    *  Returns the mechanism used to implement query timeout. \n    *  @return the mechanism used to implement query timeout.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *  \u003cli\u003eqqrytimlmt \u003d The QQRYTIMLMT will be used. \n    *  \u003cli\u003ecancel     \u003d A long running statement will be cancelled.\n    *  \u003c/ul\u003e\n    *  The default value is 0.\n    **/\n    public String getQueryTimeoutMechanism()\n    {\n        return properties_.getString(JDProperties.QUERY_TIMEOUT_MECHANISM);\n    }\n\n    //@540\n    /**                                                               \n    *  Indicates whether lock sharing is allowed for loosely coupled transaction branches.\n    *  @return the lock sharing setting.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *  \u003cli\u003e0 \u003d Locks cannot be shared\u003c/li\u003e\n    *  \u003cli\u003e1 \u003d Locks can be shared\u003c/li\u003e\n    *  \u003c/ul\u003e\n    *  The default value is 0.\n    **/\n    public int getXALooselyCoupledSupport()\n    {\n        return properties_.getInt(JDProperties.XA_LOOSELY_COUPLED_SUPPORT);\n    }\n\n    /**\n    *  Initializes the transient data for object de-serialization.\n    **/\n    private void initializeTransient()\n    {\n    \tTrace.log(Trace.INFORMATION, \"AS400JDBCDataSource.initializeTransient\"); \n\n        changes_ \u003d new PropertyChangeSupport(this);\n\n        if (isSecure_)            //@B4A  \n            as400_ \u003d new SecureAS400();         //@B4A\n        else                     //@B4A\n            as400_ \u003d new AS400();\n\n        // Reinitialize the serverName, user, password, keyRingName, etc.\n        if (serialServerName_ !\u003d null)\n            setServerName(serialServerName_);\n\n        if (serialUserName_ !\u003d null)\n        {                                                               // @J3a\n            setUser(serialUserName_);\n\n            if ((serialPWBytes_ !\u003d null) \u0026\u0026                             // @J3a\n                (serialPWBytes_.length \u003e 0))                            // @J3a\n            {                                                           // @J3a\n                as400_.setPassword(xpwDeconfuse(serialPWBytes_));        // @J3a\n            }                                                           // @J3a\n        }\n\n        try\n        {\n            if (serialKeyRingName_ !\u003d null \u0026\u0026 isSecure_)                  //@B4A\n            {                                                             //@J3a\n                if ((serialKeyRingPWBytes_ !\u003d null) \u0026\u0026                    //@J3a      \n                    (serialKeyRingPWBytes_.length \u003e 0))                   //@J3a      \n                {                                                         //@J3a\n                    String keyRingPassword \u003d xpwDeconfuse(serialKeyRingPWBytes_);  // @J3a\n                    ((SecureAS400)as400_).setKeyRingName(serialKeyRingName_, keyRingPassword); //@J3A\n                }                                                            //@J3a\n                else\n                {                                                         //@J3a                                                            //@J3a\n                    ((SecureAS400)as400_).setKeyRingName(serialKeyRingName_); //@B4A\n                }                                                            //@J3a\n            }                                                                //@J3a\n        }\n        catch (PropertyVetoException pve)\n        { /* Will never happen */\n        }\n\n        // @J4 Make sure the prompt flag is correctly de-serialized.  The problem was\n        //     the flag would get serialized with the rest of the properties \n        //     (in the properties_ object), but the flag would never be applied\n        //     to the AS400 object when de-serialzed.  De-serialization puts the\n        //     flag back in properties_ but that does no good unless the value\n        //     is passed on to the AS400 object.  That is what the new code does. \n        //     There is no affect on normal \"new\" objects since at the time this \n        //     method is called properties_ is null.\n        try\n        {                                                           //@J4A                                                             //@J4A\n            if (properties_ !\u003d null)                                   //@J4A\n                if (!isPrompt())                                        //@J4A\n                    as400_.setGuiAvailable(false);                       //@J4A\n        }                                                             //@J4A\n        catch (PropertyVetoException pve)                             //@J4A\n        { /* Will never happen */                                     //@J4A\n        }                                                             //@J4A\n\n    }\n\n    //@KBA\n    /**\n    *  Indicates whether true auto commit support is used.\n    *  @return true if true auto commit support is used; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isTrueAutoCommit()\n    {\n        return properties_.getBoolean(JDProperties.TRUE_AUTO_COMMIT); //@true\n    }\n    \n    //@dup\n    /**\n     *  Indicates whether true auto commit support is used.\n     *  @return true if true auto commit support is used; false otherwise.\n     *  The default value is false.\n     *  Note:  this method is the same as isTrueAutoCommit() so that it corresponds to the connection property name\n     **/\n    public boolean isTrueAutocommit()\n    {\n        return isTrueAutoCommit();\n    }\n     \n\n    //@K54\n    /**\n    *  Indicates whether variable-length fields are compressed.\n    *  @return true if variable-length fields are compressed; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isVariableFieldCompression()\n    {\n        return properties_.getBoolean(JDProperties.VARIABLE_FIELD_COMPRESSION);\n    }\n\n    //@AC1\n    /**\n     *  Returns whether auto-commit mode is the default connection mode for new connections.\n     *  @return Auto commit.\n     *  The default value is true.\n     **/\n     public boolean isAutoCommit()\n     {\n         return properties_.getBoolean(JDProperties.AUTO_COMMIT);\n     }\n     \n    //@CE1\n    /**\n     *  Returns whether commit or rollback throws SQLException when autocommit is enabled.\n     *  @return Autocommit Exception.\n     *  The default value is false.\n     **/\n     public boolean isAutocommitException()\n     {\n         return properties_.getBoolean(JDProperties.AUTOCOMMIT_EXCEPTION);\n     }\n     \n    //@K24\n    /**\n    *  Indicates whether bidi implicit reordering is used.\n    *  @return true if bidi implicit reordering is used; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isBidiImplicitReordering()\n    {\n        return properties_.getBoolean(JDProperties.BIDI_IMPLICIT_REORDERING);\n    }\n\n    //@K24\n    /**\n    *  Indicates whether bidi numeric ordering round trip is used.\n    *  @return true if bidi numeric ordering round trip is used; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isBidiNumericOrdering()\n    {\n        return properties_.getBoolean(JDProperties.BIDI_NUMERIC_ORDERING);\n    }\n\n    /**\n    *  Indicates whether a big decimal value is returned.\n    *  @return true if a big decimal is returned; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isBigDecimal()\n    {\n        return properties_.getBoolean(JDProperties.BIG_DECIMAL);\n    }\n\n    /**\n    *  Indicates whether the cursor is held.\n    *  @return true if the cursor is held; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isCursorHold()\n    {\n        return properties_.getBoolean(JDProperties.CURSOR_HOLD);\n    }\n\n    /**\n    *  Indicates whether data compression is used.\n    *  @return true if data compression is used; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isDataCompression()\n    {\n        return properties_.getBoolean(JDProperties.DATA_COMPRESSION);\n    }\n\n    /**\n    *  Indicates whether data truncation is used.\n    *  @return true if data truncation is used; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isDataTruncation()\n    {\n        return properties_.getBoolean(JDProperties.DATA_TRUNCATION);\n    }\n\n    /**\n    *  Indicates whether extended dynamic support is used.  Extended dynamic\n    *  support provides a mechanism for caching dynamic SQL statements on\n    *  the system.  The first time a particular SQL statement is prepared, it is\n    *  stored in an SQL package on the system.  \n    *  If the package does not exist, it will be automatically created.\n    *  On subsequent prepares of the\n    *  same SQL statement, the system can skip a significant part of the\n    *  processing by using information stored in the SQL package.\n    *  @return true if extended dynamic support is used; false otherwise.\n    *  The default value is not to use extended dynamic support.\n    **/\n    public boolean isExtendedDynamic()\n    {\n        return properties_.getBoolean(JDProperties.EXTENDED_DYNAMIC);\n    }\n\n\n    // @C3A\n    /**\n    *  Indicates whether the driver should request extended metadata from the\n    *  IBM i system.  If this property is set to true, the accuracy of the information \n    *  that is returned from ResultSetMetaData methods getColumnLabel(int),\n    *  isReadOnly(int), isSearchable(int), and isWriteable(int) will be increased.\n    *  In addition, the ResultSetMetaData method getSchemaName(int) will be supported with this \n    *  property set to true.  However, performance will be slower with this \n    *  property on.  Leave this property set to its default (false) unless you\n    *  need more specific information from those methods.\n    *\n    *  For example, without this property turned on, isSearchable(int) will \n    *  always return true even though the correct answer may be false because \n    *  the driver does not have enough information from the system to make a judgment.  Setting \n    *  this property to true forces the driver to get the correct data from the IBM i system.\n    *\n    *  @return true if extended metadata will be requested; false otherwise.\n    *  The default value is false.\n    **/\n\n    public boolean isExtendedMetaData()\n    {\n        return properties_.getBoolean(JDProperties.EXTENDED_METADATA);\n    }\n    \n    //@dup\n    /**\n     *  Indicates whether the driver should request extended metadata from the\n     *  IBM i system.  If this property is set to true, the accuracy of the information \n     *  that is returned from ResultSetMetaData methods getColumnLabel(int),\n     *  isReadOnly(int), isSearchable(int), and isWriteable(int) will be increased.\n     *  In addition, the ResultSetMetaData method getSchemaName(int) will be supported with this \n     *  property set to true.  However, performance will be slower with this \n     *  property on.  Leave this property set to its default (false) unless you\n     *  need more specific information from those methods.\n     *\n     *  For example, without this property turned on, isSearchable(int) will \n     *  always return true even though the correct answer may be false because \n     *  the driver does not have enough information from the system to make a judgment.  Setting \n     *  this property to true forces the driver to get the correct data from the IBM i system.\n     *\n     *  @return true if extended metadata will be requested; false otherwise.\n     *  The default value is false.\n     *  Note:  this method is the same as isExtendedMetaData() so that it corresponds to the connection property name\n     **/\n\n    public boolean isExtendedMetadata()\n    {\n        return isExtendedMetaData();\n    }\n\n\n    // @W1a\n    /**\n    *  Indicates whether the IBM i system fully opens a file when performing a query.\n    *  By default the system optimizes opens so they perform better.  In\n    *  certain cases an optimized open will fail.  In some\n    *  cases a query will fail when a database performance monitor\n    *  is turned on even though the same query works with the monitor\n    *  turned off.  In this case set the full open property to true.\n    *  This disables optimization on the system.\n    *  @return true if files are fully opened; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isFullOpen()\n    {\n        return properties_.getBoolean(JDProperties.FULL_OPEN);\n    }\n\n    //@dmy\n    /**\n    *  Indicates whether the temporary fix for JVM 1.6 is enabled.\n    *  @return true if enabled; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isJvm16Synchronize()\n    {\n        return properties_.getBoolean(JDProperties.JVM16_SYNCHRONIZE);\n    }\n\n    // @A1A\n    /**\n    *  Indicates whether to delay closing cursors until subsequent requests.\n    *  @return true to delay closing cursors until subsequent requests; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isLazyClose()\n    {\n        return properties_.getBoolean(JDProperties.LAZY_CLOSE);\n    }\n\n    //@KBL\n    /**\n    *  Indicates whether input locators are of type hold.\n    *  @return true if input locators are of type hold; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isHoldInputLocators()\n    {\n        return properties_.getBoolean(JDProperties.HOLD_LOCATORS);\n    }\n\n    /**\n    *  Indicates whether to add newly prepared statements to the   \n    *  SQL package specified on the \"package\" property.  This property\n    *  has no effect unless the extended dynamic property is set to true;\n    *  @return true If newly prepared statements should be added to the SQL package specified \n    *  on the \"package\" property; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isPackageAdd()\n    {\n        return properties_.getBoolean(JDProperties.PACKAGE_ADD);\n    }\n\n    /**\n    *  Indicates whether a subset of the SQL package information is cached in client memory.  \n    *  Caching SQL packages locally\n    *  reduces the amount of communication to the IBM i system for prepares and describes.  This\n    *  property has no effect unless the extended dynamic property is set to true.\n    *  @return true if caching is used; false otherwise.\n    *  The defalut value is false.\n    **/\n    public boolean isPackageCache()\n    {\n        return properties_.getBoolean(JDProperties.PACKAGE_CACHE);\n    }\n\n    //@C6D Deprecated method.\n    /**\n    *  Indicates whether SQL packages are cleared when they become full.  This method\n    *  has been deprecated.  Package clearing and the decision for the \n    *  threshold where package clearing is needed is now handled\n    *  automatically by the database.  \n    *  @return Always false.  This method is deprecated.\n    *  @deprecated\n    **/\n    public boolean isPackageClear()\n    {\n        //@C6D return properties_.getBoolean(JDProperties.PACKAGE_CLEAR);\n        return false;  //@C6A\n    }\n\n    /**\n    *  Indicates whether data is prefetched upon executing a SELECT statement.\n    *  This will increase performance when accessing the initial rows in the result set.\n    *  @return If prefetch is used; false otherwise.\n    *  The default value is prefetch data.\n    **/\n    public boolean isPrefetch()\n    {\n        return properties_.getBoolean(JDProperties.PREFETCH);\n    }\n\n    /**\n    *  Indicates whether the user is prompted if a user name or password is\n    *  needed to connect to the IBM i system.  If a connection can not be made\n    *  without prompting the user, and this property is set to false, then an\n    *  attempt to connect will fail throwing an exception.\n    *  @return true if the user is prompted for signon information; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isPrompt()\n    {\n        return properties_.getBoolean(JDProperties.PROMPT);\n    }\n\n    //@K94\n    /**\n    *  Indicates whether the cursor is held after a rollback.\n    *  @return true if the cursor is held; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isRollbackCursorHold()\n    {\n        return properties_.getBoolean(JDProperties.ROLLBACK_CURSOR_HOLD);\n    }\n\n    //@KBL\n    /**\n    *  Indicates whether statements remain open until a transaction boundary when autocommit is off and they\n    *  are associated with Lob locators.\n    *  @return true if statements are only closed at transaction boundaries; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isHoldStatements()\n    {\n        return properties_.getBoolean(JDProperties.HOLD_STATEMENTS);\n    }\n\n    // @J3 new method\n    /**\n    *  Indicates whether the password is saved locally with the rest of\n    *  the properties when this data source object is serialized.\n    *  \u003cP\u003e\n    *  If the password is saved, it is up to the application to protect\n    *  the serialized form of the object because it contains all necessary\n    *  information to connect to the IBM i system.  The default is false.  It\n    *  is a security risk to save the password with the rest of the\n    *  properties so by default the password is not saved.  If the programmer\n    *  chooses to accept this risk, call setSavePasswordWhenSerialized(true)\n    *  to force the Toolbox to save the password with the other properties\n    *  when the data source object is serialized.   \n    *  @return true if the password is saved with the rest of the properties when the\n    *          data source object is serialized; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isSavePasswordWhenSerialized()\n    {\n        return savePasswordWhenSerialized_;\n    }\n\n\n\n\n\n    /**\n    *  Indicates whether a Secure Socket Layer (SSL) connection is used to communicate\n    *  with the IBM i system.  SSL connections are only available when connecting to systems\n    *  at V4R4 or later.\n    *  @return true if Secure Socket Layer connection is used; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isSecure()\n    {\n        return properties_.getBoolean(JDProperties.SECURE);\n    }\n\n    //@pw3\n    /**\n     *  Returns the secure current user setting.  True indicates to disallow \"\" and *current for user name and password.\n     *  @return The secure current user setting.\n     **/\n    public boolean isSecureCurrentUser()\n    {\n        return  properties_.getBoolean(JDProperties.SECURE_CURRENT_USER);\n    }\n\n    /**\n    *  Indicates whether a thread is used.\n    *  @return true if a thread is used; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isThreadUsed()\n    {\n        return properties_.getBoolean(JDProperties.THREAD_USED);\n    }\n\n    /**\n    *  Indicates whether trace messages should be logged.\n    *  @return true if trace message are logged; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isTrace()\n    {\n        return properties_.getBoolean(JDProperties.TRACE);\n    }\n\n    /**\n    *  Indicates whether binary data is translated.  If this property is set\n    *  to true, then BINARY and VARBINARY fields are treated as CHAR and\n    *  VARCHAR fields.\n    *  @return true if binary data is translated; false otherwise.\n    *  The default value is false.\n    **/\n    public boolean isTranslateBinary()\n    {\n        return properties_.getBoolean(JDProperties.TRANSLATE_BINARY);\n    }\n\n    //@PDA\n    /**\n    *  Indicates how Boolean objects are interpreted when setting the value \n    *  for a character field/parameter using the PreparedStatement.setObject(), \n    *  CallableStatement.setObject() or ResultSet.updateObject() methods.  Setting the \n    *  property to \"true\", would store the Boolean object in the character field as either \n    *  \"true\" or \"false\".  Setting the property to \"false\", would store the Boolean object \n    *  in the character field as either \"1\" or \"0\".\n    *  @return true if boolean data is translated; false otherwise.\n    *  The default value is true.\n    **/\n    public boolean isTranslateBoolean()\n    {\n        return properties_.getBoolean(JDProperties.TRANSLATE_BOOLEAN);\n    }\n     \n    \n    /**\n     *  Indicates whether blocking is used for update and delete operations\n     *  @return true if enabled; false otherwise.\n     *  The default value is false.\n     **/\n     public boolean isUseBlockUpdate()\n     {\n         return properties_.getBoolean(JDProperties.DO_UPDATE_DELETE_BLOCKING);\n     }\n\n\n    /**\n    *  Logs a message to the event log.\n    *  @param message The message to log.\n    **/\n    void log(String message)\n    {\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, message);\n\n        if (log_ !\u003d null)\n            log_.log(message);\n    }\n\n    /**\n    *  Logs an exception and message to the event log.\n    *  @param property The property to log.\n    *  @param value The property value to log.\n    **/\n    private void logProperty(String property, String value)\n    {\n        if (Trace.isTraceOn())\n            JDTrace.logProperty (this, property, value);\n\n        //@A8D if (log_ !\u003d null)\n        //@A8D log_.log(property + \": \" + value);\n    }\n\n    /**\n    *  Deserializes and initializes transient data.\n    *  @exception ClassNotFoundException If the class cannot be found.\n    *  @exception IOException If an I/O exception occurs.\n    **/\n    private void readObject(ObjectInputStream in) throws ClassNotFoundException, IOException\n    {\n        in.defaultReadObject();\n        initializeTransient();\n    }\n\n    /**\n    *  Removes the PropertyChangeListener.\n    *  If the PropertyChangeListener is not in the list, nothing is done.\n    *  @param listener The PropertyChangeListener.\n    *  @see #addPropertyChangeListener\n    **/\n    public void removePropertyChangeListener(PropertyChangeListener listener)\n    {\n        if (listener \u003d\u003d null)\n            throw new NullPointerException(\"listener\");\n        changes_.removePropertyChangeListener(listener);\n\n        as400_.removePropertyChangeListener(listener);                 //@K1C  changed to removePropertyChangeListener instead of addPropertyChangeListener\n    }\n\n    /**\n    *  Sets the level of database access for the connection.\n    *  @param access The access level.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \"all\" (all SQL statements allowed)\n    *    \u003cli\u003e \"read call\" (SELECT and CALL statements allowed)\n    *    \u003cli\u003e \"read only\" (SELECT statements only)\n    *  \u003c/ul\u003e\n    *  The default value is \"all\".\n    **/\n    public void setAccess(String access)\n    {\n        String property \u003d \"access\";\n\n        if (access \u003d\u003d null)\n            throw new NullPointerException(property);\n        validateProperty(property, access, JDProperties.ACCESS);\n\n        String old \u003d getAccess();\n        properties_.setString(JDProperties.ACCESS, access);\n\n        changes_.firePropertyChange(property, old, access);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + access);  //@A8C\n    }\n \n      //@AC1\n      /**\n      *  Sets whether auto-commit mode is the default connection mode for new connections.\n      *  @param value\n      *  The default value is true.\n      **/\n      public void setAutoCommit(boolean value)\n      {\n          String property \u003d \"autoCommit\";\n          Boolean oldValue \u003d new Boolean(isAutoCommit());\n          Boolean newValue \u003d new Boolean(value);\n\n          if (value)\n              properties_.setString(JDProperties.AUTO_COMMIT, TRUE_);\n          else\n              properties_.setString(JDProperties.AUTO_COMMIT, FALSE_);\n\n          changes_.firePropertyChange(property, oldValue, newValue);\n\n          if (JDTrace.isTraceOn()) \n              JDTrace.logInformation (this, property + \": \" + value);   \n      }\n     \n    //@CE1\n    /**\n     *  Sets whether commit or rollback throws SQLException when autocommit is enabled.\n     *  @param value\n     *  The default value is false.\n     **/\n     public void setAutocommitException(boolean value)\n     {\n         String property \u003d \"autocommitException\";\n         Boolean oldValue \u003d new Boolean(isAutocommitException());\n         Boolean newValue \u003d new Boolean(value);\n\n         if (value)\n             properties_.setString(JDProperties.AUTOCOMMIT_EXCEPTION, TRUE_);\n         else\n             properties_.setString(JDProperties.AUTOCOMMIT_EXCEPTION, FALSE_);\n\n         changes_.firePropertyChange(property, oldValue, newValue);\n\n         if (JDTrace.isTraceOn()) \n             JDTrace.logInformation (this, property + \": \" + value);   \n     }\n     \n    //@KBA\n    /**\n    *  Sets whether true auto commit support is used.\n    *  @param value true if true auto commit support should be used; false otherwise.\n    *  The default value is false.\n    **/\n    public void setTrueAutoCommit(boolean value)\n    {\n        String property \u003d \"trueAutoCommit\";\n        Boolean oldValue \u003d new Boolean(isTrueAutoCommit());\n        Boolean newValue \u003d new Boolean(value);\n\n        if (value)\n            properties_.setString(JDProperties.TRUE_AUTO_COMMIT, TRUE_); //@true\n        else\n            properties_.setString(JDProperties.TRUE_AUTO_COMMIT, FALSE_); //@true\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + value);      \n    }\n    \n    //@dup\n    /**\n     *  Sets whether true auto commit support is used.\n     *  @param value true if true auto commit support should be used; false otherwise.\n     *  The default value is false.\n     *  Note:  this method is the same as setTrueAutoCommit() so that it corresponds to the connection property nameproperty name\n     **/\n    public void setTrueAutocommit(boolean value)\n    {\n        setTrueAutoCommit(value); \n    }\n\n\n    // @C9 new method\n    /**                                                               \n    *  Sets the Toolbox JDBC Driver behaviors to override.  Multiple\n    *  behaviors can be changed in combination by adding\n    *  the constants and passing that sum on the this method. \n    *  @param behaviors The driver behaviors to override.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *  \u003cli\u003e1 - Do not throw an exception if Statement.executeQuery() or\n    *          PreparedStatement.executeQuery() do not return a result set.\n    *          Instead, return null for the result set.\n    *  \u003c/ul\u003e\n    *\n    *  Carefully consider the result of overriding the default behavior of the\n    *  driver.  For example, setting the value of this property to 1 means\n    *  the driver will no longer throw an exception even though the JDBC 3.0\n    *  specification states throwing an exception is the correct behavior.  \n    *  Be sure your application correctly handles the altered behavior.  \n    *\n    **/\n    public void setBehaviorOverride(int behaviors)\n    {\n        String property \u003d \"behaviorOverride\";\n\n        Integer oldValue \u003d new Integer(getBehaviorOverride());\n        Integer newValue \u003d new Integer(behaviors);\n\n        properties_.setString(JDProperties.BEHAVIOR_OVERRIDE, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + behaviors);\n    }\n\n\n\n\n    //@B2A\n    /**\n     *  Sets the output string type of bidi data. See \u003ca href\u003d\"BidiStringType.html\"\u003e\n     *  BidiStringType\u003c/a\u003e for more information and valid values.\n     **/\n    public void setBidiStringType(int bidiStringType)                          //@B3C\n    {\n        String property \u003d \"bidiStringType\";                                             //@B3C\n\n        //@B3D if (bidiStringType \u003d\u003d null)\n        //@B3D    throw new NullPointerException(property);\n        Integer oldBidiStringType \u003d new Integer(getBidiStringType());         //@B3A\n        Integer newBidiStringType \u003d new Integer(bidiStringType);              //@B3A\n\n        validateProperty(property, newBidiStringType.toString(), JDProperties.BIDI_STRING_TYPE); //@B3C\n\n        properties_.setString(JDProperties.BIDI_STRING_TYPE, newBidiStringType.toString());   //@B3C\n\n        changes_.firePropertyChange(property, oldBidiStringType, newBidiStringType);  //@B3C\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + bidiStringType);\n    }\n\n    //@K24\n    /**\n    *  Sets whether bidi implicit reordering is used.\n    *  In this version, the parameter is used to determine whether Bidi layout \n    *  transformation should be applied to meta-data such as columns names.\n    *  @param value true if implicit reordering should be used; false otherwise.\n    *  The default value is true.\n    **/\n    public void setBidiImplicitReordering(boolean value)\n    {\n        String property \u003d \"bidiImplicitReordering\";\n        Boolean oldValue \u003d new Boolean(isBidiImplicitReordering());\n        Boolean newValue \u003d new Boolean(value);\n\n        if (value)\n            properties_.setString(JDProperties.BIDI_IMPLICIT_REORDERING, TRUE_);\n        else\n            properties_.setString(JDProperties.BIDI_IMPLICIT_REORDERING, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + value);      \n    }\n\n    //@K24\n    /**\n    *  Sets whether bidi numeric ordering round trip is used.\n    *  @param value true if numeric ordering round trip should be used; false otherwise.\n    *  The default value is false.\n    **/\n    public void setBidiNumericOrdering(boolean value)\n    {\n        String property \u003d \"bidiNumericOrdering\";\n        Boolean oldValue \u003d new Boolean(isBidiNumericOrdering());\n        Boolean newValue \u003d new Boolean(value);\n\n        if (value)\n            properties_.setString(JDProperties.BIDI_NUMERIC_ORDERING, TRUE_);\n        else\n            properties_.setString(JDProperties.BIDI_NUMERIC_ORDERING, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + value);      \n    }\n\n    /**\n    *  Sets whether a big decimal value is returned.\n    *  @param value true if a big decimal is returned; false otherwise.\n    *  The default value is true.\n    **/\n    public void setBigDecimal(boolean value)\n    {\n        String property \u003d \"bigDecimal\";\n        Boolean oldValue \u003d new Boolean(isBigDecimal());\n        Boolean newValue \u003d new Boolean(value);\n\n        if (value)\n            properties_.setString(JDProperties.BIG_DECIMAL, TRUE_);\n        else\n            properties_.setString(JDProperties.BIG_DECIMAL, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + value);      //@A8C\n    }\n\n    /**\n    *  Sets the criteria for retrieving data from the IBM i system in\n    *  blocks of records.  Specifying a non-zero value for this property\n    *  will reduce the frequency of communication to the system, and\n    *  therefore increase performance.\n    *  @param blockCriteria The block criteria.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e 0 (no record blocking)\n    *    \u003cli\u003e 1 (block if FOR FETCH ONLY is specified)\n    *    \u003cli\u003e 2 (block if FOR UPDATE is specified) - The default value.\n    *  \u003c/ul\u003e\n    **/\n    public void setBlockCriteria(int blockCriteria)\n    {\n        String property \u003d \"blockCriteria\";\n        Integer oldCriteria \u003d new Integer(getBlockCriteria());\n        Integer newCriteria \u003d new Integer(blockCriteria);\n\n        validateProperty(property, newCriteria.toString(), JDProperties.BLOCK_CRITERIA);\n\n        properties_.setString(JDProperties.BLOCK_CRITERIA, newCriteria.toString());\n        changes_.firePropertyChange(property, oldCriteria, newCriteria);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + blockCriteria);   //@A8C\n    }\n\n    /**\n    *  Sets the block size in kilobytes to retrieve from the IBM i system and\n    *  cache on the client.  This property has no effect unless the block criteria\n    *  property is non-zero.  Larger block sizes reduce the frequency of\n    *  communication to the system, and therefore may increase performance.\n    *  @param blockSize The block size in kilobytes.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e 0\n    *    \u003cli\u003e 8\n    *    \u003cli\u003e 16\n    *    \u003cli\u003e 32  - The default value.\n    *    \u003cli\u003e 64\n    *    \u003cli\u003e 128\n    *    \u003cli\u003e 256\n    *    \u003cli\u003e 512\n    *  \u003c/ul\u003e\n    **/\n    public void setBlockSize(int blockSize)\n    {\n        String property \u003d \"blockSize\";\n\n        Integer oldBlockSize \u003d new Integer(getBlockSize());\n        Integer newBlockSize \u003d new Integer(blockSize);\n\n        validateProperty(property, newBlockSize.toString(), JDProperties.BLOCK_SIZE);\n\n        properties_.setString(JDProperties.BLOCK_SIZE, new Integer(blockSize).toString());\n        changes_.firePropertyChange(property, oldBlockSize, newBlockSize);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + blockSize);  //@A8C\n    }\n\n    //@cc1\n    /**\n     * This method sets concurrent access resolution.  This method overrides the setting of ConcurrentAccessResolution on the datasource or connection\n     * URL properties.  This method has no effect on\n     * IBM i V6R1 or earlier.\n     * The possible values for this property are {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_NOT_SET}, \n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_USE_CURRENTLY_COMMITTED}, \n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_WAIT_FOR_OUTCOME} and\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_SKIP_LOCKS}, \n     * with the property defaulting to {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_NOT_SET}.  \n     * Setting this property to default exhibits the default behavior on the servers  \n     * i.e., the semantic applied for read \n     * transactions to avoid locks will be determined by the server.          \n     *\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_USE_CURRENTLY_COMMITTED} specifies that driver will flow USE CURRENTLY COMMITTED \n     * to server.  Whether CURRENTLY COMMITTED will actually be in effect is\n     * ultimately determined by server. \n     *\n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_WAIT_FOR_OUTCOME} specifies that driver will flow WAIT FOR OUTCOME\n     * to server.  This will disable the CURRENTLY COMMITTED behavior at the server,\n     * if enabled, and the server will wait for the commit or rollback of data in the process of\n     * being updated.  \n     *   \n     * {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_SKIP_LOCKS} specifies that driver will flow SKIP LOCKS\n     * to server.  This directs the database manager to skip records in the case of record lock conflicts. \n     * \n     *  @param concurrentAccessResolution The current access resolution setting.  Possible valuse:\n     *  {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_NOT_SET}, \n     *  {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_USE_CURRENTLY_COMMITTED},\n     *  {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_WAIT_FOR_OUTCOME}, or\n     *  {@link com.ibm.as400.access.AS400JDBCDataSource#CONCURRENTACCESS_SKIP_LOCKS}\n     */\n    public void setConcurrentAccessResolution (int concurrentAccessResolution)\n    {\n        String property \u003d \"concurrentAccessResolution\";\n\n        Integer oldValue \u003d new Integer(getConcurrentAccessResolution());\n        Integer newValue \u003d new Integer(concurrentAccessResolution);\n\n        validateProperty(property, newValue.toString(), JDProperties.CONCURRENT_ACCESS_RESOLUTION);\n\n        properties_.setString(JDProperties.CONCURRENT_ACCESS_RESOLUTION, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + concurrentAccessResolution );   \n    }\n    \n    //@C8A\n    /**\n    *  Sets the cursor sensitivity to be requested from the database.  If the resultSetType is \n    *  ResultSet.TYPE_FORWARD_ONLY or ResultSet.TYPE_SCROLL_SENSITIVE, the value of this property\n    *  will control what cursor sensitivity is requested from the database.  If the resultSetType\n    *  is ResultSet.TYPE_SCROLL_INSENSITIVE, this property will be ignored.\n    *\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \"asensitive\"\n    *    \u003cli\u003e \"insensitive\"\n    *    \u003cli\u003e \"sensitive\"\n    *  \u003c/ul\u003e\n    *  The default is \"asensitive\".\n    *\n    *  This property is ignored when connecting to systems\n    *  running OS/400 V5R1 and earlier. \n    **/\n    public void setCursorSensitivity(String cursorSensitivity)\n    {\n        String property \u003d \"cursorSensitivity\";\n\n        String oldCursorSensitivity \u003d getCursorSensitivity();\n        String newCursorSensitivity \u003d cursorSensitivity;\n\n        validateProperty(property, newCursorSensitivity, JDProperties.CURSOR_SENSITIVITY);\n\n        properties_.setString(JDProperties.CURSOR_SENSITIVITY, cursorSensitivity);\n        changes_.firePropertyChange(property, oldCursorSensitivity, newCursorSensitivity);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + cursorSensitivity);\n    }\n\n\n    /**\n    *  Sets whether the cursor is held.\n    *  @param cursorHold true if the cursor is held; false otherwise.  The default value is true.\n    **/\n    public void setCursorHold(boolean cursorHold)\n    {\n        String property \u003d \"cursorHold\";\n        Boolean oldHold \u003d new Boolean(isCursorHold());\n        Boolean newHold \u003d new Boolean(cursorHold);\n\n        if (cursorHold)\n            properties_.setString(JDProperties.CURSOR_HOLD, TRUE_);\n        else\n            properties_.setString(JDProperties.CURSOR_HOLD, FALSE_);\n\n        changes_.firePropertyChange(property, oldHold, newHold);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + cursorHold);  //@A8C\n    }\n\n    /**\n    *  Sets the database name.  \n    *  This property is ignored when connecting to systems\n    *  running OS/400 V5R1 and earlier.  \n    *  If a database name is specified it must exist in the relational \n    *  database directory on the system.  Use CL command WRKRDBDIRE \n    *  to view the directory.\n    *  The following criteria are used to determine\n    *  which database is accessed:  \n    *  \u003cOL\u003e\n    *  \u003cLI\u003eIf a database name is specified, that database is used.  Attempts\n    *      to connect will fail if the database does not exist.\n    *  \u003cLI\u003eIf special value *SYSBAS is specified, the system default database is used.\n    *  \u003cLI\u003eIf a database name is not specified, the database specified\n    *      in the job description for the user profile is used.\n    *  \u003cLI\u003eIf a database name is not specified and a database is not specified\n    *      in the job description for the user profile, the system default\n    *      database is used.   \n    *  \u003c/OL\u003e\n    *  @param databaseName The database name or *SYSBAS.\n    **/\n    public void setDatabaseName(String databaseName)\n    {\n        String property \u003d DATABASE_NAME;\n\n        if (databaseName \u003d\u003d null)\n            throw new NullPointerException(property);\n\n        String old \u003d getDatabaseName();\n\n        // @J2d databaseName_ \u003d databaseName;\n        // @J2d changes_.firePropertyChange(property, old, databaseName);\n        // @J2d logProperty(\"database\", databaseName_);\n\n        properties_.setString(JDProperties.DATABASE_NAME, databaseName);      // @J2a\n        changes_.firePropertyChange(property, old, databaseName);             // @J2a\n                                                                              // @J2a\n        if (JDTrace.isTraceOn())                                              // @J2a\n            JDTrace.logInformation (this, property + \": \" + databaseName);   // @J2a \n    }\n\n    /**\n    *  Sets whether to use data compression.  The default value is true.\n    *  @param compression true if data compression is used; false otherwise.\n    **/\n    public void setDataCompression(boolean compression)\n    {\n        Boolean oldCompression \u003d new Boolean(isDataCompression());\n        Boolean newCompression \u003d new Boolean(compression);\n\n        if (compression)\n            properties_.setString(JDProperties.DATA_COMPRESSION, TRUE_);\n        else\n            properties_.setString(JDProperties.DATA_COMPRESSION, FALSE_);\n\n        changes_.firePropertyChange(\"dataCompression\", oldCompression, newCompression);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"dataCompression: \" + compression);  //@A8C\n    }\n\n    /**\n    *  Sets the data source name.\n    *  This property can be used for connection pooling implementations.\n    *  @param dataSourceName The data source name.\n    **/\n    public void setDataSourceName(String dataSourceName)\n    {\n        String property \u003d DATASOURCE_NAME;\n\n        if (dataSourceName \u003d\u003d null)\n            throw new NullPointerException(property);\n\n        String old \u003d getDataSourceName();\n\n        dataSourceName_ \u003d dataSourceName;\n\n        changes_.firePropertyChange(property, old, dataSourceName);\n\n        logProperty(\"dataSource\", dataSourceName_);\n    }\n\n    /**\n    *  Sets whether to use data truncation.  The default value is true.\n    *  @param truncation true if data truncation is used; false otherwise.\n    **/\n    public void setDataTruncation(boolean truncation)\n    {\n        Boolean oldTruncation \u003d new Boolean(isDataTruncation());\n        Boolean newTruncation \u003d new Boolean(truncation);\n\n        if (truncation)\n            properties_.setString(JDProperties.DATA_TRUNCATION, TRUE_);\n        else\n            properties_.setString(JDProperties.DATA_TRUNCATION, FALSE_);\n\n        changes_.firePropertyChange(\"dataTruncation\", oldTruncation, newTruncation);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"dataTruncation: \" + truncation);   //@A8C\n    }\n\n    /**\n    *  Sets the date format used in date literals within SQL statements.\n    *  @param dateFormat The date format.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \"mdy\"\n    *    \u003cli\u003e \"dmy\"\n    *    \u003cli\u003e \"ymd\"\n    *    \u003cli\u003e \"usa\"\n    *    \u003cli\u003e \"iso\"\n    *    \u003cli\u003e \"eur\"\n    *    \u003cli\u003e \"jis\"\n    *    \u003cli\u003e \"julian\"\n    *    \u003cli\u003e \"\"  (server job value) - default.\n    *  \u003c/ul\u003e\n    *  The default is based on the server job.\n    **/\n    public void setDateFormat(String dateFormat)\n    {\n        String property \u003d \"dateFormat\";\n\n        if (dateFormat \u003d\u003d null)\n            throw new NullPointerException(property);\n        validateProperty(property, dateFormat, JDProperties.DATE_FORMAT);\n\n        String old \u003d getDateFormat();\n\n        properties_.setString(JDProperties.DATE_FORMAT, dateFormat);\n\n        changes_.firePropertyChange(property, old, dateFormat);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + dateFormat);  //@A8C\n    }\n\n    /**\n    *  Sets the date separator used in date literals within SQL statements.\n    *  This property has no effect unless the \"data format\" property is set to:\n    *  \"julian\", \"mdy\", \"dmy\", or \"ymd\".\n    *  @param dateSeparator The date separator.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \"/\" (slash)\n    *    \u003cli\u003e \"-\" (dash)\n    *    \u003cli\u003e \".\" (period)\n    *    \u003cli\u003e \",\" (comma)\n    *    \u003cli\u003e \" \" (space)\n    *    \u003cli\u003e \"\"  (server job value) - default.\n    *  \u003c/ul\u003e\n    *  The default value is based on the server job.\n    **/\n    public void setDateSeparator(String dateSeparator)\n    {\n        String property \u003d \"dateSeparator\";\n        if (dateSeparator \u003d\u003d null)\n            throw new NullPointerException(property);\n        validateProperty(property, dateSeparator, JDProperties.DATE_SEPARATOR);\n\n        String old \u003d getDateSeparator();\n\n        properties_.setString(JDProperties.DATE_SEPARATOR, dateSeparator);\n\n        changes_.firePropertyChange(property, old, dateSeparator);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + dateSeparator);   //@A8C\n    }\n\n    //@DFA\n    /**\n    *  Sets the decfloat rounding mode.\n    *  @param decfloatRoundingMode The decfloat rounding mode.\n    *   \u003cp\u003eValid values include:\n    *   \u003cul\u003e\n    *   \u003cli\u003e\"half even\" - default\n    *   \u003cli\u003e\"half up\" \n    *   \u003cli\u003e\"down\" \n    *   \u003cli\u003e\"ceiling\" \n    *   \u003cli\u003e\"floor\" \n    *   \u003cli\u003e\"half down\" \n    *   \u003cli\u003e\"up\" \n    *   \u003c/ul\u003e\n    **/\n    public void setDecfloatRoundingMode(String decfloatRoundingMode)\n    {\n        String property \u003d \"decfloatRoundingMode\";\n        if (decfloatRoundingMode \u003d\u003d null)\n            throw new NullPointerException(property);\n        validateProperty(property, decfloatRoundingMode, JDProperties.DECFLOAT_ROUNDING_MODE);\n\n        String old \u003d getDecfloatRoundingMode();\n\n        properties_.setString(JDProperties.DECFLOAT_ROUNDING_MODE, decfloatRoundingMode);\n\n        changes_.firePropertyChange(property, old, decfloatRoundingMode);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + decfloatRoundingMode);\n    }\n     \n    /**\n    *  Sets the decimal separator used in numeric literals within SQL \n    *  statements.\n    *  @param decimalSeparator The decimal separator.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \".\" (period)\n    *    \u003cli\u003e \",\" (comma)\n    *    \u003cli\u003e \"\"  (server job value) - default.\n    *  \u003c/ul\u003e\n    *  The default value is based on the server job.\n    **/\n    public void setDecimalSeparator(String decimalSeparator)\n    {\n        String property \u003d \"decimalSeparator\";\n        if (decimalSeparator \u003d\u003d null)\n            throw new NullPointerException(property);\n        validateProperty(property, decimalSeparator, JDProperties.DECIMAL_SEPARATOR);\n\n        String old \u003d getDecimalSeparator();\n\n        properties_.setString(JDProperties.DECIMAL_SEPARATOR, decimalSeparator);\n\n        changes_.firePropertyChange(property, old, decimalSeparator);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + decimalSeparator);    //@A8C\n    }\n\n    //@igwrn\n    /**\n    *  Sets the ignore warnings property.\n    *  @param ignoreWarnings Specifies a list of SQL states for which the driver should not create warning objects.\n    **/\n    public void setIgnoreWarnings(String ignoreWarnings)\n    {\n        String property \u003d \"ignoreWarnings\";\n        if (ignoreWarnings \u003d\u003d null)\n            throw new NullPointerException(property);\n \n        String old \u003d getIgnoreWarnings();\n\n        properties_.setString(JDProperties.IGNORE_WARNINGS, ignoreWarnings);\n\n        changes_.firePropertyChange(property, old, ignoreWarnings);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + ignoreWarnings);\n    }\n    \n    /**\n    *  Sets the data source description.\n    *  @param description The description.\n    **/\n    public void setDescription(String description)\n    {\n        String property \u003d DESCRIPTION;\n        if (description \u003d\u003d null)\n            throw new NullPointerException(property);\n\n        String old \u003d getDescription();\n\n        description_ \u003d description;\n\n        changes_.firePropertyChange(property, old, description);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + description);  //@A8C\n    }\n\n    /**\n    *  Sets how the IBM i system sorts records before sending them to the client.\n    *  @param sort The sort value.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \"hex\" (base the sort on hexadecimal values)\n    *    \u003cli\u003e \"language\" (base the sort on the language set in the sort language property)\n    *    \u003cli\u003e \"table\" (base the sort on the sort sequence table set in the sort table property).\n    *  \u003c/ul\u003e\n    *  The default value is \"hex\".\n    **/\n    public void setSort(String sort)\n    {\n        String property \u003d \"sort\";\n        if (sort \u003d\u003d null)\n            throw new NullPointerException(property);\n\n        //@JOB fix to allow \"sort\u003djob\" but use default value\n        if(sort.equals(\"job\"))                 //@JOB\n        {                                      //@JOB\n            if (JDTrace.isTraceOn())           //@JOB\n                JDTrace.logInformation (this, property + \": \" + getSort() + \" (warning: \" + getSort() + \" will be used since sort\u003djob is not valid)\");  //@JOB \n            return; //return and allow default setting to be used                                                  //@JOB\n        }                                     //@JOB\n\n\n        validateProperty(property, sort, JDProperties.SORT);\n        String old \u003d getSort();\n\n        properties_.setString(JDProperties.SORT, sort);\n\n        changes_.firePropertyChange(property, old, sort);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + sort); //@A8C\n    }\n\n    /**\n    *  Sets the amount of detail to be returned in the message for errors\n    *  occurring on the IBM i system.\n    *  @param errors The error message level.\n    *  Valid values include: \"basic\" and \"full\".  The default value is \"basic\".\n    **/\n    public void setErrors(String errors)\n    {\n        String property \u003d \"errors\";\n        if (errors \u003d\u003d null)\n            throw new NullPointerException(property);\n        validateProperty(property, errors, JDProperties.ERRORS);\n\n        String old \u003d getErrors();\n        properties_.setString(JDProperties.ERRORS, errors);\n\n        changes_.firePropertyChange(property, old, errors);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + errors);  //@A8C\n    }\n\n    /**\n    *  Sets whether to use extended dynamic support.  Extended dynamic\n    *  support provides a mechanism for caching dynamic SQL statements on\n    *  the IBM i system.  The first time a particular SQL statement is prepared, it is\n    *  stored in an SQL package on the system.  \n    *  If the package does not exist, it will be automatically created.\n    *  On subsequent prepares of the\n    *  same SQL statement, the system can skip a significant part of the\n    *  processing by using information stored in the SQL package.  If this\n    *  is set to \"true\", then a package name must be set using the \"package\"\n    *  property.\n    *  @param extendedDynamic If extended dynamic support is used; false otherwise.\n    *  The default value is not to use extended dynamic support.\n    **/\n    public void setExtendedDynamic(boolean extendedDynamic)\n    {\n        Boolean oldValue \u003d new Boolean(isExtendedDynamic());\n        Boolean newValue \u003d new Boolean(extendedDynamic);\n\n        if (extendedDynamic)\n            properties_.setString(JDProperties.EXTENDED_DYNAMIC, TRUE_);\n        else\n            properties_.setString(JDProperties.EXTENDED_DYNAMIC, FALSE_);\n\n        changes_.firePropertyChange(\"extendedDynamic\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"extendedDynamic: \" + extendedDynamic);  //@A8C\n    }\n\n    // @C3A\n    /**\n    *  Sets whether the driver should request extended metadata from the\n    *  IBM i system.  This property is ignored when connecting to systems\n    *  running OS/400 V5R1 and earlier. \n    *  If this property is set to true and connecting to a system running\n    *  OS/400 V5R2 or IBM i, the accuracy of the information \n    *  that is returned from ResultSetMetaData methods getColumnLabel(int),\n    *  isReadOnly(int), isSearchable(int), and isWriteable(int) will be increased.\n    *  In addition, the ResultSetMetaData method getSchemaName(int) will be supported with this \n    *  property set to true.  However, performance will be slower with this \n    *  property on.  Leave this property set to its default (false) unless you\n    *  need more specific information from those methods.\n    *\n    *  For example, without this property turned on, isSearchable(int) will \n    *  always return true even though the correct answer may be false because \n    *  the driver does not have enough information from the system to make a judgment.  Setting \n    *  this property to true forces the driver to get the correct data from the system.\n    *\n    *  @param extendedMetaData True to request extended metadata from the system, false otherwise.\n    *  The default value is false.\n    **/\n    public void setExtendedMetaData(boolean extendedMetaData)\n    {\n        Boolean oldValue \u003d new Boolean(isExtendedMetaData());\n        Boolean newValue \u003d new Boolean(extendedMetaData);\n\n        if (extendedMetaData)\n            properties_.setString(JDProperties.EXTENDED_METADATA, TRUE_);\n        else\n            properties_.setString(JDProperties.EXTENDED_METADATA, FALSE_);\n\n        changes_.firePropertyChange(\"extendedMetaData\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, \"extendedMetaData: \" + extendedMetaData);\n    }\n    \n    //@dup\n    /**\n     *  Sets whether the driver should request extended metadata from the\n     *  IBM i system.  This property is ignored when connecting to systems\n     *  running OS/400 V5R1 and earlier. \n     *  If this property is set to true and connecting to a system running\n     *  OS/400 V5R2 or IBM i, the accuracy of the information \n     *  that is returned from ResultSetMetaData methods getColumnLabel(int),\n     *  isReadOnly(int), isSearchable(int), and isWriteable(int) will be increased.\n     *  In addition, the ResultSetMetaData method getSchemaName(int) will be supported with this \n     *  property set to true.  However, performance will be slower with this \n     *  property on.  Leave this property set to its default (false) unless you\n     *  need more specific information from those methods.\n     *\n     *  For example, without this property turned on, isSearchable(int) will \n     *  always return true even though the correct answer may be false because \n     *  the driver does not have enough information from the system to make a judgment.  Setting \n     *  this property to true forces the driver to get the correct data from the system.\n     *\n     *  @param extendedMetaData True to request extended metadata from the system, false otherwise.\n     *  The default value is false.\n     *  Note:  this method is the same as setExtendedMetaData() so that it corresponds to the connection property name\n     **/\n    public void setExtendedMetadata(boolean extendedMetaData)\n    {\n        setExtendedMetaData(extendedMetaData);\n    }\n\n\n    // @W1a new method\n    /**\n    *  Sets whether to fully open a file when performing a query.\n    *  By default the IBM i system optimizes opens so they perform better.\n    *  In most cases optimization functions correctly and improves\n    *  performance.  Running a query repeatedly\n    *  when a database performance monitor is turned on may fail\n    *  because of the optimization, however.\n    *  Leave this property set to its default (false) until\n    *  you experience errors running queries with monitors\n    *  turned on.  At that time set the property to true which\n    *  will disable the optimization.\n    *  @param fullOpen True to fully open a file (turn off optimizations), false\n    *          to allow optimizations.  The default value is false.\n    **/\n    public void setFullOpen(boolean fullOpen)\n    {\n        Boolean oldValue \u003d new Boolean(isFullOpen());\n        Boolean newValue \u003d new Boolean(fullOpen);\n\n        if (fullOpen)\n            properties_.setString(JDProperties.FULL_OPEN, TRUE_);\n        else\n            properties_.setString(JDProperties.FULL_OPEN, FALSE_);\n\n        changes_.firePropertyChange(\"fullOpen\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, \"fullOpen: \" + fullOpen);\n    }\n\n    //@KBL\n    /**\n    *  Sets whether input locators are allocated as hold locators.\n    *  @param value true if locators should be allocated as hold locators; false otherwise.\n    *  The default value is true.\n    **/\n    public void setHoldInputLocators(boolean value)\n    {\n        String property \u003d \"holdInputLocators\";\n        Boolean oldValue \u003d new Boolean(isHoldInputLocators());\n        Boolean newValue \u003d new Boolean(value);\n\n        if (value)\n            properties_.setString(JDProperties.HOLD_LOCATORS, TRUE_);\n        else\n            properties_.setString(JDProperties.HOLD_LOCATORS, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + value);      \n    }   \n       \n    //@KBL\n    /**\n    *  Sets whether statements should remain open until a transaction boundary when autocommit is off\n    *  and they are associated with Lob locators.\n    *  @param value true if statements should remain open; false otherwise.\n    *  The default value is false.\n    **/\n    public void setHoldStatements(boolean value)\n    {\n        String property \u003d \"holdStatements\";\n        Boolean oldValue \u003d new Boolean(isHoldStatements());\n        Boolean newValue \u003d new Boolean(value);\n\n        if (value)\n            properties_.setString(JDProperties.HOLD_STATEMENTS, TRUE_);\n        else\n            properties_.setString(JDProperties.HOLD_STATEMENTS, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + value);      \n    }\n    \n    //@dmy\n    /**\n    *  Indicates whether the temporary fix for JVM 1.6 is enabled.\n    *  @param value true if JVM 1.6 fix is enabled; false otherwise.\n    *  The default value is true.\n    **/\n    public void setJvm16Synchronize(boolean value)\n    {\n        String property \u003d \"jvm16 synchronize\";\n        Boolean oldValue \u003d new Boolean(isJvm16Synchronize());\n        Boolean newValue \u003d new Boolean(value);\n\n        if (value)\n            properties_.setString(JDProperties.JVM16_SYNCHRONIZE, TRUE_);\n        else\n            properties_.setString(JDProperties.JVM16_SYNCHRONIZE, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + value);      \n    }\n\n    // @A1A\n    /**\n    *  Sets whether to delay closing cursors until subsequent requests.\n    *  @param lazyClose true to delay closing cursors until subsequent requests; false otherwise.\n               The default value is false.\n    **/\n    public void setLazyClose(boolean lazyClose)\n    {\n        Boolean oldValue \u003d new Boolean(isLazyClose());\n        Boolean newValue \u003d new Boolean(lazyClose);\n\n        if (lazyClose)\n            properties_.setString(JDProperties.LAZY_CLOSE, TRUE_);\n        else\n            properties_.setString(JDProperties.LAZY_CLOSE, FALSE_);\n\n        changes_.firePropertyChange(\"lazyClose\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"lazyClose: \" + lazyClose);  //@A8C\n    }\n\n    /**\n    *  Sets the libraries to add to the server job\u0027s library list.\n    *  The libraries are delimited by commas or spaces, and\n    *  \"*LIBL\" may be used as a place holder for the server job\u0027s\n    *  current library list.  The library list is used for resolving\n    *  unqualified stored procedure calls and finding schemas in\n    *  DatabaseMetaData catalog methods.  If \"*LIBL\" is not specified,\n    *  the specified libraries will replace the server job\u0027s\n    *  current library list.\n    *  @param libraries The library list.\n    **/\n    public void setLibraries(String libraries)\n    {\n        String property \u003d \"libraries\";\n        if (libraries \u003d\u003d null)\n            throw new NullPointerException(\"libraries\");\n\n        String old \u003d getLibraries();\n        properties_.setString(JDProperties.LIBRARIES, libraries);\n\n        changes_.firePropertyChange(property, old, libraries);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + libraries);  //@A8C\n    }\n\n    /**\n    *  Sets the maximum LOB (large object) size in bytes that\n    *  can be retrieved as part of a result set.  LOBs that are larger\n    *  than this threshold will be retrieved in pieces using extra\n    *  communication to the IBM i system.  Larger LOB thresholds will reduce\n    *  the frequency of communication to the system, but will download\n    *  more LOB data, even if it is not used.  Smaller LOB thresholds may\n    *  increase frequency of communication to the system, but will only\n    *  download LOB data as it is needed.\n    *\n    *  @param threshold The lob threshold.  Valid range is 0-16777216.\n    *  The default value is 32768.\n    **/\n    public void setLobThreshold(int threshold)\n    {\n        String property \u003d \"threshold\";\n        if (threshold \u003c 0 || threshold \u003e MAX_THRESHOLD)\n            throw new ExtendedIllegalArgumentException(property, ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n\n        Integer oldValue \u003d new Integer(getLobThreshold());\n        Integer newValue \u003d new Integer(threshold);\n\n        properties_.setString(JDProperties.LOB_THRESHOLD, new Integer(threshold).toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + threshold);  //@A8C\n    }\n\n    /**\n    *  Sets the maximum time in seconds that this data source can wait while attempting to connect to a database.\n    *  A value of zero specifies that the timeout is the system default if one exists; otherwise it specifies that\n    *  there is no timeout. The default value is initially zero.\n    *  @param timeout The login timeout in seconds.\n    **/\n    public void setLoginTimeout(int timeout) throws SQLException\n    {\n        \n        //@STIMEOUT setSoTimeout(timeout * 1000);    //@K5A  setSoTimeout takes milliseconds as a parameter //@STIMEOUT separate login and socket timeout into two separtate properties\n        sockProps_.setLoginTimeout(timeout * 1000); //@st3\n        String property \u003d \"loginTimeout\";                                               //@K5A\n\n        Integer oldValue \u003d new Integer(getLoginTimeout());                              //@K5A\n        Integer newValue \u003d new Integer(timeout);                                        //@K5A\n\n        properties_.setString(JDProperties.LOGIN_TIMEOUT, newValue.toString());         //@K5A\n\n        changes_.firePropertyChange(property, oldValue, newValue);                      //@K5A\n\n        if (JDTrace.isTraceOn())                                                        //@K5A\n            JDTrace.logInformation (this, property + \": \" + timeout);                   //@K5A\n\n        //@K5D JDError.throwSQLException (this, JDError.EXC_FUNCTION_NOT_SUPPORTED);\n    }\n\n    /**\n    *  Sets the log writer for this data source.\n    *  @param writer The log writer; to disable, set to null.\n    *  @exception SQLException If a database error occurs.\n    **/\n    public void setLogWriter(PrintWriter writer) throws SQLException\n    {\n        String property \u003d \"writer\";\n\n        //@C4D if (writer \u003d\u003d null)\n        //@C4D    throw new NullPointerException(property);\n\n        PrintWriter old \u003d getLogWriter();\n        writer_ \u003d writer;\n        changes_.firePropertyChange(property, old, writer);\n\n        if (writer \u003d\u003d null)         //@C4A\n        {                           //@C4A\n            log_ \u003d null;            //@C4A\n            return;                 //@C4A\n        }                           //@C4A\n\n        log_ \u003d new EventLog(writer);\n    }\n\n    //@PDA\n    /**                                                               \n    *  Sets how to retrieve DatabaseMetaData.\n    *  If set to 0, database metadata will be retrieved through the ROI data flow.  \n    *  If set to 1, database metadata will be retrieved by calling system stored procedures. \n    *  The methods that currently are available through stored procedures are:\n    *  getColumnPrivileges\n    *  @param mds The setting for metadata source\n    *  The default value is 1.\n    **/\n    public void setMetaDataSource(int mds)\n    {\n        String property \u003d \"metaDataSource\";\n\n        Integer oldValue \u003d new Integer(getMetaDataSource());\n        Integer newValue \u003d new Integer(mds);\n\n        properties_.setString(JDProperties.METADATA_SOURCE, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + mds);\n    }\n    \n    \n    //@dup\n    /**                                                               \n     *  Sets how to retrieve DatabaseMetaData.\n     *  If set to 0, database metadata will be retrieved through the ROI data flow.  \n     *  If set to 1, database metadata will be retrieved by calling system stored procedures. \n     *  The methods that currently are available through stored procedures are:\n     *  getColumnPrivileges\n     *  @param mds The setting for metadata source\n     *  The default value is 1.\n     *  Note:  this method is the same as setMetaDataSource() so that it corresponds to the connection property name\n     **/\n    public void setMetadataSource(int mds)\n    {\n        setMetaDataSource(mds);\n    }\n     \n    \n    /**\n    *  Sets the naming convention used when referring to tables.\n    *  @param naming The naming convention.  Valid values include: \"sql\" (e.g. schema.table)\n    *  and \"system\" (e.g. schema/table).  The default value is \"sql\".\n    **/\n    public void setNaming(String naming)\n    {\n        String property \u003d \"naming\";\n        if (naming \u003d\u003d null)\n            throw new NullPointerException(\"naming\");\n        validateProperty(property, naming, JDProperties.NAMING);\n\n        String old \u003d getNaming();\n        properties_.setString(JDProperties.NAMING, naming);\n\n        changes_.firePropertyChange(property, old, naming);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + naming);  //@A8C\n    }\n\n    /**\n    *  Sets the base name of the SQL package.  Note that only the\n    *  first six characters are used to generate the name of the SQL package on the IBM i system.  \n    *  This property has no effect unless\n    *  the extended dynamic property is set to true.  In addition, this property\n    *  must be set if the extended dynamic property is set to true.\n    *  @param packageName The base name of the SQL package.\n    **/\n    public void setPackage(String packageName)\n    {\n        String property \u003d \"packageName\";\n        if (packageName \u003d\u003d null)\n            throw new NullPointerException(property);\n\n        String old \u003d getPackage();\n        properties_.setString(JDProperties.PACKAGE, packageName);\n\n        changes_.firePropertyChange(property, old, packageName);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + packageName);  //@A8C\n    }\n\n    /**\n    *  Sets whether to add newly prepared statements to the SQL package \n    *  specified on the \"package\" property.  This property\n    *  has no effect unless the extended dynamic property is set to true.\n    *  @param add If newly prepared statements should be added to the SQL package specified on \n    *  the \"package\" property; false otherwise.\n    *  The default value is true.\n    **/\n    public void setPackageAdd(boolean add)\n    {\n        Boolean oldValue \u003d new Boolean(isPackageAdd());\n        Boolean newValue \u003d new Boolean(add);\n\n        if (add)\n            properties_.setString(JDProperties.PACKAGE_ADD, TRUE_);\n        else\n            properties_.setString(JDProperties.PACKAGE_ADD, FALSE_);\n\n        changes_.firePropertyChange(\"packageAdd\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"packageAdd: \" + add);  //@A8C\n    }\n\n    /**\n    *  Sets whether to cache a subset of the SQL package information in client memory.  \n    *  Caching SQL packages locally\n    *  reduces the amount of communication to the IBM i system for prepares and describes.  This\n    *  property has no effect unless the extended dynamic property is set to true.\n    *  @param cache If caching is used; false otherwise.  The default value is false.\n    **/\n    public void setPackageCache(boolean cache)\n    {\n        Boolean oldValue \u003d new Boolean(isPackageCache());\n        Boolean newValue \u003d new Boolean(cache);\n\n        if (cache)\n            properties_.setString(JDProperties.PACKAGE_CACHE, TRUE_);\n        else\n            properties_.setString(JDProperties.PACKAGE_CACHE, FALSE_);\n\n        changes_.firePropertyChange(\"packageCache\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"packageCache: \" + cache);  //@A8C\n    }\n\n\n    //@C6C Changed javadoc since package clearing is now done automatically\n    //@C6C by the database.\n    /**\n    *  Sets whether to clear SQL packages when they become full.  This method\n    *  has been deprecated.  Package clearing and the decision for the \n    *  threshold where package clearing is needed is now handled\n    *  automatically by the database.  \n    *  @param clear If the SQL package are cleared when full; false otherwise.\n    *  @deprecated\n    **/\n    public void setPackageClear(boolean clear)\n    {\n        //@C6D Package clearing and the decision for the \n        //@C6D threshold where package clearing is needed is now handled\n        //@C6D automatically by the database.\n\n        //@C6D Boolean oldValue \u003d new Boolean(isPackageClear());\n        //@C6D Boolean newValue \u003d new Boolean(clear);\n\n        //@C6D String value \u003d null;\n        //@C6D if (clear)\n        //@C6D     properties_.setString(JDProperties.PACKAGE_CLEAR, TRUE_);\n        //@C6D else\n        //@C6D     properties_.setString(JDProperties.PACKAGE_CLEAR, FALSE_);\n\n        //@C6D changes_.firePropertyChange(\"packageClear\", oldValue, newValue);\n\n        //@C6D if (JDTrace.isTraceOn()) //@A8C\n        //@C6D     JDTrace.logInformation (this, \"packageClear: \" + clear);  //@A8C\n    }\n\n\n    /**\n    *  Sets the type of SQL statement to be stored in the SQL package.  This can\n    *  be useful to improve the performance of complex join conditions.  This\n    *  property has no effect unless the extended dynamic property is set to true.\n    *  @param packageCriteria The type of SQL statement.\n    *  Valid values include: \"default\" (only store SQL statements with parameter\n    *  markers in the package), and \"select\" (store all SQL SELECT statements\n    *  in the package).  The default value is \"default\".\n    **/\n    public void setPackageCriteria(String packageCriteria)\n    {\n        String property \u003d \"packageCriteria\";\n\n        if (packageCriteria \u003d\u003d null)\n            throw new NullPointerException(property);\n        validateProperty(property, packageCriteria, JDProperties.PACKAGE_CRITERIA);\n\n        String old \u003d getPackageCriteria();\n        properties_.setString(JDProperties.PACKAGE_CRITERIA, packageCriteria);\n\n        changes_.firePropertyChange(property, old, packageCriteria);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + packageCriteria);  //@A8C\n    }\n\n    /**\n    *  Sets the action to take when SQL package errors occur.  When an SQL package\n    *  error occurs, the driver will optionally throw an SQLException or post a\n    *  warning to the Connection, based on the value of this property.  This property\n    *  has no effect unless the extended dynamic property is set to true.\n    *  @param packageError The action when SQL errors occur.\n    *  Valid values include: \"exception\", \"warning\", and \"none\".  The default value is \"warning\".\n    **/\n    public void setPackageError(String packageError)\n    {\n        String property \u003d \"packageError\";\n        if (packageError \u003d\u003d null)\n            throw new NullPointerException(property);\n        validateProperty(property, packageError, JDProperties.PACKAGE_ERROR);\n\n        String old \u003d getPackageError();\n        properties_.setString(JDProperties.PACKAGE_ERROR, packageError);\n\n        changes_.firePropertyChange(property, old, packageError);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + packageError);   //@A8C\n    }\n    /**\n    *  Sets the library for the SQL package.  This property has no effect unless\n    *  the extended dynamic property is set to true.\n    *  @param packageLibrary The SQL package library.  The default package library is \"QGPL\".\n    **/\n    public void setPackageLibrary(String packageLibrary)\n    {\n        String property \u003d \"packageLibrary\";\n        if (packageLibrary \u003d\u003d null)\n            throw new NullPointerException(property);\n\n        String old \u003d getPackageLibrary();\n        properties_.setString(JDProperties.PACKAGE_LIBRARY, packageLibrary);\n\n        changes_.firePropertyChange(property, old, packageLibrary);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + packageLibrary);  //@A8C\n    }\n\n    /**\n    *  Sets the database password.\n    *  @param password The password.\n    **/\n    public void setPassword(String password)\n    {\n        as400_.setPassword(password);\n        serialPWBytes_ \u003d xpwConfuse(password);                  //@J3a\n        log(ResourceBundleLoader.getText(\"AS400_JDBC_DS_PASSWORD_SET\"));     //@A9C\n    }\n\n    /**\n    *  Sets whether to prefetch data upon executing a SELECT statement.\n    *  This will increase performance when accessing the initial rows in the result set.\n    *  @param prefetch If prefetch is used; false otherwise.\n    *  The default value is to prefectch data.\n    **/\n    public void setPrefetch(boolean prefetch)\n    {\n        Boolean oldValue \u003d new Boolean(isPrefetch());\n        Boolean newValue \u003d new Boolean(prefetch);\n\n        if (prefetch)\n            properties_.setString(JDProperties.PREFETCH, TRUE_);\n        else\n            properties_.setString(JDProperties.PREFETCH, FALSE_);\n\n        changes_.firePropertyChange(\"prefetch\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"prefetch: \" + prefetch);      //@A8C\n    }\n\n    /**\n    *  Sets whether the user should be prompted if a user name or password is\n    *  needed to connect to the IBM i system.  If a connection can not be made\n    *  without prompting the user, and this property is set to false, then an\n    *  attempt to connect will fail.\n    *  @param prompt true if the user is prompted for signon information; false otherwise.\n    *  The default value is false.\n    **/\n    public void setPrompt(boolean prompt)\n    {\n        Boolean oldValue \u003d new Boolean(isPrompt());\n        Boolean newValue \u003d new Boolean(prompt);\n\n        if (prompt)\n            properties_.setString(JDProperties.PROMPT, TRUE_);\n        else\n            properties_.setString(JDProperties.PROMPT, FALSE_);\n\n        try\n        {                                     //@C2A  \n            as400_.setGuiAvailable(prompt);   //@C2A\n        }                                     //@C2A\n        catch (PropertyVetoException vp)      //@C2A\n        { /* ignore */                        //@C2A\n        }                                     //@C2A\n\n        changes_.firePropertyChange(\"prompt\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"prompt: \" + prompt);     //@A8C\n    }\n\n    // @F0D - Removed unused method\n    ///**\n    //*  Sets the JDBC properties.\n    //*  @param Properties The JDBC properties list.\n    //**/\n    //void setProperties(Reference reference)\n    //{\n    //    /*\n    //    *  Implementation note:  This method is called from AS400JDBCObjectFactory.getObjectInstance\n    //    */\n    //    if (reference \u003d\u003d null)\n    //        throw new NullPointerException(\"reference\");\n    // \n    //    Properties properties \u003d new Properties();\n    //\n    //    Enumeration list \u003d reference.getAll();\n    //    while (list.hasMoreElements())\n    //    {\n    //        StringRefAddr refAddr \u003d (StringRefAddr)list.nextElement();\n    //        String property \u003d refAddr.getType();\n    //        String value \u003d (String)reference.get(property).getContent();\n    //\n    //        if (property.equals(DATABASE_NAME))                         // constant identifiers were used to store in JNDI.\n    //            setDatabaseName(value);\n    //        else if (property.equals(DATASOURCE_NAME))\n    //            setDataSourceName(value);\n    //        else if (property.equals(DESCRIPTION))\n    //            setDescription(value);\n    //        else if (property.equals(SERVER_NAME))\n    //            setServerName(value);\n    //        else if (property.equals(USER))\n    //            setUser(value);\n    //        else if (property.equals(PASSWORD)) {\n    //            // get the password back from the serialized char[]\n    //            serialPWBytes_ \u003d value.toCharArray();\n    //            // decode the password and set it on the as400\n    //            as400_.setPassword(xpwDeconfuse(serialPWBytes_));\n    //        }\n    //        else if (property.equals(KEY_RING_NAME)) {\n    //            // set the key ring name\n    //            serialKeyRingName_ \u003d value;\n    //        }\n    //        else if (property.equals(KEY_RING_PASSWORD)) {\n    //            // get the key ring password back from the serialized char[]\n    //            if (value !\u003d null)\n    //                serialKeyRingPWBytes_ \u003d value.toCharArray();\n    //        }\n    //        else if (property.equals(SECURE)) {\n    //            // set the isSecure_ flag\n    //            isSecure_ \u003d value.equals(TRUE_) ? true : false;\n    //        }\n    //        else if (property.equals(SAVE_PASSWORD)) {\n    //            // set the savePasswordWhenSerialized_ flag\n    //            savePasswordWhenSerialized_ \u003d value.equals(TRUE_) ? true : false;\n    //        }\n    //        else\n    //        {\n    //            properties.put(property, value);\n    //        }\n    //    }\n    //    properties_ \u003d new JDProperties(properties, null);\n    //\n    //    // get the prompt property and set it back in the as400 object\n    //    String prmpt \u003d properties_.getString(JDProperties.PROMPT);\n    //    if (prmpt !\u003d null \u0026\u0026 prmpt.equalsIgnoreCase(FALSE_))\n    //        setPrompt(false);\n    //    else if (prmpt !\u003d null \u0026\u0026 prmpt.equalsIgnoreCase(TRUE_))\n    //        setPrompt(true);\n    //\n    //    // if the system is secure create a SecureAS400 object\n    //    if (isSecure_) {\n    //        try\n    //        {\n    //            as400_ \u003d new SecureAS400(as400_);\n    //            ((SecureAS400)as400_).setKeyRingName(serialKeyRingName_, xpwDeconfuse(serialKeyRingPWBytes_));\n    //        }\n    //        catch (PropertyVetoException pe)\n    //        { /* will never happen */\n    //        }\n    //    }\n    //}\n    \n    //@PDA\n    /**\n     * Sets the properties based on \";\" delimited string of properties, in same\n     * fashion as URL properties specified with\n     * DriverManager.getConnection(urlProperties). This method simply parses\n     * property string and then calls setPropertes(Properties). This method is\n     * intended as an enhancement so that the user does not have to write new\n     * code to call the setters for new/deleted properties.\n     * \n     * @param propertiesString list of \";\" delimited properties\n     */\n    public void setProperties(String propertiesString)\n    {\n        //use existing JDDatasourceURL to parse properties string like Connection does\n        //but first have to add dummy protocol so we can re-use parsing code\n        propertiesString \u003d \"jdbc:as400://dummyhost;\" + propertiesString;\n        JDDataSourceURL dsURL \u003d new JDDataSourceURL(propertiesString);\n        //returns only properties specified in propertyString.. (none of\n        // JDProperties defaults)\n        Properties properties \u003d dsURL.getProperties();\n        setProperties(properties);\n    }\n\n    //@PDA\n    /**\n     * Sets the properties for this datasource. This method is intended as an\n     * enhancement so that the user does not have to write new code to call the\n     * setters for new/deleted properties.\n     * \n     * @param newProperties object containing updated property values\n     */\n    public void setProperties(Properties newProperties)\n    {\n        //1. turn on/off tracing per new props\n        //2. set needed AS400JDBCDataSource instance variables\n        //3. set socket props\n        //4. propagate newProperties to existing properties_ object\n\n        // Check first thing to see if the trace property is\n        // turned on. This way we can trace everything, including\n        // the important stuff like loading the properties.\n\n        // If trace property was set to true, turn on tracing. If trace property\n        // was set to false,\n        // turn off tracing. If trace property was not set, do not change.\n        if (JDProperties.isTraceSet(newProperties, null) \u003d\u003d JDProperties.TRACE_SET_ON)\n        {\n            if (!JDTrace.isTraceOn())\n                JDTrace.setTraceOn(true);\n        } else if (JDProperties.isTraceSet(newProperties, null) \u003d\u003d JDProperties.TRACE_SET_OFF)\n        {\n            if (JDTrace.isTraceOn())\n                JDTrace.setTraceOn(false);\n        }\n\n        // If toolbox trace is set to datastream. Turn on datastream tracing.\n        if (JDProperties.isToolboxTraceSet(newProperties, null) \u003d\u003d JDProperties.TRACE_TOOLBOX_DATASTREAM)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceDatastreamOn(true);\n        }\n        // If toolbox trace is set to diagnostic. Turn on diagnostic tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) \u003d\u003d JDProperties.TRACE_TOOLBOX_DIAGNOSTIC)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceDiagnosticOn(true);\n        }\n        // If toolbox trace is set to error. Turn on error tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) \u003d\u003d JDProperties.TRACE_TOOLBOX_ERROR)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceErrorOn(true);\n        }\n        // If toolbox trace is set to information. Turn on information tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) \u003d\u003d JDProperties.TRACE_TOOLBOX_INFORMATION)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceInformationOn(true);\n        }\n        // If toolbox trace is set to warning. Turn on warning tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) \u003d\u003d JDProperties.TRACE_TOOLBOX_WARNING)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceWarningOn(true);\n        }\n        // If toolbox trace is set to conversion. Turn on conversion tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) \u003d\u003d JDProperties.TRACE_TOOLBOX_CONVERSION)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceConversionOn(true);\n        }\n        // If toolbox trace is set to proxy. Turn on proxy tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) \u003d\u003d JDProperties.TRACE_TOOLBOX_PROXY)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceProxyOn(true);\n        }\n        // If toolbox trace is set to pcml. Turn on pcml tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) \u003d\u003d JDProperties.TRACE_TOOLBOX_PCML)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTracePCMLOn(true);\n        }\n        // If toolbox trace is set to jdbc. Turn on jdbc tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) \u003d\u003d JDProperties.TRACE_TOOLBOX_JDBC)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceJDBCOn(true);\n        }\n        // If toolbox trace is set to all. Turn on tracing for all categories.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) \u003d\u003d JDProperties.TRACE_TOOLBOX_ALL)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceAllOn(true);\n        }\n        // If toolbox trace is set to thread. Turn on thread tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) \u003d\u003d JDProperties.TRACE_TOOLBOX_THREAD)\n        {\n            if (!Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            Trace.setTraceThreadOn(true);\n        }\n        // If toolbox trace is set to none. Turn off tracing.\n        else if (JDProperties.isToolboxTraceSet(newProperties, null) \u003d\u003d JDProperties.TRACE_TOOLBOX_NONE)\n        {\n            if (Trace.isTraceOn())\n            {\n                Trace.setTraceOn(false);\n            }\n        }\n\n        //next we need to set instance vars (via setX() methods)\n        //or setup socket properties or set in properties_\n        //Note: this is similar to AS400JDBCDataSource(Reference reference)logic\n\n        Enumeration e \u003d newProperties.keys();\n        while (e.hasMoreElements())\n        {\n            String propertyName \u003d (String) e.nextElement();\n            String propertyValue \u003d (String) newProperties.getProperty(propertyName);\n\n            int propIndex \u003d JDProperties.getPropertyIndex(propertyName);\n\n            //some of the setter methods also set the properties_ below\n            if (propIndex \u003d\u003d JDProperties.DATABASE_NAME)\n                setDatabaseName(propertyValue);\n            else if (propIndex \u003d\u003d JDProperties.USER)\n                setUser(propertyValue);\n            else if (propIndex \u003d\u003d JDProperties.PASSWORD)\n                setPassword(properties_.getString(JDProperties.PASSWORD));\n            else if (propIndex \u003d\u003d JDProperties.SECURE)\n                setSecure(propertyValue.equals(TRUE_) ? true : false);\n            else if (propIndex \u003d\u003d JDProperties.KEEP_ALIVE)\n                setKeepAlive(propertyValue.equals(TRUE_) ? true : false);\n            else if (propIndex \u003d\u003d JDProperties.RECEIVE_BUFFER_SIZE)\n                setReceiveBufferSize(Integer.parseInt(propertyValue));\n            else if (propIndex \u003d\u003d JDProperties.SEND_BUFFER_SIZE)\n                setSendBufferSize(Integer.parseInt(propertyValue));\n            else if (propIndex \u003d\u003d JDProperties.PROMPT)\n                setPrompt(propertyValue.equals(TRUE_) ? true : false);\n            else if (propIndex \u003d\u003d JDProperties.KEY_RING_NAME){\n                //at this time, decided to not allow this due to security and fact that there is no setKeyRingName() method\n                if (JDTrace.isTraceOn())\n                    JDTrace.logInformation(this, \"Property: \" + propertyName + \" can only be changed in AS400JDBCDataSource constructor\");  \n            } else if (propIndex \u003d\u003d JDProperties.KEY_RING_PASSWORD){\n                //at this time, decided to not allow this due to security and fact that there is no setKeyRingPassword() method\n                if (JDTrace.isTraceOn())\n                    JDTrace.logInformation(this, \"Property: \" + propertyName + \" can only be changed in AS400JDBCDataSource constructor\");  \n            } else if (propIndex !\u003d -1)\n            {\n                properties_.setString(propIndex, propertyValue);\n            }\n        } \n\n    }\n    \n    /**\n    *  Sets the name of the proxy server.\n    *  @param proxyServer The proxy server.\n    **/\n    public void setProxyServer(String proxyServer)\n    {\n        String property \u003d \"proxyServer\";\n        if (proxyServer \u003d\u003d null)\n            throw new NullPointerException(property);\n\n        String old \u003d getProxyServer();\n        properties_.setString(JDProperties.PROXY_SERVER, proxyServer);\n\n        changes_.firePropertyChange(property, old, proxyServer);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + proxyServer);  //@A8C\n    }\n\n    /**\n    *  Sets the source of the text for REMARKS columns in ResultSets returned\n    *  by DatabaseMetaData methods.\n    *  @param remarks The text source.\n    *  Valid values include: \"sql\" (SQL object comment) and \"system\" (IBM i object description).\n    *  The default value is \"system\".\n    **/\n    public void setRemarks(String remarks)\n    {\n        String property \u003d \"remarks\";\n        if (remarks \u003d\u003d null)\n            throw new NullPointerException(\"remarks\");\n        validateProperty(property, remarks, JDProperties.REMARKS);\n\n        String old \u003d getRemarks();\n        properties_.setString(JDProperties.REMARKS, remarks);\n\n        changes_.firePropertyChange(property, old, remarks);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + remarks);  //@A8C\n    }\n\n    //@K94\n    /**\n    *  Sets whether the cursor is held after a rollback.\n    *  @param cursorHold true if the cursor is held; false otherwise.  The default value is false.\n    **/\n    public void setRollbackCursorHold(boolean cursorHold)\n    {\n        String property \u003d \"rollbackCursorHold\";\n        Boolean oldHold \u003d new Boolean(isRollbackCursorHold());\n        Boolean newHold \u003d new Boolean(cursorHold);\n\n        if (cursorHold)\n            properties_.setString(JDProperties.ROLLBACK_CURSOR_HOLD, TRUE_);\n        else\n            properties_.setString(JDProperties.ROLLBACK_CURSOR_HOLD, FALSE_);\n\n        changes_.firePropertyChange(property, oldHold, newHold);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + cursorHold);  \n    }\n\n    /**\n    *  Sets the secondary URL to be used for a connection on the middle-tier\u0027s\n    *  DriverManager in a multiple tier environment, if it is different than\n    *  already specified.  This property allows you to use this driver to connect\n    *  to databases other than DB2 for IBM i. Use a backslash as an escape character\n    *  before backslashes and semicolons in the URL.\n    *  @param url The secondary URL.\n    **/\n    public void setSecondaryUrl(String url)\n    {\n        if (url \u003d\u003d null)\n            throw new NullPointerException(\"url\");\n\n        String old \u003d getSecondaryUrl();\n        properties_.setString(JDProperties.SECONDARY_URL, url);\n\n        changes_.firePropertyChange(\"secondaryUrl\", old, url);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"secondaryUrl: \" + url); //@A8C\n    }\n    \n    //@dup\n    /**\n     *  Sets the secondary URL to be used for a connection on the middle-tier\u0027s\n     *  DriverManager in a multiple tier environment, if it is different than\n     *  already specified.  This property allows you to use this driver to connect\n     *  to databases other than DB2 for IBM i. Use a backslash as an escape character\n     *  before backslashes and semicolons in the URL.\n     *  @param url The secondary URL.\n     *  Note:  this method is the same as setSecondaryUrl() so that it corresponds to the connection property name\n     **/\n    public void setSecondaryURL(String url)\n    {\n        setSecondaryUrl(url);\n    }\n\n    /**\n    *  Sets whether a Secure Socket Layer (SSL) connection is used to communicate\n    *  with the IBM i system.  SSL connections are only available when connecting to systems\n    *  at V4R4 or later.\n    *  @param secure true if Secure Socket Layer connection is used; false otherwise.\n    *  The default value is false.\n    **/\n    public void setSecure(boolean secure)\n    {\n        Boolean oldValue \u003d new Boolean(isSecure());\n        Boolean newValue \u003d new Boolean(secure);\n\n        //Do not allow user to change to not secure if they constructed the data source with \n        //a keyring.\n        if (!secure \u0026\u0026 isSecure_)                //@C2A\n        {                                        //@C2A\n            throw new ExtendedIllegalStateException(\"secure\", \n                                                    ExtendedIllegalStateException.PROPERTY_NOT_CHANGED);  //@C2A\n        }                                        //@C2A\n\n        // keep away the secure flag  // @F0A\n        isSecure_ \u003d secure;           // @F0A\n\n        if (secure)\n            properties_.setString(JDProperties.SECURE, TRUE_);\n        else\n            properties_.setString(JDProperties.SECURE, FALSE_);\n\n        changes_.firePropertyChange(\"secure\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"secure: \" + secure);     //@A8C\n    }\n\n    //@pw3\n    /**\n     *  Sets whether to disallow \"\" and *current as user name and password.  \n     *  True indicates to disallow \"\" and *current for user name and password.\n     *  @param secureCurrentUser The secure current user setting.\n     **/\n    public void setSecureCurrentUser(boolean secureCurrentUser)\n    {\n        String property \u003d \"secureCurrentUser\";\n        Boolean oldVal \u003d new Boolean(isSecureCurrentUser());\n        Boolean newVal \u003d new Boolean(secureCurrentUser);\n\n        if (secureCurrentUser)\n            properties_.setString(JDProperties.SECURE_CURRENT_USER, TRUE_);\n        else\n            properties_.setString(JDProperties.SECURE_CURRENT_USER, FALSE_);\n\n        changes_.firePropertyChange(property, oldVal, newVal);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + secureCurrentUser);  \n    }\n    \n    \n    /**\n    *  Sets the IBM i system name.\n    *  @param serverName The system name.\n    **/\n    public void setServerName(String serverName)\n    {\n        String property \u003d SERVER_NAME;\n        if (serverName \u003d\u003d null)\n            throw new NullPointerException(property);\n\n        String old \u003d getServerName();\n        \n        // keep away the name to serialize    // @F0A\n        serialServerName_ \u003d serverName;       // @F0A\n\n        try\n        {\n            as400_.setSystemName(serverName);\n        }\n        catch (PropertyVetoException pv)\n        { /* ignore */\n        }\n\n        changes_.firePropertyChange(property, old, serverName);\n\n        logProperty (\"server name\", as400_.getSystemName());\n    }\n\n\n    // @j1 new method\n    /**\n    *  Enables tracing of the JDBC server job.\n    *  If tracing is enabled, tracing is started when\n    *  the client connects to the IBM i system, and ends when the connection\n    *  is disconnected.  Tracing must be started before connecting to\n    *  the system since the client enables tracing only at connect time.\n    *\n    *  \u003cP\u003e\n    *  Trace data is collected in spooled files on the system.  Multiple\n    *  levels of tracing can be turned on in combination by adding\n    *  the constants and passing that sum on the set method.  For example,\n    *  \u003cpre\u003e\n    *  dataSource.setServerTraceCategories(AS400JDBCDataSource.SERVER_TRACE_START_DATABASE_MONITOR + AS400JDBCDataSource.SERVER_TRACE_SAVE_SERVER_JOBLOG);\n    *  \u003c/pre\u003e\n    *  @param traceCategories level of tracing to start.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *  \u003cli\u003eSERVER_TRACE_START_DATABASE_MONITOR - Start the database monitor on the JDBC server job.\n    *                               The numeric value of this constant is 2.\n    *  \u003cLI\u003eSERVER_TRACE_DEBUG_SERVER_JOB - Start debug on the JDBC server job.\n    *                         The numeric value of this constant is 4.\n    *  \u003cLI\u003eSERVER_TRACE_SAVE_SERVER_JOBLOG - Save the joblog when the JDBC server job ends.\n    *                           The numeric value of this constant is 8.\n    *  \u003cLI\u003eSERVER_TRACE_TRACE_SERVER_JOB - Start job trace on the JDBC server job.\n    *                         The numeric value of this constant is 16.\n    *  \u003cLI\u003eSERVER_TRACE_SAVE_SQL_INFORMATION - Save SQL information.\n    *                             The numeric value of this constant is 32.\n    *  \u003c/ul\u003e\n    *  \u003cP\u003e\n    *  Tracing the JDBC server job will use significant amounts of system resources.\n    *  Additional processor resource is used to collect the data, and additional\n    *  storage is used to save the data.  Turn on tracing only to debug\n    *  a problem as directed by IBM service.\n    *\n    *\n    **/\n    public void setServerTraceCategories(int traceCategories)\n    {\n        String property \u003d \"serverTrace\";\n\n        Integer oldValue \u003d new Integer(getServerTraceCategories());\n        Integer newValue \u003d new Integer(traceCategories);\n\n        properties_.setString(JDProperties.TRACE_SERVER, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + traceCategories);\n    }\n    \n    //@dup\n    /**\n     *  Enables tracing of the JDBC server job.\n     *  If tracing is enabled, tracing is started when\n     *  the client connects to the IBM i system, and ends when the connection\n     *  is disconnected.  Tracing must be started before connecting to\n     *  the system since the client enables tracing only at connect time.\n     *\n     *  \u003cP\u003e\n     *  Trace data is collected in spooled files on the system.  Multiple\n     *  levels of tracing can be turned on in combination by adding\n     *  the constants and passing that sum on the set method.  For example,\n     *  \u003cpre\u003e\n     *  dataSource.setServerTraceCategories(AS400JDBCDataSource.SERVER_TRACE_START_DATABASE_MONITOR + AS400JDBCDataSource.SERVER_TRACE_SAVE_SERVER_JOBLOG);\n     *  \u003c/pre\u003e\n     *  @param traceCategories level of tracing to start.\n     *  \u003cp\u003eValid values include:\n     *  \u003cul\u003e\n     *  \u003cli\u003eSERVER_TRACE_START_DATABASE_MONITOR - Start the database monitor on the JDBC server job.\n     *                               The numeric value of this constant is 2.\n     *  \u003cLI\u003eSERVER_TRACE_DEBUG_SERVER_JOB - Start debug on the JDBC server job.\n     *                         The numeric value of this constant is 4.\n     *  \u003cLI\u003eSERVER_TRACE_SAVE_SERVER_JOBLOG - Save the joblog when the JDBC server job ends.\n     *                           The numeric value of this constant is 8.\n     *  \u003cLI\u003eSERVER_TRACE_TRACE_SERVER_JOB - Start job trace on the JDBC server job.\n     *                         The numeric value of this constant is 16.\n     *  \u003cLI\u003eSERVER_TRACE_SAVE_SQL_INFORMATION - Save SQL information.\n     *                             The numeric value of this constant is 32.\n     *  \u003c/ul\u003e\n     *  \u003cP\u003e\n     *  Tracing the JDBC server job will use significant amounts of system resources.\n     *  Additional processor resource is used to collect the data, and additional\n     *  storage is used to save the data.  Turn on tracing only to debug\n     *  a problem as directed by IBM service.\n     *\n     * Note:  this method is the same as setServerTraceCategories() so that it corresponds to the connection property name\n     **/\n     public void setServerTrace(int traceCategories)\n     {\n         setServerTraceCategories(traceCategories);\n     }\n\n\n    // @A2A\n    /**\n    * Sets the JDBC driver implementation.\n    * This property has no\n    * effect if the \"secondary URL\" property is set.\n    * This property cannot be set to \"native\" if the\n    * environment is not an IBM i Java Virtual Machine.\n    * param driver The driver value.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *  \u003cli\u003e\"toolbox\" (use the IBM Toolbox for Java JDBC driver)\n    *  \u003cli\u003e\"native\" (use the IBM Developer Kit for Java JDBC driver)\n    *  \u003c/ul\u003e\n    *  The default value is \"toolbox\".\n    *  Note:  Not supported in a connection pool.\n    **/\n    public void setDriver(String driver)\n    {\n        String property \u003d \"driver\";\n        if (driver \u003d\u003d null)\n            throw new NullPointerException(property);\n\n        validateProperty(property, driver, JDProperties.DRIVER);\n        String old \u003d getDriver();\n\n        properties_.setString(JDProperties.DRIVER, driver);\n\n        changes_.firePropertyChange(property, old, driver);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + driver);  //@A8C\n    }\n\n    // @J3 new method\n    /**\n    *  Sets whether to save the password locally with the rest of the properties when \n    *  this data source object is serialized.\n    *  \u003cP\u003e  \n    *  If the password is saved, it is up to the application to protect\n    *  the serialized form of the object because it contains all necessary\n    *  information to connect to the IBM i system.  The default is false.  It\n    *  is a security risk to save the password with the rest of the\n    *  properties so by default the password is not saved.  If the application\n    *  programmer chooses to accept this risk, set this property to true\n    *  to force the Toolbox to save the password with the other properties\n    *  when the data source object is serialized.  \n    *\n    *  @param savePassword true if the password is saved; false otherwise.\n    *  The default value is false\n    **/\n    public void setSavePasswordWhenSerialized(boolean savePassword)\n    {                                             \n        String property \u003d \"savePasswordWhenSerialized\";            //@C5A\n\n        boolean oldValue \u003d isSavePasswordWhenSerialized();         //@C5A\n        boolean newValue \u003d savePassword;                           //@C5A\n\n        savePasswordWhenSerialized_ \u003d savePassword;                        \n\n        changes_.firePropertyChange(property, oldValue, newValue); //@C5A\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, \"save password: \" + savePassword);\n    }\n\n\n    /**\n    *  Sets the three-character language id to use for selection of a sort sequence.\n    *  This property has no effect unless the sort property is set to \"language\".\n    *  @param language The three-character language id.\n    *  The default value is ENU.\n    **/\n    public void setSortLanguage(String language)\n    {\n        if (language \u003d\u003d null)\n            throw new NullPointerException(\"language\");\n\n        String old \u003d getSortLanguage();\n        properties_.setString(JDProperties.SORT_LANGUAGE, language);\n\n        changes_.firePropertyChange(\"sortLanguage\", old, language);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"sortLanguage: \" + language);  //@A8C\n    }\n\n    /**\n    *  Sets the library and file name of a sort sequence table stored on the\n    *  IBM i system.\n    *  This property has no effect unless the sort property is set to \"table\".\n    *  The default is an empty String (\"\").\n    *  @param table The qualified sort table name.\n    **/\n    public void setSortTable(String table)\n    {\n        if (table \u003d\u003d null)\n            throw new NullPointerException(\"table\");\n\n        String old \u003d getSortTable();\n        properties_.setString(JDProperties.SORT_TABLE, table);\n\n        changes_.firePropertyChange(\"sortTable\", old, table);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"sortTable: \" + table);  //@A8C\n    }\n\n    /**\n    *  Sets how the IBM i system treats case while sorting records.  This property \n    *  has no effect unless the sort property is set to \"language\".\n    *  @param sortWeight The sort weight.\n    *  Valid values include: \"shared\" (upper- and lower-case characters are sorted as the\n    *  same character) and \"unique\" (upper- and lower-case characters are sorted as\n    *  different characters).  The default value is \"shared\".\n    **/\n    public void setSortWeight(String sortWeight)\n    {\n        String property \u003d \"sortWeight\";\n        if (sortWeight \u003d\u003d null)\n            throw new NullPointerException(property);\n\n        validateProperty(property, sortWeight, JDProperties.SORT_WEIGHT);\n\n        String old \u003d getSortWeight();\n        properties_.setString(JDProperties.SORT_WEIGHT, sortWeight);\n\n        changes_.firePropertyChange(property, old, sortWeight);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + sortWeight);  //@A8C\n    }\n\n    /**\n    *  Sets whether a thread is used.\n    *  @param threadUsed true if a thread is used; false otherwise.\n    *  The default value is true.\n    **/\n    public void setThreadUsed(boolean threadUsed)\n    {\n        Boolean oldValue \u003d new Boolean(isThreadUsed());\n        Boolean newValue \u003d new Boolean(threadUsed);\n\n        if (threadUsed)\n            properties_.setString(JDProperties.THREAD_USED, TRUE_);\n        else\n            properties_.setString(JDProperties.THREAD_USED, FALSE_);\n\n        try\n        {                                     \n            as400_.setThreadUsed(threadUsed);                       \n        }                                                            \n        catch (PropertyVetoException pve)                            \n        { /* Will never happen */                                    \n        }\n        \n        changes_.firePropertyChange(\"threadUsed\", oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"threadUsed: \" + threadUsed);  //@A8C\n    }\n\n    /**\n    *  Sets the time format used in time literals with SQL statements.\n    *  @param timeFormat The time format.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \"hms\"\n    *    \u003cli\u003e \"usa\"\n    *    \u003cli\u003e \"iso\"\n    *    \u003cli\u003e \"eur\"\n    *    \u003cli\u003e \"jis\"\n    *    \u003cli\u003e \"\"  (server job value) - default.\n    *  \u003c/ul\u003e\n    *  The default value is based on the server job.\n    **/\n    public void setTimeFormat(String timeFormat)\n    {\n        String property \u003d \"timeFormat\";\n        if (timeFormat \u003d\u003d null)\n            throw new NullPointerException(property);\n        validateProperty(property, timeFormat, JDProperties.TIME_FORMAT);\n\n        String old \u003d getTimeFormat();\n        properties_.setString(JDProperties.TIME_FORMAT, timeFormat);\n\n        changes_.firePropertyChange(property, old, timeFormat);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + timeFormat);  //@A8C\n    }\n\n    /**\n    *  Sets the time separator used in time literals within SQL statements.\n    *  This property has no effect unless the time format property is set to \"hms\".\n    *  @param timeSeparator The time separator.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \":\" (colon)\n    *    \u003cli\u003e \".\" (period)\n    *    \u003cli\u003e \",\" (comma)\n    *    \u003cli\u003e \" \" (space)\n    *    \u003cli\u003e \"\"  (server job value) - default.\n    *  \u003c/ul\u003e\n    *  The default value is based on the server job.\n    **/\n    public void setTimeSeparator(String timeSeparator)\n    {\n        String property \u003d \"timeSeparator\";\n        if (timeSeparator \u003d\u003d null)\n            throw new NullPointerException(property);\n        validateProperty(property, timeSeparator, JDProperties.TIME_SEPARATOR);\n\n        String old \u003d getTimeSeparator();\n        properties_.setString(JDProperties.TIME_SEPARATOR, timeSeparator);\n\n        changes_.firePropertyChange(property, old, timeSeparator);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + timeSeparator);   //@A8C\n    }\n\n    /**\n    *  Sets whether trace messages should be logged.  Trace messages are\n    *  useful for debugging programs that call JDBC.  However, there is a\n    *  performance penalty associated with logging trace messages, so this\n    *  property should only be set to true for debugging.  Trace messages\n    *  are logged to System.out.\n    *  @param trace true if trace message are logged; false otherwise.\n    *  The default value is false.\n    **/\n    public void setTrace(boolean trace)\n    {\n        Boolean oldValue \u003d new Boolean(isTrace());\n        Boolean newValue \u003d new Boolean(trace);\n\n        if (trace)\n            properties_.setString(JDProperties.TRACE, TRUE_);\n        else\n            properties_.setString(JDProperties.TRACE, FALSE_);\n\n        changes_.firePropertyChange(\"trace\", oldValue, newValue);\n\n        if (trace)\n        {\n            if (!JDTrace.isTraceOn ())\n                JDTrace.setTraceOn (true);\n        }\n        else\n            JDTrace.setTraceOn (false);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, \"trace: \" + trace);  //@A8C\n    }\n\n\n    /**\n    *  Sets the IBM i system\u0027s transaction isolation.\n    *  @param transactionIsolation The transaction isolation level.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \"none\"\n    *    \u003cli\u003e \"read uncommitted\"  - The default value.\n    *    \u003cli\u003e \"read committed\"\n    *    \u003cli\u003e \"repeatable read\"\n    *    \u003cli\u003e \"serializable\"\n    *  \u003c/ul\u003e\n    **/\n    public void setTransactionIsolation(String transactionIsolation)\n    {\n        String property \u003d \"transactionIsolation\";\n\n        if (transactionIsolation \u003d\u003d null)\n            throw new NullPointerException(property);\n        validateProperty(property, transactionIsolation, JDProperties.TRANSACTION_ISOLATION);\n\n        String old \u003d getTransactionIsolation();\n\n        properties_.setString(JDProperties.TRANSACTION_ISOLATION, transactionIsolation);\n\n        changes_.firePropertyChange(property, old, transactionIsolation);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + transactionIsolation);     //@A8C\n    }\n\n    /**\n    *  Sets whether binary data is translated.  If this property is set\n    *  to true, then BINARY and VARBINARY fields are treated as CHAR and\n    *  VARCHAR fields.\n    *  @param translate true if binary data is translated; false otherwise.\n    *  The default value is false.\n    **/\n    public void setTranslateBinary(boolean translate)\n    {\n        String property \u003d \"translateBinary\";\n\n        Boolean oldValue \u003d new Boolean(isTranslateBinary());\n        Boolean newValue \u003d new Boolean(translate);\n\n        if (translate)\n            properties_.setString(JDProperties.TRANSLATE_BINARY, TRUE_);\n        else\n            properties_.setString(JDProperties.TRANSLATE_BINARY, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) //@A8C\n            JDTrace.logInformation (this, property + \": \" + translate);  //@A8C\n    }\n    \n    //@PDA\n    /**\n    *  Sets how Boolean objects are interpreted when setting the value \n    *  for a character field/parameter using the PreparedStatement.setObject(), \n    *  CallableStatement.setObject() or ResultSet.updateObject() methods.  Setting the \n    *  property to \"true\", would store the Boolean object in the character field as either \n    *  \"true\" or \"false\".  Setting the property to \"false\", would store the Boolean object \n    *  in the character field as either \"1\" or \"0\".\n    *  @param translate true if boolean data is translated; false otherwise.\n    *  The default value is true.\n    **/\n    public void setTranslateBoolean(boolean translate)\n    {\n        String property \u003d \"translateBoolean\";\n\n        Boolean oldValue \u003d new Boolean(isTranslateBoolean());\n        Boolean newValue \u003d new Boolean(translate);\n\n        if (translate)\n            properties_.setString(JDProperties.TRANSLATE_BOOLEAN, TRUE_);\n        else\n            properties_.setString(JDProperties.TRANSLATE_BOOLEAN, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + translate);\n    }\n    \n\n    /**\n     *  Indicates whether blocking should be used for updates and delete.\n     *  @param value true if blocking is used for updates and deletes.\n     *  The default value is false.\n     **/\n     public void setUseBlockUpdate(boolean value)\n     {\n         String property \u003d JDProperties.DO_UPDATE_DELETE_BLOCKING_  ;\n         Boolean oldValue \u003d new Boolean(isUseBlockUpdate());\n         Boolean newValue \u003d new Boolean(value);\n\n         if (value)\n             properties_.setString(JDProperties.DO_UPDATE_DELETE_BLOCKING, TRUE_);\n         else\n             properties_.setString(JDProperties.DO_UPDATE_DELETE_BLOCKING, FALSE_);\n\n         changes_.firePropertyChange(property, oldValue, newValue);\n\n         if (JDTrace.isTraceOn()) \n             JDTrace.logInformation (this, property + \": \" + value);      \n     }\n\n    \n    /**\n    *  Sets the database user.\n    *  @param user The user.\n    **/\n    public void setUser(String user)\n    {\n        String property \u003d \"user\";\n\n        String old \u003d getUser();\n\n        // save away the user to serialize    // @F0A\n        serialUserName_ \u003d user;               // @F0A\n\n        try\n        {\n            as400_.setUserId(user);\n        }\n        catch (PropertyVetoException vp)\n        { /* ignore */\n        }\n\n        changes_.firePropertyChange(property, old, user);\n\n        logProperty (\"user\", as400_.getUserId());\n    }\n\n    //@K54\n    /**\n    *  Specifies whether variable-length fields should be compressed. \n    *  @param compress true if variable-length fields should be compressed; false otherwise.\n    *  The default value is true.\n    **/\n    public void setVariableFieldCompression(boolean compress)\n    {\n        String property \u003d \"variableFieldCompression\";\n\n        Boolean oldValue \u003d new Boolean(isVariableFieldCompression());\n        Boolean newValue \u003d new Boolean(compress);\n\n        if (compress)\n            properties_.setString(JDProperties.VARIABLE_FIELD_COMPRESSION, TRUE_);\n        else\n            properties_.setString(JDProperties.VARIABLE_FIELD_COMPRESSION, FALSE_);\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + compress);  \n    }\n\n    // @F1A Added the below methods to set socket options\n    /**\n    * Gets the socket keepalive option.\n    * @return The value of the socket keepalive option.\n    **/\n    public boolean getKeepAlive()\n    {\n        return sockProps_.isKeepAlive();\n    }\n\n    /**\n    * Gets the socket receive buffer size option.  NOTE: This does not get\n    * the actual receive buffer size, only the option which is used as a hint\n    * by the underlying socket code.\n    * @return The value of the socket receive buffer size option.\n    **/\n    public int getReceiveBufferSize()\n    {\n        return sockProps_.getReceiveBufferSize();\n    }\n\n    /**\n    * Gets the socket send buffer size option.  NOTE: This does not get\n    * the actual send buffer size, only the option which is used as a hint\n    * by the underlying socket code.\n    * @return The value of the socket send buffer size option.\n    **/\n    public int getSendBufferSize()\n    {\n        return sockProps_.getSendBufferSize();\n    }\n\n    /**\n    * Gets the socket linger option in seconds.\n    * @return The value of the socket linger option.\n    **/\n    public int getSoLinger()\n    {\n        return sockProps_.getSoLinger();\n    }\n\n    /**\n    * Gets the socket timeout option in milliseconds.\n    * @return The value of the socket timeout option.\n    **/\n    public int getSoTimeout()\n    {\n        return sockProps_.getSoTimeout();\n    }\n\n    /**\n    * Gets the socket TCP no delay option.\n    * @return The value of the socket TCP no delay option.\n    **/\n    public boolean getTcpNoDelay()\n    {\n        return sockProps_.isTcpNoDelay();\n    }\n\n    /**\n    * This property allows the turning on of socket keep alive.\n    * @param keepAlive The keepalive option value.\n    **/\n    public void setKeepAlive(boolean keepAlive)\n    {\n        sockProps_.setKeepAlive(keepAlive);\n    }\n\n    /**\n    * This property sets the receive buffer size socket option to the\n    * specified value. The receive buffer size option is used as a hint\n    * for the size to set the underlying network I/O buffers. Increasing\n    * the receive buffer size can increase the performance of network\n    * I/O for high-volume connection, while decreasing it can help reduce\n    * the backlog of incoming data.  This value must be greater than 0.\n    * @param size The socket receive buffer size option value.\n    **/\n    public void setReceiveBufferSize(int size)\n    {\n        sockProps_.setReceiveBufferSize(size);\n    }\n\n    /**\n    * This property sets the send buffer size socket option to the\n    * specified value. The send buffer size option is used by the\n    * platform\u0027s networking code as a hint for the size to set the\n    * underlying network I/O buffers.  This value must be greater\n    * than 0.\n    * @param size The socket send buffer size option value.\n    **/\n    public void setSendBufferSize(int size)\n    {\n        sockProps_.setSendBufferSize(size);\n    }\n\n    /**\n    * This property allows the turning on of socket linger with the\n    * specified linger time in seconds.  The maxium value for this\n    * property is platform specific.\n    * @param seconds The socket linger option value.\n    **/\n    public void setSoLinger(int seconds)\n    {\n        sockProps_.setSoLinger(seconds);\n    }\n\n    /**\n    * This property enables/disables socket timeout with the\n    * specified value in milliseconds.  A timeout value must be\n    * greater than zero, a value of zero for this property indicates\n    * infinite timeout.\n    * @param milliseconds The socket timeout option value.\n    **/\n    public void setSoTimeout(int milliseconds)\n    {\n        sockProps_.setSoTimeout(milliseconds);\n    }\n\n    //@STIMEOUT\n    /**\n     * This property enables/disables socket timeout with the\n     * specified value in milliseconds.  A timeout value must be\n     * greater than zero, a value of zero for this property indicates\n     * infinite timeout.\n     * @param milliseconds The socket timeout option value.\n     **/\n     public void setSocketTimeout(int milliseconds)\n     {\n         setSoTimeout(milliseconds);\n     }\n     \n    /**\n    * This property allows the turning on of the TCP no delay socket option.\n    * @param noDelay The socket TCP no delay option value.\n    **/\n    public void setTcpNoDelay(boolean noDelay)\n    {\n        sockProps_.setTcpNoDelay(noDelay);\n    }\n    // @F1A End of new socket option methods\n\n    // @M0A - added support for sending statements in UTF-16 and storing them in a UTF-16 package\n    /**\n    * Gets the package CCSID property, which indicates the\n    * CCSID in which statements are sent to the IBM i system and\n    * also the CCSID of the package they are stored in.\n    * Default value: 13488\n    * @return The value of the package CCSID property.\n    **/\n    public int getPackageCCSID()\n    {\n        return properties_.getInt(JDProperties.PACKAGE_CCSID);\n    }\n    \n    //@dup\n    /**\n     * Gets the package CCSID property, which indicates the\n     * CCSID in which statements are sent to the IBM i system and\n     * also the CCSID of the package they are stored in.\n     * Default value: 13488\n     * @return The value of the package CCSID property.\n     * Note:  this method is the same as getPackageCCSID() so that it corresponds to the connection property name\n     **/\n    public int getPackageCcsid()\n    {\n        return getPackageCCSID();\n    }\n\n    // @M0A\n    /**\n    * Sets the package CCSID property, which indicates the\n    * CCSID in which statements are sent to the IBM i system and\n    * also the CCSID of the package they are stored in.\n    * Recommended values:  1200(UTF-16)  and 13488 (UCS-2).  \n    * See \u003ca href\u003d\"BidiStringType.html\"\u003eBidiStringType\u003c/a\u003e for Bidi considerations.\n    * Default value: 13488\n    * @param ccsid The package CCSID.\n    **/\n    public void setPackageCCSID(int ccsid)\n    {\n        String property \u003d \"packageCCSID\";\n\n        Integer oldPackageCCSID \u003d new Integer(getPackageCCSID());\n        Integer newPackageCCSID \u003d new Integer(ccsid);\n\n        validateProperty(property, newPackageCCSID.toString(), JDProperties.PACKAGE_CCSID);\n\n        properties_.setString(JDProperties.PACKAGE_CCSID, newPackageCCSID.toString());\n\n        changes_.firePropertyChange(property, oldPackageCCSID, newPackageCCSID);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + ccsid);\n    }\n\n    //@dup\n    /**\n     * Sets the package CCSID property, which indicates the\n     * CCSID in which statements are sent to the IBM i system and\n     * also the CCSID of the package they are stored in.\n     * Recommended values:  1200(UTF-16)  and 13488 (UCS-2).  \n     * See \u003ca href\u003d\"BidiStringType.html\"\u003eBidiStringType\u003c/a\u003e for Bidi considerations.\n     * Default value: 13488\n     * @param ccsid The package CCSID.\n     * Note:  this method is the same as setPackageCCSID() so that it corresponds to the connection property name\n     **/\n    public void setPackageCcsid(int ccsid)\n    {\n        setPackageCCSID(ccsid);\n    }\n     \n    // @M0A - added support for 63 digit decimal precision\n    /**\n    * Gets the minimum divide scale property.  This property ensures the scale\n    * of the result of decimal division is never less than its specified value.\n    * Valid values: 0-9.  0 is default.\n    * @return The minimum divide scale.\n    **/\n    public int getMinimumDivideScale()\n    {\n        return properties_.getInt(JDProperties.MINIMUM_DIVIDE_SCALE);\n    }\n\n    /** \n     * Gets the maximum block input rows.  This property indicates the\n     * number of rows sent to the database engine for a block insert\n     * operation.  Valid values: 1-32000.  32000 is default. \n     * @return The maximum block input rows \n     */\n    public int getMaximumBlockedInputRows() {\n    \treturn properties_.getInt(JDProperties.MAXIMUM_BLOCKED_INPUT_ROWS); \n    }\n    \n    // @M0A\n    /**\n    * Gets the maximum precision property. This property indicates the \n    * maximum decimal precision the IBM i system should use.\n    * Valid values: 31 or 63.  31 is default.\n    * @return The maximum precision.\n    **/\n    public int getMaximumPrecision()\n    {\n        return properties_.getInt(JDProperties.MAXIMUM_PRECISION);\n    }\n\n    // @M0A\n    /**\n    * Gets the maximum scale property.  This property indicates the\n    * maximum decimal scale the IBM i system should use.\n    * Valid values: 0-63.  31 is default.\n    * @return The maximum scale.\n    **/\n    public int getMaximumScale()\n    {\n        return properties_.getInt(JDProperties.MAXIMUM_SCALE);\n    }\n\n    // @M0A\n    /**\n    * Sets the minimum divide scale property.  This property ensures the scale\n    * of the result of decimal division is never less than its specified value.\n    * Valid values: 0-9.  0 is default.\n    * @param scale The minimum divide scale.\n    **/\n    public void setMinimumDivideScale(int scale)\n    {\n        String property \u003d \"minimumDivideScale\";\n\n        Integer oldValue \u003d new Integer(getMinimumDivideScale());\n        Integer newValue \u003d new Integer(scale);\n\n        validateProperty(property, newValue.toString(), JDProperties.MINIMUM_DIVIDE_SCALE);\n\n        properties_.setString(JDProperties.MINIMUM_DIVIDE_SCALE, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + scale);\n    }\n\n    // @A6A \n    /**\n     * Sets the maximum blocked input rows.  This property indicates the \n     * maximum number of rows sent to the database engine for a blocked\n     * input operation.  Valid values:  1-32000.  32000 is the default\n     * @param maximumBlockedInputRows  The maximum number of input rows \n     */\n    public void setMaximumBlockedInputRows(int maximumBlockedInputRows)\n    {\n        String property \u003d \"maximumBlockedInputRows\"; \n\n        Integer oldValue \u003d new Integer(getMaximumBlockedInputRows());\n        Integer newValue \u003d new Integer(maximumBlockedInputRows);\n\n        if (maximumBlockedInputRows \u003c 0 || maximumBlockedInputRows \u003e 32000) {\n        \tthrow new ExtendedIllegalArgumentException(property, ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n        if (maximumBlockedInputRows \u003d\u003d 0) {\n        \tmaximumBlockedInputRows \u003d 32000; \n        }\n\n        properties_.setString(JDProperties.MAXIMUM_BLOCKED_INPUT_ROWS, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + maximumBlockedInputRows);\n    }\n    \n    \n    // @M0A\n    /**\n    * Sets the maximum precision property. This property indicates the \n    * maximum decimal precision the IBM i system should use.\n    * Valid values: 31 or 63.  31 is default.\n    * @param precision The maximum precision.\n    **/\n    public void setMaximumPrecision(int precision)\n    {\n        String property \u003d \"maximumPrecision\";\n\n        Integer oldValue \u003d new Integer(getMaximumPrecision());\n        Integer newValue \u003d new Integer(precision);\n\n        validateProperty(property, newValue.toString(), JDProperties.MAXIMUM_PRECISION);\n\n        properties_.setString(JDProperties.MAXIMUM_PRECISION, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + precision);\n    }\n\n    // @M0A\n    /**\n    * Sets the maximum scale property.  This property indicates the\n    * maximum decimal scale the IBM i system should use.\n    * Valid values: 0-63.  31 is default.\n    * @param scale The maximum scale.\n    **/\n    public void setMaximumScale(int scale)\n    {\n        String property \u003d \"maximumScale\";\n\n        Integer oldValue \u003d new Integer(getMaximumScale());\n        Integer newValue \u003d new Integer(scale);\n\n        // validate the new value\n        validateProperty(property, newValue.toString(), JDProperties.MAXIMUM_SCALE);\n        \n        properties_.setString(JDProperties.MAXIMUM_SCALE, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + scale);\n    }\n\n    // @M0A - added support for hex constant parser option\n    /**\n    * Gets the translate hex property, which indicates how\n    * the parser will treat hexadecimal literals.\n    * @return The value of the translate hex property.\n    * \u003cp\u003eValid values include:\n    * \u003cul\u003e\n    *   \u003cli\u003e\"character\" (Interpret hexadecimal constants as character data)\n    *   \u003cli\u003e\"binary\" (Interpret hexadecimal constants as binary data)\n    * \u003c/ul\u003e\n    * The default value is \"character\".\n    **/\n    public String getTranslateHex()\n    {\n        return properties_.getString(JDProperties.TRANSLATE_HEX);\n    }\n\n    // @M0A\n    /**\n    * Sets the translate hex property, which indicates how\n    * the parser will treat hexadecimal literals.\n    * @param parseOption The hex constant parser option.\n    * \u003cp\u003eValid values include:\n    * \u003cul\u003e\n    *   \u003cli\u003e\"character\" (Interpret hexadecimal constants as character data)\n    *   \u003cli\u003e\"binary\" (Interpret hexadecimal constants as binary data)\n    * \u003c/ul\u003e\n    * The default value is \"character\".\n    **/\n    public void setTranslateHex(String parseOption)\n    {\n        String property \u003d \"translateHex\";\n\n        String oldOption \u003d getTranslateHex();\n        String newOption \u003d parseOption;\n\n        validateProperty(property, newOption, JDProperties.TRANSLATE_HEX);\n\n        properties_.setString(JDProperties.TRANSLATE_HEX, newOption);\n\n        changes_.firePropertyChange(property, oldOption, newOption);\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + parseOption);\n    }\n\n    //@K3A\n    /**\n    *  Sets the QAQQINI library name.  \n    *  @param libraryName The QAQQINI library name.\n    **/\n    public void setQaqqiniLibrary(String libraryName)\n    {\n        String property \u003d \"qaqqiniLibrary\";\n        if (libraryName \u003d\u003d null)\n            throw new NullPointerException(property);\n\n        String old \u003d getQaqqiniLibrary();\n        properties_.setString(JDProperties.QAQQINILIB, libraryName);\n\n        changes_.firePropertyChange(property, old, libraryName);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + libraryName);  \n    }\n\n    //@dup\n    /**\n     *  Sets the QAQQINI library name.  \n     *  @param libraryName The QAQQINI library name.\n     *  Note:  this method is the same as setQaqqiniLibrary() so that it corresponds to the connection property name\n     **/\n    public void setQaqqinilib(String libraryName)\n    {\n        setQaqqiniLibrary(libraryName);\n    }\n     \n    /**                                                               \n    *  Sets the goal the IBM i system should use with optimization of queries.  \n    *  This setting corresponds with the system\u0027s QAQQINI option called OPTIMIZATION_GOAL.  \n    *  Note, this setting is ignored when running to V5R3 IBM i or earlier  \n    *  @param goal - the optimization goal \n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *  \u003cli\u003e0 \u003d Optimize query for first block of data (*ALLIO) when extended dynamic packages are used; Optimize query for entire result set (*FIRSTIO) when packages are not used\u003c/li\u003e\n    *  \u003cli\u003e1 \u003d Optimize query for first block of data (*FIRSTIO)\u003c/li\u003e\n    *  \u003cli\u003e2 \u003d Optimize query for entire result set (*ALLIO) \u003c/li\u003e\n    *  \u003c/ul\u003e\n    *  The default value is 0.\n    **/\n    public void setQueryOptimizeGoal(int goal)\n    {\n        String property \u003d \"queryOptimizeGoal\";\n\n        Integer oldValue \u003d new Integer(getQueryOptimizeGoal());\n        Integer newValue \u003d new Integer(goal);\n\n        properties_.setString(JDProperties.QUERY_OPTIMIZE_GOAL, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + goal);\n    }\n\n    //@550\n    /**\n    * Sets the storage limit in megabytes, that should be used for statements executing a query in a connection.\n    * Note, this setting is ignored when running to i5/OS V5R4 or earlier\n    * You must have *JOBCTL special authority to use query storage limit with Version 6 Release 1 of IBM i.\n    * @param limit the storage limit (in megabytes)\n    * \u003cp\u003e Valid values are -1 to MAX_STORAGE_LIMIT megabytes.  \n    * The default value is -1 meaning there is no limit.\n    **/\n    public void setQueryStorageLimit(int limit)\n    {\n        String property \u003d \"queryStorageLimit\";\n\n        if (limit \u003c -1 || limit \u003e MAX_STORAGE_LIMIT)\n            throw new ExtendedIllegalArgumentException(property, ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n\n        Integer oldValue \u003d new Integer(getQueryStorageLimit());\n        Integer newValue \u003d new Integer(limit);\n\n        properties_.setString(JDProperties.QUERY_STORAGE_LIMIT, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if(JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + limit);\n    }\n\n   /*@D4A*/\n    /**\n     * Sets the query timeout mechanism property, which indicates how\n     * the toolbox will enforce the query timeout specified on the statement. \n     * @param timeoutMechanism The timeout mechanism to use. \n     * \u003cp\u003eValid values include:\n     * \u003cul\u003e\n     *   \u003cli\u003e\"qqrytimlmt\" (QQRTIMLMT will be used)\n     *   \u003cli\u003e\"cancel\" (cancel will be used)\n     * \u003c/ul\u003e\n     * The default value is \"character\".\n     **/\n     public void setQueryTimeoutMechanism(String timeoutMechanism)\n     {\n         String property \u003d \"queryTimeoutMechanism\";\n\n         String oldOption \u003d getQueryTimeoutMechanism();\n         String newOption \u003d timeoutMechanism;\n\n         validateProperty(property, newOption, JDProperties.QUERY_TIMEOUT_MECHANISM);\n\n         properties_.setString(JDProperties.QUERY_TIMEOUT_MECHANISM, newOption);\n\n         changes_.firePropertyChange(property, oldOption, newOption);\n\n         if (JDTrace.isTraceOn())\n             JDTrace.logInformation (this, property + \": \" + timeoutMechanism);\n     }\n\n    \n    \n    //@540\n    /**                                                               \n    *  Sets whether lock sharing is allowed for loosely coupled transaction branches.\n    *  Note, this setting is ignored when running to V5R3 IBM i or earlier.  \n    *  @param lcs - the \"loosely coupled support\" setting \n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *  \u003cli\u003e0 \u003d Locks cannot be shared\u003c/li\u003e\n    *  \u003cli\u003e1 \u003d Locks can be shared\u003c/li\u003e\n    *  \u003c/ul\u003e\n    *  The default value is 0.\n    **/\n    public void setXALooselyCoupledSupport(int lcs)\n    {\n        String property \u003d \"xaLooselyCoupledSupport\";\n\n        Integer oldValue \u003d new Integer(getXALooselyCoupledSupport());\n        Integer newValue \u003d new Integer(lcs);\n\n        properties_.setString(JDProperties.XA_LOOSELY_COUPLED_SUPPORT, newValue.toString());\n\n        changes_.firePropertyChange(property, oldValue, newValue);\n\n        if (JDTrace.isTraceOn()) \n            JDTrace.logInformation (this, property + \": \" + lcs);\n    }\n\n    //K2A\n    /**\n    *  Returns the toolbox trace category.\n    *  @return The toolbox trace category.\n    *  \u003cp\u003eValid values include:\n    *  \u003cul\u003e\n    *    \u003cli\u003e \"none\" - The default value.\n    *    \u003cli\u003e \"datastream\"\n    *    \u003cli\u003e \"diagnostic\"\n    *    \u003cli\u003e \"error\"\n    *    \u003cli\u003e \"information\"\n    *    \u003cli\u003e \"warning\"\n    *    \u003cli\u003e \"conversion\"\n    *    \u003cli\u003e \"proxy\"\n    *    \u003cli\u003e \"pcml\"\n    *    \u003cli\u003e \"jdbc\"\n    *    \u003cli\u003e \"all\"\n    *    \u003cli\u003e \"thread\"\n    *  \u003c/ul\u003e\n    **/\n    public String getToolboxTraceCategory()\n    {\n        return properties_.getString(JDProperties.TRACE_TOOLBOX);\n    }\n    \n    //@dup\n    /**\n     *  Returns the toolbox trace category.\n     *  @return The toolbox trace category.\n     *  \u003cp\u003eValid values include:\n     *  \u003cul\u003e\n     *    \u003cli\u003e \"none\" - The default value.\n     *    \u003cli\u003e \"datastream\"\n     *    \u003cli\u003e \"diagnostic\"\n     *    \u003cli\u003e \"error\"\n     *    \u003cli\u003e \"information\"\n     *    \u003cli\u003e \"warning\"\n     *    \u003cli\u003e \"conversion\"\n     *    \u003cli\u003e \"proxy\"\n     *    \u003cli\u003e \"pcml\"\n     *    \u003cli\u003e \"jdbc\"\n     *    \u003cli\u003e \"all\"\n     *    \u003cli\u003e \"thread\"\n     *  \u003c/ul\u003e\n     *  Note:  this method is the same as getToolboxTraceCategory() so that it corresponds to the connection property name\n     **/\n    public String getToolboxTrace()\n    {\n        return getToolboxTraceCategory();\n    }\n\n    // @K2A\n    /**\n    * Sets the toolbox trace category, which indicates \n    * what trace points and diagnostic messages should be logged.\n    * @param traceCategory The category option.\n    * \u003cp\u003eValid values include:\n    * \u003cul\u003e\n    *    \u003cli\u003e \"none\" \n    *    \u003cli\u003e \"datastream\"\n    *    \u003cli\u003e \"diagnostic\"\n    *    \u003cli\u003e \"error\"\n    *    \u003cli\u003e \"information\"\n    *    \u003cli\u003e \"warning\"\n    *    \u003cli\u003e \"conversion\"\n    *    \u003cli\u003e \"proxy\"\n    *    \u003cli\u003e \"pcml\"\n    *    \u003cli\u003e \"jdbc\"\n    *    \u003cli\u003e \"all\"\n    *    \u003cli\u003e \"thread\"    \n    * \u003c/ul\u003e\n    * The default value is \"none\".\n    **/\n    public void setToolboxTraceCategory(String traceCategory)\n    {\n        String property \u003d \"toolboxTrace\";\n\n        String oldOption \u003d getToolboxTraceCategory();\n        String newOption \u003d traceCategory;\n\n        validateProperty(property, newOption, JDProperties.TRACE_TOOLBOX);\n\n        properties_.setString(JDProperties.TRACE_TOOLBOX, newOption);\n\n        changes_.firePropertyChange(property, oldOption, newOption);\n\n        if(!traceCategory.equals(\"\") \u0026\u0026 !traceCategory.equals(\"none\"))\n        {\n            if (! Trace.isTraceOn())\n            {\n                Trace.setTraceOn(true);\n            }\n            if(traceCategory.equals(\"datastream\"))\n                Trace.setTraceDatastreamOn(true);\n            else if(traceCategory.equals(\"diagnostic\"))\n                Trace.setTraceDiagnosticOn(true);\n            else if(traceCategory.equals(\"error\"))\n                Trace.setTraceErrorOn(true);\n            else if(traceCategory.equals(\"information\"))\n                Trace.setTraceInformationOn(true);\n            else if(traceCategory.equals(\"warning\"))\n                Trace.setTraceWarningOn(true);\n            else if(traceCategory.equals(\"conversion\"))\n                Trace.setTraceConversionOn(true);\n            else if(traceCategory.equals(\"proxy\"))\n                Trace.setTraceProxyOn(true);\n            else if(traceCategory.equals(\"pcml\"))\n                Trace.setTracePCMLOn(true);\n            else if(traceCategory.equals(\"jdbc\"))\n                Trace.setTraceJDBCOn(true);\n            else if(traceCategory.equals(\"all\"))\n                Trace.setTraceAllOn(true);\n            else if(traceCategory.equals(\"thread\"))\n                Trace.setTraceThreadOn(true);\n        }\n\n        if (JDTrace.isTraceOn())\n            JDTrace.logInformation (this, property + \": \" + traceCategory);\n    }\n\n    //@dup\n    /**\n     * Sets the toolbox trace category, which indicates \n     * what trace points and diagnostic messages should be logged.\n     * @param traceCategory The category option.\n     * \u003cp\u003eValid values include:\n     * \u003cul\u003e\n     *    \u003cli\u003e \"none\" \n     *    \u003cli\u003e \"datastream\"\n     *    \u003cli\u003e \"diagnostic\"\n     *    \u003cli\u003e \"error\"\n     *    \u003cli\u003e \"information\"\n     *    \u003cli\u003e \"warning\"\n     *    \u003cli\u003e \"conversion\"\n     *    \u003cli\u003e \"proxy\"\n     *    \u003cli\u003e \"pcml\"\n     *    \u003cli\u003e \"jdbc\"\n     *    \u003cli\u003e \"all\"\n     *    \u003cli\u003e \"thread\"    \n     * \u003c/ul\u003e\n     * The default value is \"none\".\n     * Note:  this method is the same as setToolboxTraceCategory() so that it corresponds to the connection property name\n     **/\n    public void setToolboxTrace(String traceCategory)\n    {\n        setToolboxTraceCategory(traceCategory);\n    }\n    \n    /**\n    *  Validates the property value.\n    *  @param property The property name.\n    *  @param value The property value.\n    *  @param index The property index.\n    **/\n    private void validateProperty(String property, String value, int index)\n    {\n        if (value.length() !\u003d 0)\n        {                                                      // @A7A\n            DriverPropertyInfo[] info \u003d properties_.getInfo();\n            String[] choices \u003d info[index].choices;\n                        \n            //Bidi-HCG start\n            //exception for \"package ccsid\" - it can accept any integer\n            if(index \u003d\u003d JDProperties.PACKAGE_CCSID){            \t            \t            \t\n            \ttry{            \t\n            \t\tint ccsid \u003d Integer.valueOf(value).intValue();\n            \t\tif(ccsid \u003c 1)\n            \t\t\tthrow new ExtendedIllegalArgumentException(property, ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID); \n            \t\treturn;\n            \t}catch(NumberFormatException e){\n            \t\tthrow new ExtendedIllegalArgumentException(property, ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);            \t\t\n            \t}\n            }                 \n            //Bidi-HCG end\n            \n            boolean notValid \u003d true;\n            int current \u003d 0;\n            while (notValid \u0026\u0026 current \u003c choices.length)\n            {\n                if (value.equalsIgnoreCase(choices[current]))\n                    notValid \u003d false;\n                else\n                    current++;\n            }\n            if (notValid)\n                throw new ExtendedIllegalArgumentException(property, ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }                                                                                    // @A7A\n    }\n\n    /**\n    *  Serializes the IBM i system and user information.\n    *  @param out The output stream.\n    *  @exception IOException If a file I/O error occurs.\n    **/\n    private void writeObject(ObjectOutputStream out) throws IOException\n    {\n    \tTrace.log(Trace.INFORMATION, \"AS400JDBCDataSource.writeObject\"); \n        // @F0D String server \u003d getServerName();\n        // @F0D if (!server.equals(\"\"))\n        // @F0D     serialServerName_ \u003d server;\n\n        // @F0D String user \u003d getUser();\n        // @F0D if (!user.equals(\"\"))\n        // @F0D     serialUserName_ \u003d user;\n\n        if (!savePasswordWhenSerialized_)                        //@J3a\n        {                                                        //@J3a\n            serialPWBytes_ \u003d null;                                //@J3a\n            serialKeyRingPWBytes_ \u003d null;                         //@J3a\n        }                                                        //@J3a\n\n        // Serialize the object.\n        out.defaultWriteObject();\n    }\n\n    /**\n    *  Returns the string representation of the object.\n    *  @return The string representation.\n    **/\n    public String toString()\n    {\n        /*\n        * Implementation note: Used only for tracing information.\n        */\n        String name \u003d getDataSourceName();\n        if (name \u003d\u003d null)\n            name \u003d \"\";\n        return name;\n    }\n\n    // @J3 new method.\n    // Twiddle password bytes.\n    private static char[] xpwConfuse(String info)\n    {\n        Random rng \u003d new Random();\n        byte[] adderBytes \u003d new byte[18];\n        rng.nextBytes(adderBytes);\n        char[] adder \u003d BinaryConverter.byteArrayToCharArray(adderBytes);\n\n        byte[] maskBytes \u003d new byte[14];\n        rng.nextBytes(maskBytes);\n        char[] mask \u003d BinaryConverter.byteArrayToCharArray(maskBytes);\n\n        char[] infoBytes \u003d xencode(adder, mask, info.toCharArray());\n        char[] returnBytes \u003d new char[info.length() + 16];\n        System.arraycopy(adder, 0, returnBytes, 0, 9);\n        System.arraycopy(mask, 0, returnBytes, 9, 7);\n        System.arraycopy(infoBytes, 0, returnBytes, 16, info.length());\n\n        return returnBytes;\n    }\n\n    // @J3 new method.\n    // Get clear password bytes back.\n    private static String xpwDeconfuse(char[] info)\n    {\n        char[] adder \u003d new char[9];\n        System.arraycopy(info, 0, adder, 0, 9);\n        char[] mask \u003d new char[7];\n        System.arraycopy(info, 9, mask, 0, 7);\n        char[] infoBytes \u003d new char[info.length - 16];\n        System.arraycopy(info, 16, infoBytes, 0, info.length - 16);\n\n        return new String(xdecode(adder, mask, infoBytes));\n    }\n\n    // @J3 new method    \n    // Scramble some bytes.\n    private static char[] xencode(char[] adder, char[] mask, char[] bytes)\n    {\n        if (bytes \u003d\u003d null) return null;\n        int length \u003d bytes.length;\n        char[] buf \u003d new char[length];\n        for (int i \u003d 0; i \u003c length; ++i)\n        {\n            buf[i] \u003d (char)(bytes[i] + adder[i % 9]);\n        }\n        for (int i \u003d 0; i \u003c length; ++i)\n        {\n            buf[i] \u003d (char)(buf[i] ^ mask[i % 7]);\n        }\n        return buf;\n    }\n\n\n    // @J3 new method.       \n    private static char[] xdecode(char[] adder, char[] mask, char[] bytes)\n    {\n        int length \u003d bytes.length;\n        char[] buf \u003d new char[length];\n        for (int i \u003d 0; i \u003c length; ++i)\n        {\n            buf[i] \u003d (char)(mask[i % 7] ^ bytes[i]);\n        }\n        for (int i \u003d 0; i \u003c length; ++i)\n        {\n            buf[i] \u003d (char)(buf[i] - adder[i % 9]);\n        }\n        return buf;\n    }\n    \n    \n    //@pda jdbc40\n    protected String[] getValidWrappedList()\n    {\n        return new String[] {  \"com.ibm.as400.access.AS400JDBCDataSource\", \"javax.sql.DataSource\" };\n    } \n/* ifdef JDBC40 */\n    public Logger getParentLogger() throws SQLFeatureNotSupportedException {\n    throw new SQLFeatureNotSupportedException(); \n      \n    } \n/* endif */\n\n\t/**\n\tCommits the JDBC property values being displayed to the data source.\n\t\n\t@param as400jdbcDataSourcePane TODO\n\t * @return true if changes were applied successfully; false otherwise.\n\t**/\n\t\n\tpublic boolean applyChanges(AS400JDBCDataSourcePane as400jdbcDataSourcePane)\n\t{\n\t    // The following try/catch block calls the applyChanges method on the tabbed pane and handles the\n\t    // IllegalUserDataExceptions that occur.  An IllegalUserDataException exception is thrown when\n\t    // a rule defined by the GUI builder is broken.  For instance, if a field is defined to be\n\t    // required and no value is provided the exception will be thrown.\n\t    // Assuming no exceptions are thrown, our databean will be updated with the current GUI values\n\t    // when the tabPaneManager applyChanges method returns.  That is, the tabPaneManager applyChanges\n\t    // method calls all of the databean settor methods.\n\t    \n\t    try\n\t    {\n\t\t    as400jdbcDataSourcePane.m_tabbedPaneManager.applyChanges();\n\t    }\n\t    catch (IllegalUserDataException  e) \n\t    {   // This will put up the error message and put focus on the offending control\n\t        Container c \u003d (Container)e.getComponent();\n\t\t    PanelManager.handleDataException(e,c);\n\t\t    return false;\n\t    }\n\t        \n\t    as400jdbcDataSourcePane.applyChangesToCurrentDataSource(this);    \n\t    return true;\n\t} \n    \n    \n}"},"candidatesTelemetryData":{"numberOfSuggestions":4,"candidates":[{"lineStart":1990,"lineEnd":2001,"refactoringType":"MyMoveMethodRefactoring","refactoringInfo":"Move method log to class EventLog","description":"Move method to com.ibm.as400.access.EventLog\nRationale: The log method is specifically designed to log messages, which aligns directly with the responsibilities of an EventLog class. This class would typically handle logging operations, making it the most appropriate target for this method.","couldCreateRefObject":true,"applied":false,"undone":false},{"lineStart":2003,"lineEnd":2015,"refactoringType":"MyMoveMethodRefactoring","refactoringInfo":"Move method logProperty to class EventLog","description":"Move method to com.ibm.as400.access.EventLog\nRationale: The method logProperty is specifically designed to log properties and values, which aligns directly with the responsibilities of an EventLog class.","couldCreateRefObject":true,"applied":false,"undone":false},{"lineStart":5213,"lineEnd":5229,"refactoringType":"MyMoveStaticMethodRefactoring","refactoringInfo":"Move Static method xencode to class AS400CertificateUtilImplRemote","description":"move method to com.ibm.as400.access.AS400CertificateUtilImplRemote\nRationale: The xencode method involves encoding and scrambling bytes, which is often related to security and certificate handling. AS400CertificateUtilImplRemote likely deals with certificate utilities, making it a suitable class for this method.","couldCreateRefObject":true,"applied":false,"undone":false},{"lineStart":5232,"lineEnd":5246,"refactoringType":"MyMoveStaticMethodRefactoring","refactoringInfo":"Move Static method xdecode to class AS400CertificateUtilImplRemote","description":"move method to com.ibm.as400.access.AS400CertificateUtilImplRemote\nRationale: The xdecode method appears to be related to encoding and decoding operations, which are often associated with certificate handling and security. AS400CertificateUtilImplRemote is likely to deal with such operations, making it a suitable target class.","couldCreateRefObject":true,"applied":false,"undone":false}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":4111},{"candidateIndex":1,"elapsedTime":822},{"candidateIndex":2,"elapsedTime":1510},{"candidateIndex":3,"elapsedTime":3266}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":49274},"iterationData":[{"iteration_num":1,"suggested_move_methods":[{"method_name":"log","method_signature":"void log(String message)","target_class":"Logger","rationale":"The log method is responsible for logging messages, which is a concern that belongs to a logging utility class rather than the AS400JDBCDataSource class."},{"method_name":"logProperty","method_signature":"private void logProperty(String property, String value)","target_class":"Logger","rationale":"The logProperty method is also related to logging and should be moved to a dedicated logging utility class to separate concerns."},{"method_name":"initializeTransient","method_signature":"private void initializeTransient()","target_class":"AS400","rationale":"The method initializes transient data related to the AS400 object, which suggests that it should be part of the AS400 class to encapsulate its initialization logic."},{"method_name":"xpwConfuse","method_signature":"private static char[] xpwConfuse(String info)","target_class":"PasswordUtils","rationale":"The xpwConfuse method is related to password handling and should be moved to a utility class dedicated to password operations."},{"method_name":"xpwDeconfuse","method_signature":"private static String xpwDeconfuse(char[] info)","target_class":"PasswordUtils","rationale":"Similar to xpwConfuse, this method deals with password handling and should be part of a dedicated utility class for better organization."},{"method_name":"xencode","method_signature":"private static char[] xencode(char[] adder, char[] mask, char[] bytes)","target_class":"PasswordUtils","rationale":"This method is also related to encoding passwords and should be moved to a utility class focused on password operations."},{"method_name":"xdecode","method_signature":"private static char[] xdecode(char[] adder, char[] mask, char[] bytes)","target_class":"PasswordUtils","rationale":"This method is related to decoding passwords and should be part of a dedicated utility class for password operations."}],"llm_response_time":16629},{"iteration_num":2,"suggested_move_methods":[{"method_name":"log","method_signature":"void log(String message)","target_class":"Logger","rationale":"The log method is responsible for logging messages, which is a concern that belongs to a logging utility class rather than the AS400JDBCDataSource class."},{"method_name":"logProperty","method_signature":"private void logProperty(String property, String value)","target_class":"Logger","rationale":"The logProperty method is also related to logging and should be moved to a dedicated logging utility class to separate concerns."},{"method_name":"initializeTransient","method_signature":"private void initializeTransient()","target_class":"AS400","rationale":"The method initializes transient data related to the AS400 object, which suggests that it should be part of the AS400 class to encapsulate its initialization logic."},{"method_name":"xpwConfuse","method_signature":"private static char[] xpwConfuse(String info)","target_class":"PasswordUtils","rationale":"The xpwConfuse method is responsible for password manipulation, which is a utility function that should be part of a dedicated password handling class."},{"method_name":"xpwDeconfuse","method_signature":"private static String xpwDeconfuse(char[] info)","target_class":"PasswordUtils","rationale":"Similar to xpwConfuse, this method deals with password manipulation and should be moved to a dedicated password handling class."},{"method_name":"xencode","method_signature":"private static char[] xencode(char[] adder, char[] mask, char[] bytes)","target_class":"PasswordUtils","rationale":"The xencode method is related to encoding passwords and should be part of a dedicated password utility class."},{"method_name":"xdecode","method_signature":"private static char[] xdecode(char[] adder, char[] mask, char[] bytes)","target_class":"PasswordUtils","rationale":"The xdecode method is also related to decoding passwords and should be moved to a dedicated password utility class."}],"llm_response_time":13328},{"iteration_num":3,"suggested_move_methods":[{"method_name":"log","method_signature":"void log(String message)","target_class":"Logger","rationale":"The log method is responsible for logging messages, which is a concern that belongs to a logging utility class rather than a data source class."},{"method_name":"logProperty","method_signature":"private void logProperty(String property, String value)","target_class":"Logger","rationale":"The logProperty method is also related to logging and should be moved to a dedicated logging utility class to separate concerns."},{"method_name":"initializeTransient","method_signature":"private void initializeTransient()","target_class":"AS400","rationale":"The method initializes transient data related to the AS400 object, which suggests that it should be part of the AS400 class to encapsulate its initialization logic."},{"method_name":"xpwConfuse","method_signature":"private static char[] xpwConfuse(String info)","target_class":"PasswordUtils","rationale":"The xpwConfuse method is related to password handling and should be moved to a utility class dedicated to password operations."},{"method_name":"xpwDeconfuse","method_signature":"private static String xpwDeconfuse(char[] info)","target_class":"PasswordUtils","rationale":"Similar to xpwConfuse, this method deals with password handling and should be part of a dedicated utility class for better organization."},{"method_name":"xencode","method_signature":"private static char[] xencode(char[] adder, char[] mask, char[] bytes)","target_class":"PasswordUtils","rationale":"This method is also related to encoding passwords and should be moved to a utility class focused on password operations."},{"method_name":"xdecode","method_signature":"private static char[] xdecode(char[] adder, char[] mask, char[] bytes)","target_class":"PasswordUtils","rationale":"The xdecode method is related to decoding passwords and should be part of a utility class dedicated to password operations."}],"llm_response_time":12981},{"iteration_num":-1,"suggested_move_methods":[{"method_name":"log","method_signature":"void log(String message)","target_class":"Logger","rationale":"The log method is responsible for logging messages, which is a concern that belongs to a logging utility class rather than the AS400JDBCDataSource class."},{"method_name":"logProperty","method_signature":"private void logProperty(String property, String value)","target_class":"Logger","rationale":"The logProperty method is also related to logging and should be moved to a dedicated logging utility class to separate concerns."},{"method_name":"initializeTransient","method_signature":"private void initializeTransient()","target_class":"AS400","rationale":"The method initializes transient data related to the AS400 object, which suggests that it should be part of the AS400 class to encapsulate its initialization logic."},{"method_name":"xpwConfuse","method_signature":"private static char[] xpwConfuse(String info)","target_class":"PasswordUtils","rationale":"The xpwConfuse method is related to password handling and should be moved to a utility class dedicated to password operations."},{"method_name":"xpwDeconfuse","method_signature":"private static String xpwDeconfuse(char[] info)","target_class":"PasswordUtils","rationale":"Similar to xpwConfuse, this method deals with password handling and should be part of a dedicated utility class for better organization."},{"method_name":"xencode","method_signature":"private static char[] xencode(char[] adder, char[] mask, char[] bytes)","target_class":"PasswordUtils","rationale":"This method is also related to encoding passwords and should be moved to a utility class focused on password operations."},{"method_name":"xdecode","method_signature":"private static char[] xdecode(char[] adder, char[] mask, char[] bytes)","target_class":"PasswordUtils","rationale":"This method is related to decoding passwords and should be part of a dedicated utility class for password operations."}],"llm_response_time":0}],"llmMethodPriority":{"priority_method_names":["initializeTransient","log","logProperty","xpwConfuse","xpwDeconfuse","xencode","xdecode"],"llm_response_time":6219},"targetClassMap":{"initializeTransient":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":1479,"similarity_computation_time":0,"similarity_metric":"cosine"},"log":{"target_classes":[{"class_name":"EventLog","similarity_score":0.6038795256110688}],"target_classes_sorted_by_llm":["EventLog"],"llm_response_time":1419,"similarity_computation_time":1,"similarity_metric":"cosine"},"logProperty":{"target_classes":[{"class_name":"AS400","similarity_score":0.45604650603223595},{"class_name":"JDProperties","similarity_score":0.10441203015219931},{"class_name":"SocketProperties","similarity_score":0.38212482737833403},{"class_name":"EventLog","similarity_score":0.5664007155933504}],"target_classes_sorted_by_llm":["EventLog","JDProperties","AS400","SocketProperties"],"llm_response_time":1468,"similarity_computation_time":22,"similarity_metric":"cosine"},"xpwConfuse":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":1561,"similarity_computation_time":0,"similarity_metric":"cosine"},"xpwDeconfuse":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":1163,"similarity_computation_time":0,"similarity_metric":"cosine"},"xencode":{"target_classes":[{"class_name":"IFSFileOutputStreamImplProxy","similarity_score":0.3218261738454094},{"class_name":"IFSRandomAccessFileImplProxy","similarity_score":0.3478152367625214},{"class_name":"LicenseGetInformationRequest","similarity_score":0.25242189714700275},{"class_name":"ObjectAlreadyExistsException","similarity_score":0.25629512101233287},{"class_name":"ObjectDescriptionEnumeration","similarity_score":0.4689650165146033},{"class_name":"RCCallProgramReplyDataStream","similarity_score":0.5440592298939506},{"class_name":"RequestNotSupportedException","similarity_score":0.2070951535546416},{"class_name":"UserSpaceNativeReadWriteImpl","similarity_score":0.11320978622099119},{"class_name":"ZonedDecimalFieldDescription","similarity_score":0.38292130482424863},{"class_name":"AS400JDBCXADataSourceBeanInfo","similarity_score":0.3228369312989552},{"class_name":"DBColumnDescriptorsDataFormat","similarity_score":0.3093801328447795},{"class_name":"DQRequestAttributesDataStream","similarity_score":0.24148106922928037},{"class_name":"ExtendedIllegalStateException","similarity_score":0.2485569728575902},{"class_name":"IFSFileOutputStreamImplRemote","similarity_score":0.38520177859687843},{"class_name":"IFSRandomAccessFileImplRemote","similarity_score":0.34410727993393936},{"class_name":"PackedDecimalFieldDescription","similarity_score":0.3764200754087535},{"class_name":"PSSecureServerSocketContainer","similarity_score":0.3414829612953001},{"class_name":"RCRunCommandRequestDataStream","similarity_score":0.3915694228399682},{"class_name":"AS400CertificateUsrPrfUtilImpl","similarity_score":0.26785714285714285},{"class_name":"AS400CertificateUtilImplNative","similarity_score":0.257416178600405},{"class_name":"AS400CertificateUtilImplRemote","similarity_score":0.5314071127080738},{"class_name":"AS400FileRecordDescriptionImpl","similarity_score":0.051356420341326},{"class_name":"DQExchangeAttributesDataStream","similarity_score":0.264826729620164},{"class_name":"IFSTextFileInputStreamBeanInfo","similarity_score":0.2934839220468474},{"class_name":"PrintObjectPageInputStreamImpl","similarity_score":0.053027830342765855},{"class_name":"PSServerSocketContainerAdapter","similarity_score":0.19164769207223462},{"class_name":"RCCallProgramRequestDataStream","similarity_score":0.5811150910019377},{"class_name":"VariableLengthFieldDescription","similarity_score":0.05661385170722978},{"class_name":"AS400CertificateUserProfileUtil","similarity_score":0.2691941216337121},{"class_name":"AS400FileRecordDescriptionEvent","similarity_score":0.2788866755113585}],"target_classes_sorted_by_llm":["AS400CertificateUtilImplRemote","AS400CertificateUtilImplNative","RCCallProgramRequestDataStream","RCCallProgramReplyDataStream","ObjectDescriptionEnumeration","RCRunCommandRequestDataStream","IFSFileOutputStreamImplRemote","ZonedDecimalFieldDescription","PackedDecimalFieldDescription","IFSRandomAccessFileImplProxy","IFSRandomAccessFileImplRemote","PSSecureServerSocketContainer","AS400JDBCXADataSourceBeanInfo","IFSFileOutputStreamImplProxy","DBColumnDescriptorsDataFormat","IFSTextFileInputStreamBeanInfo","AS400FileRecordDescriptionEvent","AS400CertificateUserProfileUtil","AS400CertificateUsrPrfUtilImpl","DQExchangeAttributesDataStream","ObjectAlreadyExistsException","LicenseGetInformationRequest","ExtendedIllegalStateException","DQRequestAttributesDataStream","RequestNotSupportedException","PSServerSocketContainerAdapter","UserSpaceNativeReadWriteImpl","VariableLengthFieldDescription","PrintObjectPageInputStreamImpl","AS400FileRecordDescriptionImpl"],"llm_response_time":1544,"similarity_computation_time":15,"similarity_metric":"cosine"},"xdecode":{"target_classes":[{"class_name":"IFSFileOutputStreamImplProxy","similarity_score":0.33465701636864364},{"class_name":"IFSRandomAccessFileImplProxy","similarity_score":0.3569562002588548},{"class_name":"LicenseGetInformationRequest","similarity_score":0.2642473191046953},{"class_name":"ObjectAlreadyExistsException","similarity_score":0.21464159612961406},{"class_name":"ObjectDescriptionEnumeration","similarity_score":0.4523615513816269},{"class_name":"RCCallProgramReplyDataStream","similarity_score":0.5206290652594218},{"class_name":"RequestNotSupportedException","similarity_score":0.17034059055041778},{"class_name":"UserSpaceNativeReadWriteImpl","similarity_score":0.11192934182773806},{"class_name":"ZonedDecimalFieldDescription","similarity_score":0.3692379491951046},{"class_name":"AS400JDBCXADataSourceBeanInfo","similarity_score":0.3151772484002556},{"class_name":"DBColumnDescriptorsDataFormat","similarity_score":0.2603903320573635},{"class_name":"DQRequestAttributesDataStream","similarity_score":0.2283300075899051},{"class_name":"ExtendedIllegalStateException","similarity_score":0.19838554551820048},{"class_name":"IFSFileOutputStreamImplRemote","similarity_score":0.340642993600479},{"class_name":"IFSRandomAccessFileImplRemote","similarity_score":0.2964398713400368},{"class_name":"PackedDecimalFieldDescription","similarity_score":0.36282411469837184},{"class_name":"PSSecureServerSocketContainer","similarity_score":0.2986547638614667},{"class_name":"RCRunCommandRequestDataStream","similarity_score":0.31531815887581877},{"class_name":"AS400CertificateUsrPrfUtilImpl","similarity_score":0.2504957343824594},{"class_name":"AS400CertificateUtilImplNative","similarity_score":0.24552218771508832},{"class_name":"AS400CertificateUtilImplRemote","similarity_score":0.5159189580345952},{"class_name":"AS400FileRecordDescriptionImpl","similarity_score":0.035841571980331596},{"class_name":"DQExchangeAttributesDataStream","similarity_score":0.23227654131677025},{"class_name":"IFSTextFileInputStreamBeanInfo","similarity_score":0.2926028679903264},{"class_name":"PrintObjectPageInputStreamImpl","similarity_score":0.04857306118780301},{"class_name":"PSServerSocketContainerAdapter","similarity_score":0.17868250763028734},{"class_name":"RCCallProgramRequestDataStream","similarity_score":0.5168894150734434},{"class_name":"VariableLengthFieldDescription","similarity_score":0.035559653200246656},{"class_name":"AS400CertificateUserProfileUtil","similarity_score":0.23015475717784692},{"class_name":"AS400FileRecordDescriptionEvent","similarity_score":0.2815250611904345}],"target_classes_sorted_by_llm":["AS400CertificateUtilImplRemote","AS400CertificateUtilImplNative","AS400CertificateUserProfileUtil","RCCallProgramReplyDataStream","RCCallProgramRequestDataStream","ObjectDescriptionEnumeration","ZonedDecimalFieldDescription","PackedDecimalFieldDescription","IFSRandomAccessFileImplProxy","IFSFileOutputStreamImplRemote","IFSFileOutputStreamImplProxy","RCRunCommandRequestDataStream","AS400JDBCXADataSourceBeanInfo","PSSecureServerSocketContainer","IFSRandomAccessFileImplRemote","IFSTextFileInputStreamBeanInfo","AS400FileRecordDescriptionEvent","LicenseGetInformationRequest","DBColumnDescriptorsDataFormat","AS400CertificateUsrPrfUtilImpl","DQExchangeAttributesDataStream","DQRequestAttributesDataStream","ObjectAlreadyExistsException","ExtendedIllegalStateException","PSServerSocketContainerAdapter","RequestNotSupportedException","UserSpaceNativeReadWriteImpl","PrintObjectPageInputStreamImpl","AS400FileRecordDescriptionImpl","VariableLengthFieldDescription"],"llm_response_time":1987,"similarity_computation_time":7,"similarity_metric":"cosine"}}}
    },
    {
        "oracle": "method com.ibm.as400.access.Permission::removeRow(int):void need move com.ibm.as400.vaccess.PermissionTableModelQSYS",
        "class_name": "com.ibm.as400.access.Permission",
        "telemetry": {"id":"b4a405fb-a601-492a-9af4-d2cc9246cdb2","hostFunctionTelemetryData":{"hostFunctionSize":1256,"lineStart":47,"lineEnd":1302,"bodyLineStart":47,"language":"java","filePath":"/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/large/big/jtopen-7.8/src/com/ibm/as400/access/Permission.java","sourceCode":"/**\n * Retrieves a user\u0027s authority to an object.\u003cbr\u003e\n * To improve performance, the Permission object caches authority changes \n * until the \u003ci\u003ecommit()\u003c/i\u003e method is called. When \u003ci\u003ecommit()\u003c/i\u003eis called, \n * all changes up to that point are sent to the system.\u003cbr\u003e\n * The permission of an object is a collection of many users\u0027 authority to that object,\n * and the UserPermission class is used to represent a user\u0027s authority to a object. \n * Because there are three kinds of objects on the system, three subclasses of \n * UserPermission are defined:\n * \u003cul\u003e\n *      \u003cli\u003e DLOPermission  - Represents a user\u0027s authority to a Document Library Objects (DLO)\n *                            stored in QDLS.\n *      \u003cli\u003e QSYSPermission - Represents a user\u0027s authority to the object which is contained in the system library\n *                            structure and stored in QSYS.LIB.\n *      \u003cli\u003e RootPermission - Represents a user\u0027s authority to the object which is contained in the root directory \n *                            structure. This includes everything that is not in QSYS.LIB or QDLS.\n * \u003c/ul\u003e\n * Here is a simple example:\n * \u003cp\u003e\u003cblockquote\u003e\u003cpre\u003e\n * AS400 as400 \u003d new AS400();\n * Permission permission \u003d new Permission(as400,\"/QSYS.LIB/QJAVA.LIB\");\n * permission.addAuthorizedUser(\"user1\");\n * QSYSPermission userPermission \u003d (QSYSPermission)permission.getUserPermission(\"user1\");\n * userPermission.setObjectAuthority(\"*CHANGE\");\n * permission.commit();\n * \u003c/pre\u003e\u003c/blockquote\u003e\u003c/p\u003e\n * @see UserPermission\n * @see DLOPermission\n * @see QSYSPermission\n * @see RootPermission\n**/\npublic class Permission\n       implements Serializable\n{\n    static final long serialVersionUID \u003d 4L;\n\n\n    /**\n     * Constant indicating the object is a Document Library Objects (DLO)\n     * stored in QDLS.\n     *\n    **/\n    public static final int TYPE_DLO \u003d 0;\n\n    /**\n     * Constant indicating the object is contained in the system library\n     * structure and stored in QSYS.LIB.\n     *\n    **/\n    public static final int TYPE_QSYS \u003d 1;\n\n\n    /**\n     * Constant indicating that the object is contained in the root directory \n     * structure. This includes everything that is not in QSYS.LIB or QDLS.\n     *\n    **/\n    public static final int TYPE_ROOT \u003d 2;\n\n    private AS400 as400_;\n    private String authorizationList_;\n    private String autListBackup_;\n    private boolean autListChanged_;\n    private String name_;\n    private String owner_;\n    private boolean ownerChanged_;                        // @B2a\n    private boolean revokeOldAuthority_;                  // @B2a\n    private boolean revokeOldGroupAuthority_;\n    private boolean followSymbolicLinks_ \u003d true;\n\n    // @B6 The name supplied by the application for QSYS objects on IASPs is\n    //     \"/aspName/QSYS.LIB/...\".  For QSYS objects the asp name will \n    //     be stripped.  path_ will start with /QSYS.LIB, asp_ will hold\n    //     the asp name.  Most pemission APIs dealing with QSYS objects \n    //     need a traditional QSYS name so path_ will be used as before.\n    //     One API and a couple commands, however, needs an IFS-style name.  \n    //     For them the name will be put back together.  Note the extra     \n    //     processing is done only for QSYS objects.  The extra\n    //     processing is not needed for QDLS objects since they cannot be on  \n    //     ASPs.  path_ will contain the entire path for root file system objects. \n    //     \n    private String path_;\n    private String asp_ \u003d null;                           // @B6a\n\n    private String primaryGroup_;\n    private boolean primaryGroupChanged_;\n    private boolean sensitivityChanged_;\n    private int sensitivityLevel_;\n    private int type_;\n\n    private transient Vector userPermissionsBuffer_;\n    private transient Vector userPermissions_;\n    private transient Object userPermissionsLock_ \u003d new Object();\n\n    private transient PermissionAccess access_;\n    private transient PropertyChangeSupport changes_;\n    \n    \n\n    /**\n     * Constructs a Permission object.\n     * @param file The IFSFile object. For example, The IFSFile object which represents the object \"QSYS.LIB/FRED.LIB\".\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ConnectionDroppedException If the connection is dropped unexpectedly.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception ObjectDoesNotExistException If the system object does not exist.\n     *\n    **/\n    public Permission(IFSFile file)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n    {\n        this(file.getSystem(),file.getPath(), false, true);                  // @B6c\n    }\n\n    \n    \n    // @B6a new method                                                                                 \n    /**\n     * Constructs a Permission object.  \n     * \u003cP\u003e\n     *    Use the independent auxiliary storage pool (IASP) parameter to indicate \n     *    if the path name can contain an IASP name.\n     *    If true, the name will be parsed as if the name starts with an IASP name.\n     *    If false, the name is treated as an ordinary path.  For example, suppose\n     *    the path is \"/myIASP/QSYS.LIB/MYLIB.LIB\".  If the IASP parameter is true\n     *    the object is treated as library \"MYLIB\" on IASP \"myIASP\".  If the IASP\n     *    parameter is false the object is treated as object \"MYLIB.LIB\" in\n     *    directory \"/myIASP/QSYS.LIB\" in the root file system.  Note the IASP\n     *    parameter is used only if the second component of the path is QSYS.LIB.\n     *    If the second component of the path is not QSYS.LIB, the parameter is ignored.\n     *        \n     * @param file The IFSFile object. For example, The IFSFile object which represents the object \"QSYS.LIB/FRED.LIB\".\n     * @param pathMayStartWithIASP True if the path may start with an  \n     *                independent auxiliary storage pool (IASP) name; false otherwise.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ConnectionDroppedException If the connection is dropped unexpectedly.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception ObjectDoesNotExistException If the system object does not exist.\n     *\n    **/\n    public Permission(IFSFile file, boolean pathMayStartWithIASP)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n    {\n        this(file.getSystem(),file.getPath(), pathMayStartWithIASP, true);               \n    }\n\n    \n    \n    /**\n     * Constructs a Permission object.  \n     * \u003cP\u003e\n     *    Use the independent auxiliary storage pool (IASP) parameter to indicate \n     *    if the path name can contain an IASP name.\n     *    If true, the name will be parsed as if the name starts with an IASP name.\n     *    If false, the name is treated as an ordinary path.  For example, suppose\n     *    the path is \"/myIASP/QSYS.LIB/MYLIB.LIB\".  If the IASP parameter is true\n     *    the object is treated as library \"MYLIB\" on IASP \"myIASP\".  If the IASP\n     *    parameter is false the object is treated as object \"MYLIB.LIB\" in\n     *    directory \"/myIASP/QSYS.LIB\" in the root file system.  Note the IASP\n     *    parameter is used only if the second component of the path is QSYS.LIB.\n     *    If the second component of the path is not QSYS.LIB, the parameter is ignored.\n     *        \n     * @param file The IFSFile object. For example, The IFSFile object which represents the object \"QSYS.LIB/FRED.LIB\".\n     * @param pathMayStartWithIASP True if the path may start with an  \n     *                independent auxiliary storage pool (IASP) name; false otherwise.\n     * @param followLinks Whether symbolic links are resolved.\n     * The default value is \u003ctt\u003etrue\u003c/tt\u003e; that is, symbolic links are always resolved.\n     * By default, if the IBM i object is a symbolic link, then the requested action\n     * is performed on the object that is ultimately \u003cem\u003epointed to\u003c/em\u003e by the symbolic link,\n     * rather than on the symbolic link itself.\n     * \u003cbr\u003eNote: This parameter is effective only for IBM i release V5R4 and higher.\n     * For earlier releases, symbolic links are always resolved and this parameter is ignored.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ConnectionDroppedException If the connection is dropped unexpectedly.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception ObjectDoesNotExistException If the system object does not exist.\n     *\n    **/\n    public Permission(IFSFile file, boolean pathMayStartWithIASP, boolean followLinks)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n    {\n        this(file.getSystem(),file.getPath(), pathMayStartWithIASP, followLinks);               \n    }\n                                                                                 \n\n    /**\n     * Constructs a Permission object.\n     * @param as400 The system.\n     * @param fileName The full path of the object. For example, \"/QSYS.LIB/FRED.LIB\".\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ConnectionDroppedException If the connection is dropped unexpectedly.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception ObjectDoesNotExistException If the system object does not exist.\n     *\n    **/\n    public Permission(AS400 as400, String fileName)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n    {   \n        this(as400, fileName, false, true);                    // @B6c logic moved to next c\u0027tor\n    }\n\n\n    /**                                                                     \n     * Constructs a Permission object.     \n     * \u003cP\u003e\n     *    Use the independent auxiliary storage pool (IASP) parameter to indicate \n     *    if the path name can contain an IASP name.\n     *    If true, the name will be parsed as if the name starts with an IASP name.\n     *    If false, the name is treated as an ordinary path.  For example, suppose\n     *    the path is \"/myIASP/QSYS.LIB/MYLIB.LIB\".  If the IASP parameter is true\n     *    the object is treated as library \"MYLIB\" on IASP \"myIASP\".  If the IASP\n     *    parameter is false the object is treated as object \"MYLIB.LIB\" in\n     *    directory \"/myIASP/QSYS.LIB\" in the root file system.  Note the IASP\n     *    parameter is used only if the second component of the path is QSYS.LIB.\n     *    If the second component of the path is not QSYS.LIB, the parameter is ignored.\n     *        \n     * \n     * @param as400 The system.\n     * @param fileName The full path of the object. For example, \"/QSYS.LIB/FRED.LIB\".\n     * @param pathMayStartWithIASP True if the path may start with an  \n     *                independent auxiliary storage pool (IASP) name; false otherwise.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ConnectionDroppedException If the connection is dropped unexpectedly.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception ObjectDoesNotExistException If the system object does not exist.\n     *\n    **/\n    public Permission(AS400 as400, String fileName, boolean pathMayStartWithIASP)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n    {   \n        this(as400, fileName, pathMayStartWithIASP, true);\n    }\n\n\n    /**                                                                     \n     * Constructs a Permission object.     \n     * \u003cP\u003e\n     *    Use the independent auxiliary storage pool (IASP) parameter to indicate \n     *    if the path name can contain an IASP name.\n     *    If true, the name will be parsed as if the name starts with an IASP name.\n     *    If false, the name is treated as an ordinary path.  For example, suppose\n     *    the path is \"/myIASP/QSYS.LIB/MYLIB.LIB\".  If the IASP parameter is true\n     *    the object is treated as library \"MYLIB\" on IASP \"myIASP\".  If the IASP\n     *    parameter is false the object is treated as object \"MYLIB.LIB\" in\n     *    directory \"/myIASP/QSYS.LIB\" in the root file system.  Note the IASP\n     *    parameter is used only if the second component of the path is QSYS.LIB.\n     *    If the second component of the path is not QSYS.LIB, the parameter is ignored.\n     *        \n     * \n     * @param as400 The system.\n     * @param fileName The full path of the object. For example, \"/QSYS.LIB/FRED.LIB\".\n     * @param pathMayStartWithIASP True if the path may start with an  \n     *                independent auxiliary storage pool (IASP) name; false otherwise.\n     * @param followLinks Whether symbolic links are resolved.\n     * The default value is \u003ctt\u003etrue\u003c/tt\u003e; that is, symbolic links are always resolved.\n     * By default, if the IBM i object is a symbolic link, then the requested action\n     * is performed on the object that is ultimately \u003cem\u003epointed to\u003c/em\u003e by the symbolic link,\n     * rather than on the symbolic link itself.\n     * \u003cbr\u003eNote: This parameter is effective only for IBM i release V5R4 and higher.\n     * For earlier releases, symbolic links are always resolved and this parameter is ignored.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ConnectionDroppedException If the connection is dropped unexpectedly.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception ObjectDoesNotExistException If the system object does not exist.\n     *\n    **/\n    public Permission(AS400 as400, String fileName, boolean pathMayStartWithIASP, boolean followLinks)\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   UnsupportedEncodingException\n    {   \n        if (as400 \u003d\u003d null) throw new NullPointerException(\"system\");\n        if (fileName \u003d\u003d null) throw new NullPointerException(\"fileName\");\n\n        as400_ \u003d as400;\n        int separator;\n        path_ \u003d fileName;\n        separator \u003d path_.lastIndexOf(\u0027/\u0027);\n        name_ \u003d path_.substring(separator+1);\n        type_ \u003d parseType(path_, pathMayStartWithIASP);              // @B6c\n\n        // If \u0027followLinks\u0027 is false, check VRM, and if pre-V5R4 issue warning (and don\u0027t change flag).\n        if (!followLinks \u0026\u0026 (as400_.getVRM() \u003c 0x050400))\n        {\n          if (Trace.traceOn_) {\n            Trace.log(Trace.WARNING, \"followLinks(false): Parameter is ignored because system is not V5R4 or higher.\");\n          }\n        }\n        else followSymbolicLinks_ \u003d followLinks;\n\n        switch(type_)\n        {\n            case TYPE_QSYS :\n                access_ \u003d new PermissionAccessQSYS(as400_);\n                break;\n            case TYPE_DLO :\n                access_ \u003d new PermissionAccessDLO(as400_);\n                break;\n            case TYPE_ROOT :\n            default :\n                access_ \u003d new PermissionAccessRoot(as400_);\n                break;\n        }\n        access_.setFollowSymbolicLinks(followSymbolicLinks_);\n\n        Vector perms \u003d null; \n        try \n        {\n          // @B6 If the QSYS object is on an ASP, prepend the ASP name\n          //     to correctly fully qualify the path.\n          // @A3 The ASP is already part of the path. (e.g. /iasp123/QSYS.LIB/xyz.lib)\n          // String path \u003d path_;                          // @B6a //@A3D\n          // if (asp_ !\u003d null)                             // @B6a //@A3D\n          //    path \u003d asp_ + path;                        // @B6a //@A3D\n          perms \u003d access_.getAuthority(path_);             // @B6c\n          changes_ \u003d new PropertyChangeSupport(this);\n\n          synchronized (userPermissionsLock_)\n          {\n            owner_ \u003d (String)perms.elementAt(0);\n            primaryGroup_ \u003d (String)perms.elementAt(1);\n            authorizationList_ \u003d (String)perms.elementAt(2);\n            //autListChanged_ \u003d false;                       // @B2d\n            sensitivityLevel_ \u003d ((Integer)perms.elementAt(3)).intValue();\n            //sensitivityChanged_ \u003d false;                   // @B2d\n\n            userPermissionsBuffer_ \u003d new Vector ();\n            userPermissions_ \u003d new Vector();\n            int count \u003d perms.size();\n            for (int i\u003d4;i\u003ccount;i++)\n            {\n              UserPermission userPermission \u003d (UserPermission)perms.elementAt(i);\n              if (userPermission !\u003d null)\n              {\n                userPermission.setCommitted(UserPermission.COMMIT_NONE);\n                userPermissionsBuffer_.addElement(userPermission);\n                userPermissions_.addElement(userPermission);\n              }\n            }\n          }\n        }\n        catch (PropertyVetoException e) { // should never happen\n          Trace.log(Trace.ERROR, e);\n        }\n    }\n\n\n    /**\n     * Adds an authorized user. The user added will have \"*EXCLUDE\" authorities \n     * on the object.\n     * @param userProfileName The authorized user profile name.\n     *\n    **/\n    public void addAuthorizedUser(String userProfileName)\n    {\n        if (userProfileName \u003d\u003d null) throw new NullPointerException(\"userProfileName\");\n        int index;\n        String userName \u003d userProfileName.trim().toUpperCase();\n\n        synchronized (userPermissionsLock_)\n        {\n          if (getUserIndex(userName,userPermissions_) !\u003d -1)\n          {\n            Trace.log(Trace.ERROR, \"Permission already exists for user \" + userProfileName);  // @B2a\n            throw new ExtendedIllegalArgumentException(\"userProfileName (\"+userName+\")\",\n                                                       ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n          } \n          else\n          {\n            index\u003dgetUserIndex(userName,userPermissionsBuffer_);\n            if (index !\u003d -1)\n            {\n              UserPermission usrAut \u003d (UserPermission)\n                userPermissionsBuffer_.elementAt(index);\n              usrAut.setCommitted(UserPermission.COMMIT_CHANGE);\n              userPermissions_.addElement(usrAut);\n            } \n            else\n            {\n              UserPermission userPermission;\n              switch (type_)\n              {\n                case TYPE_DLO : \n                  userPermission \u003d new DLOPermission(userName);\n                  break;\n                case TYPE_QSYS : \n                  userPermission \u003d new QSYSPermission(userName);\n                  break;\n                case TYPE_ROOT :\n                default : \n                  userPermission \u003d new RootPermission(userName);\n                  break;\n              }\n              userPermission.setGroupIndicator(UserPermission.GROUPINDICATOR_USER);\n              userPermission.setCommitted(UserPermission.COMMIT_ADD);\n              userPermissionsBuffer_.addElement(userPermission);\n              userPermissions_.addElement(userPermission);\n            }\n          }\n        }\n    }\n\n   /**\n    *  Adds a property change listener.\n    *  @param listener The property change listener to add.\n    **/\n    public void addPropertyChangeListener(PropertyChangeListener listener)\n    {\n       if (listener \u003d\u003d null)\n       {\n          Trace.log(Trace.ERROR, \"Parameter \u0027listener\u0027 is null.\");\n          throw new NullPointerException(\"listener\");\n       }\n       \n       changes_.addPropertyChangeListener(listener);\n    }\n  \n    /**\n     * Adds a user permission.\n     * @param userPermission The UserPermission object.\n     *\n    **/\n    public void addUserPermission(UserPermission userPermission)\n    {\n        if (userPermission \u003d\u003d null) throw new NullPointerException(\"userPermission\");\n\n        switch (type_)\n        {\n            case TYPE_DLO : \n                if (userPermission instanceof com.ibm.as400.access.DLOPermission)\n                    break;\n            case TYPE_QSYS : \n                if (userPermission instanceof com.ibm.as400.access.QSYSPermission)\n                    break;\n            case TYPE_ROOT : \n                if (userPermission instanceof com.ibm.as400.access.RootPermission)\n                    break;\n            default :\n                throw new ExtendedIllegalArgumentException(\"userPermission\",\n                          ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        String user \u003d userPermission.getUserID();\n\n        synchronized (userPermissionsLock_)\n        {\n          if (getUserIndex(user,userPermissions_) !\u003d -1)\n          {\n            Trace.log(Trace.ERROR, \"Permission already exists for user \" + user);  // @B2a\n            throw new ExtendedIllegalArgumentException(\"userProfileName (\"+user+\")\",\n                                                       ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n          } \n          else\n          {\n            int index\u003dgetUserIndex(user,userPermissionsBuffer_);\n            if (index !\u003d -1)\n            {\n              //UserPermission usrAut \u003d (UserPermission)userPermissionsBuffer_.elementAt(index);\n              userPermission.setCommitted(UserPermission.COMMIT_CHANGE);\n              userPermissionsBuffer_.setElementAt(userPermission,index);\n              userPermissions_.addElement(userPermission);\n            } \n            else\n            {\n              userPermission.setCommitted(UserPermission.COMMIT_ADD);\n              userPermissionsBuffer_.addElement(userPermission);\n              userPermissions_.addElement(userPermission);\n            }\n          }\n        }\n    }\n\n    /**\n     * Commits the permission changes to the system.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ConnectionDroppedException If the connection is dropped unexpectedly.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception ObjectDoesNotExistException If the system object does not exist.\n     * @exception ServerStartupException If the host server cannot be started.\n     *\n    **/\n    public synchronized void commit()\n            throws AS400Exception,\n                   AS400SecurityException,\n                   ConnectionDroppedException,\n                   ErrorCompletingRequestException,\n                   InterruptedException,\n                   IOException,\n                   ObjectDoesNotExistException,\n                   ServerStartupException\n    {\n      if (isCommitted())\n        return;\n      // Add loop to allow for the fact that there are cases where UserPermission @A1A\n      // changes must occur before the sensitivityLevel_ changes.                 @A1A\n      for (int numberOfCommitAttempts\u003d1; numberOfCommitAttempts \u003c\u003d 2; numberOfCommitAttempts++) // @A1A\n      {                                                                        // @A1A\n        try \n        {\n          try                                                                  // @A1A\n          {                                                                    // @A1A\n            if (autListChanged_)\n            {\n              access_.setAuthorizationList(path_,authorizationList_,autListBackup_);\n              autListChanged_ \u003d false;\n            }\n            if (sensitivityChanged_)\n            {\n              access_.setSensitivity(path_,sensitivityLevel_);\n              sensitivityChanged_ \u003d false;\n            }\n            if (ownerChanged_)               // @B2a\n            {\n              // Removed code which prepended asp since the asp is already in the path_  @A4D\n              access_.setOwner(path_, owner_, revokeOldAuthority_); // @B6c // @A4C\n              ownerChanged_ \u003d false;\n            }\n            if (primaryGroupChanged_)\n            {\n              access_.setPrimaryGroup(path_,primaryGroup_,revokeOldGroupAuthority_);\n              primaryGroupChanged_ \u003d false;\n            }\n          }                                               // End try-block @A1A\n          catch (AS400Exception e)                                      // @A1A\n          {                                                             // @A1A\n            Trace.log(Trace.ERROR, e);\n            if (numberOfCommitAttempts \u003d\u003d 2)                            // @A1A\n            {\n              // Failure on second attempt... throw error.\n              throw e;                                                  // @A1A\n            }\n            else                                                        // @A1A\n            {\n              // Failure on first attempt... ignore error...\n              // Let\u0027s keep going and try to perform potential userPermission \n              // changes, and then reattempt the above changes.  Some changes\n              // require the UserPermission change to occur first.\n            }\n          }                                                   // end-catch @A1A\n\n          synchronized (userPermissionsLock_)\n          {\n            int count \u003d userPermissionsBuffer_.size();\n            for (int i\u003dcount-1;i\u003e\u003d0;i--)\n            {\n              UserPermission userPermission \u003d (UserPermission)\n                userPermissionsBuffer_.elementAt(i);\n              switch(userPermission.getCommitted())\n              {\n                case UserPermission.COMMIT_FROM_AUTL :\n                  access_.setFromAuthorizationList(path_,userPermission.isFromAuthorizationList());\n                  userPermission.setCommitted(UserPermission.COMMIT_NONE);\n                  break;\n                case UserPermission.COMMIT_ADD :\n                  access_.addUser(path_,userPermission);\n                  userPermission.setCommitted(UserPermission.COMMIT_NONE);\n                  break;\n                case UserPermission.COMMIT_CHANGE :\n                  access_.setAuthority(path_,userPermission);\n                  userPermission.setCommitted(UserPermission.COMMIT_NONE);\n                  break;\n                case UserPermission.COMMIT_REMOVE :\n                  // Removed code which prepended asp since the asp is already in the path_  @A4D\n                  access_.removeUser(path_,userPermission.getUserID());     // @B6c //@A4C\n                  userPermission.setCommitted(UserPermission.COMMIT_NONE);\n                  userPermissionsBuffer_.removeElement(userPermission);\n                  break;\n                case UserPermission.COMMIT_NONE :\n                default :\n                  break;\n              }\n            }\n          }\n        }\n        catch (PropertyVetoException e) { // should never happen\n          Trace.log(Trace.ERROR, e);\n        }\n      }                                 //end numberOfCommitAttempts loop @A1A\n\n      changes_.firePropertyChange(\"permission\",null,this);\n    }\n\n    /**\n     * Returns the authorizations list of the object.\n     * @return The authorizations list of the object.\n     * @see #setAuthorizationList(String)\n     *\n    **/\n    public String getAuthorizationList()\n    {\n        return authorizationList_;\n    }\n\n    /**\n     * Returns an enumeration of authorized users.\n     * @return An enumeration of authorized users.\n     *\n    **/\n    public Enumeration getAuthorizedUsers()\n    {\n      synchronized (userPermissionsLock_)\n      {\n        int count \u003d userPermissions_.size();\n        Vector names \u003d new Vector();\n        for (int i\u003d0;i\u003ccount;i++)\n        {\n          UserPermission userPermission \u003d (UserPermission)userPermissions_.elementAt(i);\n          names.addElement(userPermission.getUserID());\n        }\n        return names.elements();\n      }\n    }\n\n    \n    /** \n     * Returns the path of the integrated file system object whose permission is represented by this object.\n     * @return The integrated file system path name.\n     *\n    **/\n    public String getObjectPath()\n    {          \n      // @A3 The ASP is already part of the path. (e.g. /iasp123/QSYS.LIB/xyz.lib)\n      // String fullPath;                                 //@A3D\n      // if (asp_.equals(\"\"))                             //@A3D\n      //   fullPath \u003d path_;                              //@A3D\n      // else                                             //@A3D\n      //   fullPath \u003d \"/\"+ asp_ + \"/\" + path_;            //@A3D\n        return (path_);\n    }\n\n    /**\n     * Returns the name of the object whose permission is represented by this object.\n     * @return The name of the object.\n     *\n    **/\n    public String getName()\n    {\n        return name_;\n    }\n\n    /**\n     * Returns the object owner.\n     * @return The object owner.\n     *\n    **/\n    public String getOwner()\n    {\n        return owner_;\n    }\n\n    /**\n     * Returns the primary group of the object.\n     * @return The primary group of the object.\n     *\n    **/\n    public String getPrimaryGroup()\n    {\n        return primaryGroup_;\n    }\n\n    /**\n     * Returns the sensitivity level of the object.\n     * @return The sensitivity level of the object.\n     * \u003cUL\u003e\n     * \u003cLI\u003e0 : This value does not apply to this object.\n     * \u003cLI\u003e1 : (*NONE) The document has no sensitivity restrictions.\n     * \u003cLI\u003e2 : (*PERSONAL) The document is intended for the user as an\n     *      individual.\n     * \u003cLI\u003e3 : (*PRIVATE) The document contains information that should be\n     *      accessed only by the owner.  This value cannot be\n     *      specified if the access code zero (0) is assigned to\n     *      the object.\n     * \u003cLI\u003e4 : (*CONFIDENTIAL) The document contains information that should\n     *      be handled according to company procedures.\n     * \u003c/UL\u003e\n     * @see #setSensitivityLevel\n     *\n    **/\n    public int getSensitivityLevel()\n    {\n        return sensitivityLevel_;\n    }\n\n    /**\n     * Returns the system\n     * @return The system instance. \n     *\n    **/\n    public AS400 getSystem()\n    {\n        return as400_;\n    }\n\n    /**\n     * Returns the object type.\n     * @return The object type. The possible values are:\n     * \u003cul\u003e\n     *    \u003cli\u003e TYPE_DLO - Indicating the object is a Document Library Objects (DLO)\n     * stored in QDLS.\n     *    \u003cli\u003e TYPE_QSYS - Indicating the object is contained in the system library\n     * structure and stored in QSYS.LIB.\n     *    \u003cli\u003e TYPE_ROOT - Indicating the object is contained in the root directory \n     * structure. This includes everything that is not in QSYS.LIB or QDLS.\n     * \u003c/ul\u003e\n     *\n    **/\n    public int getType()\n    {\n        return type_;\n    }\n\n    /*\n     Searches a user in specified vector.\n    */\n    private int getUserIndex(String userProfileName,Vector vector)\n    {\n        int count \u003d vector.size();\n        for (int i\u003d0;i\u003ccount;i++)\n        {\n            UserPermission userPermission \u003d\n                           (UserPermission)vector.elementAt(i);\n            if (userPermission.getUserID().equals(userProfileName))\n                return i;\n        }\n        return -1;\n    }\n\n\n    /**\n     * Returns a UserPermission object for the specified user.\n     * If the specified user profile has no explicit authority to the object,\n     * returns null.\n     * @param userProfileName The name of the user profile.\n     * @return The specific Permission object.\n     *\n    **/\n    public UserPermission getUserPermission(String userProfileName)\n    {\n      if (userProfileName \u003d\u003d null) throw new NullPointerException(\"userProfileName\");\n\n        String userName \u003d userProfileName.toUpperCase();\n        synchronized (userPermissionsLock_)\n        {\n          int index \u003d getUserIndex(userName,userPermissions_);\n\n          if (index !\u003d -1)\n          {\n            return (UserPermission)userPermissions_.elementAt(index);\n          }\n          return null;\n        }\n    }\n\n    /**\n     * Returns an enumeration of UserPermission objects.\n     * @return An enumeration of UserPermission objects.\n     *\n    **/\n    public Enumeration getUserPermissions()\n    {\n      synchronized (userPermissionsLock_)\n      {\n        return userPermissions_.elements();\n      }\n    }\n\n    \n    /**\n     * Returns a flag indicating whether the change has been committed.\n     * @return The flag indicating whether the change has been committed.\n    **/\n    public boolean isCommitted()\n    {\n        boolean committed \u003d true;\n        synchronized (userPermissionsLock_)\n        {\n          int count \u003d userPermissionsBuffer_.size();\n          if (sensitivityChanged_ \u003d\u003d true)\n          {\n            return false;\n          }\n          if (autListChanged_ \u003d\u003d true)\n          {\n            return false;\n          }\n          if (ownerChanged_ \u003d\u003d true)               // @B2a\n          {\n            return false;\n          }\n          if (primaryGroupChanged_ \u003d\u003d true)\n          {\n            return false;\n          }\n          for (int i\u003d0;i\u003ccount;i++)\n          {\n            UserPermission userPermission \u003d (UserPermission)\n              userPermissionsBuffer_.elementAt(i);\n            if (userPermission.getCommitted() !\u003d\n                UserPermission.COMMIT_NONE)\n            {\n              committed \u003d false;\n              break;\n            }\n          }\n          return committed;\n        }\n    }\n\n\n    /**\n     * Returns whether symbolic links are resolved when changing or retrieving permissions.\n     * @return Whether symbolic links are resolved.\n     *\n    **/\n    public boolean isFollowSymbolicLinks()\n    {\n      return followSymbolicLinks_;\n    }\n\n    /*\n     Parses object\u0027s type by full path name.\n    */\n    private int parseType(String objectName, boolean pathMayStartWithIASP)      // @B6c\n    {\n       if (Trace.traceOn_) {\n         Trace.log(Trace.INFORMATION, \"IASP flag is: \" + pathMayStartWithIASP + \", object name: \" + objectName);\n       }\n\n       if (pathMayStartWithIASP)                                                // @B6a\n       {                                                                        // @B6a\n          String name \u003d objectName.toUpperCase();                               // @B6a\n                                                                                // @B6a\n          // make sure local copy of name ends with \"/\".  That way we           // @B6a\n          // can easily tell the difference between /QDLS and                   // @B6a\n          // /QDLS_for_me.                                                      // @B6a                                                                             \n          if (! name.endsWith(\"/\"))                                             // @B6a\n             name \u003d name + \"/\";                                                 // @B6a\n                                                                                // @B6a\n          int locationOfQSYS \u003d name.indexOf(\"/QSYS.LIB/\");                      // @B6a\n                                                                                // @B6a\n          if (locationOfQSYS \u003e\u003d 0)  // if QSYS.LIB is someplace in the name     // @B6a\n          {                                                                     // @B6a\n              if (locationOfQSYS \u003e 0)  // if the name starts with QSYS.LIB      // @B6a\n              {                                                                 // @B6a\n                 // QSYS.LIB is not the first component of the path.  First,    // @B6a\n                 // set \"asp\" to everything before /QSYS.LIB\" except the        // @B6a\n                 // first and last slash.                                       // @B6a\n                 String asp \u003d name.substring(1, locationOfQSYS);                // @B6a\n                                                                                // @B6a\n                 // does \u0027asp\u0027 contain a slash?  If yes then it is not an ASP   // @B6a\n                 // name, just the name of an object in the root file system.   // @B6a\n                 // If asp does not contain a slash then it is an ASP name.     // @B6a\n                 // Set class variable asp_ to \"/aspName\".  Set class variable  // @B6a\n                 // path_ to \"/QSYS.LIB/...\".                                   // @B6a\n                 if (asp.indexOf(\u0027/\u0027) \u003c 0)                                      // @B6a\n                 {                                                              // @B6a\n                    asp_  \u003d objectName.substring(0, locationOfQSYS);            // @B6a\n                    // @A3 Leave the ASP in the path. (e.g. /iasp123/QSYS.LIB/xyz.lib)\n                    // path_ \u003d objectName.substring(locationOfQSYS);            // @B6a //@A3D\n                    return TYPE_QSYS;                                           // @B6a\n                 }                                                              // @B6a\n                 else                                                           // @B6a\n                    ;  // Don\u0027t do anything.  QSYS.LIB is not the second        // @B6a\n                       // component of the name so this object is not a QSYS    // @B6a\n                       // object on an ASP, it is a normal root file            // @B6a\n                       // system object.                                        // @B6a\n              }                                                                 // @B6a\n              else     // The name starts with QSYS                             // @B6a\n                 return TYPE_QSYS;                                              // @B6a\n          }                                                                     // @B6a\n                                                                                // @B6a\n          if (name.startsWith(\"/QDLS/\"))                                        // @B6a\n          {                                                                     // @B6a\n             return TYPE_DLO;                                                   // @B6a\n          }                                                                     // @B6a\n                                                                                // @B6a\n          return  TYPE_ROOT;                                                    // @B6a\n       }                                                                        // @B6a\n       else                                                                     // @B6a\n       {                                                                        // @B6a\n         String name \u003d objectName.toUpperCase();                                // @A2A\n        if(name.startsWith(\"/QSYS.LIB/\") || name.equals(\"/QSYS.LIB\"))           // @A2C\n        {\n            return TYPE_QSYS;\n        }\n//      if(objectName.toUpperCase().startsWith(\"/QDLS/\") || objectName.toUpperCase().equals(\"/QDLS\"))   // @1JUC check to see if it is the qdls root folder\n        if(name.startsWith(\"/QDLS/\") || name.equals(\"/QDLS\"))   // @A2C @1JUC check to see if it is the qdls root folder\n        {\n            return TYPE_DLO;\n        }\n        return  TYPE_ROOT;\n       }                                                                        // @B6a   \n    }\n\n\n    /**\n     * Serialization support.  \n     * @exception Thrown when an application tries to load in a class through its string name,\n     *            but no definition for the class with the specifed name could be found. \n     * @exception IOException If an error occurs while communicating with the system.\n     *\n    **/\n    private void readObject(ObjectInputStream s)\n      throws ClassNotFoundException, IOException \n    {   \n        int size;\n        s.defaultReadObject();\n        switch(type_)\n        {\n            case TYPE_QSYS :\n                access_ \u003d new PermissionAccessQSYS(as400_);\n                break;\n            case TYPE_DLO :\n                access_ \u003d new PermissionAccessDLO(as400_);\n                break;\n            case TYPE_ROOT :\n            default :\n                access_ \u003d new PermissionAccessRoot(as400_);\n                break;\n        }\n        access_.setFollowSymbolicLinks(followSymbolicLinks_);\n\n        userPermissionsLock_ \u003d new Object();\n        userPermissionsBuffer_ \u003d new Vector ();\n        userPermissions_ \u003d new Vector();\n        size \u003d ((Integer)s.readObject()).intValue();\n        for (int i\u003d0;i\u003csize;i++)\n        {\n            userPermissionsBuffer_.addElement(s.readObject());\n        }\n        size \u003d ((Integer)s.readObject()).intValue();\n        for (int i\u003d0;i\u003csize;i++)\n        {\n            userPermissions_.addElement(s.readObject());\n        }\n        changes_ \u003d new PropertyChangeSupport(this);\n        s.readObject();\n    }\n\n    /**\n     * Removes an authorized user.\n     * @param userProfileName The authorized user profile name.\n     *\n    **/\n    public void removeAuthorizedUser(String userProfileName)\n    {\n        if (userProfileName \u003d\u003d null) throw new NullPointerException(\"userProfileName\");\n\n        String userName \u003d userProfileName.trim().toUpperCase();\n        UserPermission userPermission \u003d getUserPermission(userName);\n        if (userPermission !\u003d null)\n        {\n            removeUserPermission(userPermission);\n        }else\n        {\n            Trace.log(Trace.ERROR, \"Permission does not exist for user \" + userProfileName);  // @B2a\n            throw new ExtendedIllegalArgumentException(\"userProfileName (\"+userName+\")\",\n                  ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n    }\n\n   \n\n   /**\n    *  Removes a property change listener.\n    *  @param listener The property change listener to remove.\n   **/\n   public void removePropertyChangeListener(PropertyChangeListener listener)\n   {\n     if (listener \u003d\u003d null)\n     {\n       Trace.log(Trace.ERROR, \"Parameter \u0027listener\u0027 is null.\");\n       throw new NullPointerException(\"listener\");\n     }\n\n     changes_.removePropertyChangeListener(listener);\n   }\n   \n    /**\n     * Removes a user permission.\n     * @param permission The UserPermission object.\n     *\n    **/\n    public void removeUserPermission(UserPermission permission)\n    {   \n        if (permission \u003d\u003d null) throw new NullPointerException(\"permission\");\n\n        synchronized (userPermissionsLock_)\n        {\n          if (userPermissions_.indexOf(permission) \u003d\u003d -1)\n          {\n            Trace.log(Trace.ERROR, \"Permission does not exist for user \" + permission.getUserID());  // @B2a\n            throw new ExtendedIllegalArgumentException\n              (\"permission\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID); // @B2c\n          } \n          else\n          {\n            switch (permission.getCommitted())\n            {\n              case UserPermission.COMMIT_ADD :\n                userPermissions_.removeElement(permission);\n                userPermissionsBuffer_.removeElement(permission);\n                permission.setCommitted(UserPermission.COMMIT_NONE);\n                break;\n              case UserPermission.COMMIT_REMOVE :\n              case UserPermission.COMMIT_CHANGE :\n              case UserPermission.COMMIT_NONE :\n              default :\n                permission.setCommitted(UserPermission.COMMIT_REMOVE);\n                userPermissions_.removeElement(permission);\n                break;\n            }\n          }\n        }\n    }\n\n    /**\n     * Sets the authorizations list of the object. For example:\n     * \u003cp\u003e\u003cblockquote\u003e\u003cpre\u003e\n     * Permission permisson \u003d new Permisson(new AS400(),\"/QSYS.LIB/FRED.LIB\";\n     * permission.setAuthorizationList(\"testautl\");\n     * System.out.println(\"The authorization list of fred.lib is \" + permissin.geAuthorizationList();\n     * permission.setAuthorizationList(\"*NONE\");\n     * System.out.println(\"The authorization list of fred.lib is \" + permissin.geAuthorizationList();\n     * \u003c/pre\u003e\u003c/blockquote\u003e\u003c/p\u003e\n     * @param autList The authorizations list of the object.\n     *\n    **/\n    public synchronized void setAuthorizationList(String autList)\n    {\n        if (autList \u003d\u003d null) throw new NullPointerException(\"autList\");\n        if (autList.trim().equalsIgnoreCase(authorizationList_))\n            return;\n        if (autListChanged_\u003d\u003d false)\n            autListBackup_ \u003d authorizationList_;\n        authorizationList_ \u003d autList.trim().toUpperCase();\n        autListChanged_ \u003d true;\n    }\n\n    // @B2a\n    /**\n     * Sets the owner of the object.\n     * @param owner The owner of the object.\n     * @param revokeOldAuthority Specifies whether the authorities for the current\n     * owner are revoked when ownership is transferred to the new owner. \n     *\n     * @see #getOwner\n    **/\n    public synchronized void setOwner(String owner, boolean revokeOldAuthority)\n    {\n        if (owner \u003d\u003d null) throw new NullPointerException(\"owner\");\n\n        owner_ \u003d owner;\n        revokeOldAuthority_ \u003d revokeOldAuthority;\n        ownerChanged_ \u003d true;\n    }\n\n    /**\n     * Sets the primary group of the object.\n     * @param primaryGroup The primary group of the object.\n     * @param revokeOldAuthority Specifies whether the authorities for the current\n     * primary group are revoked when the primary group is changed to the new value.\n     *\n    **/\n    public void setPrimaryGroup(String primaryGroup, boolean revokeOldAuthority)\n    {\n        if (primaryGroup \u003d\u003d null) throw new NullPointerException(\"primaryGroup\");\n        primaryGroup_ \u003d primaryGroup;\n        revokeOldGroupAuthority_ \u003d revokeOldAuthority;\n        primaryGroupChanged_ \u003d true;\n    }\n\n\n    /**\n     * Sets the sensitivity level of the object.\n     * @param sensitivityLevel The sensitivity level of the object.  The\n     * possible values :\n     * \u003cUL\u003e\n     * \u003cLI\u003e0 : This value does not apply to this object.\n     * \u003cLI\u003e1 : (*NONE) The document has no sensitivity restrictions.\n     * \u003cLI\u003e2 : (*PERSONAL) The document is intended for the user as an\n     *      individual.\n     * \u003cLI\u003e3 : (*PRIVATE) The document contains information that should be\n     *      accessed only by the owner.  This value cannot be\n     *      specified if the access code zero (0) is assigned to\n     *      the object.\n     * \u003cLI\u003e4 : (*CONFIDENTIAL) The document contains information that should\n     *      be handled according to company procedures.\n     * \u003c/UL\u003e\n     *\n     * @see #getSensitivityLevel\n    **/\n    public synchronized void setSensitivityLevel(int sensitivityLevel)\n    {\n        if (sensitivityLevel \u003c 0 || sensitivityLevel \u003e 4)\n        {\n            throw new ExtendedIllegalArgumentException(\"sensitivityLevel (\"+sensitivityLevel+\")\",\n                  ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID );\n        }\n        sensitivityLevel_ \u003d sensitivityLevel;\n        sensitivityChanged_ \u003d true;\n    }\n\n    /**\n     * Sets the system where system value is retrieved.\n     *\n     * @param   system The system object.\n     * @see     #getSystem\n     * @deprecated This method is of little (or no) known usefulness. If you require this method, please notify the Toolbox support team.\n    **/\n    public synchronized void setSystem(AS400 system)\n    {   \n        if (system \u003d\u003d null) throw new NullPointerException(\"system\");\n        \n        if (as400_ \u003d\u003d null)                        //$B1C\n           as400_ \u003d system;                        //$B1C\n        else                                       //$B1C\n        {  \n            if (as400_.isConnected())\n            {\n                throw new ExtendedIllegalStateException(\"system\",\n                    ExtendedIllegalStateException.PROPERTY_NOT_CHANGED);\n            }\n            if (as400_.equals(system)\u003d\u003dtrue)\n               return;\n        }\n\n        switch(type_)\n        {\n            case TYPE_QSYS :\n                access_ \u003d new PermissionAccessQSYS(as400_);\n                break;\n            case TYPE_DLO :\n                access_ \u003d new PermissionAccessDLO(as400_);\n                break;\n            case TYPE_ROOT :\n            default :\n                access_ \u003d new PermissionAccessRoot(as400_);\n                break;\n        }\n        access_.setFollowSymbolicLinks(followSymbolicLinks_);\n        // Assume that, since we\u0027re (re)connecting to the same system we were originally connected to, that none of the permissions information needs to be re-retrieved.\n    }\n    \n    /**\n     * Serialization support.  \n     * @exception IOException If an error occurs while communicating with the system.\n     *\n    **/\n    private void writeObject(ObjectOutputStream s) \n                 throws IOException\n    {\n        s.defaultWriteObject();\n\n        synchronized (userPermissionsLock_)\n        {\n          s.writeObject(new Integer(userPermissionsBuffer_.size()));\n          for (int i\u003d0;i\u003cuserPermissionsBuffer_.size();i++)\n          {\n            s.writeObject(userPermissionsBuffer_.elementAt(i));\n          }\n          s.writeObject(new Integer(userPermissions_.size()));\n          for (int i\u003d0;i\u003cuserPermissions_.size();i++)\n          {\n            s.writeObject(userPermissions_.elementAt(i));\n          }\n\n          s.writeObject(null);\n        }\n    }\n\n\n\n\t/**\n\t * Removes the specified record from the table.\n\t * @param permissionTableModelQSYS TODO\n\t * @param  row  The index of row.\n\t */\n\tpublic void removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)\n\t{\n\t     permissionTableModelQSYS.table_.clearSelection();   \n\t     QSYSPermission user \u003d (QSYSPermission)permissionTableModelQSYS.userPermissions_.elementAt(row);\n\t     removeAuthorizedUser(user.getUserID());\n\t\n\t     // Gets the new data after removing the specified user.\n\t     Enumeration userPermissions \u003d getUserPermissions();\n\t     permissionTableModelQSYS.userPermissions_ \u003d new Vector();\n\t     while(userPermissions.hasMoreElements())\n\t     {\n\t        permissionTableModelQSYS.userPermissions_.addElement(userPermissions.nextElement());\n\t     }\n\t     permissionTableModelQSYS.fireTableRowsDeleted(row, row);\n\t}\n    \n}"},"candidatesTelemetryData":{"numberOfSuggestions":1,"candidates":[{"lineStart":1280,"lineEnd":1299,"refactoringType":"MyMoveMethodRefactoring","refactoringInfo":"Move method removeRow2 to class PermissionTableModelQSYS","description":"Move method to com.ibm.as400.vaccess.PermissionTableModelQSYS\nRationale: The method removeRow2 directly manipulates the userPermissions_ of the PermissionTableModelQSYS class and is responsible for updating the table\u0027s data representation. It is closely tied to the functionality of managing user permissions within the context of the permission table.","couldCreateRefObject":true,"applied":false,"undone":false}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":2903}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":6734},"iterationData":[{"iteration_num":1,"suggested_move_methods":[{"method_name":"removeRow2","method_signature":"public void removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)","target_class":"PermissionTableModelQSYS","rationale":"The removeRow2 method is directly manipulating the PermissionTableModelQSYS and its user permissions, which indicates it is more related to the table model\u0027s functionality rather than the Permission class itself."}],"llm_response_time":2154},{"iteration_num":2,"suggested_move_methods":[{"method_name":"removeRow2","method_signature":"public void removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)","target_class":"PermissionTableModelQSYS","rationale":"The removeRow2 method is directly manipulating the PermissionTableModelQSYS and is specific to the table model\u0027s behavior. It should be moved to the PermissionTableModelQSYS class to adhere to the Single Responsibility Principle."}],"llm_response_time":1698},{"iteration_num":3,"suggested_move_methods":[{"method_name":"removeRow2","method_signature":"public void removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)","target_class":"PermissionTableModelQSYS","rationale":"The removeRow2 method is directly manipulating the PermissionTableModelQSYS and its user permissions, which indicates it is more related to the table model than the Permission class itself."}],"llm_response_time":1997},{"iteration_num":-1,"suggested_move_methods":[{"method_name":"removeRow2","method_signature":"public void removeRow2(PermissionTableModelQSYS permissionTableModelQSYS, int row)","target_class":"PermissionTableModelQSYS","rationale":"The removeRow2 method is directly manipulating the PermissionTableModelQSYS and its user permissions, which indicates it is more related to the table model\u0027s functionality rather than the Permission class itself."}],"llm_response_time":0}],"llmMethodPriority":{"priority_method_names":["removeRow2"],"llm_response_time":799},"targetClassMap":{"removeRow2":{"target_classes":[{"class_name":"PermissionTableModelQSYS","similarity_score":0.6764280756176033},{"class_name":"AS400","similarity_score":0.5464941191201543}],"target_classes_sorted_by_llm":["PermissionTableModelQSYS","AS400"],"llm_response_time":1480,"similarity_computation_time":32,"similarity_metric":"cosine"}}}
    },
    {
        "oracle": "method com.ibm.as400.access.AS400ZonedDecimal::addToHashtable(PcmlDocNode):void need move com.ibm.as400.data.PcmlDocument",
        "class_name": "com.ibm.as400.access.AS400ZonedDecimal",
        "telemetry": {"id":"506dfefe-1602-44a9-a4f5-cf44bd7399f2","hostFunctionTelemetryData":{"hostFunctionSize":546,"lineStart":25,"lineEnd":570,"bodyLineStart":25,"language":"java","filePath":"/Users/abhiram/Documents/TBE/jmove/dataset-tse/jtopen/large/big/jtopen-7.8/src/com/ibm/as400/access/AS400ZonedDecimal.java","sourceCode":"/**\n *  The AS400ZonedDecimal class provides a converter between a BigDecimal object and a zoned decimal format floating point number.\n **/\npublic class AS400ZonedDecimal implements AS400DataType\n{\n    static final long serialVersionUID \u003d 4L;\n\n    private int digits;\n    private int scale;\n    private static final long defaultValue \u003d 0;\n    private static final boolean HIGH_NIBBLE \u003d AS400PackedDecimal.HIGH_NIBBLE;\n    private static final boolean LOW_NIBBLE  \u003d AS400PackedDecimal.LOW_NIBBLE;\n\n    private boolean useDouble_ \u003d false;\n\n    /**\n     * Constructs an AS400ZonedDecimal object.\n     * @param numDigits The number of digits in the zoned decimal number. It must be greater than or equal to one and less than or equal to thirty-one.\n     * @param numDecimalPositions The number of decimal positions in the zoned decimal number. It must be greater than or equal to zero and less than or equal to \u003ci\u003enumDigits\u003c/i\u003e.\n     */\n    public AS400ZonedDecimal(int numDigits, int numDecimalPositions)\n    {\n     // check for valid input\n     if (numDigits \u003c 1 || numDigits \u003e 63) // @M0C - changed the upper limit here from 31 for JDBC support\n     {\n         throw new ExtendedIllegalArgumentException(\"numDigits (\" + String.valueOf(numDigits) + \")\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n     }\n     if (numDecimalPositions \u003c 0 || numDecimalPositions \u003e numDigits)\n     {\n         throw new ExtendedIllegalArgumentException(\"numDecimalPositions (\" + String.valueOf(numDecimalPositions) + \")\", ExtendedIllegalArgumentException.RANGE_NOT_VALID);\n     }\n\n     // set instance variables\n     this.digits \u003d numDigits;\n     this.scale \u003d numDecimalPositions;\n    }\n\n    /**\n     * Creates a new AS400ZonedDecimal object that is identical to the current instance.\n     * @return The new object.\n     **/\n    public Object clone()\n    {\n     try\n     {\n         return super.clone();  // Object.clone does not throw exception\n     }\n     catch (CloneNotSupportedException e)\n     {\n         Trace.log(Trace.ERROR, \"Unexpected cloning error\", e);\n         throw new InternalErrorException(InternalErrorException.UNKNOWN);\n     }\n    }\n\n    /**\n     * Returns the byte length of the data type.\n     * @return The number of bytes in the IBM i representation of the data type.\n     **/\n    public int getByteLength()\n    {\n     return this.digits;\n    }\n\n    /**\n     * Returns a Java object representing the default value of the data type.\n     * @return The BigDecimal object with a value of zero.\n     **/\n    public Object getDefaultValue()\n    {\n     return BigDecimal.valueOf(defaultValue);\n    }\n\n    /**\n     * Returns {@link com.ibm.as400.access.AS400DataType#TYPE_ZONED TYPE_ZONED}.\n     * @return \u003ctt\u003eAS400DataType.TYPE_ZONED\u003c/tt\u003e.\n    **/\n    public int getInstanceType()\n    {\n      return AS400DataType.TYPE_ZONED;\n    }\n\n    /**\n     * Returns the Java class that corresponds with this data type.\n     * @return \u003ctt\u003eBigDecimal.class\u003c/tt\u003e.\n     **/\n    public Class getJavaType()\n    {\n      return BigDecimal.class;\n    }\n\n    /**\n     * Returns the total number of digits in the zoned decimal number.\n     * @return The number of digits.\n     **/\n    public int getNumberOfDigits()\n    {\n     return this.digits;\n    }\n\n    /**\n     * Returns the number of decimal positions in the zoned decimal number.\n     * @return The number of decimal positions.\n     **/\n    public int getNumberOfDecimalPositions()\n    {\n     return this.scale;\n    }\n\n    /**\n     * Indicates if a {@link java.lang.Double Double} object or a\n     * {@link java.math.BigDecimal BigDecimal} object will be returned\n     * on a call to {@link #toObject toObject()}.\n     * @return true if a Double will be returned, false if a BigDecimal\n     * will be returned.  The default is false.\n    **/\n    public boolean isUseDouble()\n    {\n      return useDouble_;\n    }\n\n    /**\n     * Sets whether to return a {@link java.lang.Double Double} object or a\n     * {@link java.math.BigDecimal BigDecimal} object on a call to\n     * {@link #toObject toObject()}.\n     * @see com.ibm.as400.access.AS400PackedDecimal#setUseDouble\n    **/\n    public void setUseDouble(boolean b)\n    {\n      useDouble_ \u003d b;\n    }\n\n    /**\n     * Converts the specified Java object to IBM i format.\n     * @param javaValue The object corresponding to the data type.  It must be an instance of BigDecimal and the BigDecimal must have a less than or equal to number of digits and a less than or equal to number of decimal places.\n     * @return The IBM i representation of the data type.\n     **/\n    public byte[] toBytes(Object javaValue)\n    {\n     byte[] as400Value \u003d new byte[this.digits];\n     this.toBytes(javaValue, as400Value, 0);\n     return as400Value;\n    }\n\n    /**\n     * Converts the specified Java object into IBM i format in the specified byte array.\n     * @param javaValue The object corresponding to the data type.  It must be an instance of BigDecimal and the BigDecimal must have a less than or equal to number of digits and a less than or equal to number of decimal places.\n     * @param as400Value The array to receive the data type in IBM i format.  There must be enough space to hold the IBM i value.\n     * @return The number of bytes in the IBM i representation of the data type.\n     **/\n    public int toBytes(Object javaValue, byte[] as400Value)\n    {\n     return this.toBytes(javaValue, as400Value, 0);\n    }\n\n    /**\n     * Converts the specified Java object into IBM i format in the specified byte array.\n     * @param javaValue The object corresponding to the data type. It must be an instance of BigDecimal and the BigDecimal must have a less than or equal to number of digits and a less than or equal to number of decimal places.\n     * @param as400Value The array to receive the data type in IBM i format.  There must be enough space to hold the IBM i value.\n     * @param offset The offset into the byte array for the start of the IBM i value. It must be greater than or equal to zero.\n     * @return The number of bytes in the IBM i representation of the data type.\n     **/\n    public int toBytes(Object javaValue, byte[] as400Value, int offset)\n    {\n     int outDigits \u003d this.digits;\n     int outDecimalPlaces \u003d this.scale;\n\n     // verify input\n     BigDecimal inValue \u003d (BigDecimal)javaValue; // Let this line throw ClassCastException\n     if (inValue.scale() \u003e outDecimalPlaces)  // Let this line throw NullPointerException\n     {\n         throw new ExtendedIllegalArgumentException(\"javaValue (\" + javaValue.toString() + \")\", ExtendedIllegalArgumentException.LENGTH_NOT_VALID);\n     }\n\n     // read the sign\n     int sign \u003d inValue.signum();\n\n     // get just the digits from BigDecimal, \"normalize\" away sign, decimal place etc.\n     char[] inChars \u003d inValue.abs().movePointRight(outDecimalPlaces).toBigInteger().toString().toCharArray();\n\n     // Check overall length\n     int inLength \u003d inChars.length;\n     if (inLength \u003e outDigits)\n     {\n         throw new ExtendedIllegalArgumentException(\"javaValue (\" + javaValue.toString() + \")\", ExtendedIllegalArgumentException.LENGTH_NOT_VALID);\n     }\n\n     int inPosition \u003d 0; // position in char[]\n\n     // write correct number of leading zero\u0027s\n     for (int i\u003d0; i\u003coutDigits-inLength; ++i)\n     {\n         as400Value[offset++] \u003d (byte)0xF0;\n     }\n\n     // place all the digits except the last one\n     while (inPosition \u003c inChars.length-1)\n     {\n         as400Value[offset++] \u003d (byte)((inChars[inPosition++] \u0026 0x000F) | 0x00F0);\n     }\n\n     // place the sign and last digit\n     if (sign !\u003d -1)\n     {\n         as400Value[offset] \u003d (byte)((inChars[inPosition] \u0026 0x000F) | 0x00F0);\n     }\n     else\n     {\n         as400Value[offset] \u003d (byte)((inChars[inPosition] \u0026 0x000F) | 0x00D0);\n     }\n     return outDigits;\n    }\n\n    // @E0A\n    /**\n     * Converts the specified Java object to IBM i format.\n     *\n     * @param doubleValue   The value to be converted to IBM i format.  If the decimal part\n     *                      of this value needs to be truncated, it will be rounded towards\n     *                      zero.  If the integral part of this value needs to be truncated,\n     *                      an exception will be thrown.\n     * @return              The IBM i representation of the data type.\n     **/\n    public byte[] toBytes(double doubleValue)\n    {\n        byte[] as400Value \u003d new byte[digits];\n        toBytes(doubleValue, as400Value, 0);\n        return as400Value;\n    }\n\n    // @E0A\n    /**\n     * Converts the specified Java object into IBM i format in\n     * the specified byte array.\n     *\n     * @param doubleValue   The value to be converted to IBM i format.  If the decimal part\n     *                      of this value needs to be truncated, it will be rounded towards\n     *                      zero.  If the integral part of this value needs to be truncated,\n     *                      an exception will be thrown.\n     * @param as400Value    The array to receive the data type in IBM i format.  There must\n     *                      be enough space to hold the IBM i value.\n     * @return              The number of bytes in the IBM i representation of the data type.\n     **/\n    public int toBytes(double doubleValue, byte[] as400Value)\n    {\n        return toBytes(doubleValue, as400Value, 0);\n    }\n\n    // @E0A\n    /**\n     * Converts the specified Java object into IBM i format in\n     * the specified byte array.\n     *\n     * @param doubleValue   The value to be converted to IBM i format.  If the decimal part\n     *                      of this value needs to be truncated, it will be rounded towards\n     *                      zero.  If the integral part of this value needs to be truncated,\n     *                      an exception will be thrown.\n     * @param as400Value    The array to receive the data type in IBM i format.\n     *                      There must be enough space to hold the IBM i value.\n     * @param offset        The offset into the byte array for the start of the IBM i value.\n     *                      It must be greater than or equal to zero.\n     * @return              The number of bytes in the IBM i representation of the data type.\n     **/\n    public int toBytes(double doubleValue, byte[] as400Value, int offset)\n    {\n        // GOAL:  For performance reasons, we need to do this conversion\n        //        without creating any Java objects (e.g., BigDecimals,\n        //        Strings).\n\n        // If the number is too big, we can\u0027t do anything with it.\n        double absValue \u003d Math.abs(doubleValue);\n        if (absValue \u003e Long.MAX_VALUE)\n            throw new ExtendedIllegalArgumentException(\"doubleValue\", ExtendedIllegalArgumentException.LENGTH_NOT_VALID);\n\n        // Extract the normalized value.  This is the value represented by\n        // two longs (one for each side of the decimal point).  Using longs\n        // here improves the quality of the algorithm as well as the\n        // performance of arithmetic operations.  We may need to use an\n        // \"effective\" scale due to the lack of precision representable\n        // by a long.\n        long leftSide \u003d (long)absValue;\n        int effectiveScale \u003d (scale \u003e 15) ? 15 : scale;\n        long rightSide \u003d (long)Math.round((absValue - (double)leftSide) * Math.pow(10, effectiveScale));\n\n        // Ok, now we are done with any double arithmetic!\n\n        // If the effective scale is different than the actual scale,\n        // then pad with zeros.\n        int rightmostOffset \u003d offset + digits - 1;\n        int padOffset \u003d rightmostOffset - (scale - effectiveScale);\n        for (int i \u003d rightmostOffset; i \u003e padOffset; --i)\n            as400Value[i] \u003d (byte)0x00F0;\n\n        // Compute the bytes for the right side of the decimal point.\n        int decimalOffset \u003d rightmostOffset - scale;\n        int nextDigit;\n        for (int i \u003d padOffset; i \u003e decimalOffset; --i) {\n            nextDigit \u003d (int)(rightSide % 10);\n            as400Value[i] \u003d (byte)(0x00F0 | nextDigit);\n            rightSide /\u003d 10;\n        }\n\n        // Compute the bytes for the left side of the decimal point.\n        for (int i \u003d decimalOffset; i \u003e\u003d offset; --i) {\n            nextDigit \u003d (int)(leftSide % 10);\n            as400Value[i] \u003d (byte)(0x00F0 | nextDigit);\n            leftSide /\u003d 10;\n        }\n\n        // Fix the sign, if negative.\n        if (doubleValue \u003c 0)\n            as400Value[rightmostOffset] \u003d (byte)(as400Value[rightmostOffset] \u0026 0x00DF);\n\n        // If left side still has digits, then the value was too big\n        // to fit.\n        if (leftSide \u003e 0)\n            throw new ExtendedIllegalArgumentException(\"doubleValue\", ExtendedIllegalArgumentException.LENGTH_NOT_VALID);\n\n        return digits;\n    }\n\n    // @E0A\n    /**\n     * Converts the specified IBM i data type to a Java double value.  If the\n     * decimal part of the value needs to be truncated to be represented by a\n     * Java double value, then it is rounded towards zero.  If the integral\n     * part of the value needs to be truncated to be represented by a Java\n     * double value, then it converted to either Double.POSITIVE_INFINITY\n     * or Double.NEGATIVE_INFINITY.\n     *\n     * @param as400Value The array containing the data type in IBM i format.\n     *                   The entire data type must be represented.\n     * @return           The Java double value corresponding to the data type.\n     **/\n    public double toDouble(byte[] as400Value)\n    {\n        return toDouble(as400Value, 0);\n    }\n\n    // @E0A\n    /**\n     * Converts the specified IBM i data type to a Java double value.  If the\n     * decimal part of the value needs to be truncated to be represented by a\n     * Java double value, then it is rounded towards zero.  If the integral\n     * part of the value needs to be truncated to be represented by a Java\n     * double value, then it converted to either Double.POSITIVE_INFINITY\n     * or Double.NEGATIVE_INFINITY.\n     *\n     * @param as400Value The array containing the data type in IBM i format.\n     *                   The entire data type must be represented.\n     * @param offset     The offset into the byte array for the start of the IBM i value.\n     *                   It must be greater than or equal to zero.\n     * @return           The Java double value corresponding to the data type.\n     **/\n    public double toDouble(byte[] as400Value, int offset)\n    {\n        // Check the offset to prevent bogus NumberFormatException message.\n        if (offset \u003c 0)\n            throw new ArrayIndexOutOfBoundsException(String.valueOf(offset));\n\n        // Compute the value.\n        /*\n         * This old code had a bug in that it can produce\n         * inexact answers. For example\n         * 10.10105 is turned into -10.101049999999999\n\n        double doubleValue \u003d 0;\n        double multiplier \u003d Math.pow(10, digits - scale - 1);\n        int rightMostOffset \u003d offset + digits - 1;\n        for(int i \u003d offset; i \u003c\u003d rightMostOffset; ++i) {\n            doubleValue +\u003d ((byte)(as400Value[i] \u0026 0x000F)) * multiplier;\n            multiplier /\u003d 10;\n        }\n        */\n\n        /*\n         * Instead we gather the digits using a long, then divide by the scale.\n         * Note:  Using a multiply by Math.pow(10, -scale) gives a worse answer.\n         * Math.pow(10,-scale) is a less accurate number than Math.pow(10,scale)\n         */\n\n        int rightMostOffset \u003d offset + digits - 1;\n        double doubleValue \u003d 0;\n        \n        if(digits \u003c 18){//long type has a maximum value: 9223372036854775807\n        \tlong   longValue \u003d 0;\n            double divisor \u003d Math.pow(10, scale);\n            for(int i \u003d offset; i \u003c\u003d rightMostOffset; ++i) {\n                longValue \u003d longValue * 10 + (byte)(as400Value[i] \u0026 0x000F);\n            }\n            doubleValue \u003d longValue / divisor;\n        } else {\n        \tdouble multiplier \u003d Math.pow(10, digits - scale - 1);\n            for(int i \u003d offset; i \u003c\u003d rightMostOffset; ++i) {\n                doubleValue +\u003d ((byte)(as400Value[i] \u0026 0x000F)) * multiplier;\n                multiplier /\u003d 10;\n            }\n        }\n\n        // Determine the sign.\n        switch(as400Value[rightMostOffset] \u0026 0x00F0) {\n            case 0x00B0:\n            case 0x00D0:\n                // Negative.\n                doubleValue *\u003d -1;\n                break;\n            case 0x00A0:\n            case 0x00C0:\n            case 0x00E0:\n            case 0x00F0:\n                // Positive.\n                break;\n            default:\n                throwNumberFormatException(HIGH_NIBBLE, rightMostOffset,\n                                           as400Value[rightMostOffset] \u0026 0x00FF,\n                                           as400Value);\n        }\n\n        return doubleValue;\n    }\n\n    /**\n     * Converts the specified IBM i data type to a Java object.\n     * @param as400Value The array containing the data type in IBM i format.  The entire data type must be represented.\n     * @return The BigDecimal object corresponding to the data type.\n     **/\n    public Object toObject(byte[] as400Value)\n    {\n     return this.toObject(as400Value, 0);\n    }\n\n    /**\n     * Converts the specified IBM i data type to a Java object.\n     * @param as400Value The array containing the data type in IBM i format.  The entire data type must be represented.\n     * @param offset The offset into the byte array for the start of the IBM i value.  It must be greater than or equal to zero.\n     * @return The BigDecimal object corresponding to the data type.\n     **/\n    public Object toObject(byte[] as400Value, int offset)\n    {\n      if (useDouble_) return new Double(toDouble(as400Value, offset));\n\n     // Check offset to prevent bogus NumberFormatException message\n     if (offset \u003c 0)\n     {\n         throw new ArrayIndexOutOfBoundsException(String.valueOf(offset));\n     }\n\n     int size \u003d this.digits;\n\n     int outputPosition \u003d 0; // position in char[]\n     int digitsPlaced \u003d 0; // number of digits moved from input to output\n\n     char[] outputData \u003d null;\n     // read the sign bit, allow ArrayIndexException to be thrown\n     int nibble \u003d (as400Value[offset+size-1] \u0026 0xFF) \u003e\u003e\u003e 4;\n     switch (nibble)\n     {\n         case 0x000B: // valid negative sign bits\n         case 0x000D:\n          outputData \u003d new char[size+1];\n          outputData[outputPosition++] \u003d \u0027-\u0027;\n          break;\n         case 0x000A: // valid positive sign bits\n         case 0x000C:\n         case 0x000E:\n         case 0x000F:\n          outputData \u003d new char[size];\n          break;\n         default: // others invalid\n          throwNumberFormatException(HIGH_NIBBLE, offset+size-1,\n                                     as400Value[offset+size-1] \u0026 0xFF,\n                                     as400Value);\n     }\n\n     // place the digits\n     while (outputPosition \u003c outputData.length)\n     {\n         nibble \u003d as400Value[offset++] \u0026 0x000F;\n         if (nibble \u003e 0x0009)\n           throwNumberFormatException(LOW_NIBBLE, offset-1,\n                                      as400Value[offset-1] \u0026 0x00FF,\n                                      as400Value);\n         outputData[outputPosition++] \u003d (char)(nibble | 0x0030);\n     }\n\n     // construct New BigDecimal object\n     return new BigDecimal(new BigInteger(new String(outputData)), this.scale);\n    }\n\n    public void addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)                       // @C5A\n\t{                                                               // @C5A\n\t    String qName; // Qualified name of child                    // @C5A\n\t    Enumeration children;                                       // @C5A\n\t    PcmlDocNode child;                                          // @C5A\n\t\n\t    children \u003d newChild.getChildren();                          // @C5A\n\t    if (children \u003d\u003d null)                                       // @C5A\n\t        return;                                                 // @C5A\n\t\n\t    LinkedList queue \u003d new LinkedList(); //@F4\n\t\tqueue.add(newChild);//@F4\n\t\twhile (!queue.isEmpty()) {//@F4\n\t\t\tchild \u003d (PcmlDocNode) queue.getFirst();//@F4\n\t\t\tqueue.removeFirst();//@F4\n\t\n\t\t\tchildren \u003d child.getChildren();//@F4\n\t\t\twhile (children.hasMoreElements()) {//@F4\n\t\t\t\tchild \u003d (PcmlDocNode) children.nextElement();//@F4\n\t\t\t\tqName \u003d child.getQualifiedName();//@F4\n\t\t\t\tif (!qName.equals(\"\")) {//@F4\n\t\t\t\t\tif (pcmlDocument.addElement(child) !\u003d null) {//@F4\n\t\t\t\t\t\tpcmlDocument.addPcmlSpecificationError(DAMRI.MULTIPLE_DEFINE, new Object[] { qName });//@F4\n\t\t\t\t\t}//@F4\n\t\t\t\t}//@F4\n\t\t\t\tqueue.add(child);//@F4\n\t\t\t}//@F4\n\t\n\t\t}\n\t\n\t\n\t}\n\n\tstatic final void throwNumberFormatException(boolean highNibble, int byteOffset, int byteValue, byte[] fieldBytes) throws NumberFormatException\n    {\n      String text;\n      if (highNibble) {\n        text \u003d ResourceBundleLoader.getText(\"EXC_HIGH_NIBBLE_NOT_VALID\", Integer.toString(byteOffset), byteToString(byteValue));\n      }\n      else {\n        text \u003d ResourceBundleLoader.getText(\"EXC_LOW_NIBBLE_NOT_VALID\", Integer.toString(byteOffset), byteToString(byteValue));\n      }\n      Trace.log(Trace.ERROR, \"Byte sequence is not valid for a field of type \u0027zoned decimal\u0027:\", fieldBytes);\n      throw new NumberFormatException(text);\n    }\n\n    private static final String byteToString(int byteVal)\n    {\n      int leftDigitValue \u003d (byteVal \u003e\u003e\u003e 4) \u0026 0x0F;\n      int rightDigitValue \u003d byteVal \u0026 0x0F;\n      char[] digitChars \u003d new char[2];\n      // 0x30 \u003d \u00270\u0027, 0x41 \u003d \u0027A\u0027\n      digitChars[0] \u003d leftDigitValue \u003c 0x0A ? (char)(0x30 + leftDigitValue) : (char)(leftDigitValue - 0x0A + 0x41);\n      digitChars[1] \u003d rightDigitValue \u003c 0x0A ? (char)(0x30 + rightDigitValue) : (char)(rightDigitValue - 0x0A + 0x41);\n      return new String(digitChars);\n    }\n\n}"},"candidatesTelemetryData":{"numberOfSuggestions":2,"candidates":[{"lineStart":558,"lineEnd":567,"refactoringType":"MyMoveStaticMethodRefactoring","refactoringInfo":"Move Static method byteToString to class AS400CertificateUtilImplRemote","description":"move method to com.ibm.as400.access.AS400CertificateUtilImplRemote\nRationale: The method byteToString() is a utility function that converts a byte value to its string representation, which is often needed in certificate-related operations. Moving it to AS400CertificateUtilImplRemote aligns with its utility nature.","couldCreateRefObject":true,"applied":false,"undone":false},{"lineStart":512,"lineEnd":543,"refactoringType":"MyMoveMethodRefactoring","refactoringInfo":"Move method addToHashtable to class PcmlDocument","description":"Move method to com.ibm.as400.data.PcmlDocument\nRationale: The method addToHashtable manipulates elements within a PcmlDocument and checks for errors related to its specifications, making it more appropriate for the PcmlDocument class.","couldCreateRefObject":true,"applied":false,"undone":false}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":40}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":15572},"iterationData":[{"iteration_num":1,"suggested_move_methods":[{"method_name":"addToHashtable","method_signature":"public void addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)","target_class":"PcmlDocument","rationale":"The addToHashtable method is primarily concerned with adding elements to a PcmlDocument, which suggests that it belongs in the PcmlDocument class rather than AS400ZonedDecimal."},{"method_name":"throwNumberFormatException","method_signature":"static final void throwNumberFormatException(boolean highNibble, int byteOffset, int byteValue, byte[] fieldBytes)","target_class":"NumberFormatExceptionHandler","rationale":"The throwNumberFormatException method is a utility function for handling exceptions related to number formatting, which would be better suited in a dedicated exception handling class."},{"method_name":"byteToString","method_signature":"private static final String byteToString(int byteVal)","target_class":"ByteUtils","rationale":"The byteToString method is a utility function for converting byte values to strings, which should be moved to a utility class dedicated to byte operations."}],"llm_response_time":9470},{"iteration_num":2,"suggested_move_methods":[{"method_name":"addToHashtable","method_signature":"public void addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)","target_class":"PcmlDocument","rationale":"The addToHashtable method is primarily concerned with adding elements to a PcmlDocument, which suggests that it belongs in the PcmlDocument class rather than AS400ZonedDecimal."},{"method_name":"throwNumberFormatException","method_signature":"static final void throwNumberFormatException(boolean highNibble, int byteOffset, int byteValue, byte[] fieldBytes)","target_class":"NumberFormatExceptionHandler","rationale":"The throwNumberFormatException method is a utility function for handling exceptions related to number formatting, which would be better suited in a dedicated exception handling class."},{"method_name":"byteToString","method_signature":"private static final String byteToString(int byteVal)","target_class":"ByteUtils","rationale":"The byteToString method is a utility function for converting byte values to strings, which should be moved to a utility class dedicated to byte operations."}],"llm_response_time":2622},{"iteration_num":3,"suggested_move_methods":[{"method_name":"addToHashtable","method_signature":"public void addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)","target_class":"PcmlDocument","rationale":"The addToHashtable method is primarily concerned with adding elements to a PcmlDocument, which suggests that it belongs in the PcmlDocument class rather than AS400ZonedDecimal."},{"method_name":"throwNumberFormatException","method_signature":"static final void throwNumberFormatException(boolean highNibble, int byteOffset, int byteValue, byte[] fieldBytes)","target_class":"NumberFormatExceptionHandler","rationale":"The throwNumberFormatException method is a utility function for handling exceptions related to number formatting, which would be better suited in a dedicated exception handling class."},{"method_name":"byteToString","method_signature":"private static final String byteToString(int byteVal)","target_class":"ByteUtils","rationale":"The byteToString method is a utility function for converting byte values to strings, which should be moved to a utility class dedicated to byte operations."}],"llm_response_time":2773},{"iteration_num":-1,"suggested_move_methods":[{"method_name":"addToHashtable","method_signature":"public void addToHashtable(PcmlDocument pcmlDocument, PcmlDocNode newChild)","target_class":"PcmlDocument","rationale":"The addToHashtable method is primarily concerned with adding elements to a PcmlDocument, which suggests that it belongs in the PcmlDocument class rather than AS400ZonedDecimal."},{"method_name":"throwNumberFormatException","method_signature":"static final void throwNumberFormatException(boolean highNibble, int byteOffset, int byteValue, byte[] fieldBytes)","target_class":"NumberFormatExceptionHandler","rationale":"The throwNumberFormatException method is a utility function for handling exceptions related to number formatting, which would be better suited in a dedicated exception handling class."},{"method_name":"byteToString","method_signature":"private static final String byteToString(int byteVal)","target_class":"ByteUtils","rationale":"The byteToString method is a utility function for converting byte values to strings, which should be moved to a utility class dedicated to byte operations."}],"llm_response_time":0}],"llmMethodPriority":{"priority_method_names":["throwNumberFormatException","byteToString","addToHashtable"],"llm_response_time":602},"targetClassMap":{"throwNumberFormatException":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":1026,"similarity_computation_time":0,"similarity_metric":"cosine"},"byteToString":{"target_classes":[{"class_name":"IFSFileOutputStreamImplProxy","similarity_score":0.15161365169308122},{"class_name":"IFSRandomAccessFileImplProxy","similarity_score":0.17107741006292765},{"class_name":"LicenseGetInformationRequest","similarity_score":0.26543974933393855},{"class_name":"ObjectAlreadyExistsException","similarity_score":0.19703453177467295},{"class_name":"ObjectDescriptionEnumeration","similarity_score":0.3111074445533455},{"class_name":"RCCallProgramReplyDataStream","similarity_score":0.3976040051363729},{"class_name":"RequestNotSupportedException","similarity_score":0.16799818413610781},{"class_name":"UserSpaceNativeReadWriteImpl","similarity_score":0.12698476686866622},{"class_name":"ZonedDecimalFieldDescription","similarity_score":0.2654814225840412},{"class_name":"AS400JDBCXADataSourceBeanInfo","similarity_score":0.23069804724868834},{"class_name":"DBColumnDescriptorsDataFormat","similarity_score":0.22204953317953044},{"class_name":"DQRequestAttributesDataStream","similarity_score":0.14941189101912564},{"class_name":"ExtendedIllegalStateException","similarity_score":0.21903556042296787},{"class_name":"IFSFileOutputStreamImplRemote","similarity_score":0.23438416382792526},{"class_name":"IFSRandomAccessFileImplRemote","similarity_score":0.2218256390396833},{"class_name":"PackedDecimalFieldDescription","similarity_score":0.2621907472833748},{"class_name":"PSSecureServerSocketContainer","similarity_score":0.22909278728079807},{"class_name":"RCRunCommandRequestDataStream","similarity_score":0.37839997322241103},{"class_name":"AS400CertificateUsrPrfUtilImpl","similarity_score":0.227139509306281},{"class_name":"AS400CertificateUtilImplNative","similarity_score":0.19634163682202418},{"class_name":"AS400CertificateUtilImplRemote","similarity_score":0.5030804784893246},{"class_name":"AS400FileRecordDescriptionImpl","similarity_score":0.002880264720013801},{"class_name":"DQExchangeAttributesDataStream","similarity_score":0.158961861282456},{"class_name":"IFSTextFileInputStreamBeanInfo","similarity_score":0.2069219709271368},{"class_name":"PrintObjectPageInputStreamImpl","similarity_score":0.05353206828281135},{"class_name":"PSServerSocketContainerAdapter","similarity_score":0.1088269068424215},{"class_name":"RCCallProgramRequestDataStream","similarity_score":0.43135358372763055},{"class_name":"VariableLengthFieldDescription","similarity_score":0.011430437774861094},{"class_name":"AS400CertificateUserProfileUtil","similarity_score":0.16894961990948887},{"class_name":"AS400FileRecordDescriptionEvent","similarity_score":0.23461549121374065}],"target_classes_sorted_by_llm":["AS400CertificateUtilImplRemote","AS400CertificateUtilImplNative","AS400CertificateUsrPrfUtilImpl","RCCallProgramRequestDataStream","RCCallProgramReplyDataStream","RCRunCommandRequestDataStream","ObjectDescriptionEnumeration","ZonedDecimalFieldDescription","LicenseGetInformationRequest","PackedDecimalFieldDescription","AS400FileRecordDescriptionEvent","IFSFileOutputStreamImplRemote","AS400JDBCXADataSourceBeanInfo","PSSecureServerSocketContainer","DBColumnDescriptorsDataFormat","IFSRandomAccessFileImplRemote","ExtendedIllegalStateException","IFSTextFileInputStreamBeanInfo","ObjectAlreadyExistsException","IFSRandomAccessFileImplProxy","AS400CertificateUserProfileUtil","RequestNotSupportedException","DQExchangeAttributesDataStream","IFSFileOutputStreamImplProxy","DQRequestAttributesDataStream","UserSpaceNativeReadWriteImpl","PSServerSocketContainerAdapter","PrintObjectPageInputStreamImpl","VariableLengthFieldDescription","AS400FileRecordDescriptionImpl"],"llm_response_time":1696,"similarity_computation_time":59,"similarity_metric":"cosine"},"addToHashtable":{"target_classes":[{"class_name":"PcmlDocument","similarity_score":0.459345106713597},{"class_name":"PcmlDocNode","similarity_score":0.6011347215769316}],"target_classes_sorted_by_llm":["PcmlDocument","PcmlDocNode"],"llm_response_time":1013,"similarity_computation_time":9,"similarity_metric":"cosine"}}}
    }
]