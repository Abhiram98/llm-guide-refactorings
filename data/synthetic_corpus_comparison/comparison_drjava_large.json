[
    {
        "oracle": "method edu.rice.cs.drjava.config.ConfigOptionListeners.RequiresInteractionsRestartListener::_setupNotificationsPanel(ConfigPanel):void need move to edu.rice.cs.drjava.ui.config.ConfigFrame",
        "class_name": "edu.rice.cs.drjava.config.ConfigOptionListeners.RequiresInteractionsRestartListener",
        "telemetry": {
            "id": "55a8c70c-71b3-4573-be5b-397e096c0a25",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 805,
                "lineStart": 55,
                "lineEnd": 859,
                "bodyLineStart": 55,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/drjava/large/big/drjava-stable-20100913-r5387/src/src/edu/rice/cs/drjava/config/ConfigOptionListeners.java",
                "sourceCode": "/** @version $Id: ConfigOptionListeners.java 5186 2010-03-03 00:14:02Z fro21888 $ */\npublic class ConfigOptionListeners implements OptionConstants {\n  public static class DisplayAllCompilerVersionsListener implements OptionListener<Boolean>, OptionConstants {\n    protected JFrame _parent;\n    public DisplayAllCompilerVersionsListener(JFrame parent) { _parent = parent; }\n    public void optionChanged(OptionEvent<Boolean> oe) {\n      JOptionPane.showMessageDialog(_parent, \"You will have to restart DrJava before the change takes effect.\");\n    }\n  }\n  \n  public static class SlaveJVMArgsListener implements OptionListener<String>, OptionConstants {\n    protected JFrame _parent;\n    public SlaveJVMArgsListener(JFrame parent) { _parent = parent; }\n    public void optionChanged(OptionEvent<String> oe) {\n//      final OptionListener<String> slaveJvmArgsListener = this;\n      DrJava.getConfig().removeOptionListener(SLAVE_JVM_ARGS, this);\n      if (!oe.value.equals(\"\")) {\n        int result = JOptionPane.\n          showConfirmDialog(_parent,\n                            \"Specifying Interations JVM Args is an advanced option. Invalid arguments may cause\\n\" +\n                            \"the Interactions Pane to stop working.\\n\" + \"Are you sure you want to set this option?\\n\" +\n                            \"(You will have to reset the interactions pane before changes take effect.)\",\n                            \"Confirm Interactions JVM Arguments\", JOptionPane.YES_NO_OPTION);\n        if (result!=JOptionPane.YES_OPTION) {\n          DrJava.getConfig().setSetting(oe.option, \"\");\n        }\n        else {\n          sanitizeSlaveJVMArgs(_parent, oe.value, this);\n        }\n      }\n      DrJava.getConfig().addOptionListener(SLAVE_JVM_ARGS, this);\n    }\n  }\n\n  @SuppressWarnings(\"fallthrough\")\n  public static void sanitizeSlaveJVMArgs(JFrame parent,\n                                          String value,\n                                          final OptionListener<String> l) {\n    int pos = value.indexOf(\"-Xmx\");\n    if (((pos>1) && (Character.isWhitespace(value.charAt(pos-1)))) ||\n        (pos == 0)) {\n      int endpos = pos+(\"-Xmx\".length());\n      while(endpos<value.length() && (! Character.isWhitespace(value.charAt(endpos)))) {\n        ++endpos;\n      }\n      \n      int startpos = pos+(\"-Xmx\".length());\n      String size = value.substring(startpos,endpos);\n      long factor = 1;\n      long heapSize;\n      switch(size.toLowerCase().charAt(size.length()-1)) {\n        case 'g': {\n          factor *= 1024; // fall-through intended\n        }\n        case 'm': {\n          factor *= 1024; // fall-through intended\n        }\n        case 'k': {\n          factor *= 1024; // fall-through intended\n          break;\n        }\n        default: {\n          if (!Character.isDigit(size.toLowerCase().charAt(size.length()-1))) factor = 0;\n        }\n      }\n      try {\n        if (factor == 1)  heapSize = new Long(size);\n        else if (factor > 1) heapSize = new Long(size.substring(0,size.length()-1)) * factor;\n        else heapSize = -1;\n      }\n      catch(NumberFormatException nfe) { heapSize = -1; /* invalid */ }\n      long heapSizeMB = (heapSize / 1024) / 1024;\n      // find the next bigger of the choices\n      String newSetting = getNextBiggerHeapSize(heapSizeMB);\n      int result;\n      if (heapSize >= 0) {\n        String[] options = new String[] { \"Copy to \\\"Maximum Heap\\\" Setting\", \"Clean \\\"Slave JVM Args\\\"\", \"Ignore\" };\n        result = JOptionPane.\n          showOptionDialog(parent,\n                           \"You seem to have specified the maximum heap size as part of the\\n\" +\n                           \"\\\"JVM Args for Interactions JVM\\\" setting: \\\"-Xmx\" + size + \"\\\"\\n\" + \n                           \"The \\\"Maximum Heap Memory for Interactions JVM\\\" setting should be used instead.\\n\" + \n                           \"Would you like to copy the value \\\"\" + newSetting + \"\\\" into the \\\"Maximum Heap\\\" setting,\\n\" + \n                           \"just clean up \\\"JVM Args for Interactions JVM\\\", or ignore this potential problem?\",\n                           \"Maximum Heap Size Set in JVM Arguments\",\n                           0,\n                           JOptionPane.QUESTION_MESSAGE,\n                           null,\n                           options,\n                           options[0]);\n      }\n      else {\n        String[] options = new String[] { \"Clean \\\"Main JVM Args\\\"\",\n          \"Ignore\" };\n        result = JOptionPane.\n          showOptionDialog(parent,\n                           \"You seem to have specified the maximum heap size as part of the\\n\" +\n                           \"\\\"JVM Args for Interactions JVM\\\" setting: \\\"-Xmx\" + size + \"\\\"\\n\" + \n                           \"The \\\"Maximum Heap Memory for Interactions JVM\\\" setting should be used instead.\\n\" + \n                           \"Furthermore, the specified heap size \\\"\" + size + \"\\\" is invalid.\\n\" + \n                           \"Would you like to clean up the \\\"JVM Args for Interactions JVM\\\"\\n\" + \n                           \"or ignore this potential problem?\",\n                           \"Maximum Heap Size Set in JVM Arguments\",\n                           0,\n                           JOptionPane.QUESTION_MESSAGE,\n                           null,\n                           options,\n                           options[0]);\n        if (result==1) { result = 2; }\n      }\n      if (result!=2) {\n        // clean up\n        while((endpos<value.length()) &&\n              (Character.isWhitespace(value.charAt(endpos)))) {\n          ++endpos;\n        }\n        String newValue = value.substring(0,pos) + value.substring(endpos);\n        DrJava.getConfig().removeOptionListener(SLAVE_JVM_ARGS, l);\n        DrJava.getConfig().addOptionListener(SLAVE_JVM_ARGS, new OptionListener<String>() {\n          public void optionChanged(OptionEvent<String> oe) {\n            DrJava.getConfig().removeOptionListener(SLAVE_JVM_ARGS, this);\n            EventQueue.invokeLater(new Runnable() { \n              public void run() { DrJava.getConfig().addOptionListener(SLAVE_JVM_ARGS, l); }\n            });\n          }\n        });\n        DrJava.getConfig().setSetting(SLAVE_JVM_ARGS, newValue);\n        if (result == 0) {\n          // copy\n          DrJava.getConfig().setSetting(SLAVE_JVM_XMX, newSetting);\n        }\n        else {\n          JOptionPane.showMessageDialog(parent,\n                                        \"You will have to reset the interactions pane before changes take effect.\");\n        }\n      }\n    }\n  }\n  \n  public static class SlaveJVMXMXListener implements OptionListener<String>, OptionConstants {\n    protected JFrame _parent;\n    public SlaveJVMXMXListener(JFrame parent) { _parent = parent; }\n    public void optionChanged(OptionEvent<String> oe) {\n      DrJava.getConfig().removeOptionListener(SLAVE_JVM_XMX, this);\n      sanitizeSlaveJVMXMX(_parent, oe.value);\n      DrJava.getConfig().addOptionListener(SLAVE_JVM_XMX, this);\n      JOptionPane.showMessageDialog(_parent,\n                                    \"You will have to reset the interactions pane before changes take effect.\");\n    }\n  }\n  \n  public static void sanitizeSlaveJVMXMX(JFrame parent, String value) {\n    if ((!value.equals(\"\")) &&\n        (!value.equals(OptionConstants.heapSizeChoices.get(0)))) {\n      long heapSize;\n      String size = value.trim();\n      try {\n        heapSize = new Long(size);\n      }\n      catch(NumberFormatException nfe) {\n        heapSize = -1; // invalid\n      }\n      if (heapSize < 0) {\n        String[] options = new String[] { \"Clean \\\"Maximum Heap\\\" Setting\",\n          \"Ignore\" };\n        int result = JOptionPane.\n          showOptionDialog(parent,\n                           \"The \\\"Maximum Heap Memory for Interactions JVM\\\" setting is invalid: \\\"\" + size + \"\\\"\\n\" + \n                           \"Would you like to clean up the \\\"Maximum Heap\\\" setting or ignore this potential problem?\",\n                           \"Invalid Maximum Heap Size\",\n                           0,\n                           JOptionPane.QUESTION_MESSAGE,\n                           null,\n                           options,\n                           options[0]);\n        if (result == 0) {\n          // clean up\n          DrJava.getConfig().setSetting(SLAVE_JVM_XMX, OptionConstants.heapSizeChoices.get(0));\n        }\n      }\n      else if (heapSize > 0) {\n        if (!checkHeapSize(heapSize)) {\n          JOptionPane.\n            showMessageDialog(parent,\n                              \"The \\\"Maximum Heap Memory for Interactions JVM\\\" setting is too big: \\\"\" + size + \"\\\"\\n\" + \n                              \"DrJava has reset the heap size to the default. You should choose something smaller.\",\n                              \"Maximum Heap Size Too Big\",\n                              JOptionPane.ERROR_MESSAGE);\n          // clean up\n          DrJava.getConfig().setSetting(SLAVE_JVM_XMX, OptionConstants.heapSizeChoices.get(0));\n        }\n      }\n    }\n  }\n  \n  /** Return the next bigger heap size setting. */\n  static String getNextBiggerHeapSize(long heapSizeMB) {\n    String newSetting = OptionConstants.heapSizeChoices.get(0);\n    for(int i=1; i < OptionConstants.heapSizeChoices.size(); ++i) {\n      try {\n        newSetting = OptionConstants.heapSizeChoices.get(i);\n        float choice = new Float(newSetting);\n        if (choice>=heapSizeMB) {\n          return newSetting;\n        }\n      }\n      catch(NumberFormatException nfe) {\n        return OptionConstants.heapSizeChoices.get(0);\n      }\n    }\n    return newSetting;\n  }\n  \n  public static class MasterJVMArgsListener implements OptionListener<String>, OptionConstants {\n    protected JFrame _parent;\n    public MasterJVMArgsListener(JFrame parent) { _parent = parent; }\n    public void optionChanged(OptionEvent<String> oe) {\n      DrJava.getConfig().removeOptionListener(MASTER_JVM_ARGS, this);\n//      final OptionListener<String> masterJvmArgsListener = this;\n      if (!oe.value.equals(\"\")) {\n        int result = JOptionPane.\n          showConfirmDialog(_parent,\n                            \"Specifying Main JVM Args is an advanced option. Invalid arguments may cause\\n\" +\n                            \"DrJava to fail on start up.  You may need to edit or delete your .drjava preferences file\\n\" +\n                            \"to recover.\\n Are you sure you want to set this option?\\n\" +\n                            \"(You will have to restart Drjava before changes take effect.)\",\n                            \"Confirm Main JVM Arguments\", JOptionPane.YES_NO_OPTION);\n        if (result!=JOptionPane.YES_OPTION) {\n          DrJava.getConfig().setSetting(oe.option, \"\");\n        }\n        else {\n          sanitizeMasterJVMArgs(_parent, oe.value, this);\n        }\n      }\n      DrJava.getConfig().addOptionListener(MASTER_JVM_ARGS, this);\n    }\n  }\n  \n  @SuppressWarnings(\"fallthrough\")\n  public static void sanitizeMasterJVMArgs(JFrame parent, String value, final OptionListener<String> l) {\n    int pos = value.indexOf(\"-Xmx\");\n    if ((pos > 1 && Character.isWhitespace(value.charAt(pos-1))) || pos == 0) {\n      int endpos = pos+(\"-Xmx\".length());\n      while((endpos<value.length()) &&\n            (!Character.isWhitespace(value.charAt(endpos)))) {\n        ++endpos;\n      }\n      \n      int startpos = pos+(\"-Xmx\".length());\n      String size = value.substring(startpos,endpos);\n      long factor = 1;\n      long heapSize;\n      switch(size.toLowerCase().charAt(size.length()-1)) {\n        case 'g': { factor *= 1024; /* fall-through intended */ }\n        case 'm': { factor *= 1024; /* fall-through intended */ }\n        case 'k': {\n          factor *= 1024; /* fall-through intended */\n          break;\n        }\n        default: { if (!Character.isDigit(size.toLowerCase().charAt(size.length()-1)))  factor = 0; }\n      }\n      try {\n        if (factor==1)  heapSize = new Long(size);\n        else if (factor>1)  heapSize = new Long(size.substring(0,size.length()-1)) * factor;\n        else  heapSize = -1;\n      }\n      catch(NumberFormatException nfe) { heapSize = -1; /* invalid */ }\n      long heapSizeMB = (heapSize / 1024) / 1024;\n      \n      // find the next bigger of the choices\n      String newSetting = getNextBiggerHeapSize(heapSizeMB);\n      int result;\n      if (heapSize >= 0) {\n        String[] options = new String[] { \"Copy to \\\"Maximum Heap\\\" Setting\", \"Clean \\\"Master JVM Args\\\"\", \"Ignore\" };\n        result = JOptionPane.\n          showOptionDialog(parent,\n                           \"You seem to have specified the maximum heap size as part of the\\n\" +\n                           \"\\\"JVM Args for Main JVM\\\" setting: \\\"-Xmx\" + size + \"\\\"\\n\" + \n                           \"The \\\"Maximum Heap Memory for Main JVM\\\" setting should be used instead.\\n\" + \n                           \"Would you like to copy the value \\\"\" + newSetting + \"\\\" into the \\\"Maximum Heap\\\" setting,\\n\" + \n                           \"just clean up \\\"JVM Args for Main JVM\\\", or ignore this potential problem?\",\n                           \"Maximum Heap Size Set in JVM Arguments\",\n                           0,\n                           JOptionPane.QUESTION_MESSAGE,\n                           null,\n                           options,\n                           options[0]);\n      }\n      else {\n        String[] options = new String[] { \"Clean \\\"Main JVM Args\\\"\", \"Ignore\" };\n        result = JOptionPane.\n          showOptionDialog(parent,\n                           \"You seem to have specified the maximum heap size as part of the\\n\" +\n                           \"\\\"JVM Args for Main JVM\\\" setting: \\\"-Xmx\" + size + \"\\\"\\n\" + \n                           \"The \\\"Maximum Heap Memory for Main JVM\\\" setting should be used instead.\\n\" + \n                           \"Furthermore, the specified heap size \\\"\" + size + \"\\\" is invalid.\\n\" + \n                           \"Would you like to clean up the \\\"JVM Args for Main JVM\\\"\\n\" + \n                           \"or ignore this potential problem?\",\n                           \"Maximum Heap Size Set in JVM Arguments\",\n                           0,\n                           JOptionPane.QUESTION_MESSAGE,\n                           null,\n                           options,\n                           options[0]);\n        if (result==1) { result = 2; }\n      }\n      if (result!=2) {\n        // clean up\n        while(endpos<value.length() && Character.isWhitespace(value.charAt(endpos))) ++endpos;\n\n        String newValue = value.substring(0,pos) + value.substring(endpos);\n        DrJava.getConfig().removeOptionListener(MASTER_JVM_ARGS, l);\n        DrJava.getConfig().addOptionListener(MASTER_JVM_ARGS, new OptionListener<String>() {\n          public void optionChanged(OptionEvent<String> oe) {\n            DrJava.getConfig().removeOptionListener(MASTER_JVM_ARGS, this);\n            EventQueue.invokeLater(new Runnable() { \n              public void run() { DrJava.getConfig().addOptionListener(MASTER_JVM_ARGS, l); }\n            });\n          }\n        });\n        DrJava.getConfig().setSetting(MASTER_JVM_ARGS, newValue);\n        if (result == 0) DrJava.getConfig().setSetting(MASTER_JVM_XMX, newSetting);   // copy\n        else JOptionPane.showMessageDialog(parent, \"You will have to restart DrJava before the change takes effect.\");\n      }\n    }\n  }\n  \n  public static class MasterJVMXMXListener implements OptionListener<String>, OptionConstants {\n    protected JFrame _parent;\n    public MasterJVMXMXListener(JFrame parent) { _parent = parent; }\n    public void optionChanged(OptionEvent<String> oe) {\n      DrJava.getConfig().removeOptionListener(MASTER_JVM_XMX, this);\n      sanitizeMasterJVMXMX(_parent, oe.value);\n      JOptionPane.showMessageDialog(_parent, \"You will have to restart DrJava before the change takes effect.\");\n      DrJava.getConfig().addOptionListener(MASTER_JVM_XMX, this);\n    }\n  }\n  \n  public static void sanitizeMasterJVMXMX(JFrame parent, String value) {\n    if ((!value.equals(\"\")) &&\n        (!value.equals(OptionConstants.heapSizeChoices.get(0)))) {\n      String size = value.trim();\n      long heapSize;\n      try {\n        heapSize = new Long(size);\n      }\n      catch(NumberFormatException nfe) {\n        heapSize = -1; // invalid\n      }\n      if (heapSize < 0) {\n        String[] options = new String[] { \"Clean \\\"Maximum Heap\\\" Setting\",\n          \"Ignore\" };\n        int result = JOptionPane.\n          showOptionDialog(parent,\n                           \"The \\\"Maximum Heap Memory for Main JVM\\\" setting is invalid: \\\"\" + size + \"\\\"\\n\" + \n                           \"Would you like to clean up the \\\"Maximum Heap\\\" setting or ignore this potential problem?\",\n                           \"Invalid Maximum Heap Size\",\n                           0,\n                           JOptionPane.QUESTION_MESSAGE,\n                           null,\n                           options,\n                           options[0]);\n        if (result == 0) {\n          // clean up\n          DrJava.getConfig().setSetting(MASTER_JVM_XMX, OptionConstants.heapSizeChoices.get(0));\n        }\n      }\n      else if (heapSize > 0) {\n        if (!checkHeapSize(heapSize)) {\n          JOptionPane.\n            showMessageDialog(parent,\n                              \"The \\\"Maximum Heap Memory for Main JVM\\\" setting is too big: \\\"\" + size + \"\\\"\\n\" + \n                              \"DrJava has reset the heap size to the default. You should choose something smaller.\",\n                              \"Maximum Heap Size Too Big\",\n                              JOptionPane.ERROR_MESSAGE);\n          // clean up\n          DrJava.getConfig().setSetting(MASTER_JVM_XMX, OptionConstants.heapSizeChoices.get(0));\n        }\n      }\n    }\n  }\n  \n  /** @return true if a JVM can be created with the specified heap size (in MB) */\n  public static boolean checkHeapSize(long heapSize) {\n    int exitValue = 1;\n    try {\n      JVMBuilder jvmb = JVMBuilder.DEFAULT.jvmArguments(\"-Xmx\"+heapSize+\"M\");\n      Process p = jvmb.start(MemoryCheckDummy.class.getName());\n      exitValue = p.waitFor();\n    }\n    catch(java.io.IOException e) { exitValue = 1; }\n    catch(InterruptedException e) { exitValue = 1; }\n    return (exitValue==0);\n  }\n  \n  /** Class that gets executed to check if the selected heap size is possible. */\n  public static class MemoryCheckDummy {\n    public static void main(String[] args) {\n      final StringBuilder sb = new StringBuilder(\"DrJava Version : \");\n      sb.append(edu.rice.cs.drjava.Version.getVersionString());\n      sb.append(\"\\nDrJava Build Time: \");\n      sb.append(edu.rice.cs.drjava.Version.getBuildTimeString());\n      sb.append(\"\\n\\nUsed memory: about \");\n      sb.append(StringOps.memSizeToString(Runtime.getRuntime().totalMemory()-Runtime.getRuntime().freeMemory()));\n      sb.append(\"\\nFree memory: about \");\n      sb.append(StringOps.memSizeToString(Runtime.getRuntime().freeMemory()));\n      sb.append(\"\\nTotal memory: about \");\n      sb.append(StringOps.memSizeToString(Runtime.getRuntime().totalMemory()));\n      sb.append(\"\\nTotal memory can expand to: about \");\n      sb.append(StringOps.memSizeToString(Runtime.getRuntime().maxMemory()));\n      System.out.println(sb.toString());\n      System.exit(0);\n    }\n  }\n  \n  public static class JavadocCustomParamsListener implements OptionListener<String>, OptionConstants {\n    protected JFrame _parent;\n    public JavadocCustomParamsListener(JFrame parent) { _parent = parent; }\n    public void optionChanged(OptionEvent<String> oe) {\n      sanitizeJavadocCustomParams(_parent, oe.value);\n    }\n  }\n  \n  public static void sanitizeJavadocCustomParams(JFrame parent,\n                                                 String value) {\n    boolean containsPrivate = (value.indexOf(\"-private\") >= 0);\n    boolean containsProtected = (value.indexOf(\"-protected\") >= 0);\n    boolean containsPublic = (value.indexOf(\"-public\") >= 0);\n    boolean containsPackage = (value.indexOf(\"-package\") >= 0);\n\n    if (containsPrivate || containsProtected || containsPublic || containsPackage) {\n      StringBuilder sb = new StringBuilder();\n      if (containsPublic) { sb.append(\"-public \"); }\n      if (containsProtected) { sb.append(\"-protected \"); }\n      if (containsPrivate) { sb.append(\"-private \"); }\n      if (containsPackage) { sb.append(\"-package \"); }      \n      String[] options = new String[] { \"Copy to \\\"Access Level\\\" Setting\",\n        \"Clean \\\"Custom Javadoc Parameters\\\"\",\n        \"Ignore\" };\n      int result = JOptionPane.\n        showOptionDialog(parent,\n                         \"You seem to have specified \" + sb.toString() + \"as part of the\\n\" +\n                         \"\\\"Custom Javadoc Parameters\\\" setting. The \\\"Access Level\\\"\\n\" + \n                         \"setting should be used instead. Would you like to copy the\\n\" + \n                         \"parameter into the \\\"Access Level\\\" setting, just clean up\\n\" + \n                         \"\\\"Custom Javadoc Parameters\\\", or ignore this potential problem?\",\n                         \"Access Level Set in Custom Javadoc Parameters\",\n                         0,\n                         JOptionPane.QUESTION_MESSAGE,\n                         null,\n                         options,\n                         options[0]);\n      if (result!=2) {\n        if (result == 0) {\n          // copy\n          if (containsPublic) { DrJava.getConfig().setSetting(JAVADOC_ACCESS_LEVEL, \"public\"); }\n          else if (containsProtected) { DrJava.getConfig().setSetting(JAVADOC_ACCESS_LEVEL, \"protected\"); }\n          else if (containsPrivate) { DrJava.getConfig().setSetting(JAVADOC_ACCESS_LEVEL, \"private\"); }\n          else if (containsPackage) { DrJava.getConfig().setSetting(JAVADOC_ACCESS_LEVEL, \"package\"); }\n        }\n        // clean up\n        String[] params = value.split(\"(-private|-protected|-package|-public)\");\n        sb = new StringBuilder();\n        for(int i = 0; i < params.length; i++){\n          if(!params[i].trim().equals(\"\")) { sb.append(params[i].trim()); sb.append(' '); }\n        }\n        DrJava.getConfig().setSetting(JAVADOC_CUSTOM_PARAMS, sb.toString().trim());\n      }\n    }\n  }\n  \n  public static class LookAndFeelListener implements OptionListener<String> {\n    protected JFrame _parent;\n    public LookAndFeelListener(JFrame parent) { _parent = parent; }\n    public void optionChanged(OptionEvent<String> oe) {\n//        try {\n//          UIManager.setLookAndFeel(oe.value);\n//          SwingUtilities.updateComponentTreeUI(MainFrame.this);\n//          if (_debugPanel != null) {\n//            SwingUtilities.updateComponentTreeUI(_debugPanel);\n//          }\n//          if (_configFrame != null) {\n//            SwingUtilities.updateComponentTreeUI(_configFrame);\n//          }\n//          if (_helpFrame != null) {\n//            SwingUtilities.updateComponentTreeUI(_helpFrame);\n//          }\n//          if (_aboutDialog != null) {\n//            SwingUtilities.updateComponentTreeUI(_aboutDialog);\n//          }\n//          SwingUtilities.updateComponentTreeUI(_navPanePopupMenu);\n//          SwingUtilities.updateComponentTreeUI(_interactionsPanePopupMenu);\n//          SwingUtilities.updateComponentTreeUI(_consolePanePopupMenu);\n//          SwingUtilities.updateComponentTreeUI(_openChooser);\n//          SwingUtilities.updateComponentTreeUI(_saveChooser);\n//          Iterator<TabbedPanel> it = _tabs.iterator();\n//          while (it.hasNext()) {\n//            SwingUtilities.updateComponentTreeUI(it.next());\n//          }\n//        }\n//        catch (Exception ex) {\n//          _showError(ex, \"Could Not Set Look and Feel\",\n//                     \"An error occurred while trying to set the look and feel.\");\n//        }\n      \n      String title = \"Apply Look and Feel\";\n      String msg = \"Look and feel changes will take effect when you restart DrJava.\";\n      if (DrJava.getConfig().getSetting(WARN_CHANGE_LAF).booleanValue()) {\n        ConfirmCheckBoxDialog dialog =\n          new ConfirmCheckBoxDialog(_parent, title, msg,\n                                    \"Do not show this message again\",\n                                    JOptionPane.INFORMATION_MESSAGE,\n                                    JOptionPane.DEFAULT_OPTION);\n        if (dialog.show() == JOptionPane.OK_OPTION && dialog.getCheckBoxValue()) {\n          DrJava.getConfig().setSetting(WARN_CHANGE_LAF, Boolean.FALSE);\n        }\n      }\n    }\n  }\n  \n  public static class PlasticThemeListener implements OptionListener<String> {\n    protected JFrame _parent;\n    public PlasticThemeListener(JFrame parent) { _parent = parent; }\n    public void optionChanged(OptionEvent<String> oe) {\n      String title = \"Apply Theme\";\n      String msg = \"Changes to the theme will take effect when you restart DrJava.\";\n      if (DrJava.getConfig().getSetting(WARN_CHANGE_THEME).booleanValue()) {\n        ConfirmCheckBoxDialog dialog =\n          new ConfirmCheckBoxDialog(_parent, title, msg,\n                                    \"Do not show this message again\",\n                                    JOptionPane.INFORMATION_MESSAGE,\n                                    JOptionPane.DEFAULT_OPTION);\n        if (dialog.show() == JOptionPane.OK_OPTION && dialog.getCheckBoxValue()) {\n          DrJava.getConfig().setSetting(WARN_CHANGE_THEME, Boolean.FALSE);\n        }\n      }\n    }\n  }  \n  \n  public static class RequiresDrJavaRestartListener<T> implements OptionListener<T> {\n    protected JFrame _parent;\n    protected String _description;\n    public RequiresDrJavaRestartListener(JFrame parent, String description) {\n      _parent = parent;\n      _description = description;\n    }\n    public void optionChanged(OptionEvent<T> oe) {      \n      String title = \"Apply Preference Changes\";\n      String msg = \"Changes to the '\"+_description+\"' preferences\\nwill only take effect when you restart DrJava.\";\n      if (DrJava.getConfig().getSetting(WARN_CHANGE_MISC).booleanValue()) {\n        ConfirmCheckBoxDialog dialog =\n          new ConfirmCheckBoxDialog(_parent, title, msg,\n                                    \"Do not show this message again\",\n                                    JOptionPane.INFORMATION_MESSAGE,\n                                    JOptionPane.DEFAULT_OPTION);\n        if (dialog.show() == JOptionPane.OK_OPTION && dialog.getCheckBoxValue()) {\n          DrJava.getConfig().setSetting(WARN_CHANGE_MISC, Boolean.FALSE);\n        }\n      }\n    }\n  }\n\n  public static class RequiresInteractionsRestartListener<T> implements OptionListener<T> {\n    protected JFrame _parent;\n    protected String _description;\n    public RequiresInteractionsRestartListener(JFrame parent, String description) {\n      _parent = parent;\n      _description = description;\n    }\n    public void optionChanged(OptionEvent<T> oe) {\n      String title = \"Apply Preference Changes\";\n      String msg = \"Changes to the '\"+_description+\"' preferences\\nwill only take effect when you reset the Interactions Pane.\";\n      if (DrJava.getConfig().getSetting(WARN_CHANGE_INTERACTIONS).booleanValue()) {\n        ConfirmCheckBoxDialog dialog =\n          new ConfirmCheckBoxDialog(_parent, title, msg,\n                                    \"Do not show this message again\",\n                                    JOptionPane.INFORMATION_MESSAGE,\n                                    JOptionPane.DEFAULT_OPTION);\n        if (dialog.show() == JOptionPane.OK_OPTION && dialog.getCheckBoxValue()) {\n          DrJava.getConfig().setSetting(WARN_CHANGE_INTERACTIONS, Boolean.FALSE);\n        }\n      }\n    }\n\t/** Adds all of the components for the Prompts panel of the preferences window. \n\t * @param configFrame TODO\n\t * @param panel TODO*/\n\t  public void _setupNotificationsPanel(ConfigFrame configFrame, ConfigPanel panel) {\n\t    // Quit\n\t    configFrame.addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.QUIT_PROMPT, \"Prompt Before Quit\", configFrame,\n\t                                                         \"Whether DrJava should prompt the user before quitting.\", false)\n\t                         .setEntireColumn(true));\n\t\n\t    // Interactions\n\t    configFrame.addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.INTERACTIONS_RESET_PROMPT,\n\t                                                         \"Prompt Before Resetting Interactions Pane\", configFrame,\n\t                                                         \"<html>Whether DrJava should prompt the user before<br>\" +\n\t                                                         \"manually resetting the interactions pane.</html>\", false)\n\t                         .setEntireColumn(true));\n\t    \n\t    configFrame.addOptionComponent(panel, \n\t                       new BooleanOptionComponent(OptionConstants.INTERACTIONS_EXIT_PROMPT,\n\t                                                  \"Prompt if Interactions Pane Exits Unexpectedly\", \n\t                                                  configFrame,\n\t                                                  \"<html>Whether DrJava should show a dialog box if a program<br>\" +\n\t                                                  \"in the Interactions Pane exits without the user clicking Reset.</html>\",\n\t                                                  false)\n\t                         .setEntireColumn(true));\n\t\n\t    // Javadoc\n\t    configFrame.addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.JAVADOC_PROMPT_FOR_DESTINATION,\n\t                                                         \"Prompt for Javadoc Destination\", \n\t                                                         configFrame,\n\t                                                         \"<html>Whether Javadoc should always prompt the user<br>\" +\n\t                                                         \"to select a destination directory.</html>\", \n\t                                                         false)\n\t                         .setEntireColumn(true));\n\t\n\t\n\t    // Clean\n\t    configFrame.addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.PROMPT_BEFORE_CLEAN,\n\t                                                         \"Prompt before Cleaning Build Directory\", configFrame,\n\t                                                         \"<html>Whether DrJava should prompt before cleaning the<br>\" +\n\t                                                         \"build directory of a project</html>\", false)\n\t                         .setEntireColumn(true));\n\t\n\t    // Prompt to change the language level extensions (.dj0/.dj1->.dj, .dj2->.java)\n\t    configFrame.addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.PROMPT_RENAME_LL_FILES, \"Prompt to Rename Old Language Level Files When Saving\", configFrame,\n\t                                                         \"<html>Whether DrJava should prompt the user to rename old language level files.<br>\"+\n\t                                                         \"DrJava suggests to rename .dj0 and .dj1 files to .dj, and .dj2 files to .java.</html>\", false)\n\t                         .setEntireColumn(true));\n\t\n\t    \n\t    // Save before X\n\t    configFrame.addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.ALWAYS_SAVE_BEFORE_COMPILE,\n\t                                                         \"Automatically Save Before Compiling\", configFrame,\n\t                                                         \"<html>Whether DrJava should automatically save before<br>\" +\n\t                                                         \"recompiling or ask the user each time.</html>\", false)\n\t                         .setEntireColumn(true));\n\t    \n\t    configFrame.addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.ALWAYS_COMPILE_BEFORE_JUNIT, \n\t                                                         \"Automatically Compile Before Testing\", configFrame,\n\t                                                         \"<html>Whether DrJava should automatically compile before<br>\" +\n\t                                                         \"testing with JUnit or ask the user each time.</html>\", false)\n\t                         .setEntireColumn(true)); \n\t    \n\t    configFrame.addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.ALWAYS_SAVE_BEFORE_JAVADOC,\n\t                                                         \"Automatically Save Before Generating Javadoc\", configFrame,\n\t                                                         \"<html>Whether DrJava should automatically save before<br>\" +\n\t                                                         \"generating Javadoc or ask the user each time.</html>\", false)\n\t                         .setEntireColumn(true));\n\t    \n\t    configFrame.addOptionComponent(panel, new BooleanOptionComponent(OptionConstants.ALWAYS_COMPILE_BEFORE_JAVADOC,\n\t                                                         \"Automatically Compile Before Generating Javadoc\", configFrame,\n\t                                                         \"<html>Whether DrJava should automatically compile before<br>\" +\n\t                                                         \"generating Javadoc or ask the user each time.</html>\", false)\n\t                         .setEntireColumn(true));\n\t\n\t\n\t    // These are very problematic features, and so are disabled for the forseeable future.\n\t//    addOptionComponent(panel, \n\t//                       new BooleanOptionComponent(OptionConstants.ALWAYS_SAVE_BEFORE_RUN, \n\t//                                                  \"Automatically Save and Compile Before Running Main Method\", \n\t//                                                  this,\n\t//                                                  \"<html>Whether DrJava automatically saves and compiles before running<br>\" +\n\t//                                                  \"a document's main method or explicitly asks the user each time.</html>\"));\n\t//    addOptionComponent(panel, \n\t//                       new BooleanOptionComponent(OptionConstants.ALWAYS_SAVE_BEFORE_DEBUG, \n\t//                                                  \"Automatically Save and Compile Before Debugging\", \n\t//                                                  this,\n\t//                                                  \"<html>Whether DrJava automatically saves and compiles before<br>\" +\n\t//                                                  \"debugging or explicitly asks the user each time.</html>\"));\n\t    \n\t    // Warnings\n\t    configFrame.addOptionComponent(panel, \n\t                       new BooleanOptionComponent(OptionConstants.WARN_BREAKPOINT_OUT_OF_SYNC,\n\t                                                  \"Warn on Breakpoint if Out of Sync\", \n\t                                                  configFrame,\n\t                                                  \"<html>Whether DrJava should warn the user if the class file<br>\" +\n\t                                                  \"is out of sync before setting a breakpoint in that file.</html>\", \n\t                                                  false)\n\t                         .setEntireColumn(true));\n\t    configFrame.addOptionComponent(panel, \n\t                       new BooleanOptionComponent(OptionConstants.WARN_DEBUG_MODIFIED_FILE,\n\t                                                  \"Warn if Debugging Modified File\", \n\t                                                  configFrame,\n\t                                                  \"<html>Whether DrJava should warn the user if the file being<br>\" +\n\t                                                  \"debugged has been modified since its last save.</html>\", \n\t                                                  false)\n\t                         .setEntireColumn(true));\n\t    configFrame.addOptionComponent(panel, \n\t                       new BooleanOptionComponent(OptionConstants.WARN_CHANGE_LAF,\n\t                                                  \"Warn to Restart to Change Look and Feel\", \n\t                                                  configFrame,\n\t                                                  \"<html>Whether DrJava should warn the user that look and feel<br>\" +\n\t                                                  \"changes will not be applied until DrJava is restarted.</html>.\", \n\t                                                  false)\n\t                         .setEntireColumn(true));\n\t    configFrame.addOptionComponent(panel, \n\t                       new BooleanOptionComponent(OptionConstants.WARN_CHANGE_THEME,\n\t                                                  \"Warn to Restart to Change Theme\", \n\t                                                  configFrame,\n\t                                                  \"<html>Whether DrJava should warn the user that theme<br>\" +\n\t                                                  \"changes will not be applied until DrJava is restarted.</html>.\", \n\t                                                  false)\n\t                         .setEntireColumn(true));\n\t    configFrame.addOptionComponent(panel, \n\t                       new BooleanOptionComponent(OptionConstants.WARN_CHANGE_DCP,\n\t                                                  \"Warn to Restart to Change Default Compiler Preference\", \n\t                                                  configFrame,\n\t                                                  \"<html>Whether DrJava should warn the user that default compiler preference<br>\" +\n\t                                                  \"changes will not be applied until DrJava is restarted.</html>.\", \n\t                                                  false)\n\t                         .setEntireColumn(true));\n\t    configFrame.addOptionComponent(panel, \n\t                       new BooleanOptionComponent(OptionConstants.WARN_CHANGE_MISC,\n\t                                                  \"Warn to Restart to Change Preferences (other)\", \n\t                                                  configFrame,\n\t                                                  \"<html>Whether DrJava should warn the user that preference<br>\" +\n\t                                                  \"changes will not be applied until DrJava is restarted.</html>.\", \n\t                                                  false)\n\t                         .setEntireColumn(true));\n\t    configFrame.addOptionComponent(panel, \n\t                       new BooleanOptionComponent(OptionConstants.WARN_CHANGE_INTERACTIONS,\n\t                                                  \"Warn to Reset to Change Interactions\", \n\t                                                  configFrame,\n\t                                                  \"<html>Whether DrJava should warn the user that preference<br>\" +\n\t                                                  \"changes will not be applied until the Interactions Pane<br>\" +\n\t                                                  \"is reset.</html>.\", \n\t                                                  false)\n\t                         .setEntireColumn(true));\n\t    configFrame.addOptionComponent(panel, \n\t                       new BooleanOptionComponent(OptionConstants.WARN_PATH_CONTAINS_POUND,\n\t                                                  \"Warn if File's Path Contains a '#' Symbol\", \n\t                                                  configFrame,\n\t                                                  \"<html>Whether DrJava should warn the user if the file being<br>\" +\n\t                                                  \"saved has a path that contains a '#' symbol.<br>\" +\n\t                                                  \"Users cannot use such files in the Interactions Pane<br>\" +\n\t                                                  \"because of a bug in Java.</html>\", \n\t                                                  false)\n\t                         .setEntireColumn(true));\n\t\n\t    configFrame.addOptionComponent(panel, \n\t                       new BooleanOptionComponent(OptionConstants.DIALOG_DRJAVA_ERROR_POPUP_ENABLED, \n\t                                                  \"Show a notification window when the first DrJava error occurs\", \n\t                                                  configFrame,\n\t                                                  \"<html>Whether to show a notification window when the first DrJava error occurs.<br>\" +\n\t                                                  \"If this is disabled, only the \\\"DrJava Error\\\" button will appear.</html>\", \n\t                                                  false)\n\t                         .setEntireColumn(true));\n\t    configFrame.addOptionComponent(panel,\n\t                       new BooleanOptionComponent(OptionConstants.WARN_IF_COMPIZ, \n\t                                                  \"Warn If Compiz Detected\",\n\t                                                  configFrame,\n\t                                                  \"<html>Whether DrJava should warn the user if Compiz is running.<br>\"+\n\t                                                  \"Compiz and Java Swing are incompatible and can lead to crashes.</html>\",\n\t                                                  false)\n\t                         .setEntireColumn(true));\n\t    \n\t    \n\t    configFrame.addOptionComponent(panel, \n\t                       new LabelComponent(\"<html>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" +\n\t                                          \"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" + \n\t                                          \"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</html>\", configFrame, true));\n\t\n\t    configFrame.addOptionComponent(panel, \n\t                       new ForcedChoiceOptionComponent(OptionConstants.DELETE_LL_CLASS_FILES,\n\t                                                       \"Delete language level class files?\", configFrame,\n\t                                                       \"Whether DrJava should delete class files in directories with language level files.\"));\n\t\n\t    configFrame.addOptionComponent(panel, \n\t                       new LabelComponent(\"<html>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" +\n\t                                          \"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\" + \n\t                                          \"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</html>\", configFrame, true));\n\t\n\t    configFrame.addOptionComponent(panel, \n\t                       new ForcedChoiceOptionComponent(OptionConstants.NEW_VERSION_NOTIFICATION,\n\t                                                       \"Check for new versions?\", configFrame,\n\t                                                       \"Whether DrJava should check for new versions on drjava.org.\"));\n\t    configFrame.addOptionComponent(panel, new IntegerOptionComponent(OptionConstants.NEW_VERSION_NOTIFICATION_DAYS,\n\t                                                         \"Days between new version check\", configFrame,\n\t                                                         \"The number of days between automatic new version checks.\"));\n\t\n\t    panel.displayComponents();\n\t  }\n  }\n  \n   public static class DefaultCompilerListener implements OptionListener<String> {\n    protected JFrame _parent;\n    public DefaultCompilerListener(JFrame parent) { _parent = parent; }\n    public void optionChanged(OptionEvent<String> oe) {      \n      String title = \"Apply Default Compiler Preference Change\";\n      String msg = \"Default Compiler Preference will take effect when you restart DrJava.\";\n      if (DrJava.getConfig().getSetting(WARN_CHANGE_DCP).booleanValue()) {\n        ConfirmCheckBoxDialog dialog =\n          new ConfirmCheckBoxDialog(_parent, title, msg,\n                                    \"Do not show this message again\",\n                                    JOptionPane.INFORMATION_MESSAGE,\n                                    JOptionPane.DEFAULT_OPTION);\n        if (dialog.show() == JOptionPane.OK_OPTION && dialog.getCheckBoxValue()) {\n          DrJava.getConfig().setSetting(WARN_CHANGE_DCP, Boolean.FALSE);\n        }\n      }\n    }\n  }\n}",
                "methodCount": 35
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 637,
                        "lineEnd": 837,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method _setupNotificationsPanel to class ConfigPanel",
                        "description": "Move method _setupNotificationsPanel to edu.rice.cs.drjava.ui.config.ConfigPanel\nRationale: The method _setupNotificationsPanel is responsible for adding various notification-related components to a preferences panel. Since ConfigPanel is specifically designed to manage and display configuration options, it is the most appropriate class for this method. Moving the method to ConfigPanel will enhance cohesion, as it will centralize all configuration-related functionalities within the ConfigPanel class, making it easier to maintain and understand. The ConfigFrame class, on the other hand, serves as a container for the configuration interface and should not be burdened with the specifics of setting up individual panels.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "sanitizeSlaveJVMArgs",
                            "method_signature": "public static void sanitizeSlaveJVMArgs(JFrame parent, String value, final OptionListener<String> l)",
                            "target_class": "JVMSettings",
                            "rationale": "The method sanitizes JVM arguments and is closely related to JVM settings management, making it more appropriate for a dedicated JVMSettings class."
                        },
                        {
                            "method_name": "sanitizeMasterJVMArgs",
                            "method_signature": "public static void sanitizeMasterJVMArgs(JFrame parent, String value, final OptionListener<String> l)",
                            "target_class": "JVMSettings",
                            "rationale": "Similar to sanitizeSlaveJVMArgs, this method deals with sanitizing master JVM arguments and should be part of a class that manages JVM settings."
                        },
                        {
                            "method_name": "sanitizeSlaveJVMXMX",
                            "method_signature": "public static void sanitizeSlaveJVMXMX(JFrame parent, String value)",
                            "target_class": "JVMSettings",
                            "rationale": "This method is responsible for sanitizing the slave JVM XMX settings, which aligns with the responsibilities of a JVMSettings class."
                        },
                        {
                            "method_name": "sanitizeMasterJVMXMX",
                            "method_signature": "public static void sanitizeMasterJVMXMX(JFrame parent, String value)",
                            "target_class": "JVMSettings",
                            "rationale": "This method sanitizes the master JVM XMX settings and should be moved to a class that handles JVM configuration."
                        },
                        {
                            "method_name": "checkHeapSize",
                            "method_signature": "public static boolean checkHeapSize(long heapSize)",
                            "target_class": "JVMSettings",
                            "rationale": "This method checks if a JVM can be created with the specified heap size, which is a core functionality related to JVM settings."
                        },
                        {
                            "method_name": "sanitizeJavadocCustomParams",
                            "method_signature": "public static void sanitizeJavadocCustomParams(JFrame parent, String value)",
                            "target_class": "JavadocSettings",
                            "rationale": "This method sanitizes Javadoc custom parameters and should be part of a dedicated class that manages Javadoc settings."
                        },
                        {
                            "method_name": "getNextBiggerHeapSize",
                            "method_signature": "static String getNextBiggerHeapSize(long heapSizeMB)",
                            "target_class": "JVMSettings",
                            "rationale": "This method determines the next bigger heap size setting, which is relevant to JVM configuration and should be part of a JVMSettings class."
                        }
                    ],
                    "llm_response_time": 8786
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "sanitizeSlaveJVMArgs",
                            "method_signature": "public static void sanitizeSlaveJVMArgs(JFrame parent, String value, final OptionListener<String> l)",
                            "target_class": "JVMSettings",
                            "rationale": "The method sanitizes JVM arguments and is closely related to JVM settings. Moving it to a dedicated JVMSettings class would improve separation of concerns."
                        },
                        {
                            "method_name": "sanitizeMasterJVMArgs",
                            "method_signature": "public static void sanitizeMasterJVMArgs(JFrame parent, String value, final OptionListener<String> l)",
                            "target_class": "JVMSettings",
                            "rationale": "Similar to sanitizeSlaveJVMArgs, this method deals with sanitizing master JVM arguments and should be moved to a dedicated JVMSettings class for better organization."
                        },
                        {
                            "method_name": "sanitizeSlaveJVMXMX",
                            "method_signature": "public static void sanitizeSlaveJVMXMX(JFrame parent, String value)",
                            "target_class": "JVMSettings",
                            "rationale": "This method is responsible for sanitizing the Slave JVM XMX setting, which is related to JVM configurations. It should be moved to a JVMSettings class."
                        },
                        {
                            "method_name": "sanitizeMasterJVMXMX",
                            "method_signature": "public static void sanitizeMasterJVMXMX(JFrame parent, String value)",
                            "target_class": "JVMSettings",
                            "rationale": "This method sanitizes the Master JVM XMX setting and should be part of a dedicated JVMSettings class to maintain a clear structure."
                        },
                        {
                            "method_name": "checkHeapSize",
                            "method_signature": "public static boolean checkHeapSize(long heapSize)",
                            "target_class": "JVMSettings",
                            "rationale": "This method checks if a JVM can be created with the specified heap size, which is a configuration-related task. It should be moved to a JVMSettings class."
                        },
                        {
                            "method_name": "sanitizeJavadocCustomParams",
                            "method_signature": "public static void sanitizeJavadocCustomParams(JFrame parent, String value)",
                            "target_class": "JavadocSettings",
                            "rationale": "This method sanitizes custom Javadoc parameters and should be moved to a dedicated JavadocSettings class for better organization."
                        },
                        {
                            "method_name": "getNextBiggerHeapSize",
                            "method_signature": "static String getNextBiggerHeapSize(long heapSizeMB)",
                            "target_class": "JVMSettings",
                            "rationale": "This method determines the next bigger heap size setting and is related to JVM configurations. It should be moved to a JVMSettings class."
                        }
                    ],
                    "llm_response_time": 8907
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "sanitizeSlaveJVMArgs",
                            "method_signature": "public static void sanitizeSlaveJVMArgs(JFrame parent, String value, final OptionListener<String> l)",
                            "target_class": "JVMSettings",
                            "rationale": "The method sanitizes JVM arguments and is closely related to JVM settings. Moving it to a dedicated JVMSettings class would improve separation of concerns."
                        },
                        {
                            "method_name": "sanitizeMasterJVMArgs",
                            "method_signature": "public static void sanitizeMasterJVMArgs(JFrame parent, String value, final OptionListener<String> l)",
                            "target_class": "JVMSettings",
                            "rationale": "Similar to sanitizeSlaveJVMArgs, this method deals with sanitizing master JVM arguments and should be part of a dedicated JVMSettings class."
                        },
                        {
                            "method_name": "sanitizeSlaveJVMXMX",
                            "method_signature": "public static void sanitizeSlaveJVMXMX(JFrame parent, String value)",
                            "target_class": "JVMSettings",
                            "rationale": "This method is responsible for sanitizing the Slave JVM XMX setting, which is related to JVM configurations. It should be moved to a JVMSettings class."
                        },
                        {
                            "method_name": "sanitizeMasterJVMXMX",
                            "method_signature": "public static void sanitizeMasterJVMXMX(JFrame parent, String value)",
                            "target_class": "JVMSettings",
                            "rationale": "This method sanitizes the Master JVM XMX setting and should be part of a dedicated JVMSettings class for better organization."
                        },
                        {
                            "method_name": "checkHeapSize",
                            "method_signature": "public static boolean checkHeapSize(long heapSize)",
                            "target_class": "JVMSettings",
                            "rationale": "This method checks if a JVM can be created with the specified heap size, which is a configuration aspect of JVM settings. It should be moved to a JVMSettings class."
                        },
                        {
                            "method_name": "sanitizeJavadocCustomParams",
                            "method_signature": "public static void sanitizeJavadocCustomParams(JFrame parent, String value)",
                            "target_class": "JavadocSettings",
                            "rationale": "This method sanitizes custom Javadoc parameters and should be moved to a dedicated JavadocSettings class to improve organization."
                        },
                        {
                            "method_name": "getNextBiggerHeapSize",
                            "method_signature": "static String getNextBiggerHeapSize(long heapSizeMB)",
                            "target_class": "JVMSettings",
                            "rationale": "This method determines the next bigger heap size setting and is related to JVM configurations. It should be part of a JVMSettings class."
                        }
                    ],
                    "llm_response_time": 9196
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<String> oe)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<String> oe)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<String> oe)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<String> oe)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<String> oe)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_setupNotificationsPanel",
                            "method_signature": "public _setupNotificationsPanel(ConfigFrame configFrame, ConfigPanel panel)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "_setupNotificationsPanel",
                            "method_signature": "public _setupNotificationsPanel(ConfigFrame configFrame, ConfigPanel panel)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<String> oe)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<String> oe)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<String> oe)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<String> oe)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<String> oe)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public _setupNotificationsPanel(ConfigFrame configFrame, ConfigPanel panel)": {
                        "first": {
                            "method_name": "_setupNotificationsPanel",
                            "method_signature": "public _setupNotificationsPanel(ConfigFrame configFrame, ConfigPanel panel)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2667454408629822
                    },
                    "public optionChanged(OptionEvent<String> oe)": {
                        "first": {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<String> oe)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5954435657416713
                    }
                },
                "voyage": {
                    "public optionChanged(OptionEvent<String> oe)": {
                        "first": {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<String> oe)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.715134014353203
                    },
                    "public _setupNotificationsPanel(ConfigFrame configFrame, ConfigPanel panel)": {
                        "first": {
                            "method_name": "_setupNotificationsPanel",
                            "method_signature": "public _setupNotificationsPanel(ConfigFrame configFrame, ConfigPanel panel)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6941690470902986
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public _setupNotificationsPanel(ConfigFrame configFrame, ConfigPanel panel)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)"
                    ],
                    "llm_response_time": 1374
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public _setupNotificationsPanel(ConfigFrame configFrame, ConfigPanel panel)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)"
                    ],
                    "llm_response_time": 1150
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public _setupNotificationsPanel(ConfigFrame configFrame, ConfigPanel panel)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)"
                    ],
                    "llm_response_time": 880
                },
                "voyage": {
                    "priority_method_names": [
                        "public _setupNotificationsPanel(ConfigFrame configFrame, ConfigPanel panel)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)"
                    ],
                    "llm_response_time": 1518
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public _setupNotificationsPanel(ConfigFrame configFrame, ConfigPanel panel)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)"
                    ],
                    "llm_response_time": 1127
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)",
                        "public optionChanged(OptionEvent<String> oe)"
                    ],
                    "llm_response_time": 1019
                }
            },
            "targetClassMap": {
                "_setupNotificationsPanel": {
                    "target_classes": [
                        {
                            "class_name": "ConfigFrame",
                            "similarity_score": 0.5080026514326484
                        },
                        {
                            "class_name": "ConfigPanel",
                            "similarity_score": 0.22769341298801588
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ConfigPanel",
                        "ConfigFrame"
                    ],
                    "llm_response_time": 4118,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                },
                "optionChanged": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 0,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method edu.rice.cs.drjava.model.TestDocGetter::testConstructOneDocWithoutLineNums():void need move to edu.rice.cs.drjava.model.compiler.CompilerErrorModelTest",
        "class_name": "edu.rice.cs.drjava.model.TestDocGetter",
        "telemetry": {
            "id": "872ce86b-eebc-4c04-b7aa-e43c4d59efe7",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 84,
                "lineStart": 58,
                "lineEnd": 141,
                "bodyLineStart": 58,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/drjava/large/big/drjava-stable-20100913-r5387/src/src/edu/rice/cs/drjava/model/TestDocGetter.java",
                "sourceCode": "/** Test implementation of the document fetching methods in the GlobalModel interface. */\npublic class TestDocGetter extends DummyGlobalModel {\n  \n  /** Storage for documents and File keys. */\n  HashMap<File, OpenDefinitionsDocument> docs;\n\n  /** Convenience constructor for no-documents case. */\n  public TestDocGetter() { this(new File[0], new String[0]); }\n\n  /** Primary constructor, builds OpenDefDocs from Strings.\n   *  @param files the keys to use when getting OpenDefDocs\n   *  @param texts the text to put in the OpenDefDocs\n   */\n  public TestDocGetter(File[] files, String[] texts) {\n    if (files.length != texts.length) {\n      throw new IllegalArgumentException(\"Argument arrays must match in size.\");\n    }\n\n    docs = new HashMap<File, OpenDefinitionsDocument>(texts.length * 2);\n\n    GlobalEventNotifier en = new GlobalEventNotifier();\n    for (int i = 0; i < texts.length; i++) {\n      DefinitionsDocument doc = new DefinitionsDocument(en);\n      OpenDefinitionsDocument odoc = new TestOpenDoc(doc);\n      odoc.setFile(files[i]);\n      try { doc.insertString(0, texts[i], null); }\n      catch (BadLocationException e) { throw new UnexpectedException(e); }\n      docs.put(files[i], odoc);\n    }\n  }\n\n  public OpenDefinitionsDocument getDocumentForFile(File file)\n    throws IOException {\n    // Try to find the key in docs.\n    if (docs.containsKey(file)) return docs.get(file);\n    else throw new IllegalStateException(\"TestDocGetter can't open new files!\");\n  }\n  \n  public List<OpenDefinitionsDocument> getOpenDefinitionsDocuments() {\n    return new ArrayList<OpenDefinitionsDocument>(docs.values());\n  }\n\n  /** Tests CompilerErrorModel setup code with one file and only errors without line numbers. \n * @param compilerErrorModelTest TODO*/\n  public void testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest) {\n    compilerErrorModelTest.setupDoc();\n    compilerErrorModelTest.errors = new DJError[] { \n      new DJError(compilerErrorModelTest.files[0], \"Test error with File\", false),\n      new DJError(compilerErrorModelTest.files[0], \"Test warning with File\", true),\n      new DJError(compilerErrorModelTest.files[0], \"Test error with File\", false) \n    };\n    \n    DJError[] copy = new DJError[compilerErrorModelTest.errors.length];\n    for (int i = 0; i < compilerErrorModelTest.errors.length; i++)  copy[i] = compilerErrorModelTest.errors[i];\n    compilerErrorModelTest.model = new CompilerErrorModel(copy, this);\n    Utilities.clearEventQueue();  // constructor for CompilerErrorModel calls invokeLater\n    \n    // We successfully built the model, now test the basics.\n    Assert.assertEquals(\"Should have 3 compiler errors.\", 3, compilerErrorModelTest.model.getNumErrors());\n    Assert.assertEquals(\"Should have 1 warning\" , 1, compilerErrorModelTest.model.getNumWarnings());\n    Assert.assertEquals(\"Should have 2 compiler errors\" , 2, compilerErrorModelTest.model.getNumCompErrors());\n    Assert.assertEquals(\"Errors should be sorted.\", compilerErrorModelTest.errors[1], compilerErrorModelTest.model.getError(2));\n    Assert.assertTrue(\"hasOnlyWarnings should return false.\", !compilerErrorModelTest.model.hasOnlyWarnings());\n  }\n\n/** Test implementation of OpenDefinitionsDocument interface. */\n  private static class TestOpenDoc extends DummyOpenDefDoc {\n    DefinitionsDocument _doc;\n    File _file;\n    TestOpenDoc(DefinitionsDocument d) {\n      _doc = d;\n      _defDoc = d;\n      _file = FileOps.NULL_FILE;\n    }\n\n    /** This is the only method that we care about. */\n    public DefinitionsDocument getDocument() { return _doc; }\n\n    /** Okay, I lied.  We need this one, too. */\n    public File getFile() throws FileMovedException  { return _file; }\n    \n    public void setFile(File f) { _file = f; }\n  }\n}",
                "methodCount": 9
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 99,
                        "lineEnd": 120,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method testConstructOneDocWithoutLineNums to class CompilerErrorModelTest",
                        "description": "Move method testConstructOneDocWithoutLineNums to edu.rice.cs.drjava.model.compiler.CompilerErrorModelTest\nRationale: The method testConstructOneDocWithoutLineNums is a test case specifically designed to validate the behavior of the CompilerErrorModel when it is constructed with a single document containing errors without line numbers. Since the method directly interacts with the CompilerErrorModel and is part of the testing suite for that model, it logically belongs in the CompilerErrorModelTest class. Moving it to this class will enhance the organization of test cases, ensuring that all tests related to CompilerErrorModel are contained within a single class, which improves maintainability and readability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "testConstructOneDocWithoutLineNums",
                            "method_signature": "public void testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest)",
                            "target_class": "CompilerErrorModelTest",
                            "rationale": "The method testConstructOneDocWithoutLineNums is primarily testing the behavior of the CompilerErrorModelTest class. It should be moved to that class to maintain a clear separation of concerns and to keep the test logic close to the class it is testing."
                        }
                    ],
                    "llm_response_time": 2638
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "testConstructOneDocWithoutLineNums",
                            "method_signature": "public void testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest)",
                            "target_class": "CompilerErrorModelTest",
                            "rationale": "The method testConstructOneDocWithoutLineNums is primarily testing the behavior of the CompilerErrorModelTest class. It should be moved there to maintain a clear separation of concerns and to keep the test logic within the class that it is testing."
                        }
                    ],
                    "llm_response_time": 1965
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "testConstructOneDocWithoutLineNums",
                            "method_signature": "public void testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest)",
                            "target_class": "CompilerErrorModelTest",
                            "rationale": "The method testConstructOneDocWithoutLineNums is primarily testing the behavior of the CompilerErrorModelTest class. It should be moved there to maintain a clear separation of concerns and to keep the test logic within the class that it is testing."
                        }
                    ],
                    "llm_response_time": 2197
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "testConstructOneDocWithoutLineNums",
                            "method_signature": "public testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "testConstructOneDocWithoutLineNums",
                            "method_signature": "public testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest)": {
                        "first": {
                            "method_name": "testConstructOneDocWithoutLineNums",
                            "method_signature": "public testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4222936708681072
                    }
                },
                "voyage": {
                    "public testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest)": {
                        "first": {
                            "method_name": "testConstructOneDocWithoutLineNums",
                            "method_signature": "public testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5457312275303713
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest)"
                    ],
                    "llm_response_time": 550
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest)"
                    ],
                    "llm_response_time": 0
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest)"
                    ],
                    "llm_response_time": 0
                },
                "voyage": {
                    "priority_method_names": [
                        "public testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest)"
                    ],
                    "llm_response_time": 0
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest)"
                    ],
                    "llm_response_time": 0
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public testConstructOneDocWithoutLineNums(CompilerErrorModelTest compilerErrorModelTest)"
                    ],
                    "llm_response_time": 0
                }
            },
            "targetClassMap": {
                "testConstructOneDocWithoutLineNums": {
                    "target_classes": [
                        {
                            "class_name": "CompilerErrorModelTest",
                            "similarity_score": 0.7699124606004802
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CompilerErrorModelTest"
                    ],
                    "llm_response_time": 2495,
                    "similarity_computation_time": 8,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method edu.rice.cs.drjava.ui.MainFrame::testNE():void need move to edu.rice.cs.drjava.CommandLineTest",
        "class_name": "edu.rice.cs.drjava.ui.MainFrame",
        "telemetry": {
            "id": "83c52380-1588-4a6e-ad79-1a19e946eae7",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 10408,
                "lineStart": 119,
                "lineEnd": 10526,
                "bodyLineStart": 119,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/drjava/large/big/drjava-stable-20100913-r5387/src/src/edu/rice/cs/drjava/ui/MainFrame.java",
                "sourceCode": "/** DrJava's main window. */\npublic class MainFrame extends SwingFrame implements ClipboardOwner, DropTargetListener {\n  private final static edu.rice.cs.util.Log _log = new edu.rice.cs.util.Log(\"MainFrame.txt\", false);\n  \n  private static final int INTERACTIONS_TAB = 0;\n  private static final int CONSOLE_TAB = 1;\n  private static final String ICON_PATH = \"/edu/rice/cs/drjava/ui/icons/\";\n  public static final String DEBUGGER_OUT_OF_SYNC =\n    \" Current document is out of sync with the debugger and should be recompiled!\";\n  \n  /** Number of milliseconds to wait before displaying \"Stepping...\" message after a step is requested in \n    * the debugger.\n    */\n  private static final int DEBUG_STEP_TIMER_VALUE = 2000;\n  \n  // ------ Field Declarations -------\n  \n  /** The model which controls all logic in DrJava. */\n  private volatile AbstractGlobalModel _model;\n  \n  /** The main model listener attached by the main frame to the global model */\n  private volatile ModelListener _mainListener; \n  \n  /** Maps an OpenDefDoc to its JScrollPane.  Why doesn't OpenDefDoc contain a defScrollPane field? */\n  private HashMap<OpenDefinitionsDocument, JScrollPane> _defScrollPanes;\n  \n  /** The currently displayed DefinitionsPane. */\n  private volatile DefinitionsPane _currentDefPane;\n  \n  /** The currently displayed DefinitionsDocument. */\n  private volatile DefinitionsDocument _currentDefDoc;\n  \n  /** The filename currently being displayed. */\n  private volatile String _fileTitle = \"\";\n  \n  // Tabbed panel fields\n  public final LinkedList<TabbedPanel>  _tabs = new LinkedList<TabbedPanel>();\n  public final JTabbedPane _tabbedPane = new JTabbedPane();\n  private final LinkedList<Pair<FindResultsPanel, Map<MovingDocumentRegion, HighlightManager.HighlightInfo>>> \n    _findResults = new LinkedList<Pair<FindResultsPanel, Map<MovingDocumentRegion, HighlightManager.HighlightInfo>>>();\n  \n  // The following three fields are conceptually final, but were downgraded to volatile to allow initialization in\n  // the event thread;\n  private volatile DetachedFrame _tabbedPanesFrame;\n  public volatile Component _lastFocusOwner;\n  \n  private volatile CompilerErrorPanel _compilerErrorPanel;\n  private volatile JUnitPanel _junitPanel;\n  private volatile JavadocErrorPanel _javadocErrorPanel;\n  private volatile FindReplacePanel _findReplace;\n  private volatile BreakpointsPanel _breakpointsPanel;\n  private volatile BookmarksPanel _bookmarksPanel;\n  public volatile DebugPanel _debugPanel;\n  \n  private volatile InteractionsPane _consolePane;\n  private volatile JScrollPane _consoleScroll;            // redirects focus to embedded _consolePane\n  private volatile ConsoleController _consoleController;  \n  \n  private volatile InteractionsPane _interactionsPane;\n  private volatile JPanel _interactionsContainer;         // redirects focus to embedded _interactionsPane\n  private volatile InteractionsController _interactionsController;\n  private volatile InteractionsScriptController _interactionsScriptController;\n  private volatile InteractionsScriptPane _interactionsScriptPane;\n  \n  private volatile boolean _showDebugger;  // whether the supporting context is debugger capable\n  \n  \n  private volatile DetachedFrame _debugFrame;\n  \n  /** Panel to hold both InteractionsPane and its sync message. */\n  \n  // Status bar fields\n  private final JPanel _statusBar = new JPanel(new BorderLayout()); //( layout );\n  private final JLabel _statusField = new JLabel();\n  private final JLabel _statusReport = new JLabel();  //(\"This is the text for the center message\");\n  private final JLabel _currLocationField = new JLabel();\n  private final PositionListener _posListener = new PositionListener();\n  \n  // Split panes for layout\n  private volatile JSplitPane _docSplitPane;\n  private volatile JSplitPane _debugSplitPane;\n  JSplitPane _mainSplit;\n  \n  // private Container _docCollectionWidget;\n  private volatile JButton _compileButton;\n  private volatile JButton _closeButton;\n  private volatile JButton _undoButton;\n  private volatile JButton _redoButton;\n  private volatile JButton _runButton;\n  private volatile JButton _junitButton;\n  private volatile JButton _errorsButton;\n  \n  private final JToolBar _toolBar = new JToolBar();\n  private final JFileChooser _interactionsHistoryChooser = new JFileChooser();\n  \n  // Menu fields\n  private final JMenuBar _menuBar = new MenuBar(this);\n  private volatile JMenu _fileMenu;\n  private volatile JMenu _editMenu;\n  private volatile JMenu _toolsMenu;\n  private volatile JMenu _projectMenu;\n  private volatile JMenu _languageLevelMenu;\n  private volatile JMenu _helpMenu;\n  \n  private volatile JMenu _debugMenu;\n  private volatile JMenuItem _debuggerEnabledMenuItem;\n  \n  // Popup menus\n  private JPopupMenu _interactionsPanePopupMenu;\n  private JPopupMenu _consolePanePopupMenu;\n  \n  // Cached frames and dialogs\n  private volatile ConfigFrame _configFrame;\n  private final HelpFrame _helpFrame = new HelpFrame();\n  private final QuickStartFrame _quickStartFrame = new QuickStartFrame();\n  private volatile AboutDialog _aboutDialog;\n  private volatile RecentDocFrame _recentDocFrame;    /** Holds/shows the history of documents for ctrl-tab. */\n  \n//  private ProjectPropertiesFrame _projectPropertiesFrame;\n  \n  /** Keeps track of the recent files list in the File menu. */\n  private volatile RecentFileManager _recentFileManager;\n  \n  /** Keeps track of the recent projects list in the Project menu */\n  private volatile RecentFileManager _recentProjectManager;\n  \n  private volatile File _currentProjFile;\n  \n  /** Timer to display \"Stepping...\" message if a step takes longer than a certain amount of time.  All accesses\n    * must be synchronized on it.\n    */\n  private volatile Timer _debugStepTimer;\n  \n  /** Timer to step into another line of code. The delay for each step is recorded in milliseconds. */\n  private volatile Timer _automaticTraceTimer;\n  \n  /** The current highlight displaying the current location, used for FindAll and the of the debugger's thread,\n    * if there is one.  If there is none, this is null.\n    */\n  private volatile HighlightManager.HighlightInfo _currentLocationHighlight = null;\n  \n  /** Table to map breakpoints to their corresponding highlight objects. */\n  private final IdentityHashMap<Breakpoint, HighlightManager.HighlightInfo> _documentBreakpointHighlights =\n    new IdentityHashMap<Breakpoint, HighlightManager.HighlightInfo>();\n  \n  /** Table to map bookmarks to their corresponding highlight objects. */\n  private final IdentityHashMap<OrderedDocumentRegion, HighlightManager.HighlightInfo> _documentBookmarkHighlights =\n    new IdentityHashMap<OrderedDocumentRegion, HighlightManager.HighlightInfo>();\n  \n  /** The timestamp for the last change to any document. */\n  private volatile long _lastChangeTime = 0;\n  \n  /** Whether to display a prompt message before quitting. */\n  private volatile boolean _promptBeforeQuit;\n  \n  /** Listener for Interactions JVM */\n  volatile private ConfigOptionListeners.SlaveJVMXMXListener _slaveJvmXmxListener;\n  \n  /** Listener for Main JVM */\n  volatile private ConfigOptionListeners.MasterJVMXMXListener _masterJvmXmxListener;\n  \n  /** GUI component availability notifier. */\n  final DefaultGUIAvailabilityNotifier _guiAvailabilityNotifier = new DefaultGUIAvailabilityNotifier();\n  \n  /** Window adapter for \"pseudo-modal\" dialogs, i.e. non-modal dialogs that insist on keeping the focus. */\n  protected java.util.HashMap<Window,WindowAdapter> _modalWindowAdapters \n    = new java.util.HashMap<Window,WindowAdapter>();\n  \n  /** The owner of the modal window listener has already been taken by another window. */\n  protected volatile Window _modalWindowAdapterOwner = null;\n  \n  /** For opening files.  We have a persistent dialog to keep track of the last directory from which we opened. */\n  private volatile JFileChooser _openChooser;\n  \n  /** For opening project files. */\n  private volatile JFileChooser _openProjectChooser;\n  \n  /** For saving files. We have a persistent dialog to keep track of the last directory from which we saved. */\n  private volatile JFileChooser _saveChooser;\n  \n  /** Filter for source files (.java and .dj?). */\n  private final javax.swing.filechooser.FileFilter _javaSourceFilter = new SmartSourceFilter();\n  \n  /** Filter for source files (.java and .dj?). */\n  private final javax.swing.filechooser.FileFilter _unfilteredJavaSourceFilter = new JavaSourceFilter();\n  \n  /** Filter for drjava project files (.drjava and .xml and .pjt) */\n  private final javax.swing.filechooser.FileFilter _projectFilter = new javax.swing.filechooser.FileFilter() {\n    public boolean accept(File f) {\n      return f.isDirectory() || \n        f.getPath().endsWith(PROJECT_FILE_EXTENSION) ||\n        f.getPath().endsWith(PROJECT_FILE_EXTENSION2) ||\n        f.getPath().endsWith(OLD_PROJECT_FILE_EXTENSION);\n    }\n    public String getDescription() { \n      return \"DrJava Project Files (*\" + PROJECT_FILE_EXTENSION + \", *\" + PROJECT_FILE_EXTENSION2 + \", *\" + \n        OLD_PROJECT_FILE_EXTENSION + \")\";\n    }\n  };\n  \n  /** Filter for text files (.txt) */\n  private final javax.swing.filechooser.FileFilter _txtFileFilter = new javax.swing.filechooser.FileFilter() {\n    public boolean accept(File f) {\n      return f.isDirectory() || \n        f.getPath().endsWith(TEXT_FILE_EXTENSION);\n    }\n    public String getDescription() { \n      return \"Text Files (*\"+TEXT_FILE_EXTENSION+\")\";\n    }\n  };\n  \n  /** Filter for any files (*.*) */\n  private final javax.swing.filechooser.FileFilter _anyFileFilter = new javax.swing.filechooser.FileFilter() {\n    public boolean accept(File f) { return true; }\n    public String getDescription() { return \"All files (*.*)\"; }\n  };\n  \n  \n  /** Thread pool for executing asynchronous tasks. */\n  private ExecutorService _threadPool = Executors.newCachedThreadPool();\n  \n  // ------ End Field Declarations ------\n  \n  /** Returns the files to open to the model (command pattern). */\n  private final FileOpenSelector _openSelector = new FileOpenSelector() {\n    public File[] getFiles() throws OperationCanceledException {\n      //_openChooser.removeChoosableFileFilter(_projectFilter);\n      _openChooser.resetChoosableFileFilters();\n      \n      _openChooser.addChoosableFileFilter(_unfilteredJavaSourceFilter);\n      _openChooser.setFileFilter(_javaSourceFilter);\n      return getOpenFiles(_openChooser);\n    }\n  };\n  \n  /** Returns the files to open to the model (command pattern). */\n  private final FileOpenSelector _openFileOrProjectSelector = new FileOpenSelector() {\n    public File[] getFiles() throws OperationCanceledException {\n      //_openChooser.removeChoosableFileFilter(_projectFilter);\n      _openChooser.resetChoosableFileFilters();\n      \n      _openChooser.addChoosableFileFilter(_unfilteredJavaSourceFilter);\n      _openChooser.addChoosableFileFilter(_projectFilter);\n      _openChooser.setFileFilter(_javaSourceFilter);\n      return getOpenFiles(_openChooser);\n    }\n  };\n  \n  /** Returns the project file to open. */\n  private final FileOpenSelector _openProjectSelector = new FileOpenSelector() {\n    public File[] getFiles() throws OperationCanceledException {\n      File[] retFiles = getOpenFiles(_openProjectChooser);\n      return retFiles;\n    }\n  };\n  \n  /** Returns the files to open. */\n  private final FileOpenSelector _openAnyFileSelector = new FileOpenSelector() {\n    public File[] getFiles() throws OperationCanceledException {\n      _openChooser.resetChoosableFileFilters();\n      _openChooser.setFileFilter(_anyFileFilter);\n      return getOpenFiles(_openChooser);\n    }\n  };\n\n  /** @return possibly renamed file, if it used an old LL extension and the user wanted it. */\n  private File proposeBetterFileName(File f) {\n    if (DrJavaFileUtils.isOldLLFile(f) && DrJava.getConfig().getSetting(PROMPT_RENAME_LL_FILES)) {\n      File newFile = DrJavaFileUtils.getNewLLForOldLLFile(f);\n      String newExt = DrJavaFileUtils.getExtension(newFile.getName());\n      return proposeToChangeExtension(this,\n                                      f,\n                                      \"Change Extension?\",\n                                      f.getPath() + \"\\nThis file still has an old Language Level extension.\"\n                                        + \"\\nDo you want to change the file's extension to \\\"\"\n                                        + newExt + \"\\\"?\",\n                                      \"Change to \\\"\" + newExt + \"\\\"\",\n                                      \"Keep \\\"\" + DrJavaFileUtils.getExtension(f.getName()) + \"\\\"\",\n                                      newExt);\n    }\n    else return f;\n  }\n  \n  /** Returns the file to save to the model (command pattern).  */\n  private final FileSaveSelector _saveSelector = new FileSaveSelector() {\n    public File getFile() throws OperationCanceledException {\n      return proposeBetterFileName(getSaveFile(_saveChooser));\n    }\n    public boolean warnFileOpen(File f) { return _warnFileOpen(f); }\n    public boolean verifyOverwrite(File f) { return MainFrameStatics.verifyOverwrite(MainFrame.this, f); }\n    public boolean shouldSaveAfterFileMoved(OpenDefinitionsDocument doc, File oldFile) {\n      _model.setActiveDocument(doc);\n      String text = \"File \" + oldFile.getAbsolutePath() +\n        \"\\ncould not be found on disk!  It was probably moved\\n\" +\n        \"or deleted.  Would you like to save it in a new file?\";\n      int rc = JOptionPane.showConfirmDialog(MainFrame.this, text, \"File Moved or Deleted\", JOptionPane.YES_NO_OPTION);\n      return (rc == JOptionPane.YES_OPTION);\n    }\n    public boolean shouldUpdateDocumentState() { return true; }\n  };\n  \n  /** Returns the file to save to the model (command pattern). */\n  private final FileSaveSelector _saveAsSelector = new FileSaveSelector() {\n    public File getFile() throws OperationCanceledException {\n      return proposeBetterFileName(getSaveFile(_saveChooser));\n    }\n    public boolean warnFileOpen(File f) { return _warnFileOpen(f); }\n    public boolean verifyOverwrite(File f) { return MainFrameStatics.verifyOverwrite(MainFrame.this, f); }\n    public boolean shouldSaveAfterFileMoved(OpenDefinitionsDocument doc, File oldFile) { return true; }\n    public boolean shouldUpdateDocumentState() { return true; }\n  };\n  \n  /** Returns the file to save to the model (command pattern) without updating the document state. */\n  private final FileSaveSelector _saveCopySelector = new FileSaveSelector() {\n    public File getFile() throws OperationCanceledException {\n      return proposeBetterFileName(getSaveFile(_saveChooser));\n    }\n    public boolean warnFileOpen(File f) { return _warnFileOpen(f); }\n    public boolean verifyOverwrite(File f) { return MainFrameStatics.verifyOverwrite(MainFrame.this, f); }\n    public boolean shouldSaveAfterFileMoved(OpenDefinitionsDocument doc, File oldFile) { return true; }\n    public boolean shouldUpdateDocumentState() { return false; }\n  };\n  \n  /** Provides the view's contribution to the Javadoc interaction. */\n  private final JavadocDialog _javadocSelector = new JavadocDialog(this);\n  \n  /** Provides a chooser to open a directory */  \n  private DirectoryChooser _folderChooser;\n  private final JCheckBox _openRecursiveCheckBox = new JCheckBox(\"Open folders recursively\");\n  \n  private final Action _moveToAuxiliaryAction = new AbstractAction(\"Include With Project\") {\n    { /* initalization block */\n      String msg = \n      \"<html>Open this document each time this project is opened.<br>\"+\n      \"This file would then be compiled and tested with the<br>\"+\n      \"rest of the project.</html>\";\n      putValue(Action.LONG_DESCRIPTION, msg);\n    }\n    public void actionPerformed(ActionEvent ae) { _moveToAuxiliary(); }\n  };\n  private final Action _removeAuxiliaryAction = new AbstractAction(\"Do Not Include With Project\") {\n    { putValue(Action.LONG_DESCRIPTION, \"Do not open this document next time this project is opened.\"); }\n    public void actionPerformed(ActionEvent ae) { _removeAuxiliary(); }\n  };\n  private final Action _moveAllToAuxiliaryAction = new AbstractAction(\"Include All With Project\") {\n    { /* initalization block */\n      String msg = \n      \"<html>Open these documents each time this project is opened.<br>\"+\n      \"These files would then be compiled and tested with the<br>\"+\n      \"rest of the project.</html>\";\n      putValue(Action.LONG_DESCRIPTION, msg);\n    }\n    public void actionPerformed(ActionEvent ae) { _moveAllToAuxiliary(); }\n  };\n  \n  private final Action _removeAllAuxiliaryAction = new AbstractAction(\"Do Not Include Any With Project\") {\n    { putValue(Action.LONG_DESCRIPTION, \"Do not open these documents next time this project is opened.\"); }\n    public void actionPerformed(ActionEvent ae) { _removeAllAuxiliary(); }\n  };\n  \n  /** Creates a new blank document and select it in the definitions pane. */\n  private final Action _newAction = new AbstractAction(\"New\") {\n    public void actionPerformed(ActionEvent ae) {\n      _new();\n    }\n  };\n  \n  \n  //newclass addition\n  /** Creates a new Java class file. */\n  private final Action _newClassAction = new AbstractAction(\"New Java Class...\") {\n    public void actionPerformed(ActionEvent ae) {         \n      _newJavaClass();\n    }\n  };\n  \n  //newclass addition\n  public void _newJavaClass(){\n    NewJavaClassDialog njc = new NewJavaClassDialog(this);\n    njc.setVisible(true);\n  }\n  \n  private final Action _newProjectAction = new AbstractAction(\"New\") {\n    { putValue(Action.SHORT_DESCRIPTION, \"New DrJava project\"); }\n    public void actionPerformed(ActionEvent ae) { _newProject(); }\n  };\n  \n  private volatile AbstractAction _runProjectAction = new AbstractAction(\"Run Main Class of Project\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.PROJECT,\n                                 GUIAvailabilityListener.ComponentType.PROJECT_MAIN_CLASS,\n                                 GUIAvailabilityListener.ComponentType.COMPILER,\n                                 GUIAvailabilityListener.ComponentType.INTERACTIONS); }\n    public void actionPerformed(ActionEvent ae) { _runProject(); }\n  };\n  \n  /** The jar options dialog. */\n  private volatile JarOptionsDialog _jarOptionsDialog;\n  \n  /** Initializes the \"Create Jar from Project\" dialog. */\n  private void initJarOptionsDialog() {\n    if (DrJava.getConfig().getSetting(DIALOG_JAROPTIONS_STORE_POSITION).booleanValue())\n      _jarOptionsDialog.setFrameState(DrJava.getConfig().getSetting(DIALOG_JAROPTIONS_STATE));  \n  }\n  \n  /** Reset the position of the \"Create Jar from Project\" dialog. */\n  public void resetJarOptionsDialogPosition() {\n    _jarOptionsDialog.setFrameState(\"default\");\n    if (DrJava.getConfig().getSetting(DIALOG_JAROPTIONS_STORE_POSITION).booleanValue()) {\n      DrJava.getConfig().setSetting(DIALOG_JAROPTIONS_STATE, \"default\");\n    }\n  }\n  private final Action _jarProjectAction = new AbstractAction(\"Create Jar File from Project...\") {\n    { _addGUIAvailabilityListener(this,\n                                  GUIAvailabilityListener.ComponentType.PROJECT,\n                                  GUIAvailabilityListener.ComponentType.COMPILER); }\n    public void actionPerformed(ActionEvent ae) { _jarOptionsDialog.setVisible(true); }\n  };\n  \n  /** Initializes the \"Tabbed Panes\" frame. */\n  private void initTabbedPanesFrame() {\n    if (DrJava.getConfig().getSetting(DIALOG_TABBEDPANES_STORE_POSITION).booleanValue()) {\n      _tabbedPanesFrame.setFrameState(DrJava.getConfig().getSetting(DIALOG_TABBEDPANES_STATE));  \n    }\n  }\n  \n  /** Reset the position of the \"Tabbed Panes\" dialog. */\n  public void resetTabbedPanesFrame() {\n    _tabbedPanesFrame.setFrameState(\"default\");\n    if (DrJava.getConfig().getSetting(DIALOG_TABBEDPANES_STORE_POSITION).booleanValue()) {\n      DrJava.getConfig().setSetting(DIALOG_TABBEDPANES_STATE, \"default\");\n    }\n  }\n  \n  /** Action that detaches the tabbed panes.  Only runs in the event thread. */\n  private final Action _detachTabbedPanesAction = new AbstractAction(\"Detach Tabbed Panes\") {\n    public void actionPerformed(ActionEvent ae) { \n      JMenuItem m = (JMenuItem)ae.getSource();\n      boolean b = m.isSelected();\n      _detachTabbedPanesMenuItem.setSelected(b);\n      DrJava.getConfig().setSetting(DETACH_TABBEDPANES, b);\n      _tabbedPanesFrame.setDisplayInFrame(b);\n    }\n  };\n  \n  // menu item (checkbox menu) for detaching the tabbed panes\n  private volatile JMenuItem _detachTabbedPanesMenuItem = null;\n  \n  /** Initializes the \"Debugger\" frame. */\n  private void initDebugFrame() {\n    if (_debugFrame == null) return; // debugger isn't used\n    if (DrJava.getConfig().getSetting(DIALOG_DEBUGFRAME_STORE_POSITION).booleanValue()) {\n      _debugFrame.setFrameState(DrJava.getConfig().getSetting(DIALOG_DEBUGFRAME_STATE));  \n    }\n  }\n  \n  /** Reset the position of the \"Debugger\" dialog. */\n  public void resetDebugFrame() {\n    if (_debugFrame == null) return; // debugger isn't used\n    _debugFrame.setFrameState(\"default\");\n    if (DrJava.getConfig().getSetting(DIALOG_DEBUGFRAME_STORE_POSITION).booleanValue()) {\n      DrJava.getConfig().setSetting(DIALOG_DEBUGFRAME_STATE, \"default\");\n    }\n  }\n  \n  /** Action that detaches the debugger pane.  Only runs in the event thread. */\n  private final Action _detachDebugFrameAction = new AbstractAction(\"Detach Debugger\") {\n    { _addGUIAvailabilityListener(this, GUIAvailabilityListener.ComponentType.DEBUGGER); }\n    public void actionPerformed(ActionEvent ae) { \n      if (_debugFrame == null) return; // debugger isn't used\n      JMenuItem m = (JMenuItem)ae.getSource();\n      boolean b = m.isSelected();\n      _detachDebugFrameMenuItem.setSelected(b);\n      DrJava.getConfig().setSetting(DETACH_DEBUGGER, b);\n      _debugFrame.setDisplayInFrame(b);\n    }\n  };\n  \n  // menu item (checkbox menu) for detaching the debugger pane\n  private volatile JMenuItem _detachDebugFrameMenuItem;\n  \n  /** Sets the document in the definitions pane to a new templated junit test class. */\n  private final Action _newJUnitTestAction = new AbstractAction(\"New JUnit Test Case...\") {\n    public void actionPerformed(ActionEvent ae) {\n      String testName = JOptionPane.showInputDialog(MainFrame.this,\n                                                    \"Please enter a name for the test class:\",\n                                                    \"New JUnit Test Case\",\n                                                    JOptionPane.QUESTION_MESSAGE);\n      if (testName != null) {\n        String ext;\n        for(int i = 0; i < OptionConstants.LANGUAGE_LEVEL_EXTENSIONS.length; i++) {\n          ext = OptionConstants.LANGUAGE_LEVEL_EXTENSIONS[i];\n          if (testName.endsWith(ext)) testName = testName.substring(0, testName.length() - ext.length());\n        }\n        // For now, don't include setUp and tearDown\n        _model.newTestCase(testName, false, false);\n      }\n    }\n  };\n  \n  /** Asks user for file name and and reads that file into the definitions pane. */\n  private final Action _openAction = new AbstractAction(\"Open...\") {\n    public void actionPerformed(ActionEvent ae) {\n      _open();\n      _findReplace.updateFirstDocInSearch();\n    }\n  };\n  \n  /** Asks user for directory name and and reads it's files (and subdirectories files, on request) to\n    * the definitions pane.\n    */\n  private final Action _openFolderAction  = new AbstractAction(\"Open Folder...\") {\n    public void actionPerformed(ActionEvent ae) { \n      _openFolder();\n      _findReplace.updateFirstDocInSearch();\n    }\n  };\n  \n  /** Asks user for file name and and reads that file into the definitions pane. */\n  private final Action _openFileOrProjectAction = new AbstractAction(\"Open...\") {\n    public void actionPerformed(ActionEvent ae) { \n      _openFileOrProject(); \n      _findReplace.updateFirstDocInSearch();\n    }\n  };\n  \n  /** Asks user for project file name and and reads the associated files into the file navigator (and places the first\n    * source file in the editor pane)\n    */\n  private final Action _openProjectAction = new AbstractAction(\"Open...\") {\n    { putValue(Action.SHORT_DESCRIPTION, \"Open DrJava project\"); }\n    public void actionPerformed(ActionEvent ae) { _openProject(); }\n  };\n  \n  private final Action _closeProjectAction = new AbstractAction(\"Close\") {\n    { _addGUIAvailabilityListener(this, GUIAvailabilityListener.ComponentType.PROJECT);\n      putValue(Action.SHORT_DESCRIPTION, \"Close DrJava project\"); }\n    public void actionPerformed(ActionEvent ae) { \n      closeProject();\n      _findReplace.updateFirstDocInSearch();\n    }\n  };\n  \n  \n  /** Closes the current active document, prompting to save if necessary. */\n  private final Action _closeAction = new AbstractAction(\"Close\") {\n    public void actionPerformed(ActionEvent ae) { \n      _close();\n      _findReplace.updateFirstDocInSearch();\n    }\n  };\n  \n  /** Closes all open documents, prompting to save if necessary. */\n  private final Action _closeAllAction = new AbstractAction(\"Close All\") {\n    public void actionPerformed(ActionEvent ae) { \n      _closeAll();\n      _findReplace.updateFirstDocInSearch();\n    }\n  };\n  \n  /** Closes all open documents, prompting to save if necessary. */\n  private final Action _closeFolderAction = new AbstractAction(\"Close Folder\") {\n    public void actionPerformed(ActionEvent ae) { \n      _closeFolder();\n      _findReplace.updateFirstDocInSearch();\n      // set the document currently visible in the definitions pane as active\n      // document in the document navigator\n      // this makes sure that something is selected in the navigator after the\n      // folder was closed\n      _model.getDocumentNavigator().selectDocument(_currentDefPane.getOpenDefDocument());\n    }\n  };\n  \n  /** Opens all the files in the current folder. */\n  private final Action _openAllFolderAction = new AbstractAction(\"Open All Files\") {\n    public void actionPerformed(ActionEvent ae) {\n      // now works with multiple selected folders\n      List<File> l= _model.getDocumentNavigator().getSelectedFolders();\n      for(File f: l) {\n        File fAbs = new File(_model.getProjectRoot(), f.toString());\n        _openFolder(fAbs, false);  \n      }\n      \n      // The following does not apply anymore:\n      // Get the Folder that was clicked on by the user. When the user clicks on a directory component in the \n      // navigation pane, the current directory is updated in the openChooser JFileChooser component.  So the \n      // clicked on directory is obtained in this way\n      // File dir = _openChooser.getCurrentDirectory();\n      // _openFolder(dir, false);  \n      _findReplace.updateFirstDocInSearch();\n    }\n  };\n  \n  /** Opens a files in the current folder. */\n  private final Action _openOneFolderAction = new AbstractAction(\"Open File in Folder\") {\n    public void actionPerformed(ActionEvent ae)  { \n      _open();\n      _findReplace.updateFirstDocInSearch();\n    }\n  };\n  \n  /** Creates a new untitled, empty file in the current folder. */\n  public final Action _newFileFolderAction = new AbstractAction(\"Create New File in Folder\") {\n    public void actionPerformed(ActionEvent ae)  {\n      //make this new document the document in the document pane\n      _new();\n      _findReplace.updateFirstDocInSearch();\n    }\n  };\n  \n  /** Tests all the files in a folder. */\n  private volatile AbstractAction _junitFolderAction = new AbstractAction(\"Test Folder\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.JUNIT,\n                                 GUIAvailabilityListener.ComponentType.COMPILER,\n                                 GUIAvailabilityListener.ComponentType.INTERACTIONS); }\n    public final void actionPerformed(ActionEvent ae) { _junitFolder(); }\n  };\n  \n  /** Saves the current document. */\n  public final Action _saveAction = new AbstractAction(\"Save\") {\n    public final void actionPerformed(ActionEvent ae) { _save(); }\n  };\n  \n  /** Returns the changed status of the MainFrame. */\n  public long getLastChangeTime() { return _lastChangeTime; }\n  \n  /** Ensures that pack() is run in the event thread. Only used in test code */\n  public void pack() {\n    Utilities.invokeAndWait(new Runnable() { public void run() { packHelp(); } });\n  }\n  \n  /** Helper method that provides access to super.pack() within the anonymous class new Runnable() {...} above */\n  private void packHelp() { super.pack(); }\n  \n  /** Supports MainFrameTest.*/\n  public boolean isSaveEnabled() { return _saveAction.isEnabled(); }\n  \n  /** Asks the user for a file name and saves the active document (in the definitions pane) to that file. */\n  private final Action _saveAsAction = new AbstractAction(\"Save As...\") {\n    public void actionPerformed(ActionEvent ae) { _saveAs(); }\n  };\n  \n  /** Asks the user for a file name and saves a copy of the active document (in the definitions pane) to\n    * that file. DrJava's state is not modified (i.e. it does not set the document to 'unchanged'). */\n  private final Action _saveCopyAction = new AbstractAction(\"Save Copy...\") {\n    public void actionPerformed(ActionEvent ae) { _saveCopy(); }\n  };\n  \n  /** Asks the user for a file name and renames and saves the active document (in the definitions pane) to that file. */\n  private final Action _renameAction = new AbstractAction(\"Rename\") {\n    public void actionPerformed(ActionEvent ae) { _rename(); }\n  };  \n  \n  private final Action _saveProjectAction = new AbstractAction(\"Save\") {\n    { _addGUIAvailabilityListener(this, GUIAvailabilityListener.ComponentType.PROJECT); \n      putValue(Action.SHORT_DESCRIPTION, \"Save DrJava project\"); }\n    public void actionPerformed(ActionEvent ae) {\n      _saveAll();  // saves project file and all modified project source files; does not save external files\n    }\n  };\n  \n  private final Action _saveProjectAsAction = new AbstractAction(\"Save As...\") {\n    { _addGUIAvailabilityListener(this, GUIAvailabilityListener.ComponentType.PROJECT);\n      putValue(Action.SHORT_DESCRIPTION, \"Save DrJava project As\");\n      putValue(Action.LONG_DESCRIPTION, \"Save DrJava project under different name\"); }\n    public void actionPerformed(ActionEvent ae) {\n      if (_saveProjectAs()) {  // asks user for new project file name; sets _projectFile in global model to this value\n        _saveAll();  // performs saveAll operation using new project file name, assuming \"Save as\" was not cancelled\n      }\n    }\n  };\n  \n  private final Action _exportProjectInOldFormatAction = \n    new AbstractAction(\"Export Project In Old \\\"\" + OLD_PROJECT_FILE_EXTENSION + \"\\\" Format\") {\n    { _addGUIAvailabilityListener(this, GUIAvailabilityListener.ComponentType.PROJECT); }\n    public void actionPerformed(ActionEvent ae) {\n      File cpf = _currentProjFile;\n      _currentProjFile = FileOps.NULL_FILE;\n      if (_saveProjectAs()) {  // asks user for new project file name; sets _projectFile in global model to this value\n        _saveAllOld();  // performs saveAll operation using new project file name, assuming \"Save as\" was not cancelled\n      }\n      _currentProjFile = cpf;\n      _model.setProjectFile(cpf);\n      _recentProjectManager.updateOpenFiles(cpf);\n    }\n  };\n  \n  /** Reverts the current document. */\n  private final Action _revertAction = new AbstractAction(\"Revert to Saved\") {\n    public void actionPerformed(ActionEvent ae) {\n      String title = \"Revert to Saved?\";\n      \n      // update message to reflect the number of files\n      int count = _model.getDocumentNavigator().getDocumentSelectedCount();\n      String message;\n      if (count==1) {\n        message = \"Are you sure you want to revert the current \" +\n          \"file to the version on disk?\";\n      }\n      else {\n        message = \"Are you sure you want to revert the \" + count +\n          \" selected files to the versions on disk?\";\n      }\n      \n      int rc;\n      Object[] options = {\"Yes\", \"No\"};  \n      rc = JOptionPane.showOptionDialog(MainFrame.this, message, title, JOptionPane.YES_NO_OPTION,\n                                        JOptionPane.QUESTION_MESSAGE, null, options, options[1]);\n      if (rc == JOptionPane.YES_OPTION) {\n        _revert();\n      }\n    }\n  };\n  \n  /** Reverts all open documents.\n    * (not working yet)\n    private Action _revertAllAction = new AbstractAction(\"Revert All to Saved\") {\n    public void actionPerformed(ActionEvent ae) {\n    String title = \"Revert All to Saved?\";\n    \n    String message = \"Are you sure you want to revert all open \" +\n    \"files to the versions on disk?\";\n    \n    int rc = JOptionPane.showConfirmDialog(MainFrame.this,\n    message,\n    title,\n    JOptionPane.YES_NO_OPTION);\n    if (rc == JOptionPane.YES_OPTION) {\n    _revertAll();\n    }\n    }\n    };*/\n  \n  /** Saves all documents, prompting for file names as necessary. */\n  final Action _saveAllAction = new AbstractAction(\"Save All\") {\n    public void actionPerformed(ActionEvent ae) { _saveAll(); }\n  };\n  \n  /** Prints the current document. */\n  private final Action _printDefDocAction = new AbstractAction(\"Print...\") {\n    public void actionPerformed(ActionEvent ae) { _printDefDoc(); }\n  };\n  \n  /** Prints the console document. */\n  private final Action _printConsoleAction = new AbstractAction(\"Print Console...\") {\n    public void actionPerformed(ActionEvent ae) { _printConsole(); }\n  };\n  \n  /** Prints the interactions document. */\n  private final Action _printInteractionsAction = new AbstractAction(\"Print Interactions...\") {\n    public void actionPerformed(ActionEvent ae) { _printInteractions(); }\n  };\n  \n  /** Opens the print preview window. */\n  private final Action _printDefDocPreviewAction = new AbstractAction(\"Print Preview...\") {\n    public void actionPerformed(ActionEvent ae) { _printDefDocPreview(); }\n  };\n  \n  /** Opens the print preview window. */\n  private final Action _printConsolePreviewAction = new AbstractAction(\"Print Preview...\") {\n    public void actionPerformed(ActionEvent ae) { _printConsolePreview(); }\n  };\n  \n  /** Opens the print preview window. */\n  private final Action _printInteractionsPreviewAction = new AbstractAction(\"Print Preview...\") {\n    public void actionPerformed(ActionEvent ae) { _printInteractionsPreview(); }\n  };\n  \n  /** Opens the page setup window. */\n  private final Action _pageSetupAction = new AbstractAction(\"Page Setup...\") {\n    public void actionPerformed(ActionEvent ae) { _pageSetup(); }\n  };\n  \n  /** Compiles the document in the definitions pane. */\n  private final Action _compileAction = new AbstractAction(\"Compile Current Document\") {\n    public void actionPerformed(ActionEvent ae) { \n      if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) \n        _mainSplit.resetToPreferredSizes(); \n      updateStatusField(\"Compiling \" + _fileTitle);\n      _compile();\n      updateStatusField(\"Compilation of current document completed\");\n    }\n  };\n  \n  /** Compiles all the project. */\n  private volatile AbstractAction _compileProjectAction = new AbstractAction(\"Compile Project\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.PROJECT,\n                                 GUIAvailabilityListener.ComponentType.COMPILER); }\n    public void actionPerformed(ActionEvent ae) {\n      if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) \n        _mainSplit.resetToPreferredSizes();\n      updateStatusField(\"Compiling all source files in open project\");\n      _compileProject(); \n      _findReplace.updateFirstDocInSearch();\n      updateStatusField(\"Compilation of open project completed\");\n    }\n  };\n  \n  /** Compiles all documents in the navigators active group. */\n  private volatile AbstractAction _compileFolderAction = new AbstractAction(\"Compile Folder\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.COMPILER); }\n    public void actionPerformed(ActionEvent ae) { \n      if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) \n        _mainSplit.resetToPreferredSizes();\n      updateStatusField(\"Compiling all sources in current folder\");\n      _compileFolder();\n      _findReplace.updateFirstDocInSearch();\n      updateStatusField(\"Compilation of folder completed\");\n    }\n  };\n  \n  /** Compiles all open documents. */\n  private volatile AbstractAction _compileAllAction = new AbstractAction(\"Compile All Documents\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.COMPILER); }\n    public void actionPerformed(ActionEvent ae) {\n      if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) \n        _mainSplit.resetToPreferredSizes();\n      _compileAll();\n      _findReplace.updateFirstDocInSearch();\n    }\n  };\n  \n  /** cleans the build directory */\n  private volatile AbstractAction _cleanAction = new AbstractAction(\"Clean Build Directory\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.COMPILER,\n                                 GUIAvailabilityListener.ComponentType.PROJECT,\n                                 GUIAvailabilityListener.ComponentType.PROJECT_BUILD_DIR); }\n    public void actionPerformed(ActionEvent ae) { _clean(); }\n  };\n  \n  /** auto-refresh the project and open new files */\n  private volatile AbstractAction _autoRefreshAction = new AbstractAction(\"Auto-Refresh Project\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.PROJECT,\n                                 GUIAvailabilityListener.ComponentType.COMPILER); }\n    public void actionPerformed(ActionEvent ae) { _model.autoRefreshProject(); }\n  };\n  \n  /** Finds and runs the main method of the current document, if it exists. */\n  private volatile AbstractAction _runAction = new AbstractAction(\"Run Document's Main Method\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.COMPILER,\n                                 GUIAvailabilityListener.ComponentType.INTERACTIONS); }\n    public void actionPerformed(ActionEvent ae) { _runMain(); }\n  };\n  \n  /** Tries to run the current document as an applet. */\n  private volatile AbstractAction _runAppletAction = new AbstractAction(\"Run Document as Applet\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.COMPILER,\n                                 GUIAvailabilityListener.ComponentType.INTERACTIONS); }\n    public void actionPerformed(ActionEvent ae) { _runApplet(); }\n  };\n  \n  /** Runs JUnit on the document in the definitions pane. */\n  private volatile AbstractAction _junitAction = new AbstractAction(\"Test Current Document\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.JUNIT,\n                                 GUIAvailabilityListener.ComponentType.COMPILER,\n                                 GUIAvailabilityListener.ComponentType.INTERACTIONS); }\n    public void actionPerformed(ActionEvent ae) { \n      if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) _mainSplit.resetToPreferredSizes();\n      _junit(); \n    }\n  };\n  \n  /** Runs JUnit over all open JUnit tests. */\n  private volatile AbstractAction _junitAllAction = new AbstractAction(\"Test All Documents\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.JUNIT,\n                                 GUIAvailabilityListener.ComponentType.COMPILER,\n                                 GUIAvailabilityListener.ComponentType.INTERACTIONS); }\n    public void actionPerformed(ActionEvent e) {\n      if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) _mainSplit.resetToPreferredSizes();\n      _junitAll();\n      _findReplace.updateFirstDocInSearch();\n    }\n    \n  };\n  \n  /** Runs JUnit over all open JUnit tests in the project directory. */\n  private volatile AbstractAction _junitProjectAction = new AbstractAction(\"Test Project\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.PROJECT,\n                                 GUIAvailabilityListener.ComponentType.JUNIT,\n                                 GUIAvailabilityListener.ComponentType.COMPILER,\n                                 GUIAvailabilityListener.ComponentType.INTERACTIONS); }\n    public void actionPerformed(ActionEvent e) {\n      if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) _mainSplit.resetToPreferredSizes();\n      _junitProject();\n      _findReplace.updateFirstDocInSearch();\n    }\n  };\n  \n  /** Runs Javadoc on all open documents (and the files in their packages). */\n  private volatile AbstractAction _javadocAllAction = new AbstractAction(\"Javadoc All Documents\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.JAVADOC,\n                                 GUIAvailabilityListener.ComponentType.COMPILER); }\n    public void actionPerformed(ActionEvent ae) {\n      if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) \n        _mainSplit.resetToPreferredSizes();\n      try {\n        JavadocModel jm = _model.getJavadocModel();\n        File suggestedDir = jm.suggestJavadocDestination(_model.getActiveDocument());\n        _javadocSelector.setSuggestedDir(suggestedDir);\n        jm.javadocAll(_javadocSelector, _saveSelector);\n      }\n      catch (IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n    }\n  };\n  \n  /** Runs Javadoc on the current document. */\n  private volatile AbstractAction _javadocCurrentAction = new AbstractAction(\"Preview Javadoc for Current Document\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.JAVADOC,\n                                 GUIAvailabilityListener.ComponentType.COMPILER); }\n    public void actionPerformed(ActionEvent ae) {\n      if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) \n        _mainSplit.resetToPreferredSizes();\n      try {\n        _model.getActiveDocument().generateJavadoc(_saveSelector);\n      }\n      catch (IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n    }\n  };\n  \n  /** Default cut action.  Returns focus to the correct pane. */\n  final Action cutAction = new DefaultEditorKit.CutAction() {\n    public void actionPerformed(ActionEvent e) {\n      Component c = MainFrame.this.getFocusOwner();\n      super.actionPerformed(e);\n      if (_currentDefPane.hasFocus()) {\n        String s = Utilities.getClipboardSelection(c);\n        if (s != null && s.length() != 0) { ClipboardHistoryModel.singleton().put(s); }\n      }\n      if (c != null) c.requestFocusInWindow();\n    }\n  };\n  \n  /** Default copy action.  Returns focus to the correct pane. */\n  final Action copyAction = new DefaultEditorKit.CopyAction() {\n    public void actionPerformed(ActionEvent e) {\n      Component c = MainFrame.this.getFocusOwner();\n      super.actionPerformed(e);\n      if (_currentDefPane.hasFocus() && _currentDefPane.getSelectedText() != null) {\n        String s = Utilities.getClipboardSelection(c);\n        if (s != null && s.length() != 0) { ClipboardHistoryModel.singleton().put(s); }\n      }\n      if (c != null) c.requestFocusInWindow();\n    }\n  };\n  \n  /** We lost ownership of what we put in the clipboard. */\n  public void lostOwnership(Clipboard clipboard, Transferable contents) {\n    // ignore\n  }\n  \n  /** Default paste action.  Returns focus to the correct pane. */\n  final Action pasteAction = new DefaultEditorKit.PasteAction() {\n    public void actionPerformed(ActionEvent e) {\n      // remove unprintable characters before pasting\n      Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n      Transferable contents = clipboard.getContents(null);\n      if ((contents != null) && (contents.isDataFlavorSupported(DataFlavor.stringFlavor))) {\n        try {\n          String result = (String)contents.getTransferData(DataFlavor.stringFlavor);\n          StringBuilder sb = new StringBuilder();\n          for(int i = 0; i < result.length(); ++i) {\n            char ch = result.charAt(i);\n            if ((ch<32) && (ch!='\\n')) sb.append(' ');\n            else sb.append(ch);\n          }\n          StringSelection stringSelection = new StringSelection(sb.toString());\n          clipboard.setContents(stringSelection, stringSelection);\n        }\n        catch (UnsupportedFlavorException ex) { /* just keep it the same */ }\n        catch (IOException ex) { /* just keep it the same */ }\n      }\n      \n      Component c = MainFrame.this.getFocusOwner();\n      if (_currentDefPane.hasFocus()) {\n        _currentDefPane.endCompoundEdit();\n//        CompoundUndoManager undoMan = _model.getActiveDocument().getUndoManager(); // French keyboard fix\n//        int key = undoMan.startCompoundEdit();                                     // French keyboard fix\n        super.actionPerformed(e);\n        _currentDefPane.endCompoundEdit(); // replaced line below for French keyboard fix\n//        undoMan.endCompoundEdit(key);                                              // French keyboard fix\n      }\n      else if(_interactionsPane.hasFocus()){\n       _interactionsPane.endCompoundEdit();\n       super.actionPerformed(e);\n       _interactionsPane.endCompoundEdit();\n      }\n        \n        else super.actionPerformed(e);\n      \n      if (c != null) c.requestFocusInWindow();      \n    }\n  };\n  \n  /** Reset the position of the \"Clipboard History\" dialog. */\n  public void resetClipboardHistoryDialogPosition() {\n    if (DrJava.getConfig().getSetting(DIALOG_CLIPBOARD_HISTORY_STORE_POSITION).booleanValue()) {\n      DrJava.getConfig().setSetting(DIALOG_CLIPBOARD_HISTORY_STATE, \"default\");\n    }\n  }\n  \n  /** The \"Clipboard History\" dialog. */\n  private ClipboardHistoryFrame _clipboardHistoryDialog = null;\n  \n  /** Asks the user for a file name and goes there. */\n  private final Action _pasteHistoryAction = new AbstractAction(\"Paste from History...\") {\n    public void actionPerformed(final ActionEvent ae) {\n      final ClipboardHistoryFrame.CloseAction cancelAction = new ClipboardHistoryFrame.CloseAction() {\n        public Object value(String s) {\n          // \"Clipboard History\" dialog position and size.\n          if ((DrJava.getConfig().getSetting(DIALOG_CLIPBOARD_HISTORY_STORE_POSITION).booleanValue())\n                && (_clipboardHistoryDialog != null) && (_clipboardHistoryDialog.getFrameState() != null)) {\n            DrJava.getConfig().\n              setSetting(DIALOG_CLIPBOARD_HISTORY_STATE, (_clipboardHistoryDialog.getFrameState().toString()));\n          }\n          else {\n            // Reset to defaults to restore pristine behavior.\n            DrJava.getConfig().setSetting(DIALOG_CLIPBOARD_HISTORY_STATE, DIALOG_CLIPBOARD_HISTORY_STATE.getDefault());\n          }\n          return null;\n        }\n      };\n      ClipboardHistoryFrame.CloseAction okAction = new ClipboardHistoryFrame.CloseAction() {\n        public Object value(String s) {\n          cancelAction.value(null);\n          \n          StringSelection ssel = new StringSelection(s);\n          Clipboard cb = MainFrame.this.getToolkit().getSystemClipboard();\n          if (cb != null) {\n            cb.setContents(ssel, MainFrame.this);\n            pasteAction.actionPerformed(ae);\n          }\n          return null;\n        }\n      };\n      \n      _clipboardHistoryDialog = new ClipboardHistoryFrame(MainFrame.this, \n                                                          \"Clipboard History\", ClipboardHistoryModel.singleton(),\n                                                          okAction, cancelAction);\n      if (DrJava.getConfig().getSetting(DIALOG_CLIPBOARD_HISTORY_STORE_POSITION).booleanValue()) {\n        _clipboardHistoryDialog.setFrameState(DrJava.getConfig().getSetting(DIALOG_CLIPBOARD_HISTORY_STATE));\n      }\n      _clipboardHistoryDialog.setVisible(true);\n    }\n  };\n  \n  /** Copies whatever is currently in the interactions pane at the prompt to the definitions pane.  If the \n    * current string is empty, then it will attempt to return the last entry from the interactions pane's history.\n    */\n  private final Action _copyInteractionToDefinitionsAction =\n    new AbstractAction(\"Lift Current Interaction to Definitions\") {\n    public void actionPerformed(ActionEvent a) {\n      String text = _interactionsController.getDocument().getCurrentInput();\n      if (! text.equals(\"\")) {\n        _putTextIntoDefinitions(text + \"\\n\");\n        return;\n      }\n      try { text = _interactionsController.getDocument().lastEntry(); }\n      catch(Exception e) { return; } // no entry to promote\n      \n      //It is assumed that empty strings are not put into the history\n      _putTextIntoDefinitions(text + \"\\n\");\n      return;\n    }\n  };\n  \n  /** Action that copies the previous interaction to the definitions pane.\n    * Is there a good way to get the last history element without perturbing the current document?\n    Action copyPreviousInteractionToDefinitionsAction = new AbstractAction(\"Copy previous interaction to definitions\") {\n    public void actionPerformed(ActionEvent e) {\n    _putTextIntoDefinitions(_interactionsController.getDocument().getCurrentInput() + \"\\n\");\n    }\n    };*/\n  \n  \n  /** Undoes the last change to the active definitions document. */\n  private final DelegatingAction _undoAction = new DelegatingAction() {\n    public void actionPerformed(ActionEvent e) {\n      // use whether the delegatee is the Interactions Pane's action instead of whether\n      // _interactionsPane.hasFocus(), because the focus will be lost when the user clicks\n      // on the menu bar.\n      final boolean intPaneFocused = (getDelegatee()==_interactionsController.getUndoAction());\n      if (intPaneFocused) {\n        _interactionsPane.endCompoundEdit();\n      }\n      else {\n        _currentDefPane.endCompoundEdit();  \n      }\n      \n      super.actionPerformed(e);\n      \n      if (intPaneFocused) {\n        _interactionsPane.requestFocusInWindow();\n      }\n      else {\n        _currentDefPane.requestFocusInWindow();\n        \n        OpenDefinitionsDocument doc = _model.getActiveDocument();\n        _saveAction.setEnabled(doc.isModifiedSinceSave() || doc.isUntitled());\n      }\n    }\n  };\n  \n  /** Redoes the last undo to the active definitions document. */\n  private final DelegatingAction _redoAction = new DelegatingAction() {\n    public void actionPerformed(ActionEvent e) {\n      // use whether the delegatee is the Interactions Pane's action instead of whether\n      // _interactionsPane.hasFocus(), because the focus will be lost when the user clicks\n      // on the menu bar.\n      final boolean intPaneFocused = (getDelegatee()==_interactionsController.getRedoAction());\n      \n      super.actionPerformed(e);\n      if (intPaneFocused) {\n        _interactionsPane.requestFocusInWindow();\n      }\n      else {\n        _currentDefPane.requestFocusInWindow();\n        OpenDefinitionsDocument doc = _model.getActiveDocument();\n        _saveAction.setEnabled(doc.isModifiedSinceSave() || doc.isUntitled());\n      }\n    }\n  };\n  \n  /** Quits DrJava.  Optionally displays a prompt before quitting. */\n  private final Action _quitAction = new AbstractAction(\"Quit\") {\n    public void actionPerformed(ActionEvent ae) { quit(); }\n  };\n  \n  \n  /** Quits DrJava.  Optionally displays a prompt before quitting. */\n  private final Action _forceQuitAction = new AbstractAction(\"Force Quit\") {\n    public void actionPerformed(ActionEvent ae) { _forceQuit(); }\n  };\n  \n  /** Selects all text in window. */\n  private final Action _selectAllAction = new AbstractAction(\"Select All\") {\n    public void actionPerformed(ActionEvent ae) { _selectAll(); }\n  };\n  \n  /** Shows the find/replace tab in the interactions pane.  Only executes in the event thread. */\n  private void _showFindReplaceTab(boolean showDetachedWindow) {\n    if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) \n      _mainSplit.resetToPreferredSizes(); \n    final boolean wasDisplayed = isDisplayed(_findReplace);\n    showTab(_findReplace, showDetachedWindow);\n    if (!wasDisplayed) {\n      _findReplace.beginListeningTo(_currentDefPane);\n    }\n    _findReplace.setVisible(true);\n    _tabbedPane.setSelectedComponent(_findReplace);\n  }\n  \n  /** Action that shows the find/replace tab.  Only executes in the event thread. */\n  private final Action _findReplaceAction = new AbstractAction(\"Find/Replace\") {\n    public void actionPerformed(ActionEvent ae) {\n      _showFindReplaceTab(true);\n      _findReplace.requestFocusInWindow();\n      // Use EventQueue.invokeLater to ensure that focus is set AFTER the _findReplace tab has been selected\n      EventQueue.invokeLater(new Runnable() { public void run() { _findReplace.requestFocusInWindow(); } });\n    }\n  };\n  \n  /** Find the next instance of the find word. */\n  private final Action _findNextAction = new AbstractAction(\"Find Next\") {\n    public void actionPerformed(ActionEvent ae) {\n      _showFindReplaceTab(false);\n      if (!DrJava.getConfig().getSetting(FIND_REPLACE_FOCUS_IN_DEFPANE).booleanValue()) {\n        // Use EventQueue.invokeLater to ensure that focus is set AFTER the _findReplace tab has been selected\n        EventQueue.invokeLater(new Runnable() { public void run() { _findReplace.requestFocusInWindow(); } });\n      }\n      _findReplace.findNext();\n//      _currentDefPane.requestFocusInWindow();  \n      // atempt to fix intermittent bug where _currentDefPane listens but does not echo and won't undo!\n    }\n  };\n  \n  /** Does the find next in the opposite direction. If the direction is backward it searches forward. */\n  private final Action _findPrevAction = new AbstractAction(\"Find Previous\") {\n    public void actionPerformed(ActionEvent ae) {\n      _showFindReplaceTab(false);\n      if (!DrJava.getConfig().getSetting(FIND_REPLACE_FOCUS_IN_DEFPANE).booleanValue()) {\n        // Use EventQueue.invokeLater to ensure that focus is set AFTER the _findReplace tab has been selected\n        EventQueue.invokeLater(new Runnable() { public void run() { _findReplace.requestFocusInWindow(); } });\n      }\n      _findReplace._machine.findPrevious(_findReplace);\n      _currentDefPane.requestFocusInWindow();\n    }\n  };\n  \n  /** Asks the user for a line number and goes there. */\n  private final Action _gotoLineAction = new AbstractAction(\"Go to Line...\") {\n    public void actionPerformed(ActionEvent ae) {\n      int pos = _gotoLine();\n      _currentDefPane.requestFocusInWindow();\n      if (pos != -1) _currentDefPane.setCaretPosition(pos);  \n      // The preceding is a brute force attempt to fix intermittent failure to display caret\n    }\n  };\n  \n  /** Reset the position of the \"Go to File\" dialog. */\n  public void resetGotoFileDialogPosition() {\n    initGotoFileDialog();\n    _gotoFileDialog.setFrameState(\"default\");\n    if (DrJava.getConfig().getSetting(DIALOG_GOTOFILE_STORE_POSITION).booleanValue()) {\n      DrJava.getConfig().setSetting(DIALOG_GOTOFILE_STATE, \"default\");\n    }\n  }\n  \n  /** Initialize dialog if necessary. */\n  void initGotoFileDialog() {\n    if (_gotoFileDialog == null) {\n      PredictiveInputFrame.InfoSupplier<GoToFileListEntry> info = \n        new PredictiveInputFrame.InfoSupplier<GoToFileListEntry>() {\n        public String value(GoToFileListEntry entry) {\n          final StringBuilder sb = new StringBuilder();\n          \n          final OpenDefinitionsDocument doc = entry.getOpenDefinitionsDocument();\n          if (doc != null) {\n            try {\n              try { sb.append(FileOps.stringMakeRelativeTo(doc.getRawFile(), doc.getSourceRoot())); }\n              catch(IOException e) { sb.append(doc.getFile()); }\n            }\n            catch(edu.rice.cs.drjava.model.FileMovedException e) { sb.append(entry + \" was moved\"); }\n//            catch(java.lang.IllegalStateException e) { sb.append(entry); }\n            catch(InvalidPackageException e) { sb.append(entry); }\n          } \n          else sb.append(entry);\n          return sb.toString();\n        }\n      };\n      PredictiveInputFrame.CloseAction<GoToFileListEntry> okAction = \n        new PredictiveInputFrame.CloseAction<GoToFileListEntry>() {\n        public String getName() { return \"OK\"; }\n        public KeyStroke getKeyStroke() { return KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0); }\n        public String getToolTipText() { return null; }\n        public Object value(PredictiveInputFrame<GoToFileListEntry> p) {\n          if (p.getItem() != null) {\n            final OpenDefinitionsDocument newDoc = p.getItem().getOpenDefinitionsDocument();\n            if (newDoc != null) {\n              final boolean docChanged = ! newDoc.equals(_model.getActiveDocument());\n              final boolean docSwitch = _model.getActiveDocument() != newDoc;\n              if (docSwitch) _model.setActiveDocument(newDoc);\n              final int curLine = newDoc.getCurrentLine();\n              final String t = p.getText();\n              final int last = t.lastIndexOf(':');\n              if (last >= 0) {\n                try {\n                  String end = t.substring(last + 1);\n                  int val = Integer.parseInt(end);\n                  \n                  final int lineNum = Math.max(1, val);\n                  Runnable command = new Runnable() {\n                    public void run() {\n                      try { _jumpToLine(lineNum); }  // adds this region to browser history\n                      catch (RuntimeException e) { _jumpToLine(curLine); }\n                    }\n                  };\n                  if (docSwitch) {\n                    // postpone running command until after document switch, which is pending in the event queue\n                    EventQueue.invokeLater(command);\n                  }\n                  else command.run();\n                }\n                catch(RuntimeException e) { /* ignore */ }\n              }\n              else if (docChanged) {\n                // defer executing this code until after active document switch (if any) is complete\n                addToBrowserHistory();\n              }\n            }\n          }\n          hourglassOff();\n          return null;\n        }\n      };\n      PredictiveInputFrame.CloseAction<GoToFileListEntry> cancelAction = \n        new PredictiveInputFrame.CloseAction<GoToFileListEntry>() {\n        public String getName() { return \"Cancel\"; }\n        public KeyStroke getKeyStroke() { return KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0); }\n        public String getToolTipText() { return null; }\n        public Object value(PredictiveInputFrame<GoToFileListEntry> p) {\n          hourglassOff();\n          return null;\n        }\n      };\n      java.util.ArrayList<PredictiveInputModel.MatchingStrategy<GoToFileListEntry>> strategies =\n        new java.util.ArrayList<PredictiveInputModel.MatchingStrategy<GoToFileListEntry>>();\n      strategies.add(new PredictiveInputModel.FragmentLineNumStrategy<GoToFileListEntry>());\n      strategies.add(new PredictiveInputModel.PrefixLineNumStrategy<GoToFileListEntry>());\n      strategies.add(new PredictiveInputModel.RegExLineNumStrategy<GoToFileListEntry>());\n      List<PredictiveInputFrame.CloseAction<GoToFileListEntry>> actions\n        = new ArrayList<PredictiveInputFrame.CloseAction<GoToFileListEntry>>();\n      actions.add(okAction);\n      actions.add(cancelAction);\n      _gotoFileDialog = \n        new PredictiveInputFrame<GoToFileListEntry>(MainFrame.this,\n                                                    \"Go to File\",\n                                                    true, // force\n                                                    true, // ignore case\n                                                    info,\n                                                    strategies,\n                                                    actions, 1, // cancel is action 1\n                                                    new GoToFileListEntry(null, \"dummyGoto\")) {\n        public void setOwnerEnabled(boolean b) {\n          if (b) { hourglassOff(); } else { hourglassOn(); }\n        }\n      }; \n      // putting one dummy entry in the list; it will be changed later anyway\n      \n      if (DrJava.getConfig().getSetting(DIALOG_GOTOFILE_STORE_POSITION).booleanValue()) {\n        _gotoFileDialog.setFrameState(DrJava.getConfig().getSetting(DIALOG_GOTOFILE_STATE));\n      }      \n    }\n  }\n  \n  /** The \"Go to File\" dialog instance. */\n  volatile PredictiveInputFrame<GoToFileListEntry> _gotoFileDialog = null;\n  \n  /** Action implementing \"Go to file\" command, which asks the user for a file name and goes there. */\n  private final Action _gotoFileAction = new AbstractAction(\"Go to File...\") {\n    public void actionPerformed(ActionEvent ae) {\n      initGotoFileDialog();\n      List<OpenDefinitionsDocument> docs = _model.getOpenDefinitionsDocuments();\n      if (docs == null || docs.size() == 0) {\n        return; // do nothing\n      }\n      GoToFileListEntry currentEntry = null;\n      ArrayList<GoToFileListEntry> list;\n      if (DrJava.getConfig().getSetting(DIALOG_GOTOFILE_FULLY_QUALIFIED).booleanValue()) {\n        list = new ArrayList<GoToFileListEntry>(2 * docs.size());\n      }\n      else {\n        list = new ArrayList<GoToFileListEntry>(docs.size());\n      }\n      for(OpenDefinitionsDocument d: docs) {\n        GoToFileListEntry entry = new GoToFileListEntry(d, d.toString());\n        if (d.equals(_model.getActiveDocument())) currentEntry = entry;\n        list.add(entry);\n        if (DrJava.getConfig().getSetting(DIALOG_GOTOFILE_FULLY_QUALIFIED).booleanValue()) {\n          try {\n            try {\n              String relative = FileOps.stringMakeRelativeTo(d.getFile(), d.getSourceRoot());\n              if (!relative.equals(d.toString())) {\n                list.add(new GoToFileListEntry(d, d.getPackageName() + \".\" + d.toString()));\n              }\n            }\n            catch(IOException e) { /* ignore */ }\n            catch(edu.rice.cs.drjava.model.definitions.InvalidPackageException e) { /* ignore */ }\n          }\n          catch(IllegalStateException e) { /* ignore */ }\n        }\n      }\n      _gotoFileDialog.setItems(true, list); // ignore case\n      if (currentEntry != null) _gotoFileDialog.setCurrentItem(currentEntry);\n      hourglassOn();   // Where is the corresponding hourglassOff()?\n      /* if (!  Utilities.TEST_MODE) */ \n      _gotoFileDialog.setVisible(true);\n    }\n  };\n  \n  /** Goes to the file specified by the word the cursor is on. */\n  void _gotoFileUnderCursor() {\n//    Utilities.show(\"Calling gotoFileUnderCursor()\");\n    OpenDefinitionsDocument odd = getCurrentDefPane().getOpenDefDocument();\n    String mask = \"\";\n    int loc = getCurrentDefPane().getCaretPosition();\n    String s = odd.getText();\n    // find start\n    int start = loc;\n    while(start > 0) {\n      if (! Character.isJavaIdentifierPart(s.charAt(start-1))) { break; }\n      --start;\n    }\n    while((start<s.length()) && (!Character.isJavaIdentifierStart(s.charAt(start))) && (start<loc)) {\n      ++start;\n    }\n    // find end\n    int end = loc-1;\n    while(end<s.length()-1) {\n      if (! Character.isJavaIdentifierPart(s.charAt(end+1))) { break; }\n      ++end;\n    }\n    if ((start>=0) && (end<s.length())) {\n      mask = s.substring(start, end + 1);\n    }\n    gotoFileMatchingMask(mask);\n  }\n  \n  /** Goes to the file matching the specified mask.\n    * @param mask word specifying the file to go to*/\n  public void gotoFileMatchingMask(String mask) {        \n    List<OpenDefinitionsDocument> docs = _model.getOpenDefinitionsDocuments();\n    if ((docs == null) || (docs.size() == 0)) return; // do nothing\n    \n    GoToFileListEntry currentEntry = null;\n    ArrayList<GoToFileListEntry> list;\n    list = new ArrayList<GoToFileListEntry>(docs.size());\n    for(OpenDefinitionsDocument d: docs) {\n      GoToFileListEntry entry = new GoToFileListEntry(d, d.toString());\n      if (d.equals(_model.getActiveDocument())) currentEntry = entry;\n      list.add(entry);\n    }\n    \n    PredictiveInputModel<GoToFileListEntry> pim =\n      new PredictiveInputModel<GoToFileListEntry>(true, new PrefixStrategy<GoToFileListEntry>(), list);\n    pim.setMask(mask);\n    \n//    Utilities.show(\"Matching items are: \" + pim.getMatchingItems());\n    \n    if (pim.getMatchingItems().size() == 1) {\n      // exactly one match, go to file\n      if (pim.getCurrentItem() != null) {\n        final OpenDefinitionsDocument newDoc = pim.getCurrentItem().getOpenDefinitionsDocument();\n        if (newDoc != null) {\n          boolean docChanged = ! newDoc.equals(_model.getActiveDocument());\n//        if (docChanged) { addToBrowserHistory(); }\n          _model.setActiveDocument(newDoc);\n          if (docChanged) { // defer executing this code until after active document switch is complete\n            addToBrowserHistory();\n          }\n        }\n      }\n    }\n    else {\n      // try appending \".java\" and the other file extensions and see if it's unique\n      boolean exact = false;\n      for(String attemptedExt: OptionConstants.LANGUAGE_LEVEL_EXTENSIONS) {\n        pim.setMask(mask);\n        pim.extendMask(attemptedExt);\n        if (pim.getMatchingItems().size() == 1) {\n          exact = true;\n          // exactly one match with \".java\" appended, go to file\n          if (pim.getCurrentItem() != null) {\n            final OpenDefinitionsDocument newDoc = pim.getCurrentItem().getOpenDefinitionsDocument();\n            if (newDoc != null) {\n              boolean docChanged = !newDoc.equals(_model.getActiveDocument());\n//          if (docChanged) { addToBrowserHistory(); }\n              _model.setActiveDocument(newDoc);\n              if (docChanged) { // defer executing this code until after active document switch is complete\n                addToBrowserHistory();\n              }\n            }\n          }\n          break;\n        }\n      }\n      if (!exact) {\n        // not exactly one match\n        pim.setMask(mask);\n        if (pim.getMatchingItems().size() == 0) {\n          // if there are no matches, shorten the mask until there is at least one\n          mask = pim.getMask();\n          while (mask.length() > 0) {\n            mask = mask.substring(0, mask.length() - 1);\n            pim.setMask(mask);\n            if (pim.getMatchingItems().size() > 0) { break; }\n          }\n        }       \n        initGotoFileDialog();\n        _gotoFileDialog.setModel(true, pim); // ignore case\n        if (currentEntry != null) _gotoFileDialog.setCurrentItem(currentEntry);\n        hourglassOn();\n        /* Following boolean flag suppresses display of the dialog during unit testing.  If the unit test is revised\n         * to confirm that the dialog is displayed, this test must be removed. */\n        if (MainFrame.this.isVisible()) _gotoFileDialog.setVisible(true);\n      }\n    }\n  }\n  \n  /** Goes to the file specified by the word the cursor is on. */\n  final Action _gotoFileUnderCursorAction = new AbstractAction(\"Go to File Under Cursor\") {\n    public void actionPerformed(ActionEvent ae) { _gotoFileUnderCursor(); }\n  };\n  \n  \n  /** Reset the position of the \"Open Javadoc\" dialog. */\n  public void resetOpenJavadocDialogPosition() {\n    initOpenJavadocDialog();\n    _openJavadocDialog.setFrameState(\"default\");\n    if (DrJava.getConfig().getSetting(DIALOG_OPENJAVADOC_STORE_POSITION).booleanValue()) {\n      DrJava.getConfig().setSetting(DIALOG_OPENJAVADOC_STATE, \"default\");\n    }\n  }\n  \n  /** Initialize dialog if necessary.\n    * Should NOT be called in the event thread. */\n  void initOpenJavadocDialog() {\n    if (_openJavadocDialog == null) {\n      PredictiveInputFrame.InfoSupplier<JavaAPIListEntry> info = \n        new PredictiveInputFrame.InfoSupplier<JavaAPIListEntry>() {\n        public String value(JavaAPIListEntry entry) {\n          return entry.getFullString();\n        }\n      };\n      PredictiveInputFrame.CloseAction<JavaAPIListEntry> okAction = \n        new PredictiveInputFrame.CloseAction<JavaAPIListEntry>() {\n        public String getName() { return \"OK\"; }\n        public KeyStroke getKeyStroke() { return KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0); }\n        public String getToolTipText() { return null; }\n        public Object value(PredictiveInputFrame<JavaAPIListEntry> p) {\n          if (p.getItem() != null) {\n            PlatformFactory.ONLY.openURL(p.getItem().getURL());\n          }\n          hourglassOff();\n          return null;\n        }\n      };\n      PredictiveInputFrame.CloseAction<JavaAPIListEntry> cancelAction = \n        new PredictiveInputFrame.CloseAction<JavaAPIListEntry>() {\n        public String getName() { return \"Cancel\"; }\n        public KeyStroke getKeyStroke() { return KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0); }\n        public String getToolTipText() { return null; }\n        public Object value(PredictiveInputFrame<JavaAPIListEntry> p) {\n          hourglassOff();\n          return null;\n        }\n      };\n      // Note: PredictiveInputModel.* is statically imported\n      java.util.ArrayList<MatchingStrategy<JavaAPIListEntry>> strategies =\n        new java.util.ArrayList<MatchingStrategy<JavaAPIListEntry>>();\n      strategies.add(new FragmentStrategy<JavaAPIListEntry>());\n      strategies.add(new PrefixStrategy<JavaAPIListEntry>());\n      strategies.add(new RegExStrategy<JavaAPIListEntry>());\n      List<PredictiveInputFrame.CloseAction<JavaAPIListEntry>> actions\n        = new ArrayList<PredictiveInputFrame.CloseAction<JavaAPIListEntry>>();\n      actions.add(okAction);\n      actions.add(cancelAction);\n      _openJavadocDialog = \n        new PredictiveInputFrame<JavaAPIListEntry>(MainFrame.this,\n                                                   \"Open Java API Javadoc Webpage\",\n                                                   true, // force\n                                                   true, // ignore case\n                                                   info,\n                                                   strategies,\n                                                   actions, 1, // cancel is action 1\n                                                   new JavaAPIListEntry(\"dummyJavadoc\", \"dummyJavadoc\", null)) {\n        public void setOwnerEnabled(boolean b) {\n          if (b) { hourglassOff(); } else { hourglassOn(); }\n        }\n      }; \n      // putting one dummy entry in the list; it will be changed later anyway\n      \n      if (DrJava.getConfig().getSetting(DIALOG_OPENJAVADOC_STORE_POSITION).booleanValue()) {\n        _openJavadocDialog.setFrameState(DrJava.getConfig().getSetting(DIALOG_OPENJAVADOC_STATE));\n      }\n      generateJavaAPISet();\n    }\n  }\n  \n  \n  /** Generate Java API class list. */\n  public static Set<JavaAPIListEntry> _generateJavaAPISet(String base,\n                                                          String stripPrefix,\n                                                          String suffix) {\n    URL url = MainFrame.class.getResource(\"/edu/rice/cs/drjava/docs/javaapi\"+suffix);\n    return _generateJavaAPISet(base, stripPrefix, url);\n  }\n  \n  /** Generate Java API class list. */\n  public static Set<JavaAPIListEntry> _generateJavaAPISet(String base,\n                                                          String stripPrefix,\n                                                          URL url) {\n    Set<JavaAPIListEntry> s = new HashSet<JavaAPIListEntry>();\n    if (url==null) return s;\n    try {\n      InputStream urls = url.openStream();\n      InputStreamReader is = null;\n      BufferedReader br = null;\n      try {\n        is = new InputStreamReader(urls);\n        br = new BufferedReader(is);\n        String line = br.readLine();\n        while(line != null) {\n          final String aText = \"<a href=\\\"\";\n          int aPos = line.toLowerCase().indexOf(aText);\n          int aEndPos = line.toLowerCase().indexOf(\".html\\\" \",aPos);\n          if ((aPos>=0) && (aEndPos>=0)) {\n            String link = line.substring(aPos+aText.length(), aEndPos);\n            String fullClassName = link.substring(stripPrefix.length()).replace('/', '.');\n            String simpleClassName = fullClassName;\n            int lastDot = fullClassName.lastIndexOf('.');\n            if (lastDot>=0) { simpleClassName = fullClassName.substring(lastDot + 1); }\n            try {\n              URL pageURL = new URL(base + link + \".html\");\n              s.add(new JavaAPIListEntry(simpleClassName, fullClassName, pageURL));\n            }\n            catch(MalformedURLException mue) { /* ignore, we'll just not put this class in the list */ }\n          }\n          line = br.readLine();\n        }\n      }\n      finally {\n        if (br != null) { br.close(); }\n        if (is != null) { is.close(); }\n        if (urls != null) { urls.close(); }\n      }\n    }\n    catch(IOException ioe) { /* ignore, we'll just have an incomplete list */ }\n    return s;\n  }\n\n  /** @return the set of all classes, scanned after the last compile. */\n  public Set<GoToFileListEntry> getCompleteClassSet() {\n    return _completeClassSet;\n  }\n\n  /** Clear the set of all classes. */\n  public void clearCompleteClassSet() {\n    _completeClassSet.clear();\n  }\n  \n  /** Clears the Java API class set. */\n  public void clearJavaAPISet() {\n    _javaAPISet.clear(); \n  }\n  \n  /** @return the Java API class set. */\n  public Set<JavaAPIListEntry> getJavaAPISet() {\n    if (_javaAPISet.size() == 0) {\n      generateJavaAPISet();\n    }\n    return _javaAPISet;\n  }\n  \n  /** Generate Java API class list. */\n  public void generateJavaAPISet() {\n    // should NOT be called in the event thread\n    // otherwise the processing frame will not work correctly and the event thread will block\n    // assert (!EventQueue.isDispatchThread());\n    if (_javaAPISet.size() == 0) {\n      final edu.rice.cs.util.swing.ProcessingDialog pd =\n        new edu.rice.cs.util.swing.ProcessingDialog(this, \"Java API Classes\", \"Loading, please wait.\", false);\n      if (!EventQueue.isDispatchThread()) { pd.setVisible(true); }\n      // generate list\n      String linkVersion = DrJava.getConfig().getSetting(JAVADOC_API_REF_VERSION);\n      \n      // the string that will be ADDED to the beginning of the link to form the full URL\n      String base = \"\";\n      \n      // the string that will be REMOVED from the beginning of the link to form the fully-qualified class name\n      String stripPrefix = \"\";\n      \n      // the HTML file name that contains all the links\n      String suffix = \"\";\n      if (linkVersion.equals(JAVADOC_AUTO_TEXT)) {\n        // use the compiler's version of the Java API Javadoc\n        edu.rice.cs.plt.reflect.JavaVersion ver = _model.getCompilerModel().getActiveCompiler().version();\n        if (ver==edu.rice.cs.plt.reflect.JavaVersion.JAVA_1_4) {\n          linkVersion = JAVADOC_1_4_TEXT;\n        }\n        else if (ver==edu.rice.cs.plt.reflect.JavaVersion.JAVA_5) {\n          linkVersion = JAVADOC_1_5_TEXT;\n        }\n        else if (ver==edu.rice.cs.plt.reflect.JavaVersion.JAVA_6) {\n          linkVersion = JAVADOC_1_6_TEXT;\n        }\n        else {\n          linkVersion = JAVADOC_1_3_TEXT;\n        }\n      }\n      if (linkVersion.equals(JAVADOC_1_3_TEXT)) {\n        base = DrJava.getConfig().getSetting(JAVADOC_1_3_LINK) + \"/\";\n        stripPrefix = \"\"; // nothing needs to be stripped, links in 1.3 Javadoc are relative\n        suffix = \"/allclasses-1.3.html\";\n      }\n      else if (linkVersion.equals(JAVADOC_1_4_TEXT)) {\n        base = DrJava.getConfig().getSetting(JAVADOC_1_4_LINK) + \"/\";\n        stripPrefix = \"\"; // nothing needs to be stripped, links in 1.4 Javadoc are relative\n        suffix = \"/allclasses-1.4.html\";\n      }\n      else if (linkVersion.equals(JAVADOC_1_5_TEXT)) {\n        base = DrJava.getConfig().getSetting(JAVADOC_1_5_LINK) + \"/\";\n        stripPrefix = \"\"; // nothing needs to be stripped, links in 1.5 Javadoc are relative\n        suffix = \"/allclasses-1.5.html\";\n      }\n      else if (linkVersion.equals(JAVADOC_1_6_TEXT)) {\n        // at one point, the links in the 1.6 Javadoc were absolute, and this is how we dealt with that\n        // base = \"\"; // links in 1.6 Javadoc are absolute, so nothing needs to be added to get an absolute URL\n        // // but we do need to strip the absolute part to get correct fully-qualified class names\n        // // and we take the default string here, not what the user entered, because the links in\n        // // our allclasses-1.6.html file go to the original Sun website.\n        // stripPrefix = JAVADOC_1_6_LINK.getDefaultString() + \"/\";\n        base = DrJava.getConfig().getSetting(JAVADOC_1_6_LINK) + \"/\";\n        stripPrefix = \"\"; // nothing needs to be stripped, links in 1.6 Javadoc are relative\n        suffix = \"/allclasses-1.6.html\";\n      }\n      \n      if (!suffix.equals(\"\")) {\n        _javaAPISet.addAll(_generateJavaAPISet(base, stripPrefix, suffix));\n      }\n      else {\n        // no valid Javadoc URL\n      }\n      \n      // add JUnit\n      Set<JavaAPIListEntry> junitAPIList = _generateJavaAPISet(DrJava.getConfig().getSetting(JUNIT_LINK) + \"/\",\n                                                               \"\", // relative links\n                                                               \"/allclasses-concjunit4.7.html\");\n      _javaAPISet.addAll(junitAPIList);\n      \n      // add additional Javadoc libraries\n      for(String url: DrJava.getConfig().getSetting(JAVADOC_ADDITIONAL_LINKS)) {\n        try {\n          Set<JavaAPIListEntry> additionalList = _generateJavaAPISet(url + \"/\",\n                                                                     \"\", // relative links\n                                                                     new URL(url+\"/allclasses-frame.html\"));\n          _javaAPISet.addAll(additionalList);\n        }\n        catch(MalformedURLException mue) { /* ignore, we'll just not put this class in the list */ }\n      }\n      \n      if (_javaAPISet.size() == 0) { clearJavaAPISet(); }\n      \n      // finished\n      if (!EventQueue.isDispatchThread()) {\n        pd.setVisible(false);\n        pd.dispose();\n      }\n    }\n  }\n  \n  /** The \"Open Javadoc\" dialog instance. */\n  PredictiveInputFrame<JavaAPIListEntry> _openJavadocDialog = null;\n  \n  /** The list of Java API classes. */\n  Set<JavaAPIListEntry> _javaAPISet = new HashSet<JavaAPIListEntry>();\n  \n  /** Action that asks the user for a file name and goes there.  Only executes in the event thread. */\n  private Action _openJavadocAction = new AbstractAction(\"Open Java API Javadoc...\") {\n    public void actionPerformed(ActionEvent ae) {\n      hourglassOn();\n      new Thread() {\n        public void run() {\n        // run this in a thread other than the main thread\n          initOpenJavadocDialog();\n          Utilities.invokeLater(new Runnable() {\n            public void run() {\n              // but now run this in the event thread again\n              _openJavadocDialog.setItems(true, getJavaAPISet()); // ignore case\n              _openJavadocDialog.setVisible(true);\n            }\n          });\n        }\n      }.start();\n    }\n  };\n  \n  /** Opens the Javadoc specified by the word the cursor is on.  Only executes in the event thread. */\n  private void _openJavadocUnderCursor() {\n    hourglassOn();\n    new Thread() {\n      public void run() {\n        // run this in a thread other than the main thread\n        final Set<JavaAPIListEntry> apiSet = getJavaAPISet();\n        if (apiSet == null) {\n//        Utilities.show(\"Cannot load Java API class list. No network connectivity?\");\n          hourglassOff();\n          return;\n        }\n        Utilities.invokeLater(new Runnable() {\n          public void run() {\n            // but now run this in the event thread again\n            PredictiveInputModel<JavaAPIListEntry> pim =\n              new PredictiveInputModel<JavaAPIListEntry>(true, new PrefixStrategy<JavaAPIListEntry>(), apiSet);\n            OpenDefinitionsDocument odd = getCurrentDefPane().getOpenDefDocument();\n            String mask = \"\";\n            int loc = getCurrentDefPane().getCaretPosition();\n            String s = odd.getText();\n            // find start\n            int start = loc;\n            while(start > 0) {\n              if (!Character.isJavaIdentifierPart(s.charAt(start-1))) { break; }\n              --start;\n            }\n            while((start<s.length()) && (!Character.isJavaIdentifierStart(s.charAt(start))) && (start<loc)) {\n              ++start;\n            }\n            // find end\n            int end = loc-1;\n            while(end<s.length()-1) {\n              if (!Character.isJavaIdentifierPart(s.charAt(end+1))) { break; }\n              ++end;\n            }\n            if ((start>=0) && (end<s.length())) {\n              mask = s.substring(start, end + 1);\n              pim.setMask(mask);\n            }\n            \n//    Utilities.show(\"Matching items are: \" + pim.getMatchingItems());\n            \n            if (pim.getMatchingItems().size() == 1) {\n              // exactly one match, go to file\n              if (pim.getCurrentItem() != null) {\n                PlatformFactory.ONLY.openURL(pim.getCurrentItem().getURL());\n                hourglassOff();\n              }\n            }\n            else {\n              // try appending \".java\" and the other file extensions and see if it's unique\n              boolean exact = false;\n              for(String attemptedExt: OptionConstants.LANGUAGE_LEVEL_EXTENSIONS) {\n                pim.setMask(mask);\n                pim.extendMask(attemptedExt);\n                if (pim.getMatchingItems().size() == 1) {\n                  // exactly one match with \".java\" appended, go to file\n                  exact = true;\n                  if (pim.getCurrentItem() != null) {\n                    PlatformFactory.ONLY.openURL(pim.getCurrentItem().getURL());\n                    hourglassOff();\n                  }\n                  break;\n                }\n              }\n              if (!exact) {\n                // not exactly one match\n                pim.setMask(mask);\n                int found = 0;\n                if (pim.getMatchingItems().size() == 0) {\n                  // if there are no matches, shorten the mask until there is at least one\n                  mask = pim.getMask();\n                  while(mask.length() > 0) {\n                    mask = mask.substring(0, mask.length() - 1);\n                    pim.setMask(mask);\n                    if (pim.getMatchingItems().size() > 0) { break; }\n                  }\n                }\n                else {\n                  // there are several matches, see if there is an exact match\n                  for(JavaAPIListEntry e: pim.getMatchingItems()) {\n                    if (e.toString().equalsIgnoreCase(mask)) {\n                      ++found;\n                    }\n                  }\n                }\n                if (found==1) {\n                  // open unique item and return\n                  PlatformFactory.ONLY.openURL(pim.getCurrentItem().getURL());\n                  hourglassOff();\n                }\n                else {\n                  initOpenJavadocDialog();\n                  _openJavadocDialog.setModel(true, pim); // ignore case\n                  _openJavadocDialog.setVisible(true);\n                }\n              }\n            }\n          }\n        });\n      }\n    }.start();\n  }\n  \n  /** Open Javadoc page specified by the word the cursor is on. */\n  final Action _openJavadocUnderCursorAction = new AbstractAction(\"Open Java API Javadoc for Word Under Cursor...\") {\n    public void actionPerformed(ActionEvent ae) {\n      _openJavadocUnderCursor();\n    }\n  };\n  \n  /** Close input stream in the interactions pane. */\n  final Action _closeSystemInAction = new AbstractAction(\"Close System.in\") {\n    public void actionPerformed(ActionEvent ae){\n      _interactionsController.setEndOfStream(true);\n      _interactionsController.interruptConsoleInput();\n    }\n  };  \n  \n  /** The \"Complete Word\" dialog instance. */\n  private volatile AutoCompletePopup _completeWordDialog = null;\n\n  /** Initialize the \"Complete Word\" dialog. */\n  private void initCompleteWordDialog() {\n    if (_completeWordDialog==null) {\n      _completeWordDialog = new AutoCompletePopup(this);\n    }\n  }\n    \n  \n  /** Complete the word the cursor is on.  Only executes in the event thread. */\n  private void _completeWordUnderCursor() {\n    initCompleteWordDialog();\n    \n    hourglassOn();\n    \n    final OpenDefinitionsDocument odd = getCurrentDefPane().getOpenDefDocument();\n    final int loc = getCurrentDefPane().getCaretPosition();\n    try {\n      final String initial = odd.getText(0, loc);\n      _completeWordDialog.show(this,\n                               \"Complete Word\",\n                               initial,\n                               loc,\n                               edu.rice.cs.plt.iter.IterUtil.make(\"OK\", \"Fully Qualified\"),\n                               edu.rice.cs.plt.iter.IterUtil.\n                                 make(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0),\n                                      KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, OptionConstants.MASK)),\n                               0, // simple class name action if just one match\n                               new Runnable() {\n        public void run() {\n          // canceled\n          hourglassOff();\n          MainFrame.this.toFront();\n        }\n      },\n                               edu.rice.cs.plt.iter.IterUtil.\n                                 make(new Runnable3<AutoCompletePopupEntry,Integer,Integer>() {\n                                 public void run(AutoCompletePopupEntry entry,\n                                                 Integer from,\n                                                 Integer to) {\n                                   // accepted\n                                   try {\n                                     odd.remove(from, to-from);\n                                     odd.insertString(from, entry.getClassName(), null);\n                                   }\n                                   catch(BadLocationException ble) { /* just don't complete */ }\n                                   \n                                   hourglassOff();\n                                   MainFrame.this.toFront();\n                                 }\n                               }, new Runnable3<AutoCompletePopupEntry,Integer,Integer>() {\n                                 public void run(AutoCompletePopupEntry entry,\n                                                 Integer from,\n                                                 Integer to) {\n                                   // accepted\n                                   try {\n                                     odd.remove(from, to-from);\n                                     odd.insertString(from, entry.getFullPackage()+entry.getClassName(), null);\n                                   }\n                                   catch(BadLocationException ble) { /* just don't complete */ }\n                                   \n                                   hourglassOff();\n                                   MainFrame.this.toFront();\n                                 }\n                               }));\n    }\n    catch(BadLocationException ble) { /* just don't complete */ }\n  }\n  \n  public void resetCompleteWordDialogPosition() {\n    initCompleteWordDialog();\n    _completeWordDialog.setFrameState(\"default\");\n    if (DrJava.getConfig().getSetting(DIALOG_COMPLETE_WORD_STORE_POSITION).booleanValue()) {\n      DrJava.getConfig().setSetting(DIALOG_COMPLETE_WORD_STATE, \"default\");\n    }\n  }\n  \n  /** Auto-completes word the cursor is on. */\n  final Action completeWordUnderCursorAction = new AbstractAction(\"Auto-Complete Word Under Cursor\") {\n    public void actionPerformed(ActionEvent ae) {\n      _completeWordUnderCursor();\n    }\n  };\n  \n  /** Indents the current selection. */\n  private final Action _indentLinesAction = new AbstractAction(\"Indent Line(s)\") {\n    public void actionPerformed(ActionEvent ae) {\n      hourglassOn();\n      try {\n        _currentDefPane.endCompoundEdit();\n        _currentDefPane.indent();\n      } finally {\n        hourglassOff();\n      }\n    }\n  };\n  \n  /** Action for commenting out a block of text using wing comments. */\n  private final Action _commentLinesAction = new AbstractAction(\"Comment Line(s)\") {\n    public void actionPerformed(ActionEvent ae) {\n      hourglassOn();\n      try{ commentLines(); }\n      finally{ hourglassOff(); }\n    }\n  };\n  \n  /** Action for un-commenting a block of commented text. */\n  private final Action _uncommentLinesAction = new AbstractAction(\"Uncomment Line(s)\") {\n    public void actionPerformed(ActionEvent ae){\n      hourglassOn();\n      try{ uncommentLines(); }\n      finally{ hourglassOff(); }\n    }\n  };\n\n  /** Saves a copy of DrJava's output console to a file. */\n  private final Action _saveConsoleCopyAction = new AbstractAction(\"Save Copy of Console...\") {\n    public void actionPerformed(ActionEvent ae) {\n      updateStatusField(\"Saving Copy of Console\");\n      _saveConsoleCopy(_model.getConsoleDocument());\n      _consolePane.requestFocusInWindow();\n    }\n  };\n  \n  /** Saves a copy of either the console or the interactions pane to a file. */\n  public void _saveConsoleCopy(ConsoleDocument doc) {\n    _saveChooser.removeChoosableFileFilter(_projectFilter);\n    _saveChooser.removeChoosableFileFilter(_javaSourceFilter);\n    _saveChooser.removeChoosableFileFilter(_unfilteredJavaSourceFilter);\n    _saveChooser.setFileFilter(_txtFileFilter);    \n    _saveChooser.setMultiSelectionEnabled(false);\n    _saveChooser.setSelectedFile(new File(\"\"));\n    try {\n      _model.saveConsoleCopy(doc, new FileSaveSelector() {\n        public File getFile() throws OperationCanceledException {\n          int rc = _saveChooser.showSaveDialog(MainFrame.this);\n          switch (rc) {\n            case JFileChooser.CANCEL_OPTION:\n            case JFileChooser.ERROR_OPTION:\n              throw new OperationCanceledException();\n            case JFileChooser.APPROVE_OPTION:\n              File chosen = _saveChooser.getSelectedFile();\n              if (chosen != null) {\n                // append the .txt extension if no . written by user\n                if (chosen.getName().indexOf(\".\") == -1)\n                  return new File(chosen.getAbsolutePath() + TEXT_FILE_EXTENSION);\n                return chosen;\n              }\n              else\n                throw new RuntimeException(\"Filechooser returned null file\");\n          }\n          // impossible since rc must be one of these\n          throw new RuntimeException(\"Filechooser returned bad rc \" + rc);\n        }\n        public boolean warnFileOpen(File f) { return _warnFileOpen(f); }\n        public boolean verifyOverwrite(File f) { return MainFrameStatics.verifyOverwrite(MainFrame.this, f); }\n        public boolean shouldSaveAfterFileMoved(OpenDefinitionsDocument doc, File oldFile) { return true; }\n        public boolean shouldUpdateDocumentState() { return false; }\n      });\n    }\n    catch (IOException ioe) {\n      MainFrameStatics.showIOError(MainFrame.this, new IOException(\"An error occured writing the contents to a file\"));\n    }\n    finally {\n      _saveChooser.removeChoosableFileFilter(_projectFilter);\n      _saveChooser.removeChoosableFileFilter(_javaSourceFilter);\n      _saveChooser.removeChoosableFileFilter(_unfilteredJavaSourceFilter);\n      _saveChooser.removeChoosableFileFilter(_txtFileFilter);\n      _saveChooser.setFileFilter(_javaSourceFilter);\n    }\n  }\n  \n  /** Clears DrJava's output console. */\n  private final Action _clearConsoleAction = new AbstractAction(\"Clear Console\") {\n    public void actionPerformed(ActionEvent ae) { _model.resetConsole(); }\n  };\n  \n  /** Shows the DebugConsole. */\n  private final Action _showDebugConsoleAction = new AbstractAction(\"Show DrJava Debug Console\") {\n    public void actionPerformed(ActionEvent e) { DrJavaRoot.showDrJavaDebugConsole(MainFrame.this); }\n  };\n  \n  /** Resets the Interactions pane. */\n  private final Action _resetInteractionsAction = new AbstractAction(\"Reset Interactions\") {\n    public void actionPerformed(ActionEvent ae) {\n      if (! DrJava.getConfig().getSetting(INTERACTIONS_RESET_PROMPT).booleanValue()) {\n        _doResetInteractions();\n        \n        return;\n      }\n      \n      String title = \"Confirm Reset Interactions\";\n      String message = \"Are you sure you want to reset the Interactions Pane?\";\n      ConfirmCheckBoxDialog dialog =\n        new ConfirmCheckBoxDialog(MainFrame.this, title, message);\n      int rc = dialog.show();\n      if (rc == JOptionPane.YES_OPTION) {\n        _doResetInteractions();\n        \n        if (dialog.getCheckBoxValue()) {\n          DrJava.getConfig().setSetting(INTERACTIONS_RESET_PROMPT, Boolean.FALSE);\n        }\n      }\n    }\n  };\n  \n  private void _doResetInteractions() {\n    _tabbedPane.setSelectedIndex(INTERACTIONS_TAB);\n    updateStatusField(\"Resetting Interactions\");\n    // Lots of work, so use another thread\n    _interactionsPane.discardUndoEdits();\n    new Thread(new Runnable() { \n      public void run() {\n        _model.resetInteractions(_model.getWorkingDirectory(), true);\n        _closeSystemInAction.setEnabled(true);\n      }\n    }).start();\n  }\n  \n  /** Defines actions that displays the interactions classpath. */\n  private final Action _viewInteractionsClassPathAction = new AbstractAction(\"View Interactions Classpath...\") {\n    public void actionPerformed(ActionEvent e) { viewInteractionsClassPath(); }\n  };\n  \n  /** Displays the interactions classpath. */  \n  public void viewInteractionsClassPath() {\n    String cp = IterUtil.multilineToString(_model.getInteractionsClassPath());\n    new DrJavaScrollableDialog(this, \"Interactions Classpath\", \"Current Interpreter Classpath\", cp).show();\n  }\n  \n  /** Action that shows what help documentation is available.  Only executes in the event thread. */\n  private final Action _helpAction = new AbstractAction(\"Help\") {\n    public void actionPerformed(ActionEvent ae) {\n      // Create frame if we haven't yet\n//      if (_helpFrame == null) {\n//        _helpFrame = new HelpFrame();\n//      }\n      _helpFrame.setVisible(true);\n    }\n  };\n  \n  /** Action that shows the quick start documentation.  Only executes in the event thread. */\n  private final Action _quickStartAction = new AbstractAction(\"QuickStart\") {\n    public void actionPerformed(ActionEvent ae) {\n      // Create frame if we haven't yet\n//      if (_quickStartFrame == null) {\n//        _quickStartFrame = new QuickStartFrame();\n//      }\n      _quickStartFrame.setVisible(true);\n    }\n  };\n  \n  /** Action that pops up an info dialog.  Only runs in the event thread. */\n  private final Action _aboutAction = new AbstractAction(\"About\") {\n    public void actionPerformed(ActionEvent ae) {\n      // Create dialog if we haven't yet\n//      if (_aboutDialog == null) _aboutDialog = new AboutDialog(MainFrame.this);\n//      Point p = MainFrame.this.getLocation();\n      _aboutDialog.setVisible(true);\n//      _aboutDialog.setLocation(p.x+(MainFrame.this.getWidth() - _aboutDialog.getWidth())/2, \n//      p.y+(MainFrame.this.getHeight()-_aboutDialog.getHeight())/2);\n      \n    }\n  };\n  \n  /** Action that pops up a dialog that checks for a new version.  Only runs in the event thread. */\n  private final Action _checkNewVersionAction = new AbstractAction(\"Check for New Version\") {\n    public void actionPerformed(ActionEvent ae) {\n      NewVersionPopup popup = new NewVersionPopup(MainFrame.this);\n      popup.setVisible(true);\n    }\n  };\n  \n  /** Asks whether DrJava may contact the DrJava developers and send system information. */\n  private final Action _drjavaSurveyAction = new AbstractAction(\"Send System Information\") {\n    public void actionPerformed(ActionEvent ae) {\n      DrJavaSurveyPopup popup = new DrJavaSurveyPopup(MainFrame.this);\n      popup.setVisible(true);\n    }\n  };\n  \n  /** Action that pops up the DrJava errors dialog.  Only runs in the event thread. */\n  private final Action _errorsAction = new AbstractAction(\"DrJava Errors\") {\n    public void actionPerformed(ActionEvent ae) {\n      setPopupLoc(DrJavaErrorWindow.singleton());\n      DrJavaErrorWindow.singleton().setVisible(true);\n    }\n  };\n  \n  /** Action that pops up the dialog to generate a custom drjava.jar file. \n    * Only runs in the event thread. */\n  private final Action _generateCustomDrJavaJarAction = new AbstractAction(\"Generate Custom drjava.jar...\") {\n    public void actionPerformed(ActionEvent ae) {\n      GenerateCustomDrJavaJarFrame popup = new GenerateCustomDrJavaJarFrame(MainFrame.this);\n      popup.setVisible(true);\n    }\n  };\n\n  /** Action that starts a new, blank, unconnected DrJava instance. */\n  private final Action _newDrJavaInstanceAction = new AbstractAction(\"New DrJava Instance...\") {\n    public void actionPerformed(ActionEvent ae) {\n      try {\n        Process p = edu.rice.cs.plt.concurrent.JVMBuilder.DEFAULT.classPath(FileOps.getDrJavaFile()).\n          start(edu.rice.cs.drjava.DrJava.class.getName(), \"-new\");\n      }\n      catch(IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n    }\n  };\n  \n  /** Action that switches to next document.  Only runs in the event thread. */\n  private final Action _switchToNextAction = new AbstractAction(\"Next Document\") {\n    public void actionPerformed(ActionEvent ae) {\n      this.setEnabled(false);\n      if (_docSplitPane.getDividerLocation() < _docSplitPane.getMinimumDividerLocation())\n        _docSplitPane.setDividerLocation(DrJava.getConfig().getSetting(DOC_LIST_WIDTH).intValue());\n      //disables switching documents while the next one is opening up, in order to prevent out of control switching\n      _model.setActiveNextDocument();\n      _findReplace.updateFirstDocInSearch();\n      this.setEnabled(true);\n      // defer executing this code until after active document switch (if any) is complete\n      addToBrowserHistory();\n    }\n  };\n  \n  /** Switches to previous document. */\n  private final Action _switchToPrevAction = new AbstractAction(\"Previous Document\") {\n    public void actionPerformed(ActionEvent ae) {\n      this.setEnabled(false);\n      if (_docSplitPane.getDividerLocation() < _docSplitPane.getMinimumDividerLocation())\n        _docSplitPane.setDividerLocation(DrJava.getConfig().getSetting(DOC_LIST_WIDTH).intValue());\n      _model.setActivePreviousDocument();\n      _findReplace.updateFirstDocInSearch();\n      this.setEnabled(true);\n      // defer executing this code until after active document switch (if any) is complete\n      addToBrowserHistory();\n    }\n  };\n  \n  /** Switches focus to next pane. */\n  private final Action _switchToNextPaneAction =  new AbstractAction(\"Next Pane\") {\n    public void actionPerformed(ActionEvent ae) {\n      if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) \n        _mainSplit.resetToPreferredSizes(); \n      this.setEnabled(false);\n      _switchPaneFocus(true);\n      this.setEnabled(true);\n    }\n  };\n  \n  /** Browse back in the browser history. */\n  private final Action _browseBackAction = new AbstractAction(\"Browse Back\") {\n    public void actionPerformed(ActionEvent ae) {\n      updateStatusField(\"Browsing Back\");\n      this.setEnabled(false);\n      if (_docSplitPane.getDividerLocation() < _docSplitPane.getMinimumDividerLocation())\n        _docSplitPane.setDividerLocation(DrJava.getConfig().getSetting(DOC_LIST_WIDTH).intValue());\n      //disables switching documents while the next one is opening up, in order to prevent out of control switching\n      \n      // add current location to history\n      BrowserHistoryManager rm = _model.getBrowserHistoryManager();      \n      addToBrowserHistory();\n      \n      // then move back    \n      BrowserDocumentRegion r = rm.prevCurrentRegion(_model.getNotifier());\n      if (r != null) scrollToDocumentAndOffset(r.getDocument(), r.getStartOffset(), false, false);\n      _configureBrowsing();\n//      MainFrame.MFLOG.log(\"browseBack: \"+rm);\n    }\n  };\n  \n  /** Browse forward in the browser history. */\n  private final Action _browseForwardAction = new AbstractAction(\"Browse Forward\") {\n    public void actionPerformed(ActionEvent ae) {\n      updateStatusField(\"Browsing Forward\");\n      this.setEnabled(false);\n      if (_docSplitPane.getDividerLocation() < _docSplitPane.getMinimumDividerLocation())\n        _docSplitPane.setDividerLocation(DrJava.getConfig().getSetting(DOC_LIST_WIDTH).intValue());\n      //disables switching documents while the next one is opening up, in order to prevent out of control switching\n      \n      // add current location to history\n      BrowserHistoryManager rm = _model.getBrowserHistoryManager();      \n      addToBrowserHistoryBefore();\n      \n      // then move forward\n      BrowserDocumentRegion r = rm.nextCurrentRegion(_model.getNotifier());\n      if (r != null) scrollToDocumentAndOffset(r.getDocument(), r.getStartOffset(), false, false);\n      _configureBrowsing();\n//      MainFrame.MFLOG.log(\"browseForward: \"+rm);\n    }\n  };\n\n  /** Jump to the next region in the tabbed pane. */\n  private final Action _nextRegionAction = new AbstractAction(\"Next Region\") {\n    public void actionPerformed(ActionEvent ae) {\n      Component c = _tabbedPane.getComponentAt(_tabbedPane.getSelectedIndex());\n      if (c instanceof RegionsTreePanel) {\n        RegionsTreePanel<?> rtp = (RegionsTreePanel<?>)c;\n        rtp.goToNextRegion();\n      }\n    }\n  };\n  \n  /** Jump to the previous region in the tabbed pane. */\n  private final Action _prevRegionAction = new AbstractAction(\"Previous Region\") {\n    public void actionPerformed(ActionEvent ae) {\n      Component c = _tabbedPane.getComponentAt(_tabbedPane.getSelectedIndex());\n      if (c instanceof RegionsTreePanel) {\n        RegionsTreePanel<?> rtp = (RegionsTreePanel<?>)c;\n        rtp.goToPreviousRegion();\n      }\n    }\n  };\n  \n  /** Switches focus to previous pane. */\n  private final Action _switchToPreviousPaneAction =  new AbstractAction(\"Previous Pane\") {\n    public void actionPerformed(ActionEvent ae) {\n      if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) \n        _mainSplit.resetToPreferredSizes(); \n      this.setEnabled(false);\n      _switchPaneFocus(false);\n      this.setEnabled(true);\n    }\n  };\n  \n  /** Go to the closing brace. */\n  private final Action _gotoClosingBraceAction =  new AbstractAction(\"Go to Closing Brace\") {\n    public void actionPerformed(ActionEvent ae) {\n      OpenDefinitionsDocument odd = getCurrentDefPane().getOpenDefDocument();\n      try {\n        int pos = odd.findNextEnclosingBrace(getCurrentDefPane().getCaretPosition(), '{', '}');\n        if (pos != -1) { getCurrentDefPane().setCaretPosition(pos); }\n      }\n      catch(BadLocationException ble) { /* just ignore and don't move */ }\n    }\n  };\n  \n  /** Go to the opening brace. */\n  private final Action _gotoOpeningBraceAction =  new AbstractAction(\"Go to Opening Brace\") {\n    public void actionPerformed(ActionEvent ae) {\n      OpenDefinitionsDocument odd = getCurrentDefPane().getOpenDefDocument();\n      try {\n        int pos = odd.findPrevEnclosingBrace(getCurrentDefPane().getCaretPosition(), '{', '}');\n        if (pos != -1) { getCurrentDefPane().setCaretPosition(pos); }\n      }\n      catch(BadLocationException ble) { /* just ignore and don't move */ }\n    }\n  };\n  \n  /** This takes a component and gives it focus, showing it if it's a tab. The interactionsPane and consolePane\n    * are wrapped in scrollpanes, so we have to specifically check for those and unwrap them.\n    * @param c the pane to switch focus to\n    */\n  private void _switchToPane(Component c) {\n    Component newC = c;\n//    if (c == _interactionsContainer) newC = _interactionsPane;\n//    if (c == _consoleScroll) newC = _consolePane;\n    showTab(newC, true);\n  }\n  \n  /** This method allows the user to cycle through the definitions pane and all of the open tabs.\n    * @param next true if we want to go to the next pane, false if the previous.\n    */\n  private void _switchPaneFocus(boolean next) {\n    int numTabs = _tabbedPane.getTabCount();\n    \n    /* If next, then we go to the next tab */\n    if (next) _switchToPane(_tabbedPane.getComponentAt((numTabs + _tabbedPane.getSelectedIndex() +1 ) % numTabs));\n    else _switchToPane(_tabbedPane.getComponentAt((numTabs + _tabbedPane.getSelectedIndex() - 1) % numTabs));\n  }\n  \n  /** Action that calls the ConfigFrame to edit preferences.  Only runs in the event thread. */\n  private final Action _editPreferencesAction = new AbstractAction(\"Preferences ...\") {\n    public void actionPerformed(ActionEvent ae) {\n      \n      _configFrame.setUp();\n      setPopupLoc(_configFrame);\n      _configFrame.setVisible(true);\n      _configFrame.toFront();\n    }\n  };\n  \n  private volatile AbstractAction _projectPropertiesAction = new AbstractAction(\"Project Properties\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.PROJECT,\n                                 GUIAvailabilityListener.ComponentType.COMPILER,\n                                 GUIAvailabilityListener.ComponentType.JUNIT); }\n    public void actionPerformed(ActionEvent ae) { _editProject(); }\n  };\n  \n  /** Action that enables the debugger.  Only runs in the event thread. */\n  private final Action _toggleDebuggerAction = new AbstractAction(\"Debug Mode\") {\n    { _addGUIAvailabilityListener(this,\n                                 GUIAvailabilityListener.ComponentType.INTERACTIONS); }\n    public void actionPerformed(ActionEvent ae) { \n      _guiAvailabilityNotifier.unavailable(GUIAvailabilityListener.ComponentType.INTERACTIONS);\n      debuggerToggle();\n      _guiAvailabilityNotifier.available(GUIAvailabilityListener.ComponentType.INTERACTIONS);\n    }\n  };\n  \n  /** Action that resumes debugging.  Only runs in the event thread. */\n  private final Action _resumeDebugAction = new AbstractAction(\"Resume Debugger\") {\n    { _addGUIAvailabilityListener(this,\n                                  GUIAvailabilityListener.ComponentType.DEBUGGER,\n                                  GUIAvailabilityListener.ComponentType.DEBUGGER_SUSPENDED); }\n    public void actionPerformed(ActionEvent ae) {\n      try { debuggerResume(); }\n      catch (DebugException de) { MainFrameStatics.showDebugError(MainFrame.this, de); }\n    }\n  };\n  \n  // menu item (checkbox menu) for automatic trace in the debugger\n  private volatile JMenuItem _automaticTraceMenuItem;\n  \n  public void setAutomaticTraceMenuItemStatus() {\n    if (_automaticTraceMenuItem != null) {\n      _automaticTraceMenuItem.setSelected(_model.getDebugger().isAutomaticTraceEnabled());\n  }\n  }\n  \n  /** Action that automatically traces through entire program*/\n  private final Action _automaticTraceDebugAction = new AbstractAction(\"Automatic Trace\") {\n    { _addGUIAvailabilityListener(this,\n                                  GUIAvailabilityListener.ComponentType.DEBUGGER,\n                                  GUIAvailabilityListener.ComponentType.DEBUGGER_SUSPENDED); }\n    public void actionPerformed(ActionEvent ae) { \n      debuggerAutomaticTrace(); \n    }\n  };\n  \n  /** Action that steps into the next method call.  Only runs in the event thread. */\n  private final Action _stepIntoDebugAction = new AbstractAction(\"Step Into\") {\n    { _addGUIAvailabilityListener(this,\n                                  GUIAvailabilityListener.ComponentType.DEBUGGER,\n                                  GUIAvailabilityListener.ComponentType.DEBUGGER_SUSPENDED); }\n    public void actionPerformed(ActionEvent ae) { debuggerStep(Debugger.StepType.STEP_INTO); }\n  };\n  \n  /** Action that executes the next line, without stepping into methods.  Only runs in the event thread. */\n  private final Action _stepOverDebugAction = new AbstractAction(\"Step Over\") {\n    { _addGUIAvailabilityListener(this,\n                                  GUIAvailabilityListener.ComponentType.DEBUGGER,\n                                  GUIAvailabilityListener.ComponentType.DEBUGGER_SUSPENDED); }\n    public void actionPerformed(ActionEvent ae) { debuggerStep(Debugger.StepType.STEP_OVER); }\n  };\n  \n  /** Action that steps out of the next method call.  Only runs in the event thread. */\n  private final Action _stepOutDebugAction = new AbstractAction(\"Step Out\") {\n    { _addGUIAvailabilityListener(this,\n                                  GUIAvailabilityListener.ComponentType.DEBUGGER,\n                                  GUIAvailabilityListener.ComponentType.DEBUGGER_SUSPENDED); }\n    public void actionPerformed(ActionEvent ae) {\n      debuggerStep(Debugger.StepType.STEP_OUT);\n    }\n  };\n  \n  /** Suspend debugging */\n  /*private Action _suspendDebugAction =\n   new AbstractAction(\"Suspend Debugger\")\n   {\n   public void actionPerformed(ActionEvent ae) {\n   _debugSuspend();\n   }\n   };*/\n  \n  /** Toggles a breakpoint on the current line */\n  final Action _toggleBreakpointAction = new AbstractAction(\"Toggle Breakpoint on Current Line\") {\n    public void actionPerformed(ActionEvent ae) { debuggerToggleBreakpoint(); }\n  };\n  \n  /** Clears all breakpoints */\n  private final Action _clearAllBreakpointsAction = new AbstractAction(\"Clear All Breakpoints\") {\n    public void actionPerformed(ActionEvent ae) { debuggerClearAllBreakpoints(); }\n  };\n  \n  \n  /** Action that shows the breakpoints tab.  Only runs in the event thread. */\n  private final Action _breakpointsPanelAction = new AbstractAction(\"Breakpoints\") {\n    public void actionPerformed(ActionEvent ae) {\n      if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) \n        _mainSplit.resetToPreferredSizes(); \n      showTab(_breakpointsPanel, true);\n      _breakpointsPanel.setVisible(true);\n      _tabbedPane.setSelectedComponent(_breakpointsPanel);\n      // Use EventQueue.invokeLater to ensure that focus is set AFTER the _breakpointsPanel has been selected\n      EventQueue.invokeLater(new Runnable() { public void run() { _breakpointsPanel.requestFocusInWindow(); } });\n    }\n  };\n  \n  /** Action that shows the bookmarks tab.  Only runs in the event thread. */\n  private final Action _bookmarksPanelAction = new AbstractAction(\"Bookmarks\") {\n    public void actionPerformed(ActionEvent ae) {\n      if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) \n        _mainSplit.resetToPreferredSizes(); \n      showTab(_bookmarksPanel, true);\n      _tabbedPane.setSelectedComponent(_bookmarksPanel);\n      // Use EventQueue.invokeLater to ensure that focus is set AFTER the _bookmarksPanel has been selected\n      EventQueue.invokeLater(new Runnable() { public void run() { _bookmarksPanel.requestFocusInWindow(); } });\n    }\n  };\n  \n  /** Toggles a bookmark. */\n  private final Action _toggleBookmarkAction = new AbstractAction(\"Toggle Bookmark\") {\n    public void actionPerformed(ActionEvent ae) { toggleBookmark(); }\n  };\n  \n  /** Toggle a bookmark. */\n  public void toggleBookmark() {\n//    Utilities.show(\"MainFrame.toggleBookmark called\");\n    assert EventQueue.isDispatchThread();\n    addToBrowserHistory();\n    _model._toggleBookmark(_currentDefPane.getSelectionStart(), _currentDefPane.getSelectionEnd()); \n    showTab(_bookmarksPanel, true);\n  }\n  \n  /** Add the current location to the browser history. */\n  public void addToBrowserHistory() { _model.addToBrowserHistory(); }\n  /** Add the current location to the browser history before the current region. */\n  public void addToBrowserHistoryBefore() { _model.addToBrowserHistory(true); }\n  \n  /** Create a new find results tab.\n    * @param rm the region manager that will contain the regions\n    * @param title the title for the panel\n    * @return new find results tab.\n    * @param searchString string that was searched for\n    * @param searchAll whether all files were searched\n    * @param doc weak reference to document in which search occurred (or started, if all documents were searched)\n    * @param findReplace the FindReplacePanel that created this FindResultsPanel\n    */\n  public FindResultsPanel createFindResultsPanel(final RegionManager<MovingDocumentRegion> rm,\n                                                 MovingDocumentRegion region, String title,\n                                                 String searchString, boolean searchAll, boolean searchSelectionOnly, \n                                                 boolean matchCase, boolean wholeWord, boolean noComments, \n                                                 boolean noTestCases, WeakReference<OpenDefinitionsDocument> doc,\n                                                 FindReplacePanel findReplace) {\n    \n    final FindResultsPanel panel = new FindResultsPanel(this, rm, region, title, searchString, searchAll, \n                                                        searchSelectionOnly, matchCase, wholeWord, noComments, \n                                                        noTestCases, doc, findReplace);\n    \n    final AbstractMap<MovingDocumentRegion, HighlightManager.HighlightInfo> highlights =\n      new IdentityHashMap<MovingDocumentRegion, HighlightManager.HighlightInfo>();\n    final Pair<FindResultsPanel, Map<MovingDocumentRegion, HighlightManager.HighlightInfo>> pair =\n      new Pair<FindResultsPanel, Map<MovingDocumentRegion, HighlightManager.HighlightInfo>>(panel, highlights);\n    _findResults.add(pair);\n    \n    // hook highlighting listener to find results manager\n    rm.addListener(new RegionManagerListener<MovingDocumentRegion>() {     \n      public void regionAdded(MovingDocumentRegion r) {\n        DefinitionsPane pane = getDefPaneGivenODD(r.getDocument());\n//        if (pane == null) System.err.println(\"ODD \" + r.getDocument() + \" produced a null DefinitionsPane!\");\n        highlights.put(r, pane.getHighlightManager().\n                         addHighlight(r.getStartOffset(), r.getEndOffset(), panel.getSelectedPainter()));\n      }\n      public void regionChanged(MovingDocumentRegion r) { \n        regionRemoved(r);\n        regionAdded(r);\n      }\n      public void regionRemoved(MovingDocumentRegion r) {\n//        Utilities.show(\"Removing highlight for region \" + r);\n        HighlightManager.HighlightInfo highlight = highlights.get(r);\n//        Utilities.show(\"The retrieved highlight is \" + highlight);\n        if (highlight != null) highlight.remove();\n        highlights.remove(r);\n        // close the panel and dispose of its MainFrame resources when all regions have been removed.\n        if (rm.getDocuments().isEmpty()) {\n          panel._close(); // _close removes the panel from _tabs and pair from _findResults\n        }\n      }\n    });\n    \n    // attach a listener to the panel that removes pair from _findResults when the panel is closed\n    panel.addCloseListener(new ActionListener() {\n      public void actionPerformed(ActionEvent ae) { _findResults.remove(pair); }\n    });\n    \n    _tabs.addLast(panel);\n    panel.getMainPanel().addFocusListener(new FocusAdapter() {\n      public void focusGained(FocusEvent e) { _lastFocusOwner = panel; }\n    });\n    \n    return panel;\n  }\n  \n  /** Disable \"Find Again\" on \"Find All\" tabs that use a document that was closed. */\n  void disableFindAgainOnClose(List<OpenDefinitionsDocument> projDocs) {\n    for(TabbedPanel t: _tabs) {\n      if (t instanceof FindResultsPanel) {\n        FindResultsPanel p = (FindResultsPanel) t;\n        if (projDocs.contains(p.getDocument())) { p.disableFindAgain(); }\n      }\n    }\n  }\n  \n  /** Action that shows a find results tab. Only runs in event thread. */\n  public void showFindResultsPanel(final FindResultsPanel panel) {\n    assert EventQueue.isDispatchThread();\n    if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) _mainSplit.resetToPreferredSizes(); \n    showTab(panel, true);\n    panel.updatePanel();\n//    panel.setVisible(true);\n    _tabbedPane.setSelectedComponent(panel);\n    // Use EventQueue.invokeLater to ensure that focus is set AFTER the findResultsPanel has been selected\n    EventQueue.invokeLater(new Runnable() { public void run() { panel.requestFocusInWindow(); } });\n  };\n  \n  /** Cuts from the caret to the end of the current line to the clipboard. */\n  protected final Action _cutLineAction = new AbstractAction(\"Cut Line\") {\n    public void actionPerformed(ActionEvent ae) {\n      ActionMap actionMap = _currentDefPane.getActionMap();\n      int oldCol = _model.getActiveDocument().getCurrentCol();\n      actionMap.get(DefaultEditorKit.selectionEndLineAction).actionPerformed(ae);\n      // if oldCol is equal to the current column, then selectionEndLine did\n      // nothing, so we're at the end of the line and should remove the newline\n      // character\n      if (oldCol == _model.getActiveDocument().getCurrentCol()) {\n        // Puts newline character on the clipboard also, not just content as before.\n        actionMap.get(DefaultEditorKit.selectionForwardAction).actionPerformed(ae);\n        cutAction.actionPerformed(ae);\n      }\n      else cutAction.actionPerformed(ae);\n    }\n  };\n  \n  /** Deletes text from the caret to the end of the current line. */\n  protected final Action _clearLineAction = new AbstractAction(\"Clear Line\") {\n    public void actionPerformed(ActionEvent ae) {\n      ActionMap actionMap = _currentDefPane.getActionMap();\n      actionMap.get(DefaultEditorKit.selectionEndLineAction).actionPerformed(ae);\n      actionMap.get(DefaultEditorKit.deleteNextCharAction).actionPerformed(ae);\n    }\n  };\n  \n  /** Moves the caret to the \"intelligent\" beginning of the line.\n    * @see #_getBeginLinePos\n    */\n  private final Action _beginLineAction = new AbstractAction(\"Begin Line\") {\n    public void actionPerformed(ActionEvent ae) {\n      int beginLinePos = _getBeginLinePos();\n      _currentDefPane.setCaretPosition(beginLinePos);\n    }\n  };\n  \n  /** Selects to the \"intelligent\" beginning of the line.\n    * @see #_getBeginLinePos\n    */\n  private final Action _selectionBeginLineAction = new AbstractAction(\"Select to Beginning of Line\") {\n    public void actionPerformed(ActionEvent ae) {\n      int beginLinePos = _getBeginLinePos();\n      _currentDefPane.moveCaretPosition(beginLinePos);\n    }\n  };\n  \n  /** Returns the \"intelligent\" beginning of line.  If the caret is to fhe right of the first non-whitespace character,\n    * the position of the first non-whitespace character is returned.  If the caret is on or to the left of the first \n    * non-whitespace character, the beginning of the line is returned.\n    */\n  private int _getBeginLinePos() {\n    try {\n      int currPos = _currentDefPane.getCaretPosition();\n      OpenDefinitionsDocument openDoc = _model.getActiveDocument();\n      openDoc.setCurrentLocation(currPos);\n      return openDoc.getIntelligentBeginLinePos(currPos);\n    }\n    catch (BadLocationException ble) {\n      // Shouldn't happen: we're using a legal position\n      throw new UnexpectedException(ble);\n    }\n  }\n  \n  private final FileOpenSelector _interactionsHistoryFileSelector = new FileOpenSelector() {\n    public File[] getFiles() throws OperationCanceledException {\n      return getOpenFiles(_interactionsHistoryChooser);\n    }\n  };\n  \n  /** Interprets the commands in a file in the interactions window. */\n  private final Action _executeHistoryAction = new AbstractAction(\"Execute Interactions History...\") {\n    public void actionPerformed(ActionEvent ae) {\n      // Show interactions tab\n      _tabbedPane.setSelectedIndex(INTERACTIONS_TAB);\n      \n      _interactionsHistoryChooser.setDialogTitle(\"Execute Interactions History\");\n      try { _model.loadHistory(_interactionsHistoryFileSelector); }\n      catch (FileNotFoundException fnf) { MainFrameStatics.showFileNotFoundError(MainFrame.this, fnf); }\n      catch (IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n      _interactionsPane.requestFocusInWindow();\n    }\n  };\n  \n  /** Closes the currently executing interactions script, if there is one. */\n  private void _closeInteractionsScript() {\n    if (_interactionsScriptController != null) {\n      _interactionsContainer.remove(_interactionsScriptPane);\n      _interactionsScriptController = null;\n      _interactionsScriptPane = null;\n      _tabbedPane.invalidate();\n      _tabbedPane.repaint();\n    }\n  }\n  \n  /** Action to load an interactions history as a replayable script. */\n  private final Action _loadHistoryScriptAction = new AbstractAction(\"Load Interactions History as Script...\") {\n    public void actionPerformed(ActionEvent e) {\n      try {\n        _interactionsHistoryChooser.setDialogTitle(\"Load Interactions History\");\n        InteractionsScriptModel ism = _model.loadHistoryAsScript(_interactionsHistoryFileSelector);\n        _interactionsScriptController = new InteractionsScriptController(ism, new AbstractAction(\"Close\") {\n          public void actionPerformed(ActionEvent e) {\n            _closeInteractionsScript();\n            _interactionsPane.requestFocusInWindow();\n          }\n        }, _interactionsPane);\n        _interactionsScriptPane = _interactionsScriptController.getPane();\n        _interactionsContainer.add(_interactionsScriptPane, BorderLayout.EAST);\n        _tabbedPane.invalidate();\n        _tabbedPane.repaint();\n      }\n      catch (FileNotFoundException fnf) { MainFrameStatics.showFileNotFoundError(MainFrame.this, fnf); }\n      catch (IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n      catch (OperationCanceledException oce) {\n      }\n    }\n  };\n  \n  /** Save the contents of the interactions window to a file. */\n  private final Action _saveInteractionsCopyAction = new AbstractAction(\"Save Copy of Interactions...\") {\n    public void actionPerformed(ActionEvent ae) {\n      updateStatusField(\"Saving Copy of Interactions\");\n      _saveConsoleCopy(_model.getInteractionsDocument());\n      _interactionsPane.requestFocusInWindow();\n    }\n  };\n    \n  /** Save the commands in the interactions window's history to a file */\n  private final Action _saveHistoryAction = new AbstractAction(\"Save Interactions History...\") {\n    public void actionPerformed(ActionEvent ae) {\n      String[] options = {\"Yes\",\"No\",\"Cancel\"};\n      int resp = JOptionPane.showOptionDialog(MainFrame.this,\n                                              \"Edit interactions history before saving?\",\n                                              \"Edit History?\",\n                                              JOptionPane.YES_NO_CANCEL_OPTION,\n                                              JOptionPane.QUESTION_MESSAGE,\n                                              null,options,\n                                              options[1]);\n      // Cancel\n      if (resp == 2 || resp == JOptionPane.CLOSED_OPTION) return;\n      \n      String history = _model.getHistoryAsStringWithSemicolons();\n      \n      // Edit the history\n      if (resp == 0)\n        history = (new HistorySaveDialog(MainFrame.this)).editHistory(history);\n      if (history == null) return; // save cancelled\n      \n      _interactionsHistoryChooser.setDialogTitle(\"Save Interactions History\");\n      FileSaveSelector selector = new FileSaveSelector() {\n        public File getFile() throws OperationCanceledException {\n          // Don't try to set the fileName with getSaveFile;\n          // just display the dialog and get file with getChosenFile, otherwise\n          // the suggested file name will be whatever document is open.\n          // ED (8.14.03): Had to add this next block of code from getSaveFile to\n          // fix bug #788311 \"NullPointer when saving history\"\n          File selection = _interactionsHistoryChooser.getSelectedFile();//_saveChooser.getSelectedFile();\n          if (selection != null) {\n            _interactionsHistoryChooser.setSelectedFile(selection.getParentFile());\n            _interactionsHistoryChooser.setSelectedFile(selection);\n            _interactionsHistoryChooser.setSelectedFile(null);\n          }\n//          return getSaveFile(_interactionsHistoryChooser);\n          _interactionsHistoryChooser.setMultiSelectionEnabled(false);\n          int rc = _interactionsHistoryChooser.showSaveDialog(MainFrame.this);\n          File c = getChosenFile(_interactionsHistoryChooser, rc, null);\n          //Moved from history itself to here to account for bug #989232, non-existant default\n          //history file found\n          if ((c != null) && (c.getName().indexOf('.') == -1)) {\n            c = new File(c.getAbsolutePath() + \".\" + InteractionsHistoryFilter.HIST_EXTENSION);\n          }\n          _interactionsHistoryChooser.setSelectedFile(c);\n          return c;\n        }\n        public boolean warnFileOpen(File f) { return true; }\n        public boolean verifyOverwrite(File f) { return MainFrameStatics.verifyOverwrite(MainFrame.this, f); }\n        public boolean shouldSaveAfterFileMoved(OpenDefinitionsDocument doc, File oldFile) {\n          return true;\n        }\n        public boolean shouldUpdateDocumentState() { return true; }\n      };\n      \n      try { _model.saveHistory(selector, history);}\n      catch (IOException ioe) {\n        MainFrameStatics.showIOError(MainFrame.this, new IOException(\"An error occured writing the history to a file\"));\n      }\n      _interactionsPane.requestFocusInWindow();\n    }\n  };\n  \n  /** Clears the commands in the interaction history. */\n  private final Action _clearHistoryAction = new AbstractAction(\"Clear Interactions History\") {\n    public void actionPerformed(ActionEvent ae) {\n      _model.clearHistory();\n      _interactionsPane.requestFocusInWindow();\n    }\n  };\n  \n  /** How DrJava responds to window events. */\n  private final WindowListener _windowCloseListener = new WindowAdapter() {\n    public void windowActivated(WindowEvent ev) { }\n    public void windowClosed(WindowEvent ev) { }\n    public void windowClosing(WindowEvent ev) { quit(); }\n    public void windowDeactivated(WindowEvent ev) { }\n    public void windowDeiconified(WindowEvent ev) {\n      try { _model.getActiveDocument().revertIfModifiedOnDisk(); }\n      catch (FileMovedException fme) { _showFileMovedError(fme); }\n      catch (IOException e) { MainFrameStatics.showIOError(MainFrame.this, e);}\n    }\n    public void windowIconified(WindowEvent ev) { }\n    public void windowOpened(WindowEvent ev) { _currentDefPane.requestFocusInWindow(); }\n  };\n  \n  private final MouseListener _resetFindReplaceListener = new MouseListener() {\n    public void mouseClicked(MouseEvent e) { }\n    public void mousePressed(MouseEvent e) { }\n    // As mouseReleased event so that it happens after the document has been set in the model and defPane\n    public void mouseReleased(MouseEvent e) {_findReplace.updateFirstDocInSearch();}\n    public void mouseEntered(MouseEvent e) { }\n    public void mouseExited(MouseEvent e) { }\n  };\n  \n  // ------------- File Display Managers for File Icons ------------\n  \n  private static final DJFileDisplayManager _djFileDisplayManager20;\n  private static final DJFileDisplayManager _djFileDisplayManager30;\n  private static final OddDisplayManager _oddDisplayManager20;\n  private static final OddDisplayManager _oddDisplayManager30;\n  private static final Icon _djProjectIcon;\n  \n  static {\n    Icon java, dj0, dj1, dj2, dj, other, star, jup, juf;\n    \n    java = MainFrame.getIcon(\"JavaIcon20.gif\");\n    dj0 = MainFrame.getIcon(\"ElementaryIcon20.gif\");\n    dj1 = MainFrame.getIcon(\"IntermediateIcon20.gif\");\n    dj2 = MainFrame.getIcon(\"AdvancedIcon20.gif\");\n    dj = MainFrame.getIcon(\"FunctionalIcon20.gif\");\n    other = MainFrame.getIcon(\"OtherIcon20.gif\");\n    _djFileDisplayManager20 = new DJFileDisplayManager(java,dj0,dj1,dj2,dj,other);\n    \n    java = MainFrame.getIcon(\"JavaIcon30.gif\");\n    dj0 = MainFrame.getIcon(\"ElementaryIcon30.gif\");\n    dj1 = MainFrame.getIcon(\"IntermediateIcon30.gif\");\n    dj2 = MainFrame.getIcon(\"AdvancedIcon30.gif\");\n    dj = MainFrame.getIcon(\"FunctionalIcon30.gif\");\n    other = MainFrame.getIcon(\"OtherIcon30.gif\");\n    _djFileDisplayManager30 = new DJFileDisplayManager(java,dj0,dj1,dj2,dj,other);\n    \n    star = MainFrame.getIcon(\"ModStar20.gif\");\n    jup = MainFrame.getIcon(\"JUnitPass20.gif\");\n    juf = MainFrame.getIcon(\"JUnitFail20.gif\");\n    _oddDisplayManager20 = new OddDisplayManager(_djFileDisplayManager20,star,jup,juf);\n    \n    star = MainFrame.getIcon(\"ModStar30.gif\");\n    jup = MainFrame.getIcon(\"JUnitPass30.gif\");\n    juf = MainFrame.getIcon(\"JUnitFail30.gif\");\n    _oddDisplayManager30 = new OddDisplayManager(_djFileDisplayManager30,star,jup,juf);\n    \n    _djProjectIcon = MainFrame.getIcon(\"ProjectIcon.gif\");\n  }\n  \n  \n  /** This manager is meant to retrieve the correct icons for the given filename. The only files recognized \n    * are the files obviously listed below in the function (.java, .dj0, .dj1, .dj2, .dj). The icons that represent \n    * each filetype are given into the managers constructor upon instantiation.  This class is static since\n    * it currently does not depend of the main frame for information.\n    */\n  private static class DJFileDisplayManager extends DefaultFileDisplayManager {\n    private final Icon _java;\n    private final Icon _dj0;\n    private final Icon _dj1;\n    private final Icon _dj2;\n    private final Icon _dj;\n    private final Icon _other;\n    \n    public DJFileDisplayManager(Icon java, Icon dj0, Icon dj1, Icon dj2, Icon dj, Icon other) {\n      _java = java;\n      _dj0 = dj0;\n      _dj1 = dj1;\n      _dj2 = dj2;\n      _dj = dj;\n      _other = other;\n    }\n    /** This method chooses the custom icon only for the known filetypes. If these filetypes are not receiving \n      * the correct icons, make sure the filenames are correct and that the icons are present in the ui/icons \n      * directory.\n      */\n    public Icon getIcon(File f) {\n      if (f == null) return _other;\n      Icon ret = null;\n      if (! f.isDirectory()) {\n        String name = f.getName().toLowerCase();\n        if (name.endsWith(OptionConstants.JAVA_FILE_EXTENSION)) ret = _java;\n        else if (name.endsWith(OptionConstants.DJ_FILE_EXTENSION)) ret = _dj;\n        else if (name.endsWith(OptionConstants.OLD_DJ0_FILE_EXTENSION)) ret = _dj0;\n        else if (name.endsWith(OptionConstants.OLD_DJ1_FILE_EXTENSION)) ret = _dj1;\n        else if (name.endsWith(OptionConstants.OLD_DJ2_FILE_EXTENSION)) ret = _dj2;\n      }\n      if (ret == null) {\n        ret = super.getIcon(f);\n        if (ret.getIconHeight() < _java.getIconHeight()) {\n          ret = new CenteredIcon(ret, _java.getIconWidth(), _java.getIconHeight());\n        }\n      }\n      return ret;\n    }\n  }\n  \n  /** This class wraps the file display managers by superimposing any notification icons on top of the base \n    * file icon.  Currently, only the modified star is allowed, but everything is set up to add notification \n    * icons for whether a document has passed the junit test (for display in the tree). This class is static \n    * for now.  It may be necessary to make it dynamic when implementing the junit notifications.\n    */\n  private static class OddDisplayManager implements DisplayManager<OpenDefinitionsDocument> {\n    private final Icon _star;\n//    private Icon _juPass;\n//    private Icon _juFail;\n    private final FileDisplayManager _default;\n    \n    /** Standard constructor.\n      * @param star The star icon will be put flush to the left 1/4 the way down\n      * @param junitPass indicator of junit success, placed at bottom right\n      * @param junitFail indicator of junit failure, placed at bottom right\n      */\n    public OddDisplayManager(FileDisplayManager fdm, Icon star, Icon junitPass, Icon junitFail) {\n      _star = star;\n//      _juPass = junitPass;\n//      _juFail = junitFail;\n      _default = fdm;\n    }\n    public Icon getIcon(OpenDefinitionsDocument odd) {\n      File f = null;\n      try { f = odd.getFile(); }\n      catch(FileMovedException fme) { /* do nothing */ }\n      \n      if (odd.isModifiedSinceSave()) return makeLayeredIcon(_default.getIcon(f), _star);\n      return _default.getIcon(f);\n    }\n    public String getName(OpenDefinitionsDocument doc) { return doc.getFileName(); }\n    private LayeredIcon makeLayeredIcon(Icon base, Icon star) {\n      return new LayeredIcon(new Icon[]{base, star}, new int[]{0, 0}, \n                             new int[]{0, (base.getIconHeight() / 4)});\n    }\n  };\n  \n  /** This is what is given to the JTreeSortNavigator.  This simply resolves the INavItem to an OpenDefDoc\n    * using the model and forwards it to the OddDisplayManager for size 20.\n    */\n  private final DisplayManager<INavigatorItem> _navPaneDisplayManager = new DisplayManager<INavigatorItem>() {\n    public Icon getIcon(INavigatorItem item) {\n      OpenDefinitionsDocument odd = (OpenDefinitionsDocument) item;  // FIX THIS!\n      return _oddDisplayManager20.getIcon(odd);\n    }\n    public String getName(INavigatorItem name) { return name.getName(); }\n  };\n  \n  /** These listeners support the traversal operations that cycle through recent documents. */\n  public KeyListener _historyListener = new KeyListener() {\n    public void keyPressed(KeyEvent e) {\n      int backQuote = java.awt.event.KeyEvent.VK_BACK_QUOTE;\n      if (e.getKeyCode() == backQuote && e.isControlDown()) {\n        if (e.isShiftDown()) prevRecentDoc();\n        else nextRecentDoc();\n      }\n    }\n    public void keyReleased(KeyEvent e) {\n      if (e.getKeyCode() == java.awt.event.KeyEvent.VK_CONTROL) hideRecentDocFrame();\n    }\n    public void keyTyped(KeyEvent e) { /* noop */ }\n  };\n  \n  public FocusListener _focusListenerForRecentDocs = new FocusListener() {\n    public void focusLost(FocusEvent e) { hideRecentDocFrame();  }\n    public void focusGained(FocusEvent e) { }\n  };\n  \n  // adds Listener for undo/redo action for the definitions pane\n  public final FocusListener _undoRedoDefinitionsFocusListener = new FocusAdapter() {\n    public void focusGained(FocusEvent e){ \n      _undoAction.setDelegatee(_currentDefPane.getUndoAction());\n      _redoAction.setDelegatee(_currentDefPane.getRedoAction());   \n    }\n  };\n  \n  public static DJFileDisplayManager getFileDisplayManager20() { return _djFileDisplayManager20; }\n  public static DJFileDisplayManager getFileDisplayManager30() { return _djFileDisplayManager30; }\n  public static OddDisplayManager getOddDisplayManager20() { return _oddDisplayManager20; }\n  public static OddDisplayManager getOddDisplayManager30() { return _oddDisplayManager30; }\n  public DisplayManager<INavigatorItem> getNavPaneDisplayManager() { return _navPaneDisplayManager; }\n  \n  /* ----------------------- Constructor is here! --------------------------- */\n  \n  /** Creates the main window, and shows it. */ \n  public MainFrame() {    \n    Utilities.invokeAndWait(new Runnable() { public void run() {\n      // Cache the config object, since we use it many, many times.\n      final Configuration config = DrJava.getConfig(); \n      \n      // _historyListener (declared and initialized above) required by new FindReplacePanel(...)\n      assert _historyListener != null;\n      \n      // create our model\n      _model = new DefaultGlobalModel();\n      \n      _showDebugger = _model.getDebugger().isAvailable();\n      _findReplace = new FindReplacePanel(MainFrame.this, _model);\n      \n      // add listeners to activate/deactivate the find/replace actions in MainFrame together with\n      // those in the Find/Replace panel\n      Utilities.enableDisableWith(_findReplace._findNextAction, _findNextAction);\n      Utilities.enableDisableWith(_findReplace._findPreviousAction, _findPrevAction);\n      \n      if (_showDebugger) {\n        _debugPanel = new DebugPanel(MainFrame.this);\n        _breakpointsPanel = new BreakpointsPanel(MainFrame.this, _model.getBreakpointManager());\n      }\n      else {\n        _debugPanel = null;\n        _breakpointsPanel = null; \n      }\n      \n      _compilerErrorPanel = new CompilerErrorPanel(_model, MainFrame.this);\n      _consoleController = new ConsoleController(_model.getConsoleDocument(), _model.getSwingConsoleDocument());\n      _consolePane = _consoleController.getPane();\n      \n      _consoleScroll = new BorderlessScrollPane(_consolePane) {\n        public boolean requestFocusInWindow() { \n          super.requestFocusInWindow();\n          return _consolePane.requestFocusInWindow(); \n        } \n      };\n      \n      _interactionsController =\n        new InteractionsController(_model.getInteractionsModel(),\n                                   _model.getSwingInteractionsDocument(),\n                                   new Runnable() {\n        public void run() {\n          _closeSystemInAction.setEnabled(false);\n        }\n      });\n      \n      _interactionsPane = _interactionsController.getPane();\n      \n      _interactionsContainer = new JPanel(new BorderLayout());\n      _lastFocusOwner = _interactionsContainer;\n      \n      _junitPanel = new JUnitPanel(_model, MainFrame.this);\n      _javadocErrorPanel = new JavadocErrorPanel(_model, MainFrame.this);\n      \n      _bookmarksPanel = new BookmarksPanel(MainFrame.this, _model.getBookmarkManager());\n      \n      // Initialize the status bar\n      _setUpStatusBar();\n      \n      // Preliminary layout\n      \n      /* Definitions Pane */\n      \n      /* Ensure that DefinitionsPane uses the correct EditorKit!  This has to be stored as a static field on \n       * DefinitionsPane because the JEditorPane constructor uses it before we get a chance to assign it to an instance\n       * field ... */\n      DefinitionsPane.setEditorKit(_model.getEditorKit());\n      \n      _defScrollPanes = new HashMap<OpenDefinitionsDocument, JScrollPane>();\n      \n      /* Set up tabbed pane and navigation pane. */\n      _tabbedPane.setFocusable(false);\n      \n      _tabbedPane.addFocusListener(_focusListenerForRecentDocs);\n      _tabbedPane.addKeyListener(_historyListener);    // TODO: can this code be moved to the MainFrame keymap?\n      \n      if (Utilities.isPlasticLaf()) {\n        _tabbedPane.putClientProperty(com.jgoodies.looks.Options.EMBEDDED_TABS_KEY, Boolean.TRUE);\n      }\n      \n      JScrollPane defScroll = _createDefScrollPane(_model.getActiveDocument());\n      \n      _docSplitPane = \n        new BorderlessSplitPane(JSplitPane.HORIZONTAL_SPLIT, true,\n                                new JScrollPane(_model.getDocumentNavigator().asContainer()), defScroll);\n      _debugSplitPane = new BorderlessSplitPane(JSplitPane.VERTICAL_SPLIT, true);\n      _mainSplit = new JSplitPane(JSplitPane.VERTICAL_SPLIT, true, _docSplitPane, _tabbedPane);\n// Lightweight parsing has been disabled until we have something that is beneficial and works better in the background.\n//    // The OptionListener for LIGHTWEIGHT_PARSING_ENABLED.\n//    OptionListener<Boolean> parsingEnabledListener = new OptionListener<Boolean>() {\n//      public void optionChanged(OptionEvent<Boolean> oce) {\n//        if (oce.value) {\n//          _model.getParsingControl().addListener(new LightWeightParsingListener() {\n//            public void enclosingClassNameUpdated(OpenDefinitionsDocument doc, String old, String updated) {\n//              if (doc == _model.getActiveDocument()) { updateStatusField(); }\n//            }\n//          });\n//        }\n//        _model.getParsingControl().reset();\n//        _model.getParsingControl().setAutomaticUpdates(oce.value);\n//        updateStatusField();\n//      }\n//    };\n//    DrJava.getConfig().addOptionListener(LIGHTWEIGHT_PARSING_ENABLED, parsingEnabledListener);\n//    parsingEnabledListener.\n//      optionChanged(new OptionEvent<Boolean>(LIGHTWEIGHT_PARSING_ENABLED, \n//                                             DrJava.getConfig().\n//                                               getSetting(LIGHTWEIGHT_PARSING_ENABLED).booleanValue()));\n//    \n//    Utilities.show(\"Global Model started\");\n      \n      _model.getDocumentNavigator().asContainer().addKeyListener(_historyListener);\n      _model.getDocumentNavigator().asContainer().addFocusListener(_focusListenerForRecentDocs);\n      \n      /* Listens for clicks in the document navigator to reset the first document in an all-documents search for wrapping\n       * purposes. */\n      _model.getDocumentNavigator().asContainer().addMouseListener(_resetFindReplaceListener);\n      \n      if (_showDebugger) _model.getDebugger().addListener(new UIDebugListener()); // add listener to debug manager\n      \n      // Timer to display a message if a debugging step takes a long time\n      _debugStepTimer = new Timer(DEBUG_STEP_TIMER_VALUE, new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          _model.printDebugMessage(\"Stepping...\");\n        }\n      });\n      _debugStepTimer.setRepeats(false);\n      \n      // Working directory is default place to start (bug #895998).\n      File workDir = _model.getMasterWorkingDirectory();\n      \n      // Overrides JFileChooser to display the full path of the directory\n      _openChooser = new JFileChooser() {\n        public void setCurrentDirectory(File dir) {\n          //next two lines are order dependent!\n          super.setCurrentDirectory(dir);\n          setDialogTitle(\"Open:  \" + getCurrentDirectory());\n        }\n      };\n      _openChooser.setPreferredSize(new Dimension(650, 410));\n      _openChooser.setCurrentDirectory(workDir);\n      _openChooser.setFileFilter(_javaSourceFilter);\n      _openChooser.setMultiSelectionEnabled(true);\n      \n      _openRecursiveCheckBox.setSelected(config.getSetting(OptionConstants.OPEN_FOLDER_RECURSIVE).booleanValue());\n      \n      _folderChooser = makeFolderChooser(workDir);\n      \n      //Get most recently opened project for filechooser\n      Vector<File> recentProjects = config.getSetting(RECENT_PROJECTS);\n      _openProjectChooser = new JFileChooser();\n      _openProjectChooser.setPreferredSize(new Dimension(650, 410));\n      \n      if (recentProjects.size() > 0 && recentProjects.elementAt(0).getParentFile() != null)\n        _openProjectChooser.setCurrentDirectory(recentProjects.elementAt(0).getParentFile());\n      else\n        _openProjectChooser.setCurrentDirectory(workDir);\n      \n      _openProjectChooser.setFileFilter(_projectFilter);\n      _openProjectChooser.setMultiSelectionEnabled(false);\n      _saveChooser = new JFileChooser() {\n        public void setCurrentDirectory(File dir) {\n          //next two lines are order dependent!\n          super.setCurrentDirectory(dir);\n          setDialogTitle(\"Save:  \" + getCurrentDirectory());\n        }\n      };\n      _saveChooser.setPreferredSize(new Dimension(650, 410));\n      _saveChooser.setCurrentDirectory(workDir);\n      _saveChooser.setFileFilter(_javaSourceFilter);\n      \n      _interactionsHistoryChooser.setPreferredSize(new Dimension(650, 410));\n      _interactionsHistoryChooser.setCurrentDirectory(workDir);\n      _interactionsHistoryChooser.setFileFilter(new InteractionsHistoryFilter());\n      _interactionsHistoryChooser.setMultiSelectionEnabled(true);\n      \n      //set up the hourglass cursor\n      setGlassPane(new GlassPane());\n      setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);\n      \n      // Set up listeners\n      addWindowListener(_windowCloseListener);\n      \n      // Create the main model listener and attach it to the global model\n      _mainListener = new ModelListener();\n      _model.addListener(_mainListener);\n      \n      // Initialize tabs before DefPane\n      _setUpTabs();\n      \n      // DefinitionsPane\n      _recentDocFrame = new RecentDocFrame(MainFrame.this);\n      OpenDefinitionsDocument activeDoc = _model.getActiveDocument();\n      _recentDocFrame.pokeDocument(activeDoc);\n      _currentDefDoc = activeDoc.getDocument();\n      _currentDefPane = (DefinitionsPane) defScroll.getViewport().getView();\n      _currentDefPane.notifyActive();\n      _currentDefPane.addFocusListener(_undoRedoDefinitionsFocusListener);\n      \n      // Get proper cross-platform mask.\n      int mask = Toolkit.getDefaultToolkit().getMenuShortcutKeyMask();\n      \n      // set up key-bindings\n      KeyBindingManager.ONLY.setMainFrame(MainFrame.this);\n      _setUpKeyBindingMaps();\n      \n      _posListener.updateLocation();\n      \n      // Need to set undo/redo actions to point to the initial def pane\n      // on switching documents later these pointers will also switch\n      _undoAction.setDelegatee(_currentDefPane.getUndoAction());\n      _redoAction.setDelegatee(_currentDefPane.getRedoAction());  \n      \n      _compilerErrorPanel.reset();\n      _junitPanel.reset();\n      _javadocErrorPanel.reset();\n      \n      // Create menubar and menus\n      _fileMenu = _setUpFileMenu(mask, true);\n      _editMenu = _setUpEditMenu(mask, true);\n      _toolsMenu = _setUpToolsMenu(mask, true);\n      _projectMenu = _setUpProjectMenu(mask, true);\n      _debugMenu = null;\n      if (_showDebugger) _debugMenu = _setUpDebugMenu(mask, true);\n      MainFrame obj = null;\n      _languageLevelMenu = _folderChooser._setUpLanguageLevelMenu(obj, mask, true);\n      _helpMenu = _setUpHelpMenu(mask, true);\n      \n      // initialize menu bar and actions\n      _setUpActions();\n      _setUpMenuBar(_menuBar,\n                    _fileMenu, _editMenu, _toolsMenu, _projectMenu, _debugMenu, _languageLevelMenu, _helpMenu);\n      setJMenuBar(_menuBar);\n      \n      //    _setUpDocumentSelector();\n      _setUpContextMenus();\n      \n      // Create toolbar and buttons\n      _undoButton = _createManualToolbarButton(_undoAction);\n      _redoButton = _createManualToolbarButton(_redoAction);\n      \n      // initialize _toolBar\n      _setUpToolBar();\n      \n      // Set up GUI component availability\n      _setUpGUIComponentAvailability();\n      \n      // add recent file and project manager\n      RecentFileAction fileAct = new RecentFileManager.RecentFileAction() { \n        public void actionPerformed(FileOpenSelector selector) { open(selector); }\n      }; \n      _recentFileManager = new RecentFileManager(_fileMenu.getItemCount() - 2, _fileMenu,\n                                                 fileAct, OptionConstants.RECENT_FILES);\n      \n      RecentFileAction projAct = new RecentFileManager.RecentFileAction() { \n        public void actionPerformed(FileOpenSelector selector) { openProject(selector); } \n      };\n      _recentProjectManager = new RecentFileManager(_projectMenu.getItemCount() - 2, _projectMenu,\n                                                    projAct, OptionConstants.RECENT_PROJECTS);\n      \n      _tabbedPanesFrame = new DetachedFrame(\"Tabbed Panes\", MainFrame.this, new Runnable1<DetachedFrame>() {\n        public void run(DetachedFrame frame) {\n          frame.getContentPane().add(_tabbedPane);\n        }\n      }, new Runnable1<DetachedFrame>() {\n        public void run(DetachedFrame frame) {\n          _mainSplit.setBottomComponent(_tabbedPane);\n        }\n      });\n      _tabbedPanesFrame.addWindowListener(new WindowAdapter() {\n        public void windowClosing(WindowEvent we) {\n          _detachTabbedPanesMenuItem.setSelected(false);\n          DrJava.getConfig().setSetting(DETACH_TABBEDPANES, false);\n        }\n      });\n      \n      // set up the menu bars on other frames\n      _tabbedPanesFrame.setUpMenuBar();\n      \n      // Create detachable debug frame\n      if (_debugPanel != null) { // using debugger\n        _debugFrame = new DetachedFrame(\"Debugger\", MainFrame.this, new Runnable1<DetachedFrame>() {\n          public void run(DetachedFrame frame) {\n            frame.getContentPane().add(_debugPanel);\n          }\n        }, new Runnable1<DetachedFrame>() {\n          public void run(DetachedFrame frame) {\n            _debugSplitPane.setTopComponent(_docSplitPane);\n            _debugSplitPane.setBottomComponent(_debugPanel);\n            _mainSplit.setTopComponent(_debugSplitPane);\n          }\n        });\n        _debugFrame.addWindowListener(new WindowAdapter() {\n          public void windowClosing(WindowEvent we) {\n            if (_debugFrame == null) return; // debugger not used\n            _detachDebugFrameMenuItem.setSelected(false);\n            DrJava.getConfig().setSetting(DETACH_DEBUGGER, false);\n          }\n        });\n        _debugFrame.setUpMenuBar();\n      }\n      else { // not using debugger\n        _debugFrame = null;\n      }\n      \n      // Set frame icon\n      setIconImage(getIcon(\"drjava64.png\").getImage());\n      \n      // Size and position\n      int x = config.getSetting(WINDOW_X).intValue();\n      int y = config.getSetting(WINDOW_Y).intValue();\n      int width = config.getSetting(WINDOW_WIDTH).intValue();\n      int height = config.getSetting(WINDOW_HEIGHT).intValue();\n      int state = config.getSetting(WINDOW_STATE).intValue();\n      \n      // Bounds checking.\n      // suggested from zaq@nosi.com, to keep the frame on the screen!\n      Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n      \n      final int menubarHeight = 24;\n      if (height > screenSize.height - menubarHeight)  height = screenSize.height - menubarHeight; // Too tall, so resize\n      \n      if (width > screenSize.width)  width = screenSize.width; // Too wide, so resize\n      \n      // I assume that we want to be contained on the default screen.\n      // TODO: support spanning screens in multi-screen setups.\n      Rectangle bounds = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().\n        getDefaultConfiguration().getBounds();\n      \n      if (x == Integer.MAX_VALUE)  x = (bounds.width - width + bounds.x) / 2;    // magic value for \"not set\" - center.\n      if (y == Integer.MAX_VALUE)  y = (bounds.height - height + bounds.y) / 2;  // magic value for \"not set\" - center.\n      if (x < bounds.x)  x = bounds.x;                                           // Too far left, move to left edge.\n      if (y < bounds.y)  y = bounds.y;                                           // Too far up, move to top edge.\n      if ((x + width) > (bounds.x + bounds.width))  x = bounds.width - width + bounds.x; \n      // Too far right, move to right edge.\n      if ((y + height) > (bounds.y + bounds.height))  y = bounds.height - height + bounds.y; \n      // Too far down, move to bottom edge.\n      \n      //ensure that we don't set window state to minimized\n      state &= ~Frame.ICONIFIED;\n      \n      if (!Toolkit.getDefaultToolkit().isFrameStateSupported(state)) {\n        //we have a bad state, so reset to default\n        state = WINDOW_STATE.getDefault();\n      }\n      \n      // Set to the new correct size and location\n      setBounds(x, y, width, height);\n      \n      //Work-aroung for Java bug #6365898?\n      //setExtendedState does not work until the window in shown on Linux.\n      final int stateCopy = state;\n      addWindowListener(new WindowAdapter() {\n        public void windowOpened(WindowEvent e) {\n          setExtendedState(stateCopy);\n          //this is a one-off listener\n          removeWindowListener(this);\n        }\n      });\n      \n      _setUpPanes();\n      updateStatusField();\n      \n      _promptBeforeQuit = config.getSetting(QUIT_PROMPT).booleanValue();\n      \n      // Set the fonts\n      _setMainFont();\n      Font doclistFont = config.getSetting(FONT_DOCLIST);\n      _model.getDocCollectionWidget().setFont(doclistFont);\n      \n      // Set the colors\n      _updateNormalColor();\n      _updateBackgroundColor();\n      \n      // Add OptionListeners for the colors.\n      config.addOptionListener(DEFINITIONS_NORMAL_COLOR, new NormalColorOptionListener());\n      config.addOptionListener(DEFINITIONS_BACKGROUND_COLOR, new BackgroundColorOptionListener());\n      \n      /* Add option listeners for changes to config options.  NOTE: We should only add listeners to view-related (or view-\n       * dependent) config options here.  Model options should go in DefaultGlobalModel._registerOptionListeners(). */\n      config.addOptionListener(FONT_MAIN, new MainFontOptionListener());\n      config.addOptionListener(FONT_LINE_NUMBERS, new LineNumbersFontOptionListener());\n      config.addOptionListener(FONT_DOCLIST, new DoclistFontOptionListener());\n      config.addOptionListener(FONT_TOOLBAR, new ToolbarFontOptionListener());\n      config.addOptionListener(TOOLBAR_ICONS_ENABLED, new ToolbarOptionListener());\n      config.addOptionListener(TOOLBAR_TEXT_ENABLED, new ToolbarOptionListener());\n      config.addOptionListener(TOOLBAR_ENABLED, new ToolbarOptionListener());\n      config.addOptionListener(LINEENUM_ENABLED, new LineEnumOptionListener());\n      config.addOptionListener(DEFINITIONS_LINE_NUMBER_COLOR, new LineEnumColorOptionListener());\n      config.addOptionListener(DEFINITIONS_LINE_NUMBER_BACKGROUND_COLOR, new LineEnumColorOptionListener());\n      config.addOptionListener(QUIT_PROMPT, new QuitPromptOptionListener());\n      config.addOptionListener(RECENT_FILES_MAX_SIZE, new RecentFilesOptionListener());\n      \n      config.addOptionListener(FORCE_TEST_SUFFIX, new OptionListener<Boolean>() {\n        public void optionChanged(OptionEvent<Boolean> oce) {\n          _model.getJUnitModel().setForceTestSuffix(oce.value.booleanValue());\n        }\n      });\n      \n      // The OptionListener for JAVADOC_API_REF_VERSION.\n      OptionListener<String> choiceOptionListener = new OptionListener<String>() {\n        public void optionChanged(OptionEvent<String> oce) {\n          clearJavaAPISet();\n        }\n      };\n      DrJava.getConfig().addOptionListener(JAVADOC_API_REF_VERSION, choiceOptionListener);\n      \n      // The OptionListener for JAVADOC_XXX_LINK.\n      OptionListener<String> link13OptionListener = new OptionListener<String>() {\n        public void optionChanged(OptionEvent<String> oce) {\n          String linkVersion = DrJava.getConfig().getSetting(JAVADOC_API_REF_VERSION);\n          if (linkVersion.equals(JAVADOC_1_3_TEXT)) {\n            clearJavaAPISet();\n          }\n        }\n      };\n      DrJava.getConfig().addOptionListener(JAVADOC_1_3_LINK, link13OptionListener);\n      OptionListener<String> link14OptionListener = new OptionListener<String>() {\n        public void optionChanged(OptionEvent<String> oce) {\n          String linkVersion = DrJava.getConfig().getSetting(JAVADOC_API_REF_VERSION);\n          if (linkVersion.equals(JAVADOC_1_4_TEXT)) {\n            clearJavaAPISet();\n          }\n        }\n      };\n      DrJava.getConfig().addOptionListener(JAVADOC_1_4_LINK, link14OptionListener);\n      OptionListener<String> link15OptionListener = new OptionListener<String>() {\n        public void optionChanged(OptionEvent<String> oce) {\n          String linkVersion = DrJava.getConfig().getSetting(JAVADOC_API_REF_VERSION);\n          if (linkVersion.equals(JAVADOC_1_5_TEXT)) {\n            clearJavaAPISet();\n          }\n        }\n      };\n      DrJava.getConfig().addOptionListener(JAVADOC_1_5_LINK, link15OptionListener);\n      OptionListener<String> link16OptionListener = new OptionListener<String>() {\n        public void optionChanged(OptionEvent<String> oce) {\n          String linkVersion = DrJava.getConfig().getSetting(JAVADOC_API_REF_VERSION);\n          if (linkVersion.equals(JAVADOC_1_6_TEXT)) {\n            clearJavaAPISet();\n          }\n        }\n      };\n      DrJava.getConfig().addOptionListener(JAVADOC_1_6_LINK, link16OptionListener);\n      OptionListener<String> linkJUnitOptionListener = new OptionListener<String>() {\n        public void optionChanged(OptionEvent<String> oce) {\n          clearJavaAPISet();\n        }\n      };\n      DrJava.getConfig().addOptionListener(JUNIT_LINK, linkJUnitOptionListener);\n      OptionListener<Vector<String>> additionalLinkOptionListener = new OptionListener<Vector<String>>() {\n        public void optionChanged(OptionEvent<Vector<String>> oce) {\n          clearJavaAPISet();\n        }\n      };\n      DrJava.getConfig().addOptionListener(JAVADOC_ADDITIONAL_LINKS, additionalLinkOptionListener);\n      OptionListener<Boolean> scanClassesOptionListener = new OptionListener<Boolean>() {\n        public void optionChanged(OptionEvent<Boolean> oce) {\n          clearCompleteClassSet();\n        }\n      };\n      DrJava.getConfig().addOptionListener(DIALOG_COMPLETE_SCAN_CLASS_FILES, scanClassesOptionListener);\n      \n      // Initialize cached frames and dialogs \n      _configFrame = new ConfigFrame(MainFrame.this);\n      _aboutDialog = new AboutDialog(MainFrame.this);\n      _interactionsScriptController = null;\n      _executeExternalDialog = new ExecuteExternalDialog(MainFrame.this);\n      _editExternalDialog = new EditExternalDialog(MainFrame.this);\n      _jarOptionsDialog = new JarOptionsDialog(MainFrame.this);\n      \n      initTabbedPanesFrame();\n      initDebugFrame();\n      initJarOptionsDialog();\n      initExecuteExternalProcessDialog();\n//    _projectPropertiesFrame = null;\n      \n      config.addOptionListener(DISPLAY_ALL_COMPILER_VERSIONS, \n                               new ConfigOptionListeners.DisplayAllCompilerVersionsListener(_configFrame));\n      config.addOptionListener(LOOK_AND_FEEL, new ConfigOptionListeners.LookAndFeelListener(_configFrame));\n      config.addOptionListener(PLASTIC_THEMES, new ConfigOptionListeners.PlasticThemeListener(_configFrame));\n      OptionListener<String> slaveJVMArgsListener = new ConfigOptionListeners.SlaveJVMArgsListener(_configFrame);\n      config.addOptionListener(SLAVE_JVM_ARGS, slaveJVMArgsListener);\n      _slaveJvmXmxListener = new ConfigOptionListeners.SlaveJVMXMXListener(_configFrame);\n      config.addOptionListener(SLAVE_JVM_XMX, _slaveJvmXmxListener);\n      OptionListener<String> masterJVMArgsListener = new ConfigOptionListeners.MasterJVMArgsListener(_configFrame);\n      config.addOptionListener(MASTER_JVM_ARGS, masterJVMArgsListener);\n      _masterJvmXmxListener = new ConfigOptionListeners.MasterJVMXMXListener(_configFrame);\n      config.addOptionListener(MASTER_JVM_XMX, _masterJvmXmxListener);\n      config.addOptionListener(JAVADOC_CUSTOM_PARAMS, \n                               new ConfigOptionListeners.JavadocCustomParamsListener(_configFrame));\n      ConfigOptionListeners.sanitizeSlaveJVMArgs(MainFrame.this, config.getSetting(SLAVE_JVM_ARGS), slaveJVMArgsListener);\n      ConfigOptionListeners.sanitizeSlaveJVMXMX(MainFrame.this, config.getSetting(SLAVE_JVM_XMX));\n      ConfigOptionListeners.sanitizeMasterJVMArgs(MainFrame.this, config.getSetting(MASTER_JVM_ARGS), masterJVMArgsListener);\n      ConfigOptionListeners.sanitizeMasterJVMXMX(MainFrame.this, config.getSetting(MASTER_JVM_XMX));\n      ConfigOptionListeners.sanitizeJavadocCustomParams(MainFrame.this, config.getSetting(JAVADOC_CUSTOM_PARAMS));\n      config.addOptionListener(REMOTE_CONTROL_ENABLED, new ConfigOptionListeners.\n                                 RequiresDrJavaRestartListener<Boolean>(_configFrame, \"Remote Control\"));\n      config.addOptionListener(REMOTE_CONTROL_PORT, new ConfigOptionListeners.\n                                 RequiresDrJavaRestartListener<Integer>(_configFrame, \"Remote Control Port\"));\n      config.addOptionListener(DEFAULT_COMPILER_PREFERENCE, new ConfigOptionListeners.DefaultCompilerListener(_configFrame));\n      // If any errors occurred while parsing config file, show them\n      _showConfigException();\n      \n      KeyBindingManager.ONLY.setShouldCheckConflict(false);\n      \n      // Platform-specific UI setup.\n      PlatformFactory.ONLY.afterUISetup(_aboutAction, _editPreferencesAction, _quitAction);\n      setUpKeys();    \n      \n      // discard ` character if it was used for the next/prev recent doc feature\n      KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(new KeyEventDispatcher() {\n        public boolean dispatchKeyEvent(KeyEvent e) {\n          boolean discardEvent = false;\n          \n          if ((e.getID() == KeyEvent.KEY_TYPED) &&\n              (e.getKeyChar() == '`') &&\n              (((e.getModifiersEx() & InputEvent.CTRL_DOWN_MASK) == InputEvent.CTRL_DOWN_MASK) ||\n               ((e.getModifiersEx() & (InputEvent.CTRL_DOWN_MASK|InputEvent.SHIFT_DOWN_MASK))\n                  == (InputEvent.CTRL_DOWN_MASK|InputEvent.SHIFT_DOWN_MASK))) &&\n              (e.getComponent().getClass().equals(DefinitionsPane.class))) {\n//          System.out.println(\"discarding `, modifiers = \"+e.getModifiersEx()+\": \"+e.getComponent());\n            discardEvent = true;\n          }\n          return discardEvent;\n        }\n      });\n      \n      if (DrJava.getConfig().getSetting(edu.rice.cs.drjava.config.OptionConstants.REMOTE_CONTROL_ENABLED)) {\n        // start remote control server if no server is running\n        try {\n          if (! RemoteControlClient.isServerRunning()) {\n            new RemoteControlServer(MainFrame.this);\n          }\n        }\n        catch(IOException ioe) {\n          try { RemoteControlClient.openFile(null); }\n          catch(IOException ignored) { /* ignore */ }\n          if (!Utilities.TEST_MODE && !System.getProperty(\"user.name\").equals(RemoteControlClient.getServerUser())) {\n            Object[] options = {\"Disable\",\"Ignore\"};\n            String msg = \"<html>Could not start DrJava's remote control server\";\n            if (RemoteControlClient.getServerUser() != null) {\n              msg += \"<br>because user \"+RemoteControlClient.getServerUser()+\" is already using the same port\";\n            }\n            msg += \".<br>Please select an unused port in the Preferences dialog.<br>\"+\n              \"In the meantime, do you want to disable the remote control feature?\";\n            int n = JOptionPane.showOptionDialog(MainFrame.this,\n                                                 msg,\n                                                 \"Could Not Start Remote Control Server\",\n                                                 JOptionPane.YES_NO_OPTION,\n                                                 JOptionPane.QUESTION_MESSAGE,\n                                                 null,\n                                                 options,\n                                                 options[1]);\n            if (n==JOptionPane.YES_OPTION) {\n              DrJava.getConfig().setSetting(edu.rice.cs.drjava.config.OptionConstants.REMOTE_CONTROL_ENABLED, false);\n            }\n          }\n        }\n      }\n      \n      setUpDrJavaProperties();  \n      \n      DrJavaErrorHandler.setButton(_errorsButton);\n      \n      // check file associations if desired by user\n      boolean alreadyShowedDialog = false;\n      if (PlatformFactory.ONLY.canRegisterFileExtensions()) {\n        // only try to register file extensions if this platform supports it\n        if (DrJava.getConfig().getSetting(OptionConstants.FILE_EXT_REGISTRATION)\n              .equals(OptionConstants.FILE_EXT_REGISTRATION_CHOICES.get(2))) { // Always\n          // always set file associations\n          PlatformFactory.ONLY.registerDrJavaFileExtensions();\n          PlatformFactory.ONLY.registerJavaFileExtension();\n        }\n        else if (DrJava.getConfig().getSetting(OptionConstants.FILE_EXT_REGISTRATION)\n                   .equals(OptionConstants.FileExtRegistrationChoices.ASK_ME) && // Ask me\n                 !edu.rice.cs.util.swing.Utilities.TEST_MODE &&\n                 ((!PlatformFactory.ONLY.areDrJavaFileExtensionsRegistered()) ||\n                  (!PlatformFactory.ONLY.isJavaFileExtensionRegistered()))) {\n          alreadyShowedDialog = true;\n          EventQueue.invokeLater(new Runnable() {\n            public void run() {\n              int rc;\n              Object[] options = {\"Yes\", \"No\", \"Always\", \"Never\"};\n              String text = \"Do you want to associate .java, .drjava and .djapp files with DrJava?\\n\" + \n                \"Double-clicking on those files will open them in DrJava.\\n\\n\" +\n                \"Select 'Always' to let DrJava do this automatically.\\n\"+\n                \"Select 'Never' if you don't want to be asked again.\\n\\n\"+\n                \"You can change this setting in the Preferences dialog under\\n\"+\n                \"Miscellaneous/File Types.\";\n              \n              rc = JOptionPane.showOptionDialog(MainFrame.this, text, \"Set File Associations?\", JOptionPane.YES_NO_OPTION,\n                                                JOptionPane.QUESTION_MESSAGE, null, options, options[0]);\n              if ((rc == 0) || (rc==2)) { // Yes or Always\n                PlatformFactory.ONLY.registerDrJavaFileExtensions();\n                PlatformFactory.ONLY.registerJavaFileExtension();\n              }\n              if (rc==2) { // Always\n                DrJava.getConfig().setSetting(OptionConstants.FILE_EXT_REGISTRATION,\n                                              OptionConstants.FILE_EXT_REGISTRATION_CHOICES.get(2));\n              }\n              if (rc==3) { // Never\n                DrJava.getConfig().setSetting(OptionConstants.FILE_EXT_REGISTRATION,\n                                              OptionConstants.FILE_EXT_REGISTRATION_CHOICES.get(0));\n              }\n            }\n          });\n        }\n      }\n      \n      if (!alreadyShowedDialog) {\n        // check for new version if desired by user\n        // but only if we haven't just asked if the user wants to download a new version\n        // two dialogs on program start is too much clutter    \n        if (DrJava.getConfig().getSetting(OptionConstants.NEW_VERSION_ALLOWED) &&\n            !DrJava.getConfig().getSetting(OptionConstants.NEW_VERSION_NOTIFICATION)\n              .equals(OptionConstants.VersionNotificationChoices.DISABLED) &&\n            !edu.rice.cs.util.swing.Utilities.TEST_MODE) {\n          int days = DrJava.getConfig().getSetting(NEW_VERSION_NOTIFICATION_DAYS);\n          java.util.Date nextCheck = \n            new java.util.Date(DrJava.getConfig().getSetting(OptionConstants.LAST_NEW_VERSION_NOTIFICATION)\n                                 + days * 24L * 60 * 60 * 1000); // x days after last check; 24L ensures long accumulation\n          if (new java.util.Date().after(nextCheck)) {\n            alreadyShowedDialog = true;\n            EventQueue.invokeLater(new Runnable() {\n              public void run() {\n                NewVersionPopup popup = new NewVersionPopup(MainFrame.this);\n                if (popup.checkNewVersion()) { popup.setVisible(true); }\n              }\n            });\n          }\n        }\n      }\n      if (!alreadyShowedDialog) {\n        // ask if the user wants to submit the survey\n        // but only if we haven't just asked if the user wants to download a new version\n        // two dialogs on program start is too much clutter\n        if (DrJava.getConfig().getSetting(DIALOG_DRJAVA_SURVEY_ENABLED) && \n            ! edu.rice.cs.util.swing.Utilities.TEST_MODE) {\n          if (DrJavaSurveyPopup.maySubmitSurvey()) {\n            // either enough days have passed, or the configuration has changed\n            alreadyShowedDialog = true;\n            EventQueue.invokeLater(new Runnable() {\n              public void run() {\n                DrJavaSurveyPopup popup = new DrJavaSurveyPopup(MainFrame.this);\n                popup.setVisible(true);\n              }\n            });\n          }\n        }\n      }\n      \n      initDone();  // call mandated by SwingFrame contract\n      \n      EventQueue.invokeLater(new Runnable() {\n        public void run() {\n          _tabbedPanesFrame.setDisplayInFrame(DrJava.getConfig().getSetting(DETACH_TABBEDPANES));\n        }\n      });\n    } });\n  }   // End of MainFrame constructor\n  \n  public void setVisible(boolean b) { \n    _updateToolBarVisible();\n    super.setVisible(b); \n  }\n  \n  /** This method sets up all the DrJava properties that can be used as variables\n    * in external process command lines. */\n  public void setUpDrJavaProperties() {\n    final String DEF_DIR = \"${drjava.working.dir}\";\n    \n    DrJavaPropertySetup.setup(); \n    \n    // Files\n    PropertyMaps.TEMPLATE.\n      setProperty(\"DrJava\", \n                  new FileProperty(\"drjava.current.file\", new Thunk<File>() {\n      public File value() { return _model.getActiveDocument().getRawFile(); }\n    }, \n                                   \"Returns the current document in DrJava.\\n\"+\n                                   \"Optional attributes:\\n\"+\n                                   \"\\trel=\\\"<dir to which the output should be relative\\\"\\n\"+\n                                   \"\\tsquote=\\\"<true to enclose file in single quotes>\\\"\\n\"+\n                                   \"\\tdquote=\\\"<true to enclose file in double quotes>\\\"\") {\n                                     public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n                                   });\n    PropertyMaps.TEMPLATE.setProperty(\"DrJava\", \n                                      new DrJavaProperty(\"drjava.current.line\", \n                                                         \"Returns the current line in the Definitions Pane.\") {\n      public void update(PropertyMaps pm) { _value = String.valueOf(_posListener.lastLine()); }\n      public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n      public boolean isCurrent() { return false; }\n    });\n    PropertyMaps.TEMPLATE.\n      setProperty(\"DrJava\", new DrJavaProperty(\"drjava.current.col\",\n                                               \"Returns the current column in the Definitions Pane.\") {\n      public void update(PropertyMaps pm) {\n//        int line = _currentDefPane.getCurrentLine();\n//        int lineOffset = _currentDefPane.getLineStartOffset(line);\n//        int caretPos = _currentDefPane.getCaretPosition();\n        _value = String.valueOf(_posListener.lastCol());\n      }\n      public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n      public boolean isCurrent() { return false; }\n    });\n    PropertyMaps.TEMPLATE.\n      setProperty(\"DrJava\", \n                  new FileProperty(\"drjava.working.dir\", new Thunk<File>() {\n      public File value() { return _model.getInteractionsModel().getWorkingDirectory(); }\n    },\n                                   \"Returns the current working directory of DrJava.\\n\"+\n                                   \"Optional attributes:\\n\"+\n                                   \"\\trel=\\\"<dir to which output should be relative\\\"\\n\"+\n                                   \"\\tsquote=\\\"<true to enclose file in single quotes>\\\"\\n\"+\n                                   \"\\tdquote=\\\"<true to enclose file in double quotes>\\\"\") {\n                                     public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n                                   });\n    PropertyMaps.TEMPLATE.\n      setProperty(\"DrJava\", \n                  new FileProperty(\"drjava.master.working.dir\", new Thunk<File>() {\n      public File value() { return _model.getMasterWorkingDirectory(); }\n    },\n                                   \"Returns the working directory of the DrJava master JVM.\\n\"+\n                                   \"Optional attributes:\\n\"+\n                                   \"\\trel=\\\"<dir to which output should be relative\\\"\\n\"+\n                                   \"\\tsquote=\\\"<true to enclose file in single quotes>\\\"\\n\"+\n                                   \"\\tdquote=\\\"<true to enclose file in double quotes>\\\"\") {\n                                     public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n                                   });\n    \n    // Files\n    PropertyMaps.TEMPLATE.\n      setProperty(\"DrJava\", \n                  new FileListProperty(\"drjava.all.files\", File.pathSeparator, DEF_DIR,\n                                       \"Returns a list of all files open in DrJava.\\n\"+\n                                       \"Optional attributes:\\n\"+\n                                       \"\\trel=\\\"<dir to which output should be relative\\\"\\n\"+\n                                       \"\\tsep=\\\"<separator between files>\\\"\\n\"+\n                                       \"\\tsquote=\\\"<true to enclose file in single quotes>\\\"\\n\"+\n                                       \"\\tdquote=\\\"<true to enclose file in double quotes>\\\"\") {\n      protected List<File> getList(PropertyMaps pm) {\n        ArrayList<File> l = new ArrayList<File>();\n        for(OpenDefinitionsDocument odd: _model.getOpenDefinitionsDocuments()) {\n          l.add(odd.getRawFile());\n        }\n        return l;\n      }\n      public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n      public boolean isCurrent() { return false; }\n    });\n    PropertyMaps.TEMPLATE.\n      setProperty(\"DrJava\", \n                  new FileListProperty(\"drjava.project.files\", File.pathSeparator, DEF_DIR,\n                                       \"Returns a list of all files open in DrJava that belong \" +\n                                       \"to a project and are underneath the project root.\\n\" +\n                                       \"Optional attributes:\\n\" +\n                                       \"\\trel=\\\"<dir to which output should be relative\\\"\\n\" +\n                                       \"\\tsep=\\\"<separator between files>\\\"\\n\"+\n                                       \"\\tsquote=\\\"<true to enclose file in single quotes>\\\"\\n\"+\n                                       \"\\tdquote=\\\"<true to enclose file in double quotes>\\\"\") {\n      protected List<File> getList(PropertyMaps pm) {\n        ArrayList<File> l = new ArrayList<File>();\n        for(OpenDefinitionsDocument odd: _model.getProjectDocuments()) {\n          l.add(odd.getRawFile());\n        }\n        return l;\n      }\n      public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n      public boolean isCurrent() { return false; }\n    }).listenToInvalidatesOf(PropertyMaps.TEMPLATE.getProperty(\"DrJava\", \"drjava.all.files\"));\n    PropertyMaps.TEMPLATE.\n      setProperty(\"DrJava\", \n                  new FileListProperty(\"drjava.included.files\", File.pathSeparator, DEF_DIR,\n                                       \"Returns a list of all files open in DrJava that are \" +\n                                       \"not underneath the project root but are included in \" +\n                                       \"the project.\\n\" +\n                                       \"Optional attributes:\\n\" +\n                                       \"\\trel=\\\"<dir to which output should be relative\\\"\\n\" +\n                                       \"\\tsep=\\\"<separator between files>\\\"\\n\"+\n                                       \"\\tsquote=\\\"<true to enclose file in single quotes>\\\"\\n\"+\n                                       \"\\tdquote=\\\"<true to enclose file in double quotes>\\\"\") {\n      protected List<File> getList(PropertyMaps pm) {\n        ArrayList<File> l = new ArrayList<File>();\n        for(OpenDefinitionsDocument odd: _model.getAuxiliaryDocuments()) {\n          l.add(odd.getRawFile());\n        }\n        return l;\n      }\n      public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n      public boolean isCurrent() { return false; }\n    }).listenToInvalidatesOf(PropertyMaps.TEMPLATE.getProperty(\"DrJava\", \"drjava.all.files\"));\n    PropertyMaps.TEMPLATE.\n      setProperty(\"DrJava\", \n                  new FileListProperty(\"drjava.external.files\", File.pathSeparator, DEF_DIR,\n                                       \"Returns a list of all files open in DrJava that are \"+\n                                       \"not underneath the project root and are not included in \"+\n                                       \"the project.\\n\"+\n                                       \"Optional attributes:\\n\"+\n                                       \"\\trel=\\\"<dir to which output should be relative\\\"\\n\"+\n                                       \"\\tsep=\\\"<separator between files>\\\"\\n\"+\n                                       \"\\tsquote=\\\"<true to enclose file in single quotes>\\\"\\n\"+\n                                       \"\\tdquote=\\\"<true to enclose file in double quotes>\\\"\") {\n      protected List<File> getList(PropertyMaps pm) {\n        ArrayList<File> l = new ArrayList<File>();\n        for(OpenDefinitionsDocument odd: _model.getNonProjectDocuments()) {\n          l.add(odd.getRawFile());\n        }\n        return l;\n      }\n      public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n      public boolean isCurrent() { return false; }\n    }).listenToInvalidatesOf(PropertyMaps.TEMPLATE.getProperty(\"DrJava\", \"drjava.all.files\"));    \n    \n    PropertyMaps.TEMPLATE.\n      setProperty(\"Misc\", \n                  new DrJavaProperty(\"input\", \"(User Input...)\",\n                                     \"Get an input string from the user.\\n\"+\n                                     \"Optional attributes:\\n\"+\n                                     \"\\tprompt=\\\"<prompt to display>\\\"\\n\"+\n                                     \"\\tdefault=\\\"<suggestion to the user>\\\"\") {\n      public String toString() {\n        return \"(User Input...)\";\n      }\n      public void update(PropertyMaps pm) {\n        String msg = _attributes.get(\"prompt\");\n        if (msg == null) msg = \"Please enter text for the external process.\";\n        String input = _attributes.get(\"default\");\n        if (input == null) input = \"\";\n        input = JOptionPane.showInputDialog(MainFrame.this, msg, input);\n        if (input == null) input = _attributes.get(\"default\");\n        if (input == null) input = \"\";\n        _value = input;\n      }\n      public String getCurrent(PropertyMaps pm) {\n        invalidate();\n        return super.getCurrent(pm);\n      }\n      public void resetAttributes() {\n        _attributes.clear();\n        _attributes.put(\"prompt\", null);\n        _attributes.put(\"default\", null);\n      }\n      public boolean isCurrent() { return false; }\n    });\n    \n    // Project\n    PropertyMaps.TEMPLATE.\n      setProperty(\"Project\", \n                  new DrJavaProperty(\"project.mode\",\n                                     \"Evaluates to true if a project is loaded.\") {\n      public void update(PropertyMaps pm) {\n        Boolean b = _model.isProjectActive();\n        String f = _attributes.get(\"fmt\").toLowerCase();\n        if (f.equals(\"int\")) _value = b ? \"1\" : \"0\";\n        else if (f.equals(\"yes\")) _value = b ? \"yes\" : \"no\";\n        else _value = b.toString();\n      }\n      public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n      public void resetAttributes() {\n        _attributes.clear();\n        _attributes.put(\"fmt\", \"boolean\");\n      }\n      public boolean isCurrent() { return false; }\n    });\n    PropertyMaps.TEMPLATE.\n      setProperty(\"Project\", \n                  new DrJavaProperty(\"project.changed\",\n                                     \"Evaluates to true if the project has been \"+\n                                     \"changed since the last save.\") {  //TODO: factor out repeated code!\n      public void update(PropertyMaps pm) {\n//        long millis = System.currentTimeMillis();\n        String f = _attributes.get(\"fmt\").toLowerCase();\n        Boolean b = _model.isProjectChanged();\n        if (f.equals(\"int\")) _value = b ? \"1\" : \"0\";\n        else if (f.equals(\"yes\")) _value = b ? \"yes\" : \"no\";\n        else  _value = b.toString();\n      }\n      public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n      public void resetAttributes() {\n        _attributes.clear();\n        _attributes.put(\"fmt\", \"boolean\");\n      }\n      public boolean isCurrent() { return false; }\n    });\n    PropertyMaps.TEMPLATE.\n      setProperty(\"Project\", \n                  new FileProperty(\"project.file\", \n                                   new Thunk<File>() {\n      public File value() { return _model.getProjectFile(); }\n    },\n                                   \"Returns the current project file in DrJava.\\n\"+\n                                   \"Optional attributes:\\n\"+\n                                   \"\\trel=\\\"<dir to which the output should be relative\\\"\\n\"+\n                                   \"\\tsquote=\\\"<true to enclose file in single quotes>\\\"\\n\"+\n                                   \"\\tdquote=\\\"<true to enclose file in double quotes>\\\"\") {\n                                     public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n                                   });\n    \n    PropertyMaps.TEMPLATE.\n      setProperty(\"Project\", \n                  new FileProperty(\"project.main.class\", \n                                   new Thunk<File>() {\n      public File value() { return new File(_model.getMainClass()); }\n    },\n                                   \"Returns the current project file in DrJava.\\n\"+\n                                   \"Optional attributes:\\n\"+\n                                   \"\\trel=\\\"<dir to which the output should be relative\\\"\\n\"+\n                                   \"\\tsquote=\\\"<true to enclose file in single quotes>\\\"\\n\"+\n                                   \"\\tdquote=\\\"<true to enclose file in double quotes>\\\"\") {\n                                     public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n                                   });\n    PropertyMaps.TEMPLATE.\n      setProperty(\"Project\", \n                  new FileProperty(\"project.root\", \n                                   new Thunk<File>() {\n      public File value() { return _model.getProjectRoot(); }\n    },\n                                   \"Returns the current project root in DrJava.\\n\"+\n                                   \"Optional attributes:\\n\"+\n                                   \"\\trel=\\\"<dir to which the output should be relative\\\"\\n\"+\n                                   \"\\tsquote=\\\"<true to enclose file in single quotes>\\\"\\n\"+\n                                   \"\\tdquote=\\\"<true to enclose file in double quotes>\\\"\") {\n                                     public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n                                   });\n    PropertyMaps.TEMPLATE.\n      setProperty(\"Project\", \n                  new FileProperty(\"project.build.dir\", \n                                   new Thunk<File>() {\n      public File value() { return _model.getBuildDirectory(); }\n    },\n                                   \"Returns the current build directory in DrJava.\\n\"+\n                                   \"Optional attributes:\\n\"+\n                                   \"\\trel=\\\"<dir to which the output should be relative\\\"\\n\"+\n                                   \"\\tsquote=\\\"<true to enclose file in single quotes>\\\"\\n\"+\n                                   \"\\tdquote=\\\"<true to enclose file in double quotes>\\\"\") {\n                                     public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n                                   });\n    RecursiveFileListProperty classFilesProperty = \n      new RecursiveFileListProperty(\"project.class.files\", File.pathSeparator, DEF_DIR,\n                                    _model.getBuildDirectory().getAbsolutePath(),\n                                    \"Returns the class files currently in the build directory.\\n\"+\n                                    \"\\trel=\\\"<dir to which the output should be relative\\\"\\n\"+\n                                    \"\\tsep=\\\"<string to separate files in the list>\\\"\\n\"+\n                                    \"\\tsquote=\\\"<true to enclose file in single quotes>\\\"\\n\"+\n                                    \"\\tdquote=\\\"<true to enclose file in double quotes>\\\"\") {\n      /** Reset the attributes. */\n      public void resetAttributes() {\n        _attributes.clear();\n        _attributes.put(\"sep\", _sep);\n        _attributes.put(\"rel\", _dir);\n        _attributes.put(\"dir\", _model.getBuildDirectory().getAbsolutePath());\n        _attributes.put(\"filter\", \"*.class\");\n        _attributes.put(\"dirfilter\", \"*\");\n      }\n    };\n    PropertyMaps.TEMPLATE.setProperty(\"Project\", classFilesProperty);\n    PropertyMaps.TEMPLATE.\n      setProperty(\"Project\", \n                  new DrJavaProperty(\"project.auto.refresh\",\n                                     \"Evaluates to true if project auto-refresh is enabled.\") {\n      public void update(PropertyMaps pm) {\n        Boolean b = _model.getAutoRefreshStatus();\n        String f = _attributes.get(\"fmt\").toLowerCase();\n        if (f.equals(\"int\")) _value = b ? \"1\" : \"0\";\n        else if (f.equals(\"yes\")) _value = b ? \"yes\" : \"no\";\n        else _value = b.toString();\n      }\n      public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n      public void resetAttributes() {\n        _attributes.clear();\n        _attributes.put(\"fmt\", \"boolean\");\n      }\n      public boolean isCurrent() { return false; }\n    });\n    PropertyMaps.TEMPLATE.\n      setProperty(\"Project\", \n                  new FileListProperty(\"project.excluded.files\", File.pathSeparator, DEF_DIR,\n                                       \"Returns a list of files that are excluded from DrJava's \"+\n                                       \"project auto-refresh.\\n\"+\n                                       \"Optional attributes:\\n\"+\n                                       \"\\trel=\\\"<dir to which output should be relative\\\"\\n\"+\n                                       \"\\tsep=\\\"<separator between files>\\\"\\n\"+\n                                       \"\\tsquote=\\\"<true to enclose file in single quotes>\\\"\\n\"+\n                                       \"\\tdquote=\\\"<true to enclose file in double quotes>\\\"\") {\n      protected List<File> getList(PropertyMaps pm) {\n        ArrayList<File> l = new ArrayList<File>();\n        for(File f: _model.getExclFiles()) { l.add(f); }\n        return l;\n      }\n      public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n      public boolean isCurrent() { return false; }\n    });\n    PropertyMaps.TEMPLATE.\n      setProperty(\"Project\", \n                  new FileListProperty(\"project.extra.class.path\", File.pathSeparator, DEF_DIR,\n                                       \"Returns a list of files in the project's extra \"+\n                                       \"class path.\\n\"+\n                                       \"Optional attributes:\\n\"+\n                                       \"\\trel=\\\"<dir to which output should be relative\\\"\\n\"+\n                                       \"\\tsep=\\\"<separator between files>\\\"\\n\"+\n                                       \"\\tsquote=\\\"<true to enclose file in single quotes>\\\"\\n\"+\n                                       \"\\tdquote=\\\"<true to enclose file in double quotes>\\\"\") {\n      protected List<File> getList(PropertyMaps pm) {\n        ArrayList<File> l = new ArrayList<File>();\n        for(File f: _model.getExtraClassPath()) { l.add(f); }\n        return l;\n      }\n      public String getLazy(PropertyMaps pm) { return getCurrent(pm); }\n      public boolean isCurrent() { return false; }\n    });\n    \n    // Actions\n    PropertyMaps.TEMPLATE.setProperty(\"Action\", new DrJavaActionProperty(\"action.save.all\", \"(Save All...)\",\n                                                                         \"Execute a \\\"Save All\\\" action.\") {\n      public void update(PropertyMaps pm) { _saveAll(); }\n      public boolean isCurrent() { return false; }\n    });\n    PropertyMaps.TEMPLATE.\n      setProperty(\"Action\", new DrJavaActionProperty(\"action.compile.all\", \"(Compile All...)\",\n                                                     \"Execute a \\\"Compile All\\\" action.\") {\n      public void update(PropertyMaps pm) { _compileAll(); }\n      public boolean isCurrent() { return false; }\n    });\n    PropertyMaps.TEMPLATE.\n      setProperty(\"Action\", \n                  new DrJavaActionProperty(\"action.clean\", \"(Clean Build Directory...)\",\n                                           \"Execute a \\\"Clean Build Directory\\\" action.\") {\n      public void update(PropertyMaps pm) {\n        // could not use _clean(), since ProjectFileGroupingState.cleanBuildDirectory()\n        // is implemented as an asynchronous task, and DrJava would not wait for its completion\n        edu.rice.cs.plt.io.IOUtil.deleteRecursively(_model.getBuildDirectory());\n      }\n      public boolean isCurrent() { return false; }\n    });\n    PropertyMaps.TEMPLATE.setProperty(\"Action\", new DrJavaActionProperty(\"action.open.file\", \"(Open File...)\",\n                                                                         \"Execute an \\\"Open File\\\" action.\\n\"+\n                                                                         \"Required attributes:\\n\"+\n                                                                         \"\\tfile=\\\"<file to open>\\\"\\n\"+\n                                                                         \"Optional attributes:\\n\"+\n                                                                         \"\\tline=\\\"<line number to display>\") {\n      public void update(PropertyMaps pm) {\n        if (_attributes.get(\"file\") != null) {\n          final String dir = StringOps.\n            unescapeFileName(StringOps.replaceVariables(DEF_DIR, pm, PropertyMaps.GET_CURRENT));\n          final String fil = StringOps.\n            unescapeFileName(StringOps.replaceVariables(_attributes.get(\"file\"), pm, PropertyMaps.GET_CURRENT));\n          FileOpenSelector fs = new FileOpenSelector() {\n            public File[] getFiles() {\n              if (fil.startsWith(\"/\")) { return new File[] { new File(fil) }; }\n              else { return new File[] { new File(dir, fil) }; }\n            }\n          };\n          open(fs);\n          int lineNo = -1;\n          if (_attributes.get(\"line\") != null) {\n            try { lineNo = Integer.valueOf(_attributes.get(\"line\")); }\n            catch(NumberFormatException nfe) { lineNo = -1; }\n          }\n          if (lineNo >= 0) {\n            final int l = lineNo;\n            Utilities.invokeLater(new Runnable() { public void run() { _jumpToLine(l); } });\n          }\n        }\n      }      \n      /** Reset the attributes. */\n      public void resetAttributes() {\n        _attributes.clear();\n        _attributes.put(\"file\", null);\n        _attributes.put(\"line\", null);\n      }\n      public boolean isCurrent() { return false; }\n    });\n    PropertyMaps.TEMPLATE.\n      setProperty(\"Action\", \n                  new DrJavaActionProperty(\"action.auto.refresh\", \"(Auto-Refresh...)\",\n                                           \"Execute an \\\"Auto-Refresh Project\\\" action.\") {\n      public void update(PropertyMaps pm) {\n        _model.autoRefreshProject();\n      }\n      public boolean isCurrent() { return false; }\n    });\n  }\n  \n  /** Sets up new painters for existing breakpoint highlights. */\n  void refreshBreakpointHighlightPainter() {\n    for(Map.Entry<Breakpoint,HighlightManager.HighlightInfo> pair: _documentBreakpointHighlights.entrySet()) {\n      if (pair.getKey().isEnabled()) pair.getValue().refresh(DefinitionsPane.BREAKPOINT_PAINTER);\n      else pair.getValue().refresh(DefinitionsPane.DISABLED_BREAKPOINT_PAINTER);\n    }\n  }\n  \n  /** Sets new painters for existing bookmark highlights. */\n  void refreshBookmarkHighlightPainter() {\n    for(HighlightManager.HighlightInfo hi: _documentBookmarkHighlights.values()) {\n      hi.refresh(DefinitionsPane.BOOKMARK_PAINTER);\n    }\n  }\n  \n  /** Set new painter for existing find results highlights. */\n  void refreshFindResultsHighlightPainter(FindResultsPanel panel, LayeredHighlighter.LayerPainter painter) {\n    for(Pair<FindResultsPanel, Map<MovingDocumentRegion, HighlightManager.HighlightInfo>> pair: _findResults) {\n      if (pair.first() == panel) {\n        Map<MovingDocumentRegion, HighlightManager.HighlightInfo> highlights = pair.second();\n        for(HighlightManager.HighlightInfo hi: highlights.values()) { hi.refresh(painter); }\n      }\n    }\n  }\n  \n  /** Creates the folder chooser during MainFrame initialization which does not run in event thread. */\n  private DirectoryChooser makeFolderChooser(final File workDir) {\n    assert duringInit() || EventQueue.isDispatchThread();\n    final DirectoryChooser dc = new DirectoryChooser(this);\n    /* The following code fragement was moved to the event thread because setSelectedFile occasionally generates an \n     * ArrayOutOfBoundsException otherwise. */\n    dc.setSelectedFile(workDir);\n    dc.setApproveButtonText(\"Select\");\n    dc.setDialogTitle(\"Open Folder\");\n    dc.setAccessory(_openRecursiveCheckBox);\n    return dc;\n  }\n//  \n//  private JFileChooser makeFolderChooser(File workDir) {\n//    _folderChooser = new JFileChooser();\n//    _folderChooser.setMultiSelectionEnabled(false);\n//    _folderChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);\n//    _folderChooser.setCurrentDirectory(workDir);\n//    _folderChooser.setApproveButtonText(\"Select\");\n//    _folderChooser.setFileFilter(new DirectoryFilter());\n//    _folderChooser.setDialogTitle(\"Open Folder\");\n//    \n//    \n//    Container button_row = (Container)findButtonContainer(_folderChooser, _folderChooser.getApproveButtonText());\n//    Container buttons = (Container) button_row.getParent();\n//    \n////    Component c2 = ((BorderLayout)_folderChooser.getLayout()).getLayoutComponent(BorderLayout.SOUTH);\n//    \n////    System.out.println(\"c1: \" + c1);\n////    System.out.println(\"c2: \" + c2);\n//    \n//    \n////    JPanel buttons = (JPanel)c2;\n////    JPanel button_row = (JPanel)buttons.getComponent(3);\n//    JPanel bottom_row = new JPanel();\n//    bottom_row.setLayout(new BorderLayout());\n//    bottom_row.add(new JCheckBox(\"Recursive Open\"), BorderLayout.CENTER);\n//    bottom_row.add(button_row, BorderLayout.EAST);\n//    buttons.add(bottom_row);\n//    \n//    return _folderChooser;\n//  }\n  \n//  private Container findButtonContainer(Container container, String buttonText) {\n//    Container answer = null;\n//    Component[] cs = container.getComponents();\n//    for(Component c: cs) {\n//      if (c instanceof JButton && ((JButton)c).getText().equals(buttonText)) {\n//        return container;\n//      }else if (c instanceof Container) {\n//        answer = findButtonContainer((Container)c, buttonText);\n//      }\n//      \n//      if (answer != null) break;\n//    }\n//    return answer;\n//  }\n  \n  \n  /** Sets up the ctrl-tab listener. */\n  private void setUpKeys() { setFocusTraversalKeysEnabled(false); }\n  \n  /** Clean up model and Swing resources. */\n  public void dispose() {\n    _model.dispose();\n    super.dispose();\n  }\n  \n  /** @return The model providing the logic for this view. */\n  public SingleDisplayModel getModel() { return _model; }\n  \n  /** Returns the frame's interactions pane.  (Package private accessor) */\n  InteractionsPane getInteractionsPane() { return _interactionsPane; }\n  \n  /** Returns the frame's interactions controller. (Package private accessor) */\n  InteractionsController getInteractionsController() { return _interactionsController; }\n  \n  /** @return The frame's close button (Package private accessor). */\n  JButton getCloseButton() { return _closeButton; }\n  \n  /** For testing purposes.\n    * @return The frame's compileAll button (Package private accessor)\n    */\n  JButton getCompileAllButton() { return _compileButton; }\n  \n  private volatile int _hourglassNestLevel = 0;\n  \n  /** Make the cursor an hourglass. Only runs in the event thread. */  \n  public void hourglassOn() {\n    assert EventQueue.isDispatchThread();\n    _hourglassNestLevel++;\n    if (_hourglassNestLevel == 1) {\n      getGlassPane().setVisible(true);\n      _currentDefPane.setEditable(false);\n      setAllowKeyEvents(false); \n      // _menuBar.setEnabled(false); // causes problems on Mac OS 10.6; make sure this runs in the event thread?\n      _interactionsPane.setEnabled(false);\n    }\n  }\n  \n  /** Return the cursor to normal. Only runs in the event thread. */ \n  public void hourglassOff() { \n    assert EventQueue.isDispatchThread();\n    _hourglassNestLevel--;\n    if (_hourglassNestLevel == 0) {\n      getGlassPane().setVisible(false);\n      _currentDefPane.setEditable(true);\n      setAllowKeyEvents(true);\n      // _menuBar.setEnabled(true); // causes problems on Mac OS 10.6; make sure this runs in the event thread?\n      _interactionsPane.setEnabled(true);\n    }\n  }\n  \n  private volatile boolean _allowKeyEvents = true;\n  \n  public void setAllowKeyEvents(boolean a) { _allowKeyEvents = a; }\n  \n  public boolean getAllowKeyEvents() { return _allowKeyEvents; }\n  \n  /** Toggles whether the debugger is enabled or disabled, and updates the display accordingly.  Only runs in the \n    * event thread. */\n  public void debuggerToggle() {\n    assert EventQueue.isDispatchThread();\n    // Make sure the debugger is available\n    Debugger debugger = _model.getDebugger();\n    if (! debugger.isAvailable()) return;\n    \n    updateStatusField(\"Toggling Debugger Mode\");\n    try { \n      if (isDebuggerReady()) {\n        _guiAvailabilityNotifier.ensureUnavailable(GUIAvailabilityListener.ComponentType.DEBUGGER);\n        debugger.shutdown();\n      }\n      else {\n        // Turn on debugger\n        hourglassOn();\n        try {\n          debugger.startUp();  // may kick active document (if unmodified) out of memory!\n//          System.err.println(\"Trying to start debugger\");\n          _model.refreshActiveDocument();\n          _updateDebugStatus();\n        }\n        finally { hourglassOff(); }\n      }\n    }\n    catch (DebugException de) { \n      MainFrameStatics.showError(MainFrame.this, de, \"Debugger Error\", \"Could not start the debugger.\"); \n    }\n    catch (NoClassDefFoundError err) {\n      MainFrameStatics.showError(MainFrame.this, err, \"Debugger Error\",\n                               \"Unable to find the JPDA package for the debugger.\\n\" +\n                               \"Please make sure either tools.jar or jpda.jar is\\n\" +\n                               \"in your classpath when you start DrJava.\");\n      _setDebugMenuItemsEnabled(false);\n    }\n  }\n  \n  /** Display the debugger tab and update the Debug menu accordingly. */\n  public void showDebugger() {\n    assert EventQueue.isDispatchThread();\n    _setDebugMenuItemsEnabled(true);\n    _showDebuggerPanel();\n  }\n  \n  /** Hide the debugger tab and update the Debug menu accordingly. */\n  public void hideDebugger() {\n    _setDebugMenuItemsEnabled(false);\n    _hideDebuggerPanel();\n  }\n  \n  private void _showDebuggerPanel() {\n    if (_debugFrame == null) return; // debugger isn't used\n    if (_detachDebugFrameMenuItem.isSelected()) {\n      _debugFrame.setDisplayInFrame(true);\n    }\n    else {\n      _debugSplitPane.setTopComponent(_docSplitPane);\n      _mainSplit.setTopComponent(_debugSplitPane);\n    }\n    _debugPanel.updateData();\n    _lastFocusOwner.requestFocusInWindow();\n  }\n  \n  private void _hideDebuggerPanel() {\n    if (_debugFrame == null) return; // debugger isn't used\n    if (_detachDebugFrameMenuItem.isSelected()) {\n      _debugFrame.setVisible(false);\n    }\n    else {\n      _mainSplit.setTopComponent(_docSplitPane);\n    }\n    _lastFocusOwner.requestFocusInWindow();\n  }\n  \n  /** ONLY executes in event thread. */\n  public void updateStatusField(String text) {\n    assert EventQueue.isDispatchThread();\n    _statusField.setText(text);\n    _statusField.paint(getGraphics());  // force an immediate repaint\n  }\n  \n  /** Updates the status field with the current status of the Definitions Pane. */\n  public void updateStatusField() {\n    OpenDefinitionsDocument doc = _model.getActiveDocument();\n    String fileName = doc.getCompletePath();\n    if (! fileName.equals(_fileTitle)) {\n      _fileTitle = fileName;\n      setTitle(fileName);\n      _tabbedPanesFrame.setTitle(\"Tabbed Panes - \"+fileName);\n      if (_debugFrame!=null) _debugFrame.setTitle(\"Debugger - \"+fileName);\n      _model.getDocCollectionWidget().repaint();\n    }\n    String path = doc.getCompletePath();\n    \n    String text = \"Editing \" + path;\n    \n// Lightweight parsing has been disabled until we have something that is beneficial and works better in the background.\n//    if (DrJava.getConfig().getSetting(LIGHTWEIGHT_PARSING_ENABLED).booleanValue()) {\n//      String temp = _model.getParsingControl().getEnclosingClassName(doc);\n//      if ((temp != null) && (temp.length() > 0)) { text = text + \" - \" + temp; }\n    \n//    _statusField.setToolTipText(\"Full path for file: \" + path);\n    \n    if (! _statusField.getText().equals(text)) { \n      _statusField.setText(text); \n      _statusField.paint(getGraphics());  // force immediate painting of the _statusField\n    }\n  }\n  \n  /** Prompt the user to select a place to open files from, then load them. Ask the user if they'd like to save \n    * previous changes (if the current document has been modified) before opening.\n    * @param jfc the open dialog from which to extract information\n    * @return an array of the files that were chosen\n    */\n  public File[] getOpenFiles(JFileChooser jfc) throws OperationCanceledException {\n    int rc = jfc.showOpenDialog(this);\n    return getChosenFiles(jfc, rc);\n  }\n  \n  /** Prompt the user to select a place to save the current document. */\n  public File getSaveFile(JFileChooser jfc) throws OperationCanceledException {\n    // This redundant-looking hack is necessary for JDK 1.3.1 on Mac OS X!\n//    File selection = jfc.getSelectedFile();//_saveChooser.getSelectedFile();\n//    if (selection != null) {\n//      jfc.setSelectedFile(selection.getParentFile());\n//      jfc.setSelectedFile(selection);\n//      jfc.setSelectedFile(null);\n//    }\n    \n    OpenDefinitionsDocument active = _model.getActiveDocument();\n    File previous = null;\n    \n    // Fill in class name\n    if (active.isUntitled()) {\n      try {\n        String className = active.getFirstTopLevelClassName();\n        if (!className.equals(\"\")) {\n          jfc.setSelectedFile(new File(jfc.getCurrentDirectory(), className));\n        }\n      }\n      catch (ClassNameNotFoundException e) {\n        // Don't set selected file\n      }\n    }\n    else {\n      // not untitled, select previous name\n      previous = active.getRawFile();\n      jfc.setSelectedFile(previous);\n    }\n    \n    jfc.removeChoosableFileFilter(_projectFilter);\n    jfc.removeChoosableFileFilter(_javaSourceFilter);\n    jfc.removeChoosableFileFilter(_unfilteredJavaSourceFilter);\n    jfc.setFileFilter(_javaSourceFilter);\n    jfc.setMultiSelectionEnabled(false);\n    int rc = jfc.showSaveDialog(this);\n    return getChosenFile(jfc, rc, previous);\n  }\n  \n  /** Returns the current DefinitionsPane. */\n  public DefinitionsPane getCurrentDefPane() { return _currentDefPane; }\n  \n  /** Returns the compiler error panel. */\n  public CompilerErrorPanel getCompilerErrorPanel() { return _compilerErrorPanel; }\n  \n  /** Returns the JUnit error panel. */\n  public JUnitPanel getJUnitPanel() { return _junitPanel; }\n  \n  /** Returns the javadoc error panel. */\n  public JavadocErrorPanel getJavadocErrorPanel() { return _javadocErrorPanel; }\n  \n  /** Returns the currently shown error panel if there is one. Otherwise returns null. */\n  public CompilerErrorPanel getSelectedCompilerErrorPanel() {\n    Component c = _tabbedPane.getSelectedComponent();\n    if (c instanceof CompilerErrorPanel) return (CompilerErrorPanel) c;\n    return null;\n  }\n  \n  /** Returns whether the compiler output tab is currently showing. */\n  public boolean isCompilerTabSelected() {\n    return _tabbedPane.getSelectedComponent() == _compilerErrorPanel;\n  }\n  \n  /** Returns whether the test output tab is currently showing. */\n  public boolean isTestTabSelected() {\n    return _tabbedPane.getSelectedComponent() == _junitPanel;\n  }\n  \n  /** Returns whether the JavaDoc output tab is currently showing. */\n  public boolean isJavadocTabSelected() {\n    return _tabbedPane.getSelectedComponent() == _javadocErrorPanel;\n  }\n  \n  /** Changes the message text toward the right of the status bar\n    * @param msg The message to place in the status bar\n    */\n  public void setStatusMessage(String msg) { _statusReport.setText(msg); }\n  \n  /** Sets the message text in the status bar to the null string. */\n  public void clearStatusMessage() { _statusReport.setText(\"\"); }\n  \n  /** Sets the font of the status bar message\n    * @param f The new font of the status bar message\n    */\n  public void setStatusMessageFont(Font f) { _statusReport.setFont(f); }\n  \n  /** Sets the color of the text in the status bar message\n    * @param c The color of the text\n    */\n  public void setStatusMessageColor(Color c) { _statusReport.setForeground(c); }\n  \n  /** Performs op on each document in docs and invalidates the various project file collection properties. */\n  private void _processDocs(Collection<OpenDefinitionsDocument> docs, Runnable1<OpenDefinitionsDocument> op) {\n    for (OpenDefinitionsDocument doc: docs) {\n      if (doc != null && ! doc.isUntitled()) {\n        op.run(doc);\n        try {\n          String path = _model.fixPathForNavigator(doc.getFile().getCanonicalPath());\n          _model.getDocumentNavigator().refreshDocument(doc, path);\n        }\n        catch(IOException e) { /* do nothing */ }\n      }\n    }\n    PropertyMaps.TEMPLATE.getProperty(\"DrJava\",\"drjava.project.files\").invalidate();\n    PropertyMaps.TEMPLATE.getProperty(\"DrJava\",\"drjava.included.files\").invalidate();\n    PropertyMaps.TEMPLATE.getProperty(\"DrJava\",\"drjava.external.files\").invalidate();\n  }\n  \n  /* Converts the selected files to auxiliary files.  Access is ackage protected rather than private to support access\n   * by ProjectMenuTest.testSaveProject. \n   */\n  void _moveToAuxiliary() {\n    Runnable1<OpenDefinitionsDocument> op =  new Runnable1<OpenDefinitionsDocument>() { \n      public void run(OpenDefinitionsDocument d) { _model.addAuxiliaryFile(d); }\n    };\n    _processDocs(_model.getDocumentNavigator().getSelectedDocuments(), op);\n  }\n  \n  /** Removes selected auxiliary files. */       \n  private void _removeAuxiliary() {\n    Runnable1<OpenDefinitionsDocument> op =  new Runnable1<OpenDefinitionsDocument>() { \n      public void run(OpenDefinitionsDocument d) { _model.removeAuxiliaryFile(d); }\n    };\n    _processDocs(_model.getDocumentNavigator().getSelectedDocuments(), op);\n  }\n  \n  /** Converts all external files to auxiliary files. */\n  void _moveAllToAuxiliary() {\n    assert EventQueue.isDispatchThread();\n    Runnable1<OpenDefinitionsDocument> op =  new Runnable1<OpenDefinitionsDocument>() { \n      public void run(OpenDefinitionsDocument d) { _model.addAuxiliaryFile(d); }\n    };\n    _processDocs(_model.getDocumentNavigator().getDocumentsInBin(_model.getExternalBinTitle()), op);\n  }\n  \n  /** Converts all auxiliary files to external files. */\n  private void _removeAllAuxiliary() {\n    assert EventQueue.isDispatchThread();\n    Runnable1<OpenDefinitionsDocument> op =  new Runnable1<OpenDefinitionsDocument>() { \n      public void run(OpenDefinitionsDocument d) { _model.removeAuxiliaryFile(d); }\n    };\n    _processDocs(_model.getDocumentNavigator().getDocumentsInBin(_model.getAuxiliaryBinTitle()), op);\n  }\n  \n  private void _new() { \n    updateStatusField(\"Creating a new Untitled Document\");\n    _model.newFile(); \n  }\n  \n  private void _open() {\n    updateStatusField(\"Opening File\");\n    open(_openSelector); \n  }\n  \n  private void _openFolder() { \n    openFolder(_folderChooser); \n  }\n  \n  private void _openFileOrProject() {\n    try {\n      final File[] fileList = _openFileOrProjectSelector.getFiles();\n      \n      FileOpenSelector fos = new FileOpenSelector() { public File[] getFiles() { return fileList; } };\n      \n      if (_openChooser.getFileFilter().equals(_projectFilter)) openProject(fos);\n      else open(fos);\n    }\n    catch(OperationCanceledException oce) { /* do nothing */ }\n  }\n  \n  /** Puts the given text into the current definitions pane at the current caret position.  */\n  private void _putTextIntoDefinitions(String text) {\n    int caretPos = _currentDefPane.getCaretPosition();\n    \n    try { _model.getActiveDocument().insertString(caretPos, text, null); }\n    catch (BadLocationException ble) { throw new UnexpectedException(ble); }\n  }\n  \n  /** Sets the left navigator pane to the correct component as dictated by the model. */\n  private void _resetNavigatorPane() {\n    if (_model.getDocumentNavigator() instanceof JTreeSortNavigator<?>) {\n      JTreeSortNavigator<?> nav = (JTreeSortNavigator<?>)_model.getDocumentNavigator();\n      nav.setDisplayManager(getNavPaneDisplayManager());\n      nav.setRootIcon(_djProjectIcon);\n    }\n    _docSplitPane.remove(_docSplitPane.getLeftComponent());\n    _docSplitPane.setLeftComponent(new JScrollPane(_model.getDocumentNavigator().asContainer()));\n    Font doclistFont = DrJava.getConfig().getSetting(FONT_DOCLIST);\n    _model.getDocCollectionWidget().setFont(doclistFont);\n    _updateNormalColor();\n    _updateBackgroundColor();\n  }\n  \n  /** Asks the user to select the project file to open and starts the process of opening the project. */\n  private void _openProject() { openProject(_openProjectSelector); }\n  \n  public void openProject(FileOpenSelector projectSelector) {\n    \n    try { \n      final File[] files = projectSelector.getFiles();\n      if (files.length < 1)\n        throw new IllegalStateException(\"Open project file selection not canceled but no project file was selected.\");\n      final File file = files[0];\n      \n      updateStatusField(\"Opening project \" + file);\n      \n      try {\n        hourglassOn();\n        // make sure there are no open projects\n        if (! _model.isProjectActive() || (_model.isProjectActive() && _closeProject())) _openProjectHelper(file);\n      }\n      catch(Exception e) { e.printStackTrace(System.out); }\n      finally { hourglassOff(); } \n    }\n    catch(OperationCanceledException oce) { /* do nothing, we just won't open anything */ }\n    \n  }  \n  \n  /** Oversees the opening of the project by delegating to the model to parse and initialize the project \n    * while resetting the navigator pane and opening up the files itself.\n    * @param projectFile the file of the project to open\n    */\n  private void _openProjectHelper(File projectFile) {\n    _currentProjFile = projectFile;\n    try {\n      _mainListener.resetFNFCount();\n      _model.openProject(projectFile);\n      _setUpProjectButtons(projectFile);\n      _openProjectUpdate();\n      \n      if (_mainListener.someFilesNotFound()) _model.setProjectChanged(true);\n      clearCompleteClassSet(); // reset auto-completion list\n      addToBrowserHistory();\n    }\n    catch(MalformedProjectFileException e) {\n      MainFrameStatics.showProjectFileParseError(MainFrame.this, e); // add to an error adapter\n      return;\n    }\n    catch(FileNotFoundException e) {\n      MainFrameStatics.showFileNotFoundError(MainFrame.this, e); // add to an error adapter\n      return;\n    }\n    catch(IOException e) {\n      MainFrameStatics.showIOError(MainFrame.this, e); // add to an error adapter\n      return;\n    }\n  }\n  \n  private void _setUpProjectButtons(File projectFile) {\n    _compileButton = _updateToolbarButton(_compileButton, _compileProjectAction);\n    _junitButton = _updateToolbarButton(_junitButton, _junitProjectAction);\n    _recentProjectManager.updateOpenFiles(projectFile);\n  }\n  \n  private void _openProjectUpdate() {\n    if (_model.isProjectActive()) {\n      _guiAvailabilityNotifier.available(GUIAvailabilityListener.ComponentType.PROJECT);\n      _model.getDocumentNavigator().asContainer().addKeyListener(_historyListener);\n      _model.getDocumentNavigator().asContainer().addFocusListener(_focusListenerForRecentDocs);\n      _model.getDocumentNavigator().asContainer().addMouseListener(_resetFindReplaceListener);\n      _resetNavigatorPane();\n      _model.refreshActiveDocument();\n    }\n  }\n  \n  /** Closes project when DrJava is not in the process of quitting.\n    * @return true if the project is closed, false if cancelled.\n    */\n  boolean closeProject() {\n    updateStatusField(\"Closing current project\");\n    return _closeProject();\n  }\n  \n  boolean _closeProject() { return _closeProject(false); }\n  \n  /** Saves the project file; closes all open project files; and calls _model.closeProject(quitting) the \n    * clean up the state of the global model.  It also restores the list view navigator\n    * @param quitting whether the project is being closed as part of quitting DrJava\n    * @return true if the project is closed, false if cancelled\n    */\n  boolean _closeProject(boolean quitting) {\n    // TODO: in some cases, it is possible to see the documents being removed in the navigation pane\n    //       this can cause errors. fix this.\n    clearCompleteClassSet(); // reset auto-completion list\n    _autoImportClassSet = new HashSet<JavaAPIListEntry>(); // reset auto-import list\n    \n    if (_checkProjectClose()) {\n      List<OpenDefinitionsDocument> projDocs = _model.getProjectDocuments();\n//      System.err.println(\"projDocs = \" + projDocs);\n      _cleanUpDebugger();\n      boolean couldClose = _model.closeFiles(projDocs);\n      if (! couldClose) return false;\n      \n      disableFindAgainOnClose(projDocs); // disable \"Find Again\" for documents that are closed\n      \n      // project file has been saved and all files closed\n      if (quitting) return true;\n      _model.closeProject(quitting);\n      \n      Component renderer = _model.getDocumentNavigator().getRenderer();\n      new ForegroundColorListener(renderer);\n      new BackgroundColorListener(renderer);\n      _resetNavigatorPane();\n      if (_model.getDocumentCount() == 1) _model.setActiveFirstDocument();\n      _guiAvailabilityNotifier.unavailable(GUIAvailabilityListener.ComponentType.PROJECT);\n      _setUpContextMenus();\n      _currentProjFile = FileOps.NULL_FILE;\n      return true;\n    }\n    else return false;  // Project closing cancelled in _checkProjectClose dialog\n  }\n  \n  private void _configureBrowsing() {\n    BrowserHistoryManager bm = _model.getBrowserHistoryManager();\n    _browseBackAction.setEnabled(!bm.isCurrentRegionFirst());\n    _browseForwardAction.setEnabled(!bm.isCurrentRegionLast());\n  }\n  \n  private boolean _checkProjectClose() {\n    _log.log(\"is changed? \"+_model.isProjectChanged()+\" based on \"+_model);\n    \n    if (_model.isProjectChanged()) {\n      String fname = _model.getProjectFile().getName();\n      String text = fname + \" has been modified. Would you like to save it?\";\n      int rc = \n        JOptionPane.showConfirmDialog(MainFrame.this, text, \"Save \" + fname + \"?\", JOptionPane.YES_NO_CANCEL_OPTION);\n      switch (rc) {\n        case JOptionPane.YES_OPTION:\n          _saveProject();\n          return true;\n        case JOptionPane.NO_OPTION:\n          return true;\n        case JOptionPane.CLOSED_OPTION:\n        case JOptionPane.CANCEL_OPTION:\n          return false;\n        default:\n          throw new RuntimeException(\"Invalid rc: \" + rc);        \n      }\n    } \n    return true;\n  }\n  \n  public File getCurrentProject() { return _currentProjFile;  }\n  \n  /** Opens all the files returned by the FileOpenSelector prompting the user to handle the cases where files are \n    * already open, files are missing, or the action was canceled by the user\n    * @param openSelector the selector that returns the files to open\n    */\n  public void open(FileOpenSelector openSelector) {\n    try {\n      hourglassOn();\n      _model.openFiles(openSelector);\n    }\n    catch (AlreadyOpenException aoe) {\n      OpenDefinitionsDocument[] openDocs = aoe.getOpenDocuments();\n      for(OpenDefinitionsDocument openDoc : openDocs) {\n        try {\n          File f = openDoc.getFile();\n          if (! _model.inProject(f)) _recentFileManager.updateOpenFiles(f);\n        }\n        catch (IllegalStateException ise) {\n          // Impossible: saved => has a file\n          throw new UnexpectedException(ise);\n        }\n        catch (FileMovedException fme) {\n          File f = fme.getFile();\n          // Recover, show it in the list anyway\n          if (! _model.inProject(f))\n            _recentFileManager.updateOpenFiles(f);\n        }\n      }\n    }  \n    catch (OperationCanceledException oce) { /* do not open file */ }\n    catch (FileNotFoundException fnf) { \n      MainFrameStatics.showFileNotFoundError(MainFrame.this, fnf); \n    }\n    catch (IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n    finally { hourglassOff(); }\n  }\n  \n  /** Opens all the files in the directory returned by the FolderSelector.\n    * @param chooser the selector that returns the files to open\n    * TODO: change the dialog title to give the current path rather than \"...\"\n    */\n  public void openFolder(DirectoryChooser chooser) {\n    String type = \"'\" + OptionConstants.LANGUAGE_LEVEL_EXTENSIONS[DrJava.getConfig().getSetting(LANGUAGE_LEVEL)] + \"' \";\n    chooser.setDialogTitle(\"Open All \" + type + \"Files in ...\");\n    \n    File openDir = FileOps.NULL_FILE;\n    try { \n      File activeFile = _model.getActiveDocument().getFile();\n      if (activeFile != null) openDir = activeFile.getParentFile();\n      else openDir = _model.getProjectRoot();\n    }\n    catch(FileMovedException e) { /* do nothing */ }\n    \n    int result = chooser.showDialog(openDir);\n    if (result != DirectoryChooser.APPROVE_OPTION)  return; // canceled or error\n    \n    File dir = chooser.getSelectedDirectory();\n    boolean rec = _openRecursiveCheckBox.isSelected();\n    DrJava.getConfig().setSetting(OptionConstants.OPEN_FOLDER_RECURSIVE, Boolean.valueOf(rec));\n    updateStatusField(\"Opening folder \" + dir);\n    _openFolder(dir, rec);\n  }\n  \n  /** Opens all the files in the specified directory; it opens all files in nested folders if rec is true.\n    * @param dir the specified directory\n    * @param rec true if files in nested folders should be opened\n    */\n  private void _openFolder(File dir, boolean rec) {\n    hourglassOn();\n    try { _model.openFolder(dir, rec); }\n    catch(AlreadyOpenException e) { /* do nothing */ }\n    catch(IOException e) { MainFrameStatics.showIOError(MainFrame.this, e); }\n    catch(OperationCanceledException oce) { /* do nothing */ }\n    finally { hourglassOff(); }\n  }\n  \n  /** Closes the active document.  The user is queried in some cases. */\n  private void _close() {\n    \n    // this works with multiple selected files now\n    List<OpenDefinitionsDocument> l = _model.getDocumentNavigator().getSelectedDocuments();    \n    boolean queryNecessary = false; // is a query necessary because the files are project or auxiliary files?\n    for (OpenDefinitionsDocument doc: l) {\n      if ((_model.isProjectActive() && doc.inProjectPath()) || doc.isAuxiliaryFile()) {\n        queryNecessary = true;\n        break;\n      }\n    }\n    if (queryNecessary) {\n      int rc;\n      String fileName = null;\n      Object[] options = {\"Yes\", \"No\"};\n      if (l.size() == 1) {\n        OpenDefinitionsDocument doc = l.get(0);\n        try {\n          if (doc.isUntitled()) fileName = \"File\";\n          else fileName = _model.getActiveDocument().getFile().getName();\n        }\n        catch(FileMovedException e) { fileName = e.getFile().getName(); }\n        String text = \"Closing this file will permanently remove it from the current project.\" + \n          \"\\nAre you sure that you want to close this file?\";\n        \n        rc = JOptionPane.showOptionDialog(MainFrame.this, text,\"Close \" + fileName + \"?\", JOptionPane.YES_NO_OPTION,\n                                          JOptionPane.QUESTION_MESSAGE, null, options, options[1]);\n      }\n      else {\n        fileName = l.size()+\" files\";\n        String text = \"Closing these \"+fileName+\" will permanently remove them from the current project.\" + \n          \"\\nAre you sure that you want to close these files?\";\n        \n        rc = JOptionPane.showOptionDialog(MainFrame.this, text, \"Close \"+l.size()+\" files?\", JOptionPane.YES_NO_OPTION,\n                                          JOptionPane.QUESTION_MESSAGE, null, options, options[1]);\n      }\n      if (rc != JOptionPane.YES_OPTION) return;\n      \n      updateStatusField(\"Closing \" + fileName);\n      _model.setProjectChanged(true);\n    }\n    \n    disableFindAgainOnClose(l); // disable \"Find Again\" for documents that are closed\n    \n    // Either this is an external file or user actually wants to close it\n    for(OpenDefinitionsDocument doc: l) {\n      _model.closeFile(doc);\n    }\n  }\n  \n  private void _closeFolder() {\n    ArrayList<OpenDefinitionsDocument> docs = _model.getDocumentNavigator().getDocuments();\n    final LinkedList<OpenDefinitionsDocument> l = new LinkedList<OpenDefinitionsDocument>();\n    \n    if (_model.getDocumentNavigator().isGroupSelected()) {\n      for (OpenDefinitionsDocument doc: docs) {\n        if (_model.getDocumentNavigator().isSelectedInGroup(doc)) { l.add(doc); }\n      }\n      disableFindAgainOnClose(l); // disable \"Find Again\" for documents that are closed\n      _model.closeFiles(l);\n      if (! l.isEmpty()) _model.setProjectChanged(true);\n    }\n  }\n  \n  private void _printDefDoc() {\n    try {\n      _model.getActiveDocument().print();\n    }\n    catch (FileMovedException fme) {\n      _showFileMovedError(fme);\n    }\n    catch (PrinterException e) {\n      MainFrameStatics.showError(MainFrame.this, e, \"Print Error\", \"An error occured while printing.\");\n    }\n    catch (BadLocationException e) {\n      MainFrameStatics.showError(MainFrame.this, e, \"Print Error\", \"An error occured while printing.\");\n    }\n  }\n  \n  private void _printConsole() {\n    try {\n      _model.getConsoleDocument().print();\n    }\n    catch (PrinterException e) {\n      MainFrameStatics.showError(MainFrame.this, e, \"Print Error\", \"An error occured while printing.\");\n    }\n  }\n  \n  private void _printInteractions() {\n    try {\n      _model.getInteractionsDocument().print();\n    }\n    catch (PrinterException e) {\n      MainFrameStatics.showError(MainFrame.this, e, \"Print Error\", \"An error occured while printing.\");\n    }\n  }\n  \n  /** Opens a new PrintPreview frame. */\n  private void _printDefDocPreview() {\n    try {\n      _model.getActiveDocument().preparePrintJob();\n      new PreviewDefDocFrame(_model, this);\n    }\n    catch (FileMovedException fme) {\n      _showFileMovedError(fme);\n    }\n    catch (BadLocationException e) {\n      MainFrameStatics.showError(MainFrame.this, e, \"Print Error\", \"An error occured while preparing the print preview.\");\n    }\n    catch (IllegalStateException e) {\n      MainFrameStatics.showError(MainFrame.this, e, \"Print Error\", \"An error occured while preparing the print preview.\");\n    }\n  }\n  \n  private void _printConsolePreview() {\n    try {\n      _model.getConsoleDocument().preparePrintJob();\n      new PreviewConsoleFrame(_model, this, false);\n    }\n    catch (IllegalStateException e) {\n      MainFrameStatics.showError(MainFrame.this, e, \"Print Error\", \"An error occured while preparing the print preview.\");\n    }\n  }\n  \n  private void _printInteractionsPreview() {\n    try {\n      _model.getInteractionsDocument().preparePrintJob();\n      new PreviewConsoleFrame(_model, this, true);\n    }\n    catch (IllegalStateException e) {\n      MainFrameStatics.showError(MainFrame.this, e, \"Print Error\", \"An error occured while preparing the print preview.\");\n    }\n  }\n  \n  private void _pageSetup() {\n    PrinterJob job = PrinterJob.getPrinterJob();\n    _model.setPageFormat(job.pageDialog(_model.getPageFormat()));\n  }\n  \n  // Called by testCases\n  void closeAll() { _closeAll(); }\n  \n  private void _closeAll() {\n    updateStatusField(\"Closing All Files\");\n    if (!_model.isProjectActive() || _model.isProjectActive() && _closeProject())  _model.closeAllFiles();\n  }\n  \n  private boolean _save() {\n    updateStatusField(\"Saving File\");\n    try {\n      // now works with multiple files\n      List<OpenDefinitionsDocument> l = _model.getDocumentNavigator().getSelectedDocuments();\n      boolean success = false;\n      for(OpenDefinitionsDocument doc: l) {\n        if (doc.saveFile(_saveSelector)) {\n          getDefPaneGivenODD(doc).hasWarnedAboutModified(false);\n          success = true;\n        }\n      }\n      // Is _model.refreshActiveDocument() sufficient here? Before this action selected the document in navigator\n      // it was not in flat-file mode\n      _model.refreshActiveDocument();\n      return success;\n    }\n    catch (IOException ioe) { \n      MainFrameStatics.showIOError(MainFrame.this, ioe);\n      return false;\n    }\n  }\n  \n  private boolean _saveAs() {\n    updateStatusField(\"Saving File Under New Name\");\n    try {\n      boolean toReturn = _model.getActiveDocument().saveFileAs(_saveAsSelector);\n      _model.refreshActiveDocument();  // highlights the document in the navigator\n      return toReturn;\n    }\n    catch (IOException ioe) {\n      MainFrameStatics.showIOError(MainFrame.this, ioe);\n      return false;\n    }\n  }\n  \n  private boolean _saveCopy() {\n    updateStatusField(\"Saving Copy of File\");\n    try {\n      boolean toReturn = _model.getActiveDocument().saveFileAs(_saveCopySelector);\n      _model.refreshActiveDocument();  // highlights the document in the navigator\n      return toReturn;\n    }\n    catch (IOException ioe) {\n      MainFrameStatics.showIOError(MainFrame.this, ioe);\n      return false;\n    }\n  }\n  \n  private boolean _rename() {\n    try {\n      if (!_model.getActiveDocument().fileExists()) return _saveAs();\n      else {\n        File fileToDelete;\n        try { fileToDelete = _model.getActiveDocument().getFile(); } \n        catch (FileMovedException fme) { return _saveAs(); }\n        boolean toReturn = _model.getActiveDocument().saveFileAs(_saveAsSelector);\n        /** Delete the old file if save was successful. */\n        // TODO: what if delete() fails? (mgricken)\n        if (toReturn && ! _model.getActiveDocument().getFile().equals(fileToDelete)) fileToDelete.delete();\n        /** this highlights the document in the navigator */\n        _model.refreshActiveDocument();\n        return toReturn;\n      }\n    }\n    catch (IOException ioe) {\n      MainFrameStatics.showIOError(MainFrame.this, ioe);\n      return false;\n    }\n  }  \n  \n  /* Package private to allow use in MainFrameTest. */\n  void _saveAll() {\n    hourglassOn();\n    try {\n      if (_model.isProjectActive()) _saveProject();\n      _model.saveAllFiles(_saveSelector);\n    }\n    catch (IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n    finally { hourglassOff(); }\n  }\n  \n  void _saveAllOld() {\n    hourglassOn();\n    File file = _currentProjFile;\n    try {\n      if (_model.isProjectActive()) {\n        if (file.getName().indexOf(\".\") == -1) file = new File (file.getAbsolutePath() + OLD_PROJECT_FILE_EXTENSION);\n        _model.exportOldProject(file, gatherProjectDocInfo());\n      }\n      _model.saveAllFiles(_saveSelector);\n    }\n    catch (IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n    finally { hourglassOff(); }\n  }\n  \n  // Called by the ProjectPropertiesFrame\n  void saveProject() { _saveProject(); }\n  \n  private void _saveProject() {\n    //File file = _model.getProjectFile();\n    _saveProjectHelper(_currentProjFile);\n  }\n  \n  /** Edits project frame.  Only runs in the event thread. */  \n  private void _editProject() {\n    ProjectPropertiesFrame ppf = new ProjectPropertiesFrame(this);\n    ppf.setVisible(true);\n    ppf.reset();\n    ppf.toFront();  // ppf actions save state of ppf in global model\n  }\n  \n  /** Closes all files and makes a new project. */\n  private void _newProject() {\n    \n    _closeProject(true);  // suppress resetting interactions; it will be done in _model.newProject() below\n    _saveChooser.setFileFilter(_projectFilter);\n    _saveChooser.setMultiSelectionEnabled(false);\n    int rc = _saveChooser.showSaveDialog(this);\n    if (rc == JFileChooser.APPROVE_OPTION) {      \n      File projectFile = _saveChooser.getSelectedFile();\n      \n      if (projectFile == null || projectFile.getParentFile() == null) { return; }\n      String fileName = projectFile.getName();\n      // ensure that saved file has extension \".drjava\"\n      if (! fileName.endsWith(OptionConstants.PROJECT_FILE_EXTENSION)) {\n        int lastIndex = fileName.lastIndexOf(\".\");\n        if (lastIndex == -1) projectFile = new File (projectFile.getAbsolutePath() + \n                                                     OptionConstants.PROJECT_FILE_EXTENSION);\n        else projectFile = new File(projectFile.getParentFile(), fileName.substring(0, lastIndex) + \n                                    OptionConstants.PROJECT_FILE_EXTENSION);\n      }\n      if (projectFile == null ||\n          projectFile.getParentFile() == null ||\n          (projectFile.exists() && ! MainFrameStatics.verifyOverwrite(MainFrame.this, projectFile))) { return; }\n      \n      _model.createNewProject(projectFile); // sets model to a new FileGroupingState for project file pf\n//      ProjectPropertiesFrame ppf = new ProjectPropertiesFrame(MainFrame.this, file);\n//      ppf.saveSettings();  // Saves new project profile in global model\n      _editProject();  // edits the properties of the new FileGroupingState\n      try { _model.configNewProject(); }  // configures the new project in the model\n      catch(IOException e) { throw new UnexpectedException(e); }\n      _setUpProjectButtons(projectFile);\n      _currentProjFile = projectFile;\n    }\n  }\n  \n  /** Pops up the _saveChooser dialog, asks the user for a new project file name, and sets the project file to the \n    * specified file.  Nothing is written in the file system; this action is performed by a subsequent _saveAll().\n    * @return false if the user canceled the action */\n  private boolean _saveProjectAs() {\n    \n//    // This redundant-looking hack is necessary for JDK 1.3.1 on Mac OS X!\n    _saveChooser.removeChoosableFileFilter(_projectFilter);\n    _saveChooser.removeChoosableFileFilter(_javaSourceFilter);\n    _saveChooser.removeChoosableFileFilter(_unfilteredJavaSourceFilter);\n    _saveChooser.setFileFilter(_projectFilter);\n//    File selection = _saveChooser.getSelectedFile();\n//    if (selection != null) {  // what is this block of commands for?\n//      _saveChooser.setSelectedFile(selection.getParentFile());\n//      _saveChooser.setSelectedFile(selection);\n//      _saveChooser.setSelectedFile(null);\n//    }\n    \n    if (_currentProjFile != FileOps.NULL_FILE) _saveChooser.setSelectedFile(_currentProjFile);\n    _saveChooser.setMultiSelectionEnabled(false);\n    int rc = _saveChooser.showSaveDialog(this);\n    if (rc == JFileChooser.APPROVE_OPTION) {\n      File file = _saveChooser.getSelectedFile();\n      if ((file != null) && (! file.exists() || MainFrameStatics.verifyOverwrite(MainFrame.this, file))) { \n        _model.setProjectFile(file);\n        _currentProjFile = file;\n      }\n    }\n    \n    return (rc == JFileChooser.APPROVE_OPTION);\n  }\n  \n  void _saveProjectHelper(File file) {\n    try {\n      String fileName = file.getAbsolutePath();\n      if (!fileName.endsWith(PROJECT_FILE_EXTENSION) &&\n          !fileName.endsWith(PROJECT_FILE_EXTENSION2) &&\n          !fileName.endsWith(OLD_PROJECT_FILE_EXTENSION)) {\n        // doesn't end in .drjava or .xml or .pjt\n        String text = \"The file name does not end with a DrJava project file \"+\n          \"extension (\"+PROJECT_FILE_EXTENSION+\" or \"+PROJECT_FILE_EXTENSION2+\" or \"+OLD_PROJECT_FILE_EXTENSION+\"):\\n\"+\n          file.getName()+\"\\n\"+\n          \"Do you want to append \"+PROJECT_FILE_EXTENSION+\" at the end?\";\n        \n        Object[] options = {\"Append \"+PROJECT_FILE_EXTENSION, \"Don't Change File Name\"};  \n        int rc = 0;\n        if (!Utilities.TEST_MODE) {\n          rc = JOptionPane.showOptionDialog(MainFrame.this, text, \"Append Extension?\", JOptionPane.YES_NO_OPTION,\n                                            JOptionPane.QUESTION_MESSAGE, null, options, options[0]);\n        }\n        if (rc == 0) {\n          int lastDot = fileName.lastIndexOf('.');\n          if (lastDot == -1) {\n            file = new File(fileName + PROJECT_FILE_EXTENSION);\n          }\n          else {\n            file = new File(fileName.substring(0,lastDot) + PROJECT_FILE_EXTENSION);\n          }\n        }\n      }\n      fileName = file.getCanonicalPath();\n      if (fileName.endsWith(OLD_PROJECT_FILE_EXTENSION)) {\n        file = proposeToChangeExtension(MainFrame.this, file,\n                                        \"Change Extension?\",\n                                        \"The project will be saved in XML format.\"\n                                          + \"\\nDo you want to change the project file's extension to \\\"\"\n                                          + PROJECT_FILE_EXTENSION+ \"\\\"?\",\n                                        \"Change to \\\"\" + PROJECT_FILE_EXTENSION + \"\\\"\",\n                                        \"Keep \\\"\" + DrJavaFileUtils.getExtension(fileName) + \"\\\"\",\n                                        PROJECT_FILE_EXTENSION);\n        _model.setProjectFile(file);\n        _currentProjFile = file;\n      }\n      _model.saveProject(file, gatherProjectDocInfo());\n//      if (!(_model.getDocumentNavigator() instanceof JTreeSortNavigator)) {\n//        _openProjectHelper(file);\n//      }    \n    }\n    catch(IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n    _recentProjectManager.updateOpenFiles(file);\n    _model.setProjectChanged(false);\n  }\n  \n  public HashMap<OpenDefinitionsDocument,DocumentInfoGetter> gatherProjectDocInfo() {\n    HashMap<OpenDefinitionsDocument,DocumentInfoGetter> map =\n      new HashMap<OpenDefinitionsDocument,DocumentInfoGetter>();\n    List<OpenDefinitionsDocument> docs = _model.getProjectDocuments();\n    for(OpenDefinitionsDocument doc: docs) {\n      map.put(doc, _makeInfoGetter(doc));\n    }\n    return map;\n  }\n  /** Gets the information to be saved for a project document.\n    * Implementation may change if the scroll/selection information is later stored in a place other than the\n    * definitions pane.  Hopefully this info will eventually be backed up in the OpenDefinitionsDocument in which \n    * case all this code should be refactored into the model's _saveProject method\n    */\n  private DocumentInfoGetter _makeInfoGetter(final OpenDefinitionsDocument doc) {\n    JScrollPane s = _defScrollPanes.get(doc);\n    if (s == null) s = _createDefScrollPane(doc);\n    \n    final DefinitionsPane pane = _currentDefPane; // rhs was (DefinitionsPane)scroller.getViewport().getView();\n    return new DocumentInfoGetter() {\n      public Pair<Integer,Integer> getSelection() {\n        Integer selStart = Integer.valueOf(pane.getSelectionStart());\n        Integer selEnd = Integer.valueOf(pane.getSelectionEnd());\n        if ( selStart == 0 && selEnd == 0) \n          return new Pair<Integer,Integer>(pane.getCaretPosition(),pane.getCaretPosition());\n        if (pane.getCaretPosition() == selStart) return new Pair<Integer,Integer>(selEnd,selStart);\n        return new Pair<Integer,Integer>(selStart,selEnd);\n      }\n      public Pair<Integer,Integer> getScroll() {\n        Integer scrollv = Integer.valueOf(pane.getVerticalScroll());\n        Integer scrollh = Integer.valueOf(pane.getHorizontalScroll());\n        return new Pair<Integer,Integer>(scrollv,scrollh); \n      }\n      public File getFile() { return doc.getRawFile(); }\n      public String getPackage() { return doc.getPackageName(); }\n      public boolean isActive() { return _model.getActiveDocument() == doc; }\n      public boolean isUntitled() { return doc.isUntitled(); }\n    };\n  }\n  \n  private void _revert() {\n    // this works with multiple selected files now\n    List<OpenDefinitionsDocument> l = _model.getDocumentNavigator().getSelectedDocuments();\n    for(OpenDefinitionsDocument d: l) { _revert(d); }\n  }\n  \n  private void _revert(OpenDefinitionsDocument doc) {\n    try {\n      doc.revertFile();\n    }\n    catch (FileMovedException fme) {\n      _showFileMovedError(fme);\n    }\n    catch (IOException ioe) {\n      MainFrameStatics.showIOError(MainFrame.this, ioe);\n    }\n  }\n  \n  /**\n   private void _revertAll() {\n   try {\n   _model.revertAllFiles();\n   }\n   catch (FileMovedException fme) {\n   _showFileMovedError(fme);\n   }\n   catch (IOException ioe) {\n   MainFrameStatics.showIOError(MainFrame.this, ioe);\n   }\n   }\n   */\n  \n  void quit() {\n//    AbstractGlobalModel._log.log(\"MainFrame.quit() called\");\n    if (_promptBeforeQuit) {\n      String title = \"Quit DrJava?\";\n      String message = \"Are you sure you want to quit DrJava?\";\n      ConfirmCheckBoxDialog dialog = new ConfirmCheckBoxDialog(MainFrame.this, title, message);\n      int rc = dialog.show();\n      if (rc != JOptionPane.YES_OPTION) return;\n      else {\n        // Only remember the checkbox if they say yes\n        if (dialog.getCheckBoxValue() == true) {\n          DrJava.getConfig().setSetting(QUIT_PROMPT, Boolean.FALSE);\n        }\n      }\n    }\n    _executeExternalDialog.setVisible(false);\n    // tried passing false here. seemed to help with bug\n    // [ 1478796 ] DrJava Does Not Shut Down With Project Open\n    // on HP tc1100 and Toshiba Portege tablet PCs, but did not help in all cases\n    if (! _closeProject(true)) { return; /* if user pressed cancel, do not quit */ }\n    \n    _updateSavedConfiguration();\n    \n    //DrJava.consoleOut().println(\"Quitting DrJava...\");\n    dispose();    // Free GUI elements of this frame\n    _model.quit();\n  }\n  \n  void _updateSavedConfiguration() {\n    _recentFileManager.saveRecentFiles();\n    _recentProjectManager.saveRecentFiles();\n    if (! _model.closeAllFilesOnQuit()) { return; /* if user pressed cancel, do not quit */ }\n    _storePositionInfo();\n    \n    // Save recent files, but only if there wasn't a problem at startUp\n    // (Don't want to overwrite a custom config file with a simple typo.)\n    if (! DrJava.getConfig().hadStartupException()) {\n      try { DrJava.getConfig().saveConfiguration(); }\n      catch (IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n    }\n  }\n  \n  private void _forceQuit() { _model.forceQuit(); }\n  \n  /** Stores the current position and size info for window and panes to the config framework. Only runs in the event \n    * thread. \n    */\n  private void _storePositionInfo() {\n    assert EventQueue.isDispatchThread();\n    Configuration config = DrJava.getConfig();\n    \n    // Window bounds.\n    if (config.getSetting(WINDOW_STORE_POSITION).booleanValue()) {\n      Rectangle bounds = getBounds();\n      config.setSetting(WINDOW_HEIGHT, Integer.valueOf(bounds.height));\n      config.setSetting(WINDOW_WIDTH, Integer.valueOf(bounds.width));\n      config.setSetting(WINDOW_X, Integer.valueOf(bounds.x));\n      config.setSetting(WINDOW_Y, Integer.valueOf(bounds.y));\n      config.setSetting(WINDOW_STATE, Integer.valueOf(getExtendedState()));\n    }\n    else {\n      // Reset to defaults to restore pristine behavior.\n      config.setSetting(WINDOW_HEIGHT, WINDOW_HEIGHT.getDefault());\n      config.setSetting(WINDOW_WIDTH, WINDOW_WIDTH.getDefault());\n      config.setSetting(WINDOW_X, WINDOW_X.getDefault());\n      config.setSetting(WINDOW_Y, WINDOW_Y.getDefault());\n      config.setSetting(WINDOW_STATE, WINDOW_STATE.getDefault());\n    }\n    \n    // \"Go to File\" dialog position and size.\n    if ((DrJava.getConfig().getSetting(DIALOG_GOTOFILE_STORE_POSITION).booleanValue())\n          && (_gotoFileDialog != null) && (_gotoFileDialog.getFrameState() != null)) {\n      config.setSetting(DIALOG_GOTOFILE_STATE, (_gotoFileDialog.getFrameState().toString()));\n    }\n    else {\n      // Reset to defaults to restore pristine behavior.\n      config.setSetting(DIALOG_GOTOFILE_STATE, DIALOG_GOTOFILE_STATE.getDefault());\n    }\n    \n    // \"Open Javadoc\" dialog position and size.\n    if ((DrJava.getConfig().getSetting(DIALOG_OPENJAVADOC_STORE_POSITION).booleanValue())\n          && (_openJavadocDialog != null) && (_openJavadocDialog.getFrameState() != null)) {\n      config.setSetting(DIALOG_OPENJAVADOC_STATE, (_openJavadocDialog.getFrameState().toString()));\n    }\n    else {\n      // Reset to defaults to restore pristine behavior.\n      config.setSetting(DIALOG_OPENJAVADOC_STATE, DIALOG_OPENJAVADOC_STATE.getDefault());\n    }    \n    \n    // \"Complete Word\" dialog position and size.\n    if ((DrJava.getConfig().getSetting(DIALOG_COMPLETE_WORD_STORE_POSITION).booleanValue())\n          && (_completeWordDialog != null) && (_completeWordDialog.getFrameState() != null)) {\n      config.setSetting(DIALOG_COMPLETE_WORD_STATE, (_completeWordDialog.getFrameState().toString()));\n    }\n    else {\n      // Reset to defaults to restore pristine behavior.\n      config.setSetting(DIALOG_COMPLETE_WORD_STATE, DIALOG_COMPLETE_WORD_STATE.getDefault());\n    }\n    \n    // \"Create Jar from Project\" dialog position and size.   \n    if ((DrJava.getConfig().getSetting(DIALOG_JAROPTIONS_STORE_POSITION).booleanValue())\n          && (_jarOptionsDialog != null) && (_jarOptionsDialog.getFrameState() != null)) {\n      config.setSetting(DIALOG_JAROPTIONS_STATE, (_jarOptionsDialog.getFrameState().toString()));\n    }\n    else {\n      // Reset to defaults to restore pristine behavior.\n      config.setSetting(DIALOG_JAROPTIONS_STATE, DIALOG_JAROPTIONS_STATE.getDefault());\n    }\n    \n    // \"Tabbed Panes\" frame position and size.\n    if ((DrJava.getConfig().getSetting(DIALOG_TABBEDPANES_STORE_POSITION).booleanValue())\n          && (_tabbedPanesFrame != null) && (_tabbedPanesFrame.getFrameState() != null)) {\n      config.setSetting(DIALOG_TABBEDPANES_STATE, (_tabbedPanesFrame.getFrameState().toString()));\n    }\n    else {\n      // Reset to defaults to restore pristine behavior.\n      config.setSetting(DIALOG_TABBEDPANES_STATE, DIALOG_TABBEDPANES_STATE.getDefault());\n    }\n    \n    // \"Debugger\" frame position and size.\n    if ((DrJava.getConfig().getSetting(DIALOG_DEBUGFRAME_STORE_POSITION).booleanValue())\n          && (_debugFrame != null) && (_debugFrame.getFrameState() != null)) {\n      config.setSetting(DIALOG_DEBUGFRAME_STATE, (_debugFrame.getFrameState().toString()));\n    }\n    else {\n      // Reset to defaults to restore pristine behavior.\n      config.setSetting(DIALOG_DEBUGFRAME_STATE, DIALOG_DEBUGFRAME_STATE.getDefault());\n    }\n    \n    // Panel heights.\n    if (_showDebugger) config.setSetting(DEBUG_PANEL_HEIGHT, Integer.valueOf(_debugPanel.getHeight()));\n    \n    // Doc list width.\n    config.setSetting(DOC_LIST_WIDTH, Integer.valueOf(_docSplitPane.getDividerLocation()));\n  }\n  \n  private void _cleanUpDebugger() { if (isDebuggerReady()) _model.getDebugger().shutdown(); }\n  \n  private void _compile() {\n    // now works with multiple files\n    _cleanUpDebugger();\n    hourglassOn();\n    try {\n//      final OpenDefinitionsDocument doc = _model.getActiveDocument();\n      try { _model.getCompilerModel().compile(_model.getDocumentNavigator().getSelectedDocuments()); }\n      catch (FileMovedException fme) { _showFileMovedError(fme); }\n      catch (IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n    }\n    finally { hourglassOff();}\n//    update(getGraphics());\n  }\n  \n  private void _compileFolder() {\n    _cleanUpDebugger();\n    hourglassOn();\n    try {\n      ArrayList<OpenDefinitionsDocument> docs = _model.getDocumentNavigator().getDocuments();\n      final LinkedList<OpenDefinitionsDocument> l = new LinkedList<OpenDefinitionsDocument>();\n      if (_model.getDocumentNavigator().isGroupSelected()) {\n        for (OpenDefinitionsDocument doc: docs) {\n          if (_model.getDocumentNavigator().isSelectedInGroup(doc)) l.add(doc);\n        }\n        \n//        new Thread(\"Compile Folder\") {\n//          public void run() {\n        try { _model.getCompilerModel().compile(l); }\n        catch (FileMovedException fme) { _showFileMovedError(fme); }\n        catch (IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n//          }\n//        }.start();\n      }\n    }\n    finally { hourglassOff(); }\n//    update(getGraphics()); \n  }\n  \n  private void _compileProject() { \n    _cleanUpDebugger();\n//    new Thread(\"Compile All\") {\n//      public void run() {\n    hourglassOn();\n    try { _model.getCompilerModel().compileProject(); }\n    catch (FileMovedException fme) { _showFileMovedError(fme); }\n    catch (IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n    finally { hourglassOff(); }\n//      }\n//    }.start();\n//    update(getGraphics()); \n  }\n  \n  private void _compileAll() {\n    _cleanUpDebugger();\n    hourglassOn();\n    try { _model.getCompilerModel().compileAll(); }\n    catch (FileMovedException fme) { _showFileMovedError(fme); }\n    catch (IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n    finally{ hourglassOff(); }\n  }\n  \n  private boolean showCleanWarning() {\n    if (DrJava.getConfig().getSetting(PROMPT_BEFORE_CLEAN).booleanValue()) {\n      String buildDirTxt = \"\";\n      try { buildDirTxt = _model.getBuildDirectory().getCanonicalPath(); }\n      catch (Exception e) { buildDirTxt = _model.getBuildDirectory().getPath(); }\n      ConfirmCheckBoxDialog dialog =\n        new ConfirmCheckBoxDialog(MainFrame.this,\n                                  \"Clean Build Directory?\",\n                                  \"Cleaning your build directory will delete all\\n\" + \n                                  \"class files and empty folders within that directory.\\n\" + \n                                  \"Are you sure you want to clean\\n\" + \n                                  buildDirTxt + \"?\",\n                                  \"Do not show this message again\");\n      int rc = dialog.show();\n      switch (rc) {\n        case JOptionPane.YES_OPTION:\n          _saveAll();\n          // Only remember checkbox if they say yes\n          if (dialog.getCheckBoxValue()) DrJava.getConfig().setSetting(PROMPT_BEFORE_CLEAN, Boolean.FALSE);\n          return true;\n        case JOptionPane.NO_OPTION:      return false;\n        case JOptionPane.CANCEL_OPTION:  return false;\n        case JOptionPane.CLOSED_OPTION:  return false;\n        default:  throw new RuntimeException(\"Invalid rc from showConfirmDialog: \" + rc);\n      }\n    }\n    return true;\n  }\n  \n  private void _clean() { _model.cleanBuildDirectory(); }  // The model performs this as an AsyncTask\n  \n  /** List with entries for the complete dialog. */\n  HashSet<GoToFileListEntry> _completeClassSet = new HashSet<GoToFileListEntry>();\n  \n  /** List with entries for the auto-import dialog. */\n  HashSet<JavaAPIListEntry> _autoImportClassSet = new HashSet<JavaAPIListEntry>();\n  \n  /** Scan the build directory for class files and update the auto-completion list. */\n  private void _scanClassFiles() {\n    Thread t = new Thread(new Runnable() {\n      public void run() {\n        File buildDir = _model.getBuildDirectory();\n        HashSet<GoToFileListEntry> hs = new HashSet<GoToFileListEntry>();\n        HashSet<JavaAPIListEntry> hs2 = new HashSet<JavaAPIListEntry>();\n        if (buildDir != null) {\n          List<File> classFiles = _model.getClassFiles();\n          DummyOpenDefDoc dummyDoc = new DummyOpenDefDoc();\n          for(File f: classFiles) {\n            String s = f.toString();\n            if (s.lastIndexOf(File.separatorChar) >= 0) {\n              s = s.substring(s.lastIndexOf(File.separatorChar)+1);\n            }\n            s = s.substring(0, s.lastIndexOf(\".class\"));\n            s = s.replace('$', '.');\n            int pos = 0;\n            boolean ok = true;\n            while ((pos=s.indexOf('.', pos)) >= 0) {\n              if (s.length() <= pos + 1 || Character.isDigit(s.charAt(pos + 1))) {\n                ok = false;\n                break;\n              }\n              ++pos;\n            }\n            if (ok) {\n              if (s.lastIndexOf('.') >= 0) {\n                s = s.substring(s.lastIndexOf('.') + 1);\n              }\n              GoToFileListEntry entry = new GoToFileListEntry(dummyDoc, s);\n              hs.add(entry);\n              try {\n                String rel = FileOps.stringMakeRelativeTo(f, buildDir);\n                String full = rel.replace(File.separatorChar, '.');\n                full = full.substring(0, full.lastIndexOf(\".class\"));\n                if (full.indexOf('$') < 0) {\n                  // No '$' in the name means not an inner class. we do not support inner classes, because that would\n                  // mean having to determine public static scope\n                  hs2.add(new JavaAPIListEntry(s, full, null));\n                }\n              }\n              catch(IOException ioe) { /* ignore, just don't add this one */ }\n              catch(SecurityException se) { /* ignore, just don't add this one */ }\n            }\n          }\n        }\n        clearCompleteClassSet();\n        _completeClassSet.addAll(hs);\n        _autoImportClassSet = new HashSet<JavaAPIListEntry>(hs2);\n      }\n    });\n    t.setPriority(Thread.MIN_PRIORITY);\n    t.start();\n  }\n  \n  private void _runProject() {\n    if (_model.isProjectActive()) {\n      try {\n        final File f = _model.getMainClassContainingFile();\n        if (f != null) {\n          updateStatusField(\"Running Open Project\");\n          OpenDefinitionsDocument doc = _model.getDocumentForFile(f);\n          boolean smart = DrJava.getConfig().getSetting(OptionConstants.SMART_RUN_FOR_APPLETS_AND_PROGRAMS);\n          if (smart) {\n              doc.runSmart(_model.getMainClass());\n          }\n          else {\n              doc.runMain(_model.getMainClass());\n          }\n        }\n      }\n      catch (ClassNameNotFoundException e) {\n        // Display a warning message if a class name can't be found.\n        String msg =\n          \"DrJava could not find the top level class name in the\\n\" +\n          \"current document, so it could not run the class.  Please\\n\" +\n          \"make sure that the class is properly defined first.\";\n        \n        JOptionPane.showMessageDialog(MainFrame.this, msg, \"No Class Found\", JOptionPane.ERROR_MESSAGE);\n      }\n      catch (FileMovedException fme) { _showFileMovedError(fme); }\n      catch (IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n    }\n    else _runMain();\n  }\n  \n  /** Internal helper method to run the main method of the current document in the interactions pane. */\n  private void _runMain() {\n    try {\n      boolean smart = DrJava.getConfig().getSetting(OptionConstants.SMART_RUN_FOR_APPLETS_AND_PROGRAMS);\n      if (smart) {\n        updateStatusField(\"Running main Method of Current Document\");\n        _model.getActiveDocument().runSmart(null);\n      }\n      else {\n        updateStatusField(\"Running Current Document\");\n        _model.getActiveDocument().runMain(null);\n      }\n    }\n    \n    catch (ClassNameNotFoundException e) {\n      // Display a warning message if a class name can't be found.\n      String msg =\n        \"DrJava could not find the top level class name in the\\n\" +\n        \"current document, so it could not run the class.  Please\\n\" +\n        \"make sure that the class is properly defined first.\";\n      \n      JOptionPane.showMessageDialog(MainFrame.this, msg, \"No Class Found\", JOptionPane.ERROR_MESSAGE);\n    }\n    catch (FileMovedException fme) { _showFileMovedError(fme); }\n    catch (IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n  }\n  \n  /** Internal helper method to run the current document as applet in the interactions pane. */\n  private void _runApplet() {\n    updateStatusField(\"Running Current Document as Applet\");\n    \n    try { _model.getActiveDocument().runApplet(null); }\n    \n    catch (ClassNameNotFoundException e) {\n      // Display a warning message if a class name can't be found.\n      String msg =\n        \"DrJava could not find the top level class name in the\\n\" +\n        \"current document, so it could not run the class.  Please\\n\" +\n        \"make sure that the class is properly defined first.\";\n      \n      JOptionPane.showMessageDialog(MainFrame.this, msg, \"No Class Found\", JOptionPane.ERROR_MESSAGE);\n    }\n    catch (FileMovedException fme) { _showFileMovedError(fme); }\n    catch (IOException ioe) { MainFrameStatics.showIOError(MainFrame.this, ioe); }\n  }\n  \n  private void _junit() {\n    /* */ assert Utilities.TEST_MODE || EventQueue.isDispatchThread();\n    \n    hourglassOn(); // turned off in junitStarted/nonTestCase/_junitInterrupted  \n    // moved this back into the event thread to fix bug 2848696\n    // this code doesn't have to run in an auxiliary thread\n    // the actual unit testing later is done in a separate thread\n    _guiAvailabilityNotifier.junitStarted(); // JUNIT and COMPILER\n\n    // now also works with multiple documents\n//        hourglassOn();  // moved into the prelude before this thread start  \n    try { _model.getJUnitModel().junitDocs(_model.getDocumentNavigator().getSelectedDocuments()); }\n    catch(UnexpectedException e) { _junitInterrupted(e); }\n    catch(Exception e) { _junitInterrupted(new UnexpectedException(e)); }\n  }\n  \n  private void _junitFolder() {\n    updateStatusField(\"Running Unit Tests in Current Folder\");\n    hourglassOn();  // turned off in junitStarted/nonTestCase/_junitInterrupted\n    // moved this back into the event thread to fix bug 2848696\n    // this code doesn't have to run in an auxiliary thread\n    // the actual unit testing later is done in a separate thread\n    _guiAvailabilityNotifier.junitStarted(); // JUNIT and COMPILER\n\n//        hourglassOn();  // turned off when JUnitStarted event is fired\n    if (_model.getDocumentNavigator().isGroupSelected()) {\n      ArrayList<OpenDefinitionsDocument> docs = _model.getDocumentNavigator().getDocuments();\n      final LinkedList<OpenDefinitionsDocument> l = new LinkedList<OpenDefinitionsDocument>();\n      for (OpenDefinitionsDocument doc: docs) {\n        if (_model.getDocumentNavigator().isSelectedInGroup(doc)) l.add(doc);\n      }\n      try { _model.getJUnitModel().junitDocs(l); }  // hourglassOn executed by junitStarted()\n      catch(UnexpectedException e) { _junitInterrupted(e); }\n      catch(Exception e) { _junitInterrupted(new UnexpectedException(e)); }\n    }\n  }\n  \n  /** Tests the documents in the project source tree. Assumes that DrJava is in project mode. */\n  private void _junitProject() {\n    updateStatusField(\"Running JUnit Tests in Project\");\n    hourglassOn();  // turned off in junitStarted/nonTestCase/_junitInterrupted\n    _guiAvailabilityNotifier.junitStarted(); // JUNIT and COMPILER\n    try { _model.getJUnitModel().junitProject(); } \n    catch(UnexpectedException e) { _junitInterrupted(e); }\n    catch(Exception e) { _junitInterrupted(new UnexpectedException(e)); }\n  }\n  \n  /** Tests all open documents. */\n  private void _junitAll() {\n    updateStatusField(\"Running All Open Unit Tests\");\n    hourglassOn();  // turned off in junitStarted/nonTestCase/_junitInterrupted\n    _guiAvailabilityNotifier.junitStarted(); // JUNIT and COMPILER\n    try { _model.getJUnitModel().junitAll(); } \n    catch(UnexpectedException e) { _junitInterrupted(e); }\n    catch(Exception e) { _junitInterrupted(new UnexpectedException(e)); }\n  }\n  \n//  /**\n//   * Suspends the current execution of the debugger\n//   */\n//  private void debuggerSuspend() throws DebugException {\n//    if (isDebuggerReady())\n//      _model.getDebugger().suspend();\n//  }\n  \n  /** Resumes the debugger's current execution. */\n  void debuggerResume() throws DebugException {\n    if (isDebuggerReady()) {\n      _model.getDebugger().resume();\n      removeCurrentLocationHighlight();\n    }\n  }\n  \n  /** Automatically traces through the entire program with a defined rate for stepping into each line of code*/\n  void debuggerAutomaticTrace() {\n    if(isDebuggerReady())  {\n      if(!_model.getDebugger().isAutomaticTraceEnabled()) {\n        try {\n          int rate = DrJava.getConfig().getSetting(OptionConstants.AUTO_STEP_RATE);\n          \n          _automaticTraceTimer = new Timer(rate, new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n              if (_model.getDebugger().isAutomaticTraceEnabled()) {\n                // hasn't been disabled in the meantime\n                debuggerStep(Debugger.StepType.STEP_INTO);\n              }\n            }\n          });\n          _automaticTraceTimer.setRepeats(false);\n          _model.getDebugger().setAutomaticTraceEnabled(true);\n          _debugPanel.setAutomaticTraceButtonText();\n          debuggerStep(Debugger.StepType.STEP_INTO);\n        }\n        catch (IllegalStateException ise) {\n          // This may happen if the user if stepping very frequently,\n          // and is even more likely if they are using both hotkeys\n          // and UI buttons. Ignore it in this case.\n          // Hopefully, there are no other situations where\n          // the user can be trying to step while there are no\n          // suspended threads.\n        }        \n      }\n      else {\n        _model.getDebugger().setAutomaticTraceEnabled(false);\n        _debugPanel.setAutomaticTraceButtonText();\n        if (_automaticTraceTimer != null) _automaticTraceTimer.stop();\n      }\n    }    \n  }\n  \n  /** Steps in the debugger. */\n  void debuggerStep(Debugger.StepType type) {\n    if (isDebuggerReady()) {\n      try { _model.getDebugger().step(type); }\n      catch (IllegalStateException ise) {\n        // This may happen if the user if stepping very frequently,\n        // and is even more likely if they are using both hotkeys\n        // and UI buttons. Ignore it in this case.\n        // Hopefully, there are no other situations where\n        // the user can be trying to step while there are no\n        // suspended threads.\n      }\n      catch (DebugException de) {\n        MainFrameStatics.showError(MainFrame.this, de, \"Debugger Error\",\n                                 \"Could not create a step request.\");\n      }\n    }\n  }\n  \n  /** Toggles a breakpoint on the current line. */\n  void debuggerToggleBreakpoint() {\n    addToBrowserHistory();\n    OpenDefinitionsDocument doc = _model.getActiveDocument();\n    \n    boolean isUntitled = doc.isUntitled();\n    if (isUntitled) {\n      JOptionPane.showMessageDialog(this,\n                                    \"You must save and compile this document before you can\\n\" +\n                                    \"set a breakpoint in it.\",\n                                    \"Must Save and Compile\",\n                                    JOptionPane.ERROR_MESSAGE);\n      return;\n    }\n    \n    boolean isModified = doc.isModifiedSinceSave();\n    if (isDebuggerReady() && isModified  && !_currentDefPane.hasWarnedAboutModified() &&\n        DrJava.getConfig().getSetting(WARN_BREAKPOINT_OUT_OF_SYNC).booleanValue()) {\n      String message =\n        \"This document has been modified and may be out of sync\\n\" +\n        \"with the debugger.  It is recommended that you first\\n\" +\n        \"save and recompile before continuing to use the debugger,\\n\" +\n        \"to avoid any unexpected errors.  Would you still like to\\n\" +\n        \"toggle the breakpoint on the specified line?\";\n      String title = \"Toggle breakpoint on modified file?\";\n      \n      ConfirmCheckBoxDialog dialog = new ConfirmCheckBoxDialog(this, title, message);\n      int rc = dialog.show();\n      switch (rc) {\n        case JOptionPane.YES_OPTION:\n          _currentDefPane.hasWarnedAboutModified(true);\n          if (dialog.getCheckBoxValue()) {\n            DrJava.getConfig().setSetting(WARN_BREAKPOINT_OUT_OF_SYNC, Boolean.FALSE);\n          }\n          break;\n          \n        case JOptionPane.NO_OPTION:\n          if (dialog.getCheckBoxValue())  DrJava.getConfig().setSetting(WARN_BREAKPOINT_OUT_OF_SYNC, Boolean.FALSE);\n          return;\n          \n        case JOptionPane.CANCEL_OPTION:\n        case JOptionPane.CLOSED_OPTION:\n          // do nothing\n          return;\n          \n        default:\n          throw new RuntimeException(\"Invalid rc from showConfirmDialog: \" + rc);\n      }\n    }\n    \n    try {\n      Debugger debugger = _model.getDebugger();\n      boolean breakpointSet = \n        debugger.toggleBreakpoint(doc, _currentDefPane.getCaretPosition(), true);\n      if (breakpointSet) showBreakpoints();\n    }\n    catch (DebugException de) {\n      MainFrameStatics.showError(MainFrame.this, de, \"Debugger Error\", \"Could not set a breakpoint at the current line.\");\n    }\n  }\n  \n  \n//  private void _getText(String name) { _field = name; }\n  \n//  /** Adds a watch to a given variable or field. */\n//  void debuggerAddWatch() {\n//    if (isDebuggerReady()) {\n//      //final String field;\n//      OpenDefinitionsDocument doc = _model.getActiveDocument();\n//      final JDialog getFieldDialog = new JDialog(this, \"Choose Field to be Watched\", true);\n//      //getFieldDialog.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);\n//      final JTextField fieldName = new JTextField();\n//      getFieldDialog.setSize(new Dimension(150, 60));\n//      getFieldDialog.getContentPane().add(fieldName);\n//      fieldName.addActionListener(new ActionListener() {\n//        public void actionPerformed(ActionEvent ae) {\n//          _getText(fieldName.getText());\n//          getFieldDialog.dispose();\n//        }\n//      });\n//      getFieldDialog.setLocation(300,300);\n//      getFieldDialog.show();\n//      Debugger debugger = _model.getDebugger();\n//      debugger.addWatch(_field);\n//    }\n//  }\n  \n//  /** Displays all breakpoints currently set in the debugger. */\n//  void _printBreakpoints() { _model.getDebugger().printBreakpoints(); }\n  \n  \n  /** Clears all breakpoints from the debugger. */\n  void debuggerClearAllBreakpoints() {\n    _model.getBreakpointManager().clearRegions();\n  }\n  \n  void _showFileMovedError(FileMovedException fme) {\n    try {\n      File f = fme.getFile();\n      OpenDefinitionsDocument doc = _model.getDocumentForFile(f);\n      if (doc != null && _saveSelector.shouldSaveAfterFileMoved(doc, f)) _saveAs();\n    }\n    catch (IOException ioe) { /* Couldn't find the document, so ignore the FME */ }\n  }\n  \n  void _showProjectFileParseError(MalformedProjectFileException mpfe) {\n    showProjectFileParseError(this, mpfe);\n  }\n  \n  void _showFileNotFoundError(FileNotFoundException fnf) {\n    showFileNotFoundError(this, fnf);\n  }\n  \n  void _showIOError(IOException ioe) {\n    showIOError(this, ioe);\n  }\n  \n  void _showClassNotFoundError(ClassNotFoundException cnfe) {\n    showClassNotFoundError(this, cnfe);\n  }\n  \n  void _showNoClassDefError(NoClassDefFoundError ncde) {\n    showNoClassDefError(this, ncde);\n  }\n  \n  void _showDebugError(DebugException de) {\n    showDebugError(this, de);\n  }\n  \n  void _showJUnitInterrupted(UnexpectedException e) {\n    showJUnitInterrupted(this, e);\n  }\n\n  void _showJUnitInterrupted(String message) {\n    showJUnitInterrupted(this, message);\n  }\n  \n  void _showError(Throwable e, String title, String message) {    \n    showError(this, e, title, message);\n  }\n  \n  void _showWarning(Throwable e, String title, String message) {\n    showWarning(this, e, title, message);\n  }\n  \n  /** Check if any errors occurred while parsing the config file, and display a message if necessary. */\n  private void _showConfigException() {\n    if (DrJava.getConfig().hadStartupException()) {\n      try {\n        DrJava.getConfig().saveConfiguration();\n      }\n      catch(IOException ioe) { /* ignore */ }\n      Exception e = DrJava.getConfig().getStartupException();\n      MainFrameStatics.showError(this, e, \"Error in Config File\",\n                               \"Could not read the '.drjava' configuration file\\n\" +\n                               \"in your home directory.  Starting with default\\n\" +\n                               \"values instead.\\n\\n\" + \"The problem was:\\n\");\n    }\n  }\n  \n  /** Returns the File selected by the JFileChooser.\n    * @param fc File chooser presented to the user\n    * @param choice return value from fc\n    * @param previous previous file (or null if none)\n    * @return Selected File\n    * @throws OperationCanceledException if file choice canceled\n    * @throws RuntimeException if fc returns a bad file or choice\n    */\n  private File getChosenFile(JFileChooser fc, int choice, File previous) throws OperationCanceledException {\n    switch (choice) {\n      case JFileChooser.CANCEL_OPTION:\n      case JFileChooser.ERROR_OPTION:\n        throw new OperationCanceledException();\n      case JFileChooser.APPROVE_OPTION:\n        File chosen = fc.getSelectedFile();\n        if (chosen != null) {\n          //append the appropriate language level extension if not written by user\n          if (fc.getFileFilter() instanceof JavaSourceFilter) {\n            if (chosen.getName().indexOf(\".\") == -1) {\n              // no file extension\n              String previousName = (previous!=null)?previous.getName():\"\";\n              if (!DrJavaFileUtils.isSourceFile(previousName)) {\n                // previous file name doesn't have a file extension either\n                return new File(chosen.getAbsolutePath() + OptionConstants.\n                                  LANGUAGE_LEVEL_EXTENSIONS[DrJava.getConfig().getSetting(LANGUAGE_LEVEL)]);\n              }\n              else {\n                // use previous file's extension\n                int previousLastDotPos = previousName.lastIndexOf(\".\");\n                String previousExt = previousName.substring(previousLastDotPos);\n                File newFile = new File(chosen.getAbsolutePath() + previousExt);\n                return newFile;\n              }\n            }\n          }\n          return chosen;\n        }\n        else\n          throw new RuntimeException(\"Filechooser returned null file\");\n      default:                  // impossible since rc must be one of these\n        throw  new RuntimeException(\"Filechooser returned bad rc \" + choice);\n    }\n  }\n  /** Returns the Files selected by the JFileChooser.\n    * @param fc File chooser presented to the user\n    * @param choice return value from fc\n    * @return Selected Files - this array will be size 1 for single-selection dialogs.\n    * @throws OperationCanceledException if file choice canceled\n    * @throws RuntimeException if fc returns a bad file or choice\n    */\n  private File[] getChosenFiles(JFileChooser fc, int choice) throws OperationCanceledException {\n    switch (choice) {\n      case JFileChooser.CANCEL_OPTION:\n      case JFileChooser.ERROR_OPTION:\n        throw new OperationCanceledException();\n      case JFileChooser.APPROVE_OPTION:\n        File[] chosen = fc.getSelectedFiles();\n        if (chosen == null)\n          throw new UnexpectedException(new OperationCanceledException(), \"filechooser returned null file\");\n        \n        // Following code reviewed for bug 70902-- JVF\n        // If this is a single-selection dialog, getSelectedFiles() will always\n        // return a zero-size array -- handle it differently.\n        if (chosen.length == 0) {\n          if (!fc.isMultiSelectionEnabled()) {\n            return new File[] { fc.getSelectedFile() };\n          }\n          else {\n            /* This is the workaround for bug 70902: sometimes Mac OS X will return\n             * APPROVE_OPTION when the user clicks the close (x) control button\n             * on the dialog window, even though nothing is selected.\n             */\n            throw new OperationCanceledException();\n          }\n        }\n        else {\n          return chosen;\n        }\n        \n      default:                  // impossible since rc must be one of these\n        throw new UnexpectedException(new OperationCanceledException(), \"filechooser returned bad rc \" + choice);\n    }\n  }\n  \n  private void _selectAll() { _currentDefPane.selectAll(); }\n  \n  /** Jump to the specified line and return the offset.  Only runs in event thread.\n    * @return offset */\n  public int _jumpToLine(int lineNum) {   \n    int pos = _model.getActiveDocument().gotoLine(lineNum);\n    addToBrowserHistory();\n    _currentDefPane.setCaretPosition(pos);\n    _currentDefPane.centerViewOnOffset(pos);\n    return pos;\n  }\n  \n  /** Ask the user what line they'd like to jump to, then go there. */\n  private int _gotoLine() {\n    final String msg = \"What line would you like to go to?\";\n    final String title = \"Go to Line\";\n    String lineStr = JOptionPane.showInputDialog(this, msg, title, JOptionPane.QUESTION_MESSAGE);\n    try {\n      if (lineStr != null) {\n        int lineNum = Integer.parseInt(lineStr);\n        return _jumpToLine(lineNum);      }\n    }\n    catch (NumberFormatException nfe) {\n      // invalid input for line number\n      Toolkit.getDefaultToolkit().beep();\n      // Do nothing.\n    }\n    //catch (BadLocationException ble) { }\n    return -1;\n  }\n  \n  /** Removes the ErrorCaretListener corresponding to the given document, after that document has been closed.\n    * (Allows pane and listener to be garbage collected...)\n    */\n  private void _removeErrorListener(OpenDefinitionsDocument doc) {\n    JScrollPane scroll = _defScrollPanes.get(doc);\n    if (scroll != null) {\n      DefinitionsPane pane = (DefinitionsPane) scroll.getViewport().getView();\n      pane.removeCaretListener(pane.getErrorCaretListener());\n    }\n  }\n  \n  void _addGUIAvailabilityListener(Action a, GUIAvailabilityListener.ComponentType... components) {\n    _guiAvailabilityNotifier.\n      addListener(new AndGUIAvailabilityActionAdapter(a, _guiAvailabilityNotifier, components));\n  }\n\n  void _addGUIAvailabilityListener(Component a, GUIAvailabilityListener.ComponentType... components) {\n    _guiAvailabilityNotifier.\n      addListener(new AndGUIAvailabilityComponentAdapter(a, _guiAvailabilityNotifier, components));\n  }\n  \n  void _displayGUIComponentAvailabilityFrame() {\n    JFrame frame = new JFrame(\"GUI Availability\");\n    frame.setAlwaysOnTop(true );\n    frame.setLocationByPlatform(true);\n    frame.getContentPane().setLayout(new BoxLayout(frame.getContentPane(), BoxLayout.PAGE_AXIS));\n    for(final GUIAvailabilityListener.ComponentType c: GUIAvailabilityListener.ComponentType.values()) {\n      final edu.rice.cs.plt.lambda.DelayedThunk<JButton> buttonThunk = edu.rice.cs.plt.lambda.DelayedThunk.make();  \n      final JButton button = new JButton(new AbstractAction(c.toString()+\" \"+_guiAvailabilityNotifier.getCount(c)) {\n        public void actionPerformed(ActionEvent e) {\n          _guiAvailabilityNotifier.availabilityChanged(c, !buttonThunk.value().getText().endsWith(\" 0\"));\n        }\n      });\n      buttonThunk.set(button);\n      _guiAvailabilityNotifier.addListener(new AndGUIAvailabilityListener(_guiAvailabilityNotifier, c) {\n        public void availabilityChanged(boolean available) {\n          button.setText(c.toString()+\" \"+_guiAvailabilityNotifier.getCount(c));\n          button.setSelected(available);\n        }\n      });\n      button.setSelected(_guiAvailabilityNotifier.isAvailable(c));\n      frame.add(button);\n    }\n    frame.pack();\n    frame.setVisible(true);\n  }\n  \n  /** Initialize the availability of GUI components.\n    * \n    * When JUnit is running, the compiler or Javadoc should not be invoked (Javadoc may invoke the compiler).\n    */\n  private void _setUpGUIComponentAvailability() {\n//    _displayGUIComponentAvailabilityFrame();\n    \n    _guiAvailabilityNotifier.ensureUnavailable(GUIAvailabilityListener.ComponentType.PROJECT);\n    _guiAvailabilityNotifier.ensureUnavailable(GUIAvailabilityListener.ComponentType.PROJECT_BUILD_DIR);\n    _guiAvailabilityNotifier.ensureUnavailable(GUIAvailabilityListener.ComponentType.PROJECT_MAIN_CLASS);\n    _guiAvailabilityNotifier.ensureUnavailable(GUIAvailabilityListener.ComponentType.DEBUGGER);\n    _guiAvailabilityNotifier.ensureUnavailable(GUIAvailabilityListener.ComponentType.DEBUGGER_SUSPENDED);\n    _guiAvailabilityNotifier.ensureAvailable(GUIAvailabilityListener.ComponentType.JUNIT);\n    _guiAvailabilityNotifier.ensureAvailable(GUIAvailabilityListener.ComponentType.COMPILER);\n    _guiAvailabilityNotifier.ensureAvailabilityIs(GUIAvailabilityListener.ComponentType.JAVADOC,\n                                                  _model.getJavadocModel().isAvailable());\n  }\n  \n  /** Initializes all action objects.  Adds icons and descriptions to several of the actions. Note: this \n    * initialization will later be done in the constructor of each action, which will subclass AbstractAction.\n    */\n  private void _setUpActions() {\n    _setUpAction(_newAction, \"New\", \"Create a new document\");\n    _setUpAction(_newClassAction, \"New\", \"Create a new Java Class\");\n    _setUpAction(_newJUnitTestAction, \"New\", \"Create a new JUnit test case class\");\n    _setUpAction(_newProjectAction, \"New\", \"Make a new project\");\n    _setUpAction(_openAction, \"Open\", \"Open an existing file\");\n    _setUpAction(_openFolderAction, \"Open Folder\", \"OpenAll\", \"Open all files within a directory\");\n    _setUpAction(_openFileOrProjectAction, \"Open\", \"Open an existing file or project\");\n    _setUpAction(_openProjectAction, \"Open\", \"Open an existing project\");\n    _setUpAction(_saveAction, \"Save\", \"Save the current document\");\n    _setUpAction(_saveAsAction, \"Save As\", \"SaveAs\", \"Save the current document with a new name\");\n    _setUpAction(_saveCopyAction, \"Save Copy\", \"SaveAs\", \"Save a copy of the current document\");\n    _setUpAction(_renameAction, \"Rename\", \"Rename\", \"Rename the current document\");\n    _setUpAction(_saveProjectAction, \"Save\", \"Save\", \"Save the current project\");\n    _setUpAction(_saveProjectAsAction, \"Save As\", \"SaveAs\", \"Save current project to new project file\");\n    _setUpAction(_exportProjectInOldFormatAction, \"Export Project In Old \\\"\" + OLD_PROJECT_FILE_EXTENSION +\n                 \"\\\" Format\", \"SaveAs\", \"Export Project In Old \\\"\" + OLD_PROJECT_FILE_EXTENSION + \"\\\" Format\");\n    _setUpAction(_revertAction, \"Revert\", \"Revert the current document to the saved version\");\n    // Not yet working\n//    _setUpAction(_revertAllAction, \"Revert All\", \"RevertAll\",\n//                 \"Revert all open documents to the saved versions\");\n    \n    _setUpAction(_closeAction, \"Close\", \"Close the current document\");\n    _setUpAction(_closeAllAction, \"Close All\", \"CloseAll\", \"Close all documents\");\n    _setUpAction(_closeProjectAction, \"Close\", \"CloseAll\", \"Close the current project\");\n    _setUpAction(_projectPropertiesAction, \"Project Properties\", \"Preferences\", \"Edit Project Properties\");\n    _setUpAction(_junitProjectAction, \"Test Project\", \"Test the documents in the project source tree\");\n    _setUpAction(_compileProjectAction, \"Compile Project\", \"Compile the documents in the project source tree\");\n    _setUpAction(_runProjectAction, \"Run Project\", \"Run the project's main method\");\n    _setUpAction(_jarProjectAction, \"Jar\", \"Create a jar archive from this project\");\n    _setUpAction(_saveAllAction, \"Save All\", \"SaveAll\", \"Save all open documents\");\n    _setUpAction(_cleanAction, \"Clean\", \"Clean Build directory\");\n    _setUpAction(_autoRefreshAction, \"Auto-Refresh\", \"Auto-refresh project\");\n    _setUpAction(_compileAction, \"Compile Current Document\", \"Compile the current document\");\n    _setUpAction(_compileAllAction, \"Compile\", \"Compile all open documents\");\n    _setUpAction(_printDefDocAction, \"Print\", \"Print the current document\");\n    _setUpAction(_printConsoleAction, \"Print\", \"Print the Console pane\");\n    _setUpAction(_printInteractionsAction, \"Print\", \"Print the Interactions pane\");\n    _setUpAction(_pageSetupAction, \"Page Setup\", \"PageSetup\", \"Change the printer settings\");\n    _setUpAction(_printDefDocPreviewAction, \"Print Preview\", \"PrintPreview\", \n                 \"Preview how the document will be printed\");\n    _setUpAction(_printConsolePreviewAction, \"Print Preview\", \"PrintPreview\", \n                 \"Preview how the console document will be printed\");\n    _setUpAction(_printInteractionsPreviewAction, \"Print Preview\", \"PrintPreview\", \n                 \"Preview how the interactions document will be printed\");    \n    \n    _setUpAction(_quitAction, \"Quit\", \"Quit\", \"Quit DrJava\");\n    \n    _setUpAction(_undoAction, \"Undo\", \"Undo previous command\");\n    _setUpAction(_redoAction, \"Redo\", \"Redo last undo\");\n    _undoAction.putValue(Action.NAME, \"Undo previous command\");\n    _redoAction.putValue(Action.NAME, \"Redo last undo\");\n    \n    _setUpAction(cutAction, \"Cut\", \"Cut selected text to the clipboard\");\n    _setUpAction(copyAction, \"Copy\", \"Copy selected text to the clipboard\");\n    _setUpAction(pasteAction, \"Paste\", \"Paste text from the clipboard\");\n    _setUpAction(_pasteHistoryAction, \"Paste from History\", \"Paste text from the clipboard history\");\n    _setUpAction(_selectAllAction, \"Select All\", \"Select all text\");\n    \n    cutAction.putValue(Action.NAME, \"Cut\");\n    copyAction.putValue(Action.NAME, \"Copy\");\n    pasteAction.putValue(Action.NAME, \"Paste\");\n    _pasteHistoryAction.putValue(Action.NAME, \"Paste from History\");\n    \n    _setUpAction(_indentLinesAction, \"Indent Lines\", \"Indent all selected lines\");\n    _setUpAction(_commentLinesAction, \"Comment Lines\", \"Comment out all selected lines\");\n    _setUpAction(_uncommentLinesAction, \"Uncomment Lines\", \"Uncomment all selected lines\");\n    \n    _setUpAction(completeWordUnderCursorAction, \"Auto-Complete Word Under Cursor\",\n                 \"Auto-complete the word the cursor is currently located on\");\n    _setUpAction(_bookmarksPanelAction, \"Bookmarks\", \"Display the bookmarks panel\");\n    _setUpAction(_toggleBookmarkAction, \"Toggle Bookmark\", \"Toggle the bookmark at the current cursor location\");\n    _setUpAction(_followFileAction, \"Follow File\", \"Follow a file's updates\");\n    _setUpAction(_executeExternalProcessAction, \"Execute External\", \"Execute external process\");\n    _setUpAction(_editExternalProcessesAction, \"Preferences\", \"Edit saved external processes\");\n    \n    _setUpAction(_findReplaceAction, \"Find\", \"Find or replace text in the document\");\n    _setUpAction(_findNextAction, \"Find Next\", \"Repeats the last find\");\n    _setUpAction(_findPrevAction, \"Find Previous\", \"Repeats the last find in the opposite direction\");\n    _setUpAction(_gotoLineAction, \"Go to line\", \"Go to a line number in the document\");\n    _setUpAction(_gotoFileAction, \"Go to File\", \"Go to a file specified by its name\");\n    _setUpAction(_gotoFileUnderCursorAction, \"Go to File Under Cursor\",\n                 \"Go to the file specified by the word the cursor is located on\");\n    \n    _setUpAction(_switchToPrevAction, \"Previous Document\", \"Up\", \"Switch to the previous document\");\n    _setUpAction(_switchToNextAction, \"Next Document\", \"Down\", \"Switch to the next document\");\n    \n    _setUpAction(_browseBackAction, \"Back\", \"Back\", \"Move back in the browser history\");\n    _setUpAction(_browseForwardAction, \"Forward\", \"Forward\", \"Move forward in the browser history\");    \n    \n    _setUpAction(_prevRegionAction, \"Previous Region\", \"Move to previous region in tabbed pane\");\n    _setUpAction(_nextRegionAction, \"Next Region\", \"Move to next region in tabbed pane\");\n\n    _setUpAction(_switchToPreviousPaneAction, \"Previous Pane\", \"Switch focus to the previous pane\");\n    _setUpAction(_switchToNextPaneAction, \"Next Pane\", \"Switch focus to the next pane\");\n    _setUpAction(_gotoOpeningBraceAction, \"Go to Opening Brace\", \n                 \"Go th the opening brace of the block enclosing the cursor\");\n    _setUpAction(_gotoClosingBraceAction, \"Go to Closing Brace\", \n                 \"Go th the closing brace of the block enclosing the cursor\");\n    \n    _setUpAction(_editPreferencesAction, \"Preferences\", \"Edit configurable settings in DrJava\");\n    \n    _setUpAction(_junitAction, \"Test Current\", \"Run JUnit over the current document\");\n    _setUpAction(_junitAllAction, \"Test\", \"Run JUnit over all open JUnit tests\");\n    if (_model.getJavadocModel().isAvailable()) {\n      _setUpAction(_javadocAllAction, \"Javadoc\", \"Create and save Javadoc for the packages of all open documents\");\n      _setUpAction(_javadocCurrentAction, \"Preview Javadoc Current\", \"Preview the Javadoc for the current document\");\n    }\n    else {\n      _setUpAction(_javadocAllAction, \"Javadoc\",\n                   \"Note: DrJava cannot run Javadoc because no JDK was found. Please install a JDK.\");\n      _setUpAction(_javadocCurrentAction, \"Preview Javadoc Current\",\n                   \"Note: DrJava cannot run Javadoc because no JDK was found.  Please install a JDK.\");\n    }\n    _setUpAction(_runAction, \"Run\", \"Run the main method of the current document\");\n    _setUpAction(_runAppletAction, \"Run\", \"Run the current document as applet\");\n    \n    _setUpAction(_openJavadocAction, \"Open Java API Javadoc...\", \"Open the Java API Javadoc Web page for a class\");\n    _setUpAction(_openJavadocUnderCursorAction, \"Open Java API Javadoc for Word Under Cursor...\", \"Open the Java API \" +\n                 \"Javadoc Web page for the word under the cursor\");\n    \n    _setUpAction(_saveInteractionsCopyAction, \"Save Copy of Interactions...\",\n                 \"SaveAs\", \"Save copy of interactions contents to a file\");\n    _setUpAction(_executeHistoryAction, \"Execute History\", \"Load and execute a history of interactions from a file\");\n    _setUpAction(_loadHistoryScriptAction, \"Load History as Script\", \n                 \"Load a history from a file as a series of interactions\");\n    _setUpAction(_saveHistoryAction, \"Save History\", \"Save the history of interactions to a file\");\n    _setUpAction(_clearHistoryAction, \"Clear History\", \"Clear the current history of interactions\");\n    \n    _setUpAction(_resetInteractionsAction, \"Reset\", \"Reset the Interactions Pane\");\n    _setUpAction(_closeSystemInAction, \"Close System.in\", \"Close System.in Stream in Interactions Pane\"); \n    \n    _setUpAction(_viewInteractionsClassPathAction, \"View Interactions Classpath\", \n                 \"Display the classpath in use by the Interactions Pane\");\n    _setUpAction(_copyInteractionToDefinitionsAction, \"Lift Current Interaction\", \n                 \"Copy the current interaction into the Definitions Pane\");\n    \n    _setUpAction(_saveConsoleCopyAction, \"Save Copy of Console...\",\n                 \"SaveAs\", \"Save copy of console contents to a file\");\n    _setUpAction(_clearConsoleAction, \"Clear Console\", \"Clear all text in the Console Pane\");\n    _setUpAction(_showDebugConsoleAction, \"Show DrJava Debug Console\", \"<html>Show a console for debugging DrJava<br>\" +\n                 \"(with \\\"mainFrame\\\", \\\"model\\\", and \\\"config\\\" variables defined)</html>\");\n    \n    if (_model.getDebugger().isAvailable()) {\n      _setUpAction(_toggleDebuggerAction, \"Debug Mode\", \"Enable or disable DrJava's debugger\");\n      _setUpAction(_toggleBreakpointAction, \"Toggle Breakpoint\", \"Set or clear a breakpoint on the current line\");\n      _setUpAction(_clearAllBreakpointsAction, \"Clear Breakpoints\", \"Clear all breakpoints in all classes\");\n      _setUpAction(_resumeDebugAction, \"Resume\", \"Resume the current suspended thread\");\n      _setUpAction(_automaticTraceDebugAction, \"Automatic Trace\", \"Automatically trace through entire program\");\n      _setUpAction(_stepIntoDebugAction, \"Step Into\", \"Step into the current line or method call\");\n      _setUpAction(_stepOverDebugAction, \"Step Over\", \"Step over the current line or method call\");\n      _setUpAction(_stepOutDebugAction, \"Step Out\", \"Step out of the current method\");\n      _setUpAction(_breakpointsPanelAction, \"Breakpoints\", \"Display the breakpoints panel\");\n    }\n    \n    _setUpAction(_helpAction, \"Help\", \"Show documentation on how to use DrJava\");\n    _setUpAction(_quickStartAction, \"Help\", \"View Quick Start Guide for DrJava\");\n    _setUpAction(_aboutAction, \"About\", \"About DrJava\");\n    _setUpAction(_checkNewVersionAction, \"Check for New Version\", \"Find\", \"Check for New Version\");\n    _checkNewVersionAction.setEnabled(DrJava.getConfig().getSetting(OptionConstants.NEW_VERSION_ALLOWED));\n    _setUpAction(_drjavaSurveyAction, \"Send System Information\", \"About\", \n                 \"Send anonymous system information to DrJava developers\");\n    _setUpAction(_errorsAction, \"DrJava Errors\", \"drjavaerror\", \"Show a window with internal DrJava errors\");\n    _setUpAction(_forceQuitAction, \"Force Quit\", \"Stop\", \"Force DrJava to quit without cleaning up\");\n    _setUpAction(_generateCustomDrJavaJarAction, \"Generate Custom drjava.jar...\",\n                 \"<html>Generate a custom drjava.jar file that includes additional files,<br>\"+\n                 \"e.g. libraries or resources.</html>\");\n  }\n  \n  private void _setUpAction(Action a, String name, String icon, String longDesc) {\n    a.putValue(Action.SMALL_ICON, _getIcon(icon + \"16.gif\"));\n    a.putValue(Action.DEFAULT, name);\n    a.putValue(Action.LONG_DESCRIPTION, longDesc);\n  }\n  \n  private void _setUpAction(Action a, String icon, String shortDesc) { _setUpAction(a, icon, icon, shortDesc); }\n  \n  \n  /** Returns the icon with the given name. All icons are assumed to reside in the /edu/rice/cs/drjava/ui/icons\n    * directory.\n    * @param name Name of icon image file\n    * @return ImageIcon object constructed from the file\n    */\n  private ImageIcon _getIcon(String name) { return getIcon(name); }\n  \n  public static ImageIcon getIcon(String name) {\n    URL url = MainFrame.class.getResource(ICON_PATH + name);\n    if (url != null)  return new ImageIcon(url);\n    \n    return null;\n  }\n  \n  /** This allows us to intercept key events when compiling testing and turn them off when the glass pane is up. */\n  static class MenuBar extends JMenuBar {\n    private final MainFrame _mf;\n    public MenuBar(MainFrame mf) { _mf = mf; }\n    public boolean processKeyBinding(KeyStroke ks, KeyEvent e, int condition, boolean pressed) {\n      if (_mf.getAllowKeyEvents()) return super.processKeyBinding(ks, e, condition, pressed);\n      return false;\n    }\n  }\n  \n  public void addMenuBarInOtherFrame(JMenuBar menuBar) {\n    JMenu fileMenu = menuBar.getMenu(Utilities.getComponentIndex(_fileMenu));\n    _recentFileManager.addMirroredMenu(fileMenu);\n    JMenu projectMenu = menuBar.getMenu(Utilities.getComponentIndex(_projectMenu));\n    _recentProjectManager.addMirroredMenu(projectMenu);\n  }\n\n  public void removeMenuBarInOtherFrame(JMenuBar menuBar) {\n    JMenu fileMenu = menuBar.getMenu(Utilities.getComponentIndex(_fileMenu));\n    _recentFileManager.removeMirroredMenu(fileMenu);\n    JMenu projectMenu = menuBar.getMenu(Utilities.getComponentIndex(_projectMenu));\n    _recentProjectManager.removeMirroredMenu(projectMenu);\n  }\n    \n  /** Sets up the components of the menu bar and links them to the private fields within MainFrame.  This method \n    * serves to make the code more legible on the higher calling level, i.e., the constructor.\n    */\n  void _setUpMenuBar(JMenuBar menuBar) {\n    int mask = Toolkit.getDefaultToolkit().getMenuShortcutKeyMask();\n    _setUpMenuBar(menuBar,\n                  _setUpFileMenu(mask, false), _setUpEditMenu(mask, false), _setUpToolsMenu(mask, false),\n                  _setUpProjectMenu(mask, false), _showDebugger?_setUpDebugMenu(mask, false):null,\n                  _folderChooser._setUpLanguageLevelMenu(this, mask, false), _setUpHelpMenu(mask, false));\n  }\n\n  void _setUpMenuBar(JMenuBar menuBar,\n                     JMenu fileMenu,\n                     JMenu editMenu,\n                     JMenu toolsMenu,\n                     JMenu projectMenu,\n                     JMenu debugMenu,\n                     JMenu languageLevelMenu,\n                     JMenu helpMenu) {\n    menuBar.add(fileMenu);\n    menuBar.add(editMenu);\n    menuBar.add(toolsMenu);\n    menuBar.add(projectMenu);\n    if (_showDebugger && (debugMenu!=null)) menuBar.add(debugMenu);\n    menuBar.add(languageLevelMenu);\n    menuBar.add(helpMenu);\n    // Plastic-specific style hints\n    if(Utilities.isPlasticLaf()) {\n      menuBar.putClientProperty(com.jgoodies.looks.Options.HEADER_STYLE_KEY, com.jgoodies.looks.HeaderStyle.BOTH);\n    }\n  }\n  \n  /** Adds an Action as a menu item to the given menu, using the specified configurable keystroke.\n    * @param menu Menu to add item to\n    * @param a Action for the menu item\n    * @param opt Configurable keystroke for the menu item\n    * @param updateKeyboardManager true if the keyboard manager should be updated; pass true only for MainFrame!\n    * @return the added menu item\n    */\n  private JMenuItem _addMenuItem(JMenu menu, Action a, VectorOption<KeyStroke> opt, boolean updateKeyboardManager) {\n    JMenuItem item;\n    item = menu.add(a);\n    _setMenuShortcut(item, a, opt, updateKeyboardManager);\n    return item;\n  }\n\n  /** Inserts an Action as a menu item to the given menu, at the specified index,\n    * using the specified configurable keystroke.\n    * @param menu Menu to add item to\n    * @param a Action for the menu item\n    * @param opt Configurable keystroke for the menu item\n    * @param index Index at which the action is inserted\n    * @param updateKeyboardManager true if the keyboard manager should be updated; pass true only for MainFrame!\n    * @return the added menu item\n    */\n  private JMenuItem _addMenuItem(JMenu menu, Action a, VectorOption<KeyStroke> opt, int index,\n                                 boolean updateKeyboardManager) {\n    JMenuItem item;\n    item = menu.insert(a, index);\n    _setMenuShortcut(item, a, opt, updateKeyboardManager);\n    return item;\n  }\n  \n  /** Sets the given menu item to have the specified configurable keystroke.\n    * @param item Menu item containing the action\n    * @param a Action for the menu item\n    * @param opt Configurable keystroke for the menu item\n    * @param updateKeyboardManager true if the keyboard manager should be updated; pass true only for MainFrame!\n    */\n  private void _setMenuShortcut(JMenuItem item, Action a, VectorOption<KeyStroke> opt, boolean updateKeyboardManager) {\n    Vector<KeyStroke> keys = DrJava.getConfig().getSetting(opt);\n    // Checks that \"a\" is the action associated with the keystroke.\n    // Need to check in case two actions were assigned to the same\n    // key in the config file.\n    // Also check that the keystroke isn't the NULL_KEYSTROKE, which\n    //  can strangely be triggered by certain keys in Windows.\n    if (updateKeyboardManager) { KeyBindingManager.ONLY.put(opt, a, item, item.getText()); }\n    if ((keys.size() > 0) && KeyBindingManager.ONLY.get(keys.get(0)) == a) {\n      item.setAccelerator(keys.get(0));\n    }\n  }\n  \n  /** Creates and returns a file menu.  Side effects: sets values for _saveMenuItem.\n    * @param mask the keystroke modifier to be used\n    * @param updateKeyboardManager true if the keyboard manager should be updated; pass true only for MainFrame!\n    */\n  private JMenu _setUpFileMenu(int mask, boolean updateKeyboardManager) {\n    JMenu fileMenu = new JMenu(\"File\");\n    PlatformFactory.ONLY.setMnemonic(fileMenu,KeyEvent.VK_F);\n    // New, open\n    _addMenuItem(fileMenu, _newAction, KEY_NEW_FILE, updateKeyboardManager);\n    _addMenuItem(fileMenu, _newClassAction, KEY_NEW_CLASS_FILE, updateKeyboardManager);\n\n    _addMenuItem(fileMenu, _newJUnitTestAction, KEY_NEW_TEST, updateKeyboardManager);\n    _addMenuItem(fileMenu, _openAction, KEY_OPEN_FILE, updateKeyboardManager);\n    _addMenuItem(fileMenu, _openFolderAction, KEY_OPEN_FOLDER, updateKeyboardManager);\n    \n    fileMenu.addSeparator();\n    \n    _addMenuItem(fileMenu, _saveAction, KEY_SAVE_FILE, updateKeyboardManager);\n    _saveAction.setEnabled(true);\n    _addMenuItem(fileMenu, _saveAsAction, KEY_SAVE_FILE_AS, updateKeyboardManager);\n    _addMenuItem(fileMenu, _saveCopyAction, KEY_SAVE_FILE_COPY, updateKeyboardManager);\n    _addMenuItem(fileMenu, _saveAllAction, KEY_SAVE_ALL_FILES, updateKeyboardManager);\n    _addMenuItem(fileMenu, _renameAction, KEY_RENAME_FILE, updateKeyboardManager);\n    _renameAction.setEnabled(false);\n    \n    _addMenuItem(fileMenu, _revertAction, KEY_REVERT_FILE, updateKeyboardManager);\n    _revertAction.setEnabled(false);\n    //tmpItem = fileMenu.add(_revertAllAction);\n    \n    // Close, Close all\n    fileMenu.addSeparator();\n    _addMenuItem(fileMenu, _closeAction, KEY_CLOSE_FILE, updateKeyboardManager);\n    _addMenuItem(fileMenu, _closeAllAction, KEY_CLOSE_ALL_FILES, updateKeyboardManager);\n    \n    // Page setup, print preview, print\n    fileMenu.addSeparator();\n    _addMenuItem(fileMenu, _pageSetupAction, KEY_PAGE_SETUP, updateKeyboardManager);\n    _addMenuItem(fileMenu, _printDefDocPreviewAction, KEY_PRINT_PREVIEW, updateKeyboardManager);\n    _addMenuItem(fileMenu, _printDefDocAction, KEY_PRINT, updateKeyboardManager);\n    \n    // Quit\n    fileMenu.addSeparator();\n    _addMenuItem(fileMenu, _quitAction, KEY_QUIT, updateKeyboardManager);\n    \n    return fileMenu;\n  }\n  \n  /** Creates and returns a edit menu.\n    * @param mask the keystroke modifier to be used\n    * @param updateKeyboardManager true if the keyboard manager should be updated; pass true only for MainFrame!\n    */\n  private JMenu _setUpEditMenu(int mask, boolean updateKeyboardManager) {\n    JMenu editMenu = new JMenu(\"Edit\");\n    PlatformFactory.ONLY.setMnemonic(editMenu,KeyEvent.VK_E);\n    // Undo, redo\n    final JMenuItem undoItem = _addMenuItem(editMenu, _undoAction, KEY_UNDO, updateKeyboardManager);\n    _undoAction.addPropertyChangeListener(new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        if (\"enabled\".equals(evt.getPropertyName())) {\n          boolean val = (Boolean) evt.getNewValue();\n          undoItem.setEnabled(val);\n        }\n      }\n    });\n    \n    final JMenuItem redoItem = _addMenuItem(editMenu, _redoAction, KEY_REDO, updateKeyboardManager);\n    _redoAction.addPropertyChangeListener(new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        if (\"enabled\".equals(evt.getPropertyName())) {\n          boolean val = (Boolean) evt.getNewValue();\n          redoItem.setEnabled(val);\n        }\n      }\n    });\n    \n    // Cut, copy, paste, select all\n    editMenu.addSeparator();\n    _addMenuItem(editMenu, cutAction, KEY_CUT, updateKeyboardManager);\n    _addMenuItem(editMenu, copyAction, KEY_COPY, updateKeyboardManager);\n    _addMenuItem(editMenu, pasteAction, KEY_PASTE, updateKeyboardManager);\n    _addMenuItem(editMenu, _pasteHistoryAction, KEY_PASTE_FROM_HISTORY, updateKeyboardManager);\n    _addMenuItem(editMenu, _selectAllAction, KEY_SELECT_ALL, updateKeyboardManager);\n    \n    // Indent lines, comment lines\n    editMenu.addSeparator();\n    //_addMenuItem(editMenu, _indentLinesAction, KEY_INDENT, updateKeyboardManager);\n    JMenuItem editItem = editMenu.add(_indentLinesAction);\n    editItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_TAB, 0));\n    _addMenuItem(editMenu, _commentLinesAction, KEY_COMMENT_LINES, updateKeyboardManager);\n    _addMenuItem(editMenu, _uncommentLinesAction, KEY_UNCOMMENT_LINES, updateKeyboardManager);\n    _addMenuItem(editMenu, completeWordUnderCursorAction, KEY_COMPLETE_FILE, updateKeyboardManager);\n    \n    // Find/replace\n    editMenu.addSeparator();\n    _addMenuItem(editMenu, _findReplaceAction, KEY_FIND_REPLACE, updateKeyboardManager);\n    _addMenuItem(editMenu, _findNextAction, KEY_FIND_NEXT, updateKeyboardManager);\n    _addMenuItem(editMenu, _findPrevAction, KEY_FIND_PREV, updateKeyboardManager);\n    \n    // Next, prev doc\n    editMenu.addSeparator();\n    _addMenuItem(editMenu, _switchToPrevAction, KEY_PREVIOUS_DOCUMENT, updateKeyboardManager);\n    _addMenuItem(editMenu, _switchToNextAction, KEY_NEXT_DOCUMENT, updateKeyboardManager);\n    _addMenuItem(editMenu, _browseBackAction, KEY_BROWSE_BACK, updateKeyboardManager);\n    _addMenuItem(editMenu, _browseForwardAction, KEY_BROWSE_FORWARD, updateKeyboardManager);\n    editMenu.addSeparator();\n    \n    // Go to\n    final JMenu goToMenu = new JMenu(\"Go To\");\n    _addMenuItem(goToMenu, _gotoLineAction, KEY_GOTO_LINE, updateKeyboardManager);\n    _addMenuItem(goToMenu, _gotoFileAction, KEY_GOTO_FILE, updateKeyboardManager);\n    _addMenuItem(goToMenu, _gotoFileUnderCursorAction, KEY_GOTO_FILE_UNDER_CURSOR, updateKeyboardManager);\n    _addMenuItem(goToMenu, _gotoOpeningBraceAction, KEY_OPENING_BRACE, updateKeyboardManager);\n    _addMenuItem(goToMenu, _gotoClosingBraceAction, KEY_CLOSING_BRACE, updateKeyboardManager);\n    editMenu.add(goToMenu);\n    \n    // Panes\n    final JMenu panesMenu = new JMenu(\"Tabbed Panes\");\n    _addMenuItem(panesMenu, _switchToPreviousPaneAction, KEY_PREVIOUS_PANE, updateKeyboardManager);\n    _addMenuItem(panesMenu, _switchToNextPaneAction, KEY_NEXT_PANE, updateKeyboardManager);\n    panesMenu.addSeparator();\n    _addMenuItem(panesMenu, _prevRegionAction, KEY_TABBED_PREV_REGION, updateKeyboardManager);\n    _addMenuItem(panesMenu, _nextRegionAction, KEY_TABBED_NEXT_REGION, updateKeyboardManager);\n    panesMenu.addSeparator();\n    \n    JMenuItem tempDetachTabbedPanesMenuItem = MainFrameStatics.newCheckBoxMenuItem(_detachTabbedPanesAction);\n    tempDetachTabbedPanesMenuItem.setSelected(DrJava.getConfig().getSetting(DETACH_TABBEDPANES));\n    _setMenuShortcut(tempDetachTabbedPanesMenuItem, _detachTabbedPanesAction, KEY_DETACH_TABBEDPANES,\n                     updateKeyboardManager);\n    panesMenu.add(tempDetachTabbedPanesMenuItem);\n    if (_detachTabbedPanesMenuItem==null) {\n      // assign the first time\n      _detachTabbedPanesMenuItem = tempDetachTabbedPanesMenuItem;\n    }\n    else {\n      // otherwise link this item to the first item\n      final WeakReference<JMenuItem> weakRef = new WeakReference<JMenuItem>(tempDetachTabbedPanesMenuItem);\n      _detachTabbedPanesMenuItem.addItemListener(new ItemListener() {\n        public void itemStateChanged(ItemEvent e) {\n          JMenuItem temp = weakRef.get();\n          if (temp!=null) {\n            temp.setSelected(_detachTabbedPanesMenuItem.isSelected());\n          }\n          else {\n            // weak reference cleared, remove this listener\n            _detachTabbedPanesMenuItem.removeItemListener(this);\n          }\n        }\n      });\n    }\n   \n    editMenu.add(panesMenu);\n    \n    // access to configurations GUI\n    editMenu.addSeparator();\n    _addMenuItem(editMenu, _editPreferencesAction, KEY_PREFERENCES, updateKeyboardManager);\n    \n    // Add the menus to the menu bar\n    return editMenu;\n  }\n  \n  /** Creates and returns a tools menu.\n    * @param mask the keystroke modifier to be used\n    * @param updateKeyboardManager true if the keyboard manager should be updated; pass true only for MainFrame!\n    */\n  private JMenu _setUpToolsMenu(int mask, boolean updateKeyboardManager) {\n    final JMenu toolsMenu = new JMenu(\"Tools\");\n    PlatformFactory.ONLY.setMnemonic(toolsMenu,KeyEvent.VK_T);\n    \n    // Compile, Test, Javadoc\n    _addMenuItem(toolsMenu, _compileAllAction, KEY_COMPILE_ALL, updateKeyboardManager);\n    _addMenuItem(toolsMenu, _compileAction, KEY_COMPILE, updateKeyboardManager);\n    _addMenuItem(toolsMenu, _junitAllAction, KEY_TEST_ALL, updateKeyboardManager);\n    _addMenuItem(toolsMenu, _junitAction, KEY_TEST, updateKeyboardManager);\n    toolsMenu.addSeparator();\n    \n    // Run\n    final int runActionIndex = toolsMenu.getItemCount();\n    _addMenuItem(toolsMenu, _runAction, KEY_RUN, updateKeyboardManager);\n    _addMenuItem(toolsMenu, _runAppletAction, KEY_RUN_APPLET, updateKeyboardManager);\n    _addMenuItem(toolsMenu, _resetInteractionsAction, KEY_RESET_INTERACTIONS, updateKeyboardManager);\n    toolsMenu.addSeparator();\n    \n    // Javadoc\n    final JMenu javadocMenu = new JMenu(\"Javadoc\");\n    _addMenuItem(javadocMenu, _javadocAllAction, KEY_JAVADOC_ALL, updateKeyboardManager);\n    _addMenuItem(javadocMenu, _javadocCurrentAction, KEY_JAVADOC_CURRENT, updateKeyboardManager);\n    javadocMenu.addSeparator();\n    _addMenuItem(javadocMenu, _openJavadocAction, KEY_OPEN_JAVADOC, updateKeyboardManager);\n    _addMenuItem(javadocMenu, _openJavadocUnderCursorAction, KEY_OPEN_JAVADOC_UNDER_CURSOR, updateKeyboardManager);    \n    toolsMenu.add(javadocMenu);\n    \n    final JMenu historyMenu = new JMenu(\"History\");\n    _addMenuItem(historyMenu, _executeHistoryAction, KEY_EXECUTE_HISTORY, updateKeyboardManager);\n    _addMenuItem(historyMenu, _loadHistoryScriptAction, KEY_LOAD_HISTORY_SCRIPT, updateKeyboardManager);\n    _addMenuItem(historyMenu, _saveHistoryAction, KEY_SAVE_HISTORY, updateKeyboardManager);\n    _addMenuItem(historyMenu, _clearHistoryAction, KEY_CLEAR_HISTORY, updateKeyboardManager);\n    toolsMenu.add(historyMenu);\n    \n    // Interactions, console\n    final JMenu interMenu = new JMenu(\"Interactions & Console\");    \n    _addMenuItem(interMenu, _saveInteractionsCopyAction, KEY_SAVE_INTERACTIONS_COPY, updateKeyboardManager);\n    _addMenuItem(interMenu, _viewInteractionsClassPathAction, KEY_VIEW_INTERACTIONS_CLASSPATH, updateKeyboardManager);\n    _addMenuItem(interMenu, _copyInteractionToDefinitionsAction, KEY_LIFT_CURRENT_INTERACTION, updateKeyboardManager);\n    _addMenuItem(interMenu, _printInteractionsAction, KEY_PRINT_INTERACTIONS, updateKeyboardManager);\n    interMenu.addSeparator();\n    _addMenuItem(interMenu, _clearConsoleAction, KEY_CLEAR_CONSOLE, updateKeyboardManager);\n    _addMenuItem(interMenu, _saveConsoleCopyAction, KEY_SAVE_CONSOLE_COPY, updateKeyboardManager);\n    _addMenuItem(interMenu, _printConsoleAction, KEY_PRINT_CONSOLE, updateKeyboardManager);\n    _addMenuItem(interMenu, _closeSystemInAction, KEY_CLOSE_SYSTEM_IN, updateKeyboardManager);\n    if (DrJava.getConfig().getSetting(SHOW_DEBUG_CONSOLE).booleanValue()) {\n      toolsMenu.add(_showDebugConsoleAction);\n    }\n    toolsMenu.add(interMenu);\n    \n    final JMenu extMenu = new JMenu(\"External Processes\");\n    _addMenuItem(extMenu, _executeExternalProcessAction, KEY_EXEC_PROCESS, updateKeyboardManager);\n    final JMenuItem execItem = extMenu.getItem(0);\n    extMenu.addSeparator();\n    extMenu.add(_editExternalProcessesAction);\n    toolsMenu.add(extMenu);\n    \n    final int savedCount = DrJava.getConfig().getSetting(OptionConstants.EXTERNAL_SAVED_COUNT);\n    final int namesCount = DrJava.getConfig().getSetting(OptionConstants.EXTERNAL_SAVED_NAMES).size();\n    final int cmdlinesCount = DrJava.getConfig().getSetting(OptionConstants.EXTERNAL_SAVED_CMDLINES).size();\n    final int workdirsCount = DrJava.getConfig().getSetting(OptionConstants.EXTERNAL_SAVED_WORKDIRS).size();\n    final int enclosingFileCount = \n      DrJava.getConfig().getSetting(OptionConstants.EXTERNAL_SAVED_ENCLOSING_DJAPP_FILES).size();\n    if ((savedCount!=namesCount) ||\n        (savedCount!=cmdlinesCount) ||\n        (savedCount!=workdirsCount) ||\n        (savedCount!=enclosingFileCount)) {\n      DrJava.getConfig().setSetting(OptionConstants.EXTERNAL_SAVED_COUNT, 0);\n      DrJava.getConfig().setSetting(OptionConstants.EXTERNAL_SAVED_NAMES, new Vector<String>());\n      DrJava.getConfig().setSetting(OptionConstants.EXTERNAL_SAVED_CMDLINES, new Vector<String>());\n      DrJava.getConfig().setSetting(OptionConstants.EXTERNAL_SAVED_WORKDIRS, new Vector<String>());\n      DrJava.getConfig().setSetting(OptionConstants.EXTERNAL_SAVED_ENCLOSING_DJAPP_FILES, new Vector<String>());\n    }\n    \n    OptionListener<Integer> externalSavedCountListener =\n      new OptionListener<Integer>() {\n      public void optionChanged(final OptionEvent<Integer> oce) {\n        extMenu.removeAll();\n        extMenu.add(execItem);\n        extMenu.addSeparator();\n        for (int count=0; count<oce.value; ++count) {\n          final int i = count;\n          final Vector<String> names = DrJava.getConfig().getSetting(OptionConstants.EXTERNAL_SAVED_NAMES);\n          final Vector<String> cmdlines = DrJava.getConfig().getSetting(OptionConstants.EXTERNAL_SAVED_CMDLINES);\n          final Vector<String> workdirs = DrJava.getConfig().getSetting(OptionConstants.EXTERNAL_SAVED_WORKDIRS);\n          final Vector<String> enclosingfiles = \n            DrJava.getConfig().getSetting(OptionConstants.EXTERNAL_SAVED_ENCLOSING_DJAPP_FILES);\n          \n          extMenu.insert(new AbstractAction(names.get(i)) {\n            public void actionPerformed(ActionEvent ae) {\n              try {\n                PropertyMaps pm = PropertyMaps.TEMPLATE.clone();\n                String s = enclosingfiles.get(i).trim();\n                ((MutableFileProperty) pm.getProperty(\"enclosing.djapp.file\")).\n                  setFile(s.length() > 0 ? new File(s) : null);\n                _executeExternalDialog.\n                  runCommand(names.get(i),cmdlines.get(i),workdirs.get(i),enclosingfiles.get(i),pm);\n              }\n              catch(CloneNotSupportedException e) { throw new edu.rice.cs.util.UnexpectedException(e); }\n            }\n          },i+2);\n        }\n        if (oce.value > 0) { extMenu.addSeparator(); }\n        extMenu.add(_editExternalProcessesAction);\n        _editExternalProcessesAction.setEnabled(true); // always keep enabled, because it allows import\n      }\n    };\n    DrJava.getConfig().addOptionListener(OptionConstants.EXTERNAL_SAVED_COUNT, externalSavedCountListener);\n    externalSavedCountListener.\n      optionChanged(new OptionEvent<Integer>(OptionConstants.EXTERNAL_SAVED_COUNT,\n                                             DrJava.getConfig().getSetting(OptionConstants.EXTERNAL_SAVED_COUNT)));\n    final JMenu advancedMenu = new JMenu(\"Advanced\");\n    _addMenuItem(advancedMenu, _generateCustomDrJavaJarAction, KEY_GENERATE_CUSTOM_DRJAVA, updateKeyboardManager);\n    _addMenuItem(advancedMenu, _newDrJavaInstanceAction, KEY_NEW_DRJAVA_INSTANCE, updateKeyboardManager);\n    toolsMenu.add(advancedMenu);\n\n    toolsMenu.addSeparator();    \n    \n    _addMenuItem(toolsMenu, _bookmarksPanelAction, KEY_BOOKMARKS_PANEL, updateKeyboardManager);\n    _addMenuItem(toolsMenu, _toggleBookmarkAction, KEY_BOOKMARKS_TOGGLE, updateKeyboardManager);\n    \n    toolsMenu.addSeparator();\n    _addMenuItem(toolsMenu, _followFileAction, KEY_FOLLOW_FILE, updateKeyboardManager);\n    \n    // Add the listener that changes the \"Run Main\" menu item\n    OptionListener<Boolean> runMainListener = new OptionListener<Boolean>() {\n      public void optionChanged(final OptionEvent<Boolean> oce) {\n        JMenuItem mi = toolsMenu.getItem(runActionIndex);\n\n        // change\n        if (oce.value) {\n          mi.setText(\"Run Document\");\n          mi.setToolTipText(\"Run the current document, regardless of whether it is an applet, an ACM \" +\n                            \"Java Task Force program, or a regular Java program with a main method.\"); \n        }\n        else {\n          mi.setText(\"Run Document's Main Method\");\n          mi.setToolTipText(\"Run the main method of the current document\"); \n        }\n      }\n    };\n    DrJava.getConfig().addOptionListener(OptionConstants.SMART_RUN_FOR_APPLETS_AND_PROGRAMS, runMainListener);\n    runMainListener.optionChanged(new OptionEvent<Boolean>\n                                  (OptionConstants.SMART_RUN_FOR_APPLETS_AND_PROGRAMS,\n                                   DrJava.getConfig().getSetting(OptionConstants.SMART_RUN_FOR_APPLETS_AND_PROGRAMS)));\n      \n    // Add the menus to the menu bar\n    return toolsMenu;\n  }\n  \n  /** Creates and returns a project menu\n    * @param mask the keystroke modifier to be used\n    * @param updateKeyboardManager true if the keyboard manager should be updated; pass true only for MainFrame!\n    */\n  private JMenu _setUpProjectMenu(int mask, boolean updateKeyboardManager) {\n    JMenu projectMenu = new JMenu(\"Project\");\n    PlatformFactory.ONLY.setMnemonic(projectMenu,KeyEvent.VK_P);\n    // New, open\n    _addMenuItem(projectMenu, _newProjectAction, KEY_NEW_PROJECT, updateKeyboardManager);\n    _addMenuItem(projectMenu, _openProjectAction, KEY_OPEN_PROJECT, updateKeyboardManager);\n    \n    //Save\n    _addMenuItem(projectMenu, _saveProjectAction, KEY_SAVE_PROJECT, updateKeyboardManager);\n    //SaveAs\n    _addMenuItem(projectMenu, _saveProjectAsAction, KEY_SAVE_AS_PROJECT, updateKeyboardManager);\n    \n    // Close\n    _addMenuItem(projectMenu, _closeProjectAction, KEY_CLOSE_PROJECT, updateKeyboardManager);\n    \n    projectMenu.addSeparator();\n    // run project\n    _addMenuItem(projectMenu, _compileProjectAction, KEY_COMPILE_PROJECT, updateKeyboardManager);\n    _addMenuItem(projectMenu, _junitProjectAction, KEY_JUNIT_PROJECT, updateKeyboardManager);\n    _addMenuItem(projectMenu, _runProjectAction, KEY_RUN_PROJECT, updateKeyboardManager);\n    _addMenuItem(projectMenu, _cleanAction, KEY_CLEAN_PROJECT, updateKeyboardManager);\n    _addMenuItem(projectMenu, _autoRefreshAction, KEY_AUTO_REFRESH_PROJECT, updateKeyboardManager);\n    _addMenuItem(projectMenu, _jarProjectAction, KEY_JAR_PROJECT, updateKeyboardManager);\n    \n    projectMenu.addSeparator();\n    // eventually add project options\n    _addMenuItem(projectMenu, _projectPropertiesAction, KEY_PROJECT_PROPERTIES, updateKeyboardManager);\n    \n    return projectMenu;\n  }\n  \n  /** Creates and returns a debug menu.\n    * @param mask the keystroke modifier to be used\n    * @param updateKeyboardManager true if the keyboard manager should be updated; pass true only for MainFrame!\n    */\n  private JMenu _setUpDebugMenu(int mask, boolean updateKeyboardManager) {\n    JMenu debugMenu = new JMenu(\"Debugger\");\n    PlatformFactory.ONLY.setMnemonic(debugMenu,KeyEvent.VK_D);\n    // Enable debugging item\n    JMenuItem tempDebuggerEnabledMenuItem = MainFrameStatics.newCheckBoxMenuItem(_toggleDebuggerAction);\n    tempDebuggerEnabledMenuItem.setSelected(false);\n    _setMenuShortcut(tempDebuggerEnabledMenuItem, _toggleDebuggerAction, KEY_DEBUG_MODE_TOGGLE, updateKeyboardManager);\n    debugMenu.add(tempDebuggerEnabledMenuItem);\n    if (_debuggerEnabledMenuItem==null) {\n      // assign the first time\n      _debuggerEnabledMenuItem = tempDebuggerEnabledMenuItem;\n    }\n    else {\n      // otherwise link this item to the first item\n      final WeakReference<JMenuItem> weakRef = new WeakReference<JMenuItem>(tempDebuggerEnabledMenuItem);\n      _debuggerEnabledMenuItem.addItemListener(new ItemListener() {\n        public void itemStateChanged(ItemEvent e) {\n          JMenuItem temp = weakRef.get();\n          if (temp!=null) {\n            temp.setSelected(_debuggerEnabledMenuItem.isSelected());\n          }\n          else {\n            // weak reference cleared, remove this listener\n            _debuggerEnabledMenuItem.removeItemListener(this);\n          }\n        }\n      });\n    }\n    \n    debugMenu.addSeparator();\n    \n    _addMenuItem(debugMenu, _toggleBreakpointAction, KEY_DEBUG_BREAKPOINT_TOGGLE, updateKeyboardManager);\n    //_printBreakpointsMenuItem = debugMenu.add(_printBreakpointsAction);\n    //_clearAllBreakpointsMenuItem =\n    _addMenuItem(debugMenu, _clearAllBreakpointsAction, KEY_DEBUG_CLEAR_ALL_BREAKPOINTS, updateKeyboardManager);\n    _addMenuItem(debugMenu, _breakpointsPanelAction, KEY_DEBUG_BREAKPOINT_PANEL, updateKeyboardManager);\n    debugMenu.addSeparator();\n    \n    //_addMenuItem(debugMenu, _suspendDebugAction, KEY_DEBUG_SUSPEND, updateKeyboardManager);\n    _addMenuItem(debugMenu, _resumeDebugAction, KEY_DEBUG_RESUME, updateKeyboardManager);\n    _addMenuItem(debugMenu, _stepIntoDebugAction, KEY_DEBUG_STEP_INTO, updateKeyboardManager);\n    _addMenuItem(debugMenu, _stepOverDebugAction, KEY_DEBUG_STEP_OVER, updateKeyboardManager);\n    _addMenuItem(debugMenu, _stepOutDebugAction, KEY_DEBUG_STEP_OUT, updateKeyboardManager);\n    \n    JMenuItem tempAutomaticTraceMenuItem = MainFrameStatics.newCheckBoxMenuItem(_automaticTraceDebugAction);\n    _setMenuShortcut(tempAutomaticTraceMenuItem, _automaticTraceDebugAction, KEY_DEBUG_AUTOMATIC_TRACE,\n                     updateKeyboardManager);\n    debugMenu.add(tempAutomaticTraceMenuItem);\n    if (_automaticTraceMenuItem==null) {\n      // assign the first time\n      _automaticTraceMenuItem = tempAutomaticTraceMenuItem;\n    }\n    else {\n      // otherwise link this item to the first item\n      final WeakReference<JMenuItem> weakRef = new WeakReference<JMenuItem>(tempAutomaticTraceMenuItem);\n      _automaticTraceMenuItem.addItemListener(new ItemListener() {\n        public void itemStateChanged(ItemEvent e) {\n          JMenuItem temp = weakRef.get();\n          if (temp!=null) {\n            temp.setSelected(_automaticTraceMenuItem.isSelected());\n          }\n          else {\n            // weak reference cleared, remove this listener\n            _automaticTraceMenuItem.removeItemListener(this);\n          }\n        }\n      });\n    }\n    \n    debugMenu.addSeparator();\n    JMenuItem tempDetachDebugFrameMenuItem = MainFrameStatics.newCheckBoxMenuItem(_detachDebugFrameAction);\n    tempDetachDebugFrameMenuItem.setSelected(DrJava.getConfig().getSetting(DETACH_DEBUGGER));\n    _setMenuShortcut(tempDetachDebugFrameMenuItem, _detachDebugFrameAction, KEY_DETACH_DEBUGGER, updateKeyboardManager);\n    debugMenu.add(tempDetachDebugFrameMenuItem);\n    if (_detachDebugFrameMenuItem==null) {\n      // assign the first time\n      _detachDebugFrameMenuItem = tempDetachDebugFrameMenuItem;\n    }\n    else {\n      // otherwise link this item to the first item\n      final WeakReference<JMenuItem> weakRef = new WeakReference<JMenuItem>(tempDetachDebugFrameMenuItem);\n      _detachDebugFrameMenuItem.addItemListener(new ItemListener() {\n        public void itemStateChanged(ItemEvent e) {\n          JMenuItem temp = weakRef.get();\n          if (temp!=null) {\n            temp.setSelected(_detachDebugFrameMenuItem.isSelected());\n          }\n          else {\n            // weak reference cleared, remove this listener\n            _detachDebugFrameMenuItem.removeItemListener(this);\n          }\n        }\n      });\n    }\n    \n    // Start off disabled\n    _setDebugMenuItemsEnabled(false);\n    \n    // Add the menu to the menu bar\n    return debugMenu;\n  }\n  \n  /** Called every time the debug mode checkbox is toggled. The resume and step\n    * functions should always be disabled.\n    */\n  private void _setDebugMenuItemsEnabled(boolean isEnabled) {\n    _debuggerEnabledMenuItem.setSelected(isEnabled);\n    _guiAvailabilityNotifier.ensureUnavailable(GUIAvailabilityListener.ComponentType.DEBUGGER_SUSPENDED);\n    if (_showDebugger) { _debugPanel.setAutomaticTraceButtonText(); }\n  }\n  \n  /** Enables and disables the appropriate menu items in the debug menu depending upon the state of the current thread.\n    * @param isSuspended is true when the current thread has just been suspended\n    *        false if the current thread has just been resumed\n    */\n  private void _setThreadDependentDebugMenuItems(boolean isSuspended) {\n    _guiAvailabilityNotifier.ensureAvailabilityIs(GUIAvailabilityListener.ComponentType.DEBUGGER_SUSPENDED,\n                                                  isSuspended);\n    _debugPanel.setAutomaticTraceButtonText();\n  }\n  \n  /** Creates and returns a help menu.\n    * @param mask the keystroke modifier to be used\n    * @param updateKeyboardManager true if the keyboard manager should be updated; pass true only for MainFrame!\n    */\n  private JMenu _setUpHelpMenu(int mask, boolean updateKeyboardManager) {\n    JMenu helpMenu = new JMenu(\"Help\");\n    PlatformFactory.ONLY.setMnemonic(helpMenu,KeyEvent.VK_H);\n    _addMenuItem(helpMenu, _helpAction, KEY_HELP, updateKeyboardManager);\n    _addMenuItem(helpMenu, _quickStartAction, KEY_QUICKSTART, updateKeyboardManager);\n    helpMenu.addSeparator();\n    _addMenuItem(helpMenu, _aboutAction, KEY_ABOUT, updateKeyboardManager);\n    _addMenuItem(helpMenu, _drjavaSurveyAction, KEY_DRJAVA_SURVEY, updateKeyboardManager);\n    _addMenuItem(helpMenu, _checkNewVersionAction, KEY_CHECK_NEW_VERSION, updateKeyboardManager);\n    _addMenuItem(helpMenu, _errorsAction, KEY_DRJAVA_ERRORS, updateKeyboardManager);\n    helpMenu.addSeparator();\n    _addMenuItem(helpMenu, _forceQuitAction, KEY_FORCE_QUIT, updateKeyboardManager);\n    _addMenuItem(helpMenu, _exportProjectInOldFormatAction, KEY_EXPORT_OLD, updateKeyboardManager);\n    return helpMenu;\n  }\n  \n  /** Creates a toolbar button for undo and redo, which behave differently. */\n  JButton _createManualToolbarButton(Action a) {\n    final JButton ret;\n    Font buttonFont = DrJava.getConfig().getSetting(FONT_TOOLBAR);\n    \n    // Check whether icons should be shown\n    boolean useIcon = DrJava.getConfig().getSetting(TOOLBAR_ICONS_ENABLED).booleanValue();\n    boolean useText = DrJava.getConfig().getSetting(TOOLBAR_TEXT_ENABLED).booleanValue();\n    final Icon icon = (useIcon) ? (Icon) a.getValue(Action.SMALL_ICON) : null;\n    if (icon == null) {\n      ret = new UnfocusableButton((String) a.getValue(Action.DEFAULT));\n    }\n    else {\n      ret = new UnfocusableButton(icon);\n      if (useText) ret.setText((String) a.getValue(Action.DEFAULT));\n    }\n    ret.setEnabled(false);\n    ret.addActionListener(a);\n    ret.setToolTipText( (String) a.getValue(Action.LONG_DESCRIPTION));\n    ret.setFont(buttonFont);\n//    Boolean test = a instanceof DelegatingAction;\n    a.addPropertyChangeListener(new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        if (\"enabled\".equals(evt.getPropertyName())) {\n          Boolean val = (Boolean) evt.getNewValue();\n          ret.setEnabled(val.booleanValue());\n        }\n      }\n    });\n    \n    return ret;\n  }\n  \n  /** Sets up all buttons for the toolbar except for undo and redo, which use _createManualToolbarButton. */\n  public JButton _createToolbarButton(Action a) {\n    boolean useText = DrJava.getConfig().getSetting(TOOLBAR_TEXT_ENABLED).booleanValue();\n    boolean useIcons = DrJava.getConfig().getSetting(TOOLBAR_ICONS_ENABLED).booleanValue();\n    Font buttonFont = DrJava.getConfig().getSetting(FONT_TOOLBAR);\n    \n    final JButton result = new UnfocusableButton(a);\n    result.setText((String) a.getValue(Action.DEFAULT));\n    result.setFont(buttonFont);\n    if (! useIcons) result.setIcon(null);\n    if (! useText && (result.getIcon() != null)) result.setText(\"\");\n    return result;\n  }\n  \n  /** Removes the button b from the toolbar and creates new button in its place.  Only runs in the event thread. */\n  public JButton _updateToolbarButton(JButton b, Action a) {\n    final JButton result = _createToolbarButton(a);\n    \n    int index = _toolBar.getComponentIndex(b);\n    _toolBar.remove(b);\n    _toolBar.add(result, index);\n    \n    _fixToolbarHeights();\n    \n    return result;\n  }\n  \n  /** Sets up the toolbar with several useful buttons.  Most buttons are always enabled, but those that are not are\n    * maintained in fields to allow enabling and disabling.\n    */\n  private void _setUpToolBar() {\n    \n    _toolBar.setFloatable(false);\n    \n//     _toolBar.addSeparator();\n    \n    // New, open, save, close\n    _toolBar.add(_createToolbarButton(_newAction));\n    _toolBar.add(_createToolbarButton(_openFileOrProjectAction));\n    _toolBar.add(_createToolbarButton(_saveAction));\n    _closeButton = _createToolbarButton(_closeAction);\n    _toolBar.add(_closeButton);\n    \n    // Cut, copy, paste\n    _toolBar.addSeparator();\n    _toolBar.add(_createToolbarButton(cutAction));\n    _toolBar.add(_createToolbarButton(copyAction));\n    _toolBar.add(_createToolbarButton(pasteAction));\n    \n    // Undo, redo\n    // Simple workaround, for now, for bug # 520742:\n    // Undo/Redo button text in JDK 1.3\n    // We just manually create the JButtons, and we *don't* set up\n    // PropertyChangeListeners on the action's name.\n    //_toolBar.addSeparator();\n    \n    _toolBar.add(_undoButton);\n    _toolBar.add(_redoButton);\n    \n    // Find\n    _toolBar.addSeparator();\n    _toolBar.add(_createToolbarButton(_findReplaceAction));\n    \n    // Compile, reset, abort\n    _toolBar.addSeparator();\n    _toolBar.add(_compileButton = _createToolbarButton(_compileAllAction));\n    _toolBar.add(_createToolbarButton(_resetInteractionsAction));\n    \n    // Run, Junit, and JavaDoc\n    _toolBar.addSeparator();\n    \n    _toolBar.add(_runButton = _createToolbarButton(_runAction));\n    _toolBar.add(_junitButton = _createToolbarButton(_junitAllAction));\n    _toolBar.add(_createToolbarButton(_javadocAllAction));\n    \n    // DrJava Errors\n    _toolBar.addSeparator();\n    _errorsButton = _createToolbarButton(_errorsAction);\n    _errorsButton.setVisible(false);\n    _errorsButton.setBackground(DrJava.getConfig().getSetting(DRJAVA_ERRORS_BUTTON_COLOR));\n    _toolBar.add(_errorsButton);\n    /** The OptionListener for DRJAVA_ERRORS_BUTTON_COLOR. */\n    OptionListener<Color> errBtnColorOptionListener = new OptionListener<Color>() {\n      public void optionChanged(OptionEvent<Color> oce) {\n        _errorsButton.setBackground(oce.value);\n      }\n    };\n    DrJava.getConfig().addOptionListener(DRJAVA_ERRORS_BUTTON_COLOR, errBtnColorOptionListener);\n    // Add the listener that changes the \"Run\" button\n    OptionListener<Boolean> runButtonListener = new OptionListener<Boolean>() {\n      public void optionChanged(final OptionEvent<Boolean> oce) { \n        if (oce.value) {\n          _runAction.putValue(Action.LONG_DESCRIPTION, \n                              \"Run the current document, regardless of whether it is an applet, an ACM \" +\n                              \"Java Task Force program, or a regular Java program with a main method.\"); \n        }\n        else {\n          _runAction.putValue(Action.LONG_DESCRIPTION,\n                              \"Run the main method of the current document\"); \n        }\n        // _runButton = _updateToolbarButton(_runButton, _runAction);\n        projectRunnableChanged();\n      }\n    };\n    DrJava.getConfig().addOptionListener(OptionConstants.SMART_RUN_FOR_APPLETS_AND_PROGRAMS, runButtonListener);\n    runButtonListener.optionChanged(new OptionEvent<Boolean>\n                                    (OptionConstants.SMART_RUN_FOR_APPLETS_AND_PROGRAMS, DrJava.getConfig().\n                                       getSetting(OptionConstants.SMART_RUN_FOR_APPLETS_AND_PROGRAMS)));\n    \n    // Correct the vertical height of the buttons.\n    _fixToolbarHeights();\n    \n    // Plastic-specific style hints\n    if(Utilities.isPlasticLaf()) {\n      _toolBar.putClientProperty(\"JToolBar.isRollover\", Boolean.FALSE);\n      _toolBar.putClientProperty(com.jgoodies.looks.Options.HEADER_STYLE_KEY,\n                                 com.jgoodies.looks.HeaderStyle.BOTH);\n    }\n    \n    getContentPane().add(_toolBar, BorderLayout.NORTH);\n//    _updateToolBarVisible();  // created a visible GUI component during  initialization!\n  }\n  \n  /** Sets the toolbar as either visible or invisible based on the config option.  Only runs in the event thread. */\n  private void _updateToolBarVisible() {\n    _toolBar.setVisible(DrJava.getConfig().getSetting(TOOLBAR_ENABLED));\n  }  \n  \n  /** Update the toolbar's buttons, following any change to TOOLBAR_ICONS_ENABLED, TOOLBAR_TEXT_ENABLED, or \n    * FONT_TOOLBAR (name, style, text)\n    */\n  private void _updateToolbarButtons() {\n    _updateToolBarVisible();\n    Component[] buttons = _toolBar.getComponents();\n    \n    Font toolbarFont = DrJava.getConfig().getSetting(FONT_TOOLBAR);\n    boolean iconsEnabled = DrJava.getConfig().getSetting(TOOLBAR_ICONS_ENABLED).booleanValue();\n    boolean textEnabled = DrJava.getConfig().getSetting(TOOLBAR_TEXT_ENABLED).booleanValue();\n    \n    for (int i = 0; i < buttons.length; i++) {\n      \n      if (buttons[i] instanceof JButton) {\n        \n        JButton b = (JButton) buttons[i];\n        Action a = b.getAction();\n        \n        // Work-around for strange configuration of undo/redo buttons\n        /*\n         if (a == null) {\n         ActionListener[] al = b.getActionListeners(); // 1.4 only\n         \n         for (int j=0; j<al.length; j++) {\n         if (al[j] instanceof Action) {\n         a = (Action) al[j];\n         break;\n         }\n         }\n         }\n         */\n        \n        b.setFont(toolbarFont);\n        \n        if (a == null) {\n          if (b == _undoButton) a = _undoAction;\n          else if (b == _redoButton) a = _redoAction;\n          else continue;\n        }\n        \n        if (b.getIcon() == null) {\n          if (iconsEnabled) b.setIcon( (Icon) a.getValue(Action.SMALL_ICON));\n        }\n        else if (!iconsEnabled && b.getText().equals(\"\"))  b.setIcon(null);\n        \n        if (b.getText().equals(\"\")) {\n          if (textEnabled) b.setText( (String) a.getValue(Action.DEFAULT));\n        }\n        else if (!textEnabled && b.getIcon() != null) b.setText(\"\");\n        \n      }\n    }\n    \n    // Correct the vertical height of the buttons.\n    _fixToolbarHeights();\n  }\n  \n  /** Ensures that all toolbar buttons have the same height. */\n  private void _fixToolbarHeights() {\n    Component[] buttons = _toolBar.getComponents();\n    \n    // First, find the maximum height of all the buttons.\n    int max = 0;\n    for (int i = 0; i < buttons.length; i++) {\n      // We only care about the JButtons.\n      if (buttons[i] instanceof JButton) {\n        JButton b = (JButton) buttons[i];\n        \n        // reset any preferred size we have set\n        b.setPreferredSize(null);\n        \n        // get the preferred height, since that's what we want to use\n        Dimension d = b.getPreferredSize();\n        int cur = (int) d.getHeight();\n        if (cur > max) {\n          max = cur;\n        }\n      }\n    }\n    \n    // Now set all button heights to the max.\n    for (int i = 0; i < buttons.length; i++) {\n      // We only care about the JButtons.\n      if (buttons[i] instanceof JButton) {\n        JButton b = (JButton) buttons[i];\n        Dimension d = new Dimension((int) b.getPreferredSize().getWidth(), max);\n        \n        // JToolBar inexplicably uses the max size\n        // also set preferred size for consistency\n        b.setPreferredSize(d);\n        b.setMaximumSize(d);\n      }\n    }\n    \n    // _toolbar.revalidate();\n  }\n  \n  /** Sets up the status bar with the filename field. Only called from MainFrame constructor. */\n  private void _setUpStatusBar() {\n    \n    // Initialize the 3 labels:\n    \n    _statusField.setFont(_statusField.getFont().deriveFont(Font.PLAIN));\n    _statusReport.setHorizontalAlignment(SwingConstants.RIGHT);\n    \n    JPanel fileNameAndMessagePanel = new JPanel(new BorderLayout());\n    fileNameAndMessagePanel.add(_statusField, BorderLayout.CENTER);\n    fileNameAndMessagePanel.add(_statusReport, BorderLayout.EAST);\n    \n    _currLocationField.setFont(_currLocationField.getFont().deriveFont(Font.PLAIN));\n    _currLocationField.setHorizontalAlignment(SwingConstants.RIGHT);\n    _currLocationField.setPreferredSize(new Dimension(165,12));\n//    _currLocationField.setVisible(true);\n    \n    // Initialize the status bar panel\n//    SpringLayout layout = new SpringLayout();\n    _statusBar.add( fileNameAndMessagePanel, BorderLayout.CENTER );\n//    _statusBar.add( sbMessagePanel, BorderLayout.CENTER );\n    _statusBar.add( _currLocationField, BorderLayout.EAST );\n    _statusBar.\n      setBorder(new CompoundBorder(new EmptyBorder(2,2,2,2),\n                                   new CompoundBorder(new BevelBorder(BevelBorder.LOWERED), new EmptyBorder(2,2,2,2))));\n    getContentPane().add(_statusBar, BorderLayout.SOUTH);\n    \n//     //Adjust constraints for the fileName label so it's next to the left edge.\n//     layout.getConstraints(_statusField).setX(Spring.constant(0));\n//     \n//     //Adjust constraints for the message label so it's spaced a bit from the right.\n//     //and doesn't interfere with the left-most label\n//     layout.putConstraint(SpringLayout.EAST, _statusReport, -65,\n//     SpringLayout.EAST, _statusBar);\n//     \n//     //Adjust constraints for the location label so it's next to the right edge.\n//     layout.putConstraint(SpringLayout.EAST, _currLocationField, 0,\n//     SpringLayout.EAST, _statusBar);\n//     \n//     //Adjust constraints for the panel to set its size\n//     layout.putConstraint(SpringLayout.SOUTH, _statusBar, 0,\n//     SpringLayout.SOUTH, _currLocationField);\n  }\n  \n  /** Inner class to handle updating the current position in a document.  Registered with the DefinitionsPane. **/\n  private class PositionListener implements CaretListener {\n    \n    /* Cached caret coordinates */\n    private int _offset;\n    private int _line;\n    private int _col;\n    \n    // The following method should always run in the event thread, because we only access and update documents (and \n    // other text fields) from the event thread.  We formerly used the AbstractDocument locking protocol to access and\n    // update documents from other threads.\n    public void caretUpdate(final CaretEvent ce) {\n      \n      assert EventQueue.isDispatchThread();\n      // invokeLater was required when document updating was done outside the event thread.\n//      Utilities.invokeLater(new Runnable() { \n//        public void run() {\n      \n      int offset = ce.getDot();\n      try {\n        if (offset == _offset + 1 && _currentDefDoc.getText(_offset, 1).charAt(0) != '\\n') {\n          _col += 1;\n          _offset += 1;\n        }\n        else {\n          Element root = _currentDefDoc.getDefaultRootElement();\n          int line = root.getElementIndex(offset); \n          _line = line + 1;     // line numbers are 1-based\n          _col = offset - root.getElement(line).getStartOffset();\n        }\n      }\n      catch(BadLocationException e) { /* do nothing; should never happen */ }\n      finally { \n        _offset = offset;\n        updateLocation(_line, _col);\n      }\n//        }\n//      });\n    }\n    \n    // This method appears safe outside the event thread\n    public void updateLocation() {\n//      OpenDefinitionsDocument doc = _model.getActiveDocument();\n      _line = _currentDefDoc.getCurrentLine();\n      _col = _currentDefDoc.getCurrentCol(); \n      updateLocation(_line, _col);\n    }\n    \n    private void updateLocation(int line, int col) { // Can run outside the event thread because setText is thread safe.\n      _currLocationField.setText(line + \":\" + col +\" \\t\");  // Space before \"\\t\" required on Mac to avoid obscuring\n//  Lightweight parsing has been disabled until we have something that is beneficial and works better in the background.\n//      _model.getParsingControl().delay();\n    }\n    \n    public int lastLine() { return _line; }\n    public int lastCol() { return _col; }\n  }\n  \n  /* Only called from MainFrame constructor. */\n  private void _setUpTabs() {\n    \n    // Interactions\n    _interactionsController.setPrevPaneAction(_switchToPreviousPaneAction);\n    _interactionsController.setNextPaneAction(_switchToNextPaneAction);\n    \n    JScrollPane interactionsScroll = \n      new BorderlessScrollPane(_interactionsPane, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,\n                               JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    _interactionsContainer.add(interactionsScroll, BorderLayout.CENTER);\n    \n    if (_showDebugger) {\n      // hook highlighting listener to breakpoint manager\n      _model.getBreakpointManager().addListener(new RegionManagerListener<Breakpoint>() {\n        /* Called when a breakpoint is added. Only runs in event thread. */\n        public void regionAdded(final Breakpoint bp) {\n          DefinitionsPane bpPane = getDefPaneGivenODD(bp.getDocument());\n          _documentBreakpointHighlights.\n            put(bp, bpPane.getHighlightManager().\n                  addHighlight(bp.getStartOffset(), bp.getEndOffset(), \n                               bp.isEnabled() ? DefinitionsPane.BREAKPOINT_PAINTER\n                                 : DefinitionsPane.DISABLED_BREAKPOINT_PAINTER));\n          _updateDebugStatus();\n        }\n        \n        /** Called when a breakpoint is changed. Only runs in event thread. */\n        public void regionChanged(Breakpoint bp) { \n          regionRemoved(bp);\n          regionAdded(bp);\n        }\n        \n        /** Called when a breakpoint is removed. Only runs in event thread. */\n        public void regionRemoved(final Breakpoint bp) {      \n          HighlightManager.HighlightInfo highlight = _documentBreakpointHighlights.get(bp);\n          if (highlight != null) highlight.remove();\n          _documentBreakpointHighlights.remove(bp);\n        }\n      });\n    }\n    \n    // hook highlighting listener to bookmark manager\n    _model.getBookmarkManager().addListener(new RegionManagerListener<MovingDocumentRegion>() { \n      // listener methods only run in the event thread\n      public void regionAdded(MovingDocumentRegion r) {\n        DefinitionsPane bpPane = getDefPaneGivenODD(r.getDocument());\n        _documentBookmarkHighlights.\n          put(r, bpPane.getHighlightManager().\n                addHighlight(r.getStartOffset(), r.getEndOffset(), DefinitionsPane.BOOKMARK_PAINTER));\n      }\n      public void regionChanged(MovingDocumentRegion r) { \n        regionRemoved(r);\n        regionAdded(r);\n      }\n      public void regionRemoved(MovingDocumentRegion r) {\n        HighlightManager.HighlightInfo highlight = _documentBookmarkHighlights.get(r);\n        if (highlight != null) highlight.remove();\n        _documentBookmarkHighlights.remove(r);\n      }\n    });\n    \n    _tabbedPane.addChangeListener(new ChangeListener () {\n      /* Only runs in the event thread. */\n      public void stateChanged(ChangeEvent e) {\n//        System.err.println(\"_tabbedPane.stateChanged called with event \" + e);\n        clearStatusMessage();\n        \n        if (_tabbedPane.getSelectedIndex() == INTERACTIONS_TAB) {\n          // Use EventQueue because this action must execute AFTER all pending events in the event queue\n//        System.err.println(\"Interactions Container Selected\");\n          _interactionsContainer.setVisible(true);  // kluge to overcome subtle focus bug\n          EventQueue.invokeLater(new Runnable() {  \n            public void run() { _interactionsContainer.requestFocusInWindow(); }  \n          });\n        }\n        else if (_tabbedPane.getSelectedIndex() == CONSOLE_TAB) {\n          // Use EventQueue because this action must execute AFTER all pending events in the event queue\n//          System.err.println(\"Console Scroll Selected\");\n          EventQueue.invokeLater(new Runnable() { public void run() { _consoleScroll.requestFocusInWindow(); } });\n        }\n        // Update error highlights?\n        if (_currentDefPane != null) {\n          int pos = _currentDefPane.getCaretPosition();\n          _currentDefPane.removeErrorHighlight(); // removes highlighting whenever the current tabbed pane is switched\n          _currentDefPane.getErrorCaretListener().updateHighlight(pos);\n        }\n      }\n    });\n    \n    _tabbedPane.add(\"Interactions\", _interactionsContainer);\n    _tabbedPane.add(\"Console\", _consoleScroll);\n    \n    _interactionsPane.addKeyListener(_historyListener);\n    _interactionsPane.addFocusListener(_focusListenerForRecentDocs);\n    _interactionsController.addFocusListener(new FocusAdapter() {\n      public void focusGained(FocusEvent e){ \n        _undoAction.setDelegatee(_interactionsController.getUndoAction());\n        _redoAction.setDelegatee(_interactionsController.getRedoAction());  \n      }\n    });\n    \n    _consoleScroll.addKeyListener(_historyListener);\n    _consoleScroll.addFocusListener(_focusListenerForRecentDocs);\n    \n    \n    _tabs.addLast(_compilerErrorPanel);\n    _tabs.addLast(_junitPanel);\n    _tabs.addLast(_javadocErrorPanel);\n    _tabs.addLast(_findReplace);\n    if (_showDebugger) { _tabs.addLast(_breakpointsPanel); }\n    _tabs.addLast(_bookmarksPanel);\n    \n    _interactionsContainer.addFocusListener(new FocusAdapter() {\n      public void focusGained(FocusEvent e) { \n        EventQueue.invokeLater(new Runnable() { \n          public void run() {\n//            System.err.println(\"Requesting focus in interactions pane\");\n            _interactionsPane.requestFocusInWindow(); \n          }\n        });\n      }\n    });\n    \n    _interactionsPane.addFocusListener(new FocusAdapter() {\n      public void focusGained(FocusEvent e) { _lastFocusOwner = _interactionsContainer; }\n    });\n    _consolePane.addFocusListener(new FocusAdapter() {\n      public void focusGained(FocusEvent e) { _lastFocusOwner = _consoleScroll; }\n    });\n    _compilerErrorPanel.getMainPanel().addFocusListener(new FocusAdapter() {\n      public void focusGained(FocusEvent e) { _lastFocusOwner = _compilerErrorPanel; }\n    });\n    _junitPanel.getMainPanel().addFocusListener(new FocusAdapter() {\n      public void focusGained(FocusEvent e) { _lastFocusOwner = _junitPanel; }\n    });\n    _javadocErrorPanel.getMainPanel().addFocusListener(new FocusAdapter() {\n      public void focusGained(FocusEvent e) { _lastFocusOwner = _javadocErrorPanel; }\n    });\n    _findReplace.getFindField().addFocusListener(new FocusAdapter() {\n      public void focusGained(FocusEvent e) { _lastFocusOwner = _findReplace; }\n    });\n    if (_showDebugger) {\n      _breakpointsPanel.getMainPanel().addFocusListener(new FocusAdapter() {\n        public void focusGained(FocusEvent e) { _lastFocusOwner = _breakpointsPanel; }\n      });\n    }\n    _bookmarksPanel.getMainPanel().addFocusListener(new FocusAdapter() { \n      public void focusGained(FocusEvent e) { _lastFocusOwner = _bookmarksPanel; }\n    });\n  }\n  \n  /** Realizes this MainFrame by setting it visibile and configures the tabbed Pane. Only runs in the event thread. */\n  public void start() {\n    \n    // Make the MainFrame visible and show the compiler tab\n    EventQueue.invokeLater(new Runnable() { \n      public void run() { \n        setVisible(true);\n        _compilerErrorPanel.setVisible(true);\n        showTab(_compilerErrorPanel, true); \n        /* The following two step sequence was laboriously developed by trial and error; without it the _tabbedPane\n         * does not display properly. */\n        _tabbedPane.invalidate();\n        _tabbedPane.repaint();\n        \n        try {\n          // Perform the default imports for the interactions pane\n          _model.getInteractionsModel().performDefaultImports();\n        }\n        catch(Throwable t) {\n          DrJavaErrorHandler.record(t);\n        }\n      }\n    });\n  }\n  \n  /** Sets up the context menu to show in the document pane. */\n  private void _setUpContextMenus() {      \n    _model.getDocCollectionWidget().addMouseListener(new RightClickMouseAdapter() {\n      protected void _popupAction(MouseEvent e) {\n        boolean showContextMenu = true;\n        if (!_model.getDocumentNavigator().isSelectedAt(e.getX(), e.getY())) {\n          // click on a item that wasn't selected, change selection\n          showContextMenu = _model.getDocumentNavigator().selectDocumentAt(e.getX(), e.getY());\n        }\n        if (showContextMenu) {\n          boolean rootSelected = _model.getDocumentNavigator().isRootSelected();\n          boolean folderSelected = false;\n          boolean docSelected = false;\n          boolean externalSelected = false;\n          boolean auxiliarySelected = false;\n          boolean externalBinSelected = false;\n          boolean auxiliaryBinSelected = false;\n          \n          final int docSelectedCount = _model.getDocumentNavigator().getDocumentSelectedCount();          \n          final int groupSelectedCount = _model.getDocumentNavigator().getGroupSelectedCount();\n          try {\n            java.util.Set<String> groupNames = _model.getDocumentNavigator().getNamesOfSelectedTopLevelGroup();\n            \n            if (docSelectedCount > 0) {\n              // when documents are selected, ignore all other options and only deal with documents\n              rootSelected = false;\n              if (groupNames.contains(_model.getSourceBinTitle())) {\n                // a document in the \"[ Source Files ]\" bin is selected\n                docSelected = true;\n              }\n              if (groupNames.contains(_model.getExternalBinTitle())) {\n                // a document in the \"[ External Files ]\" bin is selected\n                externalSelected = true;\n              }\n              if (groupNames.contains(_model.getAuxiliaryBinTitle())) {\n                // a document in the \"[ Included External Files ]\" bin is selected\n                auxiliarySelected = true;\n              }\n            }\n            else {\n              // no document selected, check other options\n              if (groupSelectedCount > 0) {\n                // at least one folder is selected\n                if (!_model.getDocumentNavigator().isTopLevelGroupSelected()) {\n                  // it is really a folder and not a top level bin, e.g. \"[ Source Files ]\"\n                  folderSelected = true;\n                }\n                else {\n                  // it is a top level bin, e.g. \"[ Source Files ]\"\n                  if (groupNames.contains(_model.getSourceBinTitle())) {\n                    // the \"[ Source Files ]\" bin is selected, treat as normal folder\n                    folderSelected = true;\n                  }\n                  if (groupNames.contains(_model.getExternalBinTitle())) {\n                    // the \"[ External Files ]\" bin is selected\n                    externalBinSelected = true;\n                  }\n                  if (groupNames.contains(_model.getAuxiliaryBinTitle())) {\n                    // the \"[ Included External Files ]\" bin is selected\n                    auxiliaryBinSelected = true;\n                  }\n                }\n              }\n            }\n          }\n          catch(GroupNotSelectedException ex) {\n            // we're looking at the root of the tree, or we're in list view...\n            if (_model.isProjectActive()) {\n              // project view, so the root has been selected\n              rootSelected = true;\n            }\n            else {\n              // list view, so treat it as simple documents\n              docSelected = true;\n              rootSelected = false;\n              folderSelected = false;\n              externalSelected = false;\n              auxiliarySelected = false;\n              externalBinSelected = false;\n              auxiliaryBinSelected = false;\n            }\n          }\n          \n          if (!rootSelected && !folderSelected && !docSelected && !externalSelected &&\n              !auxiliarySelected && !externalBinSelected && !auxiliaryBinSelected) {\n            // nothing selected, don't display anything\n            return;\n          }\n          \n          final JPopupMenu m = new JPopupMenu();\n          if (docSelectedCount == 0) { docSelected = externalSelected = auxiliarySelected = false; }\n          if (groupSelectedCount == 0) { folderSelected = false; }\n          \n          if (rootSelected) {\n            // root selected\n            m.add(Utilities.createDelegateAction(\"Save Project\", _saveProjectAction));\n            m.add(Utilities.createDelegateAction(\"Close Project\", _closeProjectAction));\n            m.add(_compileProjectAction);\n            m.add(_runProjectAction);\n            m.add(_junitProjectAction);\n            m.add(_projectPropertiesAction);\n          }\n          if (folderSelected) {\n            // folder selected\n            if (m.getComponentCount() > 0) { m.addSeparator(); }\n            if (groupSelectedCount==1) {\n              // \"New File in Folder\" and \"Open File in Folder\" only work if exactly\n              // one folder is selected\n              m.add(_newFileFolderAction);\n              m.add(_openOneFolderAction);\n              \n              // get singular/plural right\n              m.add(Utilities.createDelegateAction(\"Open All Files in Folder\", _openAllFolderAction));\n              m.add(_closeFolderAction);\n              m.add(_compileFolderAction);\n              m.add(_junitFolderAction);\n            }\n            else if (groupSelectedCount>1) {\n              if (!externalBinSelected && !auxiliaryBinSelected) {\n                // open only makes sense if it's real folders, and not\n                // the external or auxiliary bins\n                m.add(Utilities.createDelegateAction(\"Open All Files in All Folders (\" + groupSelectedCount + \")\",\n                                                     _openAllFolderAction));\n              }\n              m.add(Utilities.\n                      createDelegateAction(\"Close All Folders (\"+groupSelectedCount+\")\", _closeFolderAction));\n              m.add(Utilities.\n                      createDelegateAction(\"Compile All Folders (\"+groupSelectedCount+\")\", _compileFolderAction));\n              m.add(Utilities.\n                      createDelegateAction(\"Test All Folders (\"+groupSelectedCount+\")\", _junitFolderAction));\n              \n            }\n          }\n          if (docSelected || externalSelected || auxiliarySelected) {\n            // some kind of document selected\n            if (m.getComponentCount() > 0) { m.addSeparator(); }\n            if (docSelectedCount==1) {\n              m.add(Utilities.createDelegateAction(\"Save File\", _saveAction));\n              m.add(Utilities.createDelegateAction(\"Save File As...\", _saveAsAction));\n              m.add(Utilities.createDelegateAction(\"Save File Copy...\", _saveCopyAction));\n              m.add(Utilities.createDelegateAction(\"Rename File\", _renameAction));\n              m.add(Utilities.createDelegateAction(\"Revert File to Saved\", _revertAction));\n              m.add(Utilities.createDelegateAction(\"Close File\", _closeAction));\n              m.add(Utilities.createDelegateAction(\"Print File...\", _printDefDocAction));\n              m.add(Utilities.createDelegateAction(\"Print File Preview...\", _printDefDocPreviewAction));\n              m.add(Utilities.createDelegateAction(\"Compile File\", _compileAction));\n              m.add(Utilities.createDelegateAction(\"Test File\", _junitAction));\n              m.add(Utilities.createDelegateAction(\"Preview Javadoc for File\", _javadocCurrentAction));\n              m.add(Utilities.createDelegateAction(\"Run File\", _runAction));\n              m.add(Utilities.createDelegateAction(\"Run File as Applet\", _runAppletAction));\n            }\n            else if (docSelectedCount>1) {\n              m.add(Utilities.createDelegateAction(\"Save All Files (\"+docSelectedCount+\")\", _saveAction));\n              m.add(Utilities.createDelegateAction(\"Revert All Files to Saved (\"+docSelectedCount+\")\", _revertAction));\n              m.add(Utilities.createDelegateAction(\"Close All Files  (\"+docSelectedCount+\")\", _closeAction));\n              m.add(Utilities.createDelegateAction(\"Compile All Files (\"+docSelectedCount+\")\", _compileAction));\n              m.add(Utilities.createDelegateAction(\"Test All Files (\"+docSelectedCount+\")\", _junitAction));\n            }\n          }\n          if (externalSelected && !docSelected && !auxiliarySelected) {\n            // external document selected, but no regular or auxiliary documents\n            if (m.getComponentCount() > 0) { m.addSeparator(); }\n            if (docSelectedCount==1) {\n              m.add(Utilities.createDelegateAction(\"Include File With Project\",\n                                                   _moveToAuxiliaryAction));\n            }\n            else if (docSelectedCount>1) {\n              m.add(Utilities.createDelegateAction(\"Include All Files With Project (\"+docSelectedCount+\")\",\n                                                   _moveToAuxiliaryAction));\n            }\n          }\n          if (auxiliarySelected && !docSelected && !externalSelected) {\n            // auxiliary document selected, but no regular or external documents\n            if (m.getComponentCount() > 0) { m.addSeparator(); }\n            if (docSelectedCount==1) {\n              m.add(Utilities.createDelegateAction(\"Do Not Include File With Project\",\n                                                   _removeAuxiliaryAction));\n            }\n            else if (docSelectedCount>1) {\n              m.add(Utilities.createDelegateAction(\"Do Not Include Any Files With Project (\"+docSelectedCount+\")\",\n                                                   _removeAuxiliaryAction));\n            }\n          }\n          if (!folderSelected && (externalBinSelected || auxiliaryBinSelected)) {\n            // external or auxiliary bin selected, but no regular folder\n            if (m.getComponentCount() > 0) { m.addSeparator(); }\n            m.add(Utilities.createDelegateAction(\"Close All Files\", _closeFolderAction));\n            m.add(Utilities.createDelegateAction(\"Compile All Files\", _compileFolderAction));\n            m.add(Utilities.createDelegateAction(\"Test All Files\", _junitFolderAction));\n          }\n          if (externalBinSelected && !auxiliaryBinSelected) {\n            // external bin selected\n            m.add(Utilities.createDelegateAction(\"Include All Files With Project\",\n                                                 _moveAllToAuxiliaryAction));\n          }\n          if (auxiliaryBinSelected && !externalBinSelected) {\n            // auxiliary bin selected\n            m.add(Utilities.createDelegateAction(\"Do Not Include Any Files With Project\",\n                                                 _removeAllAuxiliaryAction));\n          }\n          \n          m.show(e.getComponent(), e.getX(), e.getY());\n        }\n      }\n    });\n//    _model.getDocCollectionWidget().addMouseListener(new RightClickMouseAdapter() {\n//      protected void _popupAction(MouseEvent e) {\n//        if (_model.getDocumentNavigator().selectDocumentAt(e.getX(), e.getY())) {\n//          if (_model.getDocumentNavigator().isGroupSelected())\n//            _navPaneFolderPopupMenu.show(e.getComponent(), e.getX(), e.getY());\n//          \n//          else {\n//            try {\n//              String groupName = _model.getDocumentNavigator().getNameOfSelectedTopLevelGroup();\n//              if (groupName.equals(_model.getSourceBinTitle()))\n//                _navPanePopupMenu.show(e.getComponent(), e.getX(), e.getY());\n//              else if (groupName.equals(_model.getExternalBinTitle())) {\n//                INavigatorItem n = _model.getDocumentNavigator().getCurrent();\n//                if (n != null) {\n//                  OpenDefinitionsDocument d = (OpenDefinitionsDocument) n;\n//                  if (d.isUntitled()) { _navPanePopupMenu.show(e.getComponent(), e.getX(), e.getY()); }\n//                  else _navPanePopupMenuForExternal.show(e.getComponent(), e.getX(), e.getY());\n//                }\n//              }\n//              else if (groupName.equals(_model.getAuxiliaryBinTitle()))\n//                _navPanePopupMenuForAuxiliary.show(e.getComponent(), e.getX(), e.getY());\n//            }\n//            catch(GroupNotSelectedException ex) {\n//              // we're looking at the root of the tree, or we're in list view...\n//              if (_model.isProjectActive())\n//                _navPanePopupMenuForRoot.show(e.getComponent(), e.getX(), e.getY());\n//              else  _navPanePopupMenu.show(e.getComponent(), e.getX(), e.getY());\n//            }\n//          }\n//        }\n//      }\n//    });\n    \n    // Interactions pane menu\n    _interactionsPanePopupMenu = new JPopupMenu();\n    _interactionsPanePopupMenu.add(cutAction);\n    _interactionsPanePopupMenu.add(copyAction);\n    _interactionsPanePopupMenu.add(pasteAction);\n    _interactionsPanePopupMenu.addSeparator();\n    _interactionsPanePopupMenu.add(_printInteractionsAction);\n    _interactionsPanePopupMenu.add(_printInteractionsPreviewAction);\n    _interactionsPanePopupMenu.addSeparator();\n    _interactionsPanePopupMenu.add(_saveInteractionsCopyAction);\n    _interactionsPanePopupMenu.addSeparator();\n    _interactionsPanePopupMenu.add(_executeHistoryAction);\n    _interactionsPanePopupMenu.add(_loadHistoryScriptAction);\n    _interactionsPanePopupMenu.add(_saveHistoryAction);\n    _interactionsPanePopupMenu.add(_clearHistoryAction);\n    _interactionsPanePopupMenu.addSeparator();\n    _interactionsPanePopupMenu.add(_resetInteractionsAction);\n    _interactionsPanePopupMenu.add(_viewInteractionsClassPathAction);\n    _interactionsPanePopupMenu.add(_copyInteractionToDefinitionsAction);\n    _interactionsPane.addMouseListener(new RightClickMouseAdapter() {\n      protected void _popupAction(MouseEvent e) {\n        _interactionsPane.requestFocusInWindow();\n        _interactionsPane.endCompoundEdit();\n        _interactionsPanePopupMenu.show(e.getComponent(), e.getX(), e.getY());\n      }\n    });\n    \n//    // This listener updates the _cachedCaretPosition in the _interactionsController when the cursor is manually set.\n//    _interactionsPane.addMouseListener(new MouseInputAdapter() {\n//      public void mouseClicked(MouseEvent e) { \n//        _interactionsController.setCachedCaretPos(_interactionsPane.viewToModel(e.getPoint()));\n//      }\n//    });\n    _consolePanePopupMenu = new JPopupMenu();\n    _consolePanePopupMenu.add(_clearConsoleAction);\n    _consolePanePopupMenu.add(_saveConsoleCopyAction);\n    _consolePanePopupMenu.addSeparator();\n    _consolePanePopupMenu.add(_printConsoleAction);\n    _consolePanePopupMenu.add(_printConsolePreviewAction);\n    _consolePane.addMouseListener(new RightClickMouseAdapter() {\n      protected void _popupAction(MouseEvent e) {\n        _consolePane.requestFocusInWindow();\n        _consolePanePopupMenu.show(e.getComponent(), e.getX(), e.getY());\n      }\n    });\n  }\n  \n  private void nextRecentDoc() {\n//    Utilities.show(\"BACK_QUOTE typed\");\n    if (_recentDocFrame.isVisible()) _recentDocFrame.next();\n    else _recentDocFrame.setVisible(true);\n  }\n  \n  private void prevRecentDoc() {\n//    Utilities.show(\"BACK_QUOTE typed\");\n    if (_recentDocFrame.isVisible()) _recentDocFrame.prev();\n    else _recentDocFrame.setVisible(true);\n  }\n  \n  private void hideRecentDocFrame() {\n    if (_recentDocFrame.isVisible()) {\n      _recentDocFrame.setVisible(false);\n      OpenDefinitionsDocument doc = _recentDocFrame.getDocument();\n      if (doc != null) {\n        addToBrowserHistory();\n        _model.setActiveDocument(doc);\n//        addToBrowserHistory();\n      }\n    }\n  }\n  \n  private volatile Object _updateLock = new Object();\n  private volatile boolean _tabUpdatePending = false;\n  private volatile boolean _waitAgain = false;\n  private volatile Runnable _pendingUpdate = null;\n  private volatile OpenDefinitionsDocument _pendingDocument = null;\n  private volatile OrderedDocumentRegion _firstRegion = null;\n  private volatile OrderedDocumentRegion _lastRegion = null;\n  \n  public static long UPDATE_DELAY = 500L;  // update delay threshold in milliseconds\n  public static int UPDATER_PRIORITY = 2;   // priority in [1..10] of the updater thread.\n  \n//  /** Updates the tabbed panel in a granular fashion to avoid swamping the event thread.  */\n//  public void updateTabbedPane() {\n//    if (_tabUpdatePending) return;\n//    _tabUpdatePending = true;\n//    Thread updater = new Thread(new Runnable() {\n//      public void run() {\n//        synchronized(_updateLock) { \n//          try { _updateLock.wait(UPDATE_DELAY); } \n//          catch(InterruptedException e) { /* fall through */ }\n//        }\n//        EventQueue.invokeLater(new Runnable() { \n//          public void run() {\n//            _tabUpdatePending = false;\n//            _tabbedPane.getSelectedComponent().repaint();\n//          }\n//        });\n//      }\n//    });\n//    updater.start();\n//  }\n  \n  private static boolean isDisplayed(TabbedPanel p) { return p != null && p.isDisplayed(); }\n  \n  /** Create new DefinitionsPane and JScrollPane for an open definitions document.  Package private for testing purposes.\n    * @param doc The open definitions document to wrap\n    * @return JScrollPane containing a DefinitionsPane for the given document.\n    */\n  JScrollPane _createDefScrollPane(OpenDefinitionsDocument doc) {\n    DefinitionsPane pane = new DefinitionsPane(this, doc);\n    \n    pane.addKeyListener(_historyListener);\n    pane.addFocusListener(_focusListenerForRecentDocs);\n    \n    // Add listeners\n    _redoAction._installNewDocumentListener(this, doc);\n    ErrorCaretListener caretListener = new ErrorCaretListener(doc, pane, this);\n    pane.addErrorCaretListener(caretListener);\n    \n    doc.addDocumentListener(new DocumentUIListener() {\n      /** Updates panel displayed in interactions subwindow. */\n      private void updateUI(OpenDefinitionsDocument doc, int offset) {\n        assert EventQueue.isDispatchThread();\n//        System.err.println(\"updateUI(\" + doc + \", \" + offset + \")\");\n        \n        Component c = _tabbedPane.getSelectedComponent();\n        if (c instanceof RegionsTreePanel<?>) {\n          reloadPanel((RegionsTreePanel<?>) c, doc, offset);\n        }\n        \n//        _lastChangeTime = System.currentTimeMillis();  // TODO: what about changes to file names?\n      }\n      \n      // coarsely update the displayed RegionsTreePanel\n      private <R extends OrderedDocumentRegion> void reloadPanel(final RegionsTreePanel<R> p,\n                                                                 final OpenDefinitionsDocument doc,\n                                                                 int offset) {\n        \n        final RegionManager<R> rm = p._regionManager;\n        SortedSet<R> regions = rm.getRegions(doc);\n        if (regions == null || regions.size() == 0) return;\n        \n        // Adjust line numbers and line bounds if insert involves newline\n        final int numLinesChangedAfter = doc.getDocument().getAndResetNumLinesChangedAfter();\n        \n        // interval regions that need line number updating\n        Pair<R, R> lineNumInterval = null;\n        \n        if (numLinesChangedAfter >= 0)  {  // insertion/deletion included a newline\n          // Update the bounds of the affected regions\n          \n          // TODO: These casts are bad!  R is not always DocumentRegion (of course).\n          // The code only works because the RegionManager implementations happen to not strictly\n          // require values of type R.  Either the interface for RegionManager.updateLines()\n          // and RegionManager.reload() needs to be generalized, or a means for creating\n          // values that are truly of type R needs to be provided.\n          @SuppressWarnings(\"unchecked\") R start =\n          (R) new DocumentRegion(doc, numLinesChangedAfter, numLinesChangedAfter);\n          int len = doc.getLength();\n          @SuppressWarnings(\"unchecked\") R end = (R) new DocumentRegion(doc, len, len);\n          lineNumInterval = Pair.make(start, end); \n        }\n        \n        Pair<R, R> interval = rm.getRegionInterval(doc, offset);\n        if (interval == null && lineNumInterval == null) return;\n        \n        interval = maxInterval(lineNumInterval, interval);\n        \n        final R first = interval.first();\n        final R last = interval.second();\n        \n        synchronized(_updateLock) {\n          if (_tabUpdatePending && _pendingDocument == doc) {  // revise and delay existing task\n            _firstRegion = _firstRegion.compareTo(first) <= 0 ? _firstRegion : first;\n            _lastRegion = _lastRegion.compareTo(last) >= 0 ? _lastRegion : last;\n            _waitAgain = true;\n            return;\n          }\n          else {  // create a new update task\n            _firstRegion = first;\n            _lastRegion = last;\n            _pendingDocument = doc;\n            _tabUpdatePending = true;\n            _pendingUpdate = new Runnable() { // this Runnable only runs in the event thread\n              public void run() {\n                // TODO: Bad casts!  There's probably no guarantee that R is consistent between invocations,\n                // and even if there were, this is a confusing way to go about this process.\n                // See above discussion for alternatives.\n                @SuppressWarnings(\"unchecked\") R first = (R) _firstRegion;\n                @SuppressWarnings(\"unchecked\") R last = (R) _lastRegion;\n                rm.updateLines(first, last); // recompute _lineStartPos, _lineEndPos in affected regions\n                p.reload(first, last);  // reload the entries whose length may have changed\n                p.repaint();\n              }\n            };  // end _pendingUpdate Runnable\n          }\n        }\n        // Queue a request to perform the update\n        \n        // Create and run a new aynchronous task      that waits UPDATE_DELAY millis, then performs update in event thread\n        _threadPool.submit(new Runnable() {\n          public void run() {\n            Thread.currentThread().setPriority(UPDATER_PRIORITY);\n            synchronized (_updateLock) {\n              try { // _pendingUpdate can be updated during waits\n                do { \n                  _waitAgain = false;\n                  _updateLock.wait(UPDATE_DELAY); \n                } \n                while (_waitAgain);\n              }\n              catch(InterruptedException e) { /* fall through */ }\n              _tabUpdatePending = false;\n            } // end synchronized\n            Utilities.invokeLater(_pendingUpdate);\n          }\n        });\n      }\n      \n      public void changedUpdate(DocumentEvent e) { }\n      public void insertUpdate(DocumentEvent e) {\n        updateUI(((DefinitionsDocument) e.getDocument()).getOpenDefDoc(), e.getOffset()); \n      }\n      public void removeUpdate(DocumentEvent e) {\n        updateUI(((DefinitionsDocument) e.getDocument()).getOpenDefDoc(), e.getOffset());\n      }\n    });\n    \n    // add a listener to update line and column.\n    pane.addCaretListener(_posListener);\n    \n    // add a focus listener to this definitions pane.\n    pane.addFocusListener(new LastFocusListener());\n    \n    // Add to a scroll pane\n    final JScrollPane scroll = \n      new BorderlessScrollPane(pane, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, \n                               JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    pane.setScrollPane(scroll);\n    //scroll.setBorder(null); // removes all default borders (MacOS X installs default borders)\n    \n    if (DrJava.getConfig().getSetting(LINEENUM_ENABLED).booleanValue()) {\n      scroll.setRowHeaderView(new LineEnumRule(pane));\n    }\n    \n    _defScrollPanes.put(doc, scroll);\n    \n    return scroll;\n  }\n  \n  private static <R extends OrderedDocumentRegion> Pair<R, R> maxInterval(Pair<R, R> i, Pair<R, R> j) {\n    if (i == null) return j;\n    if (j == null) return i;\n    R i1 = i.first();\n    R i2 = i.second();\n    R j1 = j.first();\n    R j2 = j.second();\n    \n    return Pair.make(i1.compareTo(j1) <= 0 ? i1 : j1, i2.compareTo(j2) >= 0 ? i2 : j2);\n  }\n  \n  private void _setUpPanes() {\n    // DefinitionsPane\n//    JScrollPane defScroll = _defScrollPanes.get(_model.getActiveDocument());\n    \n    // Try to create debug panel (see if JSwat is around)\n    if (_showDebugger) {\n      try {\n        // Set the panel's size.\n        int debugHeight = DrJava.getConfig().getSetting(DEBUG_PANEL_HEIGHT).intValue();\n        Dimension debugMinSize = _debugPanel.getMinimumSize();\n        \n        // TODO: check bounds compared to entire window.\n        if ((debugHeight > debugMinSize.height)) debugMinSize.height = debugHeight;\n        _debugPanel.setPreferredSize(debugMinSize);\n      }\n      catch(NoClassDefFoundError e) {\n        // Don't use the debugger\n        _showDebugger = false;\n      }\n    } \n    \n    _debugSplitPane.setBottomComponent(_debugPanel);\n    _mainSplit.setResizeWeight(1.0);\n    _debugSplitPane.setResizeWeight(1.0);\n    getContentPane().add(_mainSplit, BorderLayout.CENTER);\n    // This is annoyingly order-dependent. Since split contains _docSplitPane,\n    // we need to get split's divider set up first to give _docSplitPane an\n    // overall size. Then we can set _docSplitPane's divider. Ahh, Swing.\n    // Also, according to the Swing docs, we need to set these dividers AFTER\n    // we have shown the window. How annoying.\n//    int tabHeight = DrJava.getConfig().getSetting(TABS_HEIGHT).intValue();\n    \n    // 2*getHeight()/3\n    _mainSplit.setDividerLocation(_mainSplit.getHeight() - 132);\n//    _mainSplit.setDividerLocation(_mainSplit.getHeight() - tabHeight);\n    _mainSplit.setOneTouchExpandable(true);\n    _debugSplitPane.setOneTouchExpandable(true);\n    \n    int docListWidth = DrJava.getConfig().getSetting(DOC_LIST_WIDTH).intValue();\n    \n    // TODO: Check bounds.\n    _docSplitPane.setDividerLocation(docListWidth);\n    _docSplitPane.setOneTouchExpandable(true);\n  }\n  \n  /** Switch to the JScrollPane containing the DefinitionsPane for the active document. Must run in event thread.*/\n  void _switchDefScrollPane() {\n    assert EventQueue.isDispatchThread();\n    // demoted to package private protection to test the disabling editing while compiling functionality.\n    // and to support brute force fix to DefinitionsPane bug on return from compile with errors\n    // Added 2004-May-27\n    // Notify the definitions pane that is being replaced (becoming inactive)\n    _currentDefPane.notifyInactive();\n    \n//    Utilities.showDebug(\"_switchDefScrollPane called\");\n//    Utilities.showDebug(\"Right before getting the scrollPane\");\n    OpenDefinitionsDocument activeDoc = _model.getActiveDocument();\n    _currentDefDoc = activeDoc.getDocument();\n    JScrollPane scroll = _defScrollPanes.get(activeDoc);\n    \n    if (scroll == null) scroll = _createDefScrollPane(activeDoc);\n    // Fix OS X scrollbar bug before switching\n    \n    _reenableScrollBar();\n    \n    int oldLocation = _docSplitPane.getDividerLocation();\n    _docSplitPane.setRightComponent(scroll); //crazy line\n    _docSplitPane.setDividerLocation(oldLocation);\n    \n    // if the current def pane is uneditable, that means we arrived here from a compile with errors.  We're\n    // guaranteed to make it editable again when we return from the compilation, so we take the state\n    // with us.  We guarantee only one definitions pane is un-editable at any time.\n    if (_currentDefPane.isEditable()) {\n      if (_currentDefPane != null) { _currentDefPane.removeFocusListener(_undoRedoDefinitionsFocusListener); }\n      _currentDefPane = (DefinitionsPane) scroll.getViewport().getView();\n      _currentDefPane.notifyActive();\n      _currentDefPane.addFocusListener(_undoRedoDefinitionsFocusListener);\n    }\n    else {\n      try { _currentDefPane.setEditable(true); }\n      catch(NoSuchDocumentException e) { /* It's OK */ }\n      \n      if (_currentDefPane != null) { _currentDefPane.removeFocusListener(_undoRedoDefinitionsFocusListener); }\n      _currentDefPane = (DefinitionsPane) scroll.getViewport().getView();\n      _currentDefPane.notifyActive();\n      _currentDefPane.setEditable(false);\n      _currentDefPane.addFocusListener(_undoRedoDefinitionsFocusListener);\n    }\n    // reset the undo/redo menu items\n    resetUndo();\n    _updateDebugStatus();\n  }\n  \n  /** Refresh the JScrollPane containing the DefinitionsPane for the active document. Must run in event thread.*/\n  private void _refreshDefScrollPane() {\n    // Added 2004-May-27\n    // Notify the definitions pane that is being replaced (becoming inactive)\n    _currentDefPane.notifyInactive();\n    \n//    Utilities.showDebug(\"_switchDefScrollPane called\");\n//    Utilities.showDebug(\"Right before getting the scrollPane\");\n    OpenDefinitionsDocument doc = _model.getActiveDocument();\n    _currentDefDoc = doc.getDocument();  // update the current DefinitionsDocument (can it be clobbered in a replaceAll?)\n    JScrollPane scroll = _defScrollPanes.get(doc);\n    \n//    if (scroll == null) scroll = _createDefScrollPane(doc);\n    // Fix OS X scrollbar bug before switching\n    \n    _reenableScrollBar();\n    \n    int oldLocation = _docSplitPane.getDividerLocation();\n    _docSplitPane.setRightComponent(scroll); //crazy line\n    _docSplitPane.setDividerLocation(oldLocation);\n    \n//    // if the current def pane is uneditable, that means we arrived here from a compile with errors.  We're\n//    // guaranteed to make it editable again when we return from the compilation, so we take the state\n//    // with us.  We guarantee only one definitions pane is un-editable at any time.\n//    if (_currentDefPane.isEditable()) {\n//      _currentDefPane = (DefinitionsPane) scroll.getViewport().getView();\n    _currentDefPane.notifyActive();\n//    }\n//    else {\n//      try { _currentDefPane.setEditable(true); }\n//      catch(NoSuchDocumentException e) { /* It's OK */ }\n//      \n//      _currentDefPane = (DefinitionsPane) scroll.getViewport().getView();\n//      _currentDefPane.notifyActive();\n//      _currentDefPane.setEditable(false);\n//    }\n//    // reset the undo/redo menu items\n    resetUndo();\n    _updateDebugStatus();\n  }\n  \n  /** Resets the undo/redo menu items */\n  public void resetUndo() {\n    _undoAction.setDelegatee(_currentDefPane.getUndoAction());\n    _redoAction.setDelegatee(_currentDefPane.getRedoAction());\n  }\n  \n  public DefinitionsPane getDefPaneGivenODD(OpenDefinitionsDocument doc) {\n    JScrollPane scroll = _defScrollPanes.get(doc);\n    if (scroll == null) { \n      if (_model.getOpenDefinitionsDocuments().contains(doc)) scroll = _createDefScrollPane(doc);\n      else throw new UnexpectedException(new Exception(\"Attempted to get DefinitionsPane for a closed document\")); \n    }\n    \n    DefinitionsPane pane = (DefinitionsPane) scroll.getViewport().getView();\n    return pane;\n  }\n  \n  /** Addresses Mac OS X bug where the scrollbars are disabled in one document after opening another. */\n  private void _reenableScrollBar() {\n    JScrollPane scroll = _defScrollPanes.get(_model.getActiveDocument());\n    if (scroll == null)\n      throw new UnexpectedException(new Exception(\"Current definitions scroll pane not found.\"));\n    \n    JScrollBar oldbar = scroll.getVerticalScrollBar();\n    JScrollBar newbar = scroll.createVerticalScrollBar();\n    newbar.setMinimum(oldbar.getMinimum());\n    newbar.setMaximum(oldbar.getMaximum());\n    newbar.setValue(oldbar.getValue());\n    newbar.setVisibleAmount(oldbar.getVisibleAmount());\n    newbar.setEnabled(true);\n    newbar.revalidate();\n    scroll.setVerticalScrollBar(newbar);\n    \n    // This needs to be repeated for the horizontal scrollbar\n    oldbar = scroll.getHorizontalScrollBar();\n    newbar = scroll.createHorizontalScrollBar();\n    newbar.setMinimum(oldbar.getMinimum());\n    newbar.setMaximum(oldbar.getMaximum());\n    newbar.setValue(oldbar.getValue());\n    newbar.setVisibleAmount(oldbar.getVisibleAmount());\n    newbar.setEnabled(true);\n    newbar.revalidate();\n    scroll.setHorizontalScrollBar(newbar);\n    scroll.revalidate();\n  }\n  \n  /** Gets the absolute file, or if necessary, the canonical file.\n    * @param f the file for which to get the full path\n    * @return the file representing the full path to the given file\n    */\n  private File _getFullFile(File f) throws IOException {\n    if (PlatformFactory.ONLY.isWindowsPlatform() &&\n        ((f.getAbsolutePath().indexOf(\"..\") != -1) || (f.getAbsolutePath().indexOf(\"./\") != -1) ||\n         (f.getAbsolutePath().indexOf(\".\\\\\") != -1))) {\n      return f.getCanonicalFile();\n    }\n    return f.getAbsoluteFile();\n  }\n  \n  /** Sets the current directory to be that of the given file. */\n  private void _setCurrentDirectory(File file) {\n    /* We want to use absolute paths whenever possible, since canonical paths resolve symbolic links and can be quite\n     * long and unintuitive.  However, Windows blows up if you set the current directory of a JFileChooser to an \n     * absolute path with \"..\" in it.  In that case, we'll use the canonical path for the file chooser. (Fix for \n     * bug 707734)  Extended this to fix \"./\" and \".\\\" also (bug 774896)\n     */\n    try {\n      file = _getFullFile(file);\n      _openChooser.setCurrentDirectory(file);\n      _saveChooser.setCurrentDirectory(file);\n      DrJava.getConfig().setSetting(LAST_DIRECTORY, file);\n    }\n    catch (IOException ioe) {\n      // If getCanonicalFile throws an IOException, we can't set the directory of the file chooser.  Oh well.\n    }\n  }\n  \n  /** Sets the current directory to be that of document's file.   */\n  private void _setCurrentDirectory(OpenDefinitionsDocument doc) {\n    try {\n      File file = doc.getFile();\n      if (file != null) _setCurrentDirectory(file); // if no file, leave in current directory\n    }\n    catch (FileMovedException fme) {\n      // file was deleted, but try to go the directory\n      _setCurrentDirectory(fme.getFile());\n    }\n  }\n  \n  /** Sets the font of all panes and panels to the main font. */\n  private void _setMainFont() {\n    \n    Font f = DrJava.getConfig().getSetting(FONT_MAIN);\n    \n    for (JScrollPane scroll: _defScrollPanes.values()) {\n      if (scroll != null) {\n        DefinitionsPane pane = (DefinitionsPane) scroll.getViewport().getView();\n        pane.setFont(f);\n        // Update the font of the line enumeration rule\n        if (DrJava.getConfig().getSetting(LINEENUM_ENABLED).booleanValue()) {\n          scroll.setRowHeaderView(new LineEnumRule(pane));\n        }\n      }\n    }\n    \n    // Update Interactions Pane\n    _interactionsPane.setFont(f);\n    \n    // Update Console Pane\n    _consolePane.setFont(f);\n    \n    _findReplace.setFieldFont(f);\n    _compilerErrorPanel.setListFont(f);\n    _junitPanel.setListFont(f);\n    _javadocErrorPanel.setListFont(f);\n  }\n  \n  /** Updates the text color for the doc list. */\n  private void _updateNormalColor() {\n    // Get the new value.\n    Color norm = DrJava.getConfig().getSetting(DEFINITIONS_NORMAL_COLOR);\n    \n    // Change the text (foreground) color for the doc list.\n    _model.getDocCollectionWidget().setForeground(norm);\n    \n    // We also need to immediately repaint the foremost scroll pane.\n    _repaintLineNums();\n  }\n  \n  /** Updates the background color for the doc list. */\n  private void _updateBackgroundColor() {\n    // Get the new value.\n    Color back = DrJava.getConfig().getSetting(DEFINITIONS_BACKGROUND_COLOR);\n    \n    // Change the background color for the doc list.\n    _model.getDocCollectionWidget().setBackground(back);\n    \n    // We also need to immediately repaint the foremost scroll pane.\n    _repaintLineNums();\n  }\n  \n  /** Updates the font and colors of the line number display. */\n  private void _updateLineNums() {\n    if (DrJava.getConfig().getSetting(LINEENUM_ENABLED).booleanValue()) {\n      \n      // Update the font for all line number displays\n      for (JScrollPane spane: _defScrollPanes.values()) { \n        \n        LineEnumRule ler = (LineEnumRule) spane.getRowHeader().getView();\n        ler.updateFont();\n        ler.revalidate();\n      }\n      \n      // We also need to immediately repaint the foremost scroll pane.\n      _repaintLineNums();\n    }\n  }\n  \n  /** Repaints the line numbers on the active scroll pane. */\n  private void _repaintLineNums() {\n    JScrollPane front = _defScrollPanes.get(_model.getActiveDocument());\n    if (front != null) {\n      JViewport rhvport = front.getRowHeader();\n      \n      if (rhvport != null) {\n        Component view = rhvport.getView();\n        if (view != null) view.repaint();\n      }\n    }\n  }\n  \n//  /** Revalidate the line numers, i.e. also redraw the ones not currently visible. */\n//  public void revalidateLineNums() {\n//    if (DrJava.getConfig().getSetting(LINEENUM_ENABLED).booleanValue()) {\n//      JScrollPane sp = _defScrollPanes.get(_model.getActiveDocument());\n//      if (sp != null) {\n//        LineEnumRule ler = (LineEnumRule)sp.getRowHeader().getView();\n//        ler.revalidate();\n//        _repaintLineNums();\n//      }\n//    }\n//  }\n  \n  /** Update the row header (line number enumeration) for the definitions scroll pane. */\n  private void _updateDefScrollRowHeader() {\n    boolean ruleEnabled = DrJava.getConfig().getSetting(LINEENUM_ENABLED).booleanValue();\n    \n    for (JScrollPane scroll: _defScrollPanes.values()) {\n      if (scroll != null) {\n        DefinitionsPane pane = (DefinitionsPane) scroll.getViewport().getView();\n        if (scroll.getRowHeader() == null || scroll.getRowHeader().getView() == null) {\n          if (ruleEnabled) scroll.setRowHeaderView(new LineEnumRule(pane));\n        }\n        else if (! ruleEnabled) scroll.setRowHeaderView(null);\n      }\n    }\n  }\n  \n  /** Removes the current highlight. */\n  public void removeCurrentLocationHighlight() {\n    if (_currentLocationHighlight != null) {\n      _currentLocationHighlight.remove();\n      _currentLocationHighlight = null;\n    }\n  }\n  \n  /** Disable any step timer. */\n  private void _disableStepTimer() {\n    synchronized(_debugStepTimer) { if (_debugStepTimer.isRunning()) _debugStepTimer.stop(); }\n  }\n  \n  /** Checks if debugPanel's status bar displays the DEBUGGER_OUT_OF_SYNC message but the current document is \n    * in sync.  Clears the debugPanel's status bar in this case.  Does not assume that frame is in debug mode.\n    * Must be executed in event thread.\n    */\n  private void _updateDebugStatus() {\n    boolean debuggerReady = isDebuggerReady();\n    _guiAvailabilityNotifier.ensureAvailabilityIs(GUIAvailabilityListener.ComponentType.DEBUGGER, debuggerReady);\n    if (!debuggerReady) { return; }\n    \n    // if the document is untitled, don't show that it is out of sync since it can't be debugged anyway\n    if (_model.getActiveDocument().isUntitled() || _model.getActiveDocument().getClassFileInSync()) {\n      // Hide message\n      if (_debugPanel.getStatusText().equals(DEBUGGER_OUT_OF_SYNC)) _debugPanel.setStatusText(\"\");\n    } \n    else {\n      // Show message\n      if (_debugPanel.getStatusText().equals(\"\")) {\n        _debugPanel.setStatusText(DEBUGGER_OUT_OF_SYNC);\n      }\n    }\n    _debugPanel.repaint();  // display the updated panel\n  }\n  \n  /** Ensures that the interactions pane is not editable during an interaction. */\n  protected void _disableInteractionsPane() {\n    assert EventQueue.isDispatchThread();\n    _interactionsPane.setEditable(false);\n    _interactionsPane.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n    \n    if (_interactionsScriptController != null) _interactionsScriptController.setActionsDisabled();\n  }\n  \n  /** Ensures that the interactions pane is editable after an interaction completes. */\n  protected void _enableInteractionsPane() {\n    assert EventQueue.isDispatchThread();\n    _interactionsPane.setCursor(Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));\n    _interactionsPane.setEditable(true);\n    _interactionsController.moveToEnd();\n    if (_interactionsPane.hasFocus()) _interactionsPane.getCaret().setVisible(true);\n    if (_interactionsScriptController != null) _interactionsScriptController.setActionsEnabled();\n  }\n  \n  /** Comment current selection using wing commenting.  public for testing purposes only. Runs in event thread. */\n  public void commentLines() {\n    assert EventQueue.isDispatchThread();\n    \n    // Delegate everything to the DefinitionsDocument.\n    OpenDefinitionsDocument openDoc = _model.getActiveDocument();\n    int caretPos = _currentDefPane.getCaretPosition();\n    openDoc.setCurrentLocation(caretPos);\n    int start = _currentDefPane.getSelectionStart();\n    int end = _currentDefPane.getSelectionEnd();\n//    _currentDefPane.endCompoundEdit();\n//    _currentDefPane.notifyInactive();\n    int newEnd = openDoc.commentLines(start, end);\n//    _currentDefPane.notifyActive();\n    _currentDefPane.setCaretPosition(start+2);\n    if (start != end) _currentDefPane.moveCaretPosition(newEnd);\n  }\n  \n  /** Uncomment current selection using wing commenting.  Public for testing purposes only.  Runs in event thread. */\n  public void uncommentLines() {\n    assert EventQueue.isDispatchThread();\n    \n    // Delegate everything to the DefinitionsDocument.\n    OpenDefinitionsDocument openDoc = _model.getActiveDocument();\n    int caretPos = _currentDefPane.getCaretPosition();\n    openDoc.setCurrentLocation(caretPos);\n    int start = _currentDefPane.getSelectionStart();\n    int end = _currentDefPane.getSelectionEnd();\n    _currentDefPane.endCompoundEdit();\n    \n    //notify inactive to prevent refreshing of the DefPane every time an insertion is made\n//    _currentDefPane.notifyInactive();\n    openDoc.setCurrentLocation(start);\n    Position startPos;\n    try { startPos = openDoc.createUnwrappedPosition(start); }\n    catch (BadLocationException e) { throw new UnexpectedException(e); }\n    \n    int startOffset = startPos.getOffset();        \n    final int newEnd = openDoc.uncommentLines(start, end);\n//    _currentDefPane.notifyActive();\n    if (startOffset != startPos.getOffset()) start -= 2;\n    final int f_start = start;\n    final boolean moveSelection = start != end;\n    _currentDefPane.setCaretPosition(f_start);\n    if (moveSelection) _currentDefPane.moveCaretPosition(newEnd);\n  }\n  \n  /** Blocks access to DrJava while the hourglass cursor is on. */\n  private static class GlassPane extends JComponent {\n    \n    /** Creates a new GlassPane over the DrJava window. */\n    public GlassPane() {\n      addKeyListener(new KeyAdapter() { });\n      addMouseListener(new MouseAdapter() { });\n      super.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n    }\n  }\n  \n  /** Called when a specific document and offset should be displayed. Must be executed only in the event thread.\n    * @param doc Document to display\n    * @param offset Offset to display\n    * @param shouldHighlight true iff the line should be highlighted.  Only done in debugger.\n    */\n  public void scrollToDocumentAndOffset(final OpenDefinitionsDocument doc, final int offset, \n                                        final boolean shouldHighlight) {\n    scrollToDocumentAndOffset(doc, offset, shouldHighlight, true);\n  }\n  \n  public void goToRegionAndHighlight(final IDocumentRegion r) {\n    assert EventQueue.isDispatchThread();\n    addToBrowserHistory();\n    final OpenDefinitionsDocument doc = r.getDocument();\n    boolean toSameDoc = doc == _model.getActiveDocument();\n    Runnable command = new Runnable() {\n      public void run() {\n        int startOffset = r.getStartOffset();\n        int endOffset = r.getEndOffset();\n        doc.setCurrentLocation(startOffset);\n        _currentLocationHighlight = _currentDefPane.getHighlightManager().\n          addHighlight(startOffset, endOffset, DefinitionsPane.THREAD_PAINTER);\n        _currentDefPane.centerViewOnOffset(startOffset);\n        _currentDefPane.select(startOffset, endOffset);\n        _currentDefPane.requestFocusInWindow();\n      }\n    };\n    \n    if (! toSameDoc) {\n      _model.setActiveDocument(doc);    // queues event actions\n      _findReplace.updateFirstDocInSearch();\n      EventQueue.invokeLater(command);  // postpone running command until queued event actions complete.\n    }\n    else {\n      _model.refreshActiveDocument();\n      command.run();\n    }\n    EventQueue.invokeLater(new Runnable() { public void run() { addToBrowserHistory(); } });  // after command completes\n  }\n  \n  /** Called when a specific document and offset should be displayed. Must be executed only in the event thread.\n    * @param doc Document to display\n    * @param offset Offset to display\n    * @param shouldHighlight true iff the line should be highlighted.\n    * @param shouldAddToHistory true if the location before and after the switch should be added to the browser history\n    */\n  public void scrollToDocumentAndOffset(final OpenDefinitionsDocument doc, final int offset, \n                                        final boolean shouldHighlight, final boolean shouldAddToHistory) {\n    \n    assert duringInit() || EventQueue.isDispatchThread();\n    \n    if (shouldAddToHistory) addToBrowserHistory();\n    OpenDefinitionsDocument activeDoc =  _model.getActiveDocument();\n    final boolean toSameDoc = (activeDoc == doc);\n    \n    Runnable command = new Runnable() {\n      public void run() {\n        \n        if (shouldHighlight) {\n          removeCurrentLocationHighlight();\n          int startOffset = doc._getLineStartPos(offset);\n          if (startOffset >= 0) {\n            int endOffset = doc._getLineEndPos(offset);\n            if (endOffset >= 0) {\n              _currentLocationHighlight = _currentDefPane.getHighlightManager().\n                addHighlight(startOffset, endOffset, DefinitionsPane.THREAD_PAINTER);\n            }\n          }\n        }\n        // Is the following test necessary?\n        if (_currentDefPane.getSize().getWidth() > 0 && _currentDefPane.getSize().getHeight() > 0) {\n          EventQueue.invokeLater(new Runnable() { \n            public void run() {\n              _currentDefPane.centerViewOnOffset(offset);\n              _currentDefPane.requestFocusInWindow();\n            }\n          });\n        }\n        \n        if (_showDebugger) {\n          // Give the interactions pane focus so we can debug\n          _interactionsPane.requestFocusInWindow();\n//          System.err.println(\"Showing Interactions Tab\" );\n//          showTab(_interactionsContainer); // disabled to avoid switch to interactions when browsing findall results\n          _updateDebugStatus();\n        }\n      }\n    };\n    \n    if (! toSameDoc) {\n      _model.setActiveDocument(doc);    // queues event actions\n      _findReplace.updateFirstDocInSearch();\n      EventQueue.invokeLater(command);  // postpone running command until queued event actions complete.\n    }\n    else {\n      _model.refreshActiveDocument();\n      command.run();\n    }\n  }\n  \n  /** @return true if a project is active and a valid main class is set. */\n  boolean isProjectActiveAndMainClassSet() {\n    return (_model.isProjectActive() &&\n            (_model.getMainClass() != null) &&\n            (_model.getMainClassContainingFile() != null) && \n            _model.getMainClassContainingFile().exists());\n  }\n  /** @return true if a project is active and a valid main class is set. */\n  boolean isProjectActiveAndBuildDirSet() {\n    return (_model.isProjectActive() &&\n            (_model.getBuildDirectory() != null) &&\n            (_model.getBuildDirectory() != FileOps.NULL_FILE));\n  }\n  \n  /** Listens to events from the debugger. */\n  private class UIDebugListener implements DebugListener {\n    /* Must be executed in evevt thread.*/\n    public void debuggerStarted() { EventQueue.invokeLater(new Runnable() { public void run() { showDebugger(); } }); }\n    \n    /* Must be executed in eventt thread.*/\n    public void debuggerShutdown() {\n      EventQueue.invokeLater(new Runnable() {\n        public void run() {\n          _disableStepTimer();\n          hideDebugger();\n          removeCurrentLocationHighlight();\n        }\n      } );\n    }                        \n    \n    /** Called when a step is requested on the current thread.  Must be executed in event thread. */\n    public void stepRequested() {\n      // Print a message if step takes a long time\n      synchronized(_debugStepTimer) { if (! _debugStepTimer.isRunning()) _debugStepTimer.start(); }\n    }\n    \n    public void currThreadSuspended() {\n      assert EventQueue.isDispatchThread();\n      _disableStepTimer();\n      _setThreadDependentDebugMenuItems(true);\n      _model.getInteractionsModel().autoImport();               \n      if(_model.getDebugger().isAutomaticTraceEnabled()) {\n        //System.out.println(\"new _automaticTraceTimer AUTO_STEP_RATE=\" + AUTO_STEP_RATE + \", \" + \n        //                   System.identityHashCode(_automaticTraceTimer);                                \n        if((_automaticTraceTimer != null) && (!_automaticTraceTimer.isRunning()))\n          _automaticTraceTimer.start();\n      }\n    }\n    \n    /* Must be executed in the event thread. */\n    public void currThreadResumed() {\n      _setThreadDependentDebugMenuItems(false);\n      removeCurrentLocationHighlight();\n    }    \n    \n    /** Called when the given line is reached by the current thread in the debugger, to request that the line be \n      * displayed.  Must be executed only in the event thread.\n      * @param doc Document to display\n      * @param lineNumber Line to display or highlight\n      * @param shouldHighlight true iff the line should be highlighted.\n      */\n    public void threadLocationUpdated(OpenDefinitionsDocument doc, int lineNumber, boolean shouldHighlight) {\n      scrollToDocumentAndOffset(doc, doc._getOffset(lineNumber), shouldHighlight); \n    }\n    \n    /* Must be executed in event thread. */\n    public void currThreadDied() {\n      assert EventQueue.isDispatchThread();\n      _disableStepTimer();\n      _model.getDebugger().setAutomaticTraceEnabled(false);\n      if (_automaticTraceTimer != null) _automaticTraceTimer.stop();\n      if (isDebuggerReady()) {\n        try {        \n          if (!_model.getDebugger().hasSuspendedThreads()) {\n            // no more suspended threads, resume default debugger state\n            // all thread dependent debug menu items are disabled\n            _setThreadDependentDebugMenuItems(false);\n            removeCurrentLocationHighlight();\n            // Make sure we're at the prompt\n            // (This should really be fixed in InteractionsController, not here.)\n            _interactionsController.moveToPrompt(); // there are no suspended threads, bring back prompt\n          }\n        }\n        catch (DebugException de) {\n          MainFrameStatics.showError(MainFrame.this, de, \"Debugger Error\", \"Error with a thread in the debugger.\");\n        }\n      }\n    }\n    \n    public void currThreadSet(DebugThreadData dtd) { }\n    public void regionAdded(final Breakpoint bp) { }\n    public void breakpointReached(Breakpoint bp) {\n      showTab(_interactionsContainer, true);\n    }\n    public void regionChanged(Breakpoint bp) {  }\n    public void regionRemoved(final Breakpoint bp) { }    \n    public void watchSet(final DebugWatchData w) { }\n    public void watchRemoved(final DebugWatchData w) { }\n    public void threadStarted() { }\n    public void nonCurrThreadDied() { }\n  }\n  \n  /** @author jlugo */\n  private class DJAsyncTaskLauncher extends AsyncTaskLauncher {\n    \n    protected boolean shouldSetEnabled() { return true; }\n    \n    protected void setParentContainerEnabled(boolean enabled) {\n      if (enabled) hourglassOff(); \n      else hourglassOn();\n    }\n    \n    protected IAsyncProgress createProgressMonitor(final String description, final int min, final int max) {\n      return new IAsyncProgress() {\n        private ProgressMonitor _monitor = new ProgressMonitor(MainFrame.this, description, \"\", min, max);\n        \n        public void close() { _monitor.close(); }\n        public int  getMaximum() { return _monitor.getMaximum() ; }\n        public int  getMillisToDecideToPopup() { return _monitor.getMillisToDecideToPopup(); }\n        public int  getMillisToPopup() { return  _monitor.getMillisToPopup(); }\n        public int  getMinimum() { return _monitor.getMinimum(); }\n        public String  getNote() { return _monitor.getNote(); }\n        public boolean  isCanceled() { return _monitor.isCanceled(); }\n        public void  setMaximum(int m) { _monitor.setMaximum(m); }\n        public void  setMinimum(int m) { _monitor.setMinimum(m); }\n        public void  setNote(String note) { _monitor.setNote(note); }\n        public void  setProgress(int nv) { _monitor.setProgress(nv); }\n      };\n    }\n  }\n  \n  /** Ask the user to increase the slave's max heap setting. */\n  void askToIncreaseSlaveMaxHeap() {\n    String value = \"set to \"+DrJava.getConfig().getSetting(SLAVE_JVM_XMX)+\" MB\";\n    if ((!(\"\".equals(DrJava.getConfig().getSetting(SLAVE_JVM_XMX)))) &&\n        ((OptionConstants.heapSizeChoices.get(0).equals(DrJava.getConfig().getSetting(SLAVE_JVM_XMX))))) { \n      value = \"not set, implying the system's default\";\n    }\n    \n    String res = (String)JOptionPane.\n      showInputDialog(MainFrame.this,\n                      \"Your program ran out of memory. You may try to enter a larger\\n\" +\n                      \"maximum heap size for the Interactions JVM. The maximum heap size is\\n\" +\n                      \"currently \"+value+\".\\n\"+\n                      \"A restart is required after changing this setting.\",\n                      \"Increase Maximum Heap Size?\",\n                      JOptionPane.QUESTION_MESSAGE,\n                      null,\n                      OptionConstants.heapSizeChoices.toArray(),\n                      DrJava.getConfig().getSetting(SLAVE_JVM_XMX));\n    \n    if (res != null) {\n      // temporarily make MainFrame the parent of the dialog that pops up\n      DrJava.getConfig().removeOptionListener(SLAVE_JVM_XMX, _slaveJvmXmxListener);\n      final ConfigOptionListeners.SlaveJVMXMXListener l = new ConfigOptionListeners.SlaveJVMXMXListener(MainFrame.this);\n      DrJava.getConfig().addOptionListener(SLAVE_JVM_XMX, l);\n      // change the setting\n      DrJava.getConfig().setSetting(SLAVE_JVM_XMX,res.trim());\n      EventQueue.invokeLater(new Runnable() {\n        public void run() {\n          // reinstall ConfigFrame as parent\n          DrJava.getConfig().removeOptionListener(SLAVE_JVM_XMX, l);\n          DrJava.getConfig().addOptionListener(SLAVE_JVM_XMX, _slaveJvmXmxListener);\n        }\n      });\n    }\n    _model.getInteractionsModel().resetLastErrors();\n  }\n  \n  /** Ask the user to increase the master's max heap setting. */\n  void askToIncreaseMasterMaxHeap() {\n    String value = \"set to \"+DrJava.getConfig().getSetting(MASTER_JVM_XMX)+\" MB\";\n    if ((!(\"\".equals(DrJava.getConfig().getSetting(MASTER_JVM_XMX)))) &&\n        ((OptionConstants.heapSizeChoices.get(0).equals(DrJava.getConfig().getSetting(MASTER_JVM_XMX))))) { \n      value = \"not set, implying the system's default\";\n    }\n    \n    String res = (String)JOptionPane.showInputDialog(MainFrame.this,\n                                                     \"DrJava ran out of memory. You may try to enter a larger\\n\" +\n                                                     \"maximum heap size for the main JVM. The maximum heap size is\\n\" +\n                                                     \"currently \" + value + \".\\n\" +\n                                                     \"A restart is required after changing this setting.\",\n                                                     \"Increase Maximum Heap Size?\",\n                                                     JOptionPane.QUESTION_MESSAGE,\n                                                     null,\n                                                     OptionConstants.heapSizeChoices.toArray(),\n                                                     DrJava.getConfig().getSetting(MASTER_JVM_XMX));\n    \n    if (res != null) {\n      // temporarily make MainFrame the parent of the dialog that pops up\n      DrJava.getConfig().removeOptionListener(MASTER_JVM_XMX, _masterJvmXmxListener);\n      final ConfigOptionListeners.MasterJVMXMXListener l = \n        new ConfigOptionListeners.MasterJVMXMXListener(MainFrame.this);\n      DrJava.getConfig().addOptionListener(MASTER_JVM_XMX, l);\n      // change the setting\n      DrJava.getConfig().setSetting(MASTER_JVM_XMX,res.trim());\n      EventQueue.invokeLater(new Runnable() {\n        public void run() {\n          // reinstall ConfigFrame as parent\n          DrJava.getConfig().removeOptionListener(MASTER_JVM_XMX, l);\n          DrJava.getConfig().addOptionListener(MASTER_JVM_XMX, _masterJvmXmxListener);\n        }\n      });\n    }\n    _model.getInteractionsModel().resetLastErrors();\n  }\n  \n  /** Inner class to listen to all events in the model. */\n  private class ModelListener implements GlobalModelListener {\n    \n    public <P,R> void executeAsyncTask(AsyncTask<P,R> task, P param, boolean showProgress, boolean lockUI) {\n      new DJAsyncTaskLauncher().executeTask(task, param, showProgress, lockUI);\n    }\n    public void handleAlreadyOpenDocument(OpenDefinitionsDocument doc) {\n//     boolean docChanged = !doc.equals(_model.getActiveDocument());\n//     if (docChanged) { addToBrowserHistory(); }\n      \n      // Always switch to doc\n      _model.setActiveDocument(doc);\n      \n//     // defer executing this code until after active document switch (if any) is complete\n//     EventQueue.invokeLater(new Runnable() { public void run() { addToBrowserHistory(); } });\n      \n      // Prompt to revert if modified\n      if (doc.isModifiedSinceSave()) {\n        String title = \"Revert to Saved?\";\n        String message = doc.getFileName() + \" is already open and modified.\\n\" +\n          \"Would you like to revert to the version on disk?\\n\";\n        int choice = JOptionPane.showConfirmDialog(MainFrame.this, message, title, JOptionPane.YES_NO_OPTION);\n        if (choice == JOptionPane.YES_OPTION) {\n          _revert(doc);\n        }\n      }\n    }\n    \n    public void newFileCreated(final OpenDefinitionsDocument doc) {\n      _createDefScrollPane(doc);\n      PropertyMaps.TEMPLATE.getProperty(\"DrJava\", \"drjava.all.files\").invalidate();\n    }\n    \n    private volatile int _fnfCount = 0;\n    \n    private boolean resetFNFCount() { return _fnfCount == 0; }\n    \n    private boolean someFilesNotFound() {\n      PropertyMaps.TEMPLATE.getProperty(\"DrJava\", \"drjava.all.files\").invalidate();\n      return _fnfCount > 0;\n    }\n    \n    public void filesNotFound(File... files) {\n      if (files.length == 0) return;\n      _fnfCount += files.length;\n      \n      if (files.length == 1) {\n        JOptionPane.showMessageDialog(MainFrame.this,\n                                      \"The following file could not be found and has been removed from the project.\\n\"\n                                        + files[0].getPath(),\n                                      \"File Not Found\",\n                                      JOptionPane.ERROR_MESSAGE);\n      }\n      else {\n        final List<String> filePaths = new ArrayList<String>();\n        for (File f : files) { filePaths.add(f.getPath()); }\n        \n        ScrollableListDialog<String> dialog = new ScrollableListDialog.Builder<String>()\n          .setOwner(MainFrame.this)\n          .setTitle(\"Files Not Found\")\n          .setText(\"The following files could not be found and have been removed from the project.\")\n          .setItems(filePaths)\n          .setMessageType(JOptionPane.ERROR_MESSAGE)\n          .build();\n        \n        setPopupLoc(dialog);\n        dialog.showDialog();\n        PropertyMaps.TEMPLATE.getProperty(\"DrJava\", \"drjava.all.files\").invalidate();\n      }\n    }\n    \n    public File[] filesReadOnly(File... files) {\n      if (files.length == 0) return new File[0];\n      _fnfCount += files.length;\n      \n      final ArrayList<String> choices = new java.util.ArrayList<String>();\n      choices.add(\"Yes\");\n      choices.add(\"No\");\n      final List<String> filePaths = new ArrayList<String>();\n      for (File f : files) { filePaths.add(f.getPath()); }\n      ScrollableListDialog<String> dialog = new ScrollableListDialog.Builder<String>()\n        .setOwner(MainFrame.this)\n        .setTitle(\"Files are Read-Only\")\n        .setText(\"<html>The following files could not be saved because they are read-only.<br>\"+\n                 \"Do you want to overwrite them anyway?</html>\")\n        .setItems(filePaths)\n        .setSelectedItems(filePaths)\n        .setMessageType(JOptionPane.QUESTION_MESSAGE)\n        .clearButtons()\n        .addButton(new JButton(\"Yes\"))\n        .addButton(new JButton(\"No\"))\n        .setSelectable(true)\n        .build();\n      \n      boolean overwrite = false;\n      \n      if (files.length == 1) {\n        int res = JOptionPane.showConfirmDialog(MainFrame.this,\n                                                \"The following file could not be saved because it is read-only.\\n\" +\n                                                \"Do you want to overwrite it anyway?\\n\" + files[0].getPath(),\n                                                \"File is Read-Only\",\n                                                JOptionPane.YES_NO_OPTION,\n                                                JOptionPane.QUESTION_MESSAGE);\n        overwrite = (res == 0);\n      }\n      else {\n        setPopupLoc(dialog);\n        dialog.showDialog();\n        overwrite = (dialog.getButtonPressed() == 0);\n      }\n      \n      if (overwrite) {\n        if (files.length == 1) return files;\n        else {\n          File[] overwriteFiles = new File[dialog.getSelectedItems().size()];\n          int i = 0;\n          for(String s: dialog.getSelectedItems()) { overwriteFiles[i++] = new File(s); }\n          return overwriteFiles;\n        }\n      }\n      else return new File[0];\n    }\n    \n    public void fileSaved(final OpenDefinitionsDocument doc) {\n      doc.documentSaved();  // used to update the document cache\n      _saveAction.setEnabled(false);\n      _renameAction.setEnabled(true);\n      _revertAction.setEnabled(true);\n      updateStatusField();\n      _currentDefPane.requestFocusInWindow();\n      PropertyMaps.TEMPLATE.getProperty(\"DrJava\", \"drjava.all.files\").invalidate();\n      try {\n        File f = doc.getFile();\n        if (! _model.inProject(f)) _recentFileManager.updateOpenFiles(f);\n      }\n      catch (FileMovedException fme) {\n        File f = fme.getFile();\n        // Recover, show it in the list anyway\n        if (! _model.inProject(f)) _recentFileManager.updateOpenFiles(f);\n      }\n      // Check class file sync status, in case file was renamed\n      _updateDebugStatus();\n    }\n    \n    public void fileOpened(final OpenDefinitionsDocument doc) { \n      _fileOpened(doc);\n      PropertyMaps.TEMPLATE.getProperty(\"DrJava\", \"drjava.all.files\").invalidate(); \n    }\n    \n    private void _fileOpened(final OpenDefinitionsDocument doc) {\n      try {\n        File f = doc.getFile();\n        if (! _model.inProject(f)) {\n          _recentFileManager.updateOpenFiles(f);\n          PropertyMaps.TEMPLATE.getProperty(\"DrJava\", \"drjava.all.files\").invalidate();\n        }\n      }\n      catch (FileMovedException fme) {\n        File f = fme.getFile();\n        // Recover, show it in the list anyway\n        if (! _model.inProject(f)) _recentFileManager.updateOpenFiles(f);\n      }\n    }\n    \n    public void fileClosed(final OpenDefinitionsDocument doc) { _fileClosed(doc); }\n    \n    /** Does the work of closing a file */\n    private void _fileClosed(OpenDefinitionsDocument doc) {\n//      assert EventQueue.isDispatchThread();\n      _recentDocFrame.closeDocument(doc);\n      _removeErrorListener(doc);\n      JScrollPane jsp = _defScrollPanes.get(doc);\n      if (jsp != null) {\n        ((DefinitionsPane)jsp.getViewport().getView()).close();\n        _defScrollPanes.remove(doc);\n      }\n      PropertyMaps.TEMPLATE.getProperty(\"DrJava\", \"drjava.all.files\").invalidate();\n    }\n    \n    public void fileReverted(OpenDefinitionsDocument doc) {\n      updateStatusField();\n      _saveAction.setEnabled(false);\n      _currentDefPane.resetUndo();\n      _currentDefPane.hasWarnedAboutModified(false);\n      _currentDefPane.setPositionAndScroll(0);\n      _updateDebugStatus();\n    }\n    \n    public void undoableEditHappened() {    \n      assert EventQueue.isDispatchThread();\n      _currentDefPane.getUndoAction().updateUndoState();\n      _currentDefPane.getRedoAction().updateRedoState();\n    }\n    \n    public void activeDocumentRefreshed(final OpenDefinitionsDocument active) {\n      assert EventQueue.isDispatchThread();\n//          System.err.println(\"activeDocumentRefreshed\");\n      _recentDocFrame.pokeDocument(active);\n      _refreshDefScrollPane();\n      \n      // Update error highlights\n      int pos = _currentDefPane.getCaretPosition();\n      _currentDefPane.getErrorCaretListener().updateHighlight(pos);\n      focusOnLastFocusOwner();\n    }\n    \n    public void activeDocumentChanged(final OpenDefinitionsDocument active) {\n      assert EventQueue.isDispatchThread();\n//      Utilities.show(\"MainFrame Listener: ActiveDocument changed to \" + active);\n      // code that accesses the GUI must run in the event-dispatching thread. \n      _recentDocFrame.pokeDocument(active);\n      _switchDefScrollPane();  // Updates _currentDefPane\n      \n      boolean isModified = active.isModifiedSinceSave();\n      boolean canCompile = (! isModified && ! active.isUntitled());\n      boolean hasName = ! active.isUntitled();\n      _saveAction.setEnabled(! canCompile);\n      _renameAction.setEnabled(hasName);\n      _revertAction.setEnabled(hasName);\n      \n      // Update error highlights\n      int pos = _currentDefPane.getCaretPosition();\n      _currentDefPane.getErrorCaretListener().updateHighlight(pos);\n      \n      // Update FileChoosers' directory\n      _setCurrentDirectory(active);\n      \n      // Update title and position\n      updateStatusField();\n      _posListener.updateLocation();\n      \n      // update display (adding \"*\") in navigatgorPane\n      if (isModified) _model.getDocumentNavigator().repaint();\n      \n      try { active.revertIfModifiedOnDisk(); }\n      catch (FileMovedException fme) { _showFileMovedError(fme); }\n      catch (IOException e) { MainFrameStatics.showIOError(MainFrame.this, e); }\n      \n      // Change Find/Replace to the new defpane\n      if (isDisplayed(_findReplace)) {\n        _findReplace.stopListening();\n        _findReplace.beginListeningTo(_currentDefPane);\n        //uninstallFindReplaceDialog(_findReplace);\n        //installFindReplaceDialog(_findReplace);\n      }\n//          _lastFocusOwner = _currentDefPane;\n      EventQueue.invokeLater(new Runnable() { \n        public void run() { \n          _lastFocusOwner = _currentDefPane;\n//            System.err.println(\"Requesting focus on new active document\");\n          _currentDefPane.requestFocusInWindow(); \n          PropertyMaps.TEMPLATE.getProperty(\"DrJava\",\"drjava.current.file\").invalidate();\n        } \n      });\n    }\n    \n    public void focusOnLastFocusOwner() {\n//      System.err.println(\"focusOnLastFocusOwner() called; _lastFocusOwner = \" + _lastFocusOwner);\n      _lastFocusOwner.requestFocusInWindow();\n    }\n    \n    /** Moves focus in MainFrame to the definitions pane. */\n    public void focusOnDefinitionsPane() {\n      _currentDefPane.requestFocusInWindow();\n    }\n    \n    public void interactionStarted() {\n      _interactionsPane.endCompoundEdit();\n      _disableInteractionsPane();\n      _guiAvailabilityNotifier.unavailable(GUIAvailabilityListener.ComponentType.INTERACTIONS);\n    }\n    \n    public void interactionEnded() {\n      assert EventQueue.isDispatchThread();\n      final InteractionsModel im = _model.getInteractionsModel();\n      final String lastError = im.getLastError();\n      final edu.rice.cs.drjava.config.FileConfiguration config = DrJava.getConfig();\n      if (config != null && config.getSetting(edu.rice.cs.drjava.config.OptionConstants.DIALOG_AUTOIMPORT_ENABLED)) {\n        if (lastError != null) {\n          // the interaction ended and there was an error\n          // check that this error is different than the last one (second to last may be null):\n          final String secondToLastError = im.getSecondToLastError();\n          if (secondToLastError != null || ! lastError.equals(secondToLastError)) {\n            // this aborts the auto-importing if the same class comes up twice in a row\n            if (lastError.startsWith(\"Static Error: Undefined class '\") && lastError.endsWith(\"'\")) {\n              // it was an \"undefined class\" exception\n              // show auto-import dialog\n              String undefinedClassName = lastError.substring(lastError.indexOf('\\'') + 1, lastError.lastIndexOf('\\''));\n              _showAutoImportDialog(undefinedClassName);\n            }\n            else if (lastError.startsWith(\"Static Error: Undefined name '\") && lastError.endsWith(\"'\")) {\n              // it was an \"undefined name\" exception\n              String undefinedName = lastError.substring(lastError.indexOf('\\'') + 1, lastError.lastIndexOf('\\''));\n              \n              if ((undefinedName.length() > 0) &&\n                  (Character.isUpperCase(undefinedName.charAt(0))) &&\n                  (undefinedName.indexOf('.') >= 0)) {\n                // the undefined name starts with a capital letter and contains a dot\n                // show auto-import dialog\n                String undefinedClassName = undefinedName.substring(0, undefinedName.indexOf('.'));\n                _showAutoImportDialog(undefinedClassName);\n              }\n            }\n            else if (lastError.startsWith(\"java.lang.OutOfMemoryError\")) {\n              askToIncreaseSlaveMaxHeap();\n            }\n          }\n        }\n      }\n      else im.resetLastErrors(); // reset the last errors, so the dialog works again if it is re-enabled\n      _enableInteractionsPane();\n      _guiAvailabilityNotifier.available(GUIAvailabilityListener.ComponentType.INTERACTIONS);\n      _interactionsPane.discardUndoEdits();\n      \n    }\n    \n    public void interactionErrorOccurred(final int offset, final int length) {\n      _interactionsPane.highlightError(offset, length); \n    }\n    \n    /** Called when the active interpreter is changed.\n      * @param inProgress Whether the new interpreter is currently in progress with an interaction (i.e., whether an \n      *        interactionEnded event will be fired)\n      */\n    public void interpreterChanged(final boolean inProgress) {\n      _guiAvailabilityNotifier.availabilityChanged(GUIAvailabilityListener.ComponentType.INTERACTIONS, !inProgress);\n      if (inProgress) _disableInteractionsPane();\n      else _enableInteractionsPane();\n    }\n    \n    public void compileStarted() {\n      assert EventQueue.isDispatchThread();\n      _guiAvailabilityNotifier.unavailable(GUIAvailabilityListener.ComponentType.COMPILER);      \n      showTab(_compilerErrorPanel, true);\n      _compilerErrorPanel.setCompilationInProgress();\n      _saveAction.setEnabled(false);\n    }    \n    \n    public void compileEnded(File workDir, final List<? extends File> excludedFiles) {\n      assert EventQueue.isDispatchThread();    \n      \n      _guiAvailabilityNotifier.available(GUIAvailabilityListener.ComponentType.COMPILER);\n      \n      _compilerErrorPanel.reset(excludedFiles.toArray(new File[0]));\n      if (isDebuggerReady()) {\n//              _model.getActiveDocument().checkIfClassFileInSync();\n        \n        _updateDebugStatus();\n      }\n      if ((DrJava.getConfig().getSetting(DIALOG_COMPLETE_SCAN_CLASS_FILES).booleanValue()) && \n          (_model.getBuildDirectory() != null)) {\n        _scanClassFiles();\n      }\n      if (_junitPanel.isDisplayed()) _resetJUnit();\n      _model.refreshActiveDocument();\n    }\n    \n    /** Called if a compilation is aborted. */\n    public void compileAborted(Exception e) {\n      /* Should probably display a simple popup */\n      _guiAvailabilityNotifier.available(GUIAvailabilityListener.ComponentType.COMPILER);      \n    }\n    \n    /** Called after the active compiler has been changed. */\n    public void activeCompilerChanged() {\n      String linkVersion = DrJava.getConfig().getSetting(JAVADOC_API_REF_VERSION);\n      if (linkVersion.equals(JAVADOC_AUTO_TEXT)) {\n        // The Java API Javadoc version must match the compiler.  Since compiler was changed, we rebuild the API list\n        clearJavaAPISet();\n      }\n    }\n    \n    public void prepareForRun(final OpenDefinitionsDocument doc) {\n      // Only change GUI from event-dispatching AbstractDJDocument\n      assert EventQueue.isDispatchThread();\n      \n      // Switch to the interactions pane to show results.\n      showTab(_interactionsContainer, true);\n      _lastFocusOwner = _interactionsContainer;\n    }\n    \n    /** Only runs in event thread. */\n    public void junitStarted() {\n      assert EventQueue.isDispatchThread();\n      /* Note: hourglassOn() is done by various junit commands (other than junitClasses); hourglass must be off \n       * for actual testing; the balancing simpleHourglassOff() is located here and in nonTestCase */\n      \n      try { showTab(_junitPanel, true);\n        _junitPanel.setJUnitInProgress();\n      }\n      finally { \n//        Utilities.show(\"Turning hourglassOff\");\n        hourglassOff();\n      }  \n    }\n    \n    /** We are junit'ing a specific list of classes given their source files. */\n    public void junitClassesStarted() {\n      assert EventQueue.isDispatchThread();\n      // Only change GUI from event-dispatching thread\n      // new ScrollableDialog(null, \"junitClassesStarted called in MainFrame\", \"\", \"\").show();\n      showTab(_junitPanel, true);\n      _junitPanel.setJUnitInProgress();\n    }\n    \n    //public void junitRunning() { }\n    \n    public void junitSuiteStarted(final int numTests) {\n      assert EventQueue.isDispatchThread();\n      _junitPanel.progressReset(numTests);\n    }\n    \n    public void junitTestStarted(final String name) {\n      assert EventQueue.isDispatchThread();\n      _junitPanel.getErrorListPane().testStarted(name); /* this does nothing! */         \n    }\n    \n    public void junitTestEnded(final String name, final boolean succeeded, final boolean causedError) {\n      assert EventQueue.isDispatchThread();\n//      new ScrollableDialog(null, \"junitTestEnded(\" + name + \", \" + succeeded + \", \" + causedError + \")\", \"\", \"\").\n//        show();\n      _junitPanel.getErrorListPane().testEnded(name, succeeded, causedError);  // What does this do?\n      _junitPanel.progressStep(succeeded);\n      _model.refreshActiveDocument();\n    }\n    \n    public void junitEnded() {\n      assert EventQueue.isDispatchThread();\n//      new ScrollableDialog(null, \"MainFrame.junitEnded() called\", \"\", \"\").show();\n      _guiAvailabilityNotifier.junitFinished(); // JUNIT and COMPILER\n      // Use EventQueue invokeLater to ensure that JUnit panel is \"reset\" after it is updated with test results\n      EventQueue.invokeLater(new Runnable() { public void run() { _junitPanel.reset(); } });\n      _model.refreshActiveDocument();\n    }\n    \n    /** Fire just before javadoc asynchronous thread is started. Only runs in the event thread. */\n    public void javadocStarted() {\n      \n      assert EventQueue.isDispatchThread();\n      \n      hourglassOn();\n      _guiAvailabilityNotifier.javadocStarted(); // JAVADOC and COMPILER\n\n      showTab(_javadocErrorPanel, true);\n      _javadocErrorPanel.setJavadocInProgress();\n    }\n    \n    public void javadocEnded(final boolean success, final File destDir, final boolean allDocs) {\n      // Only change GUI from event-dispatching thread\n      assert EventQueue.isDispatchThread();\n      // Utilities.showDebug(\"javadocEnded: success=\"+success);\n      try {\n        _javadocErrorPanel.getErrorListPane().setJavadocEnded(success);\n        showTab(_javadocErrorPanel, true);\n        _javadocErrorPanel.reset();\n        _model.refreshActiveDocument();\n      }\n      finally {\n        _guiAvailabilityNotifier.javadocFinished(); // JAVADOC and COMPILER\n        hourglassOff();\n      }\n      \n      // Display the results.\n      if (success) {\n        String className;\n        try {\n          className = _model.getActiveDocument().getQualifiedClassName();\n          className = className.replace('.', File.separatorChar);\n        }\n        catch (ClassNameNotFoundException cnf) {\n          // If there is no class name, pass the empty string as a flag.  We don't want to blow up here.\n          className = \"\";\n        }\n        try {\n          String fileName = (allDocs || className.equals(\"\")) ? \"index.html\" : (className + \".html\");\n          File index = new File(destDir, fileName);\n          URL address = FileOps.toURL(index.getAbsoluteFile());\n          \n          if (! PlatformFactory.ONLY.openURL(address)) {\n            JavadocFrame _javadocFrame = new JavadocFrame(destDir, className, allDocs);\n            _javadocFrame.setVisible(true);\n          }\n        }\n        catch (MalformedURLException me) { throw new UnexpectedException(me); }\n        catch (IllegalStateException ise) {\n          // JavadocFrame couldn't find any output files!\n          // Display a message.\n          String msg =\n            \"Javadoc completed successfully, but did not produce any HTML files.\\n\" +\n            \"Please ensure that your access level in Preferences is appropriate.\";\n          JOptionPane.showMessageDialog(MainFrame.this, msg,\n                                        \"No output to display.\",\n                                        JOptionPane.INFORMATION_MESSAGE);\n        }\n      }\n    }\n    \n    public void interpreterExited(final int status) {\n      // Only show prompt if option is set and not in TEST_MODE\n      if (DrJava.getConfig().getSetting(INTERACTIONS_EXIT_PROMPT).booleanValue() && ! Utilities.TEST_MODE && \n          MainFrame.this.isVisible()) {\n        // Synchronously pop up a dialog box concerning restarting the JVM.\n        String msg = \"The interactions window was terminated by a call \" +\n          \"to System.exit(\" + status + \").\\n\" +\n          \"The interactions window will now be restarted.\";\n        \n        String title = \"Interactions terminated by System.exit(\" + status + \")\";\n        \n        ConfirmCheckBoxDialog dialog =\n          new ConfirmCheckBoxDialog(MainFrame.this, title, msg,\n                                    \"Do not show this message again\",\n                                    JOptionPane.INFORMATION_MESSAGE,\n                                    JOptionPane.DEFAULT_OPTION);\n        if (dialog.show() == JOptionPane.OK_OPTION && dialog.getCheckBoxValue()) {\n          DrJava.getConfig().setSetting(INTERACTIONS_EXIT_PROMPT, Boolean.FALSE);\n        }\n      }\n    }\n    \n    public void interpreterResetFailed(Throwable t) { interpreterReady(FileOps.NULL_FILE); }\n    \n    public void interpreterResetting() {\n      assert duringInit() || EventQueue.isDispatchThread();\n      _guiAvailabilityNotifier.unavailable(GUIAvailabilityListener.ComponentType.INTERACTIONS);\n      _closeInteractionsScript();\n      _interactionsPane.setEditable(false);\n      _interactionsPane.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n    }\n    \n    public void interpreterReady(File wd) {\n      assert duringInit() || EventQueue.isDispatchThread();\n      \n      interactionEnded();\n      _guiAvailabilityNotifier.available(GUIAvailabilityListener.ComponentType.INTERACTIONS);\n      \n      /* This line was moved here from interpreterResetting because it was possible to get an InputBox in \n       * InteractionsController between interpreterResetting and interpreterReady. Fixes bug #917054 \n       * \"Interactions Reset Bug\". */\n      _interactionsController.interruptConsoleInput();\n    }\n    \n    public void consoleReset() { }\n    \n    public void saveBeforeCompile() {\n      assert EventQueue.isDispatchThread();\n      // The following event thread switch supports legacy test code that calls compile methods outside of the\n      // event thread.  The wait is necessary because compilation process cannot proceed until saving is complete.\n      _saveAllBeforeProceeding\n        (\"To compile, you must first save ALL modified files.\\n\" + \"Would you like to save and then compile?\",\n         ALWAYS_SAVE_BEFORE_COMPILE,\n         \"Always save before compiling\");\n    }\n    \n    /** Compile all open source files if this option is configured or running as a unit test.  Otherwise, pop up a\n      * dialog to ask if all open source files should be compiled in order to test the program. \n      */\n    public void compileBeforeJUnit(final CompilerListener testAfterCompile, List<OpenDefinitionsDocument> outOfSync) {\n//      System.err.println(\"in compileBeforeJUnit, TEST_MODE = \" + Utilities.TEST_MODE);\n      if (DrJava.getConfig().getSetting(ALWAYS_COMPILE_BEFORE_JUNIT).booleanValue() || Utilities.TEST_MODE) {\n        // Compile all open source files\n        _model.getCompilerModel().addListener(testAfterCompile);  // listener removes itself\n        _compileAll();\n      }\n      else { // pop up a window to ask if all open files should be compiled before testing        \n        final JButton yesButton = new JButton(new AbstractAction(\"Yes\") {\n          public void actionPerformed(ActionEvent e) {\n            // compile all open source files and test\n            _model.getCompilerModel().addListener(testAfterCompile);  // listener removes itself\n            _compileAll();\n          }\n        });\n        final JButton noButton = new JButton(new AbstractAction(\"No\") {\n          public void actionPerformed(ActionEvent e) {\n            // abort unit testing\n            // _model.getJUnitModel().nonTestCase(true);  // cleans up\n            _junitInterrupted(\"Unit testing cancelled by user.\");\n          }\n        });\n        ScrollableListDialog<OpenDefinitionsDocument> dialog = \n          new ScrollableListDialog.Builder<OpenDefinitionsDocument>()\n          .setOwner(MainFrame.this)\n          .setTitle(\"Must Compile All Source Files to Run Unit Tests\")\n          .setText(\"<html>Before you can run unit tests, you must first compile all out of sync source files.<br>\"+\n                   \"The files below are out of sync. Would you like to compile all files and<br>\"+\n                   \"run the specified test(s)?\")\n          .setItems(outOfSync)\n          .setMessageType(JOptionPane.QUESTION_MESSAGE)\n          .setFitToScreen(true)\n          .clearButtons()\n          .addButton(yesButton)\n          .addButton(noButton)\n          .build();\n        \n        dialog.showDialog();\n      }\n    }\n    \n    public void saveBeforeJavadoc() {\n      _saveAllBeforeProceeding\n        (\"To run Javadoc, you must first save ALL modified files.\\n\" +\n         \"Would you like to save and then run Javadoc?\", ALWAYS_SAVE_BEFORE_JAVADOC,\n         \"Always save before running Javadoc\");\n    }\n    \n    /** Helper method shared by all \"saveBeforeX\" methods.  In JUnit tests, YES option is automatically selected\n      * @param message a prompt message to be displayed to the user\n      * @param option the BooleanOption for the prompt dialog checkbox\n      * @param checkMsg the description of the checkbox (\"Always save before X\")\n      */\n    private void _saveAllBeforeProceeding(String message, BooleanOption option, String checkMsg) {\n//      new ScrollableDialog(null, \"saveBeforeProceeding called in MainFrame\", \"\", \"\").show();\n      if (_model.hasModifiedDocuments()) {\n        if (! DrJava.getConfig().getSetting(option).booleanValue() && ! Utilities.TEST_MODE) {\n          ConfirmCheckBoxDialog dialog =\n            new ConfirmCheckBoxDialog(MainFrame.this, \"Must Save All Files to Continue\", message, checkMsg);\n          int rc = dialog.show();\n          \n          switch (rc) {\n            case JOptionPane.YES_OPTION:\n              _saveAll();\n              // Only remember checkbox if they say yes\n              if (dialog.getCheckBoxValue())  DrJava.getConfig().setSetting(option, Boolean.TRUE);\n              break;\n            case JOptionPane.NO_OPTION:\n            case JOptionPane.CANCEL_OPTION:\n            case JOptionPane.CLOSED_OPTION:\n              // do nothing\n              break;\n            default:\n              throw new RuntimeException(\"Invalid rc from showConfirmDialog: \" + rc);\n          }\n        }\n        else _saveAll();\n      }\n    }\n\n    public void compileBeforeJavadoc(final CompilerListener afterCompile) {\n      // Utilities.showDebug(\"compileBeforeJavadoc\");\n      _compileBeforeProceeding\n        (\"To run Javadoc, you must first compile all files.\\n\" +\n         \"Would you like to compile and then run Javadoc?\", ALWAYS_COMPILE_BEFORE_JAVADOC,\n         \"Always save before running Javadoc\", afterCompile);\n    }    \n    \n    /** Helper method shared by all \"compileBeforeX\" methods.\n      * @param message a prompt message to be displayed to the user\n      * @param option the BooleanOption for the prompt dialog checkbox\n      * @param checkMsg the description of the checkbox (\"Always compile before X\")\n      */\n    private void _compileBeforeProceeding(String message, BooleanOption option, String checkMsg,\n                                          final CompilerListener afterCompile) {\n//      new ScrollableDialog(null, \"saveBeforeProceeding called in MainFrame\", \"\", \"\").show();\n      if (_model.hasOutOfSyncDocuments()) {\n        if (! DrJava.getConfig().getSetting(option).booleanValue() && ! Utilities.TEST_MODE) {\n          ConfirmCheckBoxDialog dialog =\n            new ConfirmCheckBoxDialog(MainFrame.this, \"Must Compile Files to Continue\", message, checkMsg);\n          int rc = dialog.show();\n          \n          switch (rc) {\n            case JOptionPane.YES_OPTION:\n              _model.getCompilerModel().addListener(afterCompile);  // listener removes itself\n              _compileAll();\n              // Only remember checkbox if they say yes\n              if (dialog.getCheckBoxValue())  DrJava.getConfig().setSetting(option, Boolean.TRUE);\n              break;\n            case JOptionPane.NO_OPTION:\n            case JOptionPane.CANCEL_OPTION:\n            case JOptionPane.CLOSED_OPTION:\n              afterCompile.compileAborted(new RuntimeException(\"Not compiled.\"));\n              break;\n            default:\n              throw new RuntimeException(\"Invalid rc from showConfirmDialog: \" + rc);\n          }\n        }\n        else {\n          _model.getCompilerModel().addListener(afterCompile);  // listener removes itself\n          _compileAll();\n        }\n      }\n    }\n    \n    /** Saves the active document which is untitled. */\n    public void saveUntitled() { _saveAs(); }\n    \n    public void filePathContainsPound() {\n      if (DrJava.getConfig().getSetting(WARN_PATH_CONTAINS_POUND).booleanValue()) {\n        String msg =\n          \"Files whose paths contain the '#' symbol cannot be used in the\\n\" +\n          \"Interactions Pane due to a bug in Java's file to URL conversion.\\n\" +\n          \"It is suggested that you change the name of the directory\\n\" +\n          \"containing the '#' symbol.\";\n        \n        String title = \"Path Contains Pound Sign\";\n        \n        ConfirmCheckBoxDialog dialog =\n          new ConfirmCheckBoxDialog(MainFrame.this, title, msg,\n                                    \"Do not show this message again\",\n                                    JOptionPane.WARNING_MESSAGE,\n                                    JOptionPane.DEFAULT_OPTION);\n        if (dialog.show() == JOptionPane.OK_OPTION && dialog.getCheckBoxValue()) {\n          DrJava.getConfig().setSetting(WARN_PATH_CONTAINS_POUND, Boolean.FALSE);\n        }\n      }\n    }\n    \n    /** Event that is fired with there is nothing to test.  JUnit is never started. */ \n    public void nonTestCase(boolean isTestAll, boolean didCompileFail) {\n      assert EventQueue.isDispatchThread();\n      \n//      Utilities.showStackTrace(new UnexpectedException(\"We should not have called nonTestCase\"));\n      String message;\n      String title = \"Cannot Run JUnit Test Cases\";\n      if (didCompileFail) {\n        message = \"Compile failed. Cannot run JUnit TestCases.\\n\" +\n          \"Please examine the Compiler Output.\";\n      }\n      else {        \n        if (isTestAll) {\n          message = \"There are no compiled JUnit TestCases available for execution.\\n\" +\n            \"Perhaps you have not yet saved and compiled your test files.\";\n        }\n        else {\n          message = \"The current document is not a valid JUnit test case.\\n\" +\n            \"Please make sure that:\\n\" +\n            \"- it has been compiled and\\n\" +\n            \"- it is a subclass of junit.framework.TestCase.\\n\";\n        }\n      }\n      JOptionPane.showMessageDialog(MainFrame.this, message,\n                                    title,\n                                    JOptionPane.ERROR_MESSAGE);\n      // clean up as in JUnitEnded \n      try {\n        if (!didCompileFail) showTab(_junitPanel, true);\n        _resetJUnit();\n      }\n      finally { \n        hourglassOff();\n        _guiAvailabilityNotifier.junitFinished(); // JUNIT and COMPILER\n      }\n    }\n    \n    /** Event that is fired when testing encounters an illegal class file.  JUnit is never started. */ \n    public void classFileError(ClassFileError e) {\n      \n      assert EventQueue.isDispatchThread();\n      \n      final String message = \n        \"The class file for class \" + e.getClassName() + \" in source file \" + e.getCanonicalPath() + \n        \" cannot be loaded.\\n \"\n        + \"When DrJava tries to load it, the following error is generated:\\n\" +  e.getError();\n      \n      JOptionPane.showMessageDialog(MainFrame.this, message,\n                                    \"Testing works only on valid class files\",\n                                    JOptionPane.ERROR_MESSAGE);\n      // clean up as junitEnded except hourglassOff (should factored into a private method)\n      showTab(_junitPanel, true);\n      _guiAvailabilityNotifier.junitFinished(); // JUNIT and COMPILER\n      _junitPanel.reset();\n    }\n    \n    /** Only callable from within the event-handling thread */\n    public void currentDirectoryChanged(final File dir) { _setCurrentDirectory(dir); }\n    \n    /** Check if the specified document has been modified. If it has, ask the user if he would like to save it \n      * and save the document if yes. Also give the user a \"cancel\" option to cancel doing the operation \n      * that got us here in the first place.\n      *\n      * @return A boolean indicating whether the user cancelled the save process.  False means cancel.\n      */\n    public boolean canAbandonFile(OpenDefinitionsDocument doc) {\n      return _fileSaveHelper(doc, JOptionPane.YES_NO_CANCEL_OPTION);\n    }\n    \n    private boolean _fileSaveHelper(OpenDefinitionsDocument doc, int paneOption) {\n      String text,fname;\n      OpenDefinitionsDocument lastActive = _model.getActiveDocument();\n      if (lastActive != doc) _model.setActiveDocument(doc);\n      \n      boolean notFound = false;\n      try {\n        File file = doc.getFile();\n        if (file == null) {\n          fname = \"Untitled file\";\n          text = \"Untitled file has been modified. Would you like to save it?\";\n        }\n        else {\n          fname = file.getName();\n          text = fname + \" has been modified. Would you like to save it?\";\n        }\n      }\n      catch (FileMovedException fme) {\n        // File was deleted, but use the same name anyway\n        fname = fme.getFile().getName();\n        text = fname + \" not found on disk. Would you like to save to another file?\";\n        notFound = true;\n      }\n      \n      int rc = JOptionPane.showConfirmDialog(MainFrame.this, text, \"Save \" + fname + \"?\", paneOption);\n      switch (rc) {\n        case JOptionPane.YES_OPTION:\n          boolean saved = false;\n          if (notFound) saved = _saveAs(); \n          else saved = _save();\n          if (doc != lastActive) {\n            _model.setActiveDocument(lastActive);  // breaks when \"if\" clause omitted\n          }\n          return saved;\n        case JOptionPane.NO_OPTION:\n          if (doc != lastActive) {\n          _model.setActiveDocument(lastActive);  // breaks when \"if\" clause omitted\n        }\n          return true;\n        case JOptionPane.CLOSED_OPTION:\n        case JOptionPane.CANCEL_OPTION:\n          return false;\n        default:                         // never executed\n          throw new RuntimeException(\"Invalid option: \" + rc);\n      }\n    }\n    \n    /** Check if the current document has been modified. If it has, ask the user if he would like to save it \n      * and save the document if yes.\n      * @return true if quitting should continue, false if the user cancelled\n      */\n    public boolean quitFile(OpenDefinitionsDocument doc) { \n      return _fileSaveHelper(doc, JOptionPane.YES_NO_CANCEL_OPTION); \n    }\n    \n    /** Called to ask the listener if it is OK to revert the current document to a newer version saved on file. */\n    public boolean shouldRevertFile(OpenDefinitionsDocument doc) {\n      String fname;\n      if (! _model.getActiveDocument().equals(doc)) {\n        _model.setActiveDocument(doc);\n      }\n      try {\n        File file = doc.getFile();\n        if (file == null) fname = \"Untitled file\";\n        else fname = file.getName();\n      }\n      catch (FileMovedException fme) { fname = fme.getFile().getName(); } // File was deleted, but use same name anyway\n      \n      String text = fname + \" has changed on disk.\\n\" + \n        \"Would you like to reload it and discard any changes you have made?\";\n      String[] options = { \"Reload from disk\", \"Keep my changes\" };\n      int rc = JOptionPane.showOptionDialog(MainFrame.this, text, fname + \" Modified on Disk\", \n                                            JOptionPane.DEFAULT_OPTION, JOptionPane.QUESTION_MESSAGE,\n                                            null, options, options[0]);\n      switch (rc) {\n        case 0:                         return true;\n        case 1:                         return false;\n        case JOptionPane.CLOSED_OPTION:\n        case JOptionPane.CANCEL_OPTION: return false;\n        default:                        throw new RuntimeException(\"Invalid rc: \" + rc);\n      }\n    }\n    \n    public void interactionIncomplete() { }\n    \n    /* Changes to the state */\n    \n    public void projectBuildDirChanged() {\n      _guiAvailabilityNotifier.ensureAvailabilityIs(GUIAvailabilityListener.ComponentType.PROJECT_BUILD_DIR,\n                                                    isProjectActiveAndBuildDirSet());\n    }\n    \n    public void projectWorkDirChanged() { }\n    \n    public void projectModified() {\n//      _saveProjectAction.setEnabled(_model.isProjectChanged());\n    }\n    \n    public void projectClosed() {\n      _model.getDocumentNavigator().asContainer().addKeyListener(_historyListener);\n      _model.getDocumentNavigator().asContainer().addFocusListener(_focusListenerForRecentDocs);\n      _model.getDocumentNavigator().asContainer().addMouseListener(_resetFindReplaceListener);\n//      new ScrollableDialog(null, \"Closing JUnit Error Panel in MainFrame\", \"\", \"\").show();\n      removeTab(_junitPanel);\n      _runButton = _updateToolbarButton(_runButton, _runAction);\n      _compileButton = _updateToolbarButton(_compileButton, _compileAllAction);\n      _junitButton = _updateToolbarButton(_junitButton, _junitAllAction);\n      projectRunnableChanged();\n    }\n    \n    public void allFilesClosed() {\n      _compilerErrorPanel._close();\n      _junitPanel._close();\n      _javadocErrorPanel._close();\n      _model.resetConsole();\n    }\n    \n    /* Opens project from command line. */\n    public void openProject(File projectFile, FileOpenSelector files) {\n      _setUpContextMenus();\n      projectRunnableChanged();\n      _setUpProjectButtons(projectFile);\n      open(files);\n      _openProjectUpdate();\n    }\n    \n    public void projectRunnableChanged() {\n      MainFrame.this.projectRunnableChanged();\n    }\n    \n    public void documentNotFound(OpenDefinitionsDocument d, File f) {\n      \n      _model.setProjectChanged(true);\n      \n      String text = \"File \" + f.getAbsolutePath() +\n        \"\\ncould not be found on disk!  It was probably moved\\n\" +\n        \"or deleted.  Would you like to try to find it?\";\n      \n      int rc = JOptionPane.showConfirmDialog(MainFrame.this, text, \"File Moved or Deleted\", JOptionPane.YES_NO_OPTION);\n      \n      if (rc == JOptionPane.NO_OPTION) return;\n      if (rc == JOptionPane.YES_OPTION) {\n        try {\n          File[] opened = _openSelector.getFiles(); \n          d.setFile(opened[0]);\n        } \n        catch(OperationCanceledException oce) {\n          // Interpret cancelled as \"NO\"\n        }\n      }\n// The following line was commented out because it breaks when a user want to close but not save a deleted file      \n//      else throw new DocumentClosedException(d,\"Document in \" + f + \"closed unexpectedly\");  // misnamed exception\n    }\n    \n    public void browserChanged() { _configureBrowsing(); }\n    \n    public void updateCurrentLocationInDoc() {\n//      MFLOG.log(\"updateCurrentLocationInDoc in MainFrame\");\n      if (_currentDefPane != null) { _currentDefPane.updateCurrentLocationInDoc(); }\n    }\n  } // End of ModelListener class\n  \n  public void projectRunnableChanged() {\n    boolean mainClassSet = isProjectActiveAndMainClassSet();\n    _guiAvailabilityNotifier.ensureAvailabilityIs(GUIAvailabilityListener.ComponentType.PROJECT_MAIN_CLASS,\n                                                  mainClassSet);\n    if (mainClassSet) {\n      _runButton = _updateToolbarButton(_runButton, _runProjectAction);\n    }\n    else {\n      _runButton = _updateToolbarButton(_runButton, _runAction);\n    }\n  }\n  \n//  public static final edu.rice.cs.util.Log MFLOG = new edu.rice.cs.util.Log(\"mflog.txt\",true); \n  \n  public JViewport getDefViewport() {\n    OpenDefinitionsDocument doc = _model.getActiveDocument();\n//    new ScrollableDialog(null, \"Active Document is \" + doc, \"\", \"\").show();\n    JScrollPane defScroll = _defScrollPanes.get(doc);\n    return defScroll.getViewport();\n  }\n  \n  public void removeTab(final Component c) {\n    \n    if (_tabbedPane.getTabCount() > 1) {\n//      if (_tabbedPane.getSelectedIndex() == _tabbedPane.getTabCount() - 1)\n//        _tabbedPane.setSelectedIndex(_tabbedPane.getSelectedIndex() - 1);\n      \n      _tabbedPane.remove(c);\n      ((TabbedPanel)c).setDisplayed(false);\n    }\n    _currentDefPane.requestFocusInWindow();\n  }\n  \n  /** Adds the bookmarks panel to the tabbed pane and shows it. */\n  public void showBookmarks() { showTab(_bookmarksPanel, true); }\n  \n  /** Adds the breakpoints panel to the tabbed pane and shows it. */\n  public void showBreakpoints() { showTab(_breakpointsPanel, true); }\n  \n  private void _createTab(TabbedPanel panel) {\n    int numVisible = 0;\n    for (TabbedPanel t: _tabs) {\n      if (t == panel) {\n        Icon icon = (panel instanceof FindResultsPanel) ? FIND_ICON : null;\n        _tabbedPane.insertTab(panel.getName(), icon, panel, null, numVisible + 2);  // interactions + console permanent\n        panel.setVisible(true);\n        panel.setDisplayed(true);\n        panel.repaint();\n        break;\n      }\n      else if (isDisplayed(t)) numVisible++;\n    }\n  }\n  \n  public static final Icon FIND_ICON = getIcon(\"Find16.gif\");\n  \n  /** Shows the components passed in the appropriate place in the tabbedPane depending on the position of\n    * the component in the _tabs list.  Only runs in the event thread.\n    * @param c the component to show in the tabbedPane\n    * @param showDetachedWindow true if the \"Detached Panes\" window should be shown\n    */\n  public void showTab(final Component c, boolean showDetachedWindow) {\n    // TODO: put all of the _tabbedPane components in _tabs. eliminating special cases for interactions, console (which \n    // are always displayed)\n    assert EventQueue.isDispatchThread();\n    try {\n      if (c instanceof TabbedPanel) _createTab((TabbedPanel) c);\n      if (c instanceof RegionsTreePanel<?>) {\n        RegionsTreePanel<?> p = (RegionsTreePanel<?>) c;\n        DefaultTreeModel model = p._regTreeModel;\n        // Update all JTree labels in p (equivalent to performing updateLines on p._regionManager with a [0,0] region)\n        model.reload(); \n        p.expandTree();\n        p.repaint();\n      }\n      \n      _tabbedPane.setSelectedComponent(c);\n      c.requestFocusInWindow();\n      \n      if (_mainSplit.getDividerLocation() > _mainSplit.getMaximumDividerLocation()) _mainSplit.resetToPreferredSizes();\n    }\n    finally {\n      if (showDetachedWindow && (_tabbedPanesFrame != null) && (_tabbedPanesFrame.isVisible())) { \n        _tabbedPanesFrame.toFront(); \n      }\n    }\n  }\n  \n  /** Warns the user that the current file is open and query them if they wish to save over the currently open file. */\n  private boolean _warnFileOpen(File f) {\n    OpenDefinitionsDocument d = null;\n    try { d = _model.getDocumentForFile(f); }\n    catch(IOException ioe) { /* do nothing */ }\n    Object[] options = {\"Yes\",\"No\"};\n    if (d == null) return false;\n    boolean dMod = d.isModifiedSinceSave();\n    String msg = \"This file is already open in DrJava\" + (dMod ? \" and has been modified\" : \"\") + \n      \".  Do you wish to overwrite it?\";\n    int choice = JOptionPane.showOptionDialog(MainFrame.this, msg, \"File Open Warning\", JOptionPane.YES_NO_OPTION,\n                                              JOptionPane.QUESTION_MESSAGE, null, options, options[1]);\n    if (choice == JOptionPane.YES_OPTION) return _model.closeFileWithoutPrompt(d);\n    return false;\n  }\n  \n  /** Confirms with the user that the file should be overwritten.\n    * @param f file to overwrite\n    * @return <code>true</code> iff the user accepts overwriting.\n    */\n  private boolean _verifyOverwrite(File f) {\n    return verifyOverwrite(MainFrame.this, f);\n  }\n  \n  /* Resets the JUnit functions in main frame. */\n  private void _resetJUnit() {\n    _junitPanel.reset();\n  }\n  \n  /* Pops up a message and cleans up after unit testing has been interrupted. */\n  private void _junitInterrupted(final UnexpectedException e) {\n    try {\n      MainFrameStatics.showJUnitInterrupted(MainFrame.this, e);\n      removeTab(_junitPanel);\n      _resetJUnit(); \n      _model.refreshActiveDocument();\n    }\n    finally {\n      hourglassOff();\n      _guiAvailabilityNotifier.junitFinished(); // JUNIT and COMPILER\n  }\n  }\n  \n  /* Pops up a message and cleans up after unit testing has been interrupted. */\n  private void _junitInterrupted(String message) {\n    try {\n      MainFrameStatics.showJUnitInterrupted(MainFrame.this, message);\n      removeTab(_junitPanel);\n      _resetJUnit(); \n      _model.refreshActiveDocument();\n    }\n    finally {\n      hourglassOff();\n      _guiAvailabilityNotifier.junitFinished(); // JUNIT and COMPILER\n    }\n  }\n  \n  boolean isDebuggerReady() { return _showDebugger &&  _model.getDebugger().isReady(); }\n  \n  public boolean isDebuggerEnabled() { return _showDebugger; }\n  \n  /** Return the find replace dialog. Package protected for use in tests. */\n  FindReplacePanel getFindReplaceDialog() { return _findReplace; }\n  \n  /** Builds the Hashtables in KeyBindingManager that record key-bindings and support live updating, conflict \n    * resolution, and intelligent error messages (the ActionToNameMap).  IMPORTANT: Don't use this mechanism to put\n    * an action into the KeyBindingManager if the action is a menu item because menu actions are already included.\n    * Putting in again will cause bug #803304 \"Uncomment lines wont rebind\".\n    */\n  private void _setUpKeyBindingMaps() {\n    final ActionMap actionMap = _currentDefPane.getActionMap();\n    final KeyBindingManager kbm = KeyBindingManager.ONLY;\n    \n    kbm.put(KEY_BACKWARD, actionMap.get(DefaultEditorKit.backwardAction), null, \"Cursor Backward\");\n    kbm.put(KEY_BACKWARD_SELECT, actionMap.get(DefaultEditorKit.selectionBackwardAction), null, \n            \"Cursor Backward (Select)\");\n    \n    kbm.put(KEY_BEGIN_DOCUMENT, actionMap.get(DefaultEditorKit.beginAction), null, \"Cursor Begin Document\");\n    kbm.put(KEY_BEGIN_DOCUMENT_SELECT, actionMap.get(DefaultEditorKit.selectionBeginAction), null, \n            \"Cursor Begin Document (Select)\");\n    \n    kbm.put(KEY_BEGIN_LINE, _beginLineAction, null, \"Cursor Begin Line\");\n    kbm.put(KEY_BEGIN_LINE_SELECT, _selectionBeginLineAction, null, \"Cursor Begin Line (Select)\");\n    \n    kbm.put(KEY_PREVIOUS_WORD, actionMap.get(_currentDefDoc.getEditor().previousWordAction), null, \n            \"Cursor Previous Word\");\n    kbm.put(KEY_PREVIOUS_WORD_SELECT, actionMap.get(_currentDefDoc.getEditor().selectionPreviousWordAction), null, \n            \"Cursor Previous Word (Select)\");\n    \n    kbm.put(KEY_DOWN, actionMap.get(DefaultEditorKit.downAction), null, \"Cursor Down\");\n    kbm.put(KEY_DOWN_SELECT, actionMap.get(DefaultEditorKit.selectionDownAction), null, \"Cursor Down (Select)\");\n    \n    kbm.put(KEY_END_DOCUMENT, actionMap.get(DefaultEditorKit.endAction), null, \"Cursor End Document\");\n    kbm.put(KEY_END_DOCUMENT_SELECT, actionMap.get(DefaultEditorKit.selectionEndAction), null, \n            \"Cursor End Document (Select)\");\n    \n    kbm.put(KEY_END_LINE, actionMap.get(DefaultEditorKit.endLineAction), null, \"Cursor End Line\");\n    kbm.put(KEY_END_LINE_SELECT, actionMap.get(DefaultEditorKit.selectionEndLineAction), null, \n            \"Cursor End Line (Select)\");\n    \n    kbm.put(KEY_NEXT_WORD, actionMap.get(_currentDefDoc.getEditor().nextWordAction), null, \"Cursor Next Word\");\n    kbm.put(KEY_NEXT_WORD_SELECT, actionMap.get(_currentDefDoc.getEditor().selectionNextWordAction), null, \n            \"Cursor Next Word (Select)\");\n    \n    kbm.put(KEY_FORWARD, actionMap.get(DefaultEditorKit.forwardAction), null, \"Cursor Forward\");\n    kbm.put(KEY_FORWARD_SELECT, actionMap.get(DefaultEditorKit.selectionForwardAction), null, \"Cursor Forward (Select)\");\n    \n    kbm.put(KEY_UP, actionMap.get(DefaultEditorKit.upAction), null, \"Cursor Up\");\n    kbm.put(KEY_UP_SELECT, actionMap.get(DefaultEditorKit.selectionUpAction), null, \"Cursor Up (Select)\");\n    \n//    kbm.put(KEY_NEXT_RECENT_DOCUMENT, _nextRecentDocAction, null, \"Next Recent Document\");\n//    kbm.put(KEY_PREV_RECENT_DOCUMENT, _prevRecentDocAction, null, \"Previous Recent Document\");\n    \n    // These last methods have no default selection methods\n    kbm.put(KEY_PAGE_DOWN, actionMap.get(DefaultEditorKit.pageDownAction), null, \"Cursor Page Down\");\n    kbm.put(KEY_PAGE_UP, actionMap.get(DefaultEditorKit.pageUpAction), null, \"Cursor Page Up\");\n    kbm.put(KEY_CUT_LINE, _cutLineAction, null, \"Cut Line\");\n    kbm.put(KEY_CLEAR_LINE, _clearLineAction, null, \"Clear Line\");\n    kbm.put(KEY_SHIFT_DELETE_PREVIOUS, actionMap.get(DefaultEditorKit.deletePrevCharAction), null, \"Delete Previous\");\n    kbm.put(KEY_SHIFT_DELETE_NEXT, actionMap.get(DefaultEditorKit.deleteNextCharAction), null, \"Delete Next\");\n  }\n  \n  /** @param listener The ComponentListener to add to the open documents list\n    * This method allows for testing of the dancing UI (See MainFrameTest.testDancingUI()).\n    */\n  public void addComponentListenerToOpenDocumentsList(ComponentListener listener) {\n    _docSplitPane.getLeftComponent().addComponentListener(listener);\n  }\n  \n  /**For test purposes only. Returns the text in the status bar. Is used to test brace matching*/\n  public String getFileNameField() { return _statusField.getText(); }\n  \n  /**For test purposes only. Returns the edit menu*/\n  public JMenu getEditMenu() { return _editMenu; }\n  \n  /** The OptionListener for FONT_MAIN */\n  private class MainFontOptionListener implements OptionListener<Font> {\n    public void optionChanged(OptionEvent<Font> oce) { _setMainFont(); }\n  }\n  \n  /** The OptionListener for FONT_LINE_NUMBERS */\n  private class LineNumbersFontOptionListener implements OptionListener<Font> {\n    public void optionChanged(OptionEvent<Font> oce) { _updateLineNums(); }\n  }\n  \n  /** The OptionListener for FONT_DOCLIST */\n  private class DoclistFontOptionListener implements OptionListener<Font> {\n    public void optionChanged(OptionEvent<Font> oce) {\n      Font doclistFont = DrJava.getConfig().getSetting(FONT_DOCLIST);\n      _model.getDocCollectionWidget().setFont(doclistFont);\n    }\n  }\n  \n  /** The OptionListener for FONT_TOOLBAR */\n  private class ToolbarFontOptionListener implements OptionListener<Font> {\n    public void optionChanged(OptionEvent<Font> oce) { _updateToolbarButtons(); }\n  }\n  \n  /** The OptionListener for DEFINITIONS_NORMAL_COLOR */\n  private class NormalColorOptionListener implements OptionListener<Color> {\n    public void optionChanged(OptionEvent<Color> oce) { _updateNormalColor(); }\n  }\n  \n  /** The OptionListener for DEFINITIONS_BACKGROUND_COLOR */\n  private class BackgroundColorOptionListener implements OptionListener<Color> {\n    public void optionChanged(OptionEvent<Color> oce) { _updateBackgroundColor(); }\n  }\n  \n  /** The OptionListener for TOOLBAR options */\n  private class ToolbarOptionListener implements OptionListener<Boolean> {\n    public void optionChanged(OptionEvent<Boolean> oce) { _updateToolbarButtons(); }\n  }\n  \n  /** The OptionListener for LINEENUM_ENABLED. */\n  private class LineEnumOptionListener implements OptionListener<Boolean> {\n    public void optionChanged(OptionEvent<Boolean> oce) { _updateDefScrollRowHeader(); }\n  }\n  \n  /** The OptionListener for DEFINITIONS_LINE_NUMBER_COLOR and DEFINITIONS_LINE_NUMBER_BACKGROUND_COLOR. */\n  private class LineEnumColorOptionListener implements OptionListener<Color> {\n    public void optionChanged(OptionEvent<Color> oce) { _updateLineNums(); }\n  }\n  \n  /** The OptionListener for QUIT_PROMPT. */\n  private class QuitPromptOptionListener implements OptionListener<Boolean> {\n    public void optionChanged(OptionEvent<Boolean> oce) { _promptBeforeQuit = oce.value.booleanValue(); }\n  }\n  \n  /** The OptionListener for RECENT_FILES_MAX_SIZE. */\n  private class RecentFilesOptionListener implements OptionListener<Integer> {\n    public void optionChanged(OptionEvent<Integer> oce) {\n      _recentFileManager.updateMax(oce.value.intValue());\n      _recentFileManager.numberItems();\n      _recentProjectManager.updateMax(oce.value.intValue());\n      _recentProjectManager.numberItems();\n    }\n  }\n  \n  private class LastFocusListener extends FocusAdapter {\n    public void focusGained(FocusEvent e) { \n      _lastFocusOwner = e.getComponent(); \n//      System.err.println(\"_lastFocusOwner = \" + _lastFocusOwner);\n    }\n  };\n  \n  \n  /** Wrapper for setPopupLoc(Window, Component) that uses the window's owner as the owner to center the popup on.\n    * @param popup the Popup window\n    */\n  public void setPopupLoc(Window popup) {\n    Utilities.setPopupLoc(popup, (popup.getOwner() != null) ? popup.getOwner() : this);\n  }\n  \n  /** Drag and drop target. */\n  DropTarget dropTarget = new DropTarget(this, this);\n  \n  /** Linux URI drag-and-drop data flavor. */\n  private static DataFlavor uriListFlavor;\n  static {\n    try { uriListFlavor = new DataFlavor(\"text/uri-list;class=java.lang.String\"); }\n    catch(ClassNotFoundException cnfe) { uriListFlavor = null; }\n  }\n  \n  /** User dragged something into the component. */\n  public void dragEnter(DropTargetDragEvent dropTargetDragEvent)\n  {\n    dropTargetDragEvent.acceptDrag(DnDConstants.ACTION_COPY_OR_MOVE);\n  }\n  \n  public void dragExit(DropTargetEvent dropTargetEvent) {}\n  public void dragOver(DropTargetDragEvent dropTargetDragEvent) {}\n  public void dropActionChanged(DropTargetDragEvent dropTargetDragEvent){}\n  \n  /** User dropped something on the component. */\n  public /* synchronized */ void drop(DropTargetDropEvent dropTargetDropEvent) {\n    assert EventQueue.isDispatchThread();\n    try {\n      Transferable tr = dropTargetDropEvent.getTransferable();\n      if (tr.isDataFlavorSupported(DataFlavor.javaFileListFlavor) ||\n          ((uriListFlavor != null) && (tr.isDataFlavorSupported(uriListFlavor)))) {\n        dropTargetDropEvent.acceptDrop(DnDConstants.ACTION_COPY_OR_MOVE);\n        List<File> fileList;\n        if (tr.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {\n          @SuppressWarnings(\"unchecked\")\n          List<File> data = (List<File>) tr.getTransferData(DataFlavor.javaFileListFlavor);\n          fileList = data;\n        }\n        else {\n          // work-around for Linux drag-and-drop; see Java bug 4899516\n          String data = (String) tr.getTransferData(uriListFlavor);\n          fileList = textURIListToFileList(data);\n        }\n        java.util.Iterator<File> iterator = fileList.iterator();\n        List<File> filteredFileList = new java.util.ArrayList<File>();\n        while (iterator.hasNext()) {\n          File file = iterator.next();\n          if (file.isFile() && (DrJavaFileUtils.isSourceFile(file) || file.getName().endsWith(\".txt\"))) {\n            filteredFileList.add(file);\n          }\n          else if (file.isFile() && file.getName().endsWith(OptionConstants.EXTPROCESS_FILE_EXTENSION)) {\n            openExtProcessFile(file);\n          }\n        }\n        final File[] fileArray = filteredFileList.toArray(new File[filteredFileList.size()]);\n        FileOpenSelector fs = new FileOpenSelector() {\n          public File[] getFiles() { return fileArray; }\n        };\n        open(fs);\n        dropTargetDropEvent.getDropTargetContext().dropComplete(true);\n      }\n      else {\n        dropTargetDropEvent.rejectDrop();\n      }\n    }\n    catch(IOException ioe) {\n      ioe.printStackTrace();\n      dropTargetDropEvent.rejectDrop();\n    }\n    catch (UnsupportedFlavorException ufe) {\n      ufe.printStackTrace();\n      dropTargetDropEvent.rejectDrop();\n    }    \n  }\n  \n  /** Open stand-alone external process file. */\n  public static void openExtProcessFile(File file) {\n    try {\n      XMLConfig xc = new XMLConfig(file);\n      String name = xc.get(\"drjava/extprocess/name\");\n      ExecuteExternalDialog.addToMenu(name, xc.get(\"drjava/extprocess/cmdline\"),\n                                      xc.get(\"drjava/extprocess/workdir\"), \"\");\n      JOptionPane.showMessageDialog(null, \"The installation was successful for:\\n\"+name,\n                                    \"Installation Successful\", JOptionPane.INFORMATION_MESSAGE);\n      // We override the drjava/extprocess/enclosingfile and set it to the empty string \"\"\n      // because this external process did not come from a *.djapp file that was a JAR file.\n    }\n    catch(XMLConfigException xce) {\n      // this wasn't an XML file, try to treat it as a jar file\n      openExtProcessJarFile(file);\n    }\n  }\n  \n  /** Open external process file in a jar file. */\n  public static void openExtProcessJarFile(File file) {\n    try {\n      JarFile jf = new JarFile(file);\n      JarEntry je = jf.getJarEntry(EXTPROCESS_FILE_NAME_INSIDE_JAR);\n      InputStream is = jf.getInputStream(je);\n      XMLConfig xc = new XMLConfig(is);\n      String name = xc.get(\"drjava/extprocess/name\");\n      ExecuteExternalDialog.addToMenu(name, xc.get(\"drjava/extprocess/cmdline\"),\n                                      xc.get(\"drjava/extprocess/workdir\"), file.getAbsolutePath());\n      JOptionPane.showMessageDialog(null, \"The installation was successful for:\\n\"+name,\n                                    \"Installation Successful\", JOptionPane.INFORMATION_MESSAGE);\n      // We override the drjava/extprocess/enclosingfile and set it to the file specified\n      // because this external process came from a *.djapp file that was a JAR file.\n      is.close();\n      jf.close();\n    }\n    catch(IOException ioe) { /* ignore drop */ }\n    catch(XMLConfigException xce) { /* ignore drop */ }\n  }\n  \n  /** Convert a string with URIs to a list of files.\n    * @param data string with URIs\n    * @return list of files\n    */\n  private static List<File> textURIListToFileList(String data) {\n    List<File> list = new java.util.ArrayList<File>();\n    java.util.StringTokenizer st = new java.util.StringTokenizer(data, \"\\r\\n\");\n    while(st.hasMoreTokens()) {\n      String s = st.nextToken();\n      if (s.startsWith(\"#\")) continue; // the line is a comment (as per the RFC 2483)\n      try {\n        java.net.URI uri = new java.net.URI(s);\n        File file = new File(uri);\n        list.add(file);\n      }\n      catch (java.net.URISyntaxException e) { /* malformed URI*/ }\n      catch (IllegalArgumentException e) { /* the URI is not a valid 'file:' URI */ }\n    }\n    return list;\n  }\n  \n  /** Handles an \"open file\" request, either from the remote control server or the operating system.\n    * @param f file to open\n    * @param lineNo line number to jump to, or -1 of not specified\n    */\n  public void handleRemoteOpenFile(final File f, final int lineNo) {\n    if (f.getName().endsWith(OptionConstants.EXTPROCESS_FILE_EXTENSION)) {\n      openExtProcessFile(f);\n    }\n    else {\n      final FileOpenSelector openSelector = new FileOpenSelector() {\n        public File[] getFiles() throws OperationCanceledException {\n          return new File[] { f };\n        }\n      };\n      String currFileName = f.getName();\n      if (currFileName.endsWith(OptionConstants.PROJECT_FILE_EXTENSION) ||\n          currFileName.endsWith(OptionConstants.PROJECT_FILE_EXTENSION2) ||\n          currFileName.endsWith(OptionConstants.OLD_PROJECT_FILE_EXTENSION)) {\n        Utilities.invokeLater(new Runnable() { \n          public void run() {\n            openProject(openSelector);\n          }\n        });\n      }\n      else {\n        final int l = lineNo;\n        Utilities.invokeLater(new Runnable() { \n          public void run() {\n            open(openSelector);\n            if (l>=0) {                \n              _jumpToLine(l);\n            }\n          }\n        });\n      }\n    }\n  }\n  \n  /** Reset the position of the \"Open Javadoc\" dialog. */\n  public void resetAutoImportDialogPosition() {\n    _initAutoImportDialog();\n    _autoImportDialog.setFrameState(\"default\");\n    if (DrJava.getConfig().getSetting(DIALOG_AUTOIMPORT_STORE_POSITION).booleanValue()) {\n      DrJava.getConfig().setSetting(DIALOG_AUTOIMPORT_STATE, \"default\");\n    }\n  }\n  \n  /** Initialize dialog if necessary. */\n  private void _initAutoImportDialog() {\n    if (_autoImportDialog == null) {\n      _autoImportPackageCheckbox = new JCheckBox(\"Import Package\");\n      _autoImportPackageCheckbox.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) { _autoImportDialog.resetFocus(); }\n      });\n      PlatformFactory.ONLY.setMnemonic(_autoImportPackageCheckbox,'p');\n      PredictiveInputFrame.InfoSupplier<JavaAPIListEntry> info = \n        new PredictiveInputFrame.InfoSupplier<JavaAPIListEntry>() {\n        public String value(JavaAPIListEntry entry) { // show full class name as information\n          return entry.getFullString();\n        }\n      };\n      PredictiveInputFrame.CloseAction<JavaAPIListEntry> okAction = \n        new PredictiveInputFrame.CloseAction<JavaAPIListEntry>() {\n        public String getName() { return \"OK\"; }\n        public KeyStroke getKeyStroke() { return KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0); }\n        public String getToolTipText() { return null; }\n        public Object value(PredictiveInputFrame<JavaAPIListEntry> p) {\n          String text;\n          if (p.getItem() != null) { // if a class was selected...\n            text = p.getItem().getFullString();\n          }\n          else { // use the text that was entered\n            text = p.getText();\n          }\n          if (_autoImportPackageCheckbox.isSelected()) {\n            int lastDot = text.lastIndexOf('.');\n            if (lastDot > 0) text = text.substring(0, lastDot + 1) + \"*\";\n          }\n          final InteractionsModel im = _model.getInteractionsModel();\n          // Get the last line (the one that caused the error) and remove it from the history\n          String lastLine = im.removeLastFromHistory();\n          // Import the selected class...\n          String importLine = \"import \" + text + \"; // auto-import\";\n          // ... and try to do the last line again\n          final String code = importLine + ((lastLine != null)  ?  (\"\\n\" + lastLine)  : \"\");\n          EventQueue.invokeLater(new Runnable() { \n            public void run() { // interpret with the added import\n              try {\n                im.append(code, InteractionsDocument.DEFAULT_STYLE);\n                im.interpretCurrentInteraction();\n              }\n              finally { hourglassOff(); }\n            }\n          });\n          return null;\n        }\n      };\n      PredictiveInputFrame.CloseAction<JavaAPIListEntry> cancelAction = \n        new PredictiveInputFrame.CloseAction<JavaAPIListEntry>() {\n        public String getName() { return \"Cancel\"; }\n        public KeyStroke getKeyStroke() { return KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0); }\n        public String getToolTipText() { return null; }\n        public Object value(PredictiveInputFrame<JavaAPIListEntry> p) {\n          // if no class was selected, just reset the error information so the dialog box works next time\n          _model.getInteractionsModel().resetLastErrors();\n          hourglassOff();\n          return null;\n        }\n      };\n      \n      ArrayList<MatchingStrategy<JavaAPIListEntry>> strategies =\n        new ArrayList<MatchingStrategy<JavaAPIListEntry>>();\n      strategies.add(new FragmentStrategy<JavaAPIListEntry>());\n      strategies.add(new PrefixStrategy<JavaAPIListEntry>());\n      strategies.add(new RegExStrategy<JavaAPIListEntry>());\n      List<PredictiveInputFrame.CloseAction<JavaAPIListEntry>> actions\n        = new ArrayList<PredictiveInputFrame.CloseAction<JavaAPIListEntry>>();\n      actions.add(okAction);\n      actions.add(cancelAction);\n      _autoImportDialog = \n        new PredictiveInputFrame<JavaAPIListEntry>(MainFrame.this, \"Auto Import Class\", false, true, info, strategies,\n                                                   actions, 1, new JavaAPIListEntry(\"dummyImport\", \"dummyImport\", null)) \n      {\n        public void setOwnerEnabled(boolean b) { if (b) hourglassOff(); else hourglassOn(); }\n        protected JComponent[] makeOptions() { return new JComponent[] { _autoImportPackageCheckbox }; }\n      }; \n      // Put one dummy entry in the list; it will be changed later anyway\n      if (DrJava.getConfig().getSetting(DIALOG_AUTOIMPORT_STORE_POSITION).booleanValue()) {\n        _autoImportDialog.setFrameState(DrJava.getConfig().getSetting(DIALOG_AUTOIMPORT_STATE));\n      }\n      generateJavaAPISet();\n    }\n  }\n  \n  /** The \"Auto Import\" dialog instance. */\n  PredictiveInputFrame<JavaAPIListEntry> _autoImportDialog = null;\n  JCheckBox _autoImportPackageCheckbox;\n  \n  /** Imports a class. */\n  private void _showAutoImportDialog(final String s) {\n    hourglassOn();\n    new Thread() {\n      public void run() {\n        // run this in a thread other than the main thread        \n        final Set<JavaAPIListEntry> apiSet = getJavaAPISet();\n        if (apiSet == null) {\n          hourglassOff();\n          return;\n        }\n    \n        Utilities.invokeLater(new Runnable() {\n          public void run() {\n            // but now run this in the event thread again\n            List<JavaAPIListEntry> autoImportList = new ArrayList<JavaAPIListEntry>(apiSet);\n            if (DrJava.getConfig().getSetting(DIALOG_COMPLETE_SCAN_CLASS_FILES).booleanValue() &&\n                _autoImportClassSet.size() > 0) {\n              autoImportList.addAll(_autoImportClassSet);\n            }\n            else {\n              File projectRoot = _model.getProjectRoot();\n              List<OpenDefinitionsDocument> docs = _model.getOpenDefinitionsDocuments();\n              if (docs != null) {\n                for (OpenDefinitionsDocument d: docs) {\n                  if (d.isUntitled()) continue;\n                  try {\n                    String rel = FileOps.stringMakeRelativeTo(d.getRawFile(), projectRoot);\n                    String full = rel.replace(File.separatorChar, '.');\n                    for (String ext: edu.rice.cs.drjava.model.compiler.CompilerModel.EXTENSIONS) {\n                      if (full.endsWith(ext)) {\n                        full = full.substring(0, full.lastIndexOf(ext));\n                        break;\n                      }\n                    }\n                    String simple = full;\n                    if (simple.lastIndexOf('.') >= 0) simple = simple.substring(simple.lastIndexOf('.') + 1);\n                    \n                    JavaAPIListEntry entry = new JavaAPIListEntry(simple, full, null);\n                    if (! autoImportList.contains(entry)) { autoImportList.add(entry); }\n                  }\n                  catch(IOException ioe) { /* ignore, just don't add this one */ }\n                  catch(SecurityException se) { /* ignore, just don't add this one */ }\n                }\n              }\n            }\n            PredictiveInputModel<JavaAPIListEntry> pim =\n              new PredictiveInputModel<JavaAPIListEntry>(true, new PrefixStrategy<JavaAPIListEntry>(), autoImportList);\n            pim.setMask(s);\n            _initAutoImportDialog();\n            _autoImportDialog.setModel(true, pim); // ignore case\n            _autoImportPackageCheckbox.setSelected(false);\n            _autoImportDialog.setVisible(true);\n          }\n        });\n      }\n    }.start();\n  }\n  \n  /** Follow a file. */\n  private final Action _followFileAction = new AbstractAction(\"Follow File...\") {\n    public void actionPerformed(ActionEvent ae) { _followFile(); }\n  };\n  \n  /** Open a file for following (like using \"less\" and F).  Only runs in the event thread. */\n  private void _followFile() {\n    updateStatusField(\"Opening File for Following\");\n    try {      \n      final File[] files = _openAnyFileSelector.getFiles();\n      if (files == null) { return; }\n      for (final File f: files) {\n        if (f == null) continue;\n        String end = f.getName();\n        int lastIndex = end.lastIndexOf(File.separatorChar);\n        if (lastIndex >= 0) end = end.substring(lastIndex+1);\n        final LessPanel panel = new LessPanel(this, \"Follow: \"+end, f);\n        _tabs.addLast(panel);\n        panel.getMainPanel().addFocusListener(new FocusAdapter() {\n          public void focusGained(FocusEvent e) { _lastFocusOwner = panel; }\n        });\n        panel.setVisible(true);\n        showTab(panel, true);\n        _tabbedPane.setSelectedComponent(panel);\n        // Use EventQueue.invokeLater to ensure that focus is set AFTER the findResultsPanel has been selected\n        EventQueue.invokeLater(new Runnable() { public void run() { panel.requestFocusInWindow(); } });\n      }\n    }\n    catch(OperationCanceledException oce) { /* ignore */ }\n  }\n  \n  /** Execute an external process. */\n  private final Action _executeExternalProcessAction = new AbstractAction(\"New External Process...\") {\n    public void actionPerformed(ActionEvent ae) { _executeExternalProcess(); }\n  };\n  \n  /** Execute an external process and monitor its output. */\n  private void _executeExternalProcess() { _executeExternalDialog.setVisible(true); }\n  \n  /** The execute external dialog. */\n  private volatile ExecuteExternalDialog _executeExternalDialog;\n  \n  /** Initializes the \"Execute External Process\" dialog. */\n  private void initExecuteExternalProcessDialog() {\n    if (DrJava.getConfig().getSetting(DIALOG_EXTERNALPROCESS_STORE_POSITION).booleanValue()) {\n      _executeExternalDialog.setFrameState(DrJava.getConfig().getSetting(DIALOG_EXTERNALPROCESS_STATE));\n    }\n  }\n  \n  /** Reset the position of the \"Execute External Process\" dialog. */\n  public void resetExecuteExternalProcessPosition() {\n    _executeExternalDialog.setFrameState(\"default\");\n    if (DrJava.getConfig().getSetting(DIALOG_EXTERNALPROCESS_STORE_POSITION).booleanValue()) {\n      DrJava.getConfig().setSetting(DIALOG_EXTERNALPROCESS_STATE, \"default\");\n    }\n  }\n  \n  /** The edit external dialog. */\n  private volatile EditExternalDialog _editExternalDialog;\n  \n  /** Initializes the \"Edit External Process\" dialog. */\n  private void initEditExternalProcessDialog() {\n    if (DrJava.getConfig().getSetting(DIALOG_EDITEXTERNALPROCESS_STORE_POSITION).booleanValue()) {\n      _editExternalDialog.setFrameState(DrJava.getConfig().getSetting(DIALOG_EDITEXTERNALPROCESS_STATE));\n    }\n  }\n  \n  /** Reset the position of the \"Edit External Process\" dialog. */\n  public void resetEditExternalProcessPosition() {\n    _editExternalDialog.setFrameState(\"default\");\n    if (DrJava.getConfig().getSetting(DIALOG_EDITEXTERNALPROCESS_STORE_POSITION).booleanValue()) {\n      DrJava.getConfig().setSetting(DIALOG_EDITEXTERNALPROCESS_STATE, \"default\");\n    }\n  }\n  \n  /** Action that edits saved processes.  Only runs in the event thread. */\n  private final Action _editExternalProcessesAction = new AbstractAction(\"Edit...\") {\n    public void actionPerformed(ActionEvent ae) { _editExternalDialog.setVisible(true); }\n  };\n  \n  /** Return the modal window listener if available, otherwise returns a non-modal dummy listener.\n    * Note that the WindowEvent passed to the toFrontAction runnable may not be the WindowEvent that\n    * caused the window w to be pushed off the front, it may also be the WindowEvent that restores\n    * w as front window after a modal dialog that trumped w was closed.\n    * @param w window trying to get the modal window listener\n    * @param toFrontAction action to be performed after the window has been moved to the front again\n    * @param closeAction action to be performed when the window is closing\n    */\n  public void installModalWindowAdapter(final Window w, final Runnable1<? super WindowEvent> toFrontAction,\n                                        final Runnable1<? super WindowEvent> closeAction) {\n    assert EventQueue.isDispatchThread();\n    \n    if (_modalWindowAdapters.containsKey(w)) { // already installed\n      return;\n    }\n    \n    WindowAdapter wa;\n    if (_modalWindowAdapterOwner == null) {\n      // modal listener is available, claim it\n      _modalWindowAdapterOwner = w;\n      // create a window adapter performs the specified actions after delegating to the modal window adapter\n      wa = new WindowAdapter() {\n        final HashSet<Window> trumpedBy = new HashSet<Window>(); \n        // set of windows that trumped this window in getting to the front\n        final WindowAdapter regainFront = new WindowAdapter() {\n          public void windowClosed(WindowEvent we) {\n            // the window that trumped w was closed, so we're moving w back to the front\n            w.toFront();\n            w.requestFocus();\n            toFrontAction.run(we);\n            // then we remove the window that trumped w from the set of trump windows\n            Window o = we.getOppositeWindow();\n            if (o != null) {\n              trumpedBy.remove(o);\n              // and we remove this listener\n              o.removeWindowListener(this);\n            }\n          }\n        };\n        final WindowAdapter regainFrontAfterNative = new WindowAdapter() {\n          public void windowActivated(WindowEvent we) {\n            // remove from the three windows this is installed on\n            MainFrame.this.removeWindowListener(this);\n            _tabbedPanesFrame.removeWindowListener(this);\n            if (_debugFrame != null) _debugFrame.removeWindowListener(this);\n            // if the window that lost focus because of a native application window\n            // is still the modal window adapter owner, put it back in front\n            if (_modalWindowAdapterOwner==w) {\n              w.toFront();\n              w.requestFocus();\n              toFrontAction.run(we);\n            }\n          }\n        };\n        public void toFront(WindowEvent we) {\n          Window opposite = we.getOppositeWindow();\n          if (opposite == null) {\n            // Probably a native application window, not DrJava.\n            // When the user switches back to DrJava, the user may select\n            // a different window to be on top, but we want w to be on top\n            // install a listener on MainFrame, the detached panes window, and the\n            // detached debugger that puts w back on top if one of those windows\n            // gets selected and w is still the modal window adapter owner.\n            // This isn't perfect, since the user may select a window other than\n            // those three, but it is good enough in most cases since those three\n            // windows are the biggest windows.\n            MainFrame.this.addWindowListener(regainFrontAfterNative);\n            _tabbedPanesFrame.addWindowListener(regainFrontAfterNative);\n            if (_debugFrame != null) _debugFrame.addWindowListener(regainFrontAfterNative);\n            return;\n          }\n          if (opposite instanceof Dialog) {\n            Dialog d = (Dialog)opposite;\n            if (d.isModal()) {\n              // the other window is a real modal dialog, we'll leave it on top -- the window trumped this window\n              if (!trumpedBy.contains(d)) {\n                // add a listener to move this window back to the front when the opposite window has been closed\n                d.addWindowListener(regainFront);\n                // add trump window to set of windows that have trumped this window\n                trumpedBy.add(d);\n              }\n              return; \n            }\n          }\n          we.getWindow().toFront();\n          we.getWindow().requestFocus();\n          toFrontAction.run(we);\n        }\n        public void windowDeactivated(WindowEvent we) { toFront(we); }\n        public void windowIconified(WindowEvent we) { toFront(we); }\n        public void windowLostFocus(WindowEvent we) { toFront(we); }\n        public void windowClosing(WindowEvent we) { closeAction.run(we); }\n      };\n    }\n    else {\n      /* The modal listener is already owned by another window.  The code block creates a window adapter that performs \n       * closeActions but not toFrontActions because the latter could generate an endless loop with this window \n       * competing with the modal listener window to stay on top.\n       */\n      wa = new WindowAdapter() {\n        public void windowDeactivated(WindowEvent we) { }\n        public void windowIconified(WindowEvent we) { }\n        public void windowLostFocus(WindowEvent we) { }\n        public void windowClosing(WindowEvent we) { closeAction.run(we); }\n      };\n    }\n    // install it\n    _modalWindowAdapters.put(w, wa);\n    w.addWindowListener(wa);\n    w.addWindowFocusListener(wa);\n  }\n  \n  /** Removes the modal window adapter.\n    * @param w window releasing the modal window adapter \n    */\n  public /* synchronized */ void removeModalWindowAdapter(Window w) {\n    assert EventQueue.isDispatchThread();\n    if (! _modalWindowAdapters.containsKey(w)) { // the specified window does not have a modal windowadapter\n      return;\n    }\n    w.removeWindowListener(_modalWindowAdapters.get(w));\n    w.removeWindowFocusListener(_modalWindowAdapters.get(w));\n    _modalWindowAdapterOwner = null;\n    _modalWindowAdapters.remove(w);\n  }\n\n/** A nonexistent file.  Should open a new, untitled document. \n * @param commandLineTest TODO*/\n  public void testNE(CommandLineTest commandLineTest) {\n    String[] list = new String[1];\n    list[0] = commandLineTest.nof1_name;\n    DrJavaRoot.openCommandLineFiles(this, list, false);\n//    _log.log(\"openCommandLineFiles completed\");\n    List<OpenDefinitionsDocument> docs = getModel().getOpenDefinitionsDocuments();\n    Assert.assertEquals(\"Exactly one document?\", 1, docs.size());\n    OpenDefinitionsDocument doc = docs.get(0);\n    Assert.assertTrue(\"Is document untitled?\", doc.isUntitled());\n    commandLineTest._log.log(\"testNE completed\");\n  }\n}",
                "methodCount": 841
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "iterationData": [],
            "methodCompatibilityScores": {},
            "llmMethodPriority": {},
            "targetClassMap": {}
        }
    },
    {
        "oracle": "method edu.rice.cs.util.swing.FileChooser::_runCommand():void need move to edu.rice.cs.drjava.ui.ExecuteExternalDialog",
        "class_name": "edu.rice.cs.util.swing.FileChooser",
        "telemetry": {
            "id": "efe01b2a-c908-40d4-a837-1b77af51a916",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 64,
                "lineStart": 48,
                "lineEnd": 111,
                "bodyLineStart": 48,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/drjava/large/big/drjava-stable-20100913-r5387/src/src/edu/rice/cs/util/swing/FileChooser.java",
                "sourceCode": "public class FileChooser extends JFileChooser {\n  \n  /** File system root for chooser */\n  protected File _root;\n  \n  /** Creates a FileChooser with the given root, allowing only a single selection WITHIN the specified file system\n    * @param root the root directory to display in the tree\n    */\n  public FileChooser(File root) { \n    super(root);\n    _init(root);\n  }\n  \n  /*---------- INITIALIZATION METHODS ----------*/\n  \n  /** Sets up the GUI components of the dialog */\n  private void _init(final File root) {\n    \n    setRoot(root);\n    \n    setFileSelectionMode(FILES_ONLY);\n    setDialogType(CUSTOM_DIALOG);\n    setApproveButtonText(\"Select\");\n  }\n  \n  public void setRoot(File root) {\n    _root = root; // may be null\n    if (root != null) {\n      if (! root.exists()) _root = null;\n      else if (! root.isDirectory()) _root = root.getParentFile();\n    }\n  }\n  \n  public File getRoot() { return _root; }\n  \n  public boolean isTraversable(File f) {\n    if (_root == null) return super.isTraversable(f);\n//    Utilities.show(\"isTraversable(\" + f + \") called; _root = \" + _root);\n    return f != null && f.isDirectory() && IOUtil.isMember(f, _root);\n  }\n\n/** Execute the command line. \n * @param executeExternalDialog TODO*/\n  public void _runCommand(ExecuteExternalDialog executeExternalDialog) {\n    executeExternalDialog._mainFrame.updateStatusField(\"Executing external process...\");\n    GeneralProcessCreator.LOG.log(\"_runCommand(): ${enclosing.djapp.file} = \" + executeExternalDialog._commandEnclosingFileLine.getText());\n    \n    executeExternalDialog._mainFrame.removeModalWindowAdapter(executeExternalDialog);\n    if (executeExternalDialog._commandLinePreview.getText().length() > 0) {\n      try { \n        executeExternalDialog._props = PropertyMaps.TEMPLATE.clone();\n        PropertyMaps pm = executeExternalDialog._props.clone();\n        executeExternalDialog.runCommand(\"\", executeExternalDialog._commandLine.getText(), executeExternalDialog._commandWorkDirLine.getText(), \n                   executeExternalDialog._commandEnclosingFileLine.getText().trim(), pm);\n      } \n      catch(CloneNotSupportedException e) { throw new edu.rice.cs.util.UnexpectedException(e); }\n    }\n    \n    // Always apply and save settings\n    executeExternalDialog._saveSettings();\n    executeExternalDialog.setVisible(false);\n    if (executeExternalDialog._cm != null) { executeExternalDialog._cm.signal(); }    \n  }\n}",
                "methodCount": 6
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 88,
                        "lineEnd": 109,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method _runCommand to class ExecuteExternalDialog",
                        "description": "Move method _runCommand to edu.rice.cs.drjava.ui.ExecuteExternalDialog\nRationale: The method _runCommand() is closely tied to the functionality of the ExecuteExternalDialog class, as it directly manipulates its instance variables and methods. It handles the execution of commands that are defined within the context of the ExecuteExternalDialog, such as updating the status field, saving settings, and running commands based on user input. Moving this method to ExecuteExternalDialog will enhance cohesion, as it will reside within the class that is responsible for managing the dialog's state and behavior. This will also improve maintainability, as all related functionalities will be encapsulated within the same class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "_runCommand",
                            "method_signature": "public void _runCommand(ExecuteExternalDialog executeExternalDialog)",
                            "target_class": "ExecuteExternalDialog",
                            "rationale": "The _runCommand method operates directly on the ExecuteExternalDialog instance and handles its internal state. It would be more cohesive to move this method to the ExecuteExternalDialog class, where it can manage its own execution logic."
                        }
                    ],
                    "llm_response_time": 1891
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "_runCommand",
                            "method_signature": "public void _runCommand(ExecuteExternalDialog executeExternalDialog)",
                            "target_class": "ExecuteExternalDialog",
                            "rationale": "_runCommand() directly manipulates the ExecuteExternalDialog instance and its properties, making it more appropriate for this method to reside within the ExecuteExternalDialog class."
                        }
                    ],
                    "llm_response_time": 1647
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "_runCommand",
                            "method_signature": "public void _runCommand(ExecuteExternalDialog executeExternalDialog)",
                            "target_class": "ExecuteExternalDialog",
                            "rationale": "_runCommand() directly manipulates the ExecuteExternalDialog instance and its properties, making it more appropriate for this method to reside within the ExecuteExternalDialog class."
                        }
                    ],
                    "llm_response_time": 2113
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "_runCommand",
                            "method_signature": "public _runCommand(ExecuteExternalDialog executeExternalDialog)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "_runCommand",
                            "method_signature": "public _runCommand(ExecuteExternalDialog executeExternalDialog)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public _runCommand(ExecuteExternalDialog executeExternalDialog)": {
                        "first": {
                            "method_name": "_runCommand",
                            "method_signature": "public _runCommand(ExecuteExternalDialog executeExternalDialog)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5457584763771611
                    }
                },
                "voyage": {
                    "public _runCommand(ExecuteExternalDialog executeExternalDialog)": {
                        "first": {
                            "method_name": "_runCommand",
                            "method_signature": "public _runCommand(ExecuteExternalDialog executeExternalDialog)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.38794915337099894
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public _runCommand(ExecuteExternalDialog executeExternalDialog)"
                    ],
                    "llm_response_time": 509
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public _runCommand(ExecuteExternalDialog executeExternalDialog)"
                    ],
                    "llm_response_time": 0
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public _runCommand(ExecuteExternalDialog executeExternalDialog)"
                    ],
                    "llm_response_time": 0
                },
                "voyage": {
                    "priority_method_names": [
                        "public _runCommand(ExecuteExternalDialog executeExternalDialog)"
                    ],
                    "llm_response_time": 0
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public _runCommand(ExecuteExternalDialog executeExternalDialog)"
                    ],
                    "llm_response_time": 1
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public _runCommand(ExecuteExternalDialog executeExternalDialog)"
                    ],
                    "llm_response_time": 0
                }
            },
            "targetClassMap": {
                "_runCommand": {
                    "target_classes": [
                        {
                            "class_name": "ExecuteExternalDialog",
                            "similarity_score": 0.7206198133206289
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ExecuteExternalDialog"
                    ],
                    "llm_response_time": 3086,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method edu.rice.cs.util.swing.DelegatingAction::_installNewDocumentListener(OpenDefinitionsDocument):void need move to edu.rice.cs.drjava.ui.MainFrame",
        "class_name": "edu.rice.cs.util.swing.DelegatingAction",
        "telemetry": {
            "id": "a2a6f7df-60f0-41ed-9efb-28119b8e0ee9",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 163,
                "lineStart": 52,
                "lineEnd": 214,
                "bodyLineStart": 52,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/drjava/large/big/drjava-stable-20100913-r5387/src/src/edu/rice/cs/util/swing/DelegatingAction.java",
                "sourceCode": "public class DelegatingAction implements Action {\n  /** These keys will be copied from the delegatee. All other keys are held in this action itself.\n   */\n  private static final String[] KEYS_TO_DELEGATE = {\n    //DEFAULT,\n    NAME,\n    //SHORT_DESCRIPTION,\n    //LONG_DESCRIPTION,\n    //SMALL_ICON,\n    //ACTION_COMMAND_KEY,\n    //ACCELERATOR_KEY,\n    //MNEMONIC_KEY,\n  };\n\n  /** Can't use a more specific type parameter because of Action interface. */\n  private HashMap<String, Object> _localProperties = new HashMap<String, Object>();\n\n  /** The action to delegate to. If it's null, this action is disabled and all method calls will result in \n    * IllegalStateExceptions.\n    */\n  private volatile Action _delegatee;\n  private final LinkedList<PropertyChangeListener> _listenerList =\n    new LinkedList<PropertyChangeListener>();\n\n  /** Returns value of the key, from delegatee is it's in {@link #KEYS_TO_DELEGATE} or from this if not. */\n  public Object getValue(String key) {\n    _checkState();\n    \n    if (_isDelegatedKey(key)) return _delegatee.getValue(key);\n    else return _localProperties.get(key);\n  }\n\n  private boolean _isDelegatedKey(String key) {\n    for (int i = 0; i < KEYS_TO_DELEGATE.length; i++) {\n      if (KEYS_TO_DELEGATE[i].equals(key)) return true;\n    }\n    return false;\n  }\n\n  public void putValue(String key, Object value) {\n    _checkState();\n\n    if (_isDelegatedKey(key)) {\n      _delegatee.putValue(key, value);\n    }\n    else {\n      Object old = _localProperties.get(key);\n      _localProperties.put(key, value);\n\n      PropertyChangeEvent event = new PropertyChangeEvent(this, key, old, value);\n      for (PropertyChangeListener listener : _listenerList) {\n        listener.propertyChange(event);\n      }\n    }\n  }\n\n  public void setEnabled(boolean b) {\n    _checkState();\n    _delegatee.setEnabled(b);\n  }\n\n  public boolean isEnabled() {\n    _checkState();\n    return _delegatee.isEnabled();\n  }\n\n  public void addPropertyChangeListener(PropertyChangeListener listener) {\n    _checkState();\n    _delegatee.addPropertyChangeListener(listener);\n    _listenerList.add(listener);\n  }\n\n  public void removePropertyChangeListener(PropertyChangeListener listener) {\n    _checkState();\n    _delegatee.removePropertyChangeListener(listener);\n    _listenerList.remove(listener);\n  }\n\n  public void actionPerformed(ActionEvent ae) {\n    _checkState();\n    _delegatee.actionPerformed(ae);\n  }\n\n  public Action getDelegatee() { return _delegatee; }\n    \n  public void setDelegatee(final Action newDelegatee) {\n    if (newDelegatee == null) {\n      throw new IllegalArgumentException(\"setDelegatee(null) is not allowed!\");\n    }\n    \n    // create property change notifications\n    boolean isEnabled = newDelegatee.isEnabled();\n\n    PropertyChangeEvent enabledEvent\n       = new PropertyChangeEvent(newDelegatee, \"enabled\", Boolean.FALSE, isEnabled);\n\n    PropertyChangeEvent[] events = null;\n\n    if (_delegatee != null) {\n      events = new PropertyChangeEvent[KEYS_TO_DELEGATE.length];\n\n      for (int i = 0; i < KEYS_TO_DELEGATE.length; i++) {\n        Object oldValue = _delegatee.getValue(KEYS_TO_DELEGATE[i]);\n        Object newValue = newDelegatee.getValue(KEYS_TO_DELEGATE[i]);\n\n        events[i] = new PropertyChangeEvent(newDelegatee,\n                                            KEYS_TO_DELEGATE[i],\n                                            oldValue,\n                                            newValue);\n      }\n    }\n\n    // remove listeners from old and add to new\n    for (PropertyChangeListener listener : _listenerList) {\n      if (_delegatee != null) {\n        _delegatee.removePropertyChangeListener(listener);\n      }\n\n      newDelegatee.addPropertyChangeListener(listener);\n\n      // fire property change events for all properties\n\n      if (events != null) {\n        for (int i = 0; i < events.length; i++) {\n          listener.propertyChange(events[i]);\n        }\n      }\n\n      listener.propertyChange(enabledEvent);\n    }\n\n    _delegatee = newDelegatee;\n  }\n\n  private void _checkState() {\n    if (_delegatee == null) {\n      throw new IllegalStateException(\"delegatee is null!\");\n    }\n  }\n\n/** Makes sure save and compile buttons and menu items are enabled and disabled appropriately after document\n    * modifications.\n * @param mainFrame TODO\n * @param d TODO\n    */\n  public void _installNewDocumentListener(final MainFrame mainFrame, final OpenDefinitionsDocument d) {\n    d.addDocumentListener(new DocumentUIListener() {\n      public void changedUpdate(DocumentEvent e) {  }\n      public void insertUpdate(DocumentEvent e) {\n        assert EventQueue.isDispatchThread();\n        mainFrame._saveAction.setEnabled(true);\n        if (mainFrame.isDebuggerEnabled() && mainFrame._debugPanel.getStatusText().equals(\"\"))\n          mainFrame._debugPanel.setStatusText(MainFrame.DEBUGGER_OUT_OF_SYNC);\n      }\n      public void removeUpdate(DocumentEvent e) {\n        assert EventQueue.isDispatchThread();\n        mainFrame._saveAction.setEnabled(true);\n        if (mainFrame.isDebuggerEnabled() && mainFrame._debugPanel.getStatusText().equals(\"\"))\n          mainFrame._debugPanel.setStatusText(MainFrame.DEBUGGER_OUT_OF_SYNC);\n      }\n    });\n  }\n}",
                "methodCount": 15
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 191,
                        "lineEnd": 212,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method _installNewDocumentListener to class MainFrame",
                        "description": "Move method _installNewDocumentListener to edu.rice.cs.drjava.ui.MainFrame\nRationale: The method _installNewDocumentListener() is responsible for managing the state of the save and compile buttons based on document modifications. This functionality is closely tied to the MainFrame class, which handles the user interface and interactions with the document. Moving this method to MainFrame will enhance cohesion, as it directly manipulates UI components and their states in response to document events. Additionally, it will simplify the OpenDefinitionsDocument class, which should focus on document management rather than UI concerns.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "_installNewDocumentListener",
                            "method_signature": "public void _installNewDocumentListener(final MainFrame mainFrame, final OpenDefinitionsDocument d)",
                            "target_class": "MainFrame",
                            "rationale": "The method _installNewDocumentListener is closely related to the MainFrame class, as it directly manipulates its actions and UI components. Moving it to MainFrame would enhance cohesion and encapsulation."
                        }
                    ],
                    "llm_response_time": 2046
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "_installNewDocumentListener",
                            "method_signature": "public void _installNewDocumentListener(final MainFrame mainFrame, final OpenDefinitionsDocument d)",
                            "target_class": "MainFrame",
                            "rationale": "The method _installNewDocumentListener is closely related to the MainFrame class and its actions. It should be moved to MainFrame to encapsulate the behavior of managing document listeners within the context of the main application frame."
                        }
                    ],
                    "llm_response_time": 2197
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "_installNewDocumentListener",
                            "method_signature": "public void _installNewDocumentListener(MainFrame mainFrame, OpenDefinitionsDocument d)",
                            "target_class": "MainFrame",
                            "rationale": "The method _installNewDocumentListener is closely related to the MainFrame class, as it directly manipulates its properties and actions. Moving it to MainFrame would enhance cohesion and encapsulation."
                        }
                    ],
                    "llm_response_time": 2000
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "insertUpdate",
                            "method_signature": "public insertUpdate(DocumentEvent e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeUpdate",
                            "method_signature": "public removeUpdate(DocumentEvent e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_installNewDocumentListener",
                            "method_signature": "public _installNewDocumentListener(final MainFrame mainFrame, final OpenDefinitionsDocument d)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "insertUpdate",
                            "method_signature": "public insertUpdate(DocumentEvent e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeUpdate",
                            "method_signature": "public removeUpdate(DocumentEvent e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_installNewDocumentListener",
                            "method_signature": "public _installNewDocumentListener(final MainFrame mainFrame, final OpenDefinitionsDocument d)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public insertUpdate(DocumentEvent e)": {
                        "first": {
                            "method_name": "insertUpdate",
                            "method_signature": "public insertUpdate(DocumentEvent e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4718781934396191
                    },
                    "public removeUpdate(DocumentEvent e)": {
                        "first": {
                            "method_name": "removeUpdate",
                            "method_signature": "public removeUpdate(DocumentEvent e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4718781934396191
                    },
                    "public _installNewDocumentListener(final MainFrame mainFrame, final OpenDefinitionsDocument d)": {
                        "first": {
                            "method_name": "_installNewDocumentListener",
                            "method_signature": "public _installNewDocumentListener(final MainFrame mainFrame, final OpenDefinitionsDocument d)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5008469589219636
                    }
                },
                "voyage": {
                    "public _installNewDocumentListener(final MainFrame mainFrame, final OpenDefinitionsDocument d)": {
                        "first": {
                            "method_name": "_installNewDocumentListener",
                            "method_signature": "public _installNewDocumentListener(final MainFrame mainFrame, final OpenDefinitionsDocument d)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3880666987034258
                    },
                    "public insertUpdate(DocumentEvent e)": {
                        "first": {
                            "method_name": "insertUpdate",
                            "method_signature": "public insertUpdate(DocumentEvent e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5372369448316845
                    },
                    "public removeUpdate(DocumentEvent e)": {
                        "first": {
                            "method_name": "removeUpdate",
                            "method_signature": "public removeUpdate(DocumentEvent e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5406306074565962
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public _installNewDocumentListener(final MainFrame mainFrame, final OpenDefinitionsDocument d)",
                        "public insertUpdate(DocumentEvent e)",
                        "public removeUpdate(DocumentEvent e)"
                    ],
                    "llm_response_time": 813
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public _installNewDocumentListener(final MainFrame mainFrame, final OpenDefinitionsDocument d)",
                        "public insertUpdate(DocumentEvent e)",
                        "public removeUpdate(DocumentEvent e)"
                    ],
                    "llm_response_time": 0
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public _installNewDocumentListener(final MainFrame mainFrame, final OpenDefinitionsDocument d)",
                        "public insertUpdate(DocumentEvent e)",
                        "public removeUpdate(DocumentEvent e)"
                    ],
                    "llm_response_time": 1
                },
                "voyage": {
                    "priority_method_names": [
                        "public insertUpdate(DocumentEvent e)",
                        "public removeUpdate(DocumentEvent e)",
                        "public _installNewDocumentListener(final MainFrame mainFrame, final OpenDefinitionsDocument d)"
                    ],
                    "llm_response_time": 877
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public insertUpdate(DocumentEvent e)",
                        "public removeUpdate(DocumentEvent e)",
                        "public _installNewDocumentListener(final MainFrame mainFrame, final OpenDefinitionsDocument d)"
                    ],
                    "llm_response_time": 0
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public insertUpdate(DocumentEvent e)",
                        "public removeUpdate(DocumentEvent e)",
                        "public _installNewDocumentListener(final MainFrame mainFrame, final OpenDefinitionsDocument d)"
                    ],
                    "llm_response_time": 0
                }
            },
            "targetClassMap": {
                "insertUpdate": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2399,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "removeUpdate": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2664,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "_installNewDocumentListener": {
                    "target_classes": [
                        {
                            "class_name": "MainFrame",
                            "similarity_score": 0.5333624312893388
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.3024745333046412
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "MainFrame",
                        "OpenDefinitionsDocument"
                    ],
                    "llm_response_time": 23310,
                    "similarity_computation_time": 16,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method edu.rice.cs.drjava.model.GlobalEventNotifier::testCommentOutMultipleLines():void need move to edu.rice.cs.drjava.model.definitions.CommentTest",
        "class_name": "edu.rice.cs.drjava.model.GlobalEventNotifier",
        "telemetry": {
            "id": "abd8f547-ee35-459e-a9e2-4127ea73a2bb",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 607,
                "lineStart": 50,
                "lineEnd": 656,
                "bodyLineStart": 50,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/drjava/large/big/drjava-stable-20100913-r5387/src/src/edu/rice/cs/drjava/model/GlobalEventNotifier.java",
                "sourceCode": "/** Keeps track of all listeners to the model, and has the ability to notify them of some event.\n  * <p>\n  * This class has a specific role of managing GlobalModelListeners.  Other classes with similar names use similar\n  * code to perform the same function for other interfaces, e.g. InteractionsEventNotifier and JavadocEventNotifier.\n  * These classes implement the appropriate interface definition so that they can be used transparently as composite \n  * packaging for a particular listener interface.\n  * <p>\n  * Components which might otherwise manage their own list of listeners use EventNotifiers instead to simplify their \n  * internal implementation.  Notifiers should therefore be considered a private implementation detail of the \n  * components, and should not be used directly outside of the \"host\" component.\n  * <p>\n  * TODO: remove direct references to GlobalEventNotifier outside of DefaultGlobalModel\n  * TODO: remove public modifier from this class when above has happened\n  *\n  * All methods in this class must use the synchronization methods provided by ReaderWriterLock.  This ensures that \n  * multiple notifications (reads) can occur simultaneously, but only one thread can be adding or removing listeners \n  * (writing) at a time, and no reads can occur during a write.\n  * <p>\n  * <i>No</i> methods on this class should be synchronized using traditional Java synchronization!\n  * <p>\n  * @version $Id: GlobalEventNotifier.java 5236 2010-04-27 01:43:36Z mgricken $\n  */\n// QUESTION: why are we still using _lock operations?  All notifiers should run in the event thread.\n\npublic class GlobalEventNotifier extends EventNotifier<GlobalModelListener>\n  implements GlobalModelListener /*, Serializable */ {\n  \n  public <P,R> void executeAsyncTask(AsyncTask<P,R> task, P param, boolean showProgress, boolean lockUI) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.executeAsyncTask(task, param, showProgress, lockUI); } }\n    finally { _lock.endRead(); }\n  }\n  \n  public void filesNotFound(File... f) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.filesNotFound(f); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** @return the intersection of all the return values from the listeners. */\n  public File[] filesReadOnly(File... f) {\n    _lock.startRead();\n    java.util.LinkedList<File> files = new java.util.LinkedList<File>();\n    for(File fi: f) { files.add(fi); }\n    try {\n      for (GlobalModelListener l : _listeners) {\n        java.util.List<File> retry = java.util.Arrays.asList(l.filesReadOnly(f));\n        files.retainAll(retry);\n      }\n    }\n    finally { _lock.endRead(); }\n    return files.toArray(new File[files.size()]);\n  }\n  \n  /** Performs any UI related steps to handle the case in which a file is being opened that\n   * is already open and modified. The two choices are to revert to the copy on disk, or to\n   * keep the current changes.\n   * @param doc  {@code true} if the user wishes to revert the document, {@code false} to ignore\n   */\n  public void handleAlreadyOpenDocument(OpenDefinitionsDocument doc) {\n    _lock.startRead();\n    try { for(GlobalModelListener l : _listeners) { l.handleAlreadyOpenDocument(doc); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /* -------------- project state ------------------*/\n  public void openProject(File pfile, FileOpenSelector files) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.openProject(pfile, files); } }\n    finally { _lock.endRead(); }\n  }\n  \n  public void projectClosed() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.projectClosed();} }\n    finally { _lock.endRead(); }\n  }\n  \n  public void allFilesClosed() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.allFilesClosed();} }\n    finally { _lock.endRead(); }\n  }\n   \n  public void projectModified() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.projectModified(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  public void projectBuildDirChanged() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.projectBuildDirChanged(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  public void projectWorkDirChanged() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.projectWorkDirChanged(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  public void projectRunnableChanged() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.projectRunnableChanged(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  \n  /* ---------- Deprecated Methods ---------- */\n  \n  /** Lets the listeners know some event has taken place.\n    * @param n tells the listener what happened.\n    */\n  public void notifyListeners(Notifier n) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { n.notifyListener(l); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Allows the GlobalModel to ask its listeners a yes/no question and receive a response.\n    * @param p the question being asked of the listeners\n    * @return the listeners' responses ANDed together, true if they all\n    * agree, false if some disagree\n    * @deprecated Use listener methods directly instead.\n    */\n  @Deprecated\n  public boolean pollListeners(Poller p) {\n    _lock.startRead();\n    try {\n      for (GlobalModelListener l: _listeners) { if (! p.poll(l)) return false; }\n      return true;\n    }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Class model for notifying listeners of an event.\n   * @deprecated Use listener methods directly instead.\n   */\n  @Deprecated\n  public abstract static class Notifier {\n    public abstract void notifyListener(GlobalModelListener l);\n  }\n  \n  /** Class model for asking listeners a yes/no question.\n   * @deprecated Use listener methods directly instead.\n   */\n  @Deprecated\n  public abstract static class Poller {\n    public abstract boolean poll(GlobalModelListener l);\n  }\n  \n  // ---------- End of Deprecated Methods ----------\n  \n  \n  \n  //------------------------------ GlobalModel -------------------------------//\n  \n  /** Called when a file's main method is about to be run. */\n  public void prepareForRun(OpenDefinitionsDocument doc) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.prepareForRun(doc); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called after a new document is created. */\n  public void newFileCreated(OpenDefinitionsDocument doc) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.newFileCreated(doc); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when the console window is reset. */\n  public void consoleReset() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.consoleReset(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called after the current document is saved. */\n  public void fileSaved(OpenDefinitionsDocument doc) {\n//    ScrollableDialog sd = new ScrollableDialog(null, \"fileSaved(\" + doc + \") called in GlobalEventNotifier.java\", \"\", \"\");\n//    sd.show();\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.fileSaved(doc); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called after a file is opened and read into the current document. */\n  public void fileOpened(OpenDefinitionsDocument doc) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.fileOpened(doc); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called after a document is closed. */\n  public void fileClosed(OpenDefinitionsDocument doc) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.fileClosed(doc); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called after a document is reverted. */\n  public void fileReverted(OpenDefinitionsDocument doc) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.fileReverted(doc); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when an undoable edit occurs. */\n  public void undoableEditHappened() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.undoableEditHappened(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called to ask the listeners if it is OK to abandon the current document. */\n  public boolean canAbandonFile(OpenDefinitionsDocument doc) {\n    _lock.startRead();\n    try {\n      for (GlobalModelListener l: _listeners) { if (! l.canAbandonFile(doc)) return false; }\n      return true;\n    }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called to ask the listeners save the file before quitting at the user's option.\n    * @return true if quitting should continue, false if the user cancelled */\n  public boolean quitFile(OpenDefinitionsDocument doc) {\n    _lock.startRead();\n    try {\n      // if one of the listeners returns false (=user cancelled), abort\n      for (GlobalModelListener l: _listeners) { if (!l.quitFile(doc)) return false; }\n    }\n    finally { _lock.endRead(); }\n    return true;\n  }\n  \n  /** Called to ask the listeners if it is OK to revert the current document to the version saved on disk. */\n  public boolean shouldRevertFile(OpenDefinitionsDocument doc) {\n    _lock.startRead();\n    try { \n      for (GlobalModelListener l: _listeners) { if (! l.shouldRevertFile(doc)) return false; }\n      return true;\n    }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when the selection in the navigator changes the current directory without changing the active document. */\n  public void currentDirectoryChanged(File dir) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.currentDirectoryChanged(dir); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when the selection in the navigator changes the active document. */\n  public void activeDocumentChanged(OpenDefinitionsDocument active) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.activeDocumentChanged(active); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when the active document is refreshed.  */\n  public void activeDocumentRefreshed(OpenDefinitionsDocument active) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.activeDocumentRefreshed(active); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called to shift the focus to the Definitions Pane. */\n  public void focusOnDefinitionsPane() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.focusOnDefinitionsPane(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called to shift the focus to the last focus owner among the main frame panes. */\n  public void focusOnLastFocusOwner() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.focusOnLastFocusOwner(); } }\n    finally { _lock.endRead(); }\n  }\n//  /** Called to demand that all files be saved before running the main method of a document. It is up to the caller\n//    * of this method to check if the documents have been saved, using IGetDocuments.hasModifiedDocuments(). This is\n//    * nor used currently, but it is commented out in case it is needed later. \n//    */\n//  public void saveBeforeRun() {\n//    _lock.startRead();\n//    try { for (GlobalModelListener l : _listeners) { l.saveBeforeRun(); } }\n//    finally { _lock.endRead(); }\n//  }\n  \n  //------------------------------ Interactions ------------------------------//\n  \n  /** Called after an interaction is started by the GlobalModel. */\n  public void interactionStarted() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.interactionStarted(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when an interaction has finished running. */\n  public void interactionEnded() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.interactionEnded(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when the interactions window generates a syntax error.\n    * @param offset the error's offset into the InteractionsDocument.\n    * @param length the length of the error.\n    */\n  public void interactionErrorOccurred(int offset, int length) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.interactionErrorOccurred(offset, length); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when the interactionsJVM has begun resetting. */\n  public void interpreterResetting() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.interpreterResetting(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when the interactions window is reset. */\n  public void interpreterReady(File wd) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.interpreterReady(wd); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called if the interpreter reset failed.\n    * @param t Throwable explaining why the reset failed.\n    * (Subclasses must maintain listeners.)\n    */\n  public void interpreterResetFailed(final Throwable t) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.interpreterResetFailed(t); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when the interactions JVM was closed by System.exit or by being aborted. Immediately after this the\n    * interactions will be reset.\n    * @param status the exit code\n    */\n  public void interpreterExited(int status) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.interpreterExited(status); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when the active interpreter is changed.\n    * @param inProgress Whether the new interpreter is processing an interaction (i.e,. whether an interactionEnded\n    *        event will be fired)\n    */\n  public void interpreterChanged(boolean inProgress) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.interpreterChanged(inProgress); } }\n    finally { _lock.endRead(); }\n  }\n  \n  //-------------------------------- Compiler --------------------------------//\n  \n  /** Called after a compile is started by the GlobalModel. */\n  public void compileStarted() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.compileStarted(); }\n    }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when a compile has finished running. */\n  public void compileEnded(File workDir, List<? extends File> excludedFiles) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.compileEnded(workDir, excludedFiles); } }\n    finally { _lock.endRead(); }\n  }\n  \n   /** Called if a compile is aborted. */\n  public void compileAborted(Exception e) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.compileAborted(e); } }\n    finally { _lock.endRead(); }\n  }\n  /** Called to demand that all files be saved before compiling. It is up to the caller of this method to check\n    * if the documents have been saved, using IGetDocuments.hasModifiedDocuments().\n    */\n  public void saveBeforeCompile() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.saveBeforeCompile(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called to demand that the active document, which is untitled, is saved before compiling.  */\n  public void saveUntitled() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.saveUntitled(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called after the active compiler has been changed. */\n  public void activeCompilerChanged() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.activeCompilerChanged(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  //---------------------------------- JUnit ---------------------------------//\n  \n  /** Called when trying to test a non-TestCase class.\n    * @param isTestAll whether or not it was a use of the test all button\n    * @param didCompileFail whether or not a compile before this JUnit attempt failed\n    */\n  public void nonTestCase(boolean isTestAll, boolean didCompileFail) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.nonTestCase(isTestAll, didCompileFail); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when trying to test an illegal class file.\n    * @param e the ClassFileError thrown when DrJava attempted to load the offending file\n    */\n  public void classFileError(ClassFileError e) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.classFileError(e); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called before attempting unit testing if tested class files are out of sync, to give the user a chance to save. Do\n    * not continue with JUnit if the user doesn't recompile!\n    */\n  public void compileBeforeJUnit(final CompilerListener cl, List<OpenDefinitionsDocument> outOfSync) {\n//    Utilities.show(\"compileBeforeJUnit invoked with argument \" + cl + \" in GlobalEventNotifier \" + this);\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.compileBeforeJUnit(cl, outOfSync); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called after JUnit is started by the GlobalModel. */\n  public void junitStarted() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.junitStarted(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when testing specific list of classes. */\n  public void junitClassesStarted() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.junitClassesStarted(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called to indicate that a suite of tests has started running.\n    * @param numTests The number of tests in the suite to be run.\n    */\n  public void junitSuiteStarted(int numTests) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.junitSuiteStarted(numTests); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when a particular test is started.\n    * @param name The name of the test being started.\n    */\n  public void junitTestStarted(String name) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.junitTestStarted(name); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called when a particular test has ended.\n    * @param name the name of the test that has ended\n    * @param wasSuccessful whether the test passed or not\n    * @param causedError if not successful, whether the test caused an error or simply failed\n    */\n  public void junitTestEnded(String name, boolean wasSuccessful, boolean causedError) {\n    _lock.startRead();\n    try { \n      for (GlobalModelListener l : _listeners) { l.junitTestEnded(name, wasSuccessful, causedError); }\n    }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called after JUnit is finished running tests. */\n  public void junitEnded() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.junitEnded(); } }\n    finally { _lock.endRead(); }\n  }\n  \n//  /** Called to demand that all files be saved before running JUnit tests. It is up to the caller of this \n//    * method to check if the documents have been saved, using IGetDocuments.hasModifiedDocuments(). This is \n//    * never called currently, but it is commented out in case it is needed later. */\n//  public void saveBeforeJUnit() {\n//    _lock.startRead();\n//    try {\n//      for (GlobalModelListener l : _listeners) {\n//        l.saveBeforeJUnit();\n//      }\n//    }\n//    finally {\n//      _lock.endRead();\n//    }\n//  }\n  \n  //--------------------------------- Javadoc --------------------------------//\n  \n  /** Called after Javadoc is started by the GlobalModel. */\n  public void javadocStarted() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.javadocStarted(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Called after Javadoc is finished.\n    * @param success whether the Javadoc operation generated proper output\n    * @param destDir if (success) the location where the output was generated, otherwise undefined (possibly null)\n    * @param allDocs Whether Javadoc was run for all open documents\n    */\n  public void javadocEnded(boolean success, File destDir, boolean allDocs) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.javadocEnded(success, destDir, allDocs); } }\n    finally { _lock.endRead(); }\n  }\n  \n  \n  /** Called before attempting Javadoc, to give the user a chance to save. Do not continue with Javadoc if the user \n    * doesn't save!\n    */\n  public void saveBeforeJavadoc() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.saveBeforeJavadoc(); } }\n    finally { _lock.endRead(); }\n  }\n\n  /** Called before attempting Javadoc, to give the user a chance to compile. Do not continue with Javadoc if the\n    * user doesn't comoile!\n    */\n  public void compileBeforeJavadoc(final CompilerListener afterCompile) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.compileBeforeJavadoc(afterCompile); } }\n    finally { _lock.endRead(); }\n  }\n  \n//  /** Called to demand that all files be saved before starting the debugger. It is up to the caller of this method\n//    * to check if the documents have been saved, using IGetDocuments.hasModifiedDocuments(). This is not used \n//    * currently, but it is commented out in case it is needed later. */\n//  public void saveBeforeDebug() {\n//    _lock.startRead();\n//    try { for (GlobalModelListener l : _listeners) { l.saveBeforeDebug(); } }\n//    finally { _lock.endRead(); }\n//  }\n  \n  /** Notifies the view that the current interaction is incomplete. */\n  public void interactionIncomplete() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.interactionIncomplete(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  /** Notifies the view that the current file path contains a #. */\n  public void filePathContainsPound() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.filePathContainsPound(); } }\n    finally { _lock.endRead(); }\n  }\n  \n  // ----- Cache -----\n  public void documentNotFound(OpenDefinitionsDocument d, File f) {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.documentNotFound(d,f); } }\n    finally { _lock.endRead(); } \n  }\n  \n  // ----- BrowserHistory -----\n  public void browserChanged() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.browserChanged(); } }\n    finally { _lock.endRead(); } \n  }\n\n  public void updateCurrentLocationInDoc() {\n    _lock.startRead();\n    try { for (GlobalModelListener l : _listeners) { l.updateCurrentLocationInDoc(); } }\n    finally { _lock.endRead(); } \n  }\n\n/** Tests the Comment Out Line(s) command with multiple lines. \n * @param commentTest TODO*/\n  public void testCommentOutMultipleLines(CommentTest commentTest) throws BadLocationException {\n    String text =\n      \"Here is some abritrary text that should be commented.\\n\" +\n      \"/* It is on multiple lines, and contains slashes // and other\\n\" +\n      \"various */ obnoxious characters.\\n\";\n\n    String commented =\n      \"//Here is some abritrary text that should be commented.\\n\" +\n      \"///* It is on multiple lines, and contains slashes // and other\\n\" +\n      \"//various */ obnoxious characters.\\n\";\n\n    commentTest.doc.insertString(0, text, null);\n    CommentTest._assertContents(\"Sample text is inserted improperly.\", text, commentTest.doc);\n    commentTest.doc.commentLines(0, commentTest.doc.getLength());\n    CommentTest._assertContents(\"These lines should be wing-commented!\", commented, commentTest.doc);\n  }\n}",
                "methodCount": 64
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 2,
                "candidates": [
                    {
                        "lineStart": 637,
                        "lineEnd": 654,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method testCommentOutMultipleLines to class CommentTest",
                        "description": "Move method testCommentOutMultipleLines to edu.rice.cs.drjava.model.definitions.CommentTest\nRationale: The method testCommentOutMultipleLines() is specifically designed to test the functionality of commenting out multiple lines of text, which directly relates to the purpose of the CommentTest class. This class is already responsible for testing comment and uncomment operations, making it the most appropriate location for this method. Moving it to CommentTest will enhance the organization of the code by ensuring that all related testing functionalities are encapsulated within the same class, thereby improving maintainability and readability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 169,
                        "lineEnd": 183,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method pollListeners to class Poller",
                        "description": "Move method pollListeners to edu.rice.cs.drjava.model.GlobalEventNotifier.Poller\nRationale: The method pollListeners() is designed to interact with a collection of listeners and ask them a yes/no question, which aligns closely with the purpose of the Poller class. Since Poller is specifically modeled for asking questions to listeners, moving pollListeners() to this class would encapsulate the functionality related to polling listeners more appropriately. Additionally, the method is marked as deprecated, indicating that its usage is discouraged in favor of direct listener methods, which suggests a need for a clearer separation of responsibilities. By relocating this method to Poller, it reinforces the design principle of keeping related functionalities together, thus enhancing maintainability and clarity in the codebase.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "executeAsyncTask",
                            "method_signature": "public <P,R> void executeAsyncTask(AsyncTask<P,R> task, P param, boolean showProgress, boolean lockUI)",
                            "target_class": "AsyncTaskExecutor",
                            "rationale": "The method executeAsyncTask is responsible for executing asynchronous tasks, which is a behavior that should be encapsulated in a dedicated class for managing asynchronous operations."
                        },
                        {
                            "method_name": "filesNotFound",
                            "method_signature": "public void filesNotFound(File... f)",
                            "target_class": "FileErrorNotifier",
                            "rationale": "The method filesNotFound is specifically related to notifying listeners about file errors, which should be handled by a dedicated notifier class focused on file-related events."
                        },
                        {
                            "method_name": "handleAlreadyOpenDocument",
                            "method_signature": "public void handleAlreadyOpenDocument(OpenDefinitionsDocument doc)",
                            "target_class": "DocumentStateHandler",
                            "rationale": "The method handleAlreadyOpenDocument deals with the state of documents, which is better suited in a class that manages document states and their transitions."
                        },
                        {
                            "method_name": "openProject",
                            "method_signature": "public void openProject(File pfile, FileOpenSelector files)",
                            "target_class": "ProjectManager",
                            "rationale": "The method openProject is responsible for project management tasks, which should be encapsulated in a dedicated ProjectManager class."
                        },
                        {
                            "method_name": "projectClosed",
                            "method_signature": "public void projectClosed()",
                            "target_class": "ProjectManager",
                            "rationale": "The method projectClosed is related to project lifecycle management and should be part of a ProjectManager class."
                        },
                        {
                            "method_name": "allFilesClosed",
                            "method_signature": "public void allFilesClosed()",
                            "target_class": "FileManager",
                            "rationale": "The method allFilesClosed is related to managing the state of files and should be moved to a dedicated FileManager class."
                        },
                        {
                            "method_name": "projectModified",
                            "method_signature": "public void projectModified()",
                            "target_class": "ProjectManager",
                            "rationale": "The method projectModified is related to project state changes and should be part of a ProjectManager class."
                        },
                        {
                            "method_name": "projectBuildDirChanged",
                            "method_signature": "public void projectBuildDirChanged()",
                            "target_class": "ProjectManager",
                            "rationale": "The method projectBuildDirChanged is related to project configuration changes and should be managed by a ProjectManager class."
                        },
                        {
                            "method_name": "projectWorkDirChanged",
                            "method_signature": "public void projectWorkDirChanged()",
                            "target_class": "ProjectManager",
                            "rationale": "The method projectWorkDirChanged is related to project configuration changes and should be managed by a ProjectManager class."
                        },
                        {
                            "method_name": "projectRunnableChanged",
                            "method_signature": "public void projectRunnableChanged()",
                            "target_class": "ProjectManager",
                            "rationale": "The method projectRunnableChanged is related to project configuration changes and should be managed by a ProjectManager class."
                        },
                        {
                            "method_name": "prepareForRun",
                            "method_signature": "public void prepareForRun(OpenDefinitionsDocument doc)",
                            "target_class": "RunManager",
                            "rationale": "The method prepareForRun is related to preparing documents for execution and should be part of a RunManager class."
                        },
                        {
                            "method_name": "newFileCreated",
                            "method_signature": "public void newFileCreated(OpenDefinitionsDocument doc)",
                            "target_class": "FileManager",
                            "rationale": "The method newFileCreated is related to file management and should be part of a dedicated FileManager class."
                        },
                        {
                            "method_name": "consoleReset",
                            "method_signature": "public void consoleReset()",
                            "target_class": "ConsoleManager",
                            "rationale": "The method consoleReset is related to managing the console state and should be part of a ConsoleManager class."
                        },
                        {
                            "method_name": "fileSaved",
                            "method_signature": "public void fileSaved(OpenDefinitionsDocument doc)",
                            "target_class": "FileManager",
                            "rationale": "The method fileSaved is related to file management and should be part of a dedicated FileManager class."
                        },
                        {
                            "method_name": "fileOpened",
                            "method_signature": "public void fileOpened(OpenDefinitionsDocument doc)",
                            "target_class": "FileManager",
                            "rationale": "The method fileOpened is related to file management and should be part of a dedicated FileManager class."
                        },
                        {
                            "method_name": "fileClosed",
                            "method_signature": "public void fileClosed(OpenDefinitionsDocument doc)",
                            "target_class": "FileManager",
                            "rationale": "The method fileClosed is related to file management and should be part of a dedicated FileManager class."
                        },
                        {
                            "method_name": "fileReverted",
                            "method_signature": "public void fileReverted(OpenDefinitionsDocument doc)",
                            "target_class": "FileManager",
                            "rationale": "The method fileReverted is related to file management and should be part of a dedicated FileManager class."
                        },
                        {
                            "method_name": "undoableEditHappened",
                            "method_signature": "public void undoableEditHappened()",
                            "target_class": "EditManager",
                            "rationale": "The method undoableEditHappened is related to managing edits and should be part of an EditManager class."
                        },
                        {
                            "method_name": "canAbandonFile",
                            "method_signature": "public boolean canAbandonFile(OpenDefinitionsDocument doc)",
                            "target_class": "FileManager",
                            "rationale": "The method canAbandonFile is related to file management and should be part of a dedicated FileManager class."
                        },
                        {
                            "method_name": "quitFile",
                            "method_signature": "public boolean quitFile(OpenDefinitionsDocument doc)",
                            "target_class": "FileManager",
                            "rationale": "The method quitFile is related to file management and should be part of a dedicated FileManager class."
                        },
                        {
                            "method_name": "shouldRevertFile",
                            "method_signature": "public boolean shouldRevertFile(OpenDefinitionsDocument doc)",
                            "target_class": "FileManager",
                            "rationale": "The method shouldRevertFile is related to file management and should be part of a dedicated FileManager class."
                        },
                        {
                            "method_name": "currentDirectoryChanged",
                            "method_signature": "public void currentDirectoryChanged(File dir)",
                            "target_class": "DirectoryManager",
                            "rationale": "The method currentDirectoryChanged is related to managing directory changes and should be part of a DirectoryManager class."
                        },
                        {
                            "method_name": "activeDocumentChanged",
                            "method_signature": "public void activeDocumentChanged(OpenDefinitionsDocument active)",
                            "target_class": "DocumentManager",
                            "rationale": "The method activeDocumentChanged is related to managing the active document state and should be part of a DocumentManager class."
                        },
                        {
                            "method_name": "activeDocumentRefreshed",
                            "method_signature": "public void activeDocumentRefreshed(OpenDefinitionsDocument active)",
                            "target_class": "DocumentManager",
                            "rationale": "The method activeDocumentRefreshed is related to managing the active document state and should be part of a DocumentManager class."
                        },
                        {
                            "method_name": "focusOnDefinitionsPane",
                            "method_signature": "public void focusOnDefinitionsPane()",
                            "target_class": "FocusManager",
                            "rationale": "The method focusOnDefinitionsPane is related to managing focus within the application and should be part of a FocusManager class."
                        },
                        {
                            "method_name": "focusOnLastFocusOwner",
                            "method_signature": "public void focusOnLastFocusOwner()",
                            "target_class": "FocusManager",
                            "rationale": "The method focusOnLastFocusOwner is related to managing focus within the application and should be part of a FocusManager class."
                        },
                        {
                            "method_name": "interactionStarted",
                            "method_signature": "public void interactionStarted()",
                            "target_class": "InteractionManager",
                            "rationale": "The method interactionStarted is related to managing interactions and should be part of an InteractionManager class."
                        },
                        {
                            "method_name": "interactionEnded",
                            "method_signature": "public void interactionEnded()",
                            "target_class": "InteractionManager",
                            "rationale": "The method interactionEnded is related to managing interactions and should be part of an InteractionManager class."
                        },
                        {
                            "method_name": "interactionErrorOccurred",
                            "method_signature": "public void interactionErrorOccurred(int offset, int length)",
                            "target_class": "InteractionManager",
                            "rationale": "The method interactionErrorOccurred is related to managing interactions and should be part of an InteractionManager class."
                        },
                        {
                            "method_name": "interpreterResetting",
                            "method_signature": "public void interpreterResetting()",
                            "target_class": "InterpreterManager",
                            "rationale": "The method interpreterResetting is related to managing the interpreter state and should be part of an InterpreterManager class."
                        },
                        {
                            "method_name": "interpreterReady",
                            "method_signature": "public void interpreterReady(File wd)",
                            "target_class": "InterpreterManager",
                            "rationale": "The method interpreterReady is related to managing the interpreter state and should be part of an InterpreterManager class."
                        },
                        {
                            "method_name": "interpreterResetFailed",
                            "method_signature": "public void interpreterResetFailed(final Throwable t)",
                            "target_class": "InterpreterManager",
                            "rationale": "The method interpreterResetFailed is related to managing the interpreter state and should be part of an InterpreterManager class."
                        },
                        {
                            "method_name": "interpreterExited",
                            "method_signature": "public void interpreterExited(int status)",
                            "target_class": "InterpreterManager",
                            "rationale": "The method interpreterExited is related to managing the interpreter state and should be part of an InterpreterManager class."
                        },
                        {
                            "method_name": "interpreterChanged",
                            "method_signature": "public void interpreterChanged(boolean inProgress)",
                            "target_class": "InterpreterManager",
                            "rationale": "The method interpreterChanged is related to managing the interpreter state and should be part of an InterpreterManager class."
                        },
                        {
                            "method_name": "compileStarted",
                            "method_signature": "public void compileStarted()",
                            "target_class": "CompileManager",
                            "rationale": "The method compileStarted is related to managing compilation processes and should be part of a CompileManager class."
                        },
                        {
                            "method_name": "compileEnded",
                            "method_signature": "public void compileEnded(File workDir, List<? extends File> excludedFiles)",
                            "target_class": "CompileManager",
                            "rationale": "The method compileEnded is related to managing compilation processes and should be part of a CompileManager class."
                        },
                        {
                            "method_name": "compileAborted",
                            "method_signature": "public void compileAborted(Exception e)",
                            "target_class": "CompileManager",
                            "rationale": "The method compileAborted is related to managing compilation processes and should be part of a CompileManager class."
                        },
                        {
                            "method_name": "saveBeforeCompile",
                            "method_signature": "public void saveBeforeCompile()",
                            "target_class": "CompileManager",
                            "rationale": "The method saveBeforeCompile is related to managing compilation processes and should be part of a CompileManager class."
                        },
                        {
                            "method_name": "saveUntitled",
                            "method_signature": "public void saveUntitled()",
                            "target_class": "FileManager",
                            "rationale": "The method saveUntitled is related to file management and should be part of a dedicated FileManager class."
                        },
                        {
                            "method_name": "activeCompilerChanged",
                            "method_signature": "public void activeCompilerChanged()",
                            "target_class": "CompileManager",
                            "rationale": "The method activeCompilerChanged is related to managing compilation processes and should be part of a CompileManager class."
                        },
                        {
                            "method_name": "nonTestCase",
                            "method_signature": "public void nonTestCase(boolean isTestAll, boolean didCompileFail)",
                            "target_class": "JUnitManager",
                            "rationale": "The method nonTestCase is related to managing JUnit testing processes and should be part of a JUnitManager class."
                        },
                        {
                            "method_name": "classFileError",
                            "method_signature": "public void classFileError(ClassFileError e)",
                            "target_class": "JUnitManager",
                            "rationale": "The method classFileError is related to managing JUnit testing processes and should be part of a JUnitManager class."
                        },
                        {
                            "method_name": "compileBeforeJUnit",
                            "method_signature": "public void compileBeforeJUnit(final CompilerListener cl, List<OpenDefinitionsDocument> outOfSync)",
                            "target_class": "JUnitManager",
                            "rationale": "The method compileBeforeJUnit is related to managing JUnit testing processes and should be part of a JUnitManager class."
                        },
                        {
                            "method_name": "junitStarted",
                            "method_signature": "public void junitStarted()",
                            "target_class": "JUnitManager",
                            "rationale": "The method junitStarted is related to managing JUnit testing processes and should be part of a JUnitManager class."
                        },
                        {
                            "method_name": "junitClassesStarted",
                            "method_signature": "public void junitClassesStarted()",
                            "target_class": "JUnitManager",
                            "rationale": "The method junitClassesStarted is related to managing JUnit testing processes and should be part of a JUnitManager class."
                        },
                        {
                            "method_name": "junitSuiteStarted",
                            "method_signature": "public void junitSuiteStarted(int numTests)",
                            "target_class": "JUnitManager",
                            "rationale": "The method junitSuiteStarted is related to managing JUnit testing processes and should be part of a JUnitManager class."
                        },
                        {
                            "method_name": "junitTestStarted",
                            "method_signature": "public void junitTestStarted(String name)",
                            "target_class": "JUnitManager",
                            "rationale": "The method junitTestStarted is related to managing JUnit testing processes and should be part of a JUnitManager class."
                        },
                        {
                            "method_name": "junitTestEnded",
                            "method_signature": "public void junitTestEnded(String name, boolean wasSuccessful, boolean causedError)",
                            "target_class": "JUnitManager",
                            "rationale": "The method junitTestEnded is related to managing JUnit testing processes and should be part of a JUnitManager class."
                        },
                        {
                            "method_name": "junitEnded",
                            "method_signature": "public void junitEnded()",
                            "target_class": "JUnitManager",
                            "rationale": "The method junitEnded is related to managing JUnit testing processes and should be part of a JUnitManager class."
                        },
                        {
                            "method_name": "javadocStarted",
                            "method_signature": "public void javadocStarted()",
                            "target_class": "JavadocManager",
                            "rationale": "The method javadocStarted is related to managing Javadoc generation processes and should be part of a JavadocManager class."
                        },
                        {
                            "method_name": "javadocEnded",
                            "method_signature": "public void javadocEnded(boolean success, File destDir, boolean allDocs)",
                            "target_class": "JavadocManager",
                            "rationale": "The method javadocEnded is related to managing Javadoc generation processes and should be part of a JavadocManager class."
                        },
                        {
                            "method_name": "saveBeforeJavadoc",
                            "method_signature": "public void saveBeforeJavadoc()",
                            "target_class": "JavadocManager",
                            "rationale": "The method saveBeforeJavadoc is related to managing Javadoc generation processes and should be part of a JavadocManager class."
                        },
                        {
                            "method_name": "compileBeforeJavadoc",
                            "method_signature": "public void compileBeforeJavadoc(final CompilerListener afterCompile)",
                            "target_class": "JavadocManager",
                            "rationale": "The method compileBeforeJavadoc is related to managing Javadoc generation processes and should be part of a JavadocManager class."
                        },
                        {
                            "method_name": "interactionIncomplete",
                            "method_signature": "public void interactionIncomplete()",
                            "target_class": "InteractionManager",
                            "rationale": "The method interactionIncomplete is related to managing interactions and should be part of an InteractionManager class."
                        },
                        {
                            "method_name": "filePathContainsPound",
                            "method_signature": "public void filePathContainsPound()",
                            "target_class": "FileManager",
                            "rationale": "The method filePathContainsPound is related to file management and should be part of a dedicated FileManager class."
                        },
                        {
                            "method_name": "documentNotFound",
                            "method_signature": "public void documentNotFound(OpenDefinitionsDocument d, File f)",
                            "target_class": "FileErrorNotifier",
                            "rationale": "The method documentNotFound is specifically related to notifying listeners about document errors, which should be handled by a dedicated notifier class focused on document-related events."
                        },
                        {
                            "method_name": "browserChanged",
                            "method_signature": "public void browserChanged()",
                            "target_class": "BrowserManager",
                            "rationale": "The method browserChanged is related to managing browser state and should be part of a BrowserManager class."
                        },
                        {
                            "method_name": "updateCurrentLocationInDoc",
                            "method_signature": "public void updateCurrentLocationInDoc()",
                            "target_class": "DocumentManager",
                            "rationale": "The method updateCurrentLocationInDoc is related to managing document state and should be part of a DocumentManager class."
                        },
                        {
                            "method_name": "testCommentOutMultipleLines",
                            "method_signature": "public void testCommentOutMultipleLines(CommentTest commentTest) throws BadLocationException",
                            "target_class": "CommentTestManager",
                            "rationale": "The method testCommentOutMultipleLines is related to testing comment functionality and should be part of a dedicated CommentTestManager class."
                        }
                    ],
                    "llm_response_time": 111695
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "executeAsyncTask",
                            "method_signature": "public <P,R> void executeAsyncTask(AsyncTask<P,R> task, P param, boolean showProgress, boolean lockUI)",
                            "target_class": "AsyncTaskExecutor",
                            "rationale": "The method executeAsyncTask is responsible for executing asynchronous tasks, which is a behavior that should be encapsulated in a dedicated class for managing asynchronous operations."
                        },
                        {
                            "method_name": "filesNotFound",
                            "method_signature": "public void filesNotFound(File... f)",
                            "target_class": "FileEventNotifier",
                            "rationale": "The method filesNotFound is specifically related to file events and should be moved to a class that handles file-related notifications."
                        },
                        {
                            "method_name": "handleAlreadyOpenDocument",
                            "method_signature": "public void handleAlreadyOpenDocument(OpenDefinitionsDocument doc)",
                            "target_class": "DocumentEventNotifier",
                            "rationale": "The method handleAlreadyOpenDocument deals with document-specific events and should be moved to a class that manages document-related notifications."
                        },
                        {
                            "method_name": "openProject",
                            "method_signature": "public void openProject(File pfile, FileOpenSelector files)",
                            "target_class": "ProjectEventNotifier",
                            "rationale": "The method openProject is related to project management and should be moved to a class that handles project-related notifications."
                        },
                        {
                            "method_name": "projectClosed",
                            "method_signature": "public void projectClosed()",
                            "target_class": "ProjectEventNotifier",
                            "rationale": "The method projectClosed is related to project management and should be moved to a class that handles project-related notifications."
                        },
                        {
                            "method_name": "allFilesClosed",
                            "method_signature": "public void allFilesClosed()",
                            "target_class": "FileEventNotifier",
                            "rationale": "The method allFilesClosed is related to file management and should be moved to a class that handles file-related notifications."
                        },
                        {
                            "method_name": "projectModified",
                            "method_signature": "public void projectModified()",
                            "target_class": "ProjectEventNotifier",
                            "rationale": "The method projectModified is related to project management and should be moved to a class that handles project-related notifications."
                        },
                        {
                            "method_name": "projectBuildDirChanged",
                            "method_signature": "public void projectBuildDirChanged()",
                            "target_class": "ProjectEventNotifier",
                            "rationale": "The method projectBuildDirChanged is related to project management and should be moved to a class that handles project-related notifications."
                        },
                        {
                            "method_name": "projectWorkDirChanged",
                            "method_signature": "public void projectWorkDirChanged()",
                            "target_class": "ProjectEventNotifier",
                            "rationale": "The method projectWorkDirChanged is related to project management and should be moved to a class that handles project-related notifications."
                        },
                        {
                            "method_name": "projectRunnableChanged",
                            "method_signature": "public void projectRunnableChanged()",
                            "target_class": "ProjectEventNotifier",
                            "rationale": "The method projectRunnableChanged is related to project management and should be moved to a class that handles project-related notifications."
                        },
                        {
                            "method_name": "prepareForRun",
                            "method_signature": "public void prepareForRun(OpenDefinitionsDocument doc)",
                            "target_class": "RunEventNotifier",
                            "rationale": "The method prepareForRun is related to preparing documents for execution and should be moved to a class that handles run-related notifications."
                        },
                        {
                            "method_name": "newFileCreated",
                            "method_signature": "public void newFileCreated(OpenDefinitionsDocument doc)",
                            "target_class": "FileEventNotifier",
                            "rationale": "The method newFileCreated is related to file management and should be moved to a class that handles file-related notifications."
                        },
                        {
                            "method_name": "consoleReset",
                            "method_signature": "public void consoleReset()",
                            "target_class": "ConsoleEventNotifier",
                            "rationale": "The method consoleReset is related to console management and should be moved to a class that handles console-related notifications."
                        },
                        {
                            "method_name": "fileSaved",
                            "method_signature": "public void fileSaved(OpenDefinitionsDocument doc)",
                            "target_class": "FileEventNotifier",
                            "rationale": "The method fileSaved is related to file management and should be moved to a class that handles file-related notifications."
                        },
                        {
                            "method_name": "fileOpened",
                            "method_signature": "public void fileOpened(OpenDefinitionsDocument doc)",
                            "target_class": "FileEventNotifier",
                            "rationale": "The method fileOpened is related to file management and should be moved to a class that handles file-related notifications."
                        },
                        {
                            "method_name": "fileClosed",
                            "method_signature": "public void fileClosed(OpenDefinitionsDocument doc)",
                            "target_class": "FileEventNotifier",
                            "rationale": "The method fileClosed is related to file management and should be moved to a class that handles file-related notifications."
                        },
                        {
                            "method_name": "fileReverted",
                            "method_signature": "public void fileReverted(OpenDefinitionsDocument doc)",
                            "target_class": "FileEventNotifier",
                            "rationale": "The method fileReverted is related to file management and should be moved to a class that handles file-related notifications."
                        },
                        {
                            "method_name": "undoableEditHappened",
                            "method_signature": "public void undoableEditHappened()",
                            "target_class": "EditEventNotifier",
                            "rationale": "The method undoableEditHappened is related to edit management and should be moved to a class that handles edit-related notifications."
                        },
                        {
                            "method_name": "canAbandonFile",
                            "method_signature": "public boolean canAbandonFile(OpenDefinitionsDocument doc)",
                            "target_class": "FileEventNotifier",
                            "rationale": "The method canAbandonFile is related to file management and should be moved to a class that handles file-related notifications."
                        },
                        {
                            "method_name": "quitFile",
                            "method_signature": "public boolean quitFile(OpenDefinitionsDocument doc)",
                            "target_class": "FileEventNotifier",
                            "rationale": "The method quitFile is related to file management and should be moved to a class that handles file-related notifications."
                        },
                        {
                            "method_name": "shouldRevertFile",
                            "method_signature": "public boolean shouldRevertFile(OpenDefinitionsDocument doc)",
                            "target_class": "FileEventNotifier",
                            "rationale": "The method shouldRevertFile is related to file management and should be moved to a class that handles file-related notifications."
                        },
                        {
                            "method_name": "currentDirectoryChanged",
                            "method_signature": "public void currentDirectoryChanged(File dir)",
                            "target_class": "DirectoryEventNotifier",
                            "rationale": "The method currentDirectoryChanged is related to directory management and should be moved to a class that handles directory-related notifications."
                        },
                        {
                            "method_name": "activeDocumentChanged",
                            "method_signature": "public void activeDocumentChanged(OpenDefinitionsDocument active)",
                            "target_class": "DocumentEventNotifier",
                            "rationale": "The method activeDocumentChanged is related to document management and should be moved to a class that handles document-related notifications."
                        },
                        {
                            "method_name": "activeDocumentRefreshed",
                            "method_signature": "public void activeDocumentRefreshed(OpenDefinitionsDocument active)",
                            "target_class": "DocumentEventNotifier",
                            "rationale": "The method activeDocumentRefreshed is related to document management and should be moved to a class that handles document-related notifications."
                        },
                        {
                            "method_name": "focusOnDefinitionsPane",
                            "method_signature": "public void focusOnDefinitionsPane()",
                            "target_class": "FocusEventNotifier",
                            "rationale": "The method focusOnDefinitionsPane is related to UI focus management and should be moved to a class that handles focus-related notifications."
                        },
                        {
                            "method_name": "focusOnLastFocusOwner",
                            "method_signature": "public void focusOnLastFocusOwner()",
                            "target_class": "FocusEventNotifier",
                            "rationale": "The method focusOnLastFocusOwner is related to UI focus management and should be moved to a class that handles focus-related notifications."
                        },
                        {
                            "method_name": "interactionStarted",
                            "method_signature": "public void interactionStarted()",
                            "target_class": "InteractionEventNotifier",
                            "rationale": "The method interactionStarted is related to interaction management and should be moved to a class that handles interaction-related notifications."
                        },
                        {
                            "method_name": "interactionEnded",
                            "method_signature": "public void interactionEnded()",
                            "target_class": "InteractionEventNotifier",
                            "rationale": "The method interactionEnded is related to interaction management and should be moved to a class that handles interaction-related notifications."
                        },
                        {
                            "method_name": "interactionErrorOccurred",
                            "method_signature": "public void interactionErrorOccurred(int offset, int length)",
                            "target_class": "InteractionEventNotifier",
                            "rationale": "The method interactionErrorOccurred is related to interaction management and should be moved to a class that handles interaction-related notifications."
                        },
                        {
                            "method_name": "interpreterResetting",
                            "method_signature": "public void interpreterResetting()",
                            "target_class": "InterpreterEventNotifier",
                            "rationale": "The method interpreterResetting is related to interpreter management and should be moved to a class that handles interpreter-related notifications."
                        },
                        {
                            "method_name": "interpreterReady",
                            "method_signature": "public void interpreterReady(File wd)",
                            "target_class": "InterpreterEventNotifier",
                            "rationale": "The method interpreterReady is related to interpreter management and should be moved to a class that handles interpreter-related notifications."
                        },
                        {
                            "method_name": "interpreterResetFailed",
                            "method_signature": "public void interpreterResetFailed(final Throwable t)",
                            "target_class": "InterpreterEventNotifier",
                            "rationale": "The method interpreterResetFailed is related to interpreter management and should be moved to a class that handles interpreter-related notifications."
                        },
                        {
                            "method_name": "interpreterExited",
                            "method_signature": "public void interpreterExited(int status)",
                            "target_class": "InterpreterEventNotifier",
                            "rationale": "The method interpreterExited is related to interpreter management and should be moved to a class that handles interpreter-related notifications."
                        },
                        {
                            "method_name": "interpreterChanged",
                            "method_signature": "public void interpreterChanged(boolean inProgress)",
                            "target_class": "InterpreterEventNotifier",
                            "rationale": "The method interpreterChanged is related to interpreter management and should be moved to a class that handles interpreter-related notifications."
                        },
                        {
                            "method_name": "compileStarted",
                            "method_signature": "public void compileStarted()",
                            "target_class": "CompileEventNotifier",
                            "rationale": "The method compileStarted is related to compilation management and should be moved to a class that handles compile-related notifications."
                        },
                        {
                            "method_name": "compileEnded",
                            "method_signature": "public void compileEnded(File workDir, List<? extends File> excludedFiles)",
                            "target_class": "CompileEventNotifier",
                            "rationale": "The method compileEnded is related to compilation management and should be moved to a class that handles compile-related notifications."
                        },
                        {
                            "method_name": "compileAborted",
                            "method_signature": "public void compileAborted(Exception e)",
                            "target_class": "CompileEventNotifier",
                            "rationale": "The method compileAborted is related to compilation management and should be moved to a class that handles compile-related notifications."
                        },
                        {
                            "method_name": "saveBeforeCompile",
                            "method_signature": "public void saveBeforeCompile()",
                            "target_class": "CompileEventNotifier",
                            "rationale": "The method saveBeforeCompile is related to compilation management and should be moved to a class that handles compile-related notifications."
                        },
                        {
                            "method_name": "saveUntitled",
                            "method_signature": "public void saveUntitled()",
                            "target_class": "CompileEventNotifier",
                            "rationale": "The method saveUntitled is related to compilation management and should be moved to a class that handles compile-related notifications."
                        },
                        {
                            "method_name": "activeCompilerChanged",
                            "method_signature": "public void activeCompilerChanged()",
                            "target_class": "CompileEventNotifier",
                            "rationale": "The method activeCompilerChanged is related to compilation management and should be moved to a class that handles compile-related notifications."
                        },
                        {
                            "method_name": "nonTestCase",
                            "method_signature": "public void nonTestCase(boolean isTestAll, boolean didCompileFail)",
                            "target_class": "JUnitEventNotifier",
                            "rationale": "The method nonTestCase is related to JUnit testing and should be moved to a class that handles JUnit-related notifications."
                        },
                        {
                            "method_name": "classFileError",
                            "method_signature": "public void classFileError(ClassFileError e)",
                            "target_class": "JUnitEventNotifier",
                            "rationale": "The method classFileError is related to JUnit testing and should be moved to a class that handles JUnit-related notifications."
                        },
                        {
                            "method_name": "compileBeforeJUnit",
                            "method_signature": "public void compileBeforeJUnit(final CompilerListener cl, List<OpenDefinitionsDocument> outOfSync)",
                            "target_class": "JUnitEventNotifier",
                            "rationale": "The method compileBeforeJUnit is related to JUnit testing and should be moved to a class that handles JUnit-related notifications."
                        },
                        {
                            "method_name": "junitStarted",
                            "method_signature": "public void junitStarted()",
                            "target_class": "JUnitEventNotifier",
                            "rationale": "The method junitStarted is related to JUnit testing and should be moved to a class that handles JUnit-related notifications."
                        },
                        {
                            "method_name": "junitClassesStarted",
                            "method_signature": "public void junitClassesStarted()",
                            "target_class": "JUnitEventNotifier",
                            "rationale": "The method junitClassesStarted is related to JUnit testing and should be moved to a class that handles JUnit-related notifications."
                        },
                        {
                            "method_name": "junitSuiteStarted",
                            "method_signature": "public void junitSuiteStarted(int numTests)",
                            "target_class": "JUnitEventNotifier",
                            "rationale": "The method junitSuiteStarted is related to JUnit testing and should be moved to a class that handles JUnit-related notifications."
                        },
                        {
                            "method_name": "junitTestStarted",
                            "method_signature": "public void junitTestStarted(String name)",
                            "target_class": "JUnitEventNotifier",
                            "rationale": "The method junitTestStarted is related to JUnit testing and should be moved to a class that handles JUnit-related notifications."
                        },
                        {
                            "method_name": "junitTestEnded",
                            "method_signature": "public void junitTestEnded(String name, boolean wasSuccessful, boolean causedError)",
                            "target_class": "JUnitEventNotifier",
                            "rationale": "The method junitTestEnded is related to JUnit testing and should be moved to a class that handles JUnit-related notifications."
                        },
                        {
                            "method_name": "junitEnded",
                            "method_signature": "public void junitEnded()",
                            "target_class": "JUnitEventNotifier",
                            "rationale": "The method junitEnded is related to JUnit testing and should be moved to a class that handles JUnit-related notifications."
                        },
                        {
                            "method_name": "javadocStarted",
                            "method_signature": "public void javadocStarted()",
                            "target_class": "JavadocEventNotifier",
                            "rationale": "The method javadocStarted is related to Javadoc generation and should be moved to a class that handles Javadoc-related notifications."
                        },
                        {
                            "method_name": "javadocEnded",
                            "method_signature": "public void javadocEnded(boolean success, File destDir, boolean allDocs)",
                            "target_class": "JavadocEventNotifier",
                            "rationale": "The method javadocEnded is related to Javadoc generation and should be moved to a class that handles Javadoc-related notifications."
                        },
                        {
                            "method_name": "saveBeforeJavadoc",
                            "method_signature": "public void saveBeforeJavadoc()",
                            "target_class": "JavadocEventNotifier",
                            "rationale": "The method saveBeforeJavadoc is related to Javadoc generation and should be moved to a class that handles Javadoc-related notifications."
                        },
                        {
                            "method_name": "compileBeforeJavadoc",
                            "method_signature": "public void compileBeforeJavadoc(final CompilerListener afterCompile)",
                            "target_class": "JavadocEventNotifier",
                            "rationale": "The method compileBeforeJavadoc is related to Javadoc generation and should be moved to a class that handles Javadoc-related notifications."
                        },
                        {
                            "method_name": "interactionIncomplete",
                            "method_signature": "public void interactionIncomplete()",
                            "target_class": "InteractionEventNotifier",
                            "rationale": "The method interactionIncomplete is related to interaction management and should be moved to a class that handles interaction-related notifications."
                        },
                        {
                            "method_name": "filePathContainsPound",
                            "method_signature": "public void filePathContainsPound()",
                            "target_class": "FileEventNotifier",
                            "rationale": "The method filePathContainsPound is related to file management and should be moved to a class that handles file-related notifications."
                        },
                        {
                            "method_name": "documentNotFound",
                            "method_signature": "public void documentNotFound(OpenDefinitionsDocument d, File f)",
                            "target_class": "FileEventNotifier",
                            "rationale": "The method documentNotFound is related to file management and should be moved to a class that handles file-related notifications."
                        },
                        {
                            "method_name": "browserChanged",
                            "method_signature": "public void browserChanged()",
                            "target_class": "BrowserEventNotifier",
                            "rationale": "The method browserChanged is related to browser management and should be moved to a class that handles browser-related notifications."
                        },
                        {
                            "method_name": "updateCurrentLocationInDoc",
                            "method_signature": "public void updateCurrentLocationInDoc()",
                            "target_class": "DocumentEventNotifier",
                            "rationale": "The method updateCurrentLocationInDoc is related to document management and should be moved to a class that handles document-related notifications."
                        },
                        {
                            "method_name": "testCommentOutMultipleLines",
                            "method_signature": "public void testCommentOutMultipleLines(CommentTest commentTest) throws BadLocationException",
                            "target_class": "CommentTestExecutor",
                            "rationale": "The method testCommentOutMultipleLines is a test method and should be moved to a dedicated class for executing comment tests."
                        }
                    ],
                    "llm_response_time": 52782
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "executeAsyncTask",
                            "method_signature": "public <P,R> void executeAsyncTask(AsyncTask<P,R> task, P param, boolean showProgress, boolean lockUI)",
                            "target_class": "AsyncTaskExecutor",
                            "rationale": "The method executeAsyncTask is responsible for executing asynchronous tasks, which is a separate concern from managing event listeners. Moving it to a dedicated AsyncTaskExecutor class would improve separation of concerns."
                        },
                        {
                            "method_name": "filesNotFound",
                            "method_signature": "public void filesNotFound(File... f)",
                            "target_class": "FileEventNotifier",
                            "rationale": "The filesNotFound method specifically deals with file-related events. Moving it to a FileEventNotifier class would better encapsulate file event handling."
                        },
                        {
                            "method_name": "openProject",
                            "method_signature": "public void openProject(File pfile, FileOpenSelector files)",
                            "target_class": "ProjectEventNotifier",
                            "rationale": "The openProject method is related to project management events. It should be moved to a ProjectEventNotifier class to better organize project-related notifications."
                        },
                        {
                            "method_name": "projectClosed",
                            "method_signature": "public void projectClosed()",
                            "target_class": "ProjectEventNotifier",
                            "rationale": "Similar to openProject, projectClosed is also related to project management. Moving it to a ProjectEventNotifier class would enhance clarity and organization."
                        },
                        {
                            "method_name": "projectModified",
                            "method_signature": "public void projectModified()",
                            "target_class": "ProjectEventNotifier",
                            "rationale": "The projectModified method is also related to project state changes. It should be moved to a ProjectEventNotifier class for better organization."
                        },
                        {
                            "method_name": "compileStarted",
                            "method_signature": "public void compileStarted()",
                            "target_class": "CompileEventNotifier",
                            "rationale": "The compileStarted method is related to compilation events. Moving it to a CompileEventNotifier class would help separate compilation-related notifications."
                        },
                        {
                            "method_name": "javadocStarted",
                            "method_signature": "public void javadocStarted()",
                            "target_class": "JavadocEventNotifier",
                            "rationale": "The javadocStarted method is specifically related to Javadoc generation events. It should be moved to a JavadocEventNotifier class to better encapsulate Javadoc-related notifications."
                        },
                        {
                            "method_name": "interactionStarted",
                            "method_signature": "public void interactionStarted()",
                            "target_class": "InteractionEventNotifier",
                            "rationale": "The interactionStarted method is related to interaction events. Moving it to an InteractionEventNotifier class would improve organization and clarity."
                        },
                        {
                            "method_name": "testCommentOutMultipleLines",
                            "method_signature": "public void testCommentOutMultipleLines(CommentTest commentTest) throws BadLocationException",
                            "target_class": "CommentTestExecutor",
                            "rationale": "The testCommentOutMultipleLines method is a test case and should be moved to a dedicated CommentTestExecutor class to separate testing logic from event notification logic."
                        }
                    ],
                    "llm_response_time": 10483
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "executeAsyncTask",
                            "method_signature": "public executeAsyncTask(AsyncTask<P,R> task, P param, boolean showProgress, boolean lockUI)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "filesNotFound",
                            "method_signature": "public filesNotFound(File... f)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "filesReadOnly",
                            "method_signature": "public filesReadOnly(File... f)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleAlreadyOpenDocument",
                            "method_signature": "public handleAlreadyOpenDocument(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "openProject",
                            "method_signature": "public openProject(File pfile, FileOpenSelector files)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "projectClosed",
                            "method_signature": "public projectClosed()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "allFilesClosed",
                            "method_signature": "public allFilesClosed()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "projectModified",
                            "method_signature": "public projectModified()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "projectBuildDirChanged",
                            "method_signature": "public projectBuildDirChanged()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "projectWorkDirChanged",
                            "method_signature": "public projectWorkDirChanged()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "projectRunnableChanged",
                            "method_signature": "public projectRunnableChanged()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "notifyListeners",
                            "method_signature": "public notifyListeners(Notifier n)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "pollListeners",
                            "method_signature": "@Deprecated\n  public pollListeners(Poller p)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "prepareForRun",
                            "method_signature": "public prepareForRun(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "newFileCreated",
                            "method_signature": "public newFileCreated(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "consoleReset",
                            "method_signature": "public consoleReset()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "fileSaved",
                            "method_signature": "public fileSaved(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "fileOpened",
                            "method_signature": "public fileOpened(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "fileClosed",
                            "method_signature": "public fileClosed(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "fileReverted",
                            "method_signature": "public fileReverted(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "undoableEditHappened",
                            "method_signature": "public undoableEditHappened()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "canAbandonFile",
                            "method_signature": "public canAbandonFile(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "quitFile",
                            "method_signature": "public quitFile(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "shouldRevertFile",
                            "method_signature": "public shouldRevertFile(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "currentDirectoryChanged",
                            "method_signature": "public currentDirectoryChanged(File dir)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "activeDocumentChanged",
                            "method_signature": "public activeDocumentChanged(OpenDefinitionsDocument active)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "activeDocumentRefreshed",
                            "method_signature": "public activeDocumentRefreshed(OpenDefinitionsDocument active)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "focusOnDefinitionsPane",
                            "method_signature": "public focusOnDefinitionsPane()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "focusOnLastFocusOwner",
                            "method_signature": "public focusOnLastFocusOwner()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interactionStarted",
                            "method_signature": "public interactionStarted()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interactionEnded",
                            "method_signature": "public interactionEnded()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interactionErrorOccurred",
                            "method_signature": "public interactionErrorOccurred(int offset, int length)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interpreterResetting",
                            "method_signature": "public interpreterResetting()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interpreterReady",
                            "method_signature": "public interpreterReady(File wd)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interpreterResetFailed",
                            "method_signature": "public interpreterResetFailed(final Throwable t)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interpreterExited",
                            "method_signature": "public interpreterExited(int status)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interpreterChanged",
                            "method_signature": "public interpreterChanged(boolean inProgress)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "compileStarted",
                            "method_signature": "public compileStarted()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "compileEnded",
                            "method_signature": "public compileEnded(File workDir, List<? extends File> excludedFiles)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "compileAborted",
                            "method_signature": "public compileAborted(Exception e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "saveBeforeCompile",
                            "method_signature": "public saveBeforeCompile()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "saveUntitled",
                            "method_signature": "public saveUntitled()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "activeCompilerChanged",
                            "method_signature": "public activeCompilerChanged()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "nonTestCase",
                            "method_signature": "public nonTestCase(boolean isTestAll, boolean didCompileFail)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "classFileError",
                            "method_signature": "public classFileError(ClassFileError e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "compileBeforeJUnit",
                            "method_signature": "public compileBeforeJUnit(final CompilerListener cl, List<OpenDefinitionsDocument> outOfSync)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "junitStarted",
                            "method_signature": "public junitStarted()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "junitClassesStarted",
                            "method_signature": "public junitClassesStarted()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "junitSuiteStarted",
                            "method_signature": "public junitSuiteStarted(int numTests)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "junitTestStarted",
                            "method_signature": "public junitTestStarted(String name)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "junitTestEnded",
                            "method_signature": "public junitTestEnded(String name, boolean wasSuccessful, boolean causedError)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "junitEnded",
                            "method_signature": "public junitEnded()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "javadocStarted",
                            "method_signature": "public javadocStarted()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "javadocEnded",
                            "method_signature": "public javadocEnded(boolean success, File destDir, boolean allDocs)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "saveBeforeJavadoc",
                            "method_signature": "public saveBeforeJavadoc()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "compileBeforeJavadoc",
                            "method_signature": "public compileBeforeJavadoc(final CompilerListener afterCompile)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interactionIncomplete",
                            "method_signature": "public interactionIncomplete()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "filePathContainsPound",
                            "method_signature": "public filePathContainsPound()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "documentNotFound",
                            "method_signature": "public documentNotFound(OpenDefinitionsDocument d, File f)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "browserChanged",
                            "method_signature": "public browserChanged()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "updateCurrentLocationInDoc",
                            "method_signature": "public updateCurrentLocationInDoc()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "testCommentOutMultipleLines",
                            "method_signature": "public testCommentOutMultipleLines(CommentTest commentTest)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "testCommentOutMultipleLines",
                            "method_signature": "public testCommentOutMultipleLines(CommentTest commentTest)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleAlreadyOpenDocument",
                            "method_signature": "public handleAlreadyOpenDocument(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "pollListeners",
                            "method_signature": "@Deprecated\n  public pollListeners(Poller p)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "junitTestEnded",
                            "method_signature": "public junitTestEnded(String name, boolean wasSuccessful, boolean causedError)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "quitFile",
                            "method_signature": "public quitFile(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "compileBeforeJUnit",
                            "method_signature": "public compileBeforeJUnit(final CompilerListener cl, List<OpenDefinitionsDocument> outOfSync)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "javadocEnded",
                            "method_signature": "public javadocEnded(boolean success, File destDir, boolean allDocs)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "nonTestCase",
                            "method_signature": "public nonTestCase(boolean isTestAll, boolean didCompileFail)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "executeAsyncTask",
                            "method_signature": "public executeAsyncTask(AsyncTask<P,R> task, P param, boolean showProgress, boolean lockUI)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interactionErrorOccurred",
                            "method_signature": "public interactionErrorOccurred(int offset, int length)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "shouldRevertFile",
                            "method_signature": "public shouldRevertFile(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "filesReadOnly",
                            "method_signature": "public filesReadOnly(File... f)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "fileSaved",
                            "method_signature": "public fileSaved(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interpreterChanged",
                            "method_signature": "public interpreterChanged(boolean inProgress)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interpreterExited",
                            "method_signature": "public interpreterExited(int status)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "focusOnLastFocusOwner",
                            "method_signature": "public focusOnLastFocusOwner()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interpreterResetFailed",
                            "method_signature": "public interpreterResetFailed(final Throwable t)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "compileAborted",
                            "method_signature": "public compileAborted(Exception e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interactionIncomplete",
                            "method_signature": "public interactionIncomplete()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "documentNotFound",
                            "method_signature": "public documentNotFound(OpenDefinitionsDocument d, File f)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "focusOnDefinitionsPane",
                            "method_signature": "public focusOnDefinitionsPane()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "filesNotFound",
                            "method_signature": "public filesNotFound(File... f)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "openProject",
                            "method_signature": "public openProject(File pfile, FileOpenSelector files)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "saveUntitled",
                            "method_signature": "public saveUntitled()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public testCommentOutMultipleLines(CommentTest commentTest)": {
                        "first": {
                            "method_name": "testCommentOutMultipleLines",
                            "method_signature": "public testCommentOutMultipleLines(CommentTest commentTest)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.21716572926888625
                    },
                    "public handleAlreadyOpenDocument(OpenDefinitionsDocument doc)": {
                        "first": {
                            "method_name": "handleAlreadyOpenDocument",
                            "method_signature": "public handleAlreadyOpenDocument(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6525845359632605
                    },
                    "@Deprecated\n  public pollListeners(Poller p)": {
                        "first": {
                            "method_name": "pollListeners",
                            "method_signature": "@Deprecated\n  public pollListeners(Poller p)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6653008256715666
                    },
                    "public junitTestEnded(String name, boolean wasSuccessful, boolean causedError)": {
                        "first": {
                            "method_name": "junitTestEnded",
                            "method_signature": "public junitTestEnded(String name, boolean wasSuccessful, boolean causedError)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6750527515635159
                    },
                    "public quitFile(OpenDefinitionsDocument doc)": {
                        "first": {
                            "method_name": "quitFile",
                            "method_signature": "public quitFile(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6853044027042985
                    },
                    "public compileBeforeJUnit(final CompilerListener cl, List<OpenDefinitionsDocument> outOfSync)": {
                        "first": {
                            "method_name": "compileBeforeJUnit",
                            "method_signature": "public compileBeforeJUnit(final CompilerListener cl, List<OpenDefinitionsDocument> outOfSync)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6930753282308627
                    },
                    "public javadocEnded(boolean success, File destDir, boolean allDocs)": {
                        "first": {
                            "method_name": "javadocEnded",
                            "method_signature": "public javadocEnded(boolean success, File destDir, boolean allDocs)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6947257418804423
                    },
                    "public nonTestCase(boolean isTestAll, boolean didCompileFail)": {
                        "first": {
                            "method_name": "nonTestCase",
                            "method_signature": "public nonTestCase(boolean isTestAll, boolean didCompileFail)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7333888572670134
                    },
                    "public executeAsyncTask(AsyncTask<P,R> task, P param, boolean showProgress, boolean lockUI)": {
                        "first": {
                            "method_name": "executeAsyncTask",
                            "method_signature": "public executeAsyncTask(AsyncTask<P,R> task, P param, boolean showProgress, boolean lockUI)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7609034429085638
                    },
                    "public interactionErrorOccurred(int offset, int length)": {
                        "first": {
                            "method_name": "interactionErrorOccurred",
                            "method_signature": "public interactionErrorOccurred(int offset, int length)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7646466905956487
                    },
                    "public shouldRevertFile(OpenDefinitionsDocument doc)": {
                        "first": {
                            "method_name": "shouldRevertFile",
                            "method_signature": "public shouldRevertFile(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7714543316580376
                    },
                    "public filesReadOnly(File... f)": {
                        "first": {
                            "method_name": "filesReadOnly",
                            "method_signature": "public filesReadOnly(File... f)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7809853814037794
                    },
                    "public fileSaved(OpenDefinitionsDocument doc)": {
                        "first": {
                            "method_name": "fileSaved",
                            "method_signature": "public fileSaved(OpenDefinitionsDocument doc)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7919406577988644
                    },
                    "public interpreterChanged(boolean inProgress)": {
                        "first": {
                            "method_name": "interpreterChanged",
                            "method_signature": "public interpreterChanged(boolean inProgress)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7940274181508361
                    },
                    "public interpreterExited(int status)": {
                        "first": {
                            "method_name": "interpreterExited",
                            "method_signature": "public interpreterExited(int status)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7970565496065881
                    }
                },
                "voyage": {
                    "public testCommentOutMultipleLines(CommentTest commentTest)": {
                        "first": {
                            "method_name": "testCommentOutMultipleLines",
                            "method_signature": "public testCommentOutMultipleLines(CommentTest commentTest)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.340219631962082
                    },
                    "public executeAsyncTask(AsyncTask<P,R> task, P param, boolean showProgress, boolean lockUI)": {
                        "first": {
                            "method_name": "executeAsyncTask",
                            "method_signature": "public executeAsyncTask(AsyncTask<P,R> task, P param, boolean showProgress, boolean lockUI)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4075366304302834
                    },
                    "public focusOnLastFocusOwner()": {
                        "first": {
                            "method_name": "focusOnLastFocusOwner",
                            "method_signature": "public focusOnLastFocusOwner()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4769959675426228
                    },
                    "@Deprecated\n  public pollListeners(Poller p)": {
                        "first": {
                            "method_name": "pollListeners",
                            "method_signature": "@Deprecated\n  public pollListeners(Poller p)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.49731055189314355
                    },
                    "public filesReadOnly(File... f)": {
                        "first": {
                            "method_name": "filesReadOnly",
                            "method_signature": "public filesReadOnly(File... f)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5175766738270906
                    },
                    "public interpreterResetFailed(final Throwable t)": {
                        "first": {
                            "method_name": "interpreterResetFailed",
                            "method_signature": "public interpreterResetFailed(final Throwable t)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5196721512680991
                    },
                    "public interpreterExited(int status)": {
                        "first": {
                            "method_name": "interpreterExited",
                            "method_signature": "public interpreterExited(int status)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.525858713989851
                    },
                    "public compileAborted(Exception e)": {
                        "first": {
                            "method_name": "compileAborted",
                            "method_signature": "public compileAborted(Exception e)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5294966924760126
                    },
                    "public interactionIncomplete()": {
                        "first": {
                            "method_name": "interactionIncomplete",
                            "method_signature": "public interactionIncomplete()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5362377585767658
                    },
                    "public documentNotFound(OpenDefinitionsDocument d, File f)": {
                        "first": {
                            "method_name": "documentNotFound",
                            "method_signature": "public documentNotFound(OpenDefinitionsDocument d, File f)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5415269552932895
                    },
                    "public focusOnDefinitionsPane()": {
                        "first": {
                            "method_name": "focusOnDefinitionsPane",
                            "method_signature": "public focusOnDefinitionsPane()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5469615584281834
                    },
                    "public interactionErrorOccurred(int offset, int length)": {
                        "first": {
                            "method_name": "interactionErrorOccurred",
                            "method_signature": "public interactionErrorOccurred(int offset, int length)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.559588241345335
                    },
                    "public filesNotFound(File... f)": {
                        "first": {
                            "method_name": "filesNotFound",
                            "method_signature": "public filesNotFound(File... f)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5675681620851292
                    },
                    "public openProject(File pfile, FileOpenSelector files)": {
                        "first": {
                            "method_name": "openProject",
                            "method_signature": "public openProject(File pfile, FileOpenSelector files)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5690556872410716
                    },
                    "public saveUntitled()": {
                        "first": {
                            "method_name": "saveUntitled",
                            "method_signature": "public saveUntitled()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5693708000891989
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public handleAlreadyOpenDocument(OpenDefinitionsDocument doc)",
                        "public quitFile(OpenDefinitionsDocument doc)",
                        "public shouldRevertFile(OpenDefinitionsDocument doc)",
                        "public filesReadOnly(File... f)",
                        "public fileSaved(OpenDefinitionsDocument doc)",
                        "public executeAsyncTask(AsyncTask<P,R> task, P param, boolean showProgress, boolean lockUI)",
                        "public interactionErrorOccurred(int offset, int length)",
                        "public interpreterExited(int status)",
                        "public junitTestEnded(String name, boolean wasSuccessful, boolean causedError)",
                        "public nonTestCase(boolean isTestAll, boolean didCompileFail)",
                        "public javadocEnded(boolean success, File destDir, boolean allDocs)",
                        "public compileBeforeJUnit(final CompilerListener cl, List<OpenDefinitionsDocument> outOfSync)",
                        "@Deprecated\n  public pollListeners(Poller p)",
                        "public testCommentOutMultipleLines(CommentTest commentTest)"
                    ],
                    "llm_response_time": 3171
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public handleAlreadyOpenDocument(OpenDefinitionsDocument doc)",
                        "public quitFile(OpenDefinitionsDocument doc)",
                        "public junitTestEnded(String name, boolean wasSuccessful, boolean causedError)",
                        "@Deprecated\n  public pollListeners(Poller p)",
                        "public testCommentOutMultipleLines(CommentTest commentTest)"
                    ],
                    "llm_response_time": 1275
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public handleAlreadyOpenDocument(OpenDefinitionsDocument doc)",
                        "@Deprecated\n  public pollListeners(Poller p)",
                        "public testCommentOutMultipleLines(CommentTest commentTest)"
                    ],
                    "llm_response_time": 875
                },
                "voyage": {
                    "priority_method_names": [
                        "public testCommentOutMultipleLines(CommentTest commentTest)",
                        "public executeAsyncTask(AsyncTask<P,R> task, P param, boolean showProgress, boolean lockUI)",
                        "public filesReadOnly(File... f)",
                        "public filesNotFound(File... f)",
                        "public openProject(File pfile, FileOpenSelector files)",
                        "public focusOnLastFocusOwner()",
                        "public focusOnDefinitionsPane()",
                        "public interactionErrorOccurred(int offset, int length)",
                        "public interpreterResetFailed(final Throwable t)",
                        "public interpreterExited(int status)",
                        "public compileAborted(Exception e)",
                        "@Deprecated\n  public pollListeners(Poller p)",
                        "public interactionIncomplete()",
                        "public documentNotFound(OpenDefinitionsDocument d, File f)"
                    ],
                    "llm_response_time": 2121
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public testCommentOutMultipleLines(CommentTest commentTest)",
                        "public executeAsyncTask(AsyncTask<P,R> task, P param, boolean showProgress, boolean lockUI)",
                        "public filesReadOnly(File... f)",
                        "public focusOnLastFocusOwner()",
                        "@Deprecated\n  public pollListeners(Poller p)"
                    ],
                    "llm_response_time": 1154
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public testCommentOutMultipleLines(CommentTest commentTest)",
                        "public executeAsyncTask(AsyncTask<P,R> task, P param, boolean showProgress, boolean lockUI)",
                        "public focusOnLastFocusOwner()"
                    ],
                    "llm_response_time": 1669
                }
            },
            "targetClassMap": {
                "testCommentOutMultipleLines": {
                    "target_classes": [
                        {
                            "class_name": "CommentTest",
                            "similarity_score": 0.7618435444444879
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CommentTest"
                    ],
                    "llm_response_time": 1556,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "handleAlreadyOpenDocument": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3657,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "pollListeners": {
                    "target_classes": [
                        {
                            "class_name": "Poller",
                            "similarity_score": 0.4356262160938641
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Poller"
                    ],
                    "llm_response_time": 1993,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "junitTestEnded": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3074,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "quitFile": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 5336,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "compileBeforeJUnit": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 5128,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "javadocEnded": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2348,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "nonTestCase": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2017,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "executeAsyncTask": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2140,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "interactionErrorOccurred": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2025,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "shouldRevertFile": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2612,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "filesReadOnly": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1949,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "fileSaved": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2263,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "interpreterChanged": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3626,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "interpreterExited": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2999,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "focusOnLastFocusOwner": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2585,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "interpreterResetFailed": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2913,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "compileAborted": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3614,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "interactionIncomplete": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 5060,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "documentNotFound": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3049,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method edu.rice.cs.util.swing.DirectoryChooser::_setUpLanguageLevelMenu(int, boolean):JMenu need move to edu.rice.cs.drjava.ui.MainFrame",
        "class_name": "edu.rice.cs.util.swing.DirectoryChooser",
        "telemetry": {
            "id": "1d63cde2-6d92-4fef-b9d9-f78a448f446f",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 148,
                "lineStart": 63,
                "lineEnd": 210,
                "bodyLineStart": 63,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/drjava/large/big/drjava-stable-20100913-r5387/src/src/edu/rice/cs/util/swing/DirectoryChooser.java",
                "sourceCode": "public class DirectoryChooser extends JFileChooser {\n  \n  /** GUI component that owns the dialog (if any) for this directory chooser. */\n  protected Component _owner;\n  \n  /** File system root for chooser */\n  protected File _root;\n  \n  /** Creates a DirectoryChooser rooted at file system root, allowing only a single selection. */\n  public DirectoryChooser() { this(null, null, false, false); }\n  \n  /** Creates a DirectoryChooser rooted at the file system root, allowing only single selection. */\n  public DirectoryChooser(Component owner) { this(owner, null, false, false); }\n  \n  /** Creates a DirectoryChooser rooted at the file system root, allowing multiple selection as specified.\n    * @param allowMultiple whether to allow multiple selection\n    */\n  public DirectoryChooser(Component owner, boolean allowMultiple) { this(owner, null, allowMultiple, false); }\n  \n  /** Creates a DirectoryChooser with the given root, allowing only a single selection.\n    * @param root the root directory to display in the tree\n    */\n  public DirectoryChooser(Component owner, File root) { this(owner, root, false, false); }\n  \n  /** Creates a DirectoryChooser with the given root, allowing multiple selections as specified.\n    * @param root the root directory to display in the tree. If null, then show entire file system\n    * @param allowMultiple whether to allow multiple selection\n    */\n  public DirectoryChooser(Component owner, File root, boolean allowMultiple, boolean showHidden) {\n    /* This super call sets current directory to root if it is valid directory, root.parentFile() if it is a valid \n     * non-directory file, and the system default otherwise. */\n    super(root);\n    _init(owner, root, allowMultiple, showHidden);\n  }\n  \n  /*---------- INITIALIZATION METHODS ----------*/\n  \n  /** Sets up the GUI components of the dialog */\n  private void _init(Component owner, final File root, boolean allowMultiple, boolean showHidden) {\n    \n    \n//    if (root != null && root.exists()) {\n//      setFileView(new FileView() { \n//                    public Boolean isTraversable(File f) { \n//                      return Boolean.valueOf(f.isDirectory() && FileOps.inFileTree(f, root)); \n//                    }});\n//    }\n    \n    _owner = owner;\n    _root = root; // may be null\n    if (root != null) {\n      if (! root.exists()) _root = null;\n      else if (! root.isDirectory()) _root = root.getParentFile();\n    }\n    \n    setMultiSelectionEnabled(allowMultiple);\n    setFileHidingEnabled(! showHidden);\n    setFileSelectionMode(DIRECTORIES_ONLY);\n    setDialogType(CUSTOM_DIALOG);\n    setApproveButtonText(\"Select\");\n    setFileFilter(new FileFilter() {\n      public boolean accept(File f) { return true; }\n      public String getDescription() { return \"All Folders\"; }\n    });\n  }\n  \n  public int showDialog(File initialSelection) {\n    setCurrentDirectory(initialSelection);\n    return showDialog(_owner, null);  // null means leave the approve button text unchanged\n  }\n  \n  /** Set the owner of this DirectoryChooser. */\n  public void setOwner(Component owner) { _owner = owner; }\n  \n  /** Shows the dialog with the same selection as the last time the dialog was shown. If this is the first time it is\n    * shown, then the root is selected.\n    */\n  public int showDialog() { return showDialog(_owner, null); }\n  \n  /** returns which directories were selected in the tree\n    * @return an array of files for the selected directories\n    */\n  public File[] getSelectedDirectories() { return getSelectedFiles(); }\n  \n  /** returns which directory was selected in the tree\n    * @return the file for the selected directory, null if none selected\n    */\n  public File getSelectedDirectory() { return getSelectedFile(); }\n\n/** Creates and returns the language levels menu.\n    * @param mainFrame TODO\n * @param mask the keystroke modifier to be used\n * @param updateKeyboardManager true if the keyboard manager should be updated; pass true only for MainFrame!\n    */\n  public JMenu _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager) {\n    JMenu languageLevelMenu = new JMenu(\"Language Level\");\n    PlatformFactory.ONLY.setMnemonic(languageLevelMenu,KeyEvent.VK_L);\n    ButtonGroup group = new ButtonGroup();\n    \n    final Configuration config = DrJava.getConfig();\n    int currentLanguageLevel = config.getSetting(LANGUAGE_LEVEL);\n    final JRadioButtonMenuItem rbFullJavaMenuItem = new JRadioButtonMenuItem(\"Full Java\");\n    rbFullJavaMenuItem.setToolTipText(\"Use full Java syntax\");\n    if (currentLanguageLevel != OptionConstants.FUNCTIONAL_JAVA_LEVEL) { rbFullJavaMenuItem.setSelected(true); }\n    rbFullJavaMenuItem.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        config.setSetting(LANGUAGE_LEVEL, OptionConstants.FULL_JAVA);\n      }});\n    group.add(rbFullJavaMenuItem);\n    languageLevelMenu.add(rbFullJavaMenuItem);\n    languageLevelMenu.addSeparator();\n    \n    final JRadioButtonMenuItem rbFunctionalMenuItem = new JRadioButtonMenuItem(\"Functional Java\");\n    rbFunctionalMenuItem.setToolTipText(\"Use Functional Java language-level features\");\n    if (currentLanguageLevel == OptionConstants.FUNCTIONAL_JAVA_LEVEL) { rbFunctionalMenuItem.setSelected(true); }\n    rbFunctionalMenuItem.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        config.setSetting(LANGUAGE_LEVEL, OptionConstants.FUNCTIONAL_JAVA_LEVEL);\n      }});\n    group.add(rbFunctionalMenuItem);\n    languageLevelMenu.add(rbFunctionalMenuItem);\n    \n    config.addOptionListener(LANGUAGE_LEVEL, new OptionListener<Integer>() {\n      public void optionChanged(OptionEvent<Integer> oce) {\n        switch(oce.value) {\n          case OptionConstants.ELEMENTARY_LEVEL:\n          case OptionConstants.INTERMEDIATE_LEVEL:\n          case OptionConstants.FUNCTIONAL_JAVA_LEVEL: {\n            rbFunctionalMenuItem.setSelected(true);\n            break;\n          }\n          default: {\n            rbFullJavaMenuItem.setSelected(true);\n            break;\n          }\n        }\n      }\n    });\n    \n    return languageLevelMenu;\n  }\n  \n//  public boolean isTraversable(File f) {\n//    if (_root == null) return super.isTraversable(f);\n//    Utilities.show(\"isTraversable(\" + f + \") called; _root = \" + _root);\n//    return f.isDirectory() && FileOps.inFileTree(f, _root);\n//  }\n}",
                "methodCount": 17
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 151,
                        "lineEnd": 202,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method _setUpLanguageLevelMenu to class MainFrame",
                        "description": "Move method _setUpLanguageLevelMenu to edu.rice.cs.drjava.ui.MainFrame\nRationale: The method _setUpLanguageLevelMenu() is responsible for creating and managing the language level menu, which is a UI component directly related to the MainFrame class. Since the method interacts with the main frame's components and settings, it is more appropriate for it to reside within the MainFrame class rather than being isolated elsewhere. This will enhance cohesion by keeping related functionalities together, making the code easier to maintain and understand.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "_setUpLanguageLevelMenu",
                            "method_signature": "public JMenu _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager)",
                            "target_class": "MenuManager",
                            "rationale": "The method _setUpLanguageLevelMenu is responsible for creating and managing a language level menu, which is more related to menu management than directory selection. Moving it to a dedicated MenuManager class would improve separation of concerns."
                        }
                    ],
                    "llm_response_time": 2507
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "_setUpLanguageLevelMenu",
                            "method_signature": "public JMenu _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager)",
                            "target_class": "MainFrame",
                            "rationale": "The method _setUpLanguageLevelMenu is responsible for creating a language level menu, which is more related to the MainFrame class that likely manages the overall application UI. Moving it there would improve cohesion."
                        }
                    ],
                    "llm_response_time": 2540
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "_setUpLanguageLevelMenu",
                            "method_signature": "public JMenu _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager)",
                            "target_class": "MainFrame",
                            "rationale": "The method _setUpLanguageLevelMenu is responsible for creating a language level menu, which is more related to the MainFrame class that likely manages the overall application UI. Moving it there would improve cohesion."
                        }
                    ],
                    "llm_response_time": 2214
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<Integer> oce)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_setUpLanguageLevelMenu",
                            "method_signature": "public _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<Integer> oce)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_setUpLanguageLevelMenu",
                            "method_signature": "public _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public optionChanged(OptionEvent<Integer> oce)": {
                        "first": {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<Integer> oce)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.414124555187586
                    },
                    "public _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager)": {
                        "first": {
                            "method_name": "_setUpLanguageLevelMenu",
                            "method_signature": "public _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5251568616436122
                    }
                },
                "voyage": {
                    "public _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager)": {
                        "first": {
                            "method_name": "_setUpLanguageLevelMenu",
                            "method_signature": "public _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4025392647903107
                    },
                    "public optionChanged(OptionEvent<Integer> oce)": {
                        "first": {
                            "method_name": "optionChanged",
                            "method_signature": "public optionChanged(OptionEvent<Integer> oce)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4102720229727349
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager)",
                        "public optionChanged(OptionEvent<Integer> oce)"
                    ],
                    "llm_response_time": 753
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager)",
                        "public optionChanged(OptionEvent<Integer> oce)"
                    ],
                    "llm_response_time": 0
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager)",
                        "public optionChanged(OptionEvent<Integer> oce)"
                    ],
                    "llm_response_time": 0
                },
                "voyage": {
                    "priority_method_names": [
                        "public optionChanged(OptionEvent<Integer> oce)",
                        "public _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager)"
                    ],
                    "llm_response_time": 774
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public optionChanged(OptionEvent<Integer> oce)",
                        "public _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager)"
                    ],
                    "llm_response_time": 1
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public optionChanged(OptionEvent<Integer> oce)",
                        "public _setUpLanguageLevelMenu(MainFrame mainFrame, int mask, boolean updateKeyboardManager)"
                    ],
                    "llm_response_time": 1
                }
            },
            "targetClassMap": {
                "optionChanged": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2385,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "_setUpLanguageLevelMenu": {
                    "target_classes": [
                        {
                            "class_name": "MainFrame",
                            "similarity_score": 0.7462099846532706
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "MainFrame"
                    ],
                    "llm_response_time": 7999,
                    "similarity_computation_time": 24,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method edu.rice.cs.drjava.model.FindReplaceMachine::findPrevious():void need move to edu.rice.cs.drjava.ui.FindReplacePanel",
        "class_name": "edu.rice.cs.drjava.model.FindReplaceMachine",
        "telemetry": {
            "id": "d1d56247-d84e-4ca1-ab65-d230644cbea5",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 683,
                "lineStart": 56,
                "lineEnd": 738,
                "bodyLineStart": 56,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/drjava/large/big/drjava-stable-20100913-r5387/src/src/edu/rice/cs/drjava/model/FindReplaceMachine.java",
                "sourceCode": "/** Implementation of logic of find/replace over a document.\n  * @version $Id: FindReplaceMachine.java 5354 2010-08-10 22:41:14Z mgricken $\n  */\npublic class FindReplaceMachine {\n  \n  static private Log _log = new Log(\"FindReplace.txt\", false);\n  \n  /* Visible machine state; manipulated directly or indirectly by FindReplacePanel. */\n  private OpenDefinitionsDocument _doc;      // Current search document \n  private OpenDefinitionsDocument _firstDoc; // First document where searching started (when searching all documents)\n//  private Position _current;                 // Position of the cursor in _doc when machine is stopped\n  private int _current;                 // Position of the cursor in _doc when machine is stopped\n  private MovingDocumentRegion _selectionRegion; // selected text region\n//  private Position _start;                   // Position in _doc from which searching started or will start.\n  private String _findWord;                  // Word to find. */\n  private String _replaceWord;               // Word to replace _findword.\n  private boolean _matchCase;\n  private boolean _matchWholeWord;\n  private boolean _searchAllDocuments;       // Whether to search all documents (or just the current document)\n  private boolean _searchSelectionOnly;      // Whether to search only the selection\n  private boolean _isForward;                // Whether search direction is forward (false means backward)\n  private boolean _ignoreCommentsAndStrings; // Whether to ignore matches in comments and strings\n  private boolean _ignoreTestCases;          // Whether to ignore documents that end in *Test.java\n  private String _lastFindWord;              // Last word found; set to null by FindReplacePanel if caret is updated\n  private boolean _skipText;                 // Whether to skip over the current match if direction is reversed\n  private DocumentIterator _docIterator;     // An iterator of open documents; _doc is current\n  private SingleDisplayModel _model;\n  private Component _frame;  \n  \n  /** Standard Constructor.\n    * Creates new machine to perform find/replace operations on a particular document starting from a given position.\n    * @param docIterator an object that allows navigation through open Swing documents (it is DefaultGlobalModel)\n    */\n  public FindReplaceMachine(SingleDisplayModel model, DocumentIterator docIterator, Component frame) {    \n    _skipText = false;\n//    _checkAllDocsWrapped = false;\n//    _allDocsWrapped = false;\n    _model = model;\n    _frame = frame;\n    _docIterator = docIterator;\n    _current = -1;\n    setFindAnyOccurrence();\n    setFindWord(\"\");\n    setReplaceWord(\"\");\n    setSearchBackwards(false);\n    setMatchCase(true);\n    setSearchAllDocuments(false);\n    setSearchSelectionOnly(false);\n    setIgnoreCommentsAndStrings(false);\n    setIgnoreTestCases(false);\n  }\n  \n  public void cleanUp() {\n    _docIterator = null;\n    setFindWord(\"\");\n    _doc = null;\n  }\n  \n  /** Called when the current position is updated in the document implying _skipText should not be set\n    * if the user toggles _searchBackwards\n    */\n  public void positionChanged() {\n    _lastFindWord = null;\n    _skipText = false;\n  }\n  \n  public void setLastFindWord() { _lastFindWord = _findWord; }\n  \n  public boolean isSearchBackwards() { return ! _isForward; }\n  \n  public void setSearchBackwards(boolean searchBackwards) {\n    if (_isForward == searchBackwards) {\n      // If we switch from searching forward to searching backwards or vice versa, isOnMatch is true, and _findword is\n      // the same as the _lastFindWord, we know the user just found _findWord, so skip over this match.\n      if (onMatch() && _findWord.equals(_lastFindWord)) _skipText = true;\n      else _skipText = false;\n    }\n    _isForward = ! searchBackwards;\n  }\n  \n  public void setMatchCase(boolean matchCase) { _matchCase = matchCase; }\n  public boolean getMatchCase() { return _matchCase; }\n  \n  public void setMatchWholeWord() { _matchWholeWord = true; }\n  \n  public boolean getMatchWholeWord() { return _matchWholeWord; }\n  \n  public void setFindAnyOccurrence() { _matchWholeWord = false; }  \n  \n  public void setSearchAllDocuments(boolean searchAllDocuments) { _searchAllDocuments = searchAllDocuments; }\n  \n  public void setSearchSelectionOnly(boolean searchSelectionOnly) { _searchSelectionOnly = searchSelectionOnly; }\n  \n  public void setIgnoreCommentsAndStrings(boolean ignoreCommentsAndStrings) {\n    _ignoreCommentsAndStrings = ignoreCommentsAndStrings;\n  }\n  public boolean getIgnoreCommentsAndStrings() { return _ignoreCommentsAndStrings; }\n  \n  public void setIgnoreTestCases(boolean ignoreTestCases) {\n    _ignoreTestCases = ignoreTestCases;\n  }\n  public boolean getIgnoreTestCases() { return _ignoreTestCases; }\n\n  public void setDocument(OpenDefinitionsDocument doc) { _doc = doc; }\n  \n  public void setFirstDoc(OpenDefinitionsDocument firstDoc) { _firstDoc = firstDoc; }\n  \n  public void setPosition(int pos) { _current = pos; }\n  \n  /** Gets the character offset to which this machine is currently pointing. */\n  public int getCurrentOffset() { //return _current.getOffset(); \n    return _current;\n  }\n  \n  public String getFindWord() { return _findWord; }\n  \n  public String getReplaceWord() { return _replaceWord; }\n  \n  public boolean getSearchAllDocuments() { return _searchAllDocuments; }\n  \n  public boolean getSearchSelectionOnly() { return _searchSelectionOnly; }\n  \n  public OpenDefinitionsDocument getDocument() { return _doc; }\n  \n  public OpenDefinitionsDocument getFirstDoc() { return _firstDoc; }\n  \n  /** Change the word being sought.\n    * @param word the new word to seek\n    */\n  public void setFindWord(String word) {  \n    _findWord = StringOps.replace(word, StringOps.EOL, \"\\n\"); \n  }\n  \n  /** Change the replacing word.\n    * @param word the new replacing word\n    */\n  public void setReplaceWord(String word) { \n    _replaceWord = StringOps.replace(word, StringOps.EOL,\"\\n\"); \n  }\n  \n  /** Determine if the machine is on an instance of the find word.  Only executes in event thread except for\n    * initialization.\n    * @return true if the current position is right after an instance of the find word.\n    */\n  public boolean onMatch() {\n    \n    // Should be fixed now because of invokeAndWait in MainFrame constructor\n    // (was: this invariant doesn't hold.  See DrJava bug #2321815)\n    assert Utilities.TEST_MODE || EventQueue.isDispatchThread();\n    \n    String findWord = _findWord;\n    int wordLen, off;\n    \n    if(_current == -1) return false;\n    \n    wordLen = findWord.length();\n    if (_isForward) off = getCurrentOffset() - wordLen;\n    else off = getCurrentOffset();\n    \n    if (off < 0) return false;\n    \n    String matchSpace;\n    try {\n      if (off + wordLen > _doc.getLength()) return false;\n      matchSpace = _doc.getText(off, wordLen);\n    }\n    catch (BadLocationException e) { throw new UnexpectedException(e); }\n    \n    if (!_matchCase) {\n      matchSpace = matchSpace.toLowerCase();\n      findWord = findWord.toLowerCase();\n    }\n    return matchSpace.equals(findWord);\n  }\n  \n  /** If we're on a match for the find word, replace it with the replace word.  Only executes in event thread. */\n  public boolean replaceCurrent() {\n    \n    assert EventQueue.isDispatchThread();\n    \n    if (! onMatch()) return false;\n    try {\n//      boolean atStart = false;\n      int offset = getCurrentOffset();\n      if (_isForward) offset -= _findWord.length();  // position is now on left edge of match\n//      assert _findWord.equals(_doc.getText(offset, _findWord.length()));\n      \n//      Utilities.show(\"ReplaceCurrent called. _doc = \" + _doc.getText() + \" offset = \" + offset + \" _findWord = \" +\n//        _findWord);\n      \n      _doc.remove(offset, _findWord.length());\n      \n//      if (position == 0) atStart = true;\n      _doc.insertString(offset, _replaceWord, null);  // could use _insertString if we had the DefinitionsDocument\n      \n      // update _current Position\n      if (_isForward) setPosition(offset + _replaceWord.length());\n      else setPosition(offset);\n      \n      return true;\n    }\n    catch (BadLocationException e) { throw new UnexpectedException(e); }\n  }\n\n  /** Set the selected text region.\n    * @param s selected region\n    */\n  public void setSelection(MovingDocumentRegion s) { \n    _selectionRegion = s;\n  }\n\n  /** Replaces all occurrences of the find word with the replace word in the current document of in all documents\n    * depending the value of the machine register _searchAllDocuments.\n    * @return the number of replacements\n    */\n  public int replaceAll() { \n    return replaceAll(_searchAllDocuments, _searchSelectionOnly); \n  }\n  \n  /** Replaces all occurences of the find word with the replace word in the current document of in all documents or \n    * in the current selection of the current document depending the value of the flag searchAll\n    * @return the number of replacements\n    */\n  private int replaceAll(boolean searchAll, boolean searchSelectionOnly) {\n    if (searchAll) {\n      int count = 0;           // the number of replacements done so far\n      int n = _docIterator.getDocumentCount();\n      for (int i = 0; i < n; i++) {\n        // replace all in the rest of the documents\n        count += _replaceAllInCurrentDoc(false);\n        _doc = _docIterator.getNextDocument(_doc, _frame);\n        \n        if(_doc==null) break;\n      }\n      \n      // update display (adding \"*\") in navigatgorPane\n      _model.getDocumentNavigator().repaint();\n      \n      return count;\n    }\n    else if(searchSelectionOnly) {\n      int count = 0;\n      count += _replaceAllInCurrentDoc(searchSelectionOnly);\n      return count;\n    }\n    else \n      return _replaceAllInCurrentDoc(false);\n  }\n  \n  /** Replaces all occurences of _findWord with _replaceWord in _doc. Never searches in other documents.  Starts at\n    * the beginning or the end of the document (depending on find direction).  This convention ensures that matches \n    * created by string replacement will not be replaced as in the following example:<p>\n    *   findString:    \"hello\"<br>\n    *   replaceString: \"e\"<br>\n    *   document text: \"hhellollo\"<p>\n    * Depending on the cursor position, clicking replace all could either make the document text read \"hello\" \n    * (which is correct) or \"e\".  This is because of the behavior of findNext(), and it would be incorrect\n    * to change that behavior.  Only executes in event thread.\n    * @return the number of replacements\n    */\n  private int _replaceAllInCurrentDoc(boolean searchSelectionOnly) {\n    \n    assert EventQueue.isDispatchThread();\n    \n    if(!searchSelectionOnly) {\n      _selectionRegion = new MovingDocumentRegion(_doc, 0, _doc.getLength(),\n                                                  _doc._getLineStartPos(0),\n                                                  _doc._getLineEndPos(_doc.getLength()));\n    }\n    if (_isForward) setPosition(_selectionRegion.getStartOffset());\n    else setPosition(_selectionRegion.getEndOffset());\n    \n    int count = 0;\n    FindResult fr = findNext(false);  // find next match in current doc   \n    //  Utilities.show(fr + \" returned by call on findNext()\");\n    \n    while (!fr.getWrapped() && fr.getFoundOffset() <= _selectionRegion.getEndOffset()) {\n      replaceCurrent();\n      count++;\n      //  Utilities.show(\"Found \" + count + \" occurrences. Calling findNext() inside loop\");\n      fr = findNext(false);           // find next match in current doc\n      //  Utilities.show(\"Call on findNext() returned \" + fr.toString() + \"in doc '\" + \n      //    _doc.getText().substring(0,fr.getFoundOffset()) + \"[|]\" + _doc.getText().substring(fr.getFoundOffset()) + \"'\");\n    }\n    return count;\n  }\n  \n  /** Processes all occurences of the find word with the replace word in the current document or in all documents\n    * depending the value of the machine register _searchAllDocuments.\n    * @param findAction action to perform on the occurrences; input is the FindResult, output is ignored\n    * @return the number of processed occurrences\n    */\n  public int processAll(Runnable1<FindResult> findAction, MovingDocumentRegion region) { \n    _selectionRegion = region;\n    return processAll(findAction, _searchAllDocuments, _searchSelectionOnly); \n  }\n  \n  /** Processes all occurences of the find word with the replace word in the current document or in all documents\n    * depending the value of the flag searchAll.  Assumes that findAction does not modify the document it processes.\n    * Only executes in event thread.\n    * @param findAction action to perform on the occurrences; input is the FindResult, output is ignored\n    * @return the number of replacements\n    */\n  private int processAll(Runnable1<FindResult> findAction, boolean searchAll, boolean searchSelectionOnly) {\n    \n    assert EventQueue.isDispatchThread();\n    \n    if (searchAll) {\n      int count = 0;           // the number of replacements done so far\n      int n = _docIterator.getDocumentCount();\n      for (int i = 0; i < n; i++) {\n        // process all in the rest of the documents\n        count += _processAllInCurrentDoc(findAction, false);\n        _doc = _docIterator.getNextDocument(_doc, _frame);\n        \n        if(_doc==null) break;\n      }\n      \n      // update display (perhaps adding \"*\") in navigatgorPane\n      _model.getDocumentNavigator().repaint();\n      \n      return count;\n    }\n    else if(searchSelectionOnly) {\n      int count = 0;\n      count += _processAllInCurrentDoc(findAction, searchSelectionOnly);\n      return count;\n    }\n    else return _processAllInCurrentDoc(findAction, false);\n  }\n  \n  /** Processes all occurences of _findWord in _doc. Never processes other documents.  Starts at the beginning or the\n    * end of the document (depending on find direction).  This convention ensures that matches created by string \n    * replacement will not be replaced as in the following example:<p>\n    *  findString:    \"hello\"<br>\n    *  replaceString: \"e\"<br>\n    *  document text: \"hhellollo\"<p>\n    * Assumes this has mutually exclusive access to _doc (e.g., by hourglassOn) and findAction does not modify _doc.\n    * Only executes in event thread.\n    * @param findAction action to perform on the occurrences; input is the FindResult, output is ignored\n    * @return the number of replacements\n    */\n  private int _processAllInCurrentDoc(Runnable1<FindResult> findAction, boolean searchSelectionOnly) {\n    if(!searchSelectionOnly) {\n      _selectionRegion = new MovingDocumentRegion(_doc, 0, _doc.getLength(),\n                                                  _doc._getLineStartPos(0),\n                                                  _doc._getLineEndPos(_doc.getLength()));\n    }\n    if (_isForward) setPosition(_selectionRegion.getStartOffset());\n    else setPosition(_selectionRegion.getEndOffset());\n    \n    int count = 0;\n    FindResult fr = findNext(false);  // find next match in current doc   \n    \n    while (! fr.getWrapped() && fr.getFoundOffset() <= _selectionRegion.getEndOffset()) {\n      findAction.run(fr);\n      count++;\n      fr = findNext(false);           // find next match in current doc\n    }\n    return count;\n  }\n  \n  public FindResult findNext() { return findNext(_searchAllDocuments); }\n  \n  /** Finds the next occurrence of the find word and returns an offset at the end of that occurrence or -1 if the word\n    * was not found.  In a forward search, the match offset is the RIGHT edge of the word.  In subsequent searches, the\n    * same instance won't be found again.  In a backward search, the position returned is the LEFT edge of the word.  \n    * Also returns a flag indicating whether the end of the document was reached and wrapped around. This is done\n    * using the FindResult class which contains the matching document, an integer offset and two flag indicated whether\n    * the search wrapped (within _doc and across all documents).  Only executes in the event thread.\n    * @param searchAll whether to search all documents (or just _doc)\n    * @return a FindResult object containing foundOffset and a flag indicating wrapping to the beginning during a search\n    */\n  private FindResult findNext(boolean searchAll) {\n    \n    assert EventQueue.isDispatchThread();\n    \n    // Find next match, if any, in _doc. \n    FindResult fr;\n    int start;\n    int len;\n    \n    // If the user just found a match and toggled the \"Search Backwards\" option, we should skip the matched text.\n    if (_skipText) {  // adjust position (offset)\n//      System.err.println(\"Skip text is true!  Last find word = \" + _lastFindWord);\n      int wordLen = _lastFindWord.length();\n      if (_isForward) setPosition(getCurrentOffset() + wordLen);\n      else setPosition(getCurrentOffset() - wordLen);\n      positionChanged();\n    }\n    \n//    System.err.println(\"findNext(\" + searchAll + \") called with _doc = [\" + _doc.getText() + \"] and offset = \" +\n//      _current.getOffset());\n    \n    int offset = getCurrentOffset();\n//    System.err.println(\"findNext(\" + searchAll + \") called; initial offset is \" + offset);\n//    System.err.println(\"_doc = [\" + _doc.getText() + \"], _doc.getLength() = \" + _doc.getLength());\n    if (_isForward) { \n      start = offset;\n      len = _doc.getLength() - offset; \n    }\n    else { \n      start = 0; \n      len = offset; \n    }\n    fr = _findNextInDoc(_doc, start, len, searchAll);\n    if (fr.getFoundOffset() >= 0 || ! searchAll) return fr;  // match found in _doc or search is local\n    \n    // find match in other docs\n    return _findNextInOtherDocs(_doc, start, len);\n  }\n  \n  \n  /** Finds next match in specified doc only.  If searching forward, len must be doc.getLength().  If searching backward,\n    * start must be 0.  If searchAll, suppress executing in-document wrapped search, because it must be deferred.  Only\n    * runs in the event thread.  Note than this method does a wrapped search if specified search fails.\n    */\n  private FindResult _findNextInDoc(OpenDefinitionsDocument doc, int start, int len, boolean searchAll) {\n    // search from current position to \"end\" of document (\"end\" is start if searching backward)\n//    Utilities.show(\"_findNextInDoc([\" + doc.getText() + \"], \" + start + \", \" + len + \", \" + searchAll + \")\");\n//    _log.log(\"_findNextInDoc([\" + doc.getText() + \"], \" + start + \", \" + len + \", \" + searchAll + \")\");\n    FindResult fr = _findNextInDocSegment(doc, start, len);\n    if (fr.getFoundOffset() >= 0 || searchAll) return fr;\n    \n    return _findWrapped(doc, start, len, false);  // last arg is false because search has not wrapped through all docs\n  }\n  \n  /** Helper method for findNext that looks for a match after searching has wrapped off the \"end\" (start if searching\n    * backward) of the document.  Only runs in event thread.  \n    * INVARIANT (! _isForward => start = 0) && (_isForward => start + len = doc.getLength()).\n    * @param doc  the document in which search wrapped\n    * @param start the location of preceding text segment where search FAILED.  \n    * @param len  the length of text segment previously searched\n    * @param allWrapped  whether this wrapped search is being performed after an all document search has wrapped\n    * @return the offset where the instance was found. Returns -1 if no instance was found between start and end\n    */  \n  private FindResult _findWrapped(OpenDefinitionsDocument doc, int start, int len, boolean allWrapped) {\n    \n    final int docLen = doc.getLength();\n    if (docLen == 0) return new FindResult(doc, -1, true, allWrapped); // failure result\n    \n    final int wordLen =  _findWord.length();\n    \n    assert (start >= 0 && start <= docLen) && (len >= 0 && len <= docLen) && wordLen > 0;\n    assert (_isForward && start + len == docLen) || (! _isForward && start == 0);\n//    Utilities.show(\"_findWrapped(\" + doc + \", \" + start + \", \" + len + \", \" + allWrapped + \")  docLength = \" +\n//                       doc.getLength() + \", _isForward = \" + _isForward);\n//    _log.log(\"_findWrapped(\" + doc + \", \" + start + \", \" + len + \", \" + allWrapped + \")  docLength = \" +\n//             doc.getLength() + \", _isForward = \" + _isForward);\n    \n    int newLen;\n    int newStart;\n    \n    final int adjustment = wordLen - 1; // non-negative max size of the findWord suffix (prefix) within preceding text\n    \n    if (_isForward) {\n      newStart = 0;\n      newLen = start + adjustment;  // formerly start, which was an annoying bug\n      if (newLen > docLen) newLen = docLen;\n    }\n    else {\n      newStart = len - adjustment;\n      if (newStart < 0) newStart = 0;\n      newLen = docLen - newStart;\n    }\n    \n//    _log.log(\"Calling _findNextInDocSegment(\" + doc.getText() + \", newStart = \" + newStart + \", newLen = \" + \n//             newLen + \", allWrapped = \" + allWrapped + \") and _isForward = \" + _isForward);\n    return _findNextInDocSegment(doc, newStart, newLen, true, allWrapped);\n  } \n  \n  /** Find first valid match withing specified segment of doc. */  \n  private FindResult _findNextInDocSegment(OpenDefinitionsDocument doc, int start, int len) {\n    return _findNextInDocSegment(doc, start, len, false, false);\n  }\n  \n  /** Main helper method for findNext... that searches for _findWord inside the specified document segment.  Only runs\n    * in the event thread.\n    * @param doc document to be searched\n    * @param start the location (offset/left edge) of the text segment to be searched \n    * @param len the requested length of the text segment to be searched\n    * @param wrapped whether this search is after wrapping around the document\n    * @param allWrapped whether this seach is after wrapping around all documents\n    * @return a FindResult object with foundOffset and a flag indicating wrapping to the beginning during a search. The\n    * foundOffset returned insided the FindResult is -1 if no instance was found.\n    */\n  private FindResult _findNextInDocSegment(final OpenDefinitionsDocument doc, final int start, int len, \n                                           final boolean wrapped, final boolean allWrapped) {  \n//    Utilities.show(\"called _findNextInDocSegment(\" + doc.getText() + \",\\n\" + start + \", \" + len + \", \" + wrapped +\n//      \" ...)\");\n    boolean inTestCase = false;\n    for(String ext: OptionConstants.LANGUAGE_LEVEL_EXTENSIONS) {\n      inTestCase |= doc.getFileName().endsWith(\"Test\"+ext);\n    }\n    \n    if (!_ignoreTestCases || ! inTestCase) {\n      final int docLen = doc.getLength();;     // The length of the segment to be searched\n      final int wordLen = _findWord.length();   // length of search key (word being searched for)\n      \n      assert (start >= 0 && start <= docLen) && (len >= 0 && len <= docLen);\n      \n      if (len == 0 || docLen == 0) return new FindResult(doc, -1, wrapped, allWrapped);\n      \n      if (start + len > docLen) len = docLen - start;\n      \n//    if (start + len > docLen) len = docLen - start;\n      \n      String text;             // The text segment to be searched\n      final String findWord;   // copy of word being searched (so it can converted to lower case if necessary\n      \n      try { \n        \n//      if (wrapped && allWrapped) Utilities.show(start  + \", \" + len + \", \" + docLen + \", doc = '\" + doc.getText() + \"'\");\n        text = doc.getText(start, len);\n        \n        if (! _matchCase) {\n          text = text.toLowerCase();\n          findWord = _findWord.toLowerCase();  // does not affect wordLen\n        }\n        else findWord = _findWord;\n//       if (wrapped && allWrapped) Utilities.show(\"Executing loop with findWord = \" + findWord + \"; text = \" + text +\n//          \"; len = \" + len);     \n        \n        // loop to find first valid (not ignored) occurrence of findWord\n        // loop carried variables are rem, foundOffset; \n        // loop invariant variables are _doc, docLen, _isForward, findWord, wordLen, start, len.\n        // Invariant:  on forwardsearch, foundOffset + rem == len; on backward search foundOffset == rem.\n        // loop exits by returning match (as FindResult) or by falling through with no match.\n        // if match is returned, _current has been updated to match location\n        int foundOffset = _isForward? 0 : len;\n        int rem = len;\n//      _log.log(\"Starting search loop; text = '\" + text + \"' findWord = '\" + findWord + \"' forward? = \" + _isForward +\n//         \" rem = \" + rem + \" foundOffset = \" + foundOffset);\n        while (rem >= wordLen) {\n          \n          // Find next match in text\n          foundOffset = _isForward ? text.indexOf(findWord, foundOffset) : text.lastIndexOf(findWord, foundOffset);\n//        _log.log(\"foundOffset = \" + foundOffset);\n          if (foundOffset < 0) break;  // no valid match in this document\n          int foundLocation = start + foundOffset;\n          int matchLocation;\n          \n          if (_isForward) {\n            foundOffset += wordLen;                          // skip over matched word\n//          text = text.substring(adjustedOffset, len);    // len is length of text before update\n            rem = len - foundOffset;                         // len is updated to length of remaining text to search\n            matchLocation = foundLocation + wordLen;         // matchLocation is index in _doc of right edge of match\n//            _current = docToSearch.createPosition(start);          // put caret at beginning of found word\n          }\n          else { \n            \n            foundOffset -= wordLen;                        // skip over matched word        \n            rem = foundOffset;                             // rem is adjusted to match foundOffset\n            matchLocation = foundLocation;                 // matchLocation is index in _doc of left edge of match\n//          text = text.substring(0, len);               // len is length of text after update\n//            _current = docToSearch.createPosition(foundLocation);  // put caret at end of found word\n          }\n//        _log.log(\"rem = \" + rem);\n          \n//        _log.log(\"Finished iteration with text = \" + text + \"; len = \" + len + \"; foundLocation = \" + foundLocation);\n          assert foundLocation > -1;\n          if (_shouldIgnore(foundLocation, doc)) continue;\n          \n          //_current = doc.createPosition(matchLocation);   // formerly doc.createPosition(...)\n          setPosition(matchLocation);\n          \n//        System.err.println(\"Returning result = \" + new FindResult(doc, matchLocation, wrapped, allWrapped));\n          \n          return new FindResult(doc, matchLocation, wrapped, allWrapped);  // return valid match\n        }\n      }\n      catch (BadLocationException e) { throw new UnexpectedException(e); }\n    }      \n    // loop fell through; search failed in doc segment\n    return new FindResult(doc, -1, wrapped, allWrapped);\n  }\n  \n  /** Searches all documents following startDoc for _findWord, cycling through the documents in the direction specified\n    * by _isForward. If the search cycles back to doc without finding a match, performs a wrapped search on doc.\n    * @param startDoc  document where searching started and just failed\n    * @param start  location in startDoc of the document segment where search failed.\n    * @param len  length of the text segment where search failed.\n    * @return the FindResult containing the information for where we found _findWord or a dummy FindResult.\n    */\n  private FindResult _findNextInOtherDocs(final OpenDefinitionsDocument startDoc, int start, int len) {\n    \n//    System.err.println(\"_findNextInOtherDocs(\" + startDoc.getText() + \", \" + start + \", \" + len + \")\");\n    \n    boolean allWrapped = false;\n    // _doc may be null if the next document isn't found and the user didn't want to continue!\n    _doc = _isForward ? _docIterator.getNextDocument(startDoc) : _docIterator.getPrevDocument(startDoc);\n    if (_doc == null) return new FindResult(startDoc, -1, true, true);\n    \n    while (_doc != startDoc) {\n      if (_doc == _firstDoc) allWrapped = true;\n      boolean inTestCase = (_doc.getFileName().endsWith(\"Test.java\"));\n      \n      if (! _ignoreTestCases || ! inTestCase) {\n//      System.err.println(\"_doc = [\" + _doc.getText() + \"]\");\n        \n//      if (_isForward) setPosition(0);\n//      else setPosition(_doc.getLength());\n        \n        \n        // find next match in _doc\n        FindResult fr;\n        fr = _findNextInDocSegment(_doc, 0, _doc.getLength(), false, allWrapped); \n        \n        if (fr.getFoundOffset() >= 0) return fr;\n      }\n//      System.err.println(\"Advancing from '\" + _doc.getText() + \"' to next doc\");        \n      // _doc may be null if the next document isn't found and the user didn't want to continue!\n      _doc = _isForward ? _docIterator.getNextDocument(_doc) : _docIterator.getPrevDocument(_doc);     \n      if (_doc == null) return new FindResult(startDoc, -1, true, true);\n//      System.err.println(\"Next doc is: '\" + _doc.getText() + \"'\");\n    }\n    \n    // No valid match found; perform wrapped search.  Only runs in event thread.\n    return _findWrapped(startDoc, start, len, true);  // last arg is true because searching all docs has wrapped\n  } \n  \n  /** Determines whether the whole find word is found at the input position.  Assumes read lock or hourglass is\n    * already held.\n    * @param doc - the document where an instance of the find word was found\n    * @param foundOffset - the position where that instance was found\n    * @return true if the whole word is found at foundOffset, false otherwise\n    */\n  private boolean wholeWordFoundAtCurrent(OpenDefinitionsDocument doc, int foundOffset) {    \n    \n    char leftOfMatch = 0;   //  forced initialization\n    char rightOfMatch = 0;  //  forced initialization\n    int leftLoc = foundOffset - 1;\n    int rightLoc = foundOffset + _findWord.length();\n    boolean leftOutOfBounds = false;\n    boolean rightOutOfBounds = false;\n    \n    try { leftOfMatch = doc.getText(leftLoc, 1).charAt(0); }\n    catch (BadLocationException e) { leftOutOfBounds = true; } \n    catch (IndexOutOfBoundsException e) { leftOutOfBounds = true; }\n    try { rightOfMatch = doc.getText(rightLoc, 1).charAt(0); }\n    catch (BadLocationException e) { rightOutOfBounds = true; } \n    catch (IndexOutOfBoundsException e) { rightOutOfBounds = true; }    \n    \n    if (! leftOutOfBounds && ! rightOutOfBounds) return isDelimiter(rightOfMatch) && isDelimiter(leftOfMatch);\n    if (! leftOutOfBounds) return isDelimiter(leftOfMatch);\n    if (! rightOutOfBounds) return isDelimiter(rightOfMatch);\n    return true;\n  }\n  \n  /** Determines whether a character is a delimiter (not a letter or digit) as a helper to wholeWordFoundAtCurrent\n    * \n    * @param ch - a character\n    * @return true if ch is a delimiter, false otherwise\n    */\n  private boolean isDelimiter(char ch) { return ! Character.isLetterOrDigit(ch)  &&  ch != '_'; }\n  \n  /** Returns true if the currently found instance should be ignored (either because it is inside a string or comment or\n    * because it does not match the whole word when either or both of those conditions are set to true).  Only executes \n    * in event thread.\n    * @param foundOffset the location of the instance found\n    * @param odd the current document where the instance was found\n    * @return true if the location should be ignored, false otherwise\n    */\n  private boolean _shouldIgnore(int foundOffset, OpenDefinitionsDocument odd) {\n    \n    assert EventQueue.isDispatchThread();\n\n    return (_matchWholeWord && ! wholeWordFoundAtCurrent(odd, foundOffset)) || \n      (_ignoreCommentsAndStrings && odd.isShadowed(foundOffset));\n  }\n\n/** Called when user the activates \"find previous\" command.  Package visibility to accommodate calls from MainFrame. \n * @param findReplacePanel TODO*/\n  public void findPrevious(FindReplacePanel findReplacePanel) {\n    findReplacePanel._frame.updateStatusField(\"Finding Previous\");\n    setSearchBackwards(true);\n    findReplacePanel._findLabelBot.setText(\"Prev\");\n    findReplacePanel._doFind();\n    if (DrJava.getConfig().getSetting(OptionConstants.FIND_REPLACE_FOCUS_IN_DEFPANE).booleanValue()) {\n      findReplacePanel._defPane.requestFocusInWindow();  // moves focus to DefinitionsPane\n    }\n  }\n}",
                "methodCount": 49
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 13,
                "candidates": [
                    {
                        "lineStart": 726,
                        "lineEnd": 736,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method findPrevious to class FindReplacePanel",
                        "description": "Move method findPrevious to edu.rice.cs.drjava.ui.FindReplacePanel\nRationale: The method findPrevious() is closely related to the functionality of the FindReplacePanel class, which is responsible for managing find and replace operations. The method manipulates UI components and state specific to the find/replace functionality, such as updating the status field, setting search direction, and interacting with the find label. Moving this method to FindReplacePanel will enhance cohesion by keeping all find/replace related logic within the same class, making the code easier to maintain and understand.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 711,
                        "lineEnd": 724,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method _shouldIgnore to class OpenDefinitionsDocument",
                        "description": "Move method _shouldIgnore to edu.rice.cs.drjava.model.OpenDefinitionsDocument\nRationale: The method _shouldIgnore() is responsible for determining whether a found instance in the document should be ignored based on specific conditions related to comments, strings, and whole word matching. Since it directly interacts with the OpenDefinitionsDocument to check if a position is shadowed (inside a comment or string) and to verify whole word matches, it logically belongs to the OpenDefinitionsDocument class. Moving this method to OpenDefinitionsDocument will enhance cohesion by keeping related functionality together, as it deals with the document's content and its parsing rules.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 676,
                        "lineEnd": 702,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method wholeWordFoundAtCurrent to class OpenDefinitionsDocument",
                        "description": "Move method wholeWordFoundAtCurrent to edu.rice.cs.drjava.model.OpenDefinitionsDocument\nRationale: The method wholeWordFoundAtCurrent() is responsible for determining if a specific word is found at a given position in a document. This functionality is closely related to the operations performed on documents, such as text retrieval and manipulation. Since OpenDefinitionsDocument is an interface that represents an open document and provides methods for text handling, it is the most appropriate class for this method. Moving this method to OpenDefinitionsDocument will enhance cohesion by ensuring that all document-related functionalities are encapsulated within the document interface, making it easier to maintain and understand the codebase.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 386,
                        "lineEnd": 415,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method _processAllInCurrentDoc to class OpenDefinitionsDocument",
                        "description": "Move method _processAllInCurrentDoc to edu.rice.cs.drjava.model.OpenDefinitionsDocument\nRationale: The method _processAllInCurrentDoc is responsible for processing occurrences of a word within a specific document (_doc). This functionality is inherently tied to the concept of an open document, which is represented by the OpenDefinitionsDocument class. The method manipulates document-specific data, such as the selection region and the document's length, which aligns with the responsibilities of OpenDefinitionsDocument. Moving this method to OpenDefinitionsDocument will enhance cohesion by ensuring that document-related operations are encapsulated within the document class itself, rather than being scattered across unrelated classes.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 274,
                        "lineEnd": 302,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method replaceAll to class OpenDefinitionsDocument",
                        "description": "Move method replaceAll to edu.rice.cs.drjava.model.OpenDefinitionsDocument\nRationale: The method replaceAll() is primarily concerned with modifying the content of documents, specifically replacing words within them. This functionality is inherently tied to the concept of a document, which is represented by the OpenDefinitionsDocument class. Moving replaceAll() to OpenDefinitionsDocument aligns it with other document-related operations, such as saving, modifying, and navigating through the document. This change will enhance the cohesion of the OpenDefinitionsDocument class by consolidating all document manipulation methods within it, making the codebase easier to understand and maintain.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 195,
                        "lineEnd": 228,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method onMatch to class OpenDefinitionsDocument",
                        "description": "Move method onMatch to edu.rice.cs.drjava.model.OpenDefinitionsDocument\nRationale: The method onMatch() is primarily concerned with determining if the current position in a document matches a specified 'find word'. This functionality is inherently tied to the document's content and its manipulation, which aligns closely with the responsibilities of the OpenDefinitionsDocument class. Moving this method to OpenDefinitionsDocument will enhance cohesion, as it will allow the document itself to manage its search functionality, rather than having it in a class that may not be directly responsible for document content. Additionally, the method's reliance on document length and text retrieval (via _doc.getText()) further supports its placement within OpenDefinitionsDocument, which is designed to handle document-related operations.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 352,
                        "lineEnd": 384,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method processAll to class OpenDefinitionsDocument",
                        "description": "Move method processAll to edu.rice.cs.drjava.model.OpenDefinitionsDocument\nRationale: The method processAll() is responsible for processing occurrences of a find word in documents, which directly relates to the functionality of an OpenDefinitionsDocument. This class represents an open document and is responsible for various document operations, including modifications and navigation. Since the method deals with document processing and requires access to document-specific data (like _docIterator and _doc), it is more appropriate for it to reside within OpenDefinitionsDocument rather than in a separate class. This move will enhance cohesion by keeping document-related operations encapsulated within the document class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 482,
                        "lineEnd": 524,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method _findWrapped to class OpenDefinitionsDocument",
                        "description": "Move method _findWrapped to edu.rice.cs.drjava.model.OpenDefinitionsDocument\nRationale: The method _findWrapped is a helper method that deals with searching within a document, specifically handling cases where the search wraps around the end of the document. Since it operates directly on an instance of OpenDefinitionsDocument and requires knowledge of the document's length and content, it is more appropriate for it to reside within the OpenDefinitionsDocument class. This class is responsible for managing the document's state and content, making it a suitable location for methods that manipulate or analyze the document's text. Moving this method will enhance cohesion by keeping related functionality together, as it directly interacts with the document's properties and methods.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 230,
                        "lineEnd": 257,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method replaceCurrent to class OpenDefinitionsDocument",
                        "description": "Move method replaceCurrent to edu.rice.cs.drjava.model.OpenDefinitionsDocument\nRationale: The method replaceCurrent() is responsible for replacing a matched word in a document with another word. This operation is inherently tied to the document's content and structure, which aligns with the responsibilities of the OpenDefinitionsDocument class. The method manipulates the document's text by removing and inserting strings, which is a core function of a document interface. Moving this method to OpenDefinitionsDocument will enhance cohesion by ensuring that all document-related operations, including text manipulation, are encapsulated within the document class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 304,
                        "lineEnd": 340,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method _replaceAllInCurrentDoc to class OpenDefinitionsDocument",
                        "description": "Move method _replaceAllInCurrentDoc to edu.rice.cs.drjava.model.OpenDefinitionsDocument\nRationale: The method _replaceAllInCurrentDoc() is responsible for performing text replacement operations within a specific document. This functionality is inherently tied to the concept of an 'OpenDefinitionsDocument', which represents an open document in the application. The method manipulates the document's content directly, making it more appropriate for it to reside within the OpenDefinitionsDocument class. Moving this method to OpenDefinitionsDocument will enhance cohesion, as it will encapsulate all document-related operations, including searching and replacing text, within the document class itself. This aligns with object-oriented principles, ensuring that methods that operate on a specific data type (in this case, a document) are located within that data type's class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 531,
                        "lineEnd": 630,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method _findNextInDocSegment to class OpenDefinitionsDocument",
                        "description": "Move method _findNextInDocSegment to edu.rice.cs.drjava.model.OpenDefinitionsDocument\nRationale: The method _findNextInDocSegment() is primarily concerned with searching for a specific word within a document segment, which directly relates to the functionality of the OpenDefinitionsDocument class. This class represents an open document and includes methods for manipulating and querying the document's content. The method's parameters, such as the document to be searched and the offsets for the search, align well with the responsibilities of OpenDefinitionsDocument. Moving this method to OpenDefinitionsDocument will enhance cohesion by keeping document-related operations within the document class, thereby improving maintainability and clarity of the code.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 632,
                        "lineEnd": 674,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method _findNextInOtherDocs to class OpenDefinitionsDocument",
                        "description": "Move method _findNextInOtherDocs to edu.rice.cs.drjava.model.OpenDefinitionsDocument\nRationale: The method _findNextInOtherDocs() is responsible for searching through documents to find a specific word, which is a functionality closely related to the operations performed on documents. Since OpenDefinitionsDocument represents an open document in the DrJava environment, it is logical to move this method to this class. The method interacts with document properties such as the document's text, length, and filename, which are all attributes of OpenDefinitionsDocument. By moving this method to OpenDefinitionsDocument, we enhance the cohesion of the class, ensuring that all document-related functionalities are encapsulated within the same class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 419,
                        "lineEnd": 465,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method findNext to class OpenDefinitionsDocument",
                        "description": "Move method findNext to edu.rice.cs.drjava.model.OpenDefinitionsDocument\nRationale: The method findNext(boolean searchAll) is primarily concerned with searching for text within a document, which aligns closely with the responsibilities of the OpenDefinitionsDocument class. This class represents an open document and includes methods for manipulating and querying the document's content. The findNext method's functionality, which involves finding occurrences of a word and managing offsets, is inherently tied to the document's text. Moving this method to OpenDefinitionsDocument would enhance cohesion by placing text search functionality within the class that directly manages the document's content.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setFindWord",
                            "method_signature": "public void setFindWord(String word)",
                            "target_class": "FindReplacePanel",
                            "rationale": "The method setFindWord() is responsible for setting the word to be found, which is more related to the user interface and user input handling. It should be moved to the FindReplacePanel class to better encapsulate the functionality related to user interactions."
                        },
                        {
                            "method_name": "setReplaceWord",
                            "method_signature": "public void setReplaceWord(String word)",
                            "target_class": "FindReplacePanel",
                            "rationale": "The method setReplaceWord() is responsible for setting the word to be replaced, which is more related to the user interface and user input handling. It should be moved to the FindReplacePanel class to better encapsulate the functionality related to user interactions."
                        },
                        {
                            "method_name": "findPrevious",
                            "method_signature": "public void findPrevious(FindReplacePanel findReplacePanel)",
                            "target_class": "FindReplacePanel",
                            "rationale": "The method findPrevious() interacts directly with the FindReplacePanel to update the UI and manage user commands. It should be moved to the FindReplacePanel class to maintain a clear separation of concerns between the UI and the find/replace logic."
                        }
                    ],
                    "llm_response_time": 4875
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "setFindWord",
                            "method_signature": "public void setFindWord(String word)",
                            "target_class": "FindReplacePanel",
                            "rationale": "The method setFindWord() is responsible for setting the word to be found, which is more related to the user interface and user input handling. It should be moved to the FindReplacePanel class to better encapsulate the UI logic."
                        },
                        {
                            "method_name": "setReplaceWord",
                            "method_signature": "public void setReplaceWord(String word)",
                            "target_class": "FindReplacePanel",
                            "rationale": "The method setReplaceWord() is responsible for setting the word to replace, which is more related to the user interface and user input handling. It should be moved to the FindReplacePanel class to better encapsulate the UI logic."
                        },
                        {
                            "method_name": "findPrevious",
                            "method_signature": "public void findPrevious(FindReplacePanel findReplacePanel)",
                            "target_class": "FindReplacePanel",
                            "rationale": "The findPrevious() method interacts directly with the FindReplacePanel to update the UI and perform actions based on user commands. It should be moved to the FindReplacePanel class to maintain a clear separation of concerns."
                        },
                        {
                            "method_name": "cleanUp",
                            "method_signature": "public void cleanUp()",
                            "target_class": "DocumentManager",
                            "rationale": "The cleanUp() method is responsible for cleaning up resources related to document handling. It should be moved to a DocumentManager class to centralize document management responsibilities."
                        },
                        {
                            "method_name": "processAll",
                            "method_signature": "public int processAll(Runnable1<FindResult> findAction, MovingDocumentRegion region)",
                            "target_class": "DocumentProcessor",
                            "rationale": "The processAll() method is focused on processing occurrences of the find word in documents. It should be moved to a DocumentProcessor class to better encapsulate document processing logic."
                        }
                    ],
                    "llm_response_time": 5358
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "setFindWord",
                            "method_signature": "public void setFindWord(String word)",
                            "target_class": "FindReplacePanel",
                            "rationale": "The method setFindWord() is responsible for setting the word to be found, which is more related to the user interface and user input handling. It should be moved to the FindReplacePanel class to better encapsulate the UI logic."
                        },
                        {
                            "method_name": "setReplaceWord",
                            "method_signature": "public void setReplaceWord(String word)",
                            "target_class": "FindReplacePanel",
                            "rationale": "The method setReplaceWord() is responsible for setting the word to replace, which is also related to user input handling. It should be moved to the FindReplacePanel class to maintain separation of concerns."
                        },
                        {
                            "method_name": "findPrevious",
                            "method_signature": "public void findPrevious(FindReplacePanel findReplacePanel)",
                            "target_class": "FindReplacePanel",
                            "rationale": "The findPrevious() method interacts directly with the FindReplacePanel to update the UI and manage user actions. It should be moved to the FindReplacePanel class to keep UI-related logic together."
                        },
                        {
                            "method_name": "cleanUp",
                            "method_signature": "public void cleanUp()",
                            "target_class": "DocumentManager",
                            "rationale": "The cleanUp() method is responsible for cleaning up resources related to document handling. It should be moved to a DocumentManager class to better manage document lifecycle and resource management."
                        },
                        {
                            "method_name": "processAll",
                            "method_signature": "public int processAll(Runnable1<FindResult> findAction, MovingDocumentRegion region)",
                            "target_class": "DocumentProcessor",
                            "rationale": "The processAll() method is focused on processing occurrences of the find word in documents. It should be moved to a DocumentProcessor class to encapsulate document processing logic."
                        }
                    ],
                    "llm_response_time": 5294
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "onMatch",
                            "method_signature": "public onMatch()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceCurrent",
                            "method_signature": "public replaceCurrent()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAll",
                            "method_signature": "private replaceAll(boolean searchAll, boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_replaceAllInCurrentDoc",
                            "method_signature": "private _replaceAllInCurrentDoc(boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "processAll",
                            "method_signature": "private processAll(Runnable1<FindResult> findAction, boolean searchAll, boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_processAllInCurrentDoc",
                            "method_signature": "private _processAllInCurrentDoc(Runnable1<FindResult> findAction, boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "findNext",
                            "method_signature": "private findNext(boolean searchAll)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_findWrapped",
                            "method_signature": "private _findWrapped(OpenDefinitionsDocument doc, int start, int len, boolean allWrapped)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_findNextInDocSegment",
                            "method_signature": "private _findNextInDocSegment(final OpenDefinitionsDocument doc, final int start, int len, \n                                           final boolean wrapped, final boolean allWrapped)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_findNextInOtherDocs",
                            "method_signature": "private _findNextInOtherDocs(final OpenDefinitionsDocument startDoc, int start, int len)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "wholeWordFoundAtCurrent",
                            "method_signature": "private wholeWordFoundAtCurrent(OpenDefinitionsDocument doc, int foundOffset)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_shouldIgnore",
                            "method_signature": "private _shouldIgnore(int foundOffset, OpenDefinitionsDocument odd)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "findPrevious",
                            "method_signature": "public findPrevious(FindReplacePanel findReplacePanel)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "findPrevious",
                            "method_signature": "public findPrevious(FindReplacePanel findReplacePanel)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_shouldIgnore",
                            "method_signature": "private _shouldIgnore(int foundOffset, OpenDefinitionsDocument odd)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "wholeWordFoundAtCurrent",
                            "method_signature": "private wholeWordFoundAtCurrent(OpenDefinitionsDocument doc, int foundOffset)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_processAllInCurrentDoc",
                            "method_signature": "private _processAllInCurrentDoc(Runnable1<FindResult> findAction, boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAll",
                            "method_signature": "private replaceAll(boolean searchAll, boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "onMatch",
                            "method_signature": "public onMatch()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "processAll",
                            "method_signature": "private processAll(Runnable1<FindResult> findAction, boolean searchAll, boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_findWrapped",
                            "method_signature": "private _findWrapped(OpenDefinitionsDocument doc, int start, int len, boolean allWrapped)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceCurrent",
                            "method_signature": "public replaceCurrent()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_replaceAllInCurrentDoc",
                            "method_signature": "private _replaceAllInCurrentDoc(boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_findNextInDocSegment",
                            "method_signature": "private _findNextInDocSegment(final OpenDefinitionsDocument doc, final int start, int len, \n                                           final boolean wrapped, final boolean allWrapped)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "_findNextInOtherDocs",
                            "method_signature": "private _findNextInOtherDocs(final OpenDefinitionsDocument startDoc, int start, int len)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "findNext",
                            "method_signature": "private findNext(boolean searchAll)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public findPrevious(FindReplacePanel findReplacePanel)": {
                        "first": {
                            "method_name": "findPrevious",
                            "method_signature": "public findPrevious(FindReplacePanel findReplacePanel)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3625444400946508
                    },
                    "private _shouldIgnore(int foundOffset, OpenDefinitionsDocument odd)": {
                        "first": {
                            "method_name": "_shouldIgnore",
                            "method_signature": "private _shouldIgnore(int foundOffset, OpenDefinitionsDocument odd)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.49240729493159374
                    },
                    "private wholeWordFoundAtCurrent(OpenDefinitionsDocument doc, int foundOffset)": {
                        "first": {
                            "method_name": "wholeWordFoundAtCurrent",
                            "method_signature": "private wholeWordFoundAtCurrent(OpenDefinitionsDocument doc, int foundOffset)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6432168980183842
                    },
                    "private _processAllInCurrentDoc(Runnable1<FindResult> findAction, boolean searchSelectionOnly)": {
                        "first": {
                            "method_name": "_processAllInCurrentDoc",
                            "method_signature": "private _processAllInCurrentDoc(Runnable1<FindResult> findAction, boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6432448714169622
                    },
                    "private replaceAll(boolean searchAll, boolean searchSelectionOnly)": {
                        "first": {
                            "method_name": "replaceAll",
                            "method_signature": "private replaceAll(boolean searchAll, boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6507569839179113
                    },
                    "public onMatch()": {
                        "first": {
                            "method_name": "onMatch",
                            "method_signature": "public onMatch()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6718871537150495
                    },
                    "private processAll(Runnable1<FindResult> findAction, boolean searchAll, boolean searchSelectionOnly)": {
                        "first": {
                            "method_name": "processAll",
                            "method_signature": "private processAll(Runnable1<FindResult> findAction, boolean searchAll, boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6730068826340173
                    },
                    "private _findWrapped(OpenDefinitionsDocument doc, int start, int len, boolean allWrapped)": {
                        "first": {
                            "method_name": "_findWrapped",
                            "method_signature": "private _findWrapped(OpenDefinitionsDocument doc, int start, int len, boolean allWrapped)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6785317652256864
                    },
                    "public replaceCurrent()": {
                        "first": {
                            "method_name": "replaceCurrent",
                            "method_signature": "public replaceCurrent()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7273616010113746
                    },
                    "private _replaceAllInCurrentDoc(boolean searchSelectionOnly)": {
                        "first": {
                            "method_name": "_replaceAllInCurrentDoc",
                            "method_signature": "private _replaceAllInCurrentDoc(boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7547829734657191
                    },
                    "private _findNextInDocSegment(final OpenDefinitionsDocument doc, final int start, int len, \n                                           final boolean wrapped, final boolean allWrapped)": {
                        "first": {
                            "method_name": "_findNextInDocSegment",
                            "method_signature": "private _findNextInDocSegment(final OpenDefinitionsDocument doc, final int start, int len, \n                                           final boolean wrapped, final boolean allWrapped)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7615535616293236
                    },
                    "private _findNextInOtherDocs(final OpenDefinitionsDocument startDoc, int start, int len)": {
                        "first": {
                            "method_name": "_findNextInOtherDocs",
                            "method_signature": "private _findNextInOtherDocs(final OpenDefinitionsDocument startDoc, int start, int len)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.785232794229798
                    },
                    "private findNext(boolean searchAll)": {
                        "first": {
                            "method_name": "findNext",
                            "method_signature": "private findNext(boolean searchAll)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.8208406266505709
                    }
                },
                "voyage": {
                    "private _shouldIgnore(int foundOffset, OpenDefinitionsDocument odd)": {
                        "first": {
                            "method_name": "_shouldIgnore",
                            "method_signature": "private _shouldIgnore(int foundOffset, OpenDefinitionsDocument odd)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5246550890928038
                    },
                    "private _findWrapped(OpenDefinitionsDocument doc, int start, int len, boolean allWrapped)": {
                        "first": {
                            "method_name": "_findWrapped",
                            "method_signature": "private _findWrapped(OpenDefinitionsDocument doc, int start, int len, boolean allWrapped)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6054560438918527
                    },
                    "private wholeWordFoundAtCurrent(OpenDefinitionsDocument doc, int foundOffset)": {
                        "first": {
                            "method_name": "wholeWordFoundAtCurrent",
                            "method_signature": "private wholeWordFoundAtCurrent(OpenDefinitionsDocument doc, int foundOffset)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6258065600137099
                    },
                    "public findPrevious(FindReplacePanel findReplacePanel)": {
                        "first": {
                            "method_name": "findPrevious",
                            "method_signature": "public findPrevious(FindReplacePanel findReplacePanel)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6390916372680939
                    },
                    "private _findNextInDocSegment(final OpenDefinitionsDocument doc, final int start, int len, \n                                           final boolean wrapped, final boolean allWrapped)": {
                        "first": {
                            "method_name": "_findNextInDocSegment",
                            "method_signature": "private _findNextInDocSegment(final OpenDefinitionsDocument doc, final int start, int len, \n                                           final boolean wrapped, final boolean allWrapped)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6591994397220606
                    },
                    "private findNext(boolean searchAll)": {
                        "first": {
                            "method_name": "findNext",
                            "method_signature": "private findNext(boolean searchAll)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6751660095915589
                    },
                    "public onMatch()": {
                        "first": {
                            "method_name": "onMatch",
                            "method_signature": "public onMatch()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6832311538735304
                    },
                    "private replaceAll(boolean searchAll, boolean searchSelectionOnly)": {
                        "first": {
                            "method_name": "replaceAll",
                            "method_signature": "private replaceAll(boolean searchAll, boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6838286899447485
                    },
                    "private _findNextInOtherDocs(final OpenDefinitionsDocument startDoc, int start, int len)": {
                        "first": {
                            "method_name": "_findNextInOtherDocs",
                            "method_signature": "private _findNextInOtherDocs(final OpenDefinitionsDocument startDoc, int start, int len)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6884720266921364
                    },
                    "private processAll(Runnable1<FindResult> findAction, boolean searchAll, boolean searchSelectionOnly)": {
                        "first": {
                            "method_name": "processAll",
                            "method_signature": "private processAll(Runnable1<FindResult> findAction, boolean searchAll, boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7002960365189259
                    },
                    "public replaceCurrent()": {
                        "first": {
                            "method_name": "replaceCurrent",
                            "method_signature": "public replaceCurrent()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7107417862362034
                    },
                    "private _processAllInCurrentDoc(Runnable1<FindResult> findAction, boolean searchSelectionOnly)": {
                        "first": {
                            "method_name": "_processAllInCurrentDoc",
                            "method_signature": "private _processAllInCurrentDoc(Runnable1<FindResult> findAction, boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7407136680369756
                    },
                    "private _replaceAllInCurrentDoc(boolean searchSelectionOnly)": {
                        "first": {
                            "method_name": "_replaceAllInCurrentDoc",
                            "method_signature": "private _replaceAllInCurrentDoc(boolean searchSelectionOnly)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7687218399132086
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private _shouldIgnore(int foundOffset, OpenDefinitionsDocument odd)",
                        "private wholeWordFoundAtCurrent(OpenDefinitionsDocument doc, int foundOffset)",
                        "private _replaceAllInCurrentDoc(boolean searchSelectionOnly)",
                        "private _findNextInDocSegment(final OpenDefinitionsDocument doc, final int start, int len, \n                                           final boolean wrapped, final boolean allWrapped)",
                        "private _findNextInOtherDocs(final OpenDefinitionsDocument startDoc, int start, int len)",
                        "private replaceAll(boolean searchAll, boolean searchSelectionOnly)",
                        "private processAll(Runnable1<FindResult> findAction, boolean searchAll, boolean searchSelectionOnly)",
                        "public onMatch()",
                        "public findPrevious(FindReplacePanel findReplacePanel)",
                        "public replaceCurrent()",
                        "private _findWrapped(OpenDefinitionsDocument doc, int start, int len, boolean allWrapped)",
                        "private _processAllInCurrentDoc(Runnable1<FindResult> findAction, boolean searchSelectionOnly)"
                    ],
                    "llm_response_time": 4364
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "private _shouldIgnore(int foundOffset, OpenDefinitionsDocument odd)",
                        "private wholeWordFoundAtCurrent(OpenDefinitionsDocument doc, int foundOffset)",
                        "private _processAllInCurrentDoc(Runnable1<FindResult> findAction, boolean searchSelectionOnly)",
                        "private replaceAll(boolean searchAll, boolean searchSelectionOnly)",
                        "public findPrevious(FindReplacePanel findReplacePanel)"
                    ],
                    "llm_response_time": 1466
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private wholeWordFoundAtCurrent(OpenDefinitionsDocument doc, int foundOffset)",
                        "private _shouldIgnore(int foundOffset, OpenDefinitionsDocument odd)",
                        "public findPrevious(FindReplacePanel findReplacePanel)"
                    ],
                    "llm_response_time": 1063
                },
                "voyage": {
                    "priority_method_names": [
                        "private _shouldIgnore(int foundOffset, OpenDefinitionsDocument odd)",
                        "private wholeWordFoundAtCurrent(OpenDefinitionsDocument doc, int foundOffset)",
                        "private _findWrapped(OpenDefinitionsDocument doc, int start, int len, boolean allWrapped)",
                        "private _findNextInOtherDocs(final OpenDefinitionsDocument startDoc, int start, int len)",
                        "private replaceAll(boolean searchAll, boolean searchSelectionOnly)",
                        "private processAll(Runnable1<FindResult> findAction, boolean searchAll, boolean searchSelectionOnly)",
                        "private _processAllInCurrentDoc(Runnable1<FindResult> findAction, boolean searchSelectionOnly)",
                        "private _replaceAllInCurrentDoc(boolean searchSelectionOnly)",
                        "public findPrevious(FindReplacePanel findReplacePanel)",
                        "public onMatch()",
                        "private findNext(boolean searchAll)",
                        "public replaceCurrent()"
                    ],
                    "llm_response_time": 2795
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private _shouldIgnore(int foundOffset, OpenDefinitionsDocument odd)",
                        "private wholeWordFoundAtCurrent(OpenDefinitionsDocument doc, int foundOffset)",
                        "private _findWrapped(OpenDefinitionsDocument doc, int start, int len, boolean allWrapped)",
                        "private _findNextInDocSegment(final OpenDefinitionsDocument doc, final int start, int len, \n                                           final boolean wrapped, final boolean allWrapped)",
                        "public findPrevious(FindReplacePanel findReplacePanel)"
                    ],
                    "llm_response_time": 1452
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private wholeWordFoundAtCurrent(OpenDefinitionsDocument doc, int foundOffset)",
                        "private _shouldIgnore(int foundOffset, OpenDefinitionsDocument odd)",
                        "private _findWrapped(OpenDefinitionsDocument doc, int start, int len, boolean allWrapped)"
                    ],
                    "llm_response_time": 1089
                }
            },
            "targetClassMap": {
                "findPrevious": {
                    "target_classes": [
                        {
                            "class_name": "FindReplacePanel",
                            "similarity_score": 0.4308905487222346
                        },
                        {
                            "class_name": "Log",
                            "similarity_score": 0.46535297065997305
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.3355648232820143
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.3355648232820143
                        },
                        {
                            "class_name": "MovingDocumentRegion",
                            "similarity_score": 0.36078116394544285
                        },
                        {
                            "class_name": "DocumentIterator",
                            "similarity_score": 0.23399988233151736
                        },
                        {
                            "class_name": "SingleDisplayModel",
                            "similarity_score": 0.31502679847198584
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "FindReplacePanel",
                        "MovingDocumentRegion",
                        "Log"
                    ],
                    "llm_response_time": 4618,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                },
                "_shouldIgnore": {
                    "target_classes": [
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.6178196277365555
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.6178196277365555
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.6178196277365555
                        },
                        {
                            "class_name": "DocumentIterator",
                            "similarity_score": 0.5133659648101242
                        },
                        {
                            "class_name": "SingleDisplayModel",
                            "similarity_score": 0.5559219037623252
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument"
                    ],
                    "llm_response_time": 1738,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "wholeWordFoundAtCurrent": {
                    "target_classes": [
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.32018342714418885
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.32018342714418885
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.32018342714418885
                        },
                        {
                            "class_name": "DocumentIterator",
                            "similarity_score": 0.2700630660000221
                        },
                        {
                            "class_name": "SingleDisplayModel",
                            "similarity_score": 0.28290954371224675
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument"
                    ],
                    "llm_response_time": 2104,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "_processAllInCurrentDoc": {
                    "target_classes": [
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.5455049209095691
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.5455049209095691
                        },
                        {
                            "class_name": "DocumentIterator",
                            "similarity_score": 0.4902039305659662
                        },
                        {
                            "class_name": "SingleDisplayModel",
                            "similarity_score": 0.6010732371901732
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument",
                        "SingleDisplayModel"
                    ],
                    "llm_response_time": 3209,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "replaceAll": {
                    "target_classes": [
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.5034633375153633
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.5034633375153633
                        },
                        {
                            "class_name": "DocumentIterator",
                            "similarity_score": 0.44677151042852925
                        },
                        {
                            "class_name": "SingleDisplayModel",
                            "similarity_score": 0.44001322123410475
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument",
                        "DocumentIterator"
                    ],
                    "llm_response_time": 2551,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "onMatch": {
                    "target_classes": [
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.3936026109260315
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.3936026109260315
                        },
                        {
                            "class_name": "DocumentIterator",
                            "similarity_score": 0.24958371522661943
                        },
                        {
                            "class_name": "SingleDisplayModel",
                            "similarity_score": 0.32097617947401613
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument",
                        "SingleDisplayModel"
                    ],
                    "llm_response_time": 3539,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "processAll": {
                    "target_classes": [
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.5594891929967519
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.5594891929967519
                        },
                        {
                            "class_name": "DocumentIterator",
                            "similarity_score": 0.4692408782697458
                        },
                        {
                            "class_name": "SingleDisplayModel",
                            "similarity_score": 0.5002343086460749
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument",
                        "SingleDisplayModel"
                    ],
                    "llm_response_time": 2926,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "_findWrapped": {
                    "target_classes": [
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.22579161149581345
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.22579161149581345
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.22579161149581345
                        },
                        {
                            "class_name": "DocumentIterator",
                            "similarity_score": 0.18743035694147456
                        },
                        {
                            "class_name": "SingleDisplayModel",
                            "similarity_score": 0.2078300391054046
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument"
                    ],
                    "llm_response_time": 2114,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "replaceCurrent": {
                    "target_classes": [
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.2820168897228548
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.2820168897228548
                        },
                        {
                            "class_name": "DocumentIterator",
                            "similarity_score": 0.1449635825263096
                        },
                        {
                            "class_name": "SingleDisplayModel",
                            "similarity_score": 0.18979159324723632
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument",
                        "SingleDisplayModel"
                    ],
                    "llm_response_time": 2989,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "_replaceAllInCurrentDoc": {
                    "target_classes": [
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.4809840064647499
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.4809840064647499
                        },
                        {
                            "class_name": "DocumentIterator",
                            "similarity_score": 0.41596946406838614
                        },
                        {
                            "class_name": "SingleDisplayModel",
                            "similarity_score": 0.5284983820353367
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument",
                        "SingleDisplayModel"
                    ],
                    "llm_response_time": 4975,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "_findNextInDocSegment": {
                    "target_classes": [
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.26198313264354284
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.26198313264354284
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.26198313264354284
                        },
                        {
                            "class_name": "DocumentIterator",
                            "similarity_score": 0.16885982817437376
                        },
                        {
                            "class_name": "SingleDisplayModel",
                            "similarity_score": 0.23563827056369008
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument"
                    ],
                    "llm_response_time": 1883,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "_findNextInOtherDocs": {
                    "target_classes": [
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.44644974412276156
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.44644974412276156
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.44644974412276156
                        },
                        {
                            "class_name": "DocumentIterator",
                            "similarity_score": 0.35213917707670445
                        },
                        {
                            "class_name": "SingleDisplayModel",
                            "similarity_score": 0.3921107782251196
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument"
                    ],
                    "llm_response_time": 2447,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "findNext": {
                    "target_classes": [
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.5493647212366687
                        },
                        {
                            "class_name": "OpenDefinitionsDocument",
                            "similarity_score": 0.5493647212366687
                        },
                        {
                            "class_name": "DocumentIterator",
                            "similarity_score": 0.40945484269188126
                        },
                        {
                            "class_name": "SingleDisplayModel",
                            "similarity_score": 0.46783552115724364
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OpenDefinitionsDocument",
                        "OpenDefinitionsDocument",
                        "SingleDisplayModel"
                    ],
                    "llm_response_time": 2857,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method edu.rice.cs.drjava.ui.config.VectorFileOptionComponent::reset2():void need move to edu.rice.cs.drjava.ui.ProjectPropertiesFrame",
        "class_name": "edu.rice.cs.drjava.ui.config.VectorFileOptionComponent",
        "telemetry": {
            "id": "3a2e862e-09ea-4dc3-a951-16fdba7a235b",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 108,
                "lineStart": 57,
                "lineEnd": 164,
                "bodyLineStart": 57,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/drjava/large/big/drjava-stable-20100913-r5387/src/src/edu/rice/cs/drjava/ui/config/VectorFileOptionComponent.java",
                "sourceCode": "/** Graphical form of a VectorOption for the Extra Classpath/Sourcepath options.\n  * Uses a file chooser for each File element.\n *  @version $Id: VectorFileOptionComponent.java 5246 2010-05-07 19:10:44Z mgricken $\n */\npublic class VectorFileOptionComponent extends VectorOptionComponent<File> implements OptionConstants {\n  private JFileChooser _jfc;\n  protected File _baseDir = null;\n  \n  public VectorFileOptionComponent(VectorOption<File> opt, String text, SwingFrame parent) {\n    this(opt, text, parent, null);\n  }\n  \n  /** Constructor that allows for a tooltip description. */\n  public VectorFileOptionComponent(VectorOption<File> opt, String text, SwingFrame parent, String description) {\n    this(opt, text, parent, description, false);\n  }\n\n  /** Constructor with flag for move buttons. */\n  public VectorFileOptionComponent(VectorOption<File> opt, String text, SwingFrame parent,\n                                   String description, boolean moveButtonEnabled) {\n    super(opt, text, parent, new String[] { }, description, moveButtonEnabled);  // creates all four buttons\n    \n    // set up JFileChooser\n    File workDir = new File(System.getProperty(\"user.home\"));\n\n    _jfc = new JFileChooser(workDir);\n    _jfc.setDialogTitle(\"Select\");\n    _jfc.setApproveButtonText(\"Select\");\n    _jfc.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);\n    _jfc.setMultiSelectionEnabled(true);\n    _jfc.setFileFilter(ClassPathFilter.ONLY);\n  }\n\n  /** Sets the directory where the chooser will start if no file is selected. */\n  public void setBaseDir(File f) {\n    if (f.isDirectory()) { _baseDir = f; }\n  }\n  \n  /** Shows a file chooser for adding a file to the element. */\n  public void chooseFile() {\n    int[] rows = _table.getSelectedRows();\n    File selection = (rows.length==1)?_data.get(rows[0]):null;\n    if (selection != null) {\n      File parent = selection.getParentFile();\n      if (parent != null) {\n        _jfc.setCurrentDirectory(parent);\n      }\n    }\n    else {\n      if (_baseDir != null) { _jfc.setCurrentDirectory(_baseDir); }\n    }\n\n    File[] c = null;\n    int returnValue = _jfc.showDialog(_parent, null);\n    if (returnValue == JFileChooser.APPROVE_OPTION) {\n      c = _jfc.getSelectedFiles();\n    }\n    if (c != null) {\n      _table.getSelectionModel().clearSelection();\n      for(int i = 0; i < c.length; i++) {\n        _addValue(c[i]);\n      }\n    }\n  }\n  \n  /** @return the file chooser */\n  public JFileChooser getFileChooser() {\n    return _jfc;\n  }\n  \n  protected Action _getAddAction() {\n    return new AbstractAction(\"Add\") {\n      public void actionPerformed(ActionEvent ae) {\n        chooseFile();\n      }\n    };\n  }\n\npublic void reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot) {\n//  Utilities.show(\"reset(\" + projRoot + \")\");\n    projectPropertiesFrame._projRootSelector.setFileField(projRoot);\n\n    final File bd = projectPropertiesFrame._model.getBuildDirectory();\n    final JTextField bdTextField = projectPropertiesFrame._buildDirSelector.getFileField();\n    if (bd == FileOps.NULL_FILE) bdTextField.setText(\"\");\n    else projectPropertiesFrame._buildDirSelector.setFileField(bd);\n\n    final File wd = projectPropertiesFrame._model.getWorkingDirectory();\n    final JTextField wdTextField = projectPropertiesFrame._workDirSelector.getFileField();\n    if (wd == FileOps.NULL_FILE) wdTextField.setText(\"\");\n    else projectPropertiesFrame._workDirSelector.setFileField(wd);\n\n    final String mc = projectPropertiesFrame._model.getMainClass();\n    final JTextField mcTextField = projectPropertiesFrame._mainDocumentSelector;\n    if (mc == null) mcTextField.setText(\"\");\n    else mcTextField.setText(mc);\n    \n    projectPropertiesFrame._autoRefreshComponent.setSelected(projectPropertiesFrame._getAutoRefreshStatus());\n\n    ArrayList<AbsRelFile> cp = new ArrayList<AbsRelFile>(CollectUtil.makeList(projectPropertiesFrame._model.getExtraClassPath()));\n    projectPropertiesFrame._extraClassPathList.setValue(cp);\n\n    ArrayList<File> ef = new ArrayList<File>();\n    for(File f: projectPropertiesFrame._model.getExclFiles()) { ef.add(f); }\n    setValue(ef);\n    projectPropertiesFrame._applyButton.setEnabled(false);\n  }\n}",
                "methodCount": 9
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 134,
                        "lineEnd": 162,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method reset2 to class ProjectPropertiesFrame",
                        "description": "Move method reset2 to edu.rice.cs.drjava.ui.ProjectPropertiesFrame\nRationale: The method reset2() is heavily tied to the ProjectPropertiesFrame class, as it directly manipulates its components and updates its state based on the model's data. Moving this method to ProjectPropertiesFrame will enhance cohesion, as it will reside within the class that owns the UI elements it interacts with. This method is responsible for resetting various fields in the frame based on the project properties, making it a natural fit for this class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "reset2",
                            "method_signature": "public void reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot)",
                            "target_class": "ProjectPropertiesFrame",
                            "rationale": "The reset2 method manipulates the ProjectPropertiesFrame and its components directly, indicating that it is more appropriate for this method to reside within the ProjectPropertiesFrame class."
                        }
                    ],
                    "llm_response_time": 1990
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "reset2",
                            "method_signature": "public void reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot)",
                            "target_class": "ProjectPropertiesFrame",
                            "rationale": "The reset2 method is heavily interacting with the ProjectPropertiesFrame class, manipulating its fields and methods. It would be more appropriate for this method to reside within the ProjectPropertiesFrame class to maintain cohesion and encapsulation."
                        }
                    ],
                    "llm_response_time": 2914
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "reset2",
                            "method_signature": "public void reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot)",
                            "target_class": "ProjectPropertiesFrame",
                            "rationale": "The reset2 method is heavily interacting with the ProjectPropertiesFrame class, manipulating its fields and methods. It would be more appropriate for this method to reside within the ProjectPropertiesFrame class to maintain better cohesion and encapsulation."
                        }
                    ],
                    "llm_response_time": 1761
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "reset2",
                            "method_signature": "public reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "reset2",
                            "method_signature": "public reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot)": {
                        "first": {
                            "method_name": "reset2",
                            "method_signature": "public reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.43844802953950635
                    }
                },
                "voyage": {
                    "public reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot)": {
                        "first": {
                            "method_name": "reset2",
                            "method_signature": "public reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.41510622632527866
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot)"
                    ],
                    "llm_response_time": 1415
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot)"
                    ],
                    "llm_response_time": 0
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot)"
                    ],
                    "llm_response_time": 0
                },
                "voyage": {
                    "priority_method_names": [
                        "public reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot)"
                    ],
                    "llm_response_time": 0
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot)"
                    ],
                    "llm_response_time": 1
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public reset2(ProjectPropertiesFrame projectPropertiesFrame, File projRoot)"
                    ],
                    "llm_response_time": 0
                }
            },
            "targetClassMap": {
                "reset2": {
                    "target_classes": [
                        {
                            "class_name": "ProjectPropertiesFrame",
                            "similarity_score": 0.6216409139090413
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ProjectPropertiesFrame"
                    ],
                    "llm_response_time": 1880,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method edu.rice.cs.drjava.model.repl.InteractionsDJDocument::testHistoryRecallNextMovesToEnd():void need move to edu.rice.cs.drjava.ui.InteractionsPaneTest",
        "class_name": "edu.rice.cs.drjava.model.repl.InteractionsDJDocument",
        "telemetry": {
            "id": "54604365-a275-4ea3-851b-e460cfedf882",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 290,
                "lineStart": 61,
                "lineEnd": 350,
                "bodyLineStart": 61,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/jmove/dataset-tse/drjava/large/big/drjava-stable-20100913-r5387/src/src/edu/rice/cs/drjava/model/repl/InteractionsDJDocument.java",
                "sourceCode": "/** Represents a Swing-based InteractionsDocument. Extends AbstractDJDocument which contains code shared by\n  * the Swing interactions and definitions documents.\n  */\npublic class InteractionsDJDocument extends AbstractDJDocument implements ConsoleDocumentInterface {\n  \n  /** Whether the document currently has a prompt and is ready to accept input. */\n  private volatile boolean _hasPrompt;\n  \n  /** A flag indicating that the interpreter was recently reset, and to reset the styles list \n    * the next time a style is added. Cannot reset immediately because then the styles would be lost while \n    * the interactions pane is resetting.\n    */\n  private volatile boolean _toClear = false;\n  \n // fields for use by undo/redo functionality\n  private volatile CompoundUndoManager _undoManager;\n  private static final int UNDO_LIMIT = 100;\n  private volatile boolean _isModifiedSinceSave = false;\n  private GlobalEventNotifier _notifier;\n  \n  /** Standard constructor. */\n  public InteractionsDJDocument() { \n    super(); \n    _hasPrompt = false;\n    _notifier = new GlobalEventNotifier(); // so this isn't null\n  } \n   \n\n  public InteractionsDJDocument(GlobalEventNotifier notifier){\n   super();\n   _hasPrompt = false;\n   _notifier=notifier;\n   resetUndoManager();\n  }\n  \n  public boolean hasPrompt() { return _hasPrompt; }\n  \n  /** Sets the _hasPrompt property. \n    * @param val new boolean value for _hasPrompt.\n    */\n  public void setHasPrompt(boolean val) { \n    _hasPrompt = val;\n  }\n  \n  protected void _styleChanged() { /* Do nothing */ }\n \n  //-------------Undo/Redo Functionality---------------------// \n  /** Appending any information for the reduced model from each undo command */\n  private static class CommandUndoableEdit extends AbstractUndoableEdit {\n    private final Runnable _undoCommand;\n    private final Runnable _redoCommand;\n    \n    public CommandUndoableEdit(final Runnable undoCommand, final Runnable redoCommand) {\n      _undoCommand = undoCommand;\n      _redoCommand = redoCommand;\n    }\n    \n    public void undo() throws CannotUndoException {\n      super.undo();\n      _undoCommand.run();\n    }\n    \n    public void redo() throws CannotRedoException {\n      super.redo();\n      _redoCommand.run();\n    }\n    \n    public boolean isSignificant() { return false; }\n  }\n  \n  /** Getter method for CompoundUndoManager\n    * @return _undoManager\n    */\n  public CompoundUndoManager getUndoManager() { return _undoManager; }\n  \n  /** Resets the undo manager. */\n  public void resetUndoManager() {\n    _undoManager = new CompoundUndoManager(_notifier);\n    _undoManager.setLimit(UNDO_LIMIT);\n  }\n  \n  /** Public accessor for the next undo action. */\n  public UndoableEdit getNextUndo() { return _undoManager.getNextUndo(); }\n  \n  /** Public accessor for the next undo action. */\n  public UndoableEdit getNextRedo() { return _undoManager.getNextRedo(); }\n  \n  /** Informs this document's undo manager that the document has been saved. */\n  public void documentSaved() { _undoManager.documentSaved(); }\n \n  protected int startCompoundEdit() { return _undoManager.startCompoundEdit(); }\n  \n  protected void endCompoundEdit(int key) { _undoManager.endCompoundEdit(key); }\n  \n  //This method added for FrenchKeyBoardFix\n  protected void endLastCompoundEdit() { _undoManager.endLastCompoundEdit(); }\n  \n  protected void addUndoRedo(AbstractDocument.DefaultDocumentEvent chng, Runnable undoCommand, Runnable doCommand) {\n    chng.addEdit(new CommandUndoableEdit(undoCommand, doCommand));    \n  }\n  \n  public boolean undoManagerCanUndo() {\n   return _undoManager.canUndo();\n  }\n  \n  public boolean undoManagerCanRedo(){\n    return _undoManager.canRedo();\n  }\n  \n  public void updateModifiedSinceSave() {\n    _isModifiedSinceSave = _undoManager.isModified();\n   // if (_odd != null) _odd.documentReset();\n  }\n  \n  /** Sets the modification state of this document to true and updates the state of the associated _odd. \n    * Assumes that write lock is already held. \n    */\n  private void _setModifiedSinceSave() {\n/* */ assert Utilities.TEST_MODE || EventQueue.isDispatchThread();\n    if (! _isModifiedSinceSave) {\n      _isModifiedSinceSave = true;\n      //if (_odd != null) _odd.documentModified();  // null test required for some unit tests\n    }    \n  }\n  \n  /** Resets the modification state of this document.  Used after a document has been saved or reverted. */\n  public void resetModification() {\n    _isModifiedSinceSave = false;\n    _undoManager.documentSaved();\n   // if (_odd != null) _odd.documentReset();  // null test required for some unit tests\n  }\n  \n  /** Determines if the document has been modified since the last save.\n    * @return true if the document has been modified\n    */\n  public boolean isModifiedSinceSave() { return  _isModifiedSinceSave; }\n  \n  //-------------end Undo/Redo Functionality---------------------// \n  \n  \n  /** Returns a new indenter. Eventually to be used to return an interactions indenter */\n  protected Indenter makeNewIndenter(int indentLevel) { return new Indenter(indentLevel); }\n  \n  /** A list of styles and their locations augmenting this document.  This augmentation is NOT part of the reduced\n    * model; it a separate extension that uses itself as a mutual exclusion lock.  This list holds pairs of location\n    * intervals and strings (identifying styles).  In essence it maps regions to colors (??).\n    * in the document and styles, which is basically a map of regions where the coloring view that is now attached to\n    * the Interactions Pane.  It is not allowed to use the reduced model to determine the color settings when \n    * rendering text. (Why not? -- Corky)  We keep a list of all places where styles not considered by the reduced \n    * are being used, such as System.out, System.err, and the various return styles for Strings and other Objects.  \n    * Since the LinkedList class is not thread safe,  we have to synchronized all methods that access pointers in \n    * _stylesList and the associated boolean _toClear.\n    */\n  private List<Pair<Pair<Integer,Integer>,String>> _stylesList = new LinkedList<Pair<Pair<Integer,Integer>,String>>();\n  \n  /** Adds the given coloring style to the styles list.  Only runs in event thread. */\n  public void addColoring(int start, int end, String style) {\n//    synchronized(_stylesList) {\n    if (_toClear) {\n      _stylesList.clear();    \n      _toClear = false;\n    }\n    if (style != null)\n      _stylesList.add(0, new Pair<Pair<Integer,Integer>,String>\n                      (new Pair<Integer,Integer>(Integer.valueOf(start),Integer.valueOf(end)), style));\n//    }\n  }\n  \n  /** Accessor method used to copy contents of _stylesList to an array.  Used in test cases. */\n  public Pair<Pair<Integer, Integer>, String>[] getStyles() { \n    synchronized(_stylesList) {\n        // TODO: file javac bug report concerning placement of @SuppressWarnings.  Fails if rhs of result binding is used as body of return statement.\n        @SuppressWarnings(\"unchecked\")\n        Pair<Pair<Integer, Integer>, String>[] result = _stylesList.toArray(new Pair[0]);\n        return result;\n    }\n  }\n  \n  /** Attempts to set the coloring on the graphics based upon the content of the styles list\n    * returns false if the point is not in the list.  Only runs in event thread.\n    */\n  public boolean setColoring(int point, Graphics g) {\n    synchronized(_stylesList) {\n      for(Pair<Pair<Integer,Integer>,String> p :  _stylesList) {\n        Pair<Integer,Integer> loc = p.first();\n        if (loc.first() <= point && loc.second() >= point) {\n          if (p.second().equals(InteractionsDocument.ERROR_STYLE)) {\n            //DrJava.consoleErr().println(\"Error Style\");\n            g.setColor(ERROR_COLOR);   \n            g.setFont(g.getFont().deriveFont(Font.BOLD));\n          }\n          else if (p.second().equals(InteractionsDocument.DEBUGGER_STYLE)) {\n            //DrJava.consoleErr().println(\"Debugger Style\");\n            g.setColor(DEBUGGER_COLOR);\n            g.setFont(g.getFont().deriveFont(Font.BOLD));\n          }\n          else if (p.second().equals(ConsoleDocument.SYSTEM_OUT_STYLE)) {\n            //DrJava.consoleErr().println(\"System.out Style\");\n            g.setColor(INTERACTIONS_SYSTEM_OUT_COLOR);\n            g.setFont(MAIN_FONT);\n          }\n          else if (p.second().equals(ConsoleDocument.SYSTEM_IN_STYLE)) {\n            //DrJava.consoleErr().println(\"System.in Style\");\n            g.setColor(INTERACTIONS_SYSTEM_IN_COLOR);\n            g.setFont(MAIN_FONT);\n          }\n          else if (p.second().equals(ConsoleDocument.SYSTEM_ERR_STYLE)) {\n            //DrJava.consoleErr().println(\"System.err Style\");\n            g.setColor(INTERACTIONS_SYSTEM_ERR_COLOR);\n            g.setFont(MAIN_FONT);\n          }\n          else if (p.second().equals(InteractionsDocument.OBJECT_RETURN_STYLE)) {\n            g.setColor(NORMAL_COLOR);\n            g.setFont(MAIN_FONT);\n          }\n          else if (p.second().equals(InteractionsDocument.STRING_RETURN_STYLE)) {\n            g.setColor(DOUBLE_QUOTED_COLOR);\n            g.setFont(MAIN_FONT);\n          }\n          else if (p.second().equals(InteractionsDocument.NUMBER_RETURN_STYLE)) {\n            g.setColor(NUMBER_COLOR);\n            g.setFont(MAIN_FONT);\n          }\n          else if (p.second().equals(InteractionsDocument.CHARACTER_RETURN_STYLE)) {\n            g.setColor(SINGLE_QUOTED_COLOR);\n            g.setFont(MAIN_FONT);\n          }\n          else return false; /* Normal text color */ \n          \n          return true;\n        }\n      }\n      return false;\n    }\n  }\n  \n  /** Attempts to set the font on the graphics context based upon the styles held in the styles list. Only runs in\n    * event thread. \n    */\n  public void setBoldFonts(int point, Graphics g) {\n    synchronized(_stylesList) {\n      for(Pair<Pair<Integer,Integer>,String> p :  _stylesList) {\n        Pair<Integer,Integer> loc = p.first();\n        if (loc.first() <= point && loc.second() >= point) {\n          if (p.second().equals(InteractionsDocument.ERROR_STYLE))\n            g.setFont(g.getFont().deriveFont(Font.BOLD));\n          else if (p.second().equals(InteractionsDocument.DEBUGGER_STYLE))\n            g.setFont(g.getFont().deriveFont(Font.BOLD));\n          else  g.setFont(MAIN_FONT);\n          return;\n        }\n      }\n    }\n  }\n  \n  /** Called when the Interactions pane is reset.  Only runs in event thread. */\n  public void clearColoring() { synchronized(_stylesList) { _toClear = true; } }\n  \n  /** @return true iff the end of the current interaction is an open comment block\n    */\n  public boolean _inBlockComment() {\n        boolean toReturn = _inBlockComment(getLength());\n        return toReturn;\n  }\n  \n  /** Inserts the given exception data into the document with the given style.\n    * @param message Message contained in the exception\n    * @param styleName name of the style for formatting the exception\n    */\n  public void appendExceptionResult(String message, String styleName) {\n    // Note that there is similar code in InteractionsDocument.  Something should be refactored.\n    try { insertText(getLength(), message + \"\\n\", styleName); }\n    catch (EditDocumentException ble) { throw new UnexpectedException(ble); }\n  }\n\n\n/** Tests that moving the caret down (recalling the next command from history) will move the caret to the end of\n    * the document.\n * @param interactionsPaneTest TODO\n    */\n  public void testHistoryRecallNextMovesToEnd(final InteractionsPaneTest interactionsPaneTest) {\n    Utilities.invokeAndWait(new Runnable() { \n      public void run() {\n        interactionsPaneTest._pane.setCaretPosition(1);\n        interactionsPaneTest._controller.historyNextAction.actionPerformed(null);\n      }\n    });\n    Assert.assertEquals(\"Caret not moved to end on down arrow.\", interactionsPaneTest._doc.getLength(), interactionsPaneTest._pane.getCaretPosition());\n  }\n}",
                "methodCount": 34
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 4,
                "candidates": [
                    {
                        "lineStart": 165,
                        "lineEnd": 167,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method undoManagerCanRedo to class CompoundUndoManager",
                        "description": "Move method undoManagerCanRedo to edu.rice.cs.drjava.model.definitions.CompoundUndoManager\nRationale: The method undoManagerCanRedo() checks if the UndoManager can redo an action by calling _undoManager.canRedo(). Since CompoundUndoManager extends UndoManager and is specifically designed to handle complex undo/redo operations, it is more appropriate for this method to reside in CompoundUndoManager. This class already manages the state of undoable edits and provides methods related to undoing and redoing actions. Moving this method to CompoundUndoManager will enhance cohesion by keeping all related undo/redo functionality within the same class, thereby improving maintainability and clarity of the code.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 161,
                        "lineEnd": 163,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method undoManagerCanUndo to class CompoundUndoManager",
                        "description": "Move method undoManagerCanUndo to edu.rice.cs.drjava.model.definitions.CompoundUndoManager\nRationale: The method 'undoManagerCanUndo()' checks if the undo manager can perform an undo operation by calling '_undoManager.canUndo()'. Since 'CompoundUndoManager' extends 'UndoManager' and provides additional functionality for managing compound edits, it is logical for this method to reside within 'CompoundUndoManager'. This class is specifically designed to handle undo operations, including the management of compound edits, making it the most appropriate location for this method. Moving it here will enhance cohesion, as the method directly relates to the undo capabilities of the compound manager.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 147,
                        "lineEnd": 148,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method documentSaved to class CompoundUndoManager",
                        "description": "Move method documentSaved to edu.rice.cs.drjava.model.definitions.CompoundUndoManager\nRationale: The method documentSaved() is responsible for notifying the undo manager that the document has been saved. This functionality is directly related to managing the state of undoable edits, which is a core responsibility of the CompoundUndoManager class. Moving this method to CompoundUndoManager aligns it with the class's purpose of handling undo and redo operations, including maintaining the state of edits before and after a save. Additionally, the existing implementation of documentSaved() already interacts with the internal state of CompoundUndoManager, specifically by calling endCompoundEdit() and updating the _savePoint. Therefore, it is logical to encapsulate this behavior within the CompoundUndoManager class to enhance cohesion and maintainability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 336,
                        "lineEnd": 348,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method testHistoryRecallNextMovesToEnd to class InteractionsPaneTest",
                        "description": "Move method testHistoryRecallNextMovesToEnd to edu.rice.cs.drjava.ui.InteractionsPaneTest\nRationale: The method testHistoryRecallNextMovesToEnd is a unit test that specifically checks the behavior of the InteractionsPane when recalling the next command from history. Since it directly interacts with the InteractionsPane and its controller, it logically belongs in the InteractionsPaneTest class, which is designed to test the functionality of the InteractionsPane. Moving this method to InteractionsPaneTest will enhance the organization of the test suite by ensuring that all tests related to the InteractionsPane are contained within the same class, making it easier to maintain and understand.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "appendExceptionResult",
                            "method_signature": "public void appendExceptionResult(String message, String styleName)",
                            "target_class": "ExceptionHandler",
                            "rationale": "The method appendExceptionResult is responsible for handling exception messages and formatting them with styles. This functionality is more appropriate in a dedicated ExceptionHandler class that can manage exception-related operations."
                        },
                        {
                            "method_name": "setColoring",
                            "method_signature": "public boolean setColoring(int point, Graphics g)",
                            "target_class": "ColoringManager",
                            "rationale": "The setColoring method deals with applying colors based on styles, which is a specific responsibility that can be encapsulated in a separate ColoringManager class, improving separation of concerns."
                        },
                        {
                            "method_name": "setBoldFonts",
                            "method_signature": "public void setBoldFonts(int point, Graphics g)",
                            "target_class": "FontManager",
                            "rationale": "The setBoldFonts method is focused on font styling based on conditions. This functionality should be moved to a FontManager class that can handle all font-related operations."
                        },
                        {
                            "method_name": "clearColoring",
                            "method_signature": "public void clearColoring()",
                            "target_class": "ColoringManager",
                            "rationale": "The clearColoring method is related to managing the coloring state of the document. It should be moved to a ColoringManager class to centralize all coloring-related functionalities."
                        }
                    ],
                    "llm_response_time": 5161
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "appendExceptionResult",
                            "method_signature": "public void appendExceptionResult(String message, String styleName)",
                            "target_class": "ExceptionHandler",
                            "rationale": "The method appendExceptionResult is responsible for handling exception messages and their formatting. It would be more appropriate to move this method to a dedicated ExceptionHandler class that deals with exception-related operations."
                        },
                        {
                            "method_name": "setColoring",
                            "method_signature": "public boolean setColoring(int point, Graphics g)",
                            "target_class": "ColoringManager",
                            "rationale": "The setColoring method is focused on applying styles and colors based on certain conditions. Moving it to a ColoringManager class would encapsulate all coloring logic in one place, improving separation of concerns."
                        },
                        {
                            "method_name": "setBoldFonts",
                            "method_signature": "public void setBoldFonts(int point, Graphics g)",
                            "target_class": "FontManager",
                            "rationale": "The setBoldFonts method is responsible for setting font styles based on conditions. It should be moved to a FontManager class to centralize font-related functionalities."
                        },
                        {
                            "method_name": "clearColoring",
                            "method_signature": "public void clearColoring()",
                            "target_class": "ColoringManager",
                            "rationale": "The clearColoring method is related to managing the coloring state of the document. It should be moved to a ColoringManager class to maintain a clear responsibility for coloring operations."
                        }
                    ],
                    "llm_response_time": 5154
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "appendExceptionResult",
                            "method_signature": "public void appendExceptionResult(String message, String styleName)",
                            "target_class": "ExceptionHandler",
                            "rationale": "The method appendExceptionResult is responsible for handling exception messages and formatting them with styles. It would be more appropriate to move this method to a dedicated ExceptionHandler class that deals with exception formatting and logging."
                        },
                        {
                            "method_name": "setColoring",
                            "method_signature": "public boolean setColoring(int point, Graphics g)",
                            "target_class": "ColoringManager",
                            "rationale": "The setColoring method is focused on applying styles and colors based on certain conditions. Moving it to a ColoringManager class would encapsulate the coloring logic and separate it from the document management responsibilities."
                        },
                        {
                            "method_name": "setBoldFonts",
                            "method_signature": "public void setBoldFonts(int point, Graphics g)",
                            "target_class": "FontManager",
                            "rationale": "The setBoldFonts method is responsible for setting font styles based on conditions. It would be better suited in a FontManager class that handles font-related operations, improving separation of concerns."
                        },
                        {
                            "method_name": "clearColoring",
                            "method_signature": "public void clearColoring()",
                            "target_class": "ColoringManager",
                            "rationale": "The clearColoring method is related to managing the coloring state of the document. Moving it to a ColoringManager class would centralize all coloring-related functionality."
                        }
                    ],
                    "llm_response_time": 5846
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "resetUndoManager",
                            "method_signature": "public resetUndoManager()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "documentSaved",
                            "method_signature": "public documentSaved()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "startCompoundEdit",
                            "method_signature": "protected startCompoundEdit()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "endCompoundEdit",
                            "method_signature": "protected endCompoundEdit(int key)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "endLastCompoundEdit",
                            "method_signature": "protected endLastCompoundEdit()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "undoManagerCanUndo",
                            "method_signature": "public undoManagerCanUndo()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "undoManagerCanRedo",
                            "method_signature": "public undoManagerCanRedo()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "resetModification",
                            "method_signature": "public resetModification()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "run",
                            "method_signature": "public run()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "testHistoryRecallNextMovesToEnd",
                            "method_signature": "public testHistoryRecallNextMovesToEnd(final InteractionsPaneTest interactionsPaneTest)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "endLastCompoundEdit",
                            "method_signature": "protected endLastCompoundEdit()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "undoManagerCanRedo",
                            "method_signature": "public undoManagerCanRedo()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "endCompoundEdit",
                            "method_signature": "protected endCompoundEdit(int key)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "startCompoundEdit",
                            "method_signature": "protected startCompoundEdit()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "run",
                            "method_signature": "public run()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "resetModification",
                            "method_signature": "public resetModification()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "undoManagerCanUndo",
                            "method_signature": "public undoManagerCanUndo()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "documentSaved",
                            "method_signature": "public documentSaved()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "resetUndoManager",
                            "method_signature": "public resetUndoManager()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "testHistoryRecallNextMovesToEnd",
                            "method_signature": "public testHistoryRecallNextMovesToEnd(final InteractionsPaneTest interactionsPaneTest)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "protected endLastCompoundEdit()": {
                        "first": {
                            "method_name": "endLastCompoundEdit",
                            "method_signature": "protected endLastCompoundEdit()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3372189440626163
                    },
                    "public undoManagerCanRedo()": {
                        "first": {
                            "method_name": "undoManagerCanRedo",
                            "method_signature": "public undoManagerCanRedo()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3564901895249745
                    },
                    "protected endCompoundEdit(int key)": {
                        "first": {
                            "method_name": "endCompoundEdit",
                            "method_signature": "protected endCompoundEdit(int key)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.38790380939789487
                    },
                    "protected startCompoundEdit()": {
                        "first": {
                            "method_name": "startCompoundEdit",
                            "method_signature": "protected startCompoundEdit()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.39369604123231894
                    },
                    "public run()": {
                        "first": {
                            "method_name": "run",
                            "method_signature": "public run()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4574994986686106
                    },
                    "public resetModification()": {
                        "first": {
                            "method_name": "resetModification",
                            "method_signature": "public resetModification()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4884171260594718
                    },
                    "public undoManagerCanUndo()": {
                        "first": {
                            "method_name": "undoManagerCanUndo",
                            "method_signature": "public undoManagerCanUndo()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4923703010881489
                    },
                    "public documentSaved()": {
                        "first": {
                            "method_name": "documentSaved",
                            "method_signature": "public documentSaved()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5195071136628947
                    },
                    "public resetUndoManager()": {
                        "first": {
                            "method_name": "resetUndoManager",
                            "method_signature": "public resetUndoManager()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5660697217594112
                    },
                    "public testHistoryRecallNextMovesToEnd(final InteractionsPaneTest interactionsPaneTest)": {
                        "first": {
                            "method_name": "testHistoryRecallNextMovesToEnd",
                            "method_signature": "public testHistoryRecallNextMovesToEnd(final InteractionsPaneTest interactionsPaneTest)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6126615303735786
                    }
                },
                "voyage": {
                    "public undoManagerCanRedo()": {
                        "first": {
                            "method_name": "undoManagerCanRedo",
                            "method_signature": "public undoManagerCanRedo()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3668173949691355
                    },
                    "public undoManagerCanUndo()": {
                        "first": {
                            "method_name": "undoManagerCanUndo",
                            "method_signature": "public undoManagerCanUndo()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.36955640270319706
                    },
                    "protected endCompoundEdit(int key)": {
                        "first": {
                            "method_name": "endCompoundEdit",
                            "method_signature": "protected endCompoundEdit(int key)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3774919532937622
                    },
                    "public resetUndoManager()": {
                        "first": {
                            "method_name": "resetUndoManager",
                            "method_signature": "public resetUndoManager()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.38128526136704016
                    },
                    "protected startCompoundEdit()": {
                        "first": {
                            "method_name": "startCompoundEdit",
                            "method_signature": "protected startCompoundEdit()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.41562318527221104
                    },
                    "public documentSaved()": {
                        "first": {
                            "method_name": "documentSaved",
                            "method_signature": "public documentSaved()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4240263220046103
                    },
                    "protected endLastCompoundEdit()": {
                        "first": {
                            "method_name": "endLastCompoundEdit",
                            "method_signature": "protected endLastCompoundEdit()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4536085465016134
                    },
                    "public testHistoryRecallNextMovesToEnd(final InteractionsPaneTest interactionsPaneTest)": {
                        "first": {
                            "method_name": "testHistoryRecallNextMovesToEnd",
                            "method_signature": "public testHistoryRecallNextMovesToEnd(final InteractionsPaneTest interactionsPaneTest)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.454402805282931
                    },
                    "public run()": {
                        "first": {
                            "method_name": "run",
                            "method_signature": "public run()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.47032605591697085
                    },
                    "public resetModification()": {
                        "first": {
                            "method_name": "resetModification",
                            "method_signature": "public resetModification()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4816581532323327
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public resetModification()",
                        "public documentSaved()",
                        "public resetUndoManager()",
                        "protected endCompoundEdit(int key)",
                        "protected startCompoundEdit()",
                        "public undoManagerCanUndo()",
                        "public undoManagerCanRedo()",
                        "protected endLastCompoundEdit()",
                        "public run()",
                        "public testHistoryRecallNextMovesToEnd(final InteractionsPaneTest interactionsPaneTest)"
                    ],
                    "llm_response_time": 1367
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "protected endCompoundEdit(int key)",
                        "protected startCompoundEdit()",
                        "protected endLastCompoundEdit()",
                        "public undoManagerCanRedo()",
                        "public run()"
                    ],
                    "llm_response_time": 722
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "protected endCompoundEdit(int key)",
                        "protected endLastCompoundEdit()",
                        "public undoManagerCanRedo()"
                    ],
                    "llm_response_time": 628
                },
                "voyage": {
                    "priority_method_names": [
                        "public resetUndoManager()",
                        "public documentSaved()",
                        "public resetModification()",
                        "public undoManagerCanUndo()",
                        "public undoManagerCanRedo()",
                        "protected startCompoundEdit()",
                        "protected endCompoundEdit(int key)",
                        "protected endLastCompoundEdit()",
                        "public testHistoryRecallNextMovesToEnd(final InteractionsPaneTest interactionsPaneTest)",
                        "public run()"
                    ],
                    "llm_response_time": 1374
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public resetUndoManager()",
                        "protected startCompoundEdit()",
                        "protected endCompoundEdit(int key)",
                        "public undoManagerCanUndo()",
                        "public undoManagerCanRedo()"
                    ],
                    "llm_response_time": 964
                },
                "voyage-3": {
                    "priority_method_names": [
                        "protected endCompoundEdit(int key)",
                        "public undoManagerCanUndo()",
                        "public undoManagerCanRedo()"
                    ],
                    "llm_response_time": 697
                }
            },
            "targetClassMap": {
                "endLastCompoundEdit": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2833,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "undoManagerCanRedo": {
                    "target_classes": [
                        {
                            "class_name": "CompoundUndoManager",
                            "similarity_score": 0.2549790940173477
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CompoundUndoManager"
                    ],
                    "llm_response_time": 1665,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "endCompoundEdit": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2606,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "startCompoundEdit": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2540,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "run": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2525,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "resetModification": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2879,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "undoManagerCanUndo": {
                    "target_classes": [
                        {
                            "class_name": "CompoundUndoManager",
                            "similarity_score": 0.34554408400824077
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CompoundUndoManager"
                    ],
                    "llm_response_time": 1904,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "documentSaved": {
                    "target_classes": [
                        {
                            "class_name": "CompoundUndoManager",
                            "similarity_score": 0.5046154940409081
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CompoundUndoManager"
                    ],
                    "llm_response_time": 2304,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "resetUndoManager": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3772,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "testHistoryRecallNextMovesToEnd": {
                    "target_classes": [
                        {
                            "class_name": "InteractionsPaneTest",
                            "similarity_score": 0.4760666623795118
                        },
                        {
                            "class_name": "CompoundUndoManager",
                            "similarity_score": 0.5503153559251456
                        },
                        {
                            "class_name": "GlobalEventNotifier",
                            "similarity_score": 0.5340811772049542
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "InteractionsPaneTest",
                        "CompoundUndoManager",
                        "GlobalEventNotifier"
                    ],
                    "llm_response_time": 4598,
                    "similarity_computation_time": 10,
                    "similarity_metric": "cosine"
                }
            }
        }
    }
]