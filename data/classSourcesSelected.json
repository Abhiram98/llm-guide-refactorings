{
    "ID_0": "public abstract class AbstractColumnFamilyInputFormat<K, Y> extends InputFormat<K, Y> implements org.apache.hadoop.mapred.InputFormat<K, Y>\n{\n    private static final Logger logger = LoggerFactory.getLogger(AbstractColumnFamilyInputFormat.class);\n\n    public static final String MAPRED_TASK_ID = \"mapred.task.id\";\n    // The simple fact that we need this is because the old Hadoop API wants us to \"write\"\n    // to the key and value whereas the new asks for it.\n    // I choose 8kb as the default max key size (instantiated only once), but you can\n    // override it in your jobConf with this setting.\n    public static final String CASSANDRA_HADOOP_MAX_KEY_SIZE = \"cassandra.hadoop.max_key_size\";\n    public static final int    CASSANDRA_HADOOP_MAX_KEY_SIZE_DEFAULT = 8192;\n\n    private String keyspace;\n    private String cfName;\n    private IPartitioner partitioner;\n    private Session session;\n\n    protected void validateConfiguration(Configuration conf)\n    {\n        if (ConfigHelper.getInputKeyspace(conf) == null || ConfigHelper.getInputColumnFamily(conf) == null)\n        {\n            throw new UnsupportedOperationException(\"you must set the keyspace and table with setInputColumnFamily()\");\n        }\n        if (ConfigHelper.getInputInitialAddress(conf) == null)\n            throw new UnsupportedOperationException(\"You must set the initial output address to a Cassandra node with setInputInitialAddress\");\n        if (ConfigHelper.getInputPartitioner(conf) == null)\n            throw new UnsupportedOperationException(\"You must set the Cassandra partitioner class with setInputPartitioner\");\n    }\n\n    public List<InputSplit> getSplits(JobContext context) throws IOException\n    {\n        Configuration conf = HadoopCompat.getConfiguration(context);\n\n        validateConfiguration(conf);\n\n        keyspace = ConfigHelper.getInputKeyspace(conf);\n        cfName = ConfigHelper.getInputColumnFamily(conf);\n        partitioner = ConfigHelper.getInputPartitioner(conf);\n        logger.debug(\"partitioner is {}\", partitioner);\n\n        // canonical ranges and nodes holding replicas\n        Map<TokenRange, Set<Host>> masterRangeNodes = getRangeMap(conf, keyspace);\n\n        // canonical ranges, split into pieces, fetching the splits in parallel\n        ExecutorService executor = new ThreadPoolExecutor(0, 128, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());\n        List<InputSplit> splits = new ArrayList<>();\n\n        try\n        {\n            List<Future<List<InputSplit>>> splitfutures = new ArrayList<>();\n            KeyRange jobKeyRange = ConfigHelper.getInputKeyRange(conf);\n            Range<Token> jobRange = null;\n            if (jobKeyRange != null)\n            {\n                if (jobKeyRange.start_key != null)\n                {\n                    if (!partitioner.preservesOrder())\n                        throw new UnsupportedOperationException(\"KeyRange based on keys can only be used with a order preserving partitioner\");\n                    if (jobKeyRange.start_token != null)\n                        throw new IllegalArgumentException(\"only start_key supported\");\n                    if (jobKeyRange.end_token != null)\n                        throw new IllegalArgumentException(\"only start_key supported\");\n                    jobRange = new Range<>(partitioner.getToken(jobKeyRange.start_key),\n                                           partitioner.getToken(jobKeyRange.end_key));\n                }\n                else if (jobKeyRange.start_token != null)\n                {\n                    jobRange = new Range<>(partitioner.getTokenFactory().fromString(jobKeyRange.start_token),\n                                           partitioner.getTokenFactory().fromString(jobKeyRange.end_token));\n                }\n                else\n                {\n                    logger.warn(\"ignoring jobKeyRange specified without start_key or start_token\");\n                }\n            }\n\n            session = CqlConfigHelper.getInputCluster(ConfigHelper.getInputInitialAddress(conf).split(\",\"), conf).connect();\n            Metadata metadata = session.getCluster().getMetadata();\n\n            for (TokenRange range : masterRangeNodes.keySet())\n            {\n                if (jobRange == null)\n                {\n                    // for each tokenRange, pick a live owner and ask it to compute bite-sized splits\n                    splitfutures.add(executor.submit(new SplitCallable(range, masterRangeNodes.get(range), conf)));\n                }\n                else\n                {\n                    TokenRange jobTokenRange = rangeToTokenRange(metadata, jobRange);\n                    if (range.intersects(jobTokenRange))\n                    {\n                        for (TokenRange intersection: range.intersectWith(jobTokenRange))\n                        {\n                            // for each tokenRange, pick a live owner and ask it to compute bite-sized splits\n                            splitfutures.add(executor.submit(new SplitCallable(intersection,  masterRangeNodes.get(range), conf)));\n                        }\n                    }\n                }\n            }\n\n            // wait until we have all the results back\n            for (Future<List<InputSplit>> futureInputSplits : splitfutures)\n            {\n                try\n                {\n                    splits.addAll(futureInputSplits.get());\n                }\n                catch (Exception e)\n                {\n                    throw new IOException(\"Could not get input splits\", e);\n                }\n            }\n        }\n        finally\n        {\n            executor.shutdownNow();\n        }\n\n        assert splits.size() > 0;\n        Collections.shuffle(splits, new Random(System.nanoTime()));\n        return splits;\n    }\n\n    private TokenRange rangeToTokenRange(Metadata metadata, Range<Token> range)\n    {\n        return metadata.newTokenRange(metadata.newToken(partitioner.getTokenFactory().toString(range.left)),\n                metadata.newToken(partitioner.getTokenFactory().toString(range.right)));\n    }\n\n    /**\n     * Gets a token tokenRange and splits it up according to the suggested\n     * size into input splits that Hadoop can use.\n     */\n    class SplitCallable implements Callable<List<InputSplit>>\n    {\n\n        private final TokenRange tokenRange;\n        private final Set<Host> hosts;\n        private final Configuration conf;\n\n        public SplitCallable(TokenRange tr, Set<Host> hosts, Configuration conf)\n        {\n            this.tokenRange = tr;\n            this.hosts = hosts;\n            this.conf = conf;\n        }\n\n        public List<InputSplit> call() throws Exception\n        {\n            ArrayList<InputSplit> splits = new ArrayList<>();\n            Map<TokenRange, Long> subSplits;\n            subSplits = getSubSplits(keyspace, cfName, tokenRange, conf);\n            // turn the sub-ranges into InputSplits\n            String[] endpoints = new String[hosts.size()];\n\n            // hadoop needs hostname, not ip\n            int endpointIndex = 0;\n            for (Host endpoint : hosts)\n                endpoints[endpointIndex++] = endpoint.getAddress().getHostName();\n\n            boolean partitionerIsOpp = partitioner instanceof OrderPreservingPartitioner || partitioner instanceof ByteOrderedPartitioner;\n\n            for (TokenRange subSplit : subSplits.keySet())\n            {\n                List<TokenRange> ranges = subSplit.unwrap();\n                for (TokenRange subrange : ranges)\n                {\n                    ColumnFamilySplit split =\n                            new ColumnFamilySplit(\n                                    partitionerIsOpp ?\n                                            subrange.getStart().toString().substring(2) : subrange.getStart().toString(),\n                                    partitionerIsOpp ?\n                                            subrange.getEnd().toString().substring(2) : subrange.getStart().toString(),\n                                    subSplits.get(subSplit),\n                                    endpoints);\n\n                    logger.debug(\"adding {}\", split);\n                    splits.add(split);\n                }\n            }\n            return splits;\n        }\n    }\n\n    private Map<TokenRange, Long> getSubSplits(String keyspace, String cfName, TokenRange range, Configuration conf) throws IOException\n    {\n        int splitSize = ConfigHelper.getInputSplitSize(conf);\n        try\n        {\n            return describeSplits(keyspace, cfName, range, splitSize);\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private Map<TokenRange, Set<Host>> getRangeMap(Configuration conf, String keyspace)\n    {\n        try (Session session = CqlConfigHelper.getInputCluster(ConfigHelper.getInputInitialAddress(conf).split(\",\"), conf).connect())\n        {\n            Map<TokenRange, Set<Host>> map = new HashMap<>();\n            Metadata metadata = session.getCluster().getMetadata();\n            for (TokenRange tokenRange : metadata.getTokenRanges())\n                map.put(tokenRange, metadata.getReplicas('\"' + keyspace + '\"', tokenRange));\n            return map;\n        }\n    }\n\n    private Map<TokenRange, Long> describeSplits(String keyspace, String table, TokenRange tokenRange, int splitSize)\n    {\n        String query = String.format(\"SELECT mean_partition_size, partitions_count \" +\n                                     \"FROM %s.%s \" +\n                                     \"WHERE keyspace_name = ? AND table_name = ? AND range_start = ? AND range_end = ?\",\n                                     SystemKeyspace.NAME,\n                                     SystemKeyspace.SIZE_ESTIMATES);\n\n        ResultSet resultSet = session.execute(query, keyspace, table, tokenRange.getStart().toString(), tokenRange.getEnd().toString());\n\n        Row row = resultSet.one();\n        // If we have no data on this split, return the full split i.e., do not sub-split\n        // Assume smallest granularity of partition count available from CASSANDRA-7688\n        if (row == null)\n        {\n            Map<TokenRange, Long> wrappedTokenRange = new HashMap<>();\n            wrappedTokenRange.put(tokenRange, (long) 128);\n            return wrappedTokenRange;\n        }\n\n        long meanPartitionSize = row.getLong(\"mean_partition_size\");\n        long partitionCount = row.getLong(\"partitions_count\");\n\n        int splitCount = (int)((meanPartitionSize * partitionCount) / splitSize);\n        List<TokenRange> splitRanges = tokenRange.splitEvenly(splitCount);\n        Map<TokenRange, Long> rangesWithLength = new HashMap<>();\n        for (TokenRange range : splitRanges)\n            rangesWithLength.put(range, partitionCount/splitCount);\n\n        return rangesWithLength;\n    }\n\n    // Old Hadoop API\n    public org.apache.hadoop.mapred.InputSplit[] getSplits(JobConf jobConf, int numSplits) throws IOException\n    {\n        TaskAttemptContext tac = HadoopCompat.newTaskAttemptContext(jobConf, new TaskAttemptID());\n        List<org.apache.hadoop.mapreduce.InputSplit> newInputSplits = this.getSplits(tac);\n        org.apache.hadoop.mapred.InputSplit[] oldInputSplits = new org.apache.hadoop.mapred.InputSplit[newInputSplits.size()];\n        for (int i = 0; i < newInputSplits.size(); i++)\n            oldInputSplits[i] = (ColumnFamilySplit)newInputSplits.get(i);\n        return oldInputSplits;\n    }\n}\n",
    "ID_1": "public class PlatformTestUtil {\n  public static final boolean COVERAGE_ENABLED_BUILD = \"true\".equals(System.getProperty(\"idea.coverage.enabled.build\"));\n\n  private static final boolean SKIP_HEADLESS = GraphicsEnvironment.isHeadless();\n  private static final boolean SKIP_SLOW = Boolean.getBoolean(\"skip.slow.tests.locally\");\n\n  public static <T> void registerExtension(@NotNull ExtensionPointName<T> name, @NotNull T t, @NotNull Disposable parentDisposable) {\n    registerExtension(Extensions.getRootArea(), name, t, parentDisposable);\n  }\n\n  public static <T> void registerExtension(@NotNull ExtensionsArea area, @NotNull ExtensionPointName<T> name, @NotNull final T t, @NotNull Disposable parentDisposable) {\n    final ExtensionPoint<T> extensionPoint = area.getExtensionPoint(name.getName());\n    extensionPoint.registerExtension(t);\n    Disposer.register(parentDisposable, new Disposable() {\n      @Override\n      public void dispose() {\n        extensionPoint.unregisterExtension(t);\n      }\n    });\n  }\n\n  @Nullable\n  protected static String toString(@Nullable Object node, @Nullable Queryable.PrintInfo printInfo) {\n    if (node instanceof AbstractTreeNode) {\n      if (printInfo != null) {\n        return ((AbstractTreeNode)node).toTestString(printInfo);\n      }\n      else {\n        @SuppressWarnings({\"deprecation\", \"UnnecessaryLocalVariable\"})\n        final String presentation = ((AbstractTreeNode)node).getTestPresentation();\n        return presentation;\n      }\n    }\n    if (node == null) {\n      return \"NULL\";\n    }\n    return node.toString();\n  }\n\n  public static String print(JTree tree, boolean withSelection) {\n    return print(tree, tree.getModel().getRoot(), withSelection, null, null);\n  }\n\n  public static String print(JTree tree, Object root, @Nullable Queryable.PrintInfo printInfo, boolean withSelection) {\n    return print(tree, root,  withSelection, printInfo, null);\n  }\n\n  public static String print(JTree tree, boolean withSelection, @Nullable Condition<String> nodePrintCondition) {\n    return print(tree, tree.getModel().getRoot(), withSelection, null, nodePrintCondition);\n  }\n  \n  public static String print(JTree tree, Object root, \n                             boolean withSelection,\n                             @Nullable Queryable.PrintInfo printInfo,\n                             @Nullable Condition<String> nodePrintCondition) {\n    StringBuilder buffer = new StringBuilder();\n    final Collection<String> strings = printAsList(tree, root, withSelection, printInfo, nodePrintCondition);\n    for (String string : strings) {\n      buffer.append(string).append(\"\\n\");\n    }\n    return buffer.toString();\n  }\n\n  public static Collection<String> printAsList(JTree tree, boolean withSelection, @Nullable Condition<String> nodePrintCondition) {\n    return printAsList(tree, tree.getModel().getRoot(), withSelection, null, nodePrintCondition);\n  }\n\n  private static Collection<String> printAsList(JTree tree, Object root, \n                                                boolean withSelection,\n                                                @Nullable Queryable.PrintInfo printInfo,\n                                                Condition<String> nodePrintCondition) {\n    Collection<String> strings = new ArrayList<String>();\n    printImpl(tree, root, strings, 0, withSelection, printInfo, nodePrintCondition);\n    return strings;\n  }\n\n  private static void printImpl(JTree tree,\n                                Object root,\n                                Collection<String> strings,\n                                int level,\n                                boolean withSelection,\n                                @Nullable Queryable.PrintInfo printInfo,\n                                @Nullable Condition<String> nodePrintCondition) {\n    DefaultMutableTreeNode defaultMutableTreeNode = (DefaultMutableTreeNode)root;\n\n    final Object userObject = defaultMutableTreeNode.getUserObject();\n    String nodeText;\n    if (userObject != null) {\n      nodeText = toString(userObject, printInfo);\n    }\n    else {\n      nodeText = \"null\";\n    }\n\n    if (nodePrintCondition != null && !nodePrintCondition.value(nodeText)) return;\n\n    final StringBuilder buff = new StringBuilder();\n    StringUtil.repeatSymbol(buff, ' ', level);\n\n    final boolean expanded = tree.isExpanded(new TreePath(defaultMutableTreeNode.getPath()));\n    if (!defaultMutableTreeNode.isLeaf()) {\n      buff.append(expanded ? \"-\" : \"+\");\n    }\n\n    final boolean selected = tree.getSelectionModel().isPathSelected(new TreePath(defaultMutableTreeNode.getPath()));\n    if (withSelection && selected) {\n      buff.append(\"[\");\n    }\n\n    buff.append(nodeText);\n\n    if (withSelection && selected) {\n      buff.append(\"]\");\n    }\n\n    strings.add(buff.toString());\n\n    int childCount = tree.getModel().getChildCount(root);\n    if (expanded) {\n      for (int i = 0; i < childCount; i++) {\n        printImpl(tree, tree.getModel().getChild(root, i), strings, level + 1, withSelection, printInfo, nodePrintCondition);\n      }\n    }\n  }\n\n  public static void assertTreeEqual(JTree tree, @NonNls String expected) {\n    assertTreeEqual(tree, expected, false);\n  }\n\n  public static void assertTreeEqualIgnoringNodesOrder(JTree tree, @NonNls String expected) {\n    assertTreeEqualIgnoringNodesOrder(tree, expected, false);\n  }\n\n  public static void assertTreeEqual(JTree tree, String expected, boolean checkSelected) {\n    String treeStringPresentation = print(tree, checkSelected);\n    assertEquals(expected, treeStringPresentation);\n  }\n\n  public static void assertTreeEqualIgnoringNodesOrder(JTree tree, String expected, boolean checkSelected) {\n    final Collection<String> actualNodesPresentation = printAsList(tree, checkSelected, null);\n    final List<String> expectedNodes = StringUtil.split(expected, \"\\n\");\n    UsefulTestCase.assertSameElements(actualNodesPresentation, expectedNodes);\n  }\n\n  @TestOnly\n  public static void waitForAlarm(final int delay) throws InterruptedException {\n    assert !ApplicationManager.getApplication().isWriteAccessAllowed(): \"It's a bad idea to wait for an alarm under the write action. Somebody creates an alarm which requires read action and you are deadlocked.\";\n    assert ApplicationManager.getApplication().isDispatchThread();\n\n    final AtomicBoolean invoked = new AtomicBoolean();\n    final Alarm alarm = new Alarm(Alarm.ThreadToUse.SWING_THREAD);\n    alarm.addRequest(new Runnable() {\n      @Override\n      public void run() {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            alarm.addRequest(new Runnable() {\n              @Override\n              public void run() {\n                invoked.set(true);\n              }\n            }, delay);\n          }\n        });\n      }\n    }, delay);\n\n    UIUtil.dispatchAllInvocationEvents();\n\n    boolean sleptAlready = false;\n    while (!invoked.get()) {\n      UIUtil.dispatchAllInvocationEvents();\n      //noinspection BusyWait\n      Thread.sleep(sleptAlready ? 10 : delay);\n      sleptAlready = true;\n    }\n    UIUtil.dispatchAllInvocationEvents();\n  }\n\n  @TestOnly\n  public static void dispatchAllInvocationEventsInIdeEventQueue() throws InterruptedException {\n    assert SwingUtilities.isEventDispatchThread() : Thread.currentThread();\n    final EventQueue eventQueue = Toolkit.getDefaultToolkit().getSystemEventQueue();\n    while (true) {\n      AWTEvent event = eventQueue.peekEvent();\n      if (event == null) break;\n        AWTEvent event1 = eventQueue.getNextEvent();\n        if (event1 instanceof InvocationEvent) {\n          IdeEventQueue.getInstance().dispatchEvent(event1);\n        }\n    }\n  }\n\n  private static Date raidDate(Bombed bombed) {\n    final Calendar instance = Calendar.getInstance();\n    instance.set(Calendar.YEAR, bombed.year());\n    instance.set(Calendar.MONTH, bombed.month());\n    instance.set(Calendar.DAY_OF_MONTH, bombed.day());\n    instance.set(Calendar.HOUR_OF_DAY, bombed.time());\n    instance.set(Calendar.MINUTE, 0);\n\n    return instance.getTime();\n  }\n\n  public static boolean bombExplodes(Bombed bombedAnnotation) {\n    Date now = new Date();\n    return now.after(raidDate(bombedAnnotation));\n  }\n\n  public static StringBuilder print(AbstractTreeStructure structure,\n                                    Object node,\n                                    int currentLevel,\n                                    @Nullable Comparator comparator,\n                                    int maxRowCount,\n                                    char paddingChar,\n                                    @Nullable Queryable.PrintInfo printInfo) {\n    StringBuilder buffer = new StringBuilder();\n    doPrint(buffer, currentLevel, node, structure, comparator, maxRowCount, 0, paddingChar, printInfo);\n    return buffer;\n  }\n\n  private static int doPrint(StringBuilder buffer,\n                             int currentLevel,\n                             Object node,\n                             AbstractTreeStructure structure,\n                             @Nullable Comparator comparator,\n                             int maxRowCount,\n                             int currentLine,\n                             char paddingChar,\n                             @Nullable Queryable.PrintInfo printInfo) {\n    if (currentLine >= maxRowCount && maxRowCount != -1) return currentLine;\n\n    StringUtil.repeatSymbol(buffer, paddingChar, currentLevel);\n    buffer.append(toString(node, printInfo)).append(\"\\n\");\n    currentLine++;\n    Object[] children = structure.getChildElements(node);\n\n    if (comparator != null) {\n      ArrayList<?> list = new ArrayList<Object>(Arrays.asList(children));\n      @SuppressWarnings({\"UnnecessaryLocalVariable\", \"unchecked\"}) Comparator<Object> c = comparator;\n      Collections.sort(list, c);\n      children = ArrayUtil.toObjectArray(list);\n    }\n    for (Object child : children) {\n      currentLine = doPrint(buffer, currentLevel + 1, child, structure, comparator, maxRowCount, currentLine, paddingChar, printInfo);\n    }\n\n    return currentLine;\n  }\n\n  public static String print(Object[] objects) {\n    return print(Arrays.asList(objects));\n  }\n\n  public static String print(Collection c) {\n    StringBuilder result = new StringBuilder();\n    for (Iterator iterator = c.iterator(); iterator.hasNext();) {\n      Object each = iterator.next();\n      result.append(toString(each, null));\n      if (iterator.hasNext()) {\n        result.append(\"\\n\");\n      }\n    }\n\n    return result.toString();\n  }\n\n  public static String print(ListModel model) {\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < model.getSize(); i++) {\n      result.append(toString(model.getElementAt(i), null));\n      result.append(\"\\n\");\n    }\n    return result.toString();\n  }\n\n  public static String print(JTree tree) {\n    return print(tree, false);\n  }\n\n  public static void assertTreeStructureEquals(final AbstractTreeStructure treeStructure, final String expected) {\n    assertEquals(expected, print(treeStructure, treeStructure.getRootElement(), 0, null, -1, ' ', null).toString());\n  }\n\n  public static void invokeNamedAction(final String actionId) {\n    final AnAction action = ActionManager.getInstance().getAction(actionId);\n    assertNotNull(action);\n    final Presentation presentation = new Presentation();\n    @SuppressWarnings(\"deprecation\") final DataContext context = DataManager.getInstance().getDataContext();\n    final AnActionEvent event = new AnActionEvent(null, context, \"\", presentation, ActionManager.getInstance(), 0);\n    action.update(event);\n    Assert.assertTrue(presentation.isEnabled());\n    action.actionPerformed(event);\n  }\n\n  public static void assertTiming(final String message, final long expectedMs, final long actual) {\n    if (COVERAGE_ENABLED_BUILD) return;\n\n    final long expectedOnMyMachine = Math.max(1, expectedMs * Timings.MACHINE_TIMING / Timings.ETALON_TIMING);\n\n    // Allow 10% more in case of test machine is busy.\n    String logMessage = message;\n    if (actual > expectedOnMyMachine) {\n      int percentage = (int)(100.0 * (actual - expectedOnMyMachine) / expectedOnMyMachine);\n      logMessage += \". Operation took \" + percentage + \"% longer than expected\";\n    }\n    logMessage += \". Expected on my machine: \" + expectedOnMyMachine + \".\" +\n                  \" Actual: \" + actual + \".\" +\n                  \" Expected on Standard machine: \" + expectedMs + \";\" +\n                  \" Actual on Standard: \" + actual * Timings.ETALON_TIMING / Timings.MACHINE_TIMING + \";\" +\n                  \" Timings: CPU=\" + Timings.CPU_TIMING +\n                  \", I/O=\" + Timings.IO_TIMING + \".\" +\n                  \" (\" + (int)(Timings.MACHINE_TIMING*1.0/Timings.ETALON_TIMING*100) + \"% of the Standard)\" +\n                  \".\";\n    final double acceptableChangeFactor = 1.1;\n    if (actual < expectedOnMyMachine) {\n      System.out.println(logMessage);\n      TeamCityLogger.info(logMessage);\n    }\n    else if (actual < expectedOnMyMachine * acceptableChangeFactor) {\n      TeamCityLogger.warning(logMessage, null);\n    }\n    else {\n      // throw AssertionFailedError to try one more time\n      throw new AssertionFailedError(logMessage);\n    }\n  }\n\n  /**\n   * example usage: startPerformanceTest(\"calculating pi\",100, testRunnable).cpuBound().assertTiming();\n   */\n  public static TestInfo startPerformanceTest(@NonNls @NotNull String message, int expectedMs, @NotNull ThrowableRunnable test) {\n    return new TestInfo(test, expectedMs,message);\n  }\n\n  // calculates average of the median values in the selected part of the array. E.g. for part=3 returns average in the middle third.\n  public static long averageAmongMedians(@NotNull long[] time, int part) {\n    assert part >= 1;\n    int n = time.length;\n    Arrays.sort(time);\n    long total = 0;\n    for (int i= n /2- n / part /2; i< n /2+ n / part /2; i++) {\n      total += time[i];\n    }\n    int middlePartLength = n / part;\n    return middlePartLength == 0 ? 0 : total / middlePartLength;\n  }\n\n  public static boolean canRunTest(@NotNull Class testCaseClass) {\n    if (!SKIP_SLOW && !SKIP_HEADLESS) {\n      return true;\n    }\n\n    for (Class<?> clazz = testCaseClass; clazz != null; clazz = clazz.getSuperclass()) {\n      if (SKIP_HEADLESS && clazz.getAnnotation(SkipInHeadlessEnvironment.class) != null) {\n        System.out.println(\"Class '\" + testCaseClass.getName() + \"' is skipped because it requires working UI environment\");\n        return false;\n      }\n      if (SKIP_SLOW && clazz.getAnnotation(SkipSlowTestLocally.class) != null) {\n        System.out.println(\"Class '\" + testCaseClass.getName() + \"' is skipped because it is dog slow\");\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  public static void assertPathsEqual(@Nullable String expected, @Nullable String actual) {\n    if (expected != null) expected = FileUtil.toSystemIndependentName(expected);\n    if (actual != null) actual = FileUtil.toSystemIndependentName(actual);\n    assertEquals(expected, actual);\n  }\n\n  @NotNull\n  public static String getRtJarPath() {\n    String home = System.getProperty(\"java.home\");\n    return SystemInfo.isAppleJvm ? FileUtil.toCanonicalPath(home + \"/../Classes/classes.jar\") : home + \"/lib/rt.jar\";\n  }\n\n  public static void saveProject(Project project) {\n    ApplicationEx application = ApplicationManagerEx.getApplicationEx();\n    boolean oldValue = application.isDoNotSave();\n    try {\n      application.doNotSave(false);\n      project.save();\n    }\n    finally {\n      application.doNotSave(oldValue);\n    }\n  }\n\n  public static class TestInfo {\n    private final ThrowableRunnable test; // runnable to measure\n    private final int expectedMs;           // millis the test is expected to run\n    private ThrowableRunnable setup;      // to run before each test\n    private boolean usesAllCPUCores;      // true if the test runs faster on multi-core\n    private int attempts = 4;             // number of retries if performance failed\n    private final String message;         // to print on fail\n    private boolean adjustForIO = true;   // true if test uses IO, timings need to be re-calibrated according to this agent disk performance\n    private boolean adjustForCPU = true;  // true if test uses CPU, timings need to be re-calibrated according to this agent CPU speed\n\n    private TestInfo(@NotNull ThrowableRunnable test, int expectedMs, String message) {\n      this.test = test;\n      this.expectedMs = expectedMs;\n      assert expectedMs > 0 : \"Expected must be > 0. Was: \"+ expectedMs;\n      this.message = message;\n    }\n\n    public TestInfo setup(@NotNull ThrowableRunnable setup) { assert this.setup==null; this.setup = setup; return this; }\n    public TestInfo usesAllCPUCores() { assert adjustForCPU : \"This test configured to be io-bound, it cannot use all cores\"; usesAllCPUCores = true; return this; }\n    public TestInfo cpuBound() { adjustForIO = false; adjustForCPU = true; return this; }\n    public TestInfo ioBound() { adjustForIO = true; adjustForCPU = false; return this; }\n    public TestInfo attempts(int attempts) { this.attempts = attempts; return this; }\n\n    public void assertTiming() {\n      assert expectedMs != 0 : \"Must call .expect() before run test\";\n      if (COVERAGE_ENABLED_BUILD) return;\n      Timings.getStatistics(); // warm-up, measure\n\n      while (true) {\n        attempts--;\n        long start;\n        try {\n          if (setup != null) setup.run();\n          start = System.currentTimeMillis();\n          test.run();\n        }\n        catch (Throwable throwable) {\n          throw new RuntimeException(throwable);\n        }\n        long finish = System.currentTimeMillis();\n        long duration = finish - start;\n\n        int expectedOnMyMachine = expectedMs;\n        if (adjustForCPU) {\n          expectedOnMyMachine = adjust(expectedOnMyMachine, Timings.CPU_TIMING, Timings.ETALON_CPU_TIMING);\n\n          expectedOnMyMachine = usesAllCPUCores ? expectedOnMyMachine * 8 / JobSchedulerImpl.CORES_COUNT : expectedOnMyMachine;\n        }\n        if (adjustForIO) {\n          expectedOnMyMachine = adjust(expectedOnMyMachine, Timings.IO_TIMING, Timings.ETALON_IO_TIMING);\n        }\n\n        // Allow 10% more in case of test machine is busy.\n        String logMessage = message;\n        if (duration > expectedOnMyMachine) {\n          int percentage = (int)(100.0 * (duration - expectedOnMyMachine) / expectedOnMyMachine);\n          logMessage += \": \" + percentage + \"% longer\";\n        }\n        logMessage +=\n          \". Expected: \" + formatTime(expectedOnMyMachine) + \". Actual: \" + formatTime(duration) + \".\" + Timings.getStatistics();\n        final double acceptableChangeFactor = 1.1;\n        if (duration < expectedOnMyMachine) {\n          int percentage = (int)(100.0 * (expectedOnMyMachine - duration) / expectedOnMyMachine);\n          logMessage = percentage + \"% faster. \" + logMessage;\n\n          TeamCityLogger.info(logMessage);\n          System.out.println(\"SUCCESS: \" + logMessage);\n        }\n        else if (duration < expectedOnMyMachine * acceptableChangeFactor) {\n          TeamCityLogger.warning(logMessage, null);\n          System.out.println(\"WARNING: \" + logMessage);\n        }\n        else {\n          // try one more time\n          if (attempts == 0) {\n            //try {\n            //  Object result = Class.forName(\"com.intellij.util.ProfilingUtil\").getMethod(\"captureCPUSnapshot\").invoke(null);\n            //  System.err.println(\"CPU snapshot captured in '\"+result+\"'\");\n            //}\n            //catch (Exception e) {\n            //}\n\n            throw new AssertionFailedError(logMessage);\n          }\n          System.gc();\n          System.gc();\n          System.gc();\n          String s = \"Another epic fail (remaining attempts: \" + attempts + \"): \" + logMessage;\n          TeamCityLogger.warning(s, null);\n          System.err.println(s);\n          //if (attempts == 1) {\n          //  try {\n          //    Class.forName(\"com.intellij.util.ProfilingUtil\").getMethod(\"startCPUProfiling\").invoke(null);\n          //  }\n          //  catch (Exception e) {\n          //  }\n          //}\n          continue;\n        }\n        break;\n      }\n    }\n\n    private static String formatTime(long millis) {\n      String hint = \"\";\n      DecimalFormat format = new DecimalFormat(\"#.0\", DecimalFormatSymbols.getInstance(Locale.US));\n      if (millis >= 60 * 1000) hint = format.format(millis / 60 / 1000.f) + \"m\";\n      if (millis >= 1000) hint += (hint.isEmpty() ? \"\" : \" \") + format.format(millis / 1000.f) + \"s\";\n      String result = millis + \"ms\";\n      if (!hint.isEmpty()) {\n        result = result + \" (\" + hint + \")\";\n      }\n      return result;\n    }\n\n    private static int adjust(int expectedOnMyMachine, long thisTiming, long ethanolTiming) {\n      // most of our algorithms are quadratic. sad but true.\n      double speed = 1.0 * thisTiming / ethanolTiming;\n      double delta = speed < 1\n                 ? 0.9 + Math.pow(speed - 0.7, 2)\n                 : 0.45 + Math.pow(speed - 0.25, 2);\n      expectedOnMyMachine *= delta;\n      return expectedOnMyMachine;\n    }\n  }\n\n\n  public static void assertTiming(String message, long expected, @NotNull Runnable actionToMeasure) {\n    assertTiming(message, expected, 4, actionToMeasure);\n  }\n\n  public static long measure(@NotNull Runnable actionToMeasure) {\n    long start = System.currentTimeMillis();\n    actionToMeasure.run();\n    long finish = System.currentTimeMillis();\n    return finish - start;\n  }\n\n  public static void assertTiming(String message, long expected, int attempts, @NotNull Runnable actionToMeasure) {\n    while (true) {\n      attempts--;\n      long duration = measure(actionToMeasure);\n      try {\n        assertTiming(message, expected, duration);\n        break;\n      }\n      catch (AssertionFailedError e) {\n        if (attempts == 0) throw e;\n        System.gc();\n        System.gc();\n        System.gc();\n        String s = \"Another epic fail (remaining attempts: \" + attempts + \"): \" + e.getMessage();\n        TeamCityLogger.warning(s, null);\n        System.err.println(s);\n      }\n    }\n  }\n\n  private static HashMap<String, VirtualFile> buildNameToFileMap(VirtualFile[] files, @Nullable VirtualFileFilter filter) {\n    HashMap<String, VirtualFile> map = new HashMap<String, VirtualFile>();\n    for (VirtualFile file : files) {\n      if (filter != null && !filter.accept(file)) continue;\n      map.put(file.getName(), file);\n    }\n    return map;\n  }\n\n  public static void assertDirectoriesEqual(VirtualFile dirAfter, VirtualFile dirBefore) throws IOException {\n    assertDirectoriesEqual(dirAfter, dirBefore, null);\n  }\n\n  @SuppressWarnings(\"UnsafeVfsRecursion\")\n  public static void assertDirectoriesEqual(VirtualFile dirAfter, VirtualFile dirBefore, @Nullable VirtualFileFilter fileFilter) throws IOException {\n    FileDocumentManager.getInstance().saveAllDocuments();\n\n    VirtualFile[] childrenAfter = dirAfter.getChildren();\n\n    if (dirAfter.isInLocalFileSystem() && dirAfter.getFileSystem() != TempFileSystem.getInstance()) {\n      File[] ioAfter = new File(dirAfter.getPath()).listFiles();\n      shallowCompare(childrenAfter, ioAfter);\n    }\n\n    VirtualFile[] childrenBefore = dirBefore.getChildren();\n    if (dirBefore.isInLocalFileSystem() && dirBefore.getFileSystem() != TempFileSystem.getInstance()) {\n      File[] ioBefore = new File(dirBefore.getPath()).listFiles();\n      shallowCompare(childrenBefore, ioBefore);\n    }\n\n    HashMap<String, VirtualFile> mapAfter = buildNameToFileMap(childrenAfter, fileFilter);\n    HashMap<String, VirtualFile> mapBefore = buildNameToFileMap(childrenBefore, fileFilter);\n\n    Set<String> keySetAfter = mapAfter.keySet();\n    Set<String> keySetBefore = mapBefore.keySet();\n    assertEquals(dirAfter.getPath(), keySetAfter, keySetBefore);\n\n    for (String name : keySetAfter) {\n      VirtualFile fileAfter = mapAfter.get(name);\n      VirtualFile fileBefore = mapBefore.get(name);\n      if (fileAfter.isDirectory()) {\n        assertDirectoriesEqual(fileAfter, fileBefore, fileFilter);\n      }\n      else {\n        assertFilesEqual(fileAfter, fileBefore);\n      }\n    }\n  }\n\n  private static void shallowCompare(VirtualFile[] vfs, @Nullable File[] io) {\n    List<String> vfsPaths = new ArrayList<String>();\n    for (VirtualFile file : vfs) {\n      vfsPaths.add(file.getPath());\n    }\n\n    List<String> ioPaths = new ArrayList<String>();\n    if (io != null) {\n      for (File file : io) {\n        ioPaths.add(file.getPath().replace(File.separatorChar, '/'));\n      }\n    }\n\n    assertEquals(sortAndJoin(vfsPaths), sortAndJoin(ioPaths));\n  }\n\n  private static String sortAndJoin(List<String> strings) {\n    Collections.sort(strings);\n    StringBuilder buf = new StringBuilder();\n    for (String string : strings) {\n      buf.append(string);\n      buf.append('\\n');\n    }\n    return buf.toString();\n  }\n\n  public static void assertFilesEqual(VirtualFile fileAfter, VirtualFile fileBefore) throws IOException {\n    try {\n      assertJarFilesEqual(VfsUtilCore.virtualToIoFile(fileAfter), VfsUtilCore.virtualToIoFile(fileBefore));\n    }\n    catch (IOException e) {\n      FileDocumentManager manager = FileDocumentManager.getInstance();\n\n      Document docBefore = manager.getDocument(fileBefore);\n      boolean canLoadBeforeText = !fileBefore.getFileType().isBinary() || fileBefore.getFileType() == FileTypes.UNKNOWN;\n      String textB = docBefore != null\n                     ? docBefore.getText()\n                     : !canLoadBeforeText\n                       ? null\n                       : LoadTextUtil.getTextByBinaryPresentation(fileBefore.contentsToByteArray(false), fileBefore).toString();\n\n      Document docAfter = manager.getDocument(fileAfter);\n      boolean canLoadAfterText = !fileBefore.getFileType().isBinary() || fileBefore.getFileType() == FileTypes.UNKNOWN;\n      String textA = docAfter != null\n                     ? docAfter.getText()\n                     : !canLoadAfterText\n                       ? null\n                       : LoadTextUtil.getTextByBinaryPresentation(fileAfter.contentsToByteArray(false), fileAfter).toString();\n\n      if (textA != null && textB != null) {\n        assertEquals(fileAfter.getPath(), textA, textB);\n      }\n      else {\n        Assert.assertArrayEquals(fileAfter.getPath(), fileAfter.contentsToByteArray(), fileBefore.contentsToByteArray());\n      }\n    }\n  }\n\n  public static void assertJarFilesEqual(File file1, File file2) throws IOException {\n    final File tempDirectory1;\n    final File tempDirectory2;\n\n    final JarFile jarFile1 = new JarFile(file1);\n    try {\n      final JarFile jarFile2 = new JarFile(file2);\n      try {\n        tempDirectory1 = PlatformTestCase.createTempDir(\"tmp1\");\n        tempDirectory2 = PlatformTestCase.createTempDir(\"tmp2\");\n        ZipUtil.extract(jarFile1, tempDirectory1, null);\n        ZipUtil.extract(jarFile2, tempDirectory2, null);\n      }\n      finally {\n        jarFile2.close();\n      }\n    }\n    finally {\n      jarFile1.close();\n    }\n\n    final VirtualFile dirAfter = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(tempDirectory1);\n    assertNotNull(tempDirectory1.toString(), dirAfter);\n    final VirtualFile dirBefore = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(tempDirectory2);\n    assertNotNull(tempDirectory2.toString(), dirBefore);\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        dirAfter.refresh(false, true);\n        dirBefore.refresh(false, true);\n      }\n    });\n    assertDirectoriesEqual(dirAfter, dirBefore);\n  }\n\n  public static void assertElementsEqual(final Element expected, final Element actual) throws IOException {\n    if (!JDOMUtil.areElementsEqual(expected, actual)) {\n      assertEquals(printElement(expected), printElement(actual));\n    }\n  }\n\n  public static void assertElementEquals(final String expected, final Element actual) {\n    try {\n      assertElementsEqual(JDOMUtil.loadDocument(expected).getRootElement(), actual);\n    }\n    catch (IOException e) {\n      throw new AssertionError(e);\n    }\n    catch (JDOMException e) {\n      throw new AssertionError(e);\n    }\n  }\n\n  public static String printElement(final Element element) throws IOException {\n    final StringWriter writer = new StringWriter();\n    JDOMUtil.writeElement(element, writer, \"\\n\");\n    return writer.getBuffer().toString();\n  }\n\n  public static String getCommunityPath() {\n    final String homePath = PathManager.getHomePath();\n    if (new File(homePath, \"community/.idea\").isDirectory()) {\n      return homePath + File.separatorChar + \"community\";\n    }\n    return homePath;\n  }\n\n  public static String getPlatformTestDataPath() {\n    return getCommunityPath().replace(File.separatorChar, '/') + \"/platform/platform-tests/testData/\";\n  }\n\n\n  public static Comparator<AbstractTreeNode> createComparator(final Queryable.PrintInfo printInfo) {\n    return new Comparator<AbstractTreeNode>() {\n      @Override\n      public int compare(final AbstractTreeNode o1, final AbstractTreeNode o2) {\n        String displayText1 = o1.toTestString(printInfo);\n        String displayText2 = o2.toTestString(printInfo);\n        return Comparing.compare(displayText1, displayText2);\n      }\n    };\n  }\n\n  @NotNull\n  public static <T> T notNull(@Nullable T t) {\n    assertNotNull(t);\n    return t;\n  }\n\n  @NotNull\n  public static String loadFileText(@NotNull String fileName) throws IOException {\n    return StringUtil.convertLineSeparators(FileUtil.loadFile(new File(fileName)));\n  }\n\n  public static void tryGcSoftlyReachableObjects() {\n    GCUtil.tryGcSoftlyReachableObjects();\n  }\n\n  public static void withEncoding(@NotNull String encoding, @NotNull final Runnable r) {\n    withEncoding(encoding, new ThrowableRunnable() {\n      @Override\n      public void run() throws Throwable {\n        r.run();\n      }\n    });\n  }\n\n  public static void withEncoding(@NotNull String encoding, @NotNull ThrowableRunnable r) {\n    Charset oldCharset = Charset.defaultCharset();\n    try {\n      try {\n        patchSystemFileEncoding(encoding);\n        r.run();\n      }\n      finally {\n        patchSystemFileEncoding(oldCharset.name());\n      }\n    }\n    catch (Throwable t) {\n      throw new RuntimeException(t);\n    }\n  }\n\n  private static void patchSystemFileEncoding(String encoding) {\n    ReflectionUtil.resetField(Charset.class, Charset.class, \"defaultCharset\");\n    System.setProperty(\"file.encoding\", encoding);\n  }\n\n  public static void withStdErrSuppressed(@NotNull Runnable r) {\n    PrintStream std = System.err;\n    System.setErr(new PrintStream(NULL));\n    try {\n      r.run();\n    }\n    finally {\n      System.setErr(std);\n    }\n  }\n\n  @SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n  private static final OutputStream NULL = new OutputStream() {\n    @Override\n    public void write(int b) throws IOException { }\n  };\n}\n",
    "ID_2": "public class LogRotationControl\n{\n    private final TransactionIdStore transactionIdStore;\n    private final IndexingService indexingService;\n    private final LabelScanStore labelScanStore;\n    private final Iterable<IndexImplementation> indexProviders;\n\n    public LogRotationControl( TransactionIdStore transactionIdStore, IndexingService indexingService,\n            LabelScanStore labelScanStore,\n            Iterable<IndexImplementation> indexProviders )\n    {\n        this.transactionIdStore = transactionIdStore;\n        this.indexingService = indexingService;\n        this.labelScanStore = labelScanStore;\n        this.indexProviders = indexProviders;\n    }\n\n    public void awaitAllTransactionsClosed()\n    {\n        while ( !transactionIdStore.closedTransactionIdIsOnParWithOpenedTransactionId() )\n        {\n            LockSupport.parkNanos( 1_000_000 ); // 1 ms\n        }\n    }\n\n    public void forceEverything()\n    {\n        indexingService.flushAll();\n        labelScanStore.force();\n        for ( IndexImplementation index : indexProviders )\n        {\n            index.force();\n        }\n        transactionIdStore.flush();\n    }\n}",
    "ID_3": "public class RunContentManagerImpl implements RunContentManager, Disposable {\n  public static final Key<Boolean> ALWAYS_USE_DEFAULT_STOPPING_BEHAVIOUR_KEY = Key.create(\"ALWAYS_USE_DEFAULT_STOPPING_BEHAVIOUR_KEY\");\n  private static final Logger LOG = Logger.getInstance(RunContentManagerImpl.class);\n  private static final Key<RunContentDescriptor> DESCRIPTOR_KEY = Key.create(\"Descriptor\");\n\n  private final Project myProject;\n  private final Map<String, ContentManager> myToolwindowIdToContentManagerMap = new THashMap<String, ContentManager>();\n  private final Map<String, Icon> myToolwindowIdToBaseIconMap = new THashMap<String, Icon>();\n  private final LinkedList<String> myToolwindowIdZBuffer = new LinkedList<String>();\n\n  public RunContentManagerImpl(@NotNull Project project, @NotNull DockManager dockManager) {\n    myProject = project;\n    DockableGridContainerFactory containerFactory = new DockableGridContainerFactory();\n    dockManager.register(DockableGridContainerFactory.TYPE, containerFactory);\n    Disposer.register(myProject, containerFactory);\n\n    AppUIUtil.invokeOnEdt(new Runnable() {\n      @Override\n      public void run() {\n        init();\n      }\n    }, myProject.getDisposed());\n  }\n\n  // must be called on EDT\n  private void init() {\n    ToolWindowManagerEx toolWindowManager = ToolWindowManagerEx.getInstanceEx(myProject);\n    if (toolWindowManager == null) {\n      return;\n    }\n\n    for (Executor executor : ExecutorRegistry.getInstance().getRegisteredExecutors()) {\n      registerToolwindow(executor, toolWindowManager);\n    }\n\n    toolWindowManager.addToolWindowManagerListener(new ToolWindowManagerAdapter() {\n      @Override\n      public void stateChanged() {\n        if (myProject.isDisposed()) {\n          return;\n        }\n\n        ToolWindowManager toolWindowManager = ToolWindowManager.getInstance(myProject);\n        Set<String> currentWindows = new THashSet<String>();\n        ContainerUtil.addAll(currentWindows, toolWindowManager.getToolWindowIds());\n        myToolwindowIdZBuffer.retainAll(currentWindows);\n\n        final String activeToolWindowId = toolWindowManager.getActiveToolWindowId();\n        if (activeToolWindowId != null) {\n          if (myToolwindowIdZBuffer.remove(activeToolWindowId)) {\n            myToolwindowIdZBuffer.addFirst(activeToolWindowId);\n          }\n        }\n      }\n    });\n  }\n\n  @Override\n  public void dispose() {\n  }\n\n  private void registerToolwindow(@NotNull final Executor executor, @NotNull ToolWindowManagerEx toolWindowManager) {\n    final String toolWindowId = executor.getToolWindowId();\n    if (toolWindowManager.getToolWindow(toolWindowId) != null) {\n      return;\n    }\n\n    final ToolWindow toolWindow = toolWindowManager.registerToolWindow(toolWindowId, true, ToolWindowAnchor.BOTTOM, this, true);\n    final ContentManager contentManager = toolWindow.getContentManager();\n    contentManager.addDataProvider(new DataProvider() {\n      private int myInsideGetData = 0;\n\n      @Override\n      public Object getData(String dataId) {\n        myInsideGetData++;\n        try {\n          if (PlatformDataKeys.HELP_ID.is(dataId)) {\n            return executor.getHelpId();\n          }\n          else {\n            return myInsideGetData == 1 ? DataManager.getInstance().getDataContext(contentManager.getComponent()).getData(dataId) : null;\n          }\n        }\n        finally {\n          myInsideGetData--;\n        }\n      }\n    });\n\n    toolWindow.setIcon(executor.getToolWindowIcon());\n    myToolwindowIdToBaseIconMap.put(toolWindowId, executor.getToolWindowIcon());\n    new ContentManagerWatcher(toolWindow, contentManager);\n    contentManager.addContentManagerListener(new ContentManagerAdapter() {\n      @Override\n      public void selectionChanged(final ContentManagerEvent event) {\n        Content content = event.getContent();\n        getSyncPublisher().contentSelected(content == null ? null : getRunContentDescriptorByContent(content), executor);\n      }\n    });\n    myToolwindowIdToContentManagerMap.put(toolWindowId, contentManager);\n    Disposer.register(contentManager, new Disposable() {\n      @Override\n      public void dispose() {\n        myToolwindowIdToContentManagerMap.remove(toolWindowId).removeAllContents(true);\n        myToolwindowIdZBuffer.remove(toolWindowId);\n        myToolwindowIdToBaseIconMap.remove(toolWindowId);\n      }\n    });\n    myToolwindowIdZBuffer.addLast(toolWindowId);\n  }\n\n  private RunContentWithExecutorListener getSyncPublisher() {\n    return myProject.getMessageBus().syncPublisher(TOPIC);\n  }\n\n  @Override\n  public void toFrontRunContent(final Executor requestor, final ProcessHandler handler) {\n    final RunContentDescriptor descriptor = getDescriptorBy(handler, requestor);\n    if (descriptor == null) {\n      return;\n    }\n    toFrontRunContent(requestor, descriptor);\n  }\n\n  @Override\n  public void toFrontRunContent(final Executor requestor, final RunContentDescriptor descriptor) {\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        ContentManager contentManager = getContentManagerForRunner(requestor);\n        Content content = getRunContentByDescriptor(contentManager, descriptor);\n        if (content != null) {\n          contentManager.setSelectedContent(content);\n          ToolWindowManager.getInstance(myProject).getToolWindow(requestor.getToolWindowId()).show(null);\n        }\n      }\n    }, myProject.getDisposed());\n  }\n\n  @Override\n  public void hideRunContent(@NotNull final Executor executor, final RunContentDescriptor descriptor) {\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        ToolWindow toolWindow = ToolWindowManager.getInstance(myProject).getToolWindow(executor.getToolWindowId());\n        if (toolWindow != null) {\n          toolWindow.hide(null);\n        }\n      }\n    }, myProject.getDisposed());\n  }\n\n  @Override\n  @Nullable\n  public RunContentDescriptor getSelectedContent(final Executor executor) {\n    final Content selectedContent = getContentManagerForRunner(executor).getSelectedContent();\n    return selectedContent != null ? getRunContentDescriptorByContent(selectedContent) : null;\n  }\n\n  @Override\n  @Nullable\n  public RunContentDescriptor getSelectedContent() {\n    for (String activeWindow : myToolwindowIdZBuffer) {\n      final ContentManager contentManager = myToolwindowIdToContentManagerMap.get(activeWindow);\n      if (contentManager == null) {\n        continue;\n      }\n\n      final Content selectedContent = contentManager.getSelectedContent();\n      if (selectedContent == null) {\n        if (contentManager.getContentCount() == 0) {\n          // continue to the next window if the content manager is empty\n          continue;\n        }\n        else {\n          // stop iteration over windows because there is some content in the window and the window is the last used one\n          break;\n        }\n      }\n      // here we have selected content\n      return getRunContentDescriptorByContent(selectedContent);\n    }\n\n    return null;\n  }\n\n  @Override\n  public boolean removeRunContent(@NotNull final Executor executor, final RunContentDescriptor descriptor) {\n    final ContentManager contentManager = getContentManagerForRunner(executor);\n    final Content content = getRunContentByDescriptor(contentManager, descriptor);\n    return content != null && contentManager.removeContent(content, true);\n  }\n\n  @Override\n  public void showRunContent(@NotNull Executor executor, @NotNull RunContentDescriptor descriptor) {\n    showRunContent(executor, descriptor, descriptor.getExecutionId());\n  }\n\n  public void showRunContent(@NotNull final Executor executor, @NotNull final RunContentDescriptor descriptor, final long executionId) {\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      return;\n    }\n\n    final ContentManager contentManager = getContentManagerForRunner(executor);\n    RunContentDescriptor oldDescriptor = chooseReuseContentForDescriptor(contentManager, descriptor, executionId, descriptor.getDisplayName());\n    final Content content;\n    if (oldDescriptor == null) {\n      content = createNewContent(contentManager, descriptor, executor);\n      Icon icon = descriptor.getIcon();\n      content.setIcon(icon == null ? executor.getToolWindowIcon() : icon);\n    }\n    else {\n      content = oldDescriptor.getAttachedContent();\n      LOG.assertTrue(content != null);\n      getSyncPublisher().contentRemoved(oldDescriptor, executor);\n      Disposer.dispose(oldDescriptor); // is of the same category, can be reused\n    }\n\n    content.setExecutionId(executionId);\n    content.setComponent(descriptor.getComponent());\n    content.setPreferredFocusedComponent(descriptor.getPreferredFocusComputable());\n    content.putUserData(DESCRIPTOR_KEY, descriptor);\n    final ToolWindow toolWindow = ToolWindowManager.getInstance(myProject).getToolWindow(executor.getToolWindowId());\n    final ProcessHandler processHandler = descriptor.getProcessHandler();\n    if (processHandler != null) {\n      final ProcessAdapter processAdapter = new ProcessAdapter() {\n        @Override\n        public void startNotified(final ProcessEvent event) {\n          UIUtil.invokeLaterIfNeeded(new Runnable() {\n            @Override\n            public void run() {\n              toolWindow.setIcon(getLiveIndicator(myToolwindowIdToBaseIconMap.get(executor.getToolWindowId())));\n            }\n          });\n        }\n\n        @Override\n        public void processTerminated(final ProcessEvent event) {\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              boolean alive = false;\n              String toolWindowId = executor.getToolWindowId();\n              ContentManager manager = myToolwindowIdToContentManagerMap.get(toolWindowId);\n              if (manager == null) return;\n              for (Content content : manager.getContents()) {\n                RunContentDescriptor descriptor = getRunContentDescriptorByContent(content);\n                if (descriptor != null) {\n                  ProcessHandler handler = descriptor.getProcessHandler();\n                  if (handler != null && !handler.isProcessTerminated()) {\n                    alive = true;\n                    break;\n                  }\n                }\n              }\n              Icon base = myToolwindowIdToBaseIconMap.get(toolWindowId);\n              toolWindow.setIcon(alive ? getLiveIndicator(base) : base);\n\n              Icon icon = descriptor.getIcon();\n              content.setIcon(icon == null ? executor.getDisabledIcon() : IconLoader.getTransparentIcon(icon));\n            }\n          });\n        }\n      };\n      processHandler.addProcessListener(processAdapter);\n      final Disposable disposer = content.getDisposer();\n      if (disposer != null) {\n        Disposer.register(disposer, new Disposable() {\n          @Override\n          public void dispose() {\n            processHandler.removeProcessListener(processAdapter);\n          }\n        });\n      }\n    }\n    content.setDisplayName(descriptor.getDisplayName());\n    descriptor.setAttachedContent(content);\n    content.getManager().setSelectedContent(content);\n\n    if (!descriptor.isActivateToolWindowWhenAdded()) {\n      return;\n    }\n\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        ToolWindow window = ToolWindowManager.getInstance(myProject).getToolWindow(executor.getToolWindowId());\n        // let's activate tool window, but don't move focus\n        //\n        // window.show() isn't valid here, because it will not\n        // mark the window as \"last activated\" windows and thus\n        // some action like navigation up/down in stacktrace wont\n        // work correctly\n        descriptor.getPreferredFocusComputable();\n        window.activate(descriptor.getActivationCallback(), descriptor.isAutoFocusContent(), descriptor.isAutoFocusContent());\n      }\n    }, myProject.getDisposed());\n  }\n\n  private final static int INDICATOR_SIZE = 4;\n  private static Icon getLiveIndicator(final Icon base) {\n    return new LayeredIcon(base, new Icon() {\n      @Override\n      public void paintIcon(Component c, Graphics g, int x, int y) {\n        Graphics2D g2d = (Graphics2D)g.create();\n        try {\n          GraphicsUtil.setupAAPainting(g2d);\n          g2d.setColor(Color.GREEN);\n          Ellipse2D.Double shape =\n            new Ellipse2D.Double(x + getIconWidth() - INDICATOR_SIZE, y + getIconHeight() - INDICATOR_SIZE, INDICATOR_SIZE, INDICATOR_SIZE);\n          g2d.fill(shape);\n          g2d.setColor(ColorUtil.withAlpha(Color.BLACK, .40));\n          g2d.draw(shape);\n        }\n        finally {\n          g2d.dispose();\n        }\n      }\n\n      @Override\n      public int getIconWidth() {\n        return base != null ? base.getIconWidth() : 13;\n      }\n\n      @Override\n      public int getIconHeight() {\n        return base != null ? base.getIconHeight() : 13;\n      }\n    });\n  }\n\n  @Nullable\n  @Override\n  public RunContentDescriptor getReuseContent(@NotNull ExecutionEnvironment executionEnvironment) {\n    if (ApplicationManager.getApplication().isUnitTestMode()) return null;\n    RunContentDescriptor contentToReuse = executionEnvironment.getContentToReuse();\n    if (contentToReuse != null) {\n      return contentToReuse;\n    }\n\n    final ContentManager contentManager = getContentManagerForRunner(executionEnvironment.getExecutor());\n    return chooseReuseContentForDescriptor(contentManager, null, executionEnvironment.getExecutionId(),\n                                           executionEnvironment.toString());\n  }\n\n  @Override\n  public RunContentDescriptor findContentDescriptor(final Executor requestor, final ProcessHandler handler) {\n    return getDescriptorBy(handler, requestor);\n  }\n\n  @Override\n  public void showRunContent(@NotNull Executor info, @NotNull RunContentDescriptor descriptor, @Nullable RunContentDescriptor contentToReuse) {\n    copyContentAndBehavior(descriptor, contentToReuse);\n    showRunContent(info, descriptor, descriptor.getExecutionId());\n  }\n\n  public static void copyContentAndBehavior(@NotNull RunContentDescriptor descriptor, @Nullable RunContentDescriptor contentToReuse) {\n    if (contentToReuse != null) {\n      Content attachedContent = contentToReuse.getAttachedContent();\n      if (attachedContent != null && attachedContent.isValid()) {\n        descriptor.setAttachedContent(attachedContent);\n      }\n      if (contentToReuse.isReuseToolWindowActivation()) {\n        descriptor.setActivateToolWindowWhenAdded(contentToReuse.isActivateToolWindowWhenAdded());\n      }\n    }\n  }\n\n  @Nullable\n  private static RunContentDescriptor chooseReuseContentForDescriptor(@NotNull ContentManager contentManager,\n                                                                      @Nullable RunContentDescriptor descriptor,\n                                                                      long executionId,\n                                                                      @Nullable String preferredName) {\n    Content content = null;\n    if (descriptor != null) {\n      //Stage one: some specific descriptors (like AnalyzeStacktrace) cannot be reused at all\n      if (descriptor.isContentReuseProhibited()) {\n        return null;\n      }\n      //Stage two: try to get content from descriptor itself\n      final Content attachedContent = descriptor.getAttachedContent();\n\n      if (attachedContent != null\n          && attachedContent.isValid()\n          && contentManager.getIndexOfContent(attachedContent) != -1\n          && (Comparing.equal(descriptor.getDisplayName(), attachedContent.getDisplayName()) || !attachedContent.isPinned())) {\n        content = attachedContent;\n      }\n    }\n    //Stage three: choose the content with name we prefer\n    if (content == null) {\n      content = getContentFromManager(contentManager, preferredName, executionId);\n    }\n    if (content == null || !isTerminated(content) || (content.getExecutionId() == executionId && executionId != 0)) {\n      return null;\n    }\n    final RunContentDescriptor oldDescriptor = getRunContentDescriptorByContent(content);\n    if (oldDescriptor != null && !oldDescriptor.isContentReuseProhibited() ) {\n      //content.setExecutionId(executionId);\n      return oldDescriptor;\n    }\n\n    return null;\n  }\n\n  @Nullable\n  private static Content getContentFromManager(ContentManager contentManager, @Nullable String preferredName, long executionId) {\n    ArrayList<Content> contents = new ArrayList<Content>(Arrays.asList(contentManager.getContents()));\n    Content first = contentManager.getSelectedContent();\n    if (first != null && contents.remove(first)) {//selected content should be checked first\n      contents.add(0, first);\n    }\n    if (preferredName != null) {//try to match content with specified preferred name\n      for (Content c : contents) {\n        if (canReuseContent(c, executionId) && preferredName.equals(c.getDisplayName())) {\n          return c;\n        }\n      }\n    }\n    for (Content c : contents) {//return first \"good\" content\n      if (canReuseContent(c, executionId)) {\n        return c;\n      }\n    }\n    return null;\n  }\n\n  private static boolean canReuseContent(Content c, long executionId) {\n    return c != null && !c.isPinned() && isTerminated(c) && !(c.getExecutionId() == executionId && executionId != 0);\n  }\n\n  @NotNull\n  private ContentManager getContentManagerForRunner(final Executor executor) {\n    final ContentManager contentManager = myToolwindowIdToContentManagerMap.get(executor.getToolWindowId());\n    if (contentManager == null) {\n      LOG.error(\"Runner \" + executor.getId() + \" is not registered\");\n    }\n    //noinspection ConstantConditions\n    return contentManager;\n  }\n\n  private Content createNewContent(final ContentManager contentManager, final RunContentDescriptor descriptor, Executor executor) {\n    final String processDisplayName = descriptor.getDisplayName();\n    final Content content = ContentFactory.SERVICE.getInstance().createContent(descriptor.getComponent(), processDisplayName, true);\n    content.putUserData(DESCRIPTOR_KEY, descriptor);\n    content.putUserData(ToolWindow.SHOW_CONTENT_ICON, Boolean.TRUE);\n    contentManager.addContent(content);\n    new CloseListener(content, executor);\n    return content;\n  }\n\n  private static boolean isTerminated(@NotNull Content content) {\n    RunContentDescriptor descriptor = getRunContentDescriptorByContent(content);\n    ProcessHandler processHandler = descriptor == null ? null : descriptor.getProcessHandler();\n    return processHandler == null || processHandler.isProcessTerminated();\n  }\n\n  @Nullable\n  private static RunContentDescriptor getRunContentDescriptorByContent(@NotNull Content content) {\n    return content.getUserData(DESCRIPTOR_KEY);\n  }\n\n  @Override\n  @Nullable\n  public ToolWindow getToolWindowByDescriptor(@NotNull RunContentDescriptor descriptor) {\n    for (Map.Entry<String, ContentManager> entry : myToolwindowIdToContentManagerMap.entrySet()) {\n      if (getRunContentByDescriptor(entry.getValue(), descriptor) != null) {\n        return ToolWindowManager.getInstance(myProject).getToolWindow(entry.getKey());\n      }\n    }\n    return null;\n  }\n\n  @Nullable\n  private static Content getRunContentByDescriptor(@NotNull ContentManager contentManager, @NotNull RunContentDescriptor descriptor) {\n    for (Content content : contentManager.getContents()) {\n      if (descriptor.equals(content.getUserData(DESCRIPTOR_KEY))) {\n        return content;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  @NotNull\n  public List<RunContentDescriptor> getAllDescriptors() {\n    if (myToolwindowIdToContentManagerMap.isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    List<RunContentDescriptor> descriptors = new SmartList<RunContentDescriptor>();\n    for (String id : myToolwindowIdToContentManagerMap.keySet()) {\n      for (Content content : myToolwindowIdToContentManagerMap.get(id).getContents()) {\n        RunContentDescriptor descriptor = getRunContentDescriptorByContent(content);\n        if (descriptor != null) {\n          descriptors.add(descriptor);\n        }\n      }\n    }\n    return descriptors;\n  }\n\n  @Nullable\n  private RunContentDescriptor getDescriptorBy(ProcessHandler handler, Executor runnerInfo) {\n    for (Content content : getContentManagerForRunner(runnerInfo).getContents()) {\n      RunContentDescriptor runContentDescriptor = getRunContentDescriptorByContent(content);\n      assert runContentDescriptor != null;\n      if (runContentDescriptor.getProcessHandler() == handler) {\n        return runContentDescriptor;\n      }\n    }\n    return null;\n  }\n\n  private class CloseListener extends ContentManagerAdapter implements ProjectManagerListener {\n    private Content myContent;\n    private final Executor myExecutor;\n\n    private CloseListener(@NotNull final Content content, @NotNull Executor executor) {\n      myContent = content;\n      content.getManager().addContentManagerListener(this);\n      ProjectManager.getInstance().addProjectManagerListener(this);\n      myExecutor = executor;\n    }\n\n    @Override\n    public void contentRemoved(final ContentManagerEvent event) {\n      final Content content = event.getContent();\n      if (content == myContent) {\n        dispose();\n      }\n    }\n\n    private void dispose() {\n      if (myContent == null) return;\n\n      final Content content = myContent;\n      try {\n        RunContentDescriptor descriptor = getRunContentDescriptorByContent(content);\n        getSyncPublisher().contentRemoved(descriptor, myExecutor);\n        if (descriptor != null) {\n          Disposer.dispose(descriptor);\n        }\n      }\n      finally {\n        content.getManager().removeContentManagerListener(this);\n        ProjectManager.getInstance().removeProjectManagerListener(this);\n        content.release(); // don't invoke myContent.release() because myContent becomes null after destroyProcess()\n        myContent = null;\n      }\n    }\n\n    @Override\n    public void contentRemoveQuery(final ContentManagerEvent event) {\n      if (event.getContent() == myContent) {\n        final boolean canClose = closeQuery(false);\n        if (!canClose) {\n          event.consume();\n        }\n      }\n    }\n\n    @Override\n    public void projectOpened(final Project project) {\n    }\n\n    @Override\n    public void projectClosed(final Project project) {\n      if (myContent != null && project == myProject) {\n        myContent.getManager().removeContent(myContent, true);\n        dispose(); // Dispose content even if content manager refused to.\n      }\n    }\n\n    @Override\n    public boolean canCloseProject(final Project project) {\n      if (project != myProject) return true;\n\n      if (myContent == null) return true;\n\n      final boolean canClose = closeQuery(true);\n      if (canClose) {\n        myContent.getManager().removeContent(myContent, true);\n        myContent = null;\n      }\n      return canClose;\n    }\n\n    @Override\n    public void projectClosing(final Project project) {\n    }\n\n    private boolean closeQuery(boolean modal) {\n      final RunContentDescriptor descriptor = getRunContentDescriptorByContent(myContent);\n      if (descriptor == null) {\n        return true;\n      }\n\n      final ProcessHandler processHandler = descriptor.getProcessHandler();\n      if (processHandler == null || processHandler.isProcessTerminated() || processHandler.isProcessTerminating()) {\n        return true;\n      }\n      final boolean destroyProcess;\n      //noinspection deprecation\n      if (processHandler.isSilentlyDestroyOnClose() || Boolean.TRUE.equals(processHandler.getUserData(ProcessHandler.SILENTLY_DESTROY_ON_CLOSE))) {\n        destroyProcess = true;\n      }\n      else {\n        //todo[nik] this is a temporary solution for the following problem: some configurations should not allow user to choose between 'terminating' and 'detaching'\n        final boolean useDefault = Boolean.TRUE.equals(processHandler.getUserData(ALWAYS_USE_DEFAULT_STOPPING_BEHAVIOUR_KEY));\n        final TerminateRemoteProcessDialog.TerminateOption option = new TerminateRemoteProcessDialog.TerminateOption(processHandler.detachIsDefault(), useDefault);\n        final int rc = TerminateRemoteProcessDialog.show(myProject, descriptor.getDisplayName(), option);\n        if (rc != DialogWrapper.OK_EXIT_CODE) return false;\n        destroyProcess = !option.isToBeShown();\n      }\n      if (destroyProcess) {\n        processHandler.destroyProcess();\n      }\n      else {\n        processHandler.detachProcess();\n      }\n      waitForProcess(descriptor, modal);\n      return true;\n    }\n  }\n\n  private void waitForProcess(final RunContentDescriptor descriptor, final boolean modal) {\n    final ProcessHandler processHandler = descriptor.getProcessHandler();\n    final boolean killable = !modal && (processHandler instanceof KillableProcess) && ((KillableProcess)processHandler).canKillProcess();\n\n    String title = ExecutionBundle.message(\"terminating.process.progress.title\", descriptor.getDisplayName());\n    ProgressManager.getInstance().run(new Task.Backgroundable(myProject, title, true) {\n\n      {\n        if (killable) {\n          String cancelText= ExecutionBundle.message(\"terminating.process.progress.kill\");\n          setCancelText(cancelText);\n          setCancelTooltipText(cancelText);\n        }\n      }\n\n      @Override\n      public boolean isConditionalModal() {\n        return modal;\n      }\n\n      @Override\n      public boolean shouldStartInBackground() {\n        return !modal;\n      }\n\n      @Override\n      public void run(@NotNull final ProgressIndicator progressIndicator) {\n        final Semaphore semaphore = new Semaphore();\n        semaphore.down();\n\n        ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n          @Override\n          public void run() {\n            final ProcessHandler processHandler = descriptor.getProcessHandler();\n            try {\n              if (processHandler != null) {\n                processHandler.waitFor();\n              }\n            }\n            finally {\n              semaphore.up();\n            }\n          }\n        });\n\n        progressIndicator.setText(ExecutionBundle.message(\"waiting.for.vm.detach.progress.text\"));\n        ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n          @Override\n          public void run() {\n            while (true) {\n              if (progressIndicator.isCanceled() || !progressIndicator.isRunning()) {\n                semaphore.up();\n                break;\n              }\n              try {\n                //noinspection SynchronizeOnThis\n                synchronized (this) {\n                  //noinspection SynchronizeOnThis\n                  wait(2000L);\n                }\n              }\n              catch (InterruptedException ignore) {\n              }\n            }\n          }\n        });\n\n        semaphore.waitFor();\n      }\n\n      @Override\n      public void onCancel() {\n        if (killable && !processHandler.isProcessTerminated()) {\n          ((KillableProcess)processHandler).killProcess();\n        }\n      }\n    });\n  }\n}",
    "ID_4": "public abstract class IoPrimitiveUtils\n{\n    public static String readString( ReadableLogChannel channel, int length ) throws IOException\n    {\n        assert length >= 0 : \"invalid array length \" + length;\n        byte[] chars = new byte[length];\n        channel.get( chars, length );\n        return new String(chars, \"UTF-8\");\n    }\n\n    public static void write3bLengthAndString( WritableLogChannel channel, String string ) throws IOException\n    {\n        byte[] chars = string.getBytes( \"UTF-8\" );\n        // 3 bytes to represent the length (4 is a bit overkill)... maybe\n        // this space optimization is a bit overkill also :)\n        channel.putShort( (short)chars.length );\n        channel.put( (byte)(chars.length >> 16) );\n        channel.put(chars, chars.length);\n    }\n\n    public static String read3bLengthAndString( ReadableLogChannel channel ) throws IOException\n    {\n        short lengthShort = channel.getShort();\n        byte lengthByte = channel.get();\n        int length = (lengthByte << 16) | lengthShort;\n        byte[] chars = new byte[length];\n        channel.get( chars, length );\n        return new String(chars, \"UTF-8\");\n    }\n\n    public static void write2bLengthAndString( WritableLogChannel channel, String string ) throws IOException\n    {\n        byte[] chars = string.getBytes( \"UTF-8\" );\n        channel.putShort( (short)chars.length );\n        channel.put(chars, chars.length);\n    }\n\n    public static String read2bLengthAndString( ReadableLogChannel channel ) throws IOException\n    {\n        short length = channel.getShort();\n        return readString( channel, length );\n    }\n\n    private static char[] readCharArray( ReadableByteChannel channel,\n            ByteBuffer buffer, char[] charArray ) throws IOException\n    {\n        buffer.clear();\n        int charsLeft = charArray.length;\n        int maxSize = buffer.capacity() / 2;\n        int offset = 0; // offset in chars\n        while ( charsLeft > 0 )\n        {\n            if ( charsLeft > maxSize )\n            {\n                buffer.limit( maxSize * 2 );\n                charsLeft -= maxSize;\n            }\n            else\n            {\n                buffer.limit( charsLeft * 2 );\n                charsLeft = 0;\n            }\n            if ( channel.read( buffer ) != buffer.limit() )\n            {\n                return null;\n            }\n            buffer.flip();\n            int length = buffer.limit() / 2;\n            buffer.asCharBuffer().get( charArray, offset, length );\n            offset += length;\n            buffer.clear();\n        }\n        return charArray;\n    }\n\n    public static boolean readAndFlip( ReadableByteChannel channel, ByteBuffer buffer, int bytes )\n            throws IOException\n    {\n        buffer.clear();\n        buffer.limit( bytes );\n        while ( buffer.hasRemaining())\n        {\n            int read = channel.read( buffer );\n\n            if ( read == -1 )\n            {\n                return false;\n            }\n        }\n        buffer.flip();\n        return true;\n    }\n\n    public static Integer readInt( ReadableByteChannel channel, ByteBuffer buffer ) throws IOException\n    {\n        return readAndFlip( channel, buffer, 4 ) ? buffer.getInt() : null;\n    }\n\n    public static byte[] readBytes( ReadableByteChannel channel, byte[] array ) throws IOException\n    {\n        return readBytes( channel, array, array.length );\n    }\n\n    public static byte[] readBytes( ReadableByteChannel channel, byte[] array, int length ) throws IOException\n    {\n        return readAndFlip( channel, ByteBuffer.wrap( array ), length ) ? array : null;\n    }\n\n    public static Map<String, String> read2bMap( ReadableLogChannel channel ) throws IOException\n    {\n        short size = channel.getShort();\n        Map<String, String> map = new HashMap<>();\n        for ( int i = 0; i < size; i++ )\n        {\n            String key = read2bLengthAndString( channel );\n            String value = read2bLengthAndString( channel );\n            map.put( key, value );\n        }\n        return map;\n    }\n\n    public static String readLengthAndString( ReadableByteChannel channel,\n            ByteBuffer buffer ) throws IOException\n    {\n        Integer length = readInt( channel, buffer );\n        if (length != null)\n        {\n            char[] chars = new char[length];\n            chars = readCharArray( channel, buffer, chars );\n            return chars == null ? null : new String( chars );\n        } else\n            return null;\n    }\n\n    public static Map<String, String> readMap( ReadableByteChannel channel, ByteBuffer buffer ) throws IOException\n    {\n        int size = readInt( channel, buffer );\n        Map<String, String> map = new HashMap<>();\n        for ( int i = 0; i < size; i++ )\n        {\n            String key = readLengthAndString( channel, buffer );\n            String value = readLengthAndString( channel, buffer );\n            if ( key == null || value == null )\n            {\n                return null;\n            }\n            map.put( key, value );\n        }\n        return map;\n    }\n\n    public static void writeLengthAndString( StoreChannel channel, ByteBuffer buffer, String value )\n            throws IOException\n    {\n        char[] chars = value.toCharArray();\n        int length = chars.length;\n        writeInt( channel, buffer, length );\n        writeChars( channel, buffer, chars );\n    }\n\n    private static void writeChars( StoreChannel channel, ByteBuffer buffer, char[] chars )\n            throws IOException\n    {\n        int position = 0;\n        do\n        {\n            buffer.clear();\n            int leftToWrite = chars.length - position;\n            if ( leftToWrite * 2 < buffer.capacity() )\n            {\n                buffer.asCharBuffer().put( chars, position, leftToWrite );\n                buffer.limit( leftToWrite * 2);\n                channel.write( buffer );\n                position += leftToWrite;\n            }\n            else\n            {\n                int length = buffer.capacity() / 2;\n                buffer.asCharBuffer().put( chars, position, length );\n                buffer.limit( length * 2 );\n                channel.write( buffer );\n                position += length;\n            }\n        } while ( position < chars.length );\n    }\n\n    public static void writeInt( StoreChannel channel, ByteBuffer buffer, int value )\n            throws IOException\n    {\n        buffer.clear();\n        buffer.putInt( value );\n        buffer.flip();\n        channel.write( buffer );\n    }\n\n    public static Object[] asArray( Object propertyValue )\n    {\n        if ( propertyValue.getClass().isArray() )\n        {\n            int length = Array.getLength( propertyValue );\n            Object[] result = new Object[ length ];\n            for ( int i = 0; i < length; i++ )\n            {\n                result[ i ] = Array.get( propertyValue, i );\n            }\n            return result;\n        }\n        else\n        {\n            return new Object[] { propertyValue };\n        }\n    }\n\n    public static Collection<Object> arrayAsCollection( Object arrayValue )\n    {\n        assert arrayValue.getClass().isArray();\n\n        Collection<Object> result = new ArrayList<>();\n        int length = Array.getLength( arrayValue );\n        for ( int i = 0; i < length; i++ )\n        {\n            result.add( Array.get( arrayValue, i ) );\n        }\n        return result;\n    }\n\n    public static int safeCastLongToInt( long value )\n    {\n        if ( value >= Integer.MAX_VALUE )\n        {\n            throw new IllegalArgumentException( \"Casting long value \" + value + \" to an int would wrap around\" );\n        }\n        return (int) value;\n    }\n}",
    "ID_5": "public abstract class OrderEntryFix implements IntentionAction, LocalQuickFix {\n  private static final String JUNIT4_LIBRARY_NAME = \"JUnit4\";\n\n  OrderEntryFix() {\n  }\n\n  @Override\n  public boolean startInWriteAction() {\n    return true;\n  }\n\n  @Override\n  @NotNull\n  public String getName() {\n    return getText();\n  }\n\n  @Override\n  public void applyFix(@NotNull final Project project, @NotNull final ProblemDescriptor descriptor) {\n    invoke(project, null, descriptor.getPsiElement().getContainingFile());\n  }\n\n  @Nullable\n  public static List<LocalQuickFix> registerFixes(@NotNull QuickFixActionRegistrar registrar, @NotNull final PsiReference reference) {\n    final PsiElement psiElement = reference.getElement();\n    @NonNls final String referenceName = reference.getRangeInElement().substring(psiElement.getText());\n\n    Project project = psiElement.getProject();\n    PsiFile containingFile = psiElement.getContainingFile();\n    if (containingFile == null) return null;\n\n    final VirtualFile classVFile = containingFile.getVirtualFile();\n    if (classVFile == null) return null;\n\n    final ProjectFileIndex fileIndex = ProjectRootManager.getInstance(project).getFileIndex();\n    final Module currentModule = fileIndex.getModuleForFile(classVFile);\n    if (currentModule == null) return null;\n\n    if (\"TestCase\".equals(referenceName) || isAnnotation(psiElement) && isJunitAnnotationName(referenceName, psiElement)) {\n      final boolean isJunit4 = !referenceName.equals(\"TestCase\");\n      @NonNls final String className = isJunit4 ? \"org.junit.\" + referenceName : \"junit.framework.TestCase\";\n      PsiClass found =\n        JavaPsiFacade.getInstance(project).findClass(className, currentModule.getModuleWithDependenciesAndLibrariesScope(true));\n      if (found != null) return null; //no need to add junit to classpath\n      final OrderEntryFix fix = new OrderEntryFix() {\n        @Override\n        @NotNull\n        public String getText() {\n          return QuickFixBundle.message(\"orderEntry.fix.add.junit.jar.to.classpath\");\n        }\n\n        @Override\n        @NotNull\n        public String getFamilyName() {\n          return getText();\n        }\n\n        @Override\n        public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n          return !project.isDisposed() && !currentModule.isDisposed();\n        }\n\n        @Override\n        public void invoke(@NotNull Project project, @Nullable Editor editor, PsiFile file) {\n          List<String> jarPaths;\n          String libraryName;\n          if (isJunit4) {\n            jarPaths = getJUnit4JarPaths();\n            libraryName = JUNIT4_LIBRARY_NAME;\n          }\n          else {\n            jarPaths = Collections.singletonList(JavaSdkUtil.getJunit3JarPath());\n            libraryName = null;\n          }\n          addJarsToRootsAndImportClass(jarPaths, libraryName, currentModule, editor, reference, className);\n        }\n      };\n      registrar.register(fix);\n      return Collections.singletonList((LocalQuickFix)fix);\n    }\n\n    if (isAnnotation(psiElement) && AnnotationUtil.isJetbrainsAnnotation(referenceName)) {\n      @NonNls final String className = \"org.jetbrains.annotations.\" + referenceName;\n      PsiClass found =\n        JavaPsiFacade.getInstance(project).findClass(className, currentModule.getModuleWithDependenciesAndLibrariesScope(true));\n      if (found != null) return null; //no need to add junit to classpath\n      final OrderEntryFix fix = new OrderEntryFix() {\n        @Override\n        @NotNull\n        public String getText() {\n          return QuickFixBundle.message(\"orderEntry.fix.add.annotations.jar.to.classpath\");\n        }\n\n        @Override\n        @NotNull\n        public String getFamilyName() {\n          return getText();\n        }\n\n        @Override\n        public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n          return !project.isDisposed() && !currentModule.isDisposed();\n        }\n\n        @Override\n        public void invoke(@NotNull final Project project, final Editor editor, PsiFile file) {\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              final String libraryPath = locateAnnotationsJar(currentModule);\n              if (libraryPath != null) {\n                new WriteCommandAction(project) {\n                  @Override\n                  protected void run(final Result result) throws Throwable {\n                    addJarsToRootsAndImportClass(Collections.singletonList(libraryPath), null, currentModule, editor, reference,\n                                                 \"org.jetbrains.annotations.\" + referenceName);\n                  }\n                }.execute();\n              }\n            }\n          });\n        }\n      };\n      registrar.register(fix);\n      return Collections.singletonList((LocalQuickFix)fix);\n    }\n\n    List<LocalQuickFix> result = new ArrayList<LocalQuickFix>();\n    Set<Object> librariesToAdd = new THashSet<Object>();\n    final JavaPsiFacade facade = JavaPsiFacade.getInstance(psiElement.getProject());\n    PsiClass[] classes = PsiShortNamesCache.getInstance(project).getClassesByName(referenceName, GlobalSearchScope.allScope(project));\n    List<PsiClass> allowedDependencies = filterAllowedDependencies(psiElement, classes);\n    if (allowedDependencies.isEmpty()) {\n      return result;\n    }\n    classes = allowedDependencies.toArray(new PsiClass[allowedDependencies.size()]);\n    final OrderEntryFix moduleDependencyFix = new AddModuleDependencyFix(currentModule, classVFile, classes, reference);\n    registrar.register(moduleDependencyFix);\n    result.add(moduleDependencyFix);\n    for (final PsiClass aClass : classes) {\n      if (!facade.getResolveHelper().isAccessible(aClass, psiElement, aClass)) continue;\n      PsiFile psiFile = aClass.getContainingFile();\n      if (psiFile == null) continue;\n      VirtualFile virtualFile = psiFile.getVirtualFile();\n      if (virtualFile == null) continue;\n      ModuleFileIndex moduleFileIndex = ModuleRootManager.getInstance(currentModule).getFileIndex();\n      for (OrderEntry orderEntry : fileIndex.getOrderEntriesForFile(virtualFile)) {\n        if (orderEntry instanceof LibraryOrderEntry) {\n          final LibraryOrderEntry libraryEntry = (LibraryOrderEntry)orderEntry;\n          final Library library = libraryEntry.getLibrary();\n          if (library == null) continue;\n          VirtualFile[] files = library.getFiles(OrderRootType.CLASSES);\n          if (files.length == 0) continue;\n          final VirtualFile jar = files[0];\n\n          if (jar == null || libraryEntry.isModuleLevel() && !librariesToAdd.add(jar) || !librariesToAdd.add(library)) continue;\n          OrderEntry entryForFile = moduleFileIndex.getOrderEntryForFile(virtualFile);\n          if (entryForFile != null &&\n              !(entryForFile instanceof ExportableOrderEntry &&\n                ((ExportableOrderEntry)entryForFile).getScope() == DependencyScope.TEST &&\n                !ModuleRootManager.getInstance(currentModule).getFileIndex().isInTestSourceContent(classVFile))) {\n            continue;\n          }\n          final OrderEntryFix fix = new OrderEntryFix() {\n            @Override\n            @NotNull\n            public String getText() {\n              return QuickFixBundle.message(\"orderEntry.fix.add.library.to.classpath\", libraryEntry.getPresentableName());\n            }\n\n            @Override\n            @NotNull\n            public String getFamilyName() {\n              return QuickFixBundle.message(\"orderEntry.fix.family.add.library.to.classpath\");\n            }\n\n            @Override\n            public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n              return !project.isDisposed() && !currentModule.isDisposed() && libraryEntry.isValid();\n            }\n\n            @Override\n            public void invoke(@NotNull final Project project, @Nullable final Editor editor, PsiFile file) {\n              OrderEntryUtil.addLibraryToRoots(libraryEntry, currentModule);\n              if (editor != null) {\n                DumbService.getInstance(project).withAlternativeResolveEnabled(new Runnable() {\n                  @Override\n                  public void run() {\n                    new AddImportAction(project, reference, editor, aClass).execute();\n                  }\n                });\n              }\n            }\n          };\n          registrar.register(fix);\n          result.add(fix);\n        }\n      }\n    }\n    return result;\n  }\n\n  public static void addJUnit4Library(boolean inTests, Module currentModule) throws ClassNotFoundException {\n    final List<String> junit4Paths = getJUnit4JarPaths();\n    addJarsToRoots(junit4Paths, JUNIT4_LIBRARY_NAME, currentModule, null);\n  }\n\n  @NotNull\n  private static List<String> getJUnit4JarPaths() {\n    try {\n      return Arrays.asList(JavaSdkUtil.getJunit4JarPath(),\n                           PathUtil.getJarPathForClass(Class.forName(\"org.hamcrest.Matcher\")),\n                           PathUtil.getJarPathForClass(Class.forName(\"org.hamcrest.Matchers\")));\n    }\n    catch (ClassNotFoundException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  private static List<PsiClass> filterAllowedDependencies(PsiElement element, PsiClass[] classes) {\n    DependencyValidationManager dependencyValidationManager = DependencyValidationManager.getInstance(element.getProject());\n    PsiFile fromFile = element.getContainingFile();\n    List<PsiClass> result = new ArrayList<PsiClass>();\n    for (PsiClass psiClass : classes) {\n      if (dependencyValidationManager.getViolatorDependencyRule(fromFile, psiClass.getContainingFile()) == null) {\n        result.add(psiClass);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isAnnotation(final PsiElement psiElement) {\n    return PsiTreeUtil.getParentOfType(psiElement, PsiAnnotation.class) != null && PsiUtil.isLanguageLevel5OrHigher(psiElement);\n  }\n\n  private static boolean isJunitAnnotationName(@NonNls final String referenceName, @NotNull final PsiElement psiElement) {\n    if (\"Test\".equals(referenceName) || \"Ignore\".equals(referenceName) || \"RunWith\".equals(referenceName) ||\n        \"Before\".equals(referenceName) || \"BeforeClass\".equals(referenceName) ||\n        \"After\".equals(referenceName) || \"AfterClass\".equals(referenceName)) {\n      return true;\n    }\n    final PsiElement parent = psiElement.getParent();\n    if (parent != null && !(parent instanceof PsiAnnotation)) {\n      final PsiReference reference = parent.getReference();\n      if (reference != null) {\n        final String referenceText = parent.getText();\n        if (isJunitAnnotationName(reference.getRangeInElement().substring(referenceText), parent)) {\n          final int lastDot = referenceText.lastIndexOf('.');\n          return lastDot > -1 && referenceText.substring(0, lastDot).equals(\"org.junit\");\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @deprecated use {@link #addJarsToRootsAndImportClass} instead\n   */\n  public static void addBundledJarToRoots(final Project project, @Nullable final Editor editor, final Module currentModule,\n                                          @Nullable final PsiReference reference,\n                                          @NonNls final String className,\n                                          @NonNls final String libVirtFile) {\n    addJarsToRootsAndImportClass(Collections.singletonList(libVirtFile), null, currentModule, editor, reference, className);\n  }\n\n  public static void addJarsToRootsAndImportClass(@NotNull List<String> jarPaths,\n                                                  final String libraryName,\n                                                  @NotNull final Module currentModule, @Nullable final Editor editor,\n                                                  @Nullable final PsiReference reference,\n                                                  @NonNls final String className) {\n    addJarsToRoots(jarPaths, libraryName, currentModule, reference != null ? reference.getElement() : null);\n\n    final Project project = currentModule.getProject();\n    if (editor != null && reference != null && className != null) {\n      DumbService.getInstance(project).withAlternativeResolveEnabled(new Runnable() {\n        @Override\n        public void run() {\n          GlobalSearchScope scope = GlobalSearchScope.moduleWithLibrariesScope(currentModule);\n          PsiClass aClass = JavaPsiFacade.getInstance(project).findClass(className, scope);\n          if (aClass != null) {\n            new AddImportAction(project, reference, editor, aClass).execute();\n          }\n        }\n      });\n    }\n  }\n\n  public static void addJarToRoots(@NotNull String jarPath, final @NotNull Module module, @Nullable PsiElement location) {\n    addJarsToRoots(Collections.singletonList(jarPath), null, module, location);\n  }\n\n  public static void addJarsToRoots(@NotNull List<String> jarPaths, @Nullable String libraryName,\n                                    @NotNull Module module, @Nullable PsiElement location) {\n    List<String> urls = ContainerUtil.map(jarPaths, new Function<String, String>() {\n      @Override\n      public String fun(String path) {\n        return refreshAndConvertToUrl(path);\n      }\n    });\n    boolean inTests = false;\n    if (location != null) {\n      final VirtualFile vFile = location.getContainingFile().getVirtualFile();\n      if (vFile != null && ModuleRootManager.getInstance(module).getFileIndex().isInTestSourceContent(vFile)) {\n        inTests = true;\n      }\n    }\n    ModuleRootModificationUtil.addModuleLibrary(module, libraryName, urls, Collections.<String>emptyList(),\n                                                inTests ? DependencyScope.TEST : DependencyScope.COMPILE);\n  }\n\n  @NotNull\n  private static String refreshAndConvertToUrl(String jarPath) {\n    final File libraryRoot = new File(jarPath);\n    LocalFileSystem.getInstance().refreshAndFindFileByIoFile(libraryRoot);\n    return VfsUtil.getUrlForLibraryRoot(libraryRoot);\n  }\n\n  public static boolean ensureAnnotationsJarInPath(final Module module) {\n    if (isAnnotationsJarInPath(module)) return true;\n    if (module == null) return false;\n    final String libraryPath = locateAnnotationsJar(module);\n    if (libraryPath != null) {\n      new WriteCommandAction(module.getProject()) {\n        @Override\n        protected void run(final Result result) throws Throwable {\n          addJarToRoots(libraryPath, module, null);\n        }\n      }.execute();\n      return true;\n    }\n    return false;\n  }\n\n  @Nullable\n  public static String locateAnnotationsJar(@NotNull Module module) {\n    String jarName;\n    String libPath;\n    if (EffectiveLanguageLevelUtil.getEffectiveLanguageLevel(module).isAtLeast(LanguageLevel.JDK_1_8)) {\n      jarName = \"annotations-java8.jar\";\n      libPath = new File(PathManager.getHomePath(), \"redist\").getAbsolutePath();\n    }\n    else {\n      jarName = \"annotations.jar\";\n      libPath = PathManager.getLibPath();\n    }\n    final LocateLibraryDialog dialog = new LocateLibraryDialog(module, libPath, jarName, QuickFixBundle.message(\"add.library.annotations.description\"));\n    return dialog.showAndGet() ? dialog.getResultingLibraryPath() : null;\n  }\n\n  public static boolean isAnnotationsJarInPath(Module module) {\n    if (module == null) return false;\n    return JavaPsiFacade.getInstance(module.getProject())\n             .findClass(AnnotationUtil.LANGUAGE, GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module)) != null;\n  }\n}\n",
    "ID_6": "public abstract class LightPlatformTestCase extends UsefulTestCase implements DataProvider {\n  @NonNls public static final String PROFILE = \"Configurable\";\n\n  @NonNls private static final String LIGHT_PROJECT_MARK = \"Light project: \";\n\n  private static IdeaTestApplication ourApplication;\n  protected static Project ourProject;\n  private static Module ourModule;\n  private static PsiManager ourPsiManager;\n  private static boolean ourAssertionsInTestDetected;\n  private static VirtualFile ourSourceRoot;\n  private static TestCase ourTestCase;\n  public static Thread ourTestThread;\n  private static LightProjectDescriptor ourProjectDescriptor;\n  private static boolean ourHaveShutdownHook;\n\n  private ThreadTracker myThreadTracker;\n\n  /**\n   * @return Project to be used in tests for example for project components retrieval.\n   */\n  public static Project getProject() {\n    return ourProject;\n  }\n\n  /**\n   * @return Module to be used in tests for example for module components retrieval.\n   */\n  public static Module getModule() {\n    return ourModule;\n  }\n\n  /**\n   * Shortcut to PsiManager.getInstance(getProject())\n   */\n  @NotNull\n  public static PsiManager getPsiManager() {\n    if (ourPsiManager == null) {\n      ourPsiManager = PsiManager.getInstance(ourProject);\n    }\n    return ourPsiManager;\n  }\n\n  @NotNull\n  public static IdeaTestApplication initApplication() {\n    ourApplication = IdeaTestApplication.getInstance(null);\n    return ourApplication;\n  }\n\n  @TestOnly\n  public static void disposeApplication() {\n    if (ourApplication != null) {\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        @Override\n        public void run() {\n          Disposer.dispose(ourApplication);\n        }\n      });\n\n      ourApplication = null;\n    }\n  }\n\n  public static IdeaTestApplication getApplication() {\n    return ourApplication;\n  }\n\n  @SuppressWarnings(\"UseOfSystemOutOrSystemErr\")\n  public static void reportTestExecutionStatistics() {\n    System.out.println(\"----- TEST STATISTICS -----\");\n    UsefulTestCase.logSetupTeardownCosts();\n    System.out.println(String.format(\"##teamcity[buildStatisticValue key='ideaTests.appInstancesCreated' value='%d']\",\n                                     MockApplication.INSTANCES_CREATED));\n    System.out.println(String.format(\"##teamcity[buildStatisticValue key='ideaTests.projectInstancesCreated' value='%d']\",\n                                     ProjectManagerImpl.TEST_PROJECTS_CREATED));\n    long totalGcTime = 0;\n    for (GarbageCollectorMXBean mxBean : ManagementFactory.getGarbageCollectorMXBeans()) {\n      totalGcTime += mxBean.getCollectionTime();\n    }\n    System.out.println(String.format(\"##teamcity[buildStatisticValue key='ideaTests.gcTimeMs' value='%d']\", totalGcTime));\n    System.out.println(String.format(\"##teamcity[buildStatisticValue key='ideaTests.classesLoaded' value='%d']\",\n                                     ManagementFactory.getClassLoadingMXBean().getTotalLoadedClassCount()));\n  }\n\n  protected void resetAllFields() {\n    resetClassFields(getClass());\n  }\n\n  private void resetClassFields(@NotNull Class<?> aClass) {\n    try {\n      UsefulTestCase.clearDeclaredFields(this, aClass);\n    }\n    catch (IllegalAccessException e) {\n      throw new RuntimeException(e);\n    }\n\n    if (aClass == LightPlatformTestCase.class) return;\n    resetClassFields(aClass.getSuperclass());\n  }\n\n  private static void cleanPersistedVFSContent() {\n    ((PersistentFSImpl)PersistentFS.getInstance()).cleanPersistedContents();\n  }\n\n  public static boolean isLight(@NotNull Project project) {\n    String creationPlace = project.getUserData(CREATION_PLACE);\n    return creationPlace != null && StringUtil.startsWith(creationPlace, LIGHT_PROJECT_MARK);\n  }\n\n  private static void initProject(@NotNull final LightProjectDescriptor descriptor) throws Exception {\n    ourProjectDescriptor = descriptor;\n\n    final File projectFile = FileUtil.createTempFile(\"light_temp_\", ProjectFileType.DOT_DEFAULT_EXTENSION);\n\n    new WriteCommandAction.Simple(null) {\n      @SuppressWarnings(\"AssignmentToStaticFieldFromInstanceMethod\")\n      @Override\n      protected void run() throws Throwable {\n        if (ourProject != null) {\n          closeAndDeleteProject();\n        }\n        else {\n          cleanPersistedVFSContent();\n        }\n\n        LocalFileSystem.getInstance().refreshAndFindFileByIoFile(projectFile);\n\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        new Throwable(projectFile.getPath()).printStackTrace(new PrintStream(buffer));\n\n        ourProject = PlatformTestCase.createProject(projectFile, LIGHT_PROJECT_MARK + buffer);\n        ourPathToKeep = projectFile.getPath();\n        if (!ourHaveShutdownHook) {\n          ourHaveShutdownHook = true;\n          registerShutdownHook();\n        }\n        ourPsiManager = null;\n        ourModule = createMainModule(descriptor.getModuleType());\n\n        if (descriptor instanceof LightProjectDescriptorEx) {\n          ((LightProjectDescriptorEx)descriptor).setupModule(ourModule);\n          \n          if(!((LightProjectDescriptorEx)descriptor).shouldConfigureModule()) return;\n        }\n        \n        VirtualFile dummyRoot = VirtualFileManager.getInstance().findFileByUrl(\"temp:///\");\n        assert dummyRoot != null;\n        dummyRoot.refresh(false, false);\n\n        try {\n          ourSourceRoot = dummyRoot.createChildDirectory(this, \"src\");\n          cleanSourceRoot();\n        }\n        catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n\n        final IndexableFileSet indexableFileSet = new IndexableFileSet() {\n          @Override\n          public boolean isInSet(@NotNull final VirtualFile file) {\n            return ourSourceRoot != null &&\n                   file.getFileSystem() == ourSourceRoot.getFileSystem() &&\n                   ourProject != null &&\n                   ourProject.isOpen();\n          }\n\n          @Override\n          public void iterateIndexableFilesIn(@NotNull final VirtualFile file, @NotNull final ContentIterator iterator) {\n            VfsUtilCore.visitChildrenRecursively(file, new VirtualFileVisitor() {\n              @Override\n              public boolean visitFile(@NotNull VirtualFile file) {\n                iterator.processFile(file);\n                return true;\n              }\n            });\n          }\n        };\n        FileBasedIndex.getInstance().registerIndexableSet(indexableFileSet, null);\n        Disposer.register(ourProject, new Disposable() {\n          @Override\n          public void dispose() {\n            FileBasedIndex.getInstance().removeIndexableSet(indexableFileSet);\n          }\n        });\n\n        updateModel(ourModule, new Consumer<ModifiableRootModel>() {\n          @Override\n          public void consume(ModifiableRootModel model) {\n            final Sdk sdk = descriptor.getSdk();\n            if (sdk != null) {\n              model.setSdk(sdk);\n            }\n\n            ContentEntry contentEntry = model.addContentEntry(ourSourceRoot);\n            contentEntry.addSourceFolder(ourSourceRoot, false);\n\n            descriptor.configureModule(ourModule, model, contentEntry);\n          }\n        });\n      }\n\n      private void cleanSourceRoot() throws IOException {\n        TempFileSystem tempFs = (TempFileSystem)ourSourceRoot.getFileSystem();\n        for (VirtualFile child : ourSourceRoot.getChildren()) {\n          if (!tempFs.exists(child)) {\n            tempFs.createChildFile(this, ourSourceRoot, child.getName());\n          }\n          child.delete(this);\n        }\n      }\n    }.execute().throwException();\n\n    // project creation may make a lot of pointers, do not regard them as leak\n    ((VirtualFilePointerManagerImpl)VirtualFilePointerManager.getInstance()).storePointers();\n  }\n\n  @NotNull\n  protected static Module createMainModule(@NotNull final ModuleType moduleType) {\n    return ApplicationManager.getApplication().runWriteAction(new Computable<Module>() {\n      @Override\n      public Module compute() {\n        return ModuleManager.getInstance(ourProject).newModule(\"light_idea_test_case.iml\", moduleType.getId());\n      }\n    });\n  }\n\n  /**\n   * @return The only source root\n   */\n  public static VirtualFile getSourceRoot() {\n    return ourSourceRoot;\n  }\n\n  @Override\n  protected void setUp() throws Exception {\n    UIUtil.invokeAndWaitIfNeeded(new Runnable() {\n      @Override\n      public void run() {\n        try {\n          LightPlatformTestCase.super.setUp();\n          initApplication();\n          ApplicationInfoImpl.setInPerformanceTest(isPerformanceTest());\n\n          ourApplication.setDataProvider(LightPlatformTestCase.this);\n          LightProjectDescriptor descriptor = new SimpleLightProjectDescriptor(getModuleType(), getProjectJDK());\n          doSetup(descriptor, configureLocalInspectionTools(), getTestRootDisposable());\n          InjectedLanguageManagerImpl.pushInjectors(getProject());\n\n          storeSettings();\n\n          myThreadTracker = new ThreadTracker();\n          ModuleRootManager.getInstance(ourModule).orderEntries().getAllLibrariesAndSdkClassesRoots();\n          VirtualFilePointerManagerImpl filePointerManager = (VirtualFilePointerManagerImpl)VirtualFilePointerManager.getInstance();\n          filePointerManager.storePointers();\n        }\n        catch (RuntimeException e) {\n          throw e;\n        }\n        catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n      }\n    });\n  }\n\n  public static void doSetup(@NotNull LightProjectDescriptor descriptor,\n                             @NotNull LocalInspectionTool[] localInspectionTools,\n                             @NotNull Disposable parentDisposable) throws Exception {\n    assertNull(\"Previous test \" + ourTestCase + \" hasn't called tearDown(). Probably overridden without super call.\", ourTestCase);\n    IdeaLogger.ourErrorsOccurred = null;\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    if (ourProject == null || ourProjectDescriptor == null || !ourProjectDescriptor.equals(descriptor)) {\n      initProject(descriptor);\n    }\n\n    ProjectManagerEx projectManagerEx = ProjectManagerEx.getInstanceEx();\n    projectManagerEx.openTestProject(ourProject);\n\n    MessageBusConnection connection = ourProject.getMessageBus().connect(parentDisposable);\n    connection.subscribe(ProjectTopics.MODULES, new ModuleAdapter() {\n      @Override\n      public void moduleAdded(@NotNull Project project, @NotNull Module module) {\n        fail(\"Adding modules is not permitted in LightIdeaTestCase.\");\n      }\n    });\n\n    clearUncommittedDocuments(getProject());\n\n    CodeInsightTestFixtureImpl.configureInspections(localInspectionTools, getProject(),\n                                                    Collections.<String>emptyList(), parentDisposable);\n\n    assertFalse(getPsiManager().isDisposed());\n    Boolean passed = null;\n    try {\n      passed = StartupManagerEx.getInstanceEx(getProject()).startupActivityPassed();\n    }\n    catch (Exception ignored) {\n\n    }\n    assertTrue(\"open: \" + getProject().isOpen() +\n               \"; disposed:\" + getProject().isDisposed() +\n               \"; startup passed:\" + passed +\n               \"; all open projects: \" + Arrays.asList(ProjectManager.getInstance().getOpenProjects()), getProject().isInitialized());\n\n    CodeStyleSettingsManager.getInstance(getProject()).setTemporarySettings(new CodeStyleSettings());\n\n    final FileDocumentManager manager = FileDocumentManager.getInstance();\n    if (manager instanceof FileDocumentManagerImpl) {\n      Document[] unsavedDocuments = manager.getUnsavedDocuments();\n      manager.saveAllDocuments();\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        @Override\n        public void run() {\n          ((FileDocumentManagerImpl)manager).dropAllUnsavedDocuments();\n        }\n      });\n\n      assertEmpty(\"There are unsaved documents\", Arrays.asList(unsavedDocuments));\n    }\n    UIUtil.dispatchAllInvocationEvents(); // startup activities\n\n    ((FileTypeManagerImpl)FileTypeManager.getInstance()).drainReDetectQueue();\n  }\n\n  // todo: use Class<? extends InspectionProfileEntry> once on Java 7\n  protected void enableInspectionTools(@NotNull Class<?>... classes) {\n    final InspectionProfileEntry[] tools = new InspectionProfileEntry[classes.length];\n\n    final List<InspectionEP> eps = ContainerUtil.newArrayList();\n    ContainerUtil.addAll(eps, Extensions.getExtensions(LocalInspectionEP.LOCAL_INSPECTION));\n    ContainerUtil.addAll(eps, Extensions.getExtensions(InspectionEP.GLOBAL_INSPECTION));\n\n    next:\n    for (int i = 0; i < classes.length; i++) {\n      for (InspectionEP ep : eps) {\n        if (classes[i].getName().equals(ep.implementationClass)) {\n          tools[i] = ep.instantiateTool();\n          continue next;\n        }\n      }\n      throw new IllegalArgumentException(\"Unable to find extension point for \" + classes[i].getName());\n    }\n\n    enableInspectionTools(tools);\n  }\n\n  protected void enableInspectionTools(@NotNull InspectionProfileEntry... tools) {\n    for (InspectionProfileEntry tool : tools) {\n      enableInspectionTool(tool);\n    }\n  }\n\n  protected void enableInspectionTool(@NotNull InspectionToolWrapper toolWrapper) {\n    enableInspectionTool(getProject(), toolWrapper);\n  }\n  protected void enableInspectionTool(@NotNull InspectionProfileEntry tool) {\n    InspectionToolWrapper toolWrapper = InspectionToolRegistrar.wrapTool(tool);\n    enableInspectionTool(getProject(), toolWrapper);\n  }\n\n  public static void enableInspectionTool(@NotNull final Project project, @NotNull final InspectionToolWrapper toolWrapper) {\n    final InspectionProfile profile = InspectionProjectProfileManager.getInstance(project).getInspectionProfile();\n    final String shortName = toolWrapper.getShortName();\n    final HighlightDisplayKey key = HighlightDisplayKey.find(shortName);\n    if (key == null) {\n      HighlightDisplayKey.register(shortName, toolWrapper.getDisplayName(), toolWrapper.getID());\n    }\n    InspectionProfileImpl.initAndDo(new Computable() {\n      @Override\n      public Object compute() {\n        InspectionProfileImpl impl = (InspectionProfileImpl)profile;\n        InspectionToolWrapper existingWrapper = impl.getInspectionTool(shortName, project);\n        if (existingWrapper == null || existingWrapper.isInitialized() != toolWrapper.isInitialized() || toolWrapper.isInitialized() && toolWrapper.getTool() != existingWrapper.getTool()) {\n          impl.addTool(project, toolWrapper, new THashMap<String, List<String>>());\n        }\n        impl.enableTool(shortName, project);\n        return null;\n      }\n    });\n  }\n\n  @NotNull\n  protected LocalInspectionTool[] configureLocalInspectionTools() {\n    return LocalInspectionTool.EMPTY_ARRAY;\n  }\n\n  @Override\n  protected void tearDown() throws Exception {\n    Project project = getProject();\n    CodeStyleSettingsManager.getInstance(project).dropTemporarySettings();\n    @SuppressWarnings(\"ThrowableResultOfMethodCallIgnored\")\n    CompositeException damage = checkForSettingsDamage();\n    VirtualFilePointerManagerImpl filePointerManager = (VirtualFilePointerManagerImpl)VirtualFilePointerManager.getInstance();\n    doTearDown(project, ourApplication, true);\n\n    try {\n      super.tearDown();\n    }\n    finally {\n      myThreadTracker.checkLeak();\n      InjectedLanguageManagerImpl.checkInjectorsAreDisposed(project);\n      filePointerManager.assertPointersAreDisposed();\n    }\n    damage.throwIfNotEmpty();\n  }\n\n  public static void doTearDown(@NotNull final Project project, @NotNull IdeaTestApplication application, boolean checkForEditors) throws Exception {\n    ((FileTypeManagerImpl)FileTypeManager.getInstance()).drainReDetectQueue();\n    DocumentCommitThread.getInstance().clearQueue();\n    CodeStyleSettingsManager.getInstance(project).dropTemporarySettings();\n    checkAllTimersAreDisposed();\n    UsefulTestCase.doPostponedFormatting(project);\n\n    LookupManager lookupManager = LookupManager.getInstance(project);\n    if (lookupManager != null) {\n      lookupManager.hideActiveLookup();\n    }\n    ((StartupManagerImpl)StartupManager.getInstance(project)).prepareForNextTest();\n    InspectionProfileManager.getInstance().deleteProfile(PROFILE);\n    assertNotNull(\"Application components damaged\", ProjectManager.getInstance());\n\n    new WriteCommandAction.Simple(project) {\n      @Override\n      protected void run() throws Throwable {\n        if (ourSourceRoot != null) {\n          try {\n            final VirtualFile[] children = ourSourceRoot.getChildren();\n            for (VirtualFile child : children) {\n              child.delete(this);\n            }\n          }\n          catch (IOException e) {\n            //noinspection CallToPrintStackTrace\n            e.printStackTrace();\n          }\n        }\n        EncodingManager encodingManager = EncodingManager.getInstance();\n        if (encodingManager instanceof EncodingManagerImpl) ((EncodingManagerImpl)encodingManager).clearDocumentQueue();\n\n        FileDocumentManager manager = FileDocumentManager.getInstance();\n\n        ApplicationManager.getApplication().runWriteAction(EmptyRunnable.getInstance()); // Flush postponed formatting if any.\n        manager.saveAllDocuments();\n        if (manager instanceof FileDocumentManagerImpl) {\n          ((FileDocumentManagerImpl)manager).dropAllUnsavedDocuments();\n        }\n      }\n    }.execute().throwException();\n\n    assertFalse(PsiManager.getInstance(project).isDisposed());\n    if (!ourAssertionsInTestDetected) {\n      if (IdeaLogger.ourErrorsOccurred != null) {\n        throw IdeaLogger.ourErrorsOccurred;\n      }\n    }\n    PsiDocumentManagerImpl documentManager = clearUncommittedDocuments(project);\n    ((HintManagerImpl)HintManager.getInstance()).cleanup();\n    DocumentCommitThread.getInstance().clearQueue();\n\n    UIUtil.invokeAndWaitIfNeeded(new Runnable() {\n      @Override\n      public void run() {\n        ((UndoManagerImpl)UndoManager.getGlobalInstance()).dropHistoryInTests();\n        ((UndoManagerImpl)UndoManager.getInstance(project)).dropHistoryInTests();\n\n        UIUtil.dispatchAllInvocationEvents();\n      }\n    });\n\n    TemplateDataLanguageMappings.getInstance(project).cleanupForNextTest();\n\n    ProjectManagerEx.getInstanceEx().closeTestProject(project);\n    application.setDataProvider(null);\n    ourTestCase = null;\n    ((PsiManagerImpl)PsiManager.getInstance(project)).cleanupForNextTest();\n\n    CompletionProgressIndicator.cleanupForNextTest();\n\n    if (checkForEditors) {\n      checkEditorsReleased();\n    }\n    documentManager.clearUncommittedDocuments();\n    \n    if (ourTestCount++ % 100 == 0) {\n      // some tests are written in Groovy, and running all of them may result in some 40M of memory wasted on bean infos\n      // so let's clear the cache every now and then to ensure it doesn't grow too large\n      GCUtil.clearBeanInfoCache();\n    }\n  }\n  \n  private static int ourTestCount;\n\n  public static PsiDocumentManagerImpl clearUncommittedDocuments(@NotNull Project project) {\n    PsiDocumentManagerImpl documentManager = (PsiDocumentManagerImpl)PsiDocumentManager.getInstance(project);\n    documentManager.clearUncommittedDocuments();\n\n    ProjectManagerImpl projectManager = (ProjectManagerImpl)ProjectManager.getInstance();\n    if (projectManager.isDefaultProjectInitialized()) {\n      Project defaultProject = projectManager.getDefaultProject();\n      ((PsiDocumentManagerImpl)PsiDocumentManager.getInstance(defaultProject)).clearUncommittedDocuments();\n    }\n    return documentManager;\n  }\n\n  public static void checkEditorsReleased() throws Exception {\n    CompositeException result = new CompositeException();\n    final Editor[] allEditors = EditorFactory.getInstance().getAllEditors();\n    if (allEditors.length > 0) {\n      for (Editor editor : allEditors) {\n        try {\n          EditorFactoryImpl.throwNotReleasedError(editor);\n        }\n        catch (Throwable e) {\n          result.add(e);\n        }\n        finally {\n          EditorFactory.getInstance().releaseEditor(editor);\n        }\n      }\n      try {\n        ((EditorImpl)allEditors[0]).throwDisposalError(\"Unreleased editors: \" + allEditors.length);\n      }\n      catch (Throwable e) {\n        e.printStackTrace();\n        result.add(e);\n      }\n    }\n    if (!result.isEmpty()) throw result;\n  }\n\n  @Override\n  public final void runBare() throws Throwable {\n    if (!shouldRunTest()) {\n      return;\n    }\n\n    final AtomicReference<Throwable> throwable = new AtomicReference<Throwable>();\n\n    replaceIdeEventQueueSafely();\n    SwingUtilities.invokeAndWait(new Runnable() {\n      @Override\n      public void run() {\n        try {\n          ourTestThread = Thread.currentThread();\n          startRunAndTear();\n        }\n        catch (Throwable e) {\n          throwable.set(e);\n        }\n        finally {\n          ourTestThread = null;\n          try {\n            Application application = ApplicationManager.getApplication();\n            if (application instanceof ApplicationEx) {\n              PlatformTestCase.cleanupApplicationCaches(ourProject);\n            }\n            resetAllFields();\n          }\n          catch (Throwable e) {\n            e.printStackTrace();\n          }\n        }\n      }\n    });\n\n    if (throwable.get() != null) {\n      throw throwable.get();\n    }\n\n    // just to make sure all deferred Runnables to finish\n    SwingUtilities.invokeAndWait(EmptyRunnable.getInstance());\n\n    if (IdeaLogger.ourErrorsOccurred != null) {\n      throw IdeaLogger.ourErrorsOccurred;\n    }\n  }\n\n  private void startRunAndTear() throws Throwable {\n    setUp();\n    try {\n      ourAssertionsInTestDetected = true;\n      runTest();\n      ourAssertionsInTestDetected = false;\n    }\n    finally {\n      //try{\n      tearDown();\n      //}\n      //catch(Throwable th){\n      //  noinspection CallToPrintStackTrace\n      //th.printStackTrace();\n      //}\n    }\n  }\n\n  @Override\n  public Object getData(String dataId) {\n    return ourProject == null || ourProject.isDisposed() ? null : new TestDataProvider(ourProject).getData(dataId);\n  }\n\n  protected Sdk getProjectJDK() {\n    return null;\n  }\n\n  @NotNull\n  protected ModuleType getModuleType() {\n    return EmptyModuleType.getInstance();\n  }\n\n  /**\n   * Creates dummy source file. One is not placed under source root so some PSI functions like resolve to external classes\n   * may not work. Though it works significantly faster and yet can be used if you need to create some PSI structures for\n   * test purposes\n   *\n   * @param fileName - name of the file to create. Extension is used to choose what PSI should be created like java, jsp, aj, xml etc.\n   * @param text     - file text.\n   * @return dummy psi file.\n   * @throws IncorrectOperationException\n   *\n   */\n  @NotNull\n  protected static PsiFile createFile(@NonNls @NotNull String fileName, @NonNls @NotNull String text) throws IncorrectOperationException {\n    FileType fileType = FileTypeManager.getInstance().getFileTypeByFileName(fileName);\n    return PsiFileFactory.getInstance(getProject())\n      .createFileFromText(fileName, fileType, text, LocalTimeCounter.currentTime(), true, false);\n  }\n\n  @NotNull\n  protected static PsiFile createLightFile(@NonNls @NotNull String fileName, @NotNull String text) throws IncorrectOperationException {\n    FileType fileType = FileTypeManager.getInstance().getFileTypeByFileName(fileName);\n    return PsiFileFactory.getInstance(getProject())\n      .createFileFromText(fileName, fileType, text, LocalTimeCounter.currentTime(), false, false);\n  }\n\n  /**\n   * Convenient conversion of testSomeTest -> someTest | SomeTest where testSomeTest is the name of current test.\n   *\n   * @param lowercaseFirstLetter - whether first letter after test should be lowercased.\n   */\n  @Override\n  protected String getTestName(boolean lowercaseFirstLetter) {\n    String name = getName();\n    assertTrue(\"Test name should start with 'test': \" + name, name.startsWith(\"test\"));\n    name = name.substring(\"test\".length());\n    if (!name.isEmpty() && lowercaseFirstLetter && !UsefulTestCase.isAllUppercaseName(name)) {\n      name = Character.toLowerCase(name.charAt(0)) + name.substring(1);\n    }\n    return name;\n  }\n\n  protected static void commitDocument(@NotNull Document document) {\n    PsiDocumentManager.getInstance(getProject()).commitDocument(document);\n  }\n\n  protected static void commitAllDocuments() {\n    PsiDocumentManager.getInstance(getProject()).commitAllDocuments();\n  }\n\n  @Override\n  protected CodeStyleSettings getCurrentCodeStyleSettings() {\n    if (CodeStyleSchemes.getInstance().getCurrentScheme() == null) return new CodeStyleSettings();\n    return CodeStyleSettingsManager.getSettings(getProject());\n  }\n\n  protected static Document getDocument(@NotNull PsiFile file) {\n    return PsiDocumentManager.getInstance(getProject()).getDocument(file);\n  }\n\n  @SuppressWarnings(\"NonPrivateFieldAccessedInSynchronizedContext\")\n  public static synchronized void closeAndDeleteProject() {\n    if (ourProject != null) {\n      ApplicationManager.getApplication().assertWriteAccessAllowed();\n\n      if (!ourProject.isDisposed()) {\n        VirtualFile projectFile = ourProject.getProjectFile();\n        File ioFile = projectFile == null ? null : VfsUtilCore.virtualToIoFile(projectFile);\n        Disposer.dispose(ourProject);\n        if (ioFile != null) {\n          File dir = ioFile.getParentFile();\n          if (dir.getName().startsWith(UsefulTestCase.TEMP_DIR_MARKER)) {\n            FileUtil.delete(dir);\n          }\n          else {\n            FileUtil.delete(ioFile);\n          }\n        }\n      }\n\n      ProjectManagerEx.getInstanceEx().closeAndDispose(ourProject);\n\n      ourProject = null;\n      ourPathToKeep = null;\n    }\n  }\n\n  private static void registerShutdownHook() {\n    ShutDownTracker.getInstance().registerShutdownTask(new Runnable() {\n      @Override\n      public void run() {\n        ShutDownTracker.invokeAndWait(true, true, new Runnable() {\n          @Override\n          public void run() {\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              @Override\n              public void run() {\n                closeAndDeleteProject();\n              }\n            });\n          }\n        });\n      }\n    });\n  }\n\n  private static class SimpleLightProjectDescriptor implements LightProjectDescriptor {\n    @NotNull private final ModuleType myModuleType;\n    private final Sdk mySdk;\n\n    SimpleLightProjectDescriptor(@NotNull ModuleType moduleType, Sdk sdk) {\n      myModuleType = moduleType;\n      mySdk = sdk;\n    }\n\n    @NotNull\n    @Override\n    public ModuleType getModuleType() {\n      return myModuleType;\n    }\n\n    @Override\n    public Sdk getSdk() {\n      return mySdk;\n    }\n\n    @Override\n    public void configureModule(@NotNull Module module, @NotNull ModifiableRootModel model, @NotNull ContentEntry contentEntry) {\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n\n      SimpleLightProjectDescriptor that = (SimpleLightProjectDescriptor)o;\n\n      if (!myModuleType.equals(that.myModuleType)) return false;\n      return areJdksEqual(that.getSdk());\n    }\n\n    @Override\n    public int hashCode() {\n      return myModuleType.hashCode();\n    }\n\n    private boolean areJdksEqual(final Sdk newSdk) {\n      if (mySdk == null || newSdk == null) return mySdk == newSdk;\n\n      final String[] myUrls = mySdk.getRootProvider().getUrls(OrderRootType.CLASSES);\n      final String[] newUrls = newSdk.getRootProvider().getUrls(OrderRootType.CLASSES);\n      return ContainerUtil.newHashSet(myUrls).equals(ContainerUtil.newHashSet(newUrls));\n    }\n  }\n}\n",
    "ID_7": "public class BuildMain {\n  private static final String PRELOAD_PROJECT_PATH = \"preload.project.path\";\n  private static final String PRELOAD_CONFIG_PATH = \"preload.config.path\";\n  \n  private static final String LOG_CONFIG_FILE_NAME = \"build-log.properties\";\n  private static final String LOG_FILE_NAME = \"build.log\";\n  private static final String DEFAULT_LOGGER_CONFIG = \"defaultLogConfig.properties\";\n  private static final String LOG_FILE_MACRO = \"$LOG_FILE_PATH$\";\n  private static final Logger LOG;\n  static {\n    initLoggers();\n    LOG = Logger.getInstance(\"#org.jetbrains.jps.cmdline.BuildMain\");\n  }\n\n  private static final int HOST_ARG = 0;\n  private static final int PORT_ARG = HOST_ARG + 1;\n  private static final int SESSION_ID_ARG = PORT_ARG + 1;\n  private static final int SYSTEM_DIR_ARG = SESSION_ID_ARG + 1;\n\n  private static NioEventLoopGroup ourEventLoopGroup;\n  @Nullable \n  private static PreloadedData ourPreloadedData;\n\n  public static void main(String[] args){\n    final long processStart = System.currentTimeMillis();\n    final String startMessage = \"Build process started. Classpath: \" + System.getProperty(\"java.class.path\");\n    System.out.println(startMessage);\n    LOG.info(startMessage);\n    \n    final String host = args[HOST_ARG];\n    final int port = Integer.parseInt(args[PORT_ARG]);\n    final UUID sessionId = UUID.fromString(args[SESSION_ID_ARG]);\n    @SuppressWarnings(\"ConstantConditions\")\n    final File systemDir = new File(FileUtil.toCanonicalPath(args[SYSTEM_DIR_ARG]));\n    Utils.setSystemRoot(systemDir);\n\n    final long connectStart = System.currentTimeMillis();\n    // IDEA-123132, let's try again\n    for (int attempt = 0; attempt < 3; attempt++) {\n      try {\n        ourEventLoopGroup = new NioEventLoopGroup(1, SharedThreadPool.getInstance());\n        break;\n      }\n      catch (IllegalStateException e) {\n        if (attempt == 2) {\n          printErrorAndExit(host, port, e);\n          return;\n        }\n        else {\n          LOG.warn(\"Cannot create event loop, attempt #\" + attempt, e);\n          try {\n            //noinspection BusyWait\n            Thread.sleep(10 * (attempt + 1));\n          }\n          catch (InterruptedException ignored) {\n          }\n        }\n      }\n    }\n\n    final Bootstrap bootstrap = new Bootstrap().group(ourEventLoopGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer() {\n      @Override\n      protected void initChannel(Channel channel) throws Exception {\n        channel.pipeline().addLast(new ProtobufVarint32FrameDecoder(),\n                                   new ProtobufDecoder(CmdlineRemoteProto.Message.getDefaultInstance()),\n                                   new ProtobufVarint32LengthFieldPrepender(),\n                                   new ProtobufEncoder(),\n                                   new MyMessageHandler(sessionId));\n      }\n    }).option(ChannelOption.TCP_NODELAY, true).option(ChannelOption.SO_KEEPALIVE, true);\n\n    final ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port)).awaitUninterruptibly();\n\n    \n    final boolean success = future.isSuccess();\n    if (success) {\n      LOG.info(\"Connection to IDE established in \" + (System.currentTimeMillis() - connectStart) + \" ms\");\n\n      final String projectPathToPreload = System.getProperty(PRELOAD_PROJECT_PATH, null);\n      final String globalsPathToPreload = System.getProperty(PRELOAD_CONFIG_PATH, null); \n      if (projectPathToPreload != null && globalsPathToPreload != null) {\n        final PreloadedData data = new PreloadedData();\n        ourPreloadedData = data;\n        try {\n          FileSystemUtil.getAttributes(projectPathToPreload); // this will pre-load all FS optimizations\n\n          final BuildRunner runner = new BuildRunner(new JpsModelLoaderImpl(projectPathToPreload, globalsPathToPreload, null));\n          data.setRunner(runner);\n\n          final File dataStorageRoot = Utils.getDataStorageRoot(projectPathToPreload);\n          final BuildFSState fsState = new BuildFSState(false);\n          final ProjectDescriptor pd = runner.load(new MessageHandler() {\n            @Override\n            public void processMessage(BuildMessage msg) {\n              data.addMessage(msg);\n            }\n          }, dataStorageRoot, fsState);\n          data.setProjectDescriptor(pd);\n          \n          try {\n            final File fsStateFile = new File(dataStorageRoot, BuildSession.FS_STATE_FILE);\n            final DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream(fsStateFile)));\n            try {\n              final int version = in.readInt();\n              if (version == BuildFSState.VERSION) {\n                final long savedOrdinal = in.readLong();\n                final boolean hasWorkToDo = in.readBoolean();// must skip \"has-work-to-do\" flag\n                fsState.load(in, pd.getModel(), pd.getBuildRootIndex());\n                data.setFsEventOrdinal(savedOrdinal);\n                data.setHasHasWorkToDo(hasWorkToDo);\n              }\n            }\n            finally {\n              in.close();\n            }\n          }\n          catch (FileNotFoundException ignored) {\n          }\n          catch (IOException e) {\n            LOG.info(\"Error pre-loading FS state\", e);\n            fsState.clearAll();\n          }\n\n          // preloading target configurations\n          final BuildTargetsState targetsState = pd.getTargetsState();\n          for (BuildTarget<?> target : pd.getBuildTargetIndex().getAllTargets()) {\n            targetsState.getTargetConfiguration(target);\n          }\n\n          BuilderRegistry.getInstance();\n\n          LOG.info(\"Pre-loaded process ready in \" + (System.currentTimeMillis() - processStart) + \" ms\");\n        }\n        catch (Throwable e) {\n          LOG.info(\"Failed to pre-load project \" + projectPathToPreload, e);\n          // just failed to preload the project, the situation will be handled later, when real build starts\n        }\n      }\n      else if (projectPathToPreload != null || globalsPathToPreload != null){\n        LOG.info(\"Skipping project pre-loading step: both paths to project configuration files and path to global settings must be specified\");\n      }\n      future.channel().writeAndFlush(CmdlineProtoUtil.toMessage(sessionId, CmdlineProtoUtil.createParamRequest()));\n    }\n    else {\n      printErrorAndExit(host, port, future.cause());\n    }\n  }\n\n  private static void printErrorAndExit(String host, int port, Throwable reason) {\n    System.err.println(\"Error connecting to \" + host + \":\" + port + \"; reason: \" + (reason != null ? reason.getMessage() : \"unknown\"));\n    if (reason != null) {\n      reason.printStackTrace(System.err);\n    }\n    System.err.println(\"Exiting.\");\n    System.exit(-1);\n  }\n\n  private static class MyMessageHandler extends SimpleChannelInboundHandler<CmdlineRemoteProto.Message> {\n    private final UUID mySessionId;\n    private volatile BuildSession mySession;\n\n    private MyMessageHandler(UUID sessionId) {\n      mySessionId = sessionId;\n    }\n\n    @Override\n    public void channelRead0(final ChannelHandlerContext context, CmdlineRemoteProto.Message message) throws Exception {\n      final CmdlineRemoteProto.Message.Type type = message.getType();\n      final Channel channel = context.channel();\n\n      if (type == CmdlineRemoteProto.Message.Type.CONTROLLER_MESSAGE) {\n        final CmdlineRemoteProto.Message.ControllerMessage controllerMessage = message.getControllerMessage();\n        switch (controllerMessage.getType()) {\n\n          case BUILD_PARAMETERS: {\n            if (mySession == null) {\n              final CmdlineRemoteProto.Message.ControllerMessage.FSEvent delta = controllerMessage.hasFsEvent()? controllerMessage.getFsEvent() : null;\n              final BuildSession session = new BuildSession(mySessionId, channel, controllerMessage.getParamsMessage(), delta, ourPreloadedData);\n              mySession = session;\n              SharedThreadPool.getInstance().executeOnPooledThread(new Runnable() {\n                @Override\n                public void run() {\n                  //noinspection finally\n                  try {\n                    try {\n                      session.run();\n                    }\n                    finally {\n                      channel.close();\n                    }\n                  }\n                  finally {\n                    System.exit(0);\n                  }\n                }\n              });\n            }\n            else {\n              LOG.info(\"Cannot start another build session because one is already running\");\n            }\n            return;\n          }\n\n          case FS_EVENT: {\n            final BuildSession session = mySession;\n            if (session != null) {\n              session.processFSEvent(controllerMessage.getFsEvent());\n            }\n            return;\n          }\n\n          case CONSTANT_SEARCH_RESULT: {\n            final BuildSession session = mySession;\n            if (session != null) {\n              session.processConstantSearchResult(controllerMessage.getConstantSearchResult());\n            }\n            return;\n          }\n\n          case CANCEL_BUILD_COMMAND: {\n            final BuildSession session = mySession;\n            if (session != null) {\n              session.cancel();\n            }\n            else {\n              LOG.info(\"Build canceled, but no build session is running. Exiting.\");\n              try {\n                final CmdlineRemoteProto.Message.BuilderMessage canceledEvent = CmdlineProtoUtil\n                  .createBuildCompletedEvent(\"build completed\", CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.Status.CANCELED);\n                channel.writeAndFlush(CmdlineProtoUtil.toMessage(mySessionId, canceledEvent)).await();\n                channel.close();\n              }\n              catch (Throwable e) {\n                LOG.info(e);\n              }\n              Thread.interrupted(); // to clear 'interrupted' flag\n              final PreloadedData preloaded = ourPreloadedData;\n              final ProjectDescriptor pd = preloaded != null? preloaded.getProjectDescriptor() : null;\n              if (pd != null) {\n                pd.release();\n              }\n              System.exit(0);\n            }\n            return;\n          }\n        }\n      }\n\n      channel.writeAndFlush(\n        CmdlineProtoUtil.toMessage(mySessionId, CmdlineProtoUtil.createFailure(\"Unsupported message type: \" + type.name(), null)));\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext context) throws Exception {\n      try {\n        super.channelInactive(context);\n      }\n      finally {\n        new Thread(\"Shutdown thread\") {\n          @Override\n          public void run() {\n            //noinspection finally\n            try {\n              ourEventLoopGroup.shutdownGracefully(0, 15, TimeUnit.SECONDS);\n            }\n            finally {\n              System.exit(0);\n            }\n          }\n        }.start();\n      }\n    }\n  }\n\n  private static void initLoggers() {\n    try {\n      final String logDir = System.getProperty(GlobalOptions.LOG_DIR_OPTION, null);\n      final File configFile = logDir != null? new File(logDir, LOG_CONFIG_FILE_NAME) : new File(LOG_CONFIG_FILE_NAME);\n      ensureLogConfigExists(configFile);\n      String text = FileUtil.loadFile(configFile);\n      final String logFile = logDir != null? new File(logDir, LOG_FILE_NAME).getAbsolutePath() : LOG_FILE_NAME;\n      text = StringUtil.replace(text, LOG_FILE_MACRO, StringUtil.replace(logFile, \"\\\\\", \"\\\\\\\\\"));\n      PropertyConfigurator.configure(new ByteArrayInputStream(text.getBytes(\"UTF-8\")));\n    }\n    catch (IOException e) {\n      System.err.println(\"Failed to configure logging: \");\n      //noinspection UseOfSystemOutOrSystemErr\n      e.printStackTrace(System.err);\n    }\n\n    Logger.setFactory(MyLoggerFactory.class);\n  }\n\n  private static void ensureLogConfigExists(final File logConfig) throws IOException {\n    if (!logConfig.exists()) {\n      FileUtil.createIfDoesntExist(logConfig);\n      @SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n      final InputStream in = BuildMain.class.getResourceAsStream(\"/\" + DEFAULT_LOGGER_CONFIG);\n      if (in != null) {\n        try {\n          final FileOutputStream out = new FileOutputStream(logConfig);\n          try {\n            FileUtil.copy(in, out);\n          }\n          finally {\n            out.close();\n          }\n        }\n        finally {\n          in.close();\n        }\n      }\n    }\n  }\n\n  private static class MyLoggerFactory implements Logger.Factory {\n    @Override\n    public Logger getLoggerInstance(String category) {\n      final org.apache.log4j.Logger logger = org.apache.log4j.Logger.getLogger(category);\n\n      return new Logger() {\n        @Override\n        public boolean isDebugEnabled() {\n          return logger.isDebugEnabled();\n        }\n\n        @Override\n        public void debug(@NonNls String message) {\n          logger.debug(message);\n        }\n\n        @Override\n        public void debug(@Nullable Throwable t) {\n          logger.debug(\"\", t);\n        }\n\n        @Override\n        public void debug(@NonNls String message, @Nullable Throwable t) {\n          logger.debug(message, t);\n        }\n\n        @Override\n        public void error(@NonNls String message, @Nullable Throwable t, @NotNull @NonNls String... details) {\n          logger.error(message, t);\n        }\n\n        @Override\n        public void info(@NonNls String message) {\n          logger.info(message);\n        }\n\n        @Override\n        public void info(@NonNls String message, @Nullable Throwable t) {\n          logger.info(message, t);\n        }\n\n        @Override\n        public void warn(@NonNls String message, @Nullable Throwable t) {\n          logger.warn(message, t);\n        }\n\n        @Override\n        public void setLevel(Level level) {\n          logger.setLevel(level);\n        }\n      };\n    }\n  }\n}\n",
    "ID_8": "public class BuildMain {\n  private static final String PRELOAD_PROJECT_PATH = \"preload.project.path\";\n  private static final String PRELOAD_CONFIG_PATH = \"preload.config.path\";\n  \n  private static final String LOG_CONFIG_FILE_NAME = \"build-log.properties\";\n  private static final String LOG_FILE_NAME = \"build.log\";\n  private static final String DEFAULT_LOGGER_CONFIG = \"defaultLogConfig.properties\";\n  private static final String LOG_FILE_MACRO = \"$LOG_FILE_PATH$\";\n  private static final Logger LOG;\n  static {\n    initLoggers();\n    LOG = Logger.getInstance(\"#org.jetbrains.jps.cmdline.BuildMain\");\n  }\n\n  private static final int HOST_ARG = 0;\n  private static final int PORT_ARG = HOST_ARG + 1;\n  private static final int SESSION_ID_ARG = PORT_ARG + 1;\n  private static final int SYSTEM_DIR_ARG = SESSION_ID_ARG + 1;\n\n  private static NioEventLoopGroup ourEventLoopGroup;\n  @Nullable \n  private static PreloadedData ourPreloadedData;\n\n  public static void main(String[] args){\n    final long processStart = System.currentTimeMillis();\n    final String startMessage = \"Build process started. Classpath: \" + System.getProperty(\"java.class.path\");\n    System.out.println(startMessage);\n    LOG.info(startMessage);\n    \n    final String host = args[HOST_ARG];\n    final int port = Integer.parseInt(args[PORT_ARG]);\n    final UUID sessionId = UUID.fromString(args[SESSION_ID_ARG]);\n    @SuppressWarnings(\"ConstantConditions\")\n    final File systemDir = new File(FileUtil.toCanonicalPath(args[SYSTEM_DIR_ARG]));\n    Utils.setSystemRoot(systemDir);\n\n    final long connectStart = System.currentTimeMillis();\n    // IDEA-123132, let's try again\n    for (int attempt = 0; attempt < 3; attempt++) {\n      try {\n        ourEventLoopGroup = new NioEventLoopGroup(1, SharedThreadPool.getInstance());\n        break;\n      }\n      catch (IllegalStateException e) {\n        if (attempt == 2) {\n          printErrorAndExit(host, port, e);\n          return;\n        }\n        else {\n          LOG.warn(\"Cannot create event loop, attempt #\" + attempt, e);\n          try {\n            //noinspection BusyWait\n            Thread.sleep(10 * (attempt + 1));\n          }\n          catch (InterruptedException ignored) {\n          }\n        }\n      }\n    }\n\n    final Bootstrap bootstrap = new Bootstrap().group(ourEventLoopGroup).channel(NioSocketChannel.class).handler(new ChannelInitializer() {\n      @Override\n      protected void initChannel(Channel channel) throws Exception {\n        channel.pipeline().addLast(new ProtobufVarint32FrameDecoder(),\n                                   new ProtobufDecoder(CmdlineRemoteProto.Message.getDefaultInstance()),\n                                   new ProtobufVarint32LengthFieldPrepender(),\n                                   new ProtobufEncoder(),\n                                   new MyMessageHandler(sessionId));\n      }\n    }).option(ChannelOption.TCP_NODELAY, true).option(ChannelOption.SO_KEEPALIVE, true);\n\n    final ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port)).awaitUninterruptibly();\n\n    \n    final boolean success = future.isSuccess();\n    if (success) {\n      LOG.info(\"Connection to IDE established in \" + (System.currentTimeMillis() - connectStart) + \" ms\");\n\n      final String projectPathToPreload = System.getProperty(PRELOAD_PROJECT_PATH, null);\n      final String globalsPathToPreload = System.getProperty(PRELOAD_CONFIG_PATH, null); \n      if (projectPathToPreload != null && globalsPathToPreload != null) {\n        final PreloadedData data = new PreloadedData();\n        ourPreloadedData = data;\n        try {\n          FileSystemUtil.getAttributes(projectPathToPreload); // this will pre-load all FS optimizations\n\n          final BuildRunner runner = new BuildRunner(new JpsModelLoaderImpl(projectPathToPreload, globalsPathToPreload, null));\n          data.setRunner(runner);\n\n          final File dataStorageRoot = Utils.getDataStorageRoot(projectPathToPreload);\n          final BuildFSState fsState = new BuildFSState(false);\n          final ProjectDescriptor pd = runner.load(new MessageHandler() {\n            @Override\n            public void processMessage(BuildMessage msg) {\n              data.addMessage(msg);\n            }\n          }, dataStorageRoot, fsState);\n          data.setProjectDescriptor(pd);\n          \n          try {\n            final File fsStateFile = new File(dataStorageRoot, BuildSession.FS_STATE_FILE);\n            final DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream(fsStateFile)));\n            try {\n              final int version = in.readInt();\n              if (version == BuildFSState.VERSION) {\n                final long savedOrdinal = in.readLong();\n                final boolean hasWorkToDo = in.readBoolean();// must skip \"has-work-to-do\" flag\n                fsState.load(in, pd.getModel(), pd.getBuildRootIndex());\n                data.setFsEventOrdinal(savedOrdinal);\n                data.setHasHasWorkToDo(hasWorkToDo);\n              }\n            }\n            finally {\n              in.close();\n            }\n          }\n          catch (FileNotFoundException ignored) {\n          }\n          catch (IOException e) {\n            LOG.info(\"Error pre-loading FS state\", e);\n            fsState.clearAll();\n          }\n\n          // preloading target configurations\n          final BuildTargetsState targetsState = pd.getTargetsState();\n          for (BuildTarget<?> target : pd.getBuildTargetIndex().getAllTargets()) {\n            targetsState.getTargetConfiguration(target);\n          }\n\n          BuilderRegistry.getInstance();\n\n          LOG.info(\"Pre-loaded process ready in \" + (System.currentTimeMillis() - processStart) + \" ms\");\n        }\n        catch (Throwable e) {\n          LOG.info(\"Failed to pre-load project \" + projectPathToPreload, e);\n          // just failed to preload the project, the situation will be handled later, when real build starts\n        }\n      }\n      else if (projectPathToPreload != null || globalsPathToPreload != null){\n        LOG.info(\"Skipping project pre-loading step: both paths to project configuration files and path to global settings must be specified\");\n      }\n      future.channel().writeAndFlush(CmdlineProtoUtil.toMessage(sessionId, CmdlineProtoUtil.createParamRequest()));\n    }\n    else {\n      printErrorAndExit(host, port, future.cause());\n    }\n  }\n\n  private static void printErrorAndExit(String host, int port, Throwable reason) {\n    System.err.println(\"Error connecting to \" + host + \":\" + port + \"; reason: \" + (reason != null ? reason.getMessage() : \"unknown\"));\n    if (reason != null) {\n      reason.printStackTrace(System.err);\n    }\n    System.err.println(\"Exiting.\");\n    System.exit(-1);\n  }\n\n  private static class MyMessageHandler extends SimpleChannelInboundHandler<CmdlineRemoteProto.Message> {\n    private final UUID mySessionId;\n    private volatile BuildSession mySession;\n\n    private MyMessageHandler(UUID sessionId) {\n      mySessionId = sessionId;\n    }\n\n    @Override\n    public void channelRead0(final ChannelHandlerContext context, CmdlineRemoteProto.Message message) throws Exception {\n      final CmdlineRemoteProto.Message.Type type = message.getType();\n      final Channel channel = context.channel();\n\n      if (type == CmdlineRemoteProto.Message.Type.CONTROLLER_MESSAGE) {\n        final CmdlineRemoteProto.Message.ControllerMessage controllerMessage = message.getControllerMessage();\n        switch (controllerMessage.getType()) {\n\n          case BUILD_PARAMETERS: {\n            if (mySession == null) {\n              final CmdlineRemoteProto.Message.ControllerMessage.FSEvent delta = controllerMessage.hasFsEvent()? controllerMessage.getFsEvent() : null;\n              final BuildSession session = new BuildSession(mySessionId, channel, controllerMessage.getParamsMessage(), delta, ourPreloadedData);\n              mySession = session;\n              SharedThreadPool.getInstance().executeOnPooledThread(new Runnable() {\n                @Override\n                public void run() {\n                  //noinspection finally\n                  try {\n                    try {\n                      session.run();\n                    }\n                    finally {\n                      channel.close();\n                    }\n                  }\n                  finally {\n                    System.exit(0);\n                  }\n                }\n              });\n            }\n            else {\n              LOG.info(\"Cannot start another build session because one is already running\");\n            }\n            return;\n          }\n\n          case FS_EVENT: {\n            final BuildSession session = mySession;\n            if (session != null) {\n              session.processFSEvent(controllerMessage.getFsEvent());\n            }\n            return;\n          }\n\n          case CONSTANT_SEARCH_RESULT: {\n            final BuildSession session = mySession;\n            if (session != null) {\n              session.processConstantSearchResult(controllerMessage.getConstantSearchResult());\n            }\n            return;\n          }\n\n          case CANCEL_BUILD_COMMAND: {\n            final BuildSession session = mySession;\n            if (session != null) {\n              session.cancel();\n            }\n            else {\n              LOG.info(\"Build canceled, but no build session is running. Exiting.\");\n              try {\n                final CmdlineRemoteProto.Message.BuilderMessage canceledEvent = CmdlineProtoUtil\n                  .createBuildCompletedEvent(\"build completed\", CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.Status.CANCELED);\n                channel.writeAndFlush(CmdlineProtoUtil.toMessage(mySessionId, canceledEvent)).await();\n                channel.close();\n              }\n              catch (Throwable e) {\n                LOG.info(e);\n              }\n              Thread.interrupted(); // to clear 'interrupted' flag\n              final PreloadedData preloaded = ourPreloadedData;\n              final ProjectDescriptor pd = preloaded != null? preloaded.getProjectDescriptor() : null;\n              if (pd != null) {\n                pd.release();\n              }\n              System.exit(0);\n            }\n            return;\n          }\n        }\n      }\n\n      channel.writeAndFlush(\n        CmdlineProtoUtil.toMessage(mySessionId, CmdlineProtoUtil.createFailure(\"Unsupported message type: \" + type.name(), null)));\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext context) throws Exception {\n      try {\n        super.channelInactive(context);\n      }\n      finally {\n        new Thread(\"Shutdown thread\") {\n          @Override\n          public void run() {\n            //noinspection finally\n            try {\n              ourEventLoopGroup.shutdownGracefully(0, 15, TimeUnit.SECONDS);\n            }\n            finally {\n              System.exit(0);\n            }\n          }\n        }.start();\n      }\n    }\n  }\n\n  private static void initLoggers() {\n    try {\n      final String logDir = System.getProperty(GlobalOptions.LOG_DIR_OPTION, null);\n      final File configFile = logDir != null? new File(logDir, LOG_CONFIG_FILE_NAME) : new File(LOG_CONFIG_FILE_NAME);\n      ensureLogConfigExists(configFile);\n      String text = FileUtil.loadFile(configFile);\n      final String logFile = logDir != null? new File(logDir, LOG_FILE_NAME).getAbsolutePath() : LOG_FILE_NAME;\n      text = StringUtil.replace(text, LOG_FILE_MACRO, StringUtil.replace(logFile, \"\\\\\", \"\\\\\\\\\"));\n      PropertyConfigurator.configure(new ByteArrayInputStream(text.getBytes(\"UTF-8\")));\n    }\n    catch (IOException e) {\n      System.err.println(\"Failed to configure logging: \");\n      //noinspection UseOfSystemOutOrSystemErr\n      e.printStackTrace(System.err);\n    }\n\n    Logger.setFactory(MyLoggerFactory.class);\n  }\n\n  private static void ensureLogConfigExists(final File logConfig) throws IOException {\n    if (!logConfig.exists()) {\n      FileUtil.createIfDoesntExist(logConfig);\n      @SuppressWarnings(\"IOResourceOpenedButNotSafelyClosed\")\n      final InputStream in = BuildMain.class.getResourceAsStream(\"/\" + DEFAULT_LOGGER_CONFIG);\n      if (in != null) {\n        try {\n          final FileOutputStream out = new FileOutputStream(logConfig);\n          try {\n            FileUtil.copy(in, out);\n          }\n          finally {\n            out.close();\n          }\n        }\n        finally {\n          in.close();\n        }\n      }\n    }\n  }\n\n  private static class MyLoggerFactory implements Logger.Factory {\n    @Override\n    public Logger getLoggerInstance(String category) {\n      final org.apache.log4j.Logger logger = org.apache.log4j.Logger.getLogger(category);\n\n      return new Logger() {\n        @Override\n        public boolean isDebugEnabled() {\n          return logger.isDebugEnabled();\n        }\n\n        @Override\n        public void debug(@NonNls String message) {\n          logger.debug(message);\n        }\n\n        @Override\n        public void debug(@Nullable Throwable t) {\n          logger.debug(\"\", t);\n        }\n\n        @Override\n        public void debug(@NonNls String message, @Nullable Throwable t) {\n          logger.debug(message, t);\n        }\n\n        @Override\n        public void error(@NonNls String message, @Nullable Throwable t, @NotNull @NonNls String... details) {\n          logger.error(message, t);\n        }\n\n        @Override\n        public void info(@NonNls String message) {\n          logger.info(message);\n        }\n\n        @Override\n        public void info(@NonNls String message, @Nullable Throwable t) {\n          logger.info(message, t);\n        }\n\n        @Override\n        public void warn(@NonNls String message, @Nullable Throwable t) {\n          logger.warn(message, t);\n        }\n\n        @Override\n        public void setLevel(Level level) {\n          logger.setLevel(level);\n        }\n      };\n    }\n  }\n}\n",
    "ID_9": "public class GaugeImplTest {\n\n    private MetricsRegistryImpl metricsRegistry;\n\n    @Before\n    public void setup() {\n        metricsRegistry = new MetricsRegistryImpl(Logger.getLogger(MetricsRegistryImpl.class));\n    }\n\n    class SomeObject {\n        @Probe\n        long longField = 10;\n        @Probe\n        double doubleField = 10.8;\n    }\n\n    @Test\n    public void getName() {\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        String actual = gauge.getName();\n\n        assertEquals(\"foo\", actual);\n    }\n\n    //  ============ getLong ===========================\n\n    @Test\n    public void readLong_whenNoInput() {\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        long actual = gauge.readLong();\n\n        assertEquals(0, actual);\n    }\n\n    @Test\n    public void readLong_whenDoubleGauge() {\n        metricsRegistry.register(this, \"foo\", new DoubleProbe<GaugeImplTest>() {\n            @Override\n            public double get(GaugeImplTest source) throws Exception {\n                return 10;\n            }\n        });\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        long actual = gauge.readLong();\n\n        assertEquals(10, actual);\n    }\n\n    @Test\n    public void readLong_whenLongGauge() {\n        metricsRegistry.register(this, \"foo\", new LongProbe() {\n            @Override\n            public long get(Object o) throws Exception {\n                return 10;\n            }\n        });\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n        assertEquals(10, gauge.readLong());\n    }\n\n    @Test\n    public void readLong_whenExceptionalInput() {\n        metricsRegistry.register(this, \"foo\", new LongProbe() {\n            @Override\n            public long get(Object o) {\n                throw new RuntimeException();\n            }\n        });\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        long actual = gauge.readLong();\n\n        assertEquals(0, actual);\n    }\n\n    @Test\n    public void readLong_whenLongGaugeField() {\n        SomeObject someObject = new SomeObject();\n        metricsRegistry.scanAndRegister(someObject, \"foo\");\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo.longField\");\n        assertEquals(10, gauge.readLong());\n    }\n\n    @Test\n    public void readLong_whenDoubleGaugeField() {\n        SomeObject someObject = new SomeObject();\n        metricsRegistry.scanAndRegister(someObject, \"foo\");\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo.doubleField\");\n        assertEquals(round(someObject.doubleField), gauge.readLong());\n    }\n\n    // ============ readDouble ===========================\n\n    @Test\n    public void readDouble_whenNoMetricInput() {\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        double actual = gauge.readDouble();\n\n        assertEquals(0, actual, 0.1);\n    }\n\n    @Test\n    public void readDouble_whenExceptionalInput() {\n        metricsRegistry.register(this, \"foo\", new DoubleProbe() {\n            @Override\n            public double get(Object o) {\n                throw new RuntimeException();\n            }\n        });\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        double actual = gauge.readDouble();\n\n        assertEquals(0, actual, 0.1);\n    }\n\n    @Test\n    public void readDouble_whenDoubleGauge() {\n        metricsRegistry.register(this, \"foo\", new DoubleProbe() {\n            @Override\n            public double get(Object o) {\n                return 10;\n            }\n        });\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        double actual = gauge.readDouble();\n\n        assertEquals(10, actual, 0.1);\n    }\n\n    @Test\n    public void readDouble_whenLongGauge() {\n        metricsRegistry.register(this, \"foo\", new LongProbe() {\n            @Override\n            public long get(Object o) throws Exception {\n                return 10;\n            }\n        });\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        double actual = gauge.readDouble();\n\n        assertEquals(10, actual, 0.1);\n    }\n\n    @Test\n    public void readDouble_whenLongGaugeField() {\n        SomeObject someObject = new SomeObject();\n        metricsRegistry.scanAndRegister(someObject, \"foo\");\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo.longField\");\n        assertEquals(someObject.longField, gauge.readDouble(), 0.1);\n    }\n\n    @Test\n    public void readDouble_whenDoubleGaugeField() {\n        SomeObject someObject = new SomeObject();\n        metricsRegistry.scanAndRegister(someObject, \"foo\");\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo.doubleField\");\n        assertEquals(someObject.doubleField, gauge.readDouble(), 0.1);\n    }\n\n    // ====================== render ===================================\n\n    @Test\n    public void render_whenDoubleGauge() {\n        metricsRegistry.register(this, \"foo\", new DoubleProbe() {\n            @Override\n            public double get(Object o) {\n                return 10;\n            }\n        });\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n        StringBuilder sb = new StringBuilder();\n\n        gauge.render(sb);\n\n        assertEquals(\"foo=10.0\", sb.toString());\n    }\n\n    @Test\n    public void render_whenLongGauge() {\n        metricsRegistry.register(this, \"foo\", new LongProbe() {\n            @Override\n            public long get(Object o) {\n                return 10;\n            }\n        });\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n        StringBuilder sb = new StringBuilder();\n\n        gauge.render(sb);\n\n        assertEquals(\"foo=10\", sb.toString());\n    }\n\n    @Test\n    public void render_whenNoInput() {\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n        StringBuilder sb = new StringBuilder();\n\n        gauge.render(sb);\n\n        assertEquals(\"foo=NA\", sb.toString());\n    }\n\n    @Test\n    public void render_whenNoSource() {\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n        StringBuilder sb = new StringBuilder();\n\n        gauge.render(sb);\n\n        assertEquals(\"foo=NA\", sb.toString());\n    }\n\n    @Test\n    public void render_whenDoubleField() {\n        SomeObject someObject = new SomeObject();\n        metricsRegistry.scanAndRegister(someObject, \"foo\");\n        Gauge gauge = metricsRegistry.getGauge(\"foo.doubleField\");\n        StringBuilder sb = new StringBuilder();\n\n        gauge.render(sb);\n        assertEquals(\"foo.doubleField=10.8\", sb.toString());\n    }\n\n    @Test\n    public void render_whenLongField() {\n        SomeObject someObject = new SomeObject();\n        metricsRegistry.scanAndRegister(someObject, \"foo\");\n        Gauge gauge = metricsRegistry.getGauge(\"foo.longField\");\n        StringBuilder sb = new StringBuilder();\n\n        gauge.render(sb);\n        assertEquals(\"foo.longField=10\", sb.toString());\n    }\n\n    @Test\n    public void render_whenException() {\n        metricsRegistry.register(this, \"foo\", new LongProbe() {\n            @Override\n            public long get(Object o) {\n                throw new RuntimeException();\n            }\n        });\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n        StringBuilder sb = new StringBuilder();\n\n        gauge.render(sb);\n\n        assertEquals(\"foo=NA\", sb.toString());\n    }\n}",
    "ID_10": "public class GaugeImplTest {\n\n    private MetricsRegistryImpl metricsRegistry;\n\n    @Before\n    public void setup() {\n        metricsRegistry = new MetricsRegistryImpl(Logger.getLogger(MetricsRegistryImpl.class));\n    }\n\n    class SomeObject {\n        @Probe\n        long longField = 10;\n        @Probe\n        double doubleField = 10.8;\n    }\n\n    @Test\n    public void getName() {\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        String actual = gauge.getName();\n\n        assertEquals(\"foo\", actual);\n    }\n\n    //  ============ getLong ===========================\n\n    @Test\n    public void readLong_whenNoInput() {\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        long actual = gauge.readLong();\n\n        assertEquals(0, actual);\n    }\n\n    @Test\n    public void readLong_whenDoubleGauge() {\n        metricsRegistry.register(this, \"foo\", new DoubleProbe<GaugeImplTest>() {\n            @Override\n            public double get(GaugeImplTest source) throws Exception {\n                return 10;\n            }\n        });\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        long actual = gauge.readLong();\n\n        assertEquals(10, actual);\n    }\n\n    @Test\n    public void readLong_whenLongGauge() {\n        metricsRegistry.register(this, \"foo\", new LongProbe() {\n            @Override\n            public long get(Object o) throws Exception {\n                return 10;\n            }\n        });\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n        assertEquals(10, gauge.readLong());\n    }\n\n    @Test\n    public void readLong_whenExceptionalInput() {\n        metricsRegistry.register(this, \"foo\", new LongProbe() {\n            @Override\n            public long get(Object o) {\n                throw new RuntimeException();\n            }\n        });\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        long actual = gauge.readLong();\n\n        assertEquals(0, actual);\n    }\n\n    @Test\n    public void readLong_whenLongGaugeField() {\n        SomeObject someObject = new SomeObject();\n        metricsRegistry.scanAndRegister(someObject, \"foo\");\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo.longField\");\n        assertEquals(10, gauge.readLong());\n    }\n\n    @Test\n    public void readLong_whenDoubleGaugeField() {\n        SomeObject someObject = new SomeObject();\n        metricsRegistry.scanAndRegister(someObject, \"foo\");\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo.doubleField\");\n        assertEquals(round(someObject.doubleField), gauge.readLong());\n    }\n\n    // ============ readDouble ===========================\n\n    @Test\n    public void readDouble_whenNoMetricInput() {\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        double actual = gauge.readDouble();\n\n        assertEquals(0, actual, 0.1);\n    }\n\n    @Test\n    public void readDouble_whenExceptionalInput() {\n        metricsRegistry.register(this, \"foo\", new DoubleProbe() {\n            @Override\n            public double get(Object o) {\n                throw new RuntimeException();\n            }\n        });\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        double actual = gauge.readDouble();\n\n        assertEquals(0, actual, 0.1);\n    }\n\n    @Test\n    public void readDouble_whenDoubleGauge() {\n        metricsRegistry.register(this, \"foo\", new DoubleProbe() {\n            @Override\n            public double get(Object o) {\n                return 10;\n            }\n        });\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        double actual = gauge.readDouble();\n\n        assertEquals(10, actual, 0.1);\n    }\n\n    @Test\n    public void readDouble_whenLongGauge() {\n        metricsRegistry.register(this, \"foo\", new LongProbe() {\n            @Override\n            public long get(Object o) throws Exception {\n                return 10;\n            }\n        });\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n\n        double actual = gauge.readDouble();\n\n        assertEquals(10, actual, 0.1);\n    }\n\n    @Test\n    public void readDouble_whenLongGaugeField() {\n        SomeObject someObject = new SomeObject();\n        metricsRegistry.scanAndRegister(someObject, \"foo\");\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo.longField\");\n        assertEquals(someObject.longField, gauge.readDouble(), 0.1);\n    }\n\n    @Test\n    public void readDouble_whenDoubleGaugeField() {\n        SomeObject someObject = new SomeObject();\n        metricsRegistry.scanAndRegister(someObject, \"foo\");\n\n        Gauge gauge = metricsRegistry.getGauge(\"foo.doubleField\");\n        assertEquals(someObject.doubleField, gauge.readDouble(), 0.1);\n    }\n\n    // ====================== render ===================================\n\n    @Test\n    public void render_whenDoubleGauge() {\n        metricsRegistry.register(this, \"foo\", new DoubleProbe() {\n            @Override\n            public double get(Object o) {\n                return 10;\n            }\n        });\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n        StringBuilder sb = new StringBuilder();\n\n        gauge.render(sb);\n\n        assertEquals(\"foo=10.0\", sb.toString());\n    }\n\n    @Test\n    public void render_whenLongGauge() {\n        metricsRegistry.register(this, \"foo\", new LongProbe() {\n            @Override\n            public long get(Object o) {\n                return 10;\n            }\n        });\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n        StringBuilder sb = new StringBuilder();\n\n        gauge.render(sb);\n\n        assertEquals(\"foo=10\", sb.toString());\n    }\n\n    @Test\n    public void render_whenNoInput() {\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n        StringBuilder sb = new StringBuilder();\n\n        gauge.render(sb);\n\n        assertEquals(\"foo=NA\", sb.toString());\n    }\n\n    @Test\n    public void render_whenNoSource() {\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n        StringBuilder sb = new StringBuilder();\n\n        gauge.render(sb);\n\n        assertEquals(\"foo=NA\", sb.toString());\n    }\n\n    @Test\n    public void render_whenDoubleField() {\n        SomeObject someObject = new SomeObject();\n        metricsRegistry.scanAndRegister(someObject, \"foo\");\n        Gauge gauge = metricsRegistry.getGauge(\"foo.doubleField\");\n        StringBuilder sb = new StringBuilder();\n\n        gauge.render(sb);\n        assertEquals(\"foo.doubleField=10.8\", sb.toString());\n    }\n\n    @Test\n    public void render_whenLongField() {\n        SomeObject someObject = new SomeObject();\n        metricsRegistry.scanAndRegister(someObject, \"foo\");\n        Gauge gauge = metricsRegistry.getGauge(\"foo.longField\");\n        StringBuilder sb = new StringBuilder();\n\n        gauge.render(sb);\n        assertEquals(\"foo.longField=10\", sb.toString());\n    }\n\n    @Test\n    public void render_whenException() {\n        metricsRegistry.register(this, \"foo\", new LongProbe() {\n            @Override\n            public long get(Object o) {\n                throw new RuntimeException();\n            }\n        });\n        Gauge gauge = metricsRegistry.getGauge(\"foo\");\n        StringBuilder sb = new StringBuilder();\n\n        gauge.render(sb);\n\n        assertEquals(\"foo=NA\", sb.toString());\n    }\n}",
    "ID_11": "public class HealthMonitor extends Thread {\n\n    private static final String[] UNITS = new String[]{\"\", \"K\", \"M\", \"G\", \"T\", \"P\", \"E\"};\n    private static final double PERCENTAGE_MULTIPLIER = 100d;\n    private static final double THRESHOLD = 70;\n\n    private final ILogger logger;\n    private final Node node;\n    private final Runtime runtime;\n    private final HealthMonitorLevel logLevel;\n    private final int delaySeconds;\n    private final ClusterServiceImpl clusterService;\n    private final ExecutionService executionService;\n    private final EventService eventService;\n    private final InternalOperationService operationService;\n    private final ProxyService proxyService;\n    private final ConnectionManager connectionManager;\n    private final ClientEngineImpl clientEngine;\n    private final ThreadMXBean threadMxBean;\n\n    public HealthMonitor(HazelcastInstanceImpl hazelcastInstance, HealthMonitorLevel logLevel, int delaySeconds) {\n        super(hazelcastInstance.node.getHazelcastThreadGroup().getInternalThreadGroup(),\n                hazelcastInstance.node.getHazelcastThreadGroup().getThreadNamePrefix(\"HealthMonitor\"));\n        setDaemon(true);\n\n        this.node = hazelcastInstance.node;\n        this.logger = node.getLogger(HealthMonitor.class);\n        this.runtime = Runtime.getRuntime();\n        this.logLevel = logLevel;\n        this.delaySeconds = delaySeconds;\n        this.threadMxBean = ManagementFactory.getThreadMXBean();\n        this.clusterService = node.getClusterService();\n        this.executionService = node.nodeEngine.getExecutionService();\n        this.eventService = node.nodeEngine.getEventService();\n        this.operationService = node.nodeEngine.getOperationService();\n        this.proxyService = node.nodeEngine.getProxyService();\n        this.clientEngine = node.clientEngine;\n        this.connectionManager = node.connectionManager;\n    }\n\n    @Override\n    public void run() {\n        if (logLevel == HealthMonitorLevel.OFF) {\n            return;\n        }\n\n        try {\n            while (node.isActive()) {\n                HealthMetrics metrics;\n                switch (logLevel) {\n                    case NOISY:\n                        metrics = new HealthMetrics();\n                        logger.log(Level.INFO, metrics.toString());\n                        break;\n                    case SILENT:\n                        metrics = new HealthMetrics();\n                        if (metrics.exceedsThreshold()) {\n                            logger.log(Level.INFO, metrics.toString());\n                        }\n                        break;\n                    default:\n                        throw new IllegalStateException(\"unrecognized logLevel:\" + logLevel);\n                }\n\n                try {\n                    Thread.sleep(TimeUnit.SECONDS.toMillis(delaySeconds));\n                } catch (InterruptedException e) {\n                    return;\n                }\n            }\n        } catch (OutOfMemoryError e) {\n            OutOfMemoryErrorDispatcher.onOutOfMemory(e);\n        }\n    }\n\n    /**\n     * Health metrics to be logged under load.\n     */\n    private class HealthMetrics {\n        private final long memoryFree;\n        private final long memoryTotal;\n        private final long memoryUsed;\n        private final long memoryMax;\n        private final double memoryUsedOfTotalPercentage;\n        private final double memoryUsedOfMaxPercentage;\n        //following three load variables are always between 0 and 100.\n        private final double processCpuLoad;\n        private final double systemLoadAverage;\n        private final double systemCpuLoad;\n        private final int threadCount;\n        private final int peakThreadCount;\n        private final long clusterTimeDiff;\n        private final int asyncExecutorQueueSize;\n        private final int clientExecutorQueueSize;\n        private final int queryExecutorQueueSize;\n        private final int scheduledExecutorQueueSize;\n        private final int systemExecutorQueueSize;\n        private final int eventQueueSize;\n        private final int pendingInvocationsCount;\n        private final double pendingInvocationsPercentage;\n        private final int operationServiceOperationExecutorQueueSize;\n        private final int operationServiceOperationPriorityExecutorQueueSize;\n        private final int operationServiceOperationResponseQueueSize;\n        private final int runningOperationsCount;\n        private final int remoteOperationsCount;\n        private final int proxyCount;\n        private final int clientEndpointCount;\n        private final int activeConnectionCount;\n        private final int currentClientConnectionCount;\n        private final int connectionCount;\n        private final int ioExecutorQueueSize;\n\n        //CHECKSTYLE:OFF\n        public HealthMetrics() {\n            memoryFree = runtime.freeMemory();\n            memoryTotal = runtime.totalMemory();\n            memoryUsed = memoryTotal - memoryFree;\n            memoryMax = runtime.maxMemory();\n            memoryUsedOfTotalPercentage = PERCENTAGE_MULTIPLIER * memoryUsed / memoryTotal;\n            memoryUsedOfMaxPercentage = PERCENTAGE_MULTIPLIER * memoryUsed / memoryMax;\n            processCpuLoad = readLongAttribute(\"ProcessCpuLoad\", -1L);\n            systemLoadAverage = getSystemLoadAverage();\n            systemCpuLoad = readLongAttribute(\"SystemCpuLoad\", -1L);\n            threadCount = threadMxBean.getThreadCount();\n            peakThreadCount = threadMxBean.getPeakThreadCount();\n            clusterTimeDiff = clusterService.getClusterClock().getClusterTimeDiff();\n            asyncExecutorQueueSize = executionService.getExecutor(ExecutionService.ASYNC_EXECUTOR).getQueueSize();\n            clientExecutorQueueSize = executionService.getExecutor(ExecutionService.CLIENT_EXECUTOR).getQueueSize();\n            queryExecutorQueueSize = executionService.getExecutor(ExecutionService.QUERY_EXECUTOR).getQueueSize();\n            scheduledExecutorQueueSize = executionService.getExecutor(ExecutionService.SCHEDULED_EXECUTOR).getQueueSize();\n            systemExecutorQueueSize = executionService.getExecutor(ExecutionService.SYSTEM_EXECUTOR).getQueueSize();\n            ioExecutorQueueSize = executionService.getExecutor(ExecutionService.IO_EXECUTOR).getQueueSize();\n            eventQueueSize = eventService.getEventQueueSize();\n            operationServiceOperationExecutorQueueSize = operationService.getOperationExecutorQueueSize();\n            operationServiceOperationPriorityExecutorQueueSize = operationService.getPriorityOperationExecutorQueueSize();\n            operationServiceOperationResponseQueueSize = operationService.getResponseQueueSize();\n            runningOperationsCount = operationService.getRunningOperationsCount();\n            remoteOperationsCount = operationService.getRemoteOperationsCount();\n            pendingInvocationsCount = operationService.getPendingInvocationCount();\n            pendingInvocationsPercentage = operationService.getInvocationUsagePercentage();\n            proxyCount = proxyService.getProxyCount();\n            clientEndpointCount = clientEngine.getClientEndpointCount();\n            activeConnectionCount = connectionManager.getActiveConnectionCount();\n            currentClientConnectionCount = connectionManager.getCurrentClientConnections();\n            connectionCount = connectionManager.getConnectionCount();\n        }\n        //CHECKSTYLE:ON\n\n        public boolean exceedsThreshold() {\n            if (memoryUsedOfMaxPercentage > THRESHOLD) {\n                return true;\n            }\n\n            if (processCpuLoad > THRESHOLD) {\n                return true;\n            }\n\n            if (systemCpuLoad > THRESHOLD) {\n                return true;\n            }\n\n            if (pendingInvocationsPercentage > THRESHOLD) {\n                return true;\n            }\n\n            return false;\n        }\n\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"processors=\").append(runtime.availableProcessors()).append(\", \");\n            sb.append(\"physical.memory.total=\").append(numberToUnit(totalPhysicalMemory())).append(\", \");\n            sb.append(\"physical.memory.free=\").append(numberToUnit(freePhysicalMemory())).append(\", \");\n            sb.append(\"swap.space.total=\").append(numberToUnit(totalSwapSpace())).append(\", \");\n            sb.append(\"swap.space.free=\").append(numberToUnit(freeSwapSpace())).append(\", \");\n            sb.append(\"heap.memory.used=\").append(numberToUnit(memoryUsed)).append(\", \");\n            sb.append(\"heap.memory.free=\").append(numberToUnit(memoryFree)).append(\", \");\n            sb.append(\"heap.memory.total=\").append(numberToUnit(memoryTotal)).append(\", \");\n            sb.append(\"heap.memory.max=\").append(numberToUnit(memoryMax)).append(\", \");\n            sb.append(\"heap.memory.used/total=\").append(percentageString(memoryUsedOfTotalPercentage)).append(\", \");\n            sb.append(\"heap.memory.used/max=\").append(percentageString(memoryUsedOfMaxPercentage)).append((\", \"));\n\n            MemoryStats memoryStats = node.getNodeExtension().getMemoryStats();\n            if (memoryStats.getMaxNativeMemory() > 0L) {\n                sb.append(\"native.memory.used=\").append(numberToUnit(memoryStats.getUsedNativeMemory())).append(\", \");\n                sb.append(\"native.memory.free=\").append(numberToUnit(memoryStats.getFreeNativeMemory())).append(\", \");\n                sb.append(\"native.memory.total=\").append(numberToUnit(memoryStats.getCommittedNativeMemory())).append(\", \");\n                sb.append(\"native.memory.max=\").append(numberToUnit(memoryStats.getMaxNativeMemory())).append(\", \");\n            }\n\n            GarbageCollectorStats gcStats = memoryStats.getGCStats();\n            sb.append(\"minor.gc.count=\").append(gcStats.getMinorCollectionCount()).append(\", \");\n            sb.append(\"minor.gc.time=\").append(gcStats.getMinorCollectionTime()).append(\"ms, \");\n            sb.append(\"major.gc.count=\").append(gcStats.getMajorCollectionCount()).append(\", \");\n            sb.append(\"major.gc.time=\").append(gcStats.getMajorCollectionTime()).append(\"ms, \");\n            if (gcStats.getUnknownCollectionCount() > 0) {\n                sb.append(\"unknown.gc.count=\").append(gcStats.getUnknownCollectionCount()).append(\", \");\n                sb.append(\"unknown.gc.time=\").append(gcStats.getUnknownCollectionTime()).append(\"ms, \");\n            }\n\n            sb.append(\"load.process=\").append(format(\"%.2f\", processCpuLoad)).append(\"%, \");\n            sb.append(\"load.system=\").append(format(\"%.2f\", systemCpuLoad)).append(\"%, \");\n            sb.append(\"load.systemAverage=\").append(systemLoadAverage >= 0 ? format(\"%.2f, \", systemLoadAverage) : \"n/a, \");\n            sb.append(\"thread.count=\").append(threadCount).append(\", \");\n            sb.append(\"thread.peakCount=\").append(peakThreadCount).append(\", \");\n            sb.append(\"cluster.timeDiff=\").append(clusterTimeDiff).append(\", \");\n            sb.append(\"event.q.size=\").append(eventQueueSize).append(\", \");\n            sb.append(\"executor.q.async.size=\").append(asyncExecutorQueueSize).append(\", \");\n            sb.append(\"executor.q.client.size=\").append(clientExecutorQueueSize).append(\", \");\n            sb.append(\"executor.q.query.size=\").append(queryExecutorQueueSize).append(\", \");\n            sb.append(\"executor.q.scheduled.size=\").append(scheduledExecutorQueueSize).append(\", \");\n            sb.append(\"executor.q.io.size=\").append(ioExecutorQueueSize).append(\", \");\n            sb.append(\"executor.q.system.size=\").append(systemExecutorQueueSize).append(\", \");\n            sb.append(\"executor.q.operation.size=\").append(operationServiceOperationExecutorQueueSize).append(\", \");\n            sb.append(\"executor.q.priorityOperation.size=\").\n                    append(operationServiceOperationPriorityExecutorQueueSize).append(\", \");\n            sb.append(\"executor.q.response.size=\").append(operationServiceOperationResponseQueueSize).append(\", \");\n            sb.append(\"operations.remote.size=\").append(remoteOperationsCount).append(\", \");\n            sb.append(\"operations.running.size=\").append(runningOperationsCount).append(\", \");\n            sb.append(\"operations.pending.invocations.count=\")\n                    .append(pendingInvocationsCount).append(\", \");\n            sb.append(\"operations.pending.invocations.percentage=\")\n                    .append(format(\"%.2f\", pendingInvocationsPercentage)).append(\"%, \");\n            sb.append(\"proxy.count=\").append(proxyCount).append(\", \");\n            sb.append(\"clientEndpoint.count=\").append(clientEndpointCount).append(\", \");\n            sb.append(\"connection.active.count=\").append(activeConnectionCount).append(\", \");\n            sb.append(\"client.connection.count=\").append(currentClientConnectionCount).append(\", \");\n            sb.append(\"connection.count=\").append(connectionCount);\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Given a number, returns that number as a percentage string.\n     *\n     * @param p the given number\n     * @return a string of the given number as a format float with two decimal places and a period\n     */\n    public static String percentageString(double p) {\n        return format(\"%.2f\", p) + \"%\";\n    }\n\n    public static String numberToUnit(long number) {\n        //CHECKSTYLE:OFF\n        for (int i = 6; i > 0; i--) {\n            double step = Math.pow(1024, i); // 1024 is for 1024 kb is 1 MB etc\n            if (number > step) {\n                return format(\"%3.1f%s\", number / step, UNITS[i]);\n            }\n        }\n        //CHECKSTYLE:ON\n        return Long.toString(number);\n    }\n\n}",
    "ID_12": "public class PerformanceMonitor extends Thread {\n\n    private final ILogger logger;\n    private final Node node;\n    private final int delaySeconds;\n    private final InternalOperationService operationService;\n    private final ConnectionManager connectionManager;\n\n    public PerformanceMonitor(HazelcastInstanceImpl hazelcastInstance, int delaySeconds) {\n        super(hazelcastInstance.node.getHazelcastThreadGroup().getInternalThreadGroup(),\n                hazelcastInstance.node.getHazelcastThreadGroup().getThreadNamePrefix(\"PerformanceMonitor\"));\n        setDaemon(true);\n\n        this.delaySeconds = delaySeconds;\n        this.node = hazelcastInstance.node;\n        this.logger = node.getLogger(PerformanceMonitor.class.getName());\n        this.operationService = node.nodeEngine.getOperationService();\n        this.connectionManager = node.connectionManager;\n    }\n\n    @Override\n    public void run() {\n        StringBuffer sb = new StringBuffer();\n\n        while (node.isActive()) {\n            sb.append(\"\\n\");\n            sb.append(\"ConnectionManager metrics\\n\");\n            connectionManager.dumpPerformanceMetrics(sb);\n            sb.append(\"OperationService metrics\\n\");\n            operationService.dumpPerformanceMetrics(sb);\n\n            logger.info(sb.toString());\n\n            sb.setLength(0);\n            try {\n                Thread.sleep(TimeUnit.SECONDS.toMillis(delaySeconds));\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n    }\n}",
    "ID_13": "public class DiskLayer implements StoreReadLayer\n{\n    private static final Function<PropertyConstraintRule, PropertyConstraint> RULE_TO_CONSTRAINT =\n            new Function<PropertyConstraintRule, PropertyConstraint>()\n            {\n                @Override\n                public PropertyConstraint apply( PropertyConstraintRule rule )\n                {\n                    // We can use propertyKeyId straight up here, without reading from the record, since we have\n                    // verified that it has that propertyKeyId in the predicate. And since we currently only support\n                    // uniqueness on single properties, there is nothing else to pass in to UniquenessConstraint.\n                    return rule.toConstraint();\n                }\n            };\n\n    private static final Function<NodePropertyConstraintRule,NodePropertyConstraint> NODE_RULE_TO_CONSTRAINT =\n            new Function<NodePropertyConstraintRule,NodePropertyConstraint>()\n            {\n                @Override\n                public NodePropertyConstraint apply( NodePropertyConstraintRule rule )\n                {\n                    return rule.toConstraint();\n                }\n            };\n\n    private static final Function<RelationshipPropertyConstraintRule,RelationshipPropertyConstraint> REL_RULE_TO_CONSTRAINT =\n            new Function<RelationshipPropertyConstraintRule,RelationshipPropertyConstraint>()\n            {\n                @Override\n                public RelationshipPropertyConstraint apply( RelationshipPropertyConstraintRule rule )\n                {\n                    return rule.toConstraint();\n                }\n            };\n\n    // These token holders should perhaps move to the cache layer.. not really any reason to have them here?\n    private final PropertyKeyTokenHolder propertyKeyTokenHolder;\n    private final LabelTokenHolder labelTokenHolder;\n    private final RelationshipTypeTokenHolder relationshipTokenHolder;\n\n    private final NeoStore neoStore;\n    private final IndexingService indexService;\n    private final NodeStore nodeStore;\n    private final RelationshipGroupStore relationshipGroupStore;\n    private final RelationshipStore relationshipStore;\n    private final SchemaStorage schemaStorage;\n    private final CountsAccessor counts;\n    private final PropertyLoader propertyLoader;\n\n    public DiskLayer( PropertyKeyTokenHolder propertyKeyTokenHolder, LabelTokenHolder labelTokenHolder,\n            RelationshipTypeTokenHolder relationshipTokenHolder, SchemaStorage schemaStorage, NeoStore neoStore,\n            IndexingService indexService )\n    {\n        this.relationshipTokenHolder = relationshipTokenHolder;\n        this.schemaStorage = schemaStorage;\n        this.indexService = indexService;\n        this.propertyKeyTokenHolder = propertyKeyTokenHolder;\n        this.labelTokenHolder = labelTokenHolder;\n        this.neoStore = neoStore;\n        this.nodeStore = this.neoStore.getNodeStore();\n        this.relationshipStore = this.neoStore.getRelationshipStore();\n        this.relationshipGroupStore = this.neoStore.getRelationshipGroupStore();\n        this.counts = neoStore.getCounts();\n        this.propertyLoader = new PropertyLoader( neoStore );\n\n    }\n\n    @Override\n    public StoreStatement acquireStatement()\n    {\n        return neoStore.acquireStatement();\n    }\n\n    @Override\n    public int labelGetOrCreateForName( String label ) throws TooManyLabelsException\n    {\n        try\n        {\n            return labelTokenHolder.getOrCreateId( label );\n        }\n        catch ( TransactionFailureException e )\n        {\n            // Temporary workaround for the property store based label\n            // implementation. Actual\n            // implementation should not depend on internal kernel exception\n            // messages like this.\n            if ( e.getCause() instanceof UnderlyingStorageException\n                    && e.getCause().getMessage().equals( \"Id capacity exceeded\" ) )\n            {\n                throw new TooManyLabelsException( e );\n            }\n            throw e;\n        }\n    }\n\n    @Override\n    public int labelGetForName( String label )\n    {\n        return labelTokenHolder.getIdByName( label );\n    }\n\n    @Override\n    public PrimitiveIntIterator nodeGetLabels( StoreStatement statement, long nodeId ) throws EntityNotFoundException\n    {\n        try ( Cursor<NodeItem> nodeCursor = statement.acquireSingleNodeCursor( nodeId ) )\n        {\n            if ( nodeCursor.next() )\n            {\n                return Cursors.intIterator( nodeCursor.get().labels(), LabelItem.GET_LABEL );\n            }\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n    }\n\n    @Override\n    public RelationshipIterator nodeListRelationships( StoreStatement statement,\n            long nodeId,\n            Direction direction )\n            throws EntityNotFoundException\n    {\n        return nodeListRelationships( statement, nodeId, direction, null );\n    }\n\n    @Override\n    public RelationshipIterator nodeListRelationships( final StoreStatement statement,\n            long nodeId,\n            Direction direction,\n            int[] relTypes )\n            throws EntityNotFoundException\n    {\n        try ( final Cursor<NodeItem> nodeCursor = statement.acquireSingleNodeCursor( nodeId ) )\n        {\n            if ( nodeCursor.next() )\n            {\n                return new CursorRelationshipIterator( nodeCursor.get().relationships( direction, relTypes ) );\n            }\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n    }\n\n    @Override\n    public int nodeGetDegree( StoreStatement statement,\n            long nodeId,\n            Direction direction ) throws EntityNotFoundException\n    {\n        NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n\n        if ( node.isDense() )\n        {\n            long groupId = node.getNextRel();\n            long count = 0;\n            while ( groupId != Record.NO_NEXT_RELATIONSHIP.intValue() )\n            {\n                RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                count += nodeDegreeByDirection( nodeId, group, direction );\n                groupId = group.getNext();\n            }\n            return (int) count;\n        }\n\n        return count( nodeListRelationships( statement, nodeId, direction ) );\n    }\n\n    @Override\n    public int nodeGetDegree( StoreStatement statement, long nodeId,\n            Direction direction,\n            int relType ) throws EntityNotFoundException\n    {\n        NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n\n        if ( node.isDense() )\n        {\n            long groupId = node.getNextRel();\n            while ( groupId != Record.NO_NEXT_RELATIONSHIP.intValue() )\n            {\n                RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                if ( group.getType() == relType )\n                {\n                    return (int) nodeDegreeByDirection( nodeId, group, direction );\n                }\n                groupId = group.getNext();\n            }\n            return 0;\n        }\n\n        return count( nodeListRelationships( statement, nodeId, direction, new int[]{relType} ) );\n    }\n\n    private long nodeDegreeByDirection( long nodeId, RelationshipGroupRecord group, Direction direction )\n    {\n        long loopCount = countByFirstPrevPointer( nodeId, group.getFirstLoop() );\n        switch ( direction )\n        {\n            case OUTGOING:\n                return countByFirstPrevPointer( nodeId, group.getFirstOut() ) + loopCount;\n            case INCOMING:\n                return countByFirstPrevPointer( nodeId, group.getFirstIn() ) + loopCount;\n            case BOTH:\n                return countByFirstPrevPointer( nodeId, group.getFirstOut() ) +\n                        countByFirstPrevPointer( nodeId, group.getFirstIn() ) + loopCount;\n            default:\n                throw new IllegalArgumentException( direction.name() );\n        }\n    }\n\n    @Override\n    public boolean nodeVisitDegrees( StoreStatement statement, final long nodeId, final DegreeVisitor visitor )\n    {\n        NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            return true;\n        }\n\n        if ( node.isDense() )\n        {\n            long groupId = node.getNextRel();\n            while ( groupId != Record.NO_NEXT_RELATIONSHIP.intValue() )\n            {\n                RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                long outCount = countByFirstPrevPointer( nodeId, group.getFirstOut() );\n                long inCount = countByFirstPrevPointer( nodeId, group.getFirstIn() );\n                long loopCount = countByFirstPrevPointer( nodeId, group.getFirstLoop() );\n                visitor.visitDegree( group.getType(), (int) (outCount + loopCount), (int) (inCount + loopCount) );\n                groupId = group.getNext();\n            }\n        }\n        else\n        {\n            final PrimitiveIntObjectMap<int[]> degrees = Primitive.intObjectMap( 5 );\n            RelationshipVisitor<RuntimeException> typeVisitor = new RelationshipVisitor<RuntimeException>()\n            {\n                @Override\n                public void visit( long relId, int type, long startNode, long endNode ) throws RuntimeException\n                {\n                    int[] byType = degrees.get( type );\n                    if ( byType == null )\n                    {\n                        degrees.put( type, byType = new int[3] );\n                    }\n                    byType[directionOf( nodeId, relId, startNode, endNode ).ordinal()]++;\n                }\n            };\n            RelationshipIterator relationships;\n            try\n            {\n                relationships = nodeListRelationships( statement, nodeId, Direction.BOTH );\n                while ( relationships.hasNext() )\n                {\n                    relationships.relationshipVisit( relationships.next(), typeVisitor );\n                }\n\n                degrees.visitEntries( new PrimitiveIntObjectVisitor<int[], RuntimeException>()\n                {\n                    @Override\n                    public boolean visited( int type, int[] degrees /*out,in,loop*/ ) throws RuntimeException\n                    {\n                        visitor.visitDegree( type, degrees[0] + degrees[2], degrees[1] + degrees[2] );\n                        return false;\n                    }\n                } );\n            }\n            catch ( EntityNotFoundException e )\n            {\n                // OK?\n            }\n        }\n        return false;\n    }\n\n    private Direction directionOf( long nodeId, long relationshipId, long startNode, long endNode )\n    {\n        if ( startNode == nodeId )\n        {\n            return endNode == nodeId ? Direction.BOTH : Direction.OUTGOING;\n        }\n        if ( endNode == nodeId )\n        {\n            return Direction.INCOMING;\n        }\n        throw new InvalidRecordException( \"Node \" + nodeId + \" neither start nor end node of relationship \" +\n                relationshipId + \" with startNode:\" + startNode + \" and endNode:\" + endNode );\n    }\n\n    private long countByFirstPrevPointer( long nodeId, long relationshipId )\n    {\n        if ( relationshipId == Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            return 0;\n        }\n        RelationshipRecord record = relationshipStore.getRecord( relationshipId );\n        if ( record.getFirstNode() == nodeId )\n        {\n            return record.getFirstPrevRel();\n        }\n        if ( record.getSecondNode() == nodeId )\n        {\n            return record.getSecondPrevRel();\n        }\n        throw new InvalidRecordException( \"Node \" + nodeId + \" neither start nor end node of \" + record );\n    }\n\n    @Override\n    public PrimitiveIntIterator nodeGetRelationshipTypes( StoreStatement statement,\n            long nodeId ) throws EntityNotFoundException\n    {\n        final NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n\n        if ( node.isDense() )\n        {\n            return new PrimitiveIntCollections.PrimitiveIntBaseIterator()\n            {\n                private long groupId = node.getNextRel();\n\n                @Override\n                protected boolean fetchNext()\n                {\n                    if ( groupId == Record.NO_NEXT_RELATIONSHIP.intValue() )\n                    {\n                        return false;\n                    }\n\n                    RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                    try\n                    {\n                        return next( group.getType() );\n                    }\n                    finally\n                    {\n                        groupId = group.getNext();\n                    }\n                }\n            };\n        }\n\n        final PrimitiveIntSet types = Primitive.intSet( 5 );\n        RelationshipVisitor<RuntimeException> visitor = new RelationshipVisitor<RuntimeException>()\n        {\n            @Override\n            public void visit( long relId, int type, long startNode, long endNode ) throws RuntimeException\n            {\n                types.add( type );\n            }\n        };\n        RelationshipIterator relationships = nodeListRelationships( statement, nodeId, Direction.BOTH );\n        while ( relationships.hasNext() )\n        {\n            relationships.relationshipVisit( relationships.next(), visitor );\n        }\n        return types.iterator();\n    }\n\n    @Override\n    public String labelGetName( int labelId ) throws LabelNotFoundKernelException\n    {\n        try\n        {\n            return labelTokenHolder.getTokenById( labelId ).name();\n        }\n        catch ( TokenNotFoundException e )\n        {\n            throw new LabelNotFoundKernelException( \"Label by id \" + labelId, e );\n        }\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetForLabel( KernelStatement state, int labelId )\n    {\n        return state.getLabelScanReader().nodesWithLabel( labelId );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexSeek( KernelStatement state, IndexDescriptor index,\n            Object value ) throws IndexNotFoundKernelException\n    {\n        IndexReader reader = state.getIndexReader( index );\n        return reader.seek( value );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexRangeSeekByNumber( KernelStatement statement,\n                                                                     IndexDescriptor index,\n                                                                     Number lower, boolean includeLower,\n                                                                     Number upper, boolean includeUpper )\n            throws IndexNotFoundKernelException\n\n    {\n        IndexReader reader = statement.getIndexReader( index );\n        return reader.rangeSeekByNumber( lower, includeLower, upper, includeUpper );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexRangeSeekByString( KernelStatement statement,\n                                                                     IndexDescriptor index,\n                                                                     String lower, boolean includeLower,\n                                                                     String upper, boolean includeUpper )\n            throws IndexNotFoundKernelException\n\n    {\n        IndexReader reader = statement.getIndexReader( index );\n        return reader.rangeSeekByString( lower, includeLower, upper, includeUpper );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexRangeSeekByPrefix( KernelStatement state,\n                                                                     IndexDescriptor index,\n                                                                     String prefix )\n            throws IndexNotFoundKernelException\n    {\n        IndexReader reader = state.getIndexReader( index );\n        return reader.rangeSeekByPrefix( prefix );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexScan( KernelStatement state, IndexDescriptor index ) throws\n            IndexNotFoundKernelException\n    {\n        IndexReader reader = state.getIndexReader( index );\n        return reader.scan();\n    }\n\n    @Override\n    public IndexDescriptor indexesGetForLabelAndPropertyKey( int labelId, int propertyKey )\n    {\n        return descriptor( schemaStorage.indexRule( labelId, propertyKey ) );\n    }\n\n    private static IndexDescriptor descriptor( IndexRule ruleRecord )\n    {\n        return new IndexDescriptor( ruleRecord.getLabel(), ruleRecord.getPropertyKey() );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> indexesGetForLabel( int labelId )\n    {\n        return getIndexDescriptorsFor( indexRules( labelId ) );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> indexesGetAll()\n    {\n        return getIndexDescriptorsFor( INDEX_RULES );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> uniqueIndexesGetForLabel( int labelId )\n    {\n        return getIndexDescriptorsFor( constraintIndexRules( labelId ) );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> uniqueIndexesGetAll()\n    {\n        return getIndexDescriptorsFor( CONSTRAINT_INDEX_RULES );\n    }\n\n    private static Predicate<SchemaRule> indexRules( final int labelId )\n    {\n        return new Predicate<SchemaRule>()\n        {\n\n            @Override\n            public boolean test( SchemaRule rule )\n            {\n                return rule.getLabel() == labelId && rule.getKind() == SchemaRule.Kind.INDEX_RULE;\n            }\n        };\n    }\n\n    private static Predicate<SchemaRule> constraintIndexRules( final int labelId )\n    {\n        return new Predicate<SchemaRule>()\n        {\n\n            @Override\n            public boolean test( SchemaRule rule )\n            {\n                return rule.getLabel() == labelId && rule.getKind() == SchemaRule.Kind.CONSTRAINT_INDEX_RULE;\n            }\n        };\n    }\n\n    private static final Predicate<SchemaRule> INDEX_RULES = new Predicate<SchemaRule>()\n    {\n\n        @Override\n        public boolean test( SchemaRule rule )\n        {\n            return rule.getKind() == SchemaRule.Kind.INDEX_RULE;\n        }\n    }, CONSTRAINT_INDEX_RULES = new Predicate<SchemaRule>()\n    {\n\n        @Override\n        public boolean test( SchemaRule rule )\n        {\n            return rule.getKind() == SchemaRule.Kind.CONSTRAINT_INDEX_RULE;\n        }\n    };\n\n    private Iterator<IndexDescriptor> getIndexDescriptorsFor( Predicate<SchemaRule> filter )\n    {\n        Iterator<SchemaRule> filtered = filter( filter, neoStore.getSchemaStore().loadAllSchemaRules() );\n\n        return map( new Function<SchemaRule, IndexDescriptor>()\n        {\n\n            @Override\n            public IndexDescriptor apply( SchemaRule from )\n            {\n                return descriptor( (IndexRule) from );\n            }\n        }, filtered );\n    }\n\n    @Override\n    public Long indexGetOwningUniquenessConstraintId( IndexDescriptor index )\n            throws SchemaRuleNotFoundException\n    {\n        return schemaStorage.indexRule( index.getLabelId(), index.getPropertyKeyId() ).getOwningConstraint();\n    }\n\n    @Override\n    public IndexRule indexRule( IndexDescriptor index, SchemaStorage.IndexRuleKind kind )\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public long indexGetCommittedId( IndexDescriptor index, SchemaStorage.IndexRuleKind kind )\n            throws SchemaRuleNotFoundException\n    {\n        return schemaStorage.indexRule( index.getLabelId(), index.getPropertyKeyId() ).getId();\n    }\n\n    @Override\n    public InternalIndexState indexGetState( IndexDescriptor descriptor )\n            throws IndexNotFoundKernelException\n    {\n        return indexService.getIndexProxy( descriptor ).getState();\n    }\n\n    @Override\n    public long indexSize( IndexDescriptor descriptor ) throws IndexNotFoundKernelException\n    {\n        return indexService.indexSize( descriptor );\n    }\n\n    @Override\n    public double indexUniqueValuesPercentage( IndexDescriptor descriptor ) throws IndexNotFoundKernelException\n    {\n        return indexService.indexUniqueValuesPercentage( descriptor );\n    }\n\n    @Override\n    public String indexGetFailure( IndexDescriptor descriptor ) throws IndexNotFoundKernelException\n    {\n        return indexService.getIndexProxy( descriptor ).getPopulationFailure().asString();\n    }\n\n    @Override\n    public Iterator<NodePropertyConstraint> constraintsGetForLabelAndPropertyKey( int labelId, final int propertyKeyId )\n    {\n        return schemaStorage.schemaRulesForNodes( NODE_RULE_TO_CONSTRAINT, NodePropertyConstraintRule.class,\n                labelId, new Predicate<NodePropertyConstraintRule>()\n                {\n                    @Override\n                    public boolean test( NodePropertyConstraintRule rule )\n                    {\n                        return rule.containsPropertyKeyId( propertyKeyId );\n                    }\n                } );\n    }\n\n    @Override\n    public Iterator<NodePropertyConstraint> constraintsGetForLabel( int labelId )\n    {\n        return schemaStorage.schemaRulesForNodes( NODE_RULE_TO_CONSTRAINT, NodePropertyConstraintRule.class,\n                labelId, Predicates.<NodePropertyConstraintRule>alwaysTrue() );\n    }\n\n    @Override\n    public Iterator<RelationshipPropertyConstraint> constraintsGetForRelationshipTypeAndPropertyKey( int typeId,\n            final int propertyKeyId )\n    {\n        return schemaStorage.schemaRulesForRelationships( REL_RULE_TO_CONSTRAINT,\n                RelationshipPropertyConstraintRule.class, typeId, new Predicate<RelationshipPropertyConstraintRule>()\n                {\n                    @Override\n                    public boolean test( RelationshipPropertyConstraintRule rule )\n                    {\n                        return rule.containsPropertyKeyId( propertyKeyId );\n                    }\n                } );\n    }\n\n    @Override\n    public Iterator<RelationshipPropertyConstraint> constraintsGetForRelationshipType( int typeId )\n    {\n        return schemaStorage.schemaRulesForRelationships( REL_RULE_TO_CONSTRAINT,\n                RelationshipPropertyConstraintRule.class, typeId,\n                Predicates.<RelationshipPropertyConstraintRule>alwaysTrue() );\n    }\n\n    @Override\n    public Iterator<PropertyConstraint> constraintsGetAll()\n    {\n        return schemaStorage.schemaRules( RULE_TO_CONSTRAINT, PropertyConstraintRule.class );\n    }\n\n    @Override\n    public PrimitiveLongResourceIterator nodeGetFromUniqueIndexSeek( KernelStatement state, IndexDescriptor descriptor,\n            Object value ) throws IndexNotFoundKernelException, IndexBrokenKernelException\n    {\n        /* Here we have an intricate scenario where we need to return the PrimitiveLongIterator\n         * since subsequent filtering will happen outside, but at the same time have the ability to\n         * close the IndexReader when done iterating over the lookup result. This is because we get\n         * a fresh reader that isn't associated with the current transaction and hence will not be\n         * automatically closed. */\n        IndexReader reader = state.getFreshIndexReader( descriptor );\n        return resourceIterator( reader.seek( value ), reader );\n    }\n\n    @Override\n    public int propertyKeyGetOrCreateForName( String propertyKey )\n    {\n        return propertyKeyTokenHolder.getOrCreateId( propertyKey );\n    }\n\n    @Override\n    public int propertyKeyGetForName( String propertyKey )\n    {\n        return propertyKeyTokenHolder.getIdByName( propertyKey );\n    }\n\n    @Override\n    public String propertyKeyGetName( int propertyKeyId )\n            throws PropertyKeyIdNotFoundKernelException\n    {\n        try\n        {\n            return propertyKeyTokenHolder.getTokenById( propertyKeyId ).name();\n        }\n        catch ( TokenNotFoundException e )\n        {\n            throw new PropertyKeyIdNotFoundKernelException( propertyKeyId, e );\n        }\n    }\n\n    @Override\n    public PrimitiveIntIterator graphGetPropertyKeys( KernelStatement state )\n    {\n        return new PropertyKeyIdIterator( propertyLoader.graphLoadProperties( new IteratingPropertyReceiver() ) );\n    }\n\n    @Override\n    public Object graphGetProperty( int propertyKeyId )\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Iterator<DefinedProperty> graphGetAllProperties()\n    {\n        return propertyLoader.graphLoadProperties( new IteratingPropertyReceiver() );\n    }\n\n    @Override\n    public Iterator<Token> propertyKeyGetAllTokens()\n    {\n        return propertyKeyTokenHolder.getAllTokens().iterator();\n    }\n\n    @Override\n    public Iterator<Token> labelsGetAllTokens()\n    {\n        return labelTokenHolder.getAllTokens().iterator();\n    }\n\n    @Override\n    public int relationshipTypeGetForName( String relationshipTypeName )\n    {\n        return relationshipTokenHolder.getIdByName( relationshipTypeName );\n    }\n\n    @Override\n    public String relationshipTypeGetName( int relationshipTypeId ) throws RelationshipTypeIdNotFoundKernelException\n    {\n        try\n        {\n            return relationshipTokenHolder.getTokenById( relationshipTypeId ).name();\n        }\n        catch ( TokenNotFoundException e )\n        {\n            throw new RelationshipTypeIdNotFoundKernelException( relationshipTypeId, e );\n        }\n    }\n\n    @Override\n    public int relationshipTypeGetOrCreateForName( String relationshipTypeName )\n    {\n        return relationshipTokenHolder.getOrCreateId( relationshipTypeName );\n    }\n\n    @Override\n    public <EXCEPTION extends Exception> void relationshipVisit( long relationshipId,\n            RelationshipVisitor<EXCEPTION> relationshipVisitor ) throws EntityNotFoundException, EXCEPTION\n    {\n        // TODO Please don't create a record for this, it's ridiculous\n        RelationshipRecord record;\n        try\n        {\n            record = relationshipStore.getRecord( relationshipId );\n        }\n        catch ( InvalidRecordException e )\n        {\n            throw new EntityNotFoundException( EntityType.RELATIONSHIP, relationshipId );\n        }\n        relationshipVisitor.visit( relationshipId, record.getType(), record.getFirstNode(), record.getSecondNode() );\n    }\n\n    @Override\n    public long highestNodeIdInUse()\n    {\n        return nodeStore.getHighestPossibleIdInUse();\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetAll()\n    {\n        return new PrimitiveLongBaseIterator()\n        {\n            private final NodeStore store = neoStore.getNodeStore();\n            private long highId = store.getHighestPossibleIdInUse();\n            private long currentId;\n            private final NodeRecord reusableNodeRecord = new NodeRecord( -1 ); // reused\n\n            @Override\n            protected boolean fetchNext()\n            {\n                while ( true )\n                {   // This outer loop is for checking if highId has changed since we started.\n                    while ( currentId <= highId )\n                    {\n                        try\n                        {\n                            NodeRecord record = store.loadRecord( currentId, reusableNodeRecord );\n                            if ( record != null && record.inUse() )\n                            {\n                                return next( record.getId() );\n                            }\n                        }\n                        finally\n                        {\n                            currentId++;\n                        }\n                    }\n\n                    long newHighId = store.getHighestPossibleIdInUse();\n                    if ( newHighId > highId )\n                    {\n                        highId = newHighId;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                return false;\n            }\n        };\n    }\n\n    @Override\n    public Cursor<NodeItem> nodesGetAllCursor( StoreStatement statement )\n    {\n        return statement.acquireIteratorNodeCursor( new AllStoreIdIterator( neoStore.getNodeStore() ) );\n    }\n\n    @Override\n    public RelationshipIterator relationshipsGetAll()\n    {\n        return new RelationshipIterator.BaseIterator()\n        {\n            private final RelationshipStore store = neoStore.getRelationshipStore();\n            private long highId = store.getHighestPossibleIdInUse();\n            private long currentId;\n            private final RelationshipRecord reusableRecord = new RelationshipRecord( -1 ); // reused\n\n            @Override\n            protected boolean fetchNext()\n            {\n                while ( true )\n                {   // This outer loop is for checking if highId has changed since we started.\n                    while ( currentId <= highId )\n                    {\n                        try\n                        {\n                            if ( store.fillRecord( currentId, reusableRecord, CHECK ) && reusableRecord.inUse() )\n                            {\n                                return next( reusableRecord.getId() );\n                            }\n                        }\n                        finally\n                        {\n                            currentId++;\n                        }\n                    }\n\n                    long newHighId = store.getHighestPossibleIdInUse();\n                    if ( newHighId > highId )\n                    {\n                        highId = newHighId;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                return false;\n            }\n\n            @Override\n            public <EXCEPTION extends Exception> boolean relationshipVisit( long relationshipId,\n                    RelationshipVisitor<EXCEPTION> visitor ) throws EXCEPTION\n            {\n                visitor.visit( relationshipId, reusableRecord.getType(),\n                        reusableRecord.getFirstNode(), reusableRecord.getSecondNode() );\n                return false;\n            }\n        };\n    }\n\n    @Override\n    public Cursor<RelationshipItem> relationshipsGetAllCursor( StoreStatement storeStatement )\n    {\n        return storeStatement.acquireIteratorRelationshipCursor(\n                new AllStoreIdIterator( neoStore.getRelationshipStore() ) );\n    }\n\n    @Override\n    public long reserveNode()\n    {\n        return nodeStore.nextId();\n    }\n\n    @Override\n    public long reserveRelationship()\n    {\n        return relationshipStore.nextId();\n    }\n\n    @Override\n    public void releaseNode( long id )\n    {\n        nodeStore.freeId( id );\n    }\n\n    @Override\n    public void releaseRelationship( long id )\n    {\n        relationshipStore.freeId( id );\n    }\n\n    @Override\n    public long countsForNode( int labelId )\n    {\n        return counts.nodeCount( labelId, newDoubleLongRegister() ).readSecond();\n    }\n\n    @Override\n    public long countsForRelationship( int startLabelId, int typeId, int endLabelId )\n    {\n        if ( !(startLabelId == ReadOperations.ANY_LABEL || endLabelId == ReadOperations.ANY_LABEL) )\n        {\n            throw new UnsupportedOperationException( \"not implemented\" );\n        }\n        return counts.relationshipCount( startLabelId, typeId, endLabelId, newDoubleLongRegister() ).readSecond();\n    }\n\n    private class AllStoreIdIterator extends PrimitiveLongBaseIterator\n    {\n        private final CommonAbstractStore store;\n        private long highId;\n        private long currentId;\n\n        public AllStoreIdIterator( CommonAbstractStore store )\n        {\n            this.store = store;\n            highId = store.getHighestPossibleIdInUse();\n        }\n\n        @Override\n        protected boolean fetchNext()\n        {\n            while ( true )\n            {   // This outer loop is for checking if highId has changed since we started.\n                if ( currentId <= highId )\n                {\n                    try\n                    {\n                        return next( currentId );\n                    }\n                    finally\n                    {\n                        currentId++;\n                    }\n          ",
    "ID_14": "public class DiskLayer implements StoreReadLayer\n{\n    private static final Function<PropertyConstraintRule, PropertyConstraint> RULE_TO_CONSTRAINT =\n            new Function<PropertyConstraintRule, PropertyConstraint>()\n            {\n                @Override\n                public PropertyConstraint apply( PropertyConstraintRule rule )\n                {\n                    // We can use propertyKeyId straight up here, without reading from the record, since we have\n                    // verified that it has that propertyKeyId in the predicate. And since we currently only support\n                    // uniqueness on single properties, there is nothing else to pass in to UniquenessConstraint.\n                    return rule.toConstraint();\n                }\n            };\n\n    private static final Function<NodePropertyConstraintRule,NodePropertyConstraint> NODE_RULE_TO_CONSTRAINT =\n            new Function<NodePropertyConstraintRule,NodePropertyConstraint>()\n            {\n                @Override\n                public NodePropertyConstraint apply( NodePropertyConstraintRule rule )\n                {\n                    return rule.toConstraint();\n                }\n            };\n\n    private static final Function<RelationshipPropertyConstraintRule,RelationshipPropertyConstraint> REL_RULE_TO_CONSTRAINT =\n            new Function<RelationshipPropertyConstraintRule,RelationshipPropertyConstraint>()\n            {\n                @Override\n                public RelationshipPropertyConstraint apply( RelationshipPropertyConstraintRule rule )\n                {\n                    return rule.toConstraint();\n                }\n            };\n\n    // These token holders should perhaps move to the cache layer.. not really any reason to have them here?\n    private final PropertyKeyTokenHolder propertyKeyTokenHolder;\n    private final LabelTokenHolder labelTokenHolder;\n    private final RelationshipTypeTokenHolder relationshipTokenHolder;\n\n    private final NeoStore neoStore;\n    private final IndexingService indexService;\n    private final NodeStore nodeStore;\n    private final RelationshipGroupStore relationshipGroupStore;\n    private final RelationshipStore relationshipStore;\n    private final SchemaStorage schemaStorage;\n    private final CountsAccessor counts;\n    private final PropertyLoader propertyLoader;\n\n    public DiskLayer( PropertyKeyTokenHolder propertyKeyTokenHolder, LabelTokenHolder labelTokenHolder,\n            RelationshipTypeTokenHolder relationshipTokenHolder, SchemaStorage schemaStorage, NeoStore neoStore,\n            IndexingService indexService )\n    {\n        this.relationshipTokenHolder = relationshipTokenHolder;\n        this.schemaStorage = schemaStorage;\n        this.indexService = indexService;\n        this.propertyKeyTokenHolder = propertyKeyTokenHolder;\n        this.labelTokenHolder = labelTokenHolder;\n        this.neoStore = neoStore;\n        this.nodeStore = this.neoStore.getNodeStore();\n        this.relationshipStore = this.neoStore.getRelationshipStore();\n        this.relationshipGroupStore = this.neoStore.getRelationshipGroupStore();\n        this.counts = neoStore.getCounts();\n        this.propertyLoader = new PropertyLoader( neoStore );\n\n    }\n\n    @Override\n    public StoreStatement acquireStatement()\n    {\n        return neoStore.acquireStatement();\n    }\n\n    @Override\n    public int labelGetOrCreateForName( String label ) throws TooManyLabelsException\n    {\n        try\n        {\n            return labelTokenHolder.getOrCreateId( label );\n        }\n        catch ( TransactionFailureException e )\n        {\n            // Temporary workaround for the property store based label\n            // implementation. Actual\n            // implementation should not depend on internal kernel exception\n            // messages like this.\n            if ( e.getCause() instanceof UnderlyingStorageException\n                    && e.getCause().getMessage().equals( \"Id capacity exceeded\" ) )\n            {\n                throw new TooManyLabelsException( e );\n            }\n            throw e;\n        }\n    }\n\n    @Override\n    public int labelGetForName( String label )\n    {\n        return labelTokenHolder.getIdByName( label );\n    }\n\n    @Override\n    public PrimitiveIntIterator nodeGetLabels( StoreStatement statement, long nodeId ) throws EntityNotFoundException\n    {\n        try ( Cursor<NodeItem> nodeCursor = statement.acquireSingleNodeCursor( nodeId ) )\n        {\n            if ( nodeCursor.next() )\n            {\n                return Cursors.intIterator( nodeCursor.get().labels(), LabelItem.GET_LABEL );\n            }\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n    }\n\n    @Override\n    public RelationshipIterator nodeListRelationships( StoreStatement statement,\n            long nodeId,\n            Direction direction )\n            throws EntityNotFoundException\n    {\n        return nodeListRelationships( statement, nodeId, direction, null );\n    }\n\n    @Override\n    public RelationshipIterator nodeListRelationships( final StoreStatement statement,\n            long nodeId,\n            Direction direction,\n            int[] relTypes )\n            throws EntityNotFoundException\n    {\n        try ( final Cursor<NodeItem> nodeCursor = statement.acquireSingleNodeCursor( nodeId ) )\n        {\n            if ( nodeCursor.next() )\n            {\n                return new CursorRelationshipIterator( nodeCursor.get().relationships( direction, relTypes ) );\n            }\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n    }\n\n    @Override\n    public int nodeGetDegree( StoreStatement statement,\n            long nodeId,\n            Direction direction ) throws EntityNotFoundException\n    {\n        NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n\n        if ( node.isDense() )\n        {\n            long groupId = node.getNextRel();\n            long count = 0;\n            while ( groupId != Record.NO_NEXT_RELATIONSHIP.intValue() )\n            {\n                RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                count += nodeDegreeByDirection( nodeId, group, direction );\n                groupId = group.getNext();\n            }\n            return (int) count;\n        }\n\n        return count( nodeListRelationships( statement, nodeId, direction ) );\n    }\n\n    @Override\n    public int nodeGetDegree( StoreStatement statement, long nodeId,\n            Direction direction,\n            int relType ) throws EntityNotFoundException\n    {\n        NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n\n        if ( node.isDense() )\n        {\n            long groupId = node.getNextRel();\n            while ( groupId != Record.NO_NEXT_RELATIONSHIP.intValue() )\n            {\n                RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                if ( group.getType() == relType )\n                {\n                    return (int) nodeDegreeByDirection( nodeId, group, direction );\n                }\n                groupId = group.getNext();\n            }\n            return 0;\n        }\n\n        return count( nodeListRelationships( statement, nodeId, direction, new int[]{relType} ) );\n    }\n\n    private long nodeDegreeByDirection( long nodeId, RelationshipGroupRecord group, Direction direction )\n    {\n        long loopCount = countByFirstPrevPointer( nodeId, group.getFirstLoop() );\n        switch ( direction )\n        {\n            case OUTGOING:\n                return countByFirstPrevPointer( nodeId, group.getFirstOut() ) + loopCount;\n            case INCOMING:\n                return countByFirstPrevPointer( nodeId, group.getFirstIn() ) + loopCount;\n            case BOTH:\n                return countByFirstPrevPointer( nodeId, group.getFirstOut() ) +\n                        countByFirstPrevPointer( nodeId, group.getFirstIn() ) + loopCount;\n            default:\n                throw new IllegalArgumentException( direction.name() );\n        }\n    }\n\n    @Override\n    public boolean nodeVisitDegrees( StoreStatement statement, final long nodeId, final DegreeVisitor visitor )\n    {\n        NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            return true;\n        }\n\n        if ( node.isDense() )\n        {\n            long groupId = node.getNextRel();\n            while ( groupId != Record.NO_NEXT_RELATIONSHIP.intValue() )\n            {\n                RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                long outCount = countByFirstPrevPointer( nodeId, group.getFirstOut() );\n                long inCount = countByFirstPrevPointer( nodeId, group.getFirstIn() );\n                long loopCount = countByFirstPrevPointer( nodeId, group.getFirstLoop() );\n                visitor.visitDegree( group.getType(), (int) (outCount + loopCount), (int) (inCount + loopCount) );\n                groupId = group.getNext();\n            }\n        }\n        else\n        {\n            final PrimitiveIntObjectMap<int[]> degrees = Primitive.intObjectMap( 5 );\n            RelationshipVisitor<RuntimeException> typeVisitor = new RelationshipVisitor<RuntimeException>()\n            {\n                @Override\n                public void visit( long relId, int type, long startNode, long endNode ) throws RuntimeException\n                {\n                    int[] byType = degrees.get( type );\n                    if ( byType == null )\n                    {\n                        degrees.put( type, byType = new int[3] );\n                    }\n                    byType[directionOf( nodeId, relId, startNode, endNode ).ordinal()]++;\n                }\n            };\n            RelationshipIterator relationships;\n            try\n            {\n                relationships = nodeListRelationships( statement, nodeId, Direction.BOTH );\n                while ( relationships.hasNext() )\n                {\n                    relationships.relationshipVisit( relationships.next(), typeVisitor );\n                }\n\n                degrees.visitEntries( new PrimitiveIntObjectVisitor<int[], RuntimeException>()\n                {\n                    @Override\n                    public boolean visited( int type, int[] degrees /*out,in,loop*/ ) throws RuntimeException\n                    {\n                        visitor.visitDegree( type, degrees[0] + degrees[2], degrees[1] + degrees[2] );\n                        return false;\n                    }\n                } );\n            }\n            catch ( EntityNotFoundException e )\n            {\n                // OK?\n            }\n        }\n        return false;\n    }\n\n    private Direction directionOf( long nodeId, long relationshipId, long startNode, long endNode )\n    {\n        if ( startNode == nodeId )\n        {\n            return endNode == nodeId ? Direction.BOTH : Direction.OUTGOING;\n        }\n        if ( endNode == nodeId )\n        {\n            return Direction.INCOMING;\n        }\n        throw new InvalidRecordException( \"Node \" + nodeId + \" neither start nor end node of relationship \" +\n                relationshipId + \" with startNode:\" + startNode + \" and endNode:\" + endNode );\n    }\n\n    private long countByFirstPrevPointer( long nodeId, long relationshipId )\n    {\n        if ( relationshipId == Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            return 0;\n        }\n        RelationshipRecord record = relationshipStore.getRecord( relationshipId );\n        if ( record.getFirstNode() == nodeId )\n        {\n            return record.getFirstPrevRel();\n        }\n        if ( record.getSecondNode() == nodeId )\n        {\n            return record.getSecondPrevRel();\n        }\n        throw new InvalidRecordException( \"Node \" + nodeId + \" neither start nor end node of \" + record );\n    }\n\n    @Override\n    public PrimitiveIntIterator nodeGetRelationshipTypes( StoreStatement statement,\n            long nodeId ) throws EntityNotFoundException\n    {\n        final NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n\n        if ( node.isDense() )\n        {\n            return new PrimitiveIntCollections.PrimitiveIntBaseIterator()\n            {\n                private long groupId = node.getNextRel();\n\n                @Override\n                protected boolean fetchNext()\n                {\n                    if ( groupId == Record.NO_NEXT_RELATIONSHIP.intValue() )\n                    {\n                        return false;\n                    }\n\n                    RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                    try\n                    {\n                        return next( group.getType() );\n                    }\n                    finally\n                    {\n                        groupId = group.getNext();\n                    }\n                }\n            };\n        }\n\n        final PrimitiveIntSet types = Primitive.intSet( 5 );\n        RelationshipVisitor<RuntimeException> visitor = new RelationshipVisitor<RuntimeException>()\n        {\n            @Override\n            public void visit( long relId, int type, long startNode, long endNode ) throws RuntimeException\n            {\n                types.add( type );\n            }\n        };\n        RelationshipIterator relationships = nodeListRelationships( statement, nodeId, Direction.BOTH );\n        while ( relationships.hasNext() )\n        {\n            relationships.relationshipVisit( relationships.next(), visitor );\n        }\n        return types.iterator();\n    }\n\n    @Override\n    public String labelGetName( int labelId ) throws LabelNotFoundKernelException\n    {\n        try\n        {\n            return labelTokenHolder.getTokenById( labelId ).name();\n        }\n        catch ( TokenNotFoundException e )\n        {\n            throw new LabelNotFoundKernelException( \"Label by id \" + labelId, e );\n        }\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetForLabel( KernelStatement state, int labelId )\n    {\n        return state.getLabelScanReader().nodesWithLabel( labelId );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexSeek( KernelStatement state, IndexDescriptor index,\n            Object value ) throws IndexNotFoundKernelException\n    {\n        IndexReader reader = state.getIndexReader( index );\n        return reader.seek( value );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexRangeSeekByNumber( KernelStatement statement,\n                                                                     IndexDescriptor index,\n                                                                     Number lower, boolean includeLower,\n                                                                     Number upper, boolean includeUpper )\n            throws IndexNotFoundKernelException\n\n    {\n        IndexReader reader = statement.getIndexReader( index );\n        return reader.rangeSeekByNumber( lower, includeLower, upper, includeUpper );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexRangeSeekByString( KernelStatement statement,\n                                                                     IndexDescriptor index,\n                                                                     String lower, boolean includeLower,\n                                                                     String upper, boolean includeUpper )\n            throws IndexNotFoundKernelException\n\n    {\n        IndexReader reader = statement.getIndexReader( index );\n        return reader.rangeSeekByString( lower, includeLower, upper, includeUpper );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexRangeSeekByPrefix( KernelStatement state,\n                                                                     IndexDescriptor index,\n                                                                     String prefix )\n            throws IndexNotFoundKernelException\n    {\n        IndexReader reader = state.getIndexReader( index );\n        return reader.rangeSeekByPrefix( prefix );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexScan( KernelStatement state, IndexDescriptor index ) throws\n            IndexNotFoundKernelException\n    {\n        IndexReader reader = state.getIndexReader( index );\n        return reader.scan();\n    }\n\n    @Override\n    public IndexDescriptor indexesGetForLabelAndPropertyKey( int labelId, int propertyKey )\n    {\n        return descriptor( schemaStorage.indexRule( labelId, propertyKey ) );\n    }\n\n    private static IndexDescriptor descriptor( IndexRule ruleRecord )\n    {\n        return new IndexDescriptor( ruleRecord.getLabel(), ruleRecord.getPropertyKey() );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> indexesGetForLabel( int labelId )\n    {\n        return getIndexDescriptorsFor( indexRules( labelId ) );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> indexesGetAll()\n    {\n        return getIndexDescriptorsFor( INDEX_RULES );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> uniqueIndexesGetForLabel( int labelId )\n    {\n        return getIndexDescriptorsFor( constraintIndexRules( labelId ) );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> uniqueIndexesGetAll()\n    {\n        return getIndexDescriptorsFor( CONSTRAINT_INDEX_RULES );\n    }\n\n    private static Predicate<SchemaRule> indexRules( final int labelId )\n    {\n        return new Predicate<SchemaRule>()\n        {\n\n            @Override\n            public boolean test( SchemaRule rule )\n            {\n                return rule.getLabel() == labelId && rule.getKind() == SchemaRule.Kind.INDEX_RULE;\n            }\n        };\n    }\n\n    private static Predicate<SchemaRule> constraintIndexRules( final int labelId )\n    {\n        return new Predicate<SchemaRule>()\n        {\n\n            @Override\n            public boolean test( SchemaRule rule )\n            {\n                return rule.getLabel() == labelId && rule.getKind() == SchemaRule.Kind.CONSTRAINT_INDEX_RULE;\n            }\n        };\n    }\n\n    private static final Predicate<SchemaRule> INDEX_RULES = new Predicate<SchemaRule>()\n    {\n\n        @Override\n        public boolean test( SchemaRule rule )\n        {\n            return rule.getKind() == SchemaRule.Kind.INDEX_RULE;\n        }\n    }, CONSTRAINT_INDEX_RULES = new Predicate<SchemaRule>()\n    {\n\n        @Override\n        public boolean test( SchemaRule rule )\n        {\n            return rule.getKind() == SchemaRule.Kind.CONSTRAINT_INDEX_RULE;\n        }\n    };\n\n    private Iterator<IndexDescriptor> getIndexDescriptorsFor( Predicate<SchemaRule> filter )\n    {\n        Iterator<SchemaRule> filtered = filter( filter, neoStore.getSchemaStore().loadAllSchemaRules() );\n\n        return map( new Function<SchemaRule, IndexDescriptor>()\n        {\n\n            @Override\n            public IndexDescriptor apply( SchemaRule from )\n            {\n                return descriptor( (IndexRule) from );\n            }\n        }, filtered );\n    }\n\n    @Override\n    public Long indexGetOwningUniquenessConstraintId( IndexDescriptor index )\n            throws SchemaRuleNotFoundException\n    {\n        return schemaStorage.indexRule( index.getLabelId(), index.getPropertyKeyId() ).getOwningConstraint();\n    }\n\n    @Override\n    public IndexRule indexRule( IndexDescriptor index, SchemaStorage.IndexRuleKind kind )\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public long indexGetCommittedId( IndexDescriptor index, SchemaStorage.IndexRuleKind kind )\n            throws SchemaRuleNotFoundException\n    {\n        return schemaStorage.indexRule( index.getLabelId(), index.getPropertyKeyId() ).getId();\n    }\n\n    @Override\n    public InternalIndexState indexGetState( IndexDescriptor descriptor )\n            throws IndexNotFoundKernelException\n    {\n        return indexService.getIndexProxy( descriptor ).getState();\n    }\n\n    @Override\n    public long indexSize( IndexDescriptor descriptor ) throws IndexNotFoundKernelException\n    {\n        return indexService.indexSize( descriptor );\n    }\n\n    @Override\n    public double indexUniqueValuesPercentage( IndexDescriptor descriptor ) throws IndexNotFoundKernelException\n    {\n        return indexService.indexUniqueValuesPercentage( descriptor );\n    }\n\n    @Override\n    public String indexGetFailure( IndexDescriptor descriptor ) throws IndexNotFoundKernelException\n    {\n        return indexService.getIndexProxy( descriptor ).getPopulationFailure().asString();\n    }\n\n    @Override\n    public Iterator<NodePropertyConstraint> constraintsGetForLabelAndPropertyKey( int labelId, final int propertyKeyId )\n    {\n        return schemaStorage.schemaRulesForNodes( NODE_RULE_TO_CONSTRAINT, NodePropertyConstraintRule.class,\n                labelId, new Predicate<NodePropertyConstraintRule>()\n                {\n                    @Override\n                    public boolean test( NodePropertyConstraintRule rule )\n                    {\n                        return rule.containsPropertyKeyId( propertyKeyId );\n                    }\n                } );\n    }\n\n    @Override\n    public Iterator<NodePropertyConstraint> constraintsGetForLabel( int labelId )\n    {\n        return schemaStorage.schemaRulesForNodes( NODE_RULE_TO_CONSTRAINT, NodePropertyConstraintRule.class,\n                labelId, Predicates.<NodePropertyConstraintRule>alwaysTrue() );\n    }\n\n    @Override\n    public Iterator<RelationshipPropertyConstraint> constraintsGetForRelationshipTypeAndPropertyKey( int typeId,\n            final int propertyKeyId )\n    {\n        return schemaStorage.schemaRulesForRelationships( REL_RULE_TO_CONSTRAINT,\n                RelationshipPropertyConstraintRule.class, typeId, new Predicate<RelationshipPropertyConstraintRule>()\n                {\n                    @Override\n                    public boolean test( RelationshipPropertyConstraintRule rule )\n                    {\n                        return rule.containsPropertyKeyId( propertyKeyId );\n                    }\n                } );\n    }\n\n    @Override\n    public Iterator<RelationshipPropertyConstraint> constraintsGetForRelationshipType( int typeId )\n    {\n        return schemaStorage.schemaRulesForRelationships( REL_RULE_TO_CONSTRAINT,\n                RelationshipPropertyConstraintRule.class, typeId,\n                Predicates.<RelationshipPropertyConstraintRule>alwaysTrue() );\n    }\n\n    @Override\n    public Iterator<PropertyConstraint> constraintsGetAll()\n    {\n        return schemaStorage.schemaRules( RULE_TO_CONSTRAINT, PropertyConstraintRule.class );\n    }\n\n    @Override\n    public PrimitiveLongResourceIterator nodeGetFromUniqueIndexSeek( KernelStatement state, IndexDescriptor descriptor,\n            Object value ) throws IndexNotFoundKernelException, IndexBrokenKernelException\n    {\n        /* Here we have an intricate scenario where we need to return the PrimitiveLongIterator\n         * since subsequent filtering will happen outside, but at the same time have the ability to\n         * close the IndexReader when done iterating over the lookup result. This is because we get\n         * a fresh reader that isn't associated with the current transaction and hence will not be\n         * automatically closed. */\n        IndexReader reader = state.getFreshIndexReader( descriptor );\n        return resourceIterator( reader.seek( value ), reader );\n    }\n\n    @Override\n    public int propertyKeyGetOrCreateForName( String propertyKey )\n    {\n        return propertyKeyTokenHolder.getOrCreateId( propertyKey );\n    }\n\n    @Override\n    public int propertyKeyGetForName( String propertyKey )\n    {\n        return propertyKeyTokenHolder.getIdByName( propertyKey );\n    }\n\n    @Override\n    public String propertyKeyGetName( int propertyKeyId )\n            throws PropertyKeyIdNotFoundKernelException\n    {\n        try\n        {\n            return propertyKeyTokenHolder.getTokenById( propertyKeyId ).name();\n        }\n        catch ( TokenNotFoundException e )\n        {\n            throw new PropertyKeyIdNotFoundKernelException( propertyKeyId, e );\n        }\n    }\n\n    @Override\n    public PrimitiveIntIterator graphGetPropertyKeys( KernelStatement state )\n    {\n        return new PropertyKeyIdIterator( propertyLoader.graphLoadProperties( new IteratingPropertyReceiver() ) );\n    }\n\n    @Override\n    public Object graphGetProperty( int propertyKeyId )\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Iterator<DefinedProperty> graphGetAllProperties()\n    {\n        return propertyLoader.graphLoadProperties( new IteratingPropertyReceiver() );\n    }\n\n    @Override\n    public Iterator<Token> propertyKeyGetAllTokens()\n    {\n        return propertyKeyTokenHolder.getAllTokens().iterator();\n    }\n\n    @Override\n    public Iterator<Token> labelsGetAllTokens()\n    {\n        return labelTokenHolder.getAllTokens().iterator();\n    }\n\n    @Override\n    public int relationshipTypeGetForName( String relationshipTypeName )\n    {\n        return relationshipTokenHolder.getIdByName( relationshipTypeName );\n    }\n\n    @Override\n    public String relationshipTypeGetName( int relationshipTypeId ) throws RelationshipTypeIdNotFoundKernelException\n    {\n        try\n        {\n            return relationshipTokenHolder.getTokenById( relationshipTypeId ).name();\n        }\n        catch ( TokenNotFoundException e )\n        {\n            throw new RelationshipTypeIdNotFoundKernelException( relationshipTypeId, e );\n        }\n    }\n\n    @Override\n    public int relationshipTypeGetOrCreateForName( String relationshipTypeName )\n    {\n        return relationshipTokenHolder.getOrCreateId( relationshipTypeName );\n    }\n\n    @Override\n    public <EXCEPTION extends Exception> void relationshipVisit( long relationshipId,\n            RelationshipVisitor<EXCEPTION> relationshipVisitor ) throws EntityNotFoundException, EXCEPTION\n    {\n        // TODO Please don't create a record for this, it's ridiculous\n        RelationshipRecord record;\n        try\n        {\n            record = relationshipStore.getRecord( relationshipId );\n        }\n        catch ( InvalidRecordException e )\n        {\n            throw new EntityNotFoundException( EntityType.RELATIONSHIP, relationshipId );\n        }\n        relationshipVisitor.visit( relationshipId, record.getType(), record.getFirstNode(), record.getSecondNode() );\n    }\n\n    @Override\n    public long highestNodeIdInUse()\n    {\n        return nodeStore.getHighestPossibleIdInUse();\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetAll()\n    {\n        return new PrimitiveLongBaseIterator()\n        {\n            private final NodeStore store = neoStore.getNodeStore();\n            private long highId = store.getHighestPossibleIdInUse();\n            private long currentId;\n            private final NodeRecord reusableNodeRecord = new NodeRecord( -1 ); // reused\n\n            @Override\n            protected boolean fetchNext()\n            {\n                while ( true )\n                {   // This outer loop is for checking if highId has changed since we started.\n                    while ( currentId <= highId )\n                    {\n                        try\n                        {\n                            NodeRecord record = store.loadRecord( currentId, reusableNodeRecord );\n                            if ( record != null && record.inUse() )\n                            {\n                                return next( record.getId() );\n                            }\n                        }\n                        finally\n                        {\n                            currentId++;\n                        }\n                    }\n\n                    long newHighId = store.getHighestPossibleIdInUse();\n                    if ( newHighId > highId )\n                    {\n                        highId = newHighId;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                return false;\n            }\n        };\n    }\n\n    @Override\n    public Cursor<NodeItem> nodesGetAllCursor( StoreStatement statement )\n    {\n        return statement.acquireIteratorNodeCursor( new AllStoreIdIterator( neoStore.getNodeStore() ) );\n    }\n\n    @Override\n    public RelationshipIterator relationshipsGetAll()\n    {\n        return new RelationshipIterator.BaseIterator()\n        {\n            private final RelationshipStore store = neoStore.getRelationshipStore();\n            private long highId = store.getHighestPossibleIdInUse();\n            private long currentId;\n            private final RelationshipRecord reusableRecord = new RelationshipRecord( -1 ); // reused\n\n            @Override\n            protected boolean fetchNext()\n            {\n                while ( true )\n                {   // This outer loop is for checking if highId has changed since we started.\n                    while ( currentId <= highId )\n                    {\n                        try\n                        {\n                            if ( store.fillRecord( currentId, reusableRecord, CHECK ) && reusableRecord.inUse() )\n                            {\n                                return next( reusableRecord.getId() );\n                            }\n                        }\n                        finally\n                        {\n                            currentId++;\n                        }\n                    }\n\n                    long newHighId = store.getHighestPossibleIdInUse();\n                    if ( newHighId > highId )\n                    {\n                        highId = newHighId;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                return false;\n            }\n\n            @Override\n            public <EXCEPTION extends Exception> boolean relationshipVisit( long relationshipId,\n                    RelationshipVisitor<EXCEPTION> visitor ) throws EXCEPTION\n            {\n                visitor.visit( relationshipId, reusableRecord.getType(),\n                        reusableRecord.getFirstNode(), reusableRecord.getSecondNode() );\n                return false;\n            }\n        };\n    }\n\n    @Override\n    public Cursor<RelationshipItem> relationshipsGetAllCursor( StoreStatement storeStatement )\n    {\n        return storeStatement.acquireIteratorRelationshipCursor(\n                new AllStoreIdIterator( neoStore.getRelationshipStore() ) );\n    }\n\n    @Override\n    public long reserveNode()\n    {\n        return nodeStore.nextId();\n    }\n\n    @Override\n    public long reserveRelationship()\n    {\n        return relationshipStore.nextId();\n    }\n\n    @Override\n    public void releaseNode( long id )\n    {\n        nodeStore.freeId( id );\n    }\n\n    @Override\n    public void releaseRelationship( long id )\n    {\n        relationshipStore.freeId( id );\n    }\n\n    @Override\n    public long countsForNode( int labelId )\n    {\n        return counts.nodeCount( labelId, newDoubleLongRegister() ).readSecond();\n    }\n\n    @Override\n    public long countsForRelationship( int startLabelId, int typeId, int endLabelId )\n    {\n        if ( !(startLabelId == ReadOperations.ANY_LABEL || endLabelId == ReadOperations.ANY_LABEL) )\n        {\n            throw new UnsupportedOperationException( \"not implemented\" );\n        }\n        return counts.relationshipCount( startLabelId, typeId, endLabelId, newDoubleLongRegister() ).readSecond();\n    }\n\n    private class AllStoreIdIterator extends PrimitiveLongBaseIterator\n    {\n        private final CommonAbstractStore store;\n        private long highId;\n        private long currentId;\n\n        public AllStoreIdIterator( CommonAbstractStore store )\n        {\n            this.store = store;\n            highId = store.getHighestPossibleIdInUse();\n        }\n\n        @Override\n        protected boolean fetchNext()\n        {\n            while ( true )\n            {   // This outer loop is for checking if highId has changed since we started.\n                if ( currentId <= highId )\n                {\n                    try\n                    {\n                        return next( currentId );\n                    }\n                    finally\n                    {\n                        currentId++;\n                    }\n          ",
    "ID_15": "public class DiskLayer implements StoreReadLayer\n{\n    private static final Function<PropertyConstraintRule, PropertyConstraint> RULE_TO_CONSTRAINT =\n            new Function<PropertyConstraintRule, PropertyConstraint>()\n            {\n                @Override\n                public PropertyConstraint apply( PropertyConstraintRule rule )\n                {\n                    // We can use propertyKeyId straight up here, without reading from the record, since we have\n                    // verified that it has that propertyKeyId in the predicate. And since we currently only support\n                    // uniqueness on single properties, there is nothing else to pass in to UniquenessConstraint.\n                    return rule.toConstraint();\n                }\n            };\n\n    private static final Function<NodePropertyConstraintRule,NodePropertyConstraint> NODE_RULE_TO_CONSTRAINT =\n            new Function<NodePropertyConstraintRule,NodePropertyConstraint>()\n            {\n                @Override\n                public NodePropertyConstraint apply( NodePropertyConstraintRule rule )\n                {\n                    return rule.toConstraint();\n                }\n            };\n\n    private static final Function<RelationshipPropertyConstraintRule,RelationshipPropertyConstraint> REL_RULE_TO_CONSTRAINT =\n            new Function<RelationshipPropertyConstraintRule,RelationshipPropertyConstraint>()\n            {\n                @Override\n                public RelationshipPropertyConstraint apply( RelationshipPropertyConstraintRule rule )\n                {\n                    return rule.toConstraint();\n                }\n            };\n\n    // These token holders should perhaps move to the cache layer.. not really any reason to have them here?\n    private final PropertyKeyTokenHolder propertyKeyTokenHolder;\n    private final LabelTokenHolder labelTokenHolder;\n    private final RelationshipTypeTokenHolder relationshipTokenHolder;\n\n    private final NeoStore neoStore;\n    private final IndexingService indexService;\n    private final NodeStore nodeStore;\n    private final RelationshipGroupStore relationshipGroupStore;\n    private final RelationshipStore relationshipStore;\n    private final SchemaStorage schemaStorage;\n    private final CountsAccessor counts;\n    private final PropertyLoader propertyLoader;\n\n    public DiskLayer( PropertyKeyTokenHolder propertyKeyTokenHolder, LabelTokenHolder labelTokenHolder,\n            RelationshipTypeTokenHolder relationshipTokenHolder, SchemaStorage schemaStorage, NeoStore neoStore,\n            IndexingService indexService )\n    {\n        this.relationshipTokenHolder = relationshipTokenHolder;\n        this.schemaStorage = schemaStorage;\n        this.indexService = indexService;\n        this.propertyKeyTokenHolder = propertyKeyTokenHolder;\n        this.labelTokenHolder = labelTokenHolder;\n        this.neoStore = neoStore;\n        this.nodeStore = this.neoStore.getNodeStore();\n        this.relationshipStore = this.neoStore.getRelationshipStore();\n        this.relationshipGroupStore = this.neoStore.getRelationshipGroupStore();\n        this.counts = neoStore.getCounts();\n        this.propertyLoader = new PropertyLoader( neoStore );\n\n    }\n\n    @Override\n    public StoreStatement acquireStatement()\n    {\n        return neoStore.acquireStatement();\n    }\n\n    @Override\n    public int labelGetOrCreateForName( String label ) throws TooManyLabelsException\n    {\n        try\n        {\n            return labelTokenHolder.getOrCreateId( label );\n        }\n        catch ( TransactionFailureException e )\n        {\n            // Temporary workaround for the property store based label\n            // implementation. Actual\n            // implementation should not depend on internal kernel exception\n            // messages like this.\n            if ( e.getCause() instanceof UnderlyingStorageException\n                    && e.getCause().getMessage().equals( \"Id capacity exceeded\" ) )\n            {\n                throw new TooManyLabelsException( e );\n            }\n            throw e;\n        }\n    }\n\n    @Override\n    public int labelGetForName( String label )\n    {\n        return labelTokenHolder.getIdByName( label );\n    }\n\n    @Override\n    public PrimitiveIntIterator nodeGetLabels( StoreStatement statement, long nodeId ) throws EntityNotFoundException\n    {\n        try ( Cursor<NodeItem> nodeCursor = statement.acquireSingleNodeCursor( nodeId ) )\n        {\n            if ( nodeCursor.next() )\n            {\n                return Cursors.intIterator( nodeCursor.get().labels(), LabelItem.GET_LABEL );\n            }\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n    }\n\n    @Override\n    public RelationshipIterator nodeListRelationships( StoreStatement statement,\n            long nodeId,\n            Direction direction )\n            throws EntityNotFoundException\n    {\n        return nodeListRelationships( statement, nodeId, direction, null );\n    }\n\n    @Override\n    public RelationshipIterator nodeListRelationships( final StoreStatement statement,\n            long nodeId,\n            Direction direction,\n            int[] relTypes )\n            throws EntityNotFoundException\n    {\n        try ( final Cursor<NodeItem> nodeCursor = statement.acquireSingleNodeCursor( nodeId ) )\n        {\n            if ( nodeCursor.next() )\n            {\n                return new CursorRelationshipIterator( nodeCursor.get().relationships( direction, relTypes ) );\n            }\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n    }\n\n    @Override\n    public int nodeGetDegree( StoreStatement statement,\n            long nodeId,\n            Direction direction ) throws EntityNotFoundException\n    {\n        NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n\n        if ( node.isDense() )\n        {\n            long groupId = node.getNextRel();\n            long count = 0;\n            while ( groupId != Record.NO_NEXT_RELATIONSHIP.intValue() )\n            {\n                RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                count += nodeDegreeByDirection( nodeId, group, direction );\n                groupId = group.getNext();\n            }\n            return (int) count;\n        }\n\n        return count( nodeListRelationships( statement, nodeId, direction ) );\n    }\n\n    @Override\n    public int nodeGetDegree( StoreStatement statement, long nodeId,\n            Direction direction,\n            int relType ) throws EntityNotFoundException\n    {\n        NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n\n        if ( node.isDense() )\n        {\n            long groupId = node.getNextRel();\n            while ( groupId != Record.NO_NEXT_RELATIONSHIP.intValue() )\n            {\n                RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                if ( group.getType() == relType )\n                {\n                    return (int) nodeDegreeByDirection( nodeId, group, direction );\n                }\n                groupId = group.getNext();\n            }\n            return 0;\n        }\n\n        return count( nodeListRelationships( statement, nodeId, direction, new int[]{relType} ) );\n    }\n\n    private long nodeDegreeByDirection( long nodeId, RelationshipGroupRecord group, Direction direction )\n    {\n        long loopCount = countByFirstPrevPointer( nodeId, group.getFirstLoop() );\n        switch ( direction )\n        {\n            case OUTGOING:\n                return countByFirstPrevPointer( nodeId, group.getFirstOut() ) + loopCount;\n            case INCOMING:\n                return countByFirstPrevPointer( nodeId, group.getFirstIn() ) + loopCount;\n            case BOTH:\n                return countByFirstPrevPointer( nodeId, group.getFirstOut() ) +\n                        countByFirstPrevPointer( nodeId, group.getFirstIn() ) + loopCount;\n            default:\n                throw new IllegalArgumentException( direction.name() );\n        }\n    }\n\n    @Override\n    public boolean nodeVisitDegrees( StoreStatement statement, final long nodeId, final DegreeVisitor visitor )\n    {\n        NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            return true;\n        }\n\n        if ( node.isDense() )\n        {\n            long groupId = node.getNextRel();\n            while ( groupId != Record.NO_NEXT_RELATIONSHIP.intValue() )\n            {\n                RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                long outCount = countByFirstPrevPointer( nodeId, group.getFirstOut() );\n                long inCount = countByFirstPrevPointer( nodeId, group.getFirstIn() );\n                long loopCount = countByFirstPrevPointer( nodeId, group.getFirstLoop() );\n                visitor.visitDegree( group.getType(), (int) (outCount + loopCount), (int) (inCount + loopCount) );\n                groupId = group.getNext();\n            }\n        }\n        else\n        {\n            final PrimitiveIntObjectMap<int[]> degrees = Primitive.intObjectMap( 5 );\n            RelationshipVisitor<RuntimeException> typeVisitor = new RelationshipVisitor<RuntimeException>()\n            {\n                @Override\n                public void visit( long relId, int type, long startNode, long endNode ) throws RuntimeException\n                {\n                    int[] byType = degrees.get( type );\n                    if ( byType == null )\n                    {\n                        degrees.put( type, byType = new int[3] );\n                    }\n                    byType[directionOf( nodeId, relId, startNode, endNode ).ordinal()]++;\n                }\n            };\n            RelationshipIterator relationships;\n            try\n            {\n                relationships = nodeListRelationships( statement, nodeId, Direction.BOTH );\n                while ( relationships.hasNext() )\n                {\n                    relationships.relationshipVisit( relationships.next(), typeVisitor );\n                }\n\n                degrees.visitEntries( new PrimitiveIntObjectVisitor<int[], RuntimeException>()\n                {\n                    @Override\n                    public boolean visited( int type, int[] degrees /*out,in,loop*/ ) throws RuntimeException\n                    {\n                        visitor.visitDegree( type, degrees[0] + degrees[2], degrees[1] + degrees[2] );\n                        return false;\n                    }\n                } );\n            }\n            catch ( EntityNotFoundException e )\n            {\n                // OK?\n            }\n        }\n        return false;\n    }\n\n    private Direction directionOf( long nodeId, long relationshipId, long startNode, long endNode )\n    {\n        if ( startNode == nodeId )\n        {\n            return endNode == nodeId ? Direction.BOTH : Direction.OUTGOING;\n        }\n        if ( endNode == nodeId )\n        {\n            return Direction.INCOMING;\n        }\n        throw new InvalidRecordException( \"Node \" + nodeId + \" neither start nor end node of relationship \" +\n                relationshipId + \" with startNode:\" + startNode + \" and endNode:\" + endNode );\n    }\n\n    private long countByFirstPrevPointer( long nodeId, long relationshipId )\n    {\n        if ( relationshipId == Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            return 0;\n        }\n        RelationshipRecord record = relationshipStore.getRecord( relationshipId );\n        if ( record.getFirstNode() == nodeId )\n        {\n            return record.getFirstPrevRel();\n        }\n        if ( record.getSecondNode() == nodeId )\n        {\n            return record.getSecondPrevRel();\n        }\n        throw new InvalidRecordException( \"Node \" + nodeId + \" neither start nor end node of \" + record );\n    }\n\n    @Override\n    public PrimitiveIntIterator nodeGetRelationshipTypes( StoreStatement statement,\n            long nodeId ) throws EntityNotFoundException\n    {\n        final NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n\n        if ( node.isDense() )\n        {\n            return new PrimitiveIntCollections.PrimitiveIntBaseIterator()\n            {\n                private long groupId = node.getNextRel();\n\n                @Override\n                protected boolean fetchNext()\n                {\n                    if ( groupId == Record.NO_NEXT_RELATIONSHIP.intValue() )\n                    {\n                        return false;\n                    }\n\n                    RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                    try\n                    {\n                        return next( group.getType() );\n                    }\n                    finally\n                    {\n                        groupId = group.getNext();\n                    }\n                }\n            };\n        }\n\n        final PrimitiveIntSet types = Primitive.intSet( 5 );\n        RelationshipVisitor<RuntimeException> visitor = new RelationshipVisitor<RuntimeException>()\n        {\n            @Override\n            public void visit( long relId, int type, long startNode, long endNode ) throws RuntimeException\n            {\n                types.add( type );\n            }\n        };\n        RelationshipIterator relationships = nodeListRelationships( statement, nodeId, Direction.BOTH );\n        while ( relationships.hasNext() )\n        {\n            relationships.relationshipVisit( relationships.next(), visitor );\n        }\n        return types.iterator();\n    }\n\n    @Override\n    public String labelGetName( int labelId ) throws LabelNotFoundKernelException\n    {\n        try\n        {\n            return labelTokenHolder.getTokenById( labelId ).name();\n        }\n        catch ( TokenNotFoundException e )\n        {\n            throw new LabelNotFoundKernelException( \"Label by id \" + labelId, e );\n        }\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetForLabel( KernelStatement state, int labelId )\n    {\n        return state.getLabelScanReader().nodesWithLabel( labelId );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexSeek( KernelStatement state, IndexDescriptor index,\n            Object value ) throws IndexNotFoundKernelException\n    {\n        IndexReader reader = state.getIndexReader( index );\n        return reader.seek( value );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexRangeSeekByNumber( KernelStatement statement,\n                                                                     IndexDescriptor index,\n                                                                     Number lower, boolean includeLower,\n                                                                     Number upper, boolean includeUpper )\n            throws IndexNotFoundKernelException\n\n    {\n        IndexReader reader = statement.getIndexReader( index );\n        return reader.rangeSeekByNumber( lower, includeLower, upper, includeUpper );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexRangeSeekByString( KernelStatement statement,\n                                                                     IndexDescriptor index,\n                                                                     String lower, boolean includeLower,\n                                                                     String upper, boolean includeUpper )\n            throws IndexNotFoundKernelException\n\n    {\n        IndexReader reader = statement.getIndexReader( index );\n        return reader.rangeSeekByString( lower, includeLower, upper, includeUpper );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexRangeSeekByPrefix( KernelStatement state,\n                                                                     IndexDescriptor index,\n                                                                     String prefix )\n            throws IndexNotFoundKernelException\n    {\n        IndexReader reader = state.getIndexReader( index );\n        return reader.rangeSeekByPrefix( prefix );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexScan( KernelStatement state, IndexDescriptor index ) throws\n            IndexNotFoundKernelException\n    {\n        IndexReader reader = state.getIndexReader( index );\n        return reader.scan();\n    }\n\n    @Override\n    public IndexDescriptor indexesGetForLabelAndPropertyKey( int labelId, int propertyKey )\n    {\n        return descriptor( schemaStorage.indexRule( labelId, propertyKey ) );\n    }\n\n    private static IndexDescriptor descriptor( IndexRule ruleRecord )\n    {\n        return new IndexDescriptor( ruleRecord.getLabel(), ruleRecord.getPropertyKey() );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> indexesGetForLabel( int labelId )\n    {\n        return getIndexDescriptorsFor( indexRules( labelId ) );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> indexesGetAll()\n    {\n        return getIndexDescriptorsFor( INDEX_RULES );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> uniqueIndexesGetForLabel( int labelId )\n    {\n        return getIndexDescriptorsFor( constraintIndexRules( labelId ) );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> uniqueIndexesGetAll()\n    {\n        return getIndexDescriptorsFor( CONSTRAINT_INDEX_RULES );\n    }\n\n    private static Predicate<SchemaRule> indexRules( final int labelId )\n    {\n        return new Predicate<SchemaRule>()\n        {\n\n            @Override\n            public boolean test( SchemaRule rule )\n            {\n                return rule.getLabel() == labelId && rule.getKind() == SchemaRule.Kind.INDEX_RULE;\n            }\n        };\n    }\n\n    private static Predicate<SchemaRule> constraintIndexRules( final int labelId )\n    {\n        return new Predicate<SchemaRule>()\n        {\n\n            @Override\n            public boolean test( SchemaRule rule )\n            {\n                return rule.getLabel() == labelId && rule.getKind() == SchemaRule.Kind.CONSTRAINT_INDEX_RULE;\n            }\n        };\n    }\n\n    private static final Predicate<SchemaRule> INDEX_RULES = new Predicate<SchemaRule>()\n    {\n\n        @Override\n        public boolean test( SchemaRule rule )\n        {\n            return rule.getKind() == SchemaRule.Kind.INDEX_RULE;\n        }\n    }, CONSTRAINT_INDEX_RULES = new Predicate<SchemaRule>()\n    {\n\n        @Override\n        public boolean test( SchemaRule rule )\n        {\n            return rule.getKind() == SchemaRule.Kind.CONSTRAINT_INDEX_RULE;\n        }\n    };\n\n    private Iterator<IndexDescriptor> getIndexDescriptorsFor( Predicate<SchemaRule> filter )\n    {\n        Iterator<SchemaRule> filtered = filter( filter, neoStore.getSchemaStore().loadAllSchemaRules() );\n\n        return map( new Function<SchemaRule, IndexDescriptor>()\n        {\n\n            @Override\n            public IndexDescriptor apply( SchemaRule from )\n            {\n                return descriptor( (IndexRule) from );\n            }\n        }, filtered );\n    }\n\n    @Override\n    public Long indexGetOwningUniquenessConstraintId( IndexDescriptor index )\n            throws SchemaRuleNotFoundException\n    {\n        return schemaStorage.indexRule( index.getLabelId(), index.getPropertyKeyId() ).getOwningConstraint();\n    }\n\n    @Override\n    public IndexRule indexRule( IndexDescriptor index, SchemaStorage.IndexRuleKind kind )\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public long indexGetCommittedId( IndexDescriptor index, SchemaStorage.IndexRuleKind kind )\n            throws SchemaRuleNotFoundException\n    {\n        return schemaStorage.indexRule( index.getLabelId(), index.getPropertyKeyId() ).getId();\n    }\n\n    @Override\n    public InternalIndexState indexGetState( IndexDescriptor descriptor )\n            throws IndexNotFoundKernelException\n    {\n        return indexService.getIndexProxy( descriptor ).getState();\n    }\n\n    @Override\n    public long indexSize( IndexDescriptor descriptor ) throws IndexNotFoundKernelException\n    {\n        return indexService.indexSize( descriptor );\n    }\n\n    @Override\n    public double indexUniqueValuesPercentage( IndexDescriptor descriptor ) throws IndexNotFoundKernelException\n    {\n        return indexService.indexUniqueValuesPercentage( descriptor );\n    }\n\n    @Override\n    public String indexGetFailure( IndexDescriptor descriptor ) throws IndexNotFoundKernelException\n    {\n        return indexService.getIndexProxy( descriptor ).getPopulationFailure().asString();\n    }\n\n    @Override\n    public Iterator<NodePropertyConstraint> constraintsGetForLabelAndPropertyKey( int labelId, final int propertyKeyId )\n    {\n        return schemaStorage.schemaRulesForNodes( NODE_RULE_TO_CONSTRAINT, NodePropertyConstraintRule.class,\n                labelId, new Predicate<NodePropertyConstraintRule>()\n                {\n                    @Override\n                    public boolean test( NodePropertyConstraintRule rule )\n                    {\n                        return rule.containsPropertyKeyId( propertyKeyId );\n                    }\n                } );\n    }\n\n    @Override\n    public Iterator<NodePropertyConstraint> constraintsGetForLabel( int labelId )\n    {\n        return schemaStorage.schemaRulesForNodes( NODE_RULE_TO_CONSTRAINT, NodePropertyConstraintRule.class,\n                labelId, Predicates.<NodePropertyConstraintRule>alwaysTrue() );\n    }\n\n    @Override\n    public Iterator<RelationshipPropertyConstraint> constraintsGetForRelationshipTypeAndPropertyKey( int typeId,\n            final int propertyKeyId )\n    {\n        return schemaStorage.schemaRulesForRelationships( REL_RULE_TO_CONSTRAINT,\n                RelationshipPropertyConstraintRule.class, typeId, new Predicate<RelationshipPropertyConstraintRule>()\n                {\n                    @Override\n                    public boolean test( RelationshipPropertyConstraintRule rule )\n                    {\n                        return rule.containsPropertyKeyId( propertyKeyId );\n                    }\n                } );\n    }\n\n    @Override\n    public Iterator<RelationshipPropertyConstraint> constraintsGetForRelationshipType( int typeId )\n    {\n        return schemaStorage.schemaRulesForRelationships( REL_RULE_TO_CONSTRAINT,\n                RelationshipPropertyConstraintRule.class, typeId,\n                Predicates.<RelationshipPropertyConstraintRule>alwaysTrue() );\n    }\n\n    @Override\n    public Iterator<PropertyConstraint> constraintsGetAll()\n    {\n        return schemaStorage.schemaRules( RULE_TO_CONSTRAINT, PropertyConstraintRule.class );\n    }\n\n    @Override\n    public PrimitiveLongResourceIterator nodeGetFromUniqueIndexSeek( KernelStatement state, IndexDescriptor descriptor,\n            Object value ) throws IndexNotFoundKernelException, IndexBrokenKernelException\n    {\n        /* Here we have an intricate scenario where we need to return the PrimitiveLongIterator\n         * since subsequent filtering will happen outside, but at the same time have the ability to\n         * close the IndexReader when done iterating over the lookup result. This is because we get\n         * a fresh reader that isn't associated with the current transaction and hence will not be\n         * automatically closed. */\n        IndexReader reader = state.getFreshIndexReader( descriptor );\n        return resourceIterator( reader.seek( value ), reader );\n    }\n\n    @Override\n    public int propertyKeyGetOrCreateForName( String propertyKey )\n    {\n        return propertyKeyTokenHolder.getOrCreateId( propertyKey );\n    }\n\n    @Override\n    public int propertyKeyGetForName( String propertyKey )\n    {\n        return propertyKeyTokenHolder.getIdByName( propertyKey );\n    }\n\n    @Override\n    public String propertyKeyGetName( int propertyKeyId )\n            throws PropertyKeyIdNotFoundKernelException\n    {\n        try\n        {\n            return propertyKeyTokenHolder.getTokenById( propertyKeyId ).name();\n        }\n        catch ( TokenNotFoundException e )\n        {\n            throw new PropertyKeyIdNotFoundKernelException( propertyKeyId, e );\n        }\n    }\n\n    @Override\n    public PrimitiveIntIterator graphGetPropertyKeys( KernelStatement state )\n    {\n        return new PropertyKeyIdIterator( propertyLoader.graphLoadProperties( new IteratingPropertyReceiver() ) );\n    }\n\n    @Override\n    public Object graphGetProperty( int propertyKeyId )\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Iterator<DefinedProperty> graphGetAllProperties()\n    {\n        return propertyLoader.graphLoadProperties( new IteratingPropertyReceiver() );\n    }\n\n    @Override\n    public Iterator<Token> propertyKeyGetAllTokens()\n    {\n        return propertyKeyTokenHolder.getAllTokens().iterator();\n    }\n\n    @Override\n    public Iterator<Token> labelsGetAllTokens()\n    {\n        return labelTokenHolder.getAllTokens().iterator();\n    }\n\n    @Override\n    public int relationshipTypeGetForName( String relationshipTypeName )\n    {\n        return relationshipTokenHolder.getIdByName( relationshipTypeName );\n    }\n\n    @Override\n    public String relationshipTypeGetName( int relationshipTypeId ) throws RelationshipTypeIdNotFoundKernelException\n    {\n        try\n        {\n            return relationshipTokenHolder.getTokenById( relationshipTypeId ).name();\n        }\n        catch ( TokenNotFoundException e )\n        {\n            throw new RelationshipTypeIdNotFoundKernelException( relationshipTypeId, e );\n        }\n    }\n\n    @Override\n    public int relationshipTypeGetOrCreateForName( String relationshipTypeName )\n    {\n        return relationshipTokenHolder.getOrCreateId( relationshipTypeName );\n    }\n\n    @Override\n    public <EXCEPTION extends Exception> void relationshipVisit( long relationshipId,\n            RelationshipVisitor<EXCEPTION> relationshipVisitor ) throws EntityNotFoundException, EXCEPTION\n    {\n        // TODO Please don't create a record for this, it's ridiculous\n        RelationshipRecord record;\n        try\n        {\n            record = relationshipStore.getRecord( relationshipId );\n        }\n        catch ( InvalidRecordException e )\n        {\n            throw new EntityNotFoundException( EntityType.RELATIONSHIP, relationshipId );\n        }\n        relationshipVisitor.visit( relationshipId, record.getType(), record.getFirstNode(), record.getSecondNode() );\n    }\n\n    @Override\n    public long highestNodeIdInUse()\n    {\n        return nodeStore.getHighestPossibleIdInUse();\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetAll()\n    {\n        return new PrimitiveLongBaseIterator()\n        {\n            private final NodeStore store = neoStore.getNodeStore();\n            private long highId = store.getHighestPossibleIdInUse();\n            private long currentId;\n            private final NodeRecord reusableNodeRecord = new NodeRecord( -1 ); // reused\n\n            @Override\n            protected boolean fetchNext()\n            {\n                while ( true )\n                {   // This outer loop is for checking if highId has changed since we started.\n                    while ( currentId <= highId )\n                    {\n                        try\n                        {\n                            NodeRecord record = store.loadRecord( currentId, reusableNodeRecord );\n                            if ( record != null && record.inUse() )\n                            {\n                                return next( record.getId() );\n                            }\n                        }\n                        finally\n                        {\n                            currentId++;\n                        }\n                    }\n\n                    long newHighId = store.getHighestPossibleIdInUse();\n                    if ( newHighId > highId )\n                    {\n                        highId = newHighId;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                return false;\n            }\n        };\n    }\n\n    @Override\n    public Cursor<NodeItem> nodesGetAllCursor( StoreStatement statement )\n    {\n        return statement.acquireIteratorNodeCursor( new AllStoreIdIterator( neoStore.getNodeStore() ) );\n    }\n\n    @Override\n    public RelationshipIterator relationshipsGetAll()\n    {\n        return new RelationshipIterator.BaseIterator()\n        {\n            private final RelationshipStore store = neoStore.getRelationshipStore();\n            private long highId = store.getHighestPossibleIdInUse();\n            private long currentId;\n            private final RelationshipRecord reusableRecord = new RelationshipRecord( -1 ); // reused\n\n            @Override\n            protected boolean fetchNext()\n            {\n                while ( true )\n                {   // This outer loop is for checking if highId has changed since we started.\n                    while ( currentId <= highId )\n                    {\n                        try\n                        {\n                            if ( store.fillRecord( currentId, reusableRecord, CHECK ) && reusableRecord.inUse() )\n                            {\n                                return next( reusableRecord.getId() );\n                            }\n                        }\n                        finally\n                        {\n                            currentId++;\n                        }\n                    }\n\n                    long newHighId = store.getHighestPossibleIdInUse();\n                    if ( newHighId > highId )\n                    {\n                        highId = newHighId;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                return false;\n            }\n\n            @Override\n            public <EXCEPTION extends Exception> boolean relationshipVisit( long relationshipId,\n                    RelationshipVisitor<EXCEPTION> visitor ) throws EXCEPTION\n            {\n                visitor.visit( relationshipId, reusableRecord.getType(),\n                        reusableRecord.getFirstNode(), reusableRecord.getSecondNode() );\n                return false;\n            }\n        };\n    }\n\n    @Override\n    public Cursor<RelationshipItem> relationshipsGetAllCursor( StoreStatement storeStatement )\n    {\n        return storeStatement.acquireIteratorRelationshipCursor(\n                new AllStoreIdIterator( neoStore.getRelationshipStore() ) );\n    }\n\n    @Override\n    public long reserveNode()\n    {\n        return nodeStore.nextId();\n    }\n\n    @Override\n    public long reserveRelationship()\n    {\n        return relationshipStore.nextId();\n    }\n\n    @Override\n    public void releaseNode( long id )\n    {\n        nodeStore.freeId( id );\n    }\n\n    @Override\n    public void releaseRelationship( long id )\n    {\n        relationshipStore.freeId( id );\n    }\n\n    @Override\n    public long countsForNode( int labelId )\n    {\n        return counts.nodeCount( labelId, newDoubleLongRegister() ).readSecond();\n    }\n\n    @Override\n    public long countsForRelationship( int startLabelId, int typeId, int endLabelId )\n    {\n        if ( !(startLabelId == ReadOperations.ANY_LABEL || endLabelId == ReadOperations.ANY_LABEL) )\n        {\n            throw new UnsupportedOperationException( \"not implemented\" );\n        }\n        return counts.relationshipCount( startLabelId, typeId, endLabelId, newDoubleLongRegister() ).readSecond();\n    }\n\n    private class AllStoreIdIterator extends PrimitiveLongBaseIterator\n    {\n        private final CommonAbstractStore store;\n        private long highId;\n        private long currentId;\n\n        public AllStoreIdIterator( CommonAbstractStore store )\n        {\n            this.store = store;\n            highId = store.getHighestPossibleIdInUse();\n        }\n\n        @Override\n        protected boolean fetchNext()\n        {\n            while ( true )\n            {   // This outer loop is for checking if highId has changed since we started.\n                if ( currentId <= highId )\n                {\n                    try\n                    {\n                        return next( currentId );\n                    }\n                    finally\n                    {\n                        currentId++;\n                    }\n          ",
    "ID_16": "public class DiskLayer implements StoreReadLayer\n{\n    private static final Function<PropertyConstraintRule, PropertyConstraint> RULE_TO_CONSTRAINT =\n            new Function<PropertyConstraintRule, PropertyConstraint>()\n            {\n                @Override\n                public PropertyConstraint apply( PropertyConstraintRule rule )\n                {\n                    // We can use propertyKeyId straight up here, without reading from the record, since we have\n                    // verified that it has that propertyKeyId in the predicate. And since we currently only support\n                    // uniqueness on single properties, there is nothing else to pass in to UniquenessConstraint.\n                    return rule.toConstraint();\n                }\n            };\n\n    private static final Function<NodePropertyConstraintRule,NodePropertyConstraint> NODE_RULE_TO_CONSTRAINT =\n            new Function<NodePropertyConstraintRule,NodePropertyConstraint>()\n            {\n                @Override\n                public NodePropertyConstraint apply( NodePropertyConstraintRule rule )\n                {\n                    return rule.toConstraint();\n                }\n            };\n\n    private static final Function<RelationshipPropertyConstraintRule,RelationshipPropertyConstraint> REL_RULE_TO_CONSTRAINT =\n            new Function<RelationshipPropertyConstraintRule,RelationshipPropertyConstraint>()\n            {\n                @Override\n                public RelationshipPropertyConstraint apply( RelationshipPropertyConstraintRule rule )\n                {\n                    return rule.toConstraint();\n                }\n            };\n\n    // These token holders should perhaps move to the cache layer.. not really any reason to have them here?\n    private final PropertyKeyTokenHolder propertyKeyTokenHolder;\n    private final LabelTokenHolder labelTokenHolder;\n    private final RelationshipTypeTokenHolder relationshipTokenHolder;\n\n    private final NeoStore neoStore;\n    private final IndexingService indexService;\n    private final NodeStore nodeStore;\n    private final RelationshipGroupStore relationshipGroupStore;\n    private final RelationshipStore relationshipStore;\n    private final SchemaStorage schemaStorage;\n    private final CountsAccessor counts;\n    private final PropertyLoader propertyLoader;\n\n    public DiskLayer( PropertyKeyTokenHolder propertyKeyTokenHolder, LabelTokenHolder labelTokenHolder,\n            RelationshipTypeTokenHolder relationshipTokenHolder, SchemaStorage schemaStorage, NeoStore neoStore,\n            IndexingService indexService )\n    {\n        this.relationshipTokenHolder = relationshipTokenHolder;\n        this.schemaStorage = schemaStorage;\n        this.indexService = indexService;\n        this.propertyKeyTokenHolder = propertyKeyTokenHolder;\n        this.labelTokenHolder = labelTokenHolder;\n        this.neoStore = neoStore;\n        this.nodeStore = this.neoStore.getNodeStore();\n        this.relationshipStore = this.neoStore.getRelationshipStore();\n        this.relationshipGroupStore = this.neoStore.getRelationshipGroupStore();\n        this.counts = neoStore.getCounts();\n        this.propertyLoader = new PropertyLoader( neoStore );\n\n    }\n\n    @Override\n    public StoreStatement acquireStatement()\n    {\n        return neoStore.acquireStatement();\n    }\n\n    @Override\n    public int labelGetOrCreateForName( String label ) throws TooManyLabelsException\n    {\n        try\n        {\n            return labelTokenHolder.getOrCreateId( label );\n        }\n        catch ( TransactionFailureException e )\n        {\n            // Temporary workaround for the property store based label\n            // implementation. Actual\n            // implementation should not depend on internal kernel exception\n            // messages like this.\n            if ( e.getCause() instanceof UnderlyingStorageException\n                    && e.getCause().getMessage().equals( \"Id capacity exceeded\" ) )\n            {\n                throw new TooManyLabelsException( e );\n            }\n            throw e;\n        }\n    }\n\n    @Override\n    public int labelGetForName( String label )\n    {\n        return labelTokenHolder.getIdByName( label );\n    }\n\n    @Override\n    public PrimitiveIntIterator nodeGetLabels( StoreStatement statement, long nodeId ) throws EntityNotFoundException\n    {\n        try ( Cursor<NodeItem> nodeCursor = statement.acquireSingleNodeCursor( nodeId ) )\n        {\n            if ( nodeCursor.next() )\n            {\n                return Cursors.intIterator( nodeCursor.get().labels(), LabelItem.GET_LABEL );\n            }\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n    }\n\n    @Override\n    public RelationshipIterator nodeListRelationships( StoreStatement statement,\n            long nodeId,\n            Direction direction )\n            throws EntityNotFoundException\n    {\n        return nodeListRelationships( statement, nodeId, direction, null );\n    }\n\n    @Override\n    public RelationshipIterator nodeListRelationships( final StoreStatement statement,\n            long nodeId,\n            Direction direction,\n            int[] relTypes )\n            throws EntityNotFoundException\n    {\n        try ( final Cursor<NodeItem> nodeCursor = statement.acquireSingleNodeCursor( nodeId ) )\n        {\n            if ( nodeCursor.next() )\n            {\n                return new CursorRelationshipIterator( nodeCursor.get().relationships( direction, relTypes ) );\n            }\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n    }\n\n    @Override\n    public int nodeGetDegree( StoreStatement statement,\n            long nodeId,\n            Direction direction ) throws EntityNotFoundException\n    {\n        NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n\n        if ( node.isDense() )\n        {\n            long groupId = node.getNextRel();\n            long count = 0;\n            while ( groupId != Record.NO_NEXT_RELATIONSHIP.intValue() )\n            {\n                RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                count += nodeDegreeByDirection( nodeId, group, direction );\n                groupId = group.getNext();\n            }\n            return (int) count;\n        }\n\n        return count( nodeListRelationships( statement, nodeId, direction ) );\n    }\n\n    @Override\n    public int nodeGetDegree( StoreStatement statement, long nodeId,\n            Direction direction,\n            int relType ) throws EntityNotFoundException\n    {\n        NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n\n        if ( node.isDense() )\n        {\n            long groupId = node.getNextRel();\n            while ( groupId != Record.NO_NEXT_RELATIONSHIP.intValue() )\n            {\n                RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                if ( group.getType() == relType )\n                {\n                    return (int) nodeDegreeByDirection( nodeId, group, direction );\n                }\n                groupId = group.getNext();\n            }\n            return 0;\n        }\n\n        return count( nodeListRelationships( statement, nodeId, direction, new int[]{relType} ) );\n    }\n\n    private long nodeDegreeByDirection( long nodeId, RelationshipGroupRecord group, Direction direction )\n    {\n        long loopCount = countByFirstPrevPointer( nodeId, group.getFirstLoop() );\n        switch ( direction )\n        {\n            case OUTGOING:\n                return countByFirstPrevPointer( nodeId, group.getFirstOut() ) + loopCount;\n            case INCOMING:\n                return countByFirstPrevPointer( nodeId, group.getFirstIn() ) + loopCount;\n            case BOTH:\n                return countByFirstPrevPointer( nodeId, group.getFirstOut() ) +\n                        countByFirstPrevPointer( nodeId, group.getFirstIn() ) + loopCount;\n            default:\n                throw new IllegalArgumentException( direction.name() );\n        }\n    }\n\n    @Override\n    public boolean nodeVisitDegrees( StoreStatement statement, final long nodeId, final DegreeVisitor visitor )\n    {\n        NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            return true;\n        }\n\n        if ( node.isDense() )\n        {\n            long groupId = node.getNextRel();\n            while ( groupId != Record.NO_NEXT_RELATIONSHIP.intValue() )\n            {\n                RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                long outCount = countByFirstPrevPointer( nodeId, group.getFirstOut() );\n                long inCount = countByFirstPrevPointer( nodeId, group.getFirstIn() );\n                long loopCount = countByFirstPrevPointer( nodeId, group.getFirstLoop() );\n                visitor.visitDegree( group.getType(), (int) (outCount + loopCount), (int) (inCount + loopCount) );\n                groupId = group.getNext();\n            }\n        }\n        else\n        {\n            final PrimitiveIntObjectMap<int[]> degrees = Primitive.intObjectMap( 5 );\n            RelationshipVisitor<RuntimeException> typeVisitor = new RelationshipVisitor<RuntimeException>()\n            {\n                @Override\n                public void visit( long relId, int type, long startNode, long endNode ) throws RuntimeException\n                {\n                    int[] byType = degrees.get( type );\n                    if ( byType == null )\n                    {\n                        degrees.put( type, byType = new int[3] );\n                    }\n                    byType[directionOf( nodeId, relId, startNode, endNode ).ordinal()]++;\n                }\n            };\n            RelationshipIterator relationships;\n            try\n            {\n                relationships = nodeListRelationships( statement, nodeId, Direction.BOTH );\n                while ( relationships.hasNext() )\n                {\n                    relationships.relationshipVisit( relationships.next(), typeVisitor );\n                }\n\n                degrees.visitEntries( new PrimitiveIntObjectVisitor<int[], RuntimeException>()\n                {\n                    @Override\n                    public boolean visited( int type, int[] degrees /*out,in,loop*/ ) throws RuntimeException\n                    {\n                        visitor.visitDegree( type, degrees[0] + degrees[2], degrees[1] + degrees[2] );\n                        return false;\n                    }\n                } );\n            }\n            catch ( EntityNotFoundException e )\n            {\n                // OK?\n            }\n        }\n        return false;\n    }\n\n    private Direction directionOf( long nodeId, long relationshipId, long startNode, long endNode )\n    {\n        if ( startNode == nodeId )\n        {\n            return endNode == nodeId ? Direction.BOTH : Direction.OUTGOING;\n        }\n        if ( endNode == nodeId )\n        {\n            return Direction.INCOMING;\n        }\n        throw new InvalidRecordException( \"Node \" + nodeId + \" neither start nor end node of relationship \" +\n                relationshipId + \" with startNode:\" + startNode + \" and endNode:\" + endNode );\n    }\n\n    private long countByFirstPrevPointer( long nodeId, long relationshipId )\n    {\n        if ( relationshipId == Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            return 0;\n        }\n        RelationshipRecord record = relationshipStore.getRecord( relationshipId );\n        if ( record.getFirstNode() == nodeId )\n        {\n            return record.getFirstPrevRel();\n        }\n        if ( record.getSecondNode() == nodeId )\n        {\n            return record.getSecondPrevRel();\n        }\n        throw new InvalidRecordException( \"Node \" + nodeId + \" neither start nor end node of \" + record );\n    }\n\n    @Override\n    public PrimitiveIntIterator nodeGetRelationshipTypes( StoreStatement statement,\n            long nodeId ) throws EntityNotFoundException\n    {\n        final NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n\n        if ( node.isDense() )\n        {\n            return new PrimitiveIntCollections.PrimitiveIntBaseIterator()\n            {\n                private long groupId = node.getNextRel();\n\n                @Override\n                protected boolean fetchNext()\n                {\n                    if ( groupId == Record.NO_NEXT_RELATIONSHIP.intValue() )\n                    {\n                        return false;\n                    }\n\n                    RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                    try\n                    {\n                        return next( group.getType() );\n                    }\n                    finally\n                    {\n                        groupId = group.getNext();\n                    }\n                }\n            };\n        }\n\n        final PrimitiveIntSet types = Primitive.intSet( 5 );\n        RelationshipVisitor<RuntimeException> visitor = new RelationshipVisitor<RuntimeException>()\n        {\n            @Override\n            public void visit( long relId, int type, long startNode, long endNode ) throws RuntimeException\n            {\n                types.add( type );\n            }\n        };\n        RelationshipIterator relationships = nodeListRelationships( statement, nodeId, Direction.BOTH );\n        while ( relationships.hasNext() )\n        {\n            relationships.relationshipVisit( relationships.next(), visitor );\n        }\n        return types.iterator();\n    }\n\n    @Override\n    public String labelGetName( int labelId ) throws LabelNotFoundKernelException\n    {\n        try\n        {\n            return labelTokenHolder.getTokenById( labelId ).name();\n        }\n        catch ( TokenNotFoundException e )\n        {\n            throw new LabelNotFoundKernelException( \"Label by id \" + labelId, e );\n        }\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetForLabel( KernelStatement state, int labelId )\n    {\n        return state.getLabelScanReader().nodesWithLabel( labelId );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexSeek( KernelStatement state, IndexDescriptor index,\n            Object value ) throws IndexNotFoundKernelException\n    {\n        IndexReader reader = state.getIndexReader( index );\n        return reader.seek( value );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexRangeSeekByNumber( KernelStatement statement,\n                                                                     IndexDescriptor index,\n                                                                     Number lower, boolean includeLower,\n                                                                     Number upper, boolean includeUpper )\n            throws IndexNotFoundKernelException\n\n    {\n        IndexReader reader = statement.getIndexReader( index );\n        return reader.rangeSeekByNumber( lower, includeLower, upper, includeUpper );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexRangeSeekByString( KernelStatement statement,\n                                                                     IndexDescriptor index,\n                                                                     String lower, boolean includeLower,\n                                                                     String upper, boolean includeUpper )\n            throws IndexNotFoundKernelException\n\n    {\n        IndexReader reader = statement.getIndexReader( index );\n        return reader.rangeSeekByString( lower, includeLower, upper, includeUpper );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexRangeSeekByPrefix( KernelStatement state,\n                                                                     IndexDescriptor index,\n                                                                     String prefix )\n            throws IndexNotFoundKernelException\n    {\n        IndexReader reader = state.getIndexReader( index );\n        return reader.rangeSeekByPrefix( prefix );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexScan( KernelStatement state, IndexDescriptor index ) throws\n            IndexNotFoundKernelException\n    {\n        IndexReader reader = state.getIndexReader( index );\n        return reader.scan();\n    }\n\n    @Override\n    public IndexDescriptor indexesGetForLabelAndPropertyKey( int labelId, int propertyKey )\n    {\n        return descriptor( schemaStorage.indexRule( labelId, propertyKey ) );\n    }\n\n    private static IndexDescriptor descriptor( IndexRule ruleRecord )\n    {\n        return new IndexDescriptor( ruleRecord.getLabel(), ruleRecord.getPropertyKey() );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> indexesGetForLabel( int labelId )\n    {\n        return getIndexDescriptorsFor( indexRules( labelId ) );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> indexesGetAll()\n    {\n        return getIndexDescriptorsFor( INDEX_RULES );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> uniqueIndexesGetForLabel( int labelId )\n    {\n        return getIndexDescriptorsFor( constraintIndexRules( labelId ) );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> uniqueIndexesGetAll()\n    {\n        return getIndexDescriptorsFor( CONSTRAINT_INDEX_RULES );\n    }\n\n    private static Predicate<SchemaRule> indexRules( final int labelId )\n    {\n        return new Predicate<SchemaRule>()\n        {\n\n            @Override\n            public boolean test( SchemaRule rule )\n            {\n                return rule.getLabel() == labelId && rule.getKind() == SchemaRule.Kind.INDEX_RULE;\n            }\n        };\n    }\n\n    private static Predicate<SchemaRule> constraintIndexRules( final int labelId )\n    {\n        return new Predicate<SchemaRule>()\n        {\n\n            @Override\n            public boolean test( SchemaRule rule )\n            {\n                return rule.getLabel() == labelId && rule.getKind() == SchemaRule.Kind.CONSTRAINT_INDEX_RULE;\n            }\n        };\n    }\n\n    private static final Predicate<SchemaRule> INDEX_RULES = new Predicate<SchemaRule>()\n    {\n\n        @Override\n        public boolean test( SchemaRule rule )\n        {\n            return rule.getKind() == SchemaRule.Kind.INDEX_RULE;\n        }\n    }, CONSTRAINT_INDEX_RULES = new Predicate<SchemaRule>()\n    {\n\n        @Override\n        public boolean test( SchemaRule rule )\n        {\n            return rule.getKind() == SchemaRule.Kind.CONSTRAINT_INDEX_RULE;\n        }\n    };\n\n    private Iterator<IndexDescriptor> getIndexDescriptorsFor( Predicate<SchemaRule> filter )\n    {\n        Iterator<SchemaRule> filtered = filter( filter, neoStore.getSchemaStore().loadAllSchemaRules() );\n\n        return map( new Function<SchemaRule, IndexDescriptor>()\n        {\n\n            @Override\n            public IndexDescriptor apply( SchemaRule from )\n            {\n                return descriptor( (IndexRule) from );\n            }\n        }, filtered );\n    }\n\n    @Override\n    public Long indexGetOwningUniquenessConstraintId( IndexDescriptor index )\n            throws SchemaRuleNotFoundException\n    {\n        return schemaStorage.indexRule( index.getLabelId(), index.getPropertyKeyId() ).getOwningConstraint();\n    }\n\n    @Override\n    public IndexRule indexRule( IndexDescriptor index, SchemaStorage.IndexRuleKind kind )\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public long indexGetCommittedId( IndexDescriptor index, SchemaStorage.IndexRuleKind kind )\n            throws SchemaRuleNotFoundException\n    {\n        return schemaStorage.indexRule( index.getLabelId(), index.getPropertyKeyId() ).getId();\n    }\n\n    @Override\n    public InternalIndexState indexGetState( IndexDescriptor descriptor )\n            throws IndexNotFoundKernelException\n    {\n        return indexService.getIndexProxy( descriptor ).getState();\n    }\n\n    @Override\n    public long indexSize( IndexDescriptor descriptor ) throws IndexNotFoundKernelException\n    {\n        return indexService.indexSize( descriptor );\n    }\n\n    @Override\n    public double indexUniqueValuesPercentage( IndexDescriptor descriptor ) throws IndexNotFoundKernelException\n    {\n        return indexService.indexUniqueValuesPercentage( descriptor );\n    }\n\n    @Override\n    public String indexGetFailure( IndexDescriptor descriptor ) throws IndexNotFoundKernelException\n    {\n        return indexService.getIndexProxy( descriptor ).getPopulationFailure().asString();\n    }\n\n    @Override\n    public Iterator<NodePropertyConstraint> constraintsGetForLabelAndPropertyKey( int labelId, final int propertyKeyId )\n    {\n        return schemaStorage.schemaRulesForNodes( NODE_RULE_TO_CONSTRAINT, NodePropertyConstraintRule.class,\n                labelId, new Predicate<NodePropertyConstraintRule>()\n                {\n                    @Override\n                    public boolean test( NodePropertyConstraintRule rule )\n                    {\n                        return rule.containsPropertyKeyId( propertyKeyId );\n                    }\n                } );\n    }\n\n    @Override\n    public Iterator<NodePropertyConstraint> constraintsGetForLabel( int labelId )\n    {\n        return schemaStorage.schemaRulesForNodes( NODE_RULE_TO_CONSTRAINT, NodePropertyConstraintRule.class,\n                labelId, Predicates.<NodePropertyConstraintRule>alwaysTrue() );\n    }\n\n    @Override\n    public Iterator<RelationshipPropertyConstraint> constraintsGetForRelationshipTypeAndPropertyKey( int typeId,\n            final int propertyKeyId )\n    {\n        return schemaStorage.schemaRulesForRelationships( REL_RULE_TO_CONSTRAINT,\n                RelationshipPropertyConstraintRule.class, typeId, new Predicate<RelationshipPropertyConstraintRule>()\n                {\n                    @Override\n                    public boolean test( RelationshipPropertyConstraintRule rule )\n                    {\n                        return rule.containsPropertyKeyId( propertyKeyId );\n                    }\n                } );\n    }\n\n    @Override\n    public Iterator<RelationshipPropertyConstraint> constraintsGetForRelationshipType( int typeId )\n    {\n        return schemaStorage.schemaRulesForRelationships( REL_RULE_TO_CONSTRAINT,\n                RelationshipPropertyConstraintRule.class, typeId,\n                Predicates.<RelationshipPropertyConstraintRule>alwaysTrue() );\n    }\n\n    @Override\n    public Iterator<PropertyConstraint> constraintsGetAll()\n    {\n        return schemaStorage.schemaRules( RULE_TO_CONSTRAINT, PropertyConstraintRule.class );\n    }\n\n    @Override\n    public PrimitiveLongResourceIterator nodeGetFromUniqueIndexSeek( KernelStatement state, IndexDescriptor descriptor,\n            Object value ) throws IndexNotFoundKernelException, IndexBrokenKernelException\n    {\n        /* Here we have an intricate scenario where we need to return the PrimitiveLongIterator\n         * since subsequent filtering will happen outside, but at the same time have the ability to\n         * close the IndexReader when done iterating over the lookup result. This is because we get\n         * a fresh reader that isn't associated with the current transaction and hence will not be\n         * automatically closed. */\n        IndexReader reader = state.getFreshIndexReader( descriptor );\n        return resourceIterator( reader.seek( value ), reader );\n    }\n\n    @Override\n    public int propertyKeyGetOrCreateForName( String propertyKey )\n    {\n        return propertyKeyTokenHolder.getOrCreateId( propertyKey );\n    }\n\n    @Override\n    public int propertyKeyGetForName( String propertyKey )\n    {\n        return propertyKeyTokenHolder.getIdByName( propertyKey );\n    }\n\n    @Override\n    public String propertyKeyGetName( int propertyKeyId )\n            throws PropertyKeyIdNotFoundKernelException\n    {\n        try\n        {\n            return propertyKeyTokenHolder.getTokenById( propertyKeyId ).name();\n        }\n        catch ( TokenNotFoundException e )\n        {\n            throw new PropertyKeyIdNotFoundKernelException( propertyKeyId, e );\n        }\n    }\n\n    @Override\n    public PrimitiveIntIterator graphGetPropertyKeys( KernelStatement state )\n    {\n        return new PropertyKeyIdIterator( propertyLoader.graphLoadProperties( new IteratingPropertyReceiver() ) );\n    }\n\n    @Override\n    public Object graphGetProperty( int propertyKeyId )\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Iterator<DefinedProperty> graphGetAllProperties()\n    {\n        return propertyLoader.graphLoadProperties( new IteratingPropertyReceiver() );\n    }\n\n    @Override\n    public Iterator<Token> propertyKeyGetAllTokens()\n    {\n        return propertyKeyTokenHolder.getAllTokens().iterator();\n    }\n\n    @Override\n    public Iterator<Token> labelsGetAllTokens()\n    {\n        return labelTokenHolder.getAllTokens().iterator();\n    }\n\n    @Override\n    public int relationshipTypeGetForName( String relationshipTypeName )\n    {\n        return relationshipTokenHolder.getIdByName( relationshipTypeName );\n    }\n\n    @Override\n    public String relationshipTypeGetName( int relationshipTypeId ) throws RelationshipTypeIdNotFoundKernelException\n    {\n        try\n        {\n            return relationshipTokenHolder.getTokenById( relationshipTypeId ).name();\n        }\n        catch ( TokenNotFoundException e )\n        {\n            throw new RelationshipTypeIdNotFoundKernelException( relationshipTypeId, e );\n        }\n    }\n\n    @Override\n    public int relationshipTypeGetOrCreateForName( String relationshipTypeName )\n    {\n        return relationshipTokenHolder.getOrCreateId( relationshipTypeName );\n    }\n\n    @Override\n    public <EXCEPTION extends Exception> void relationshipVisit( long relationshipId,\n            RelationshipVisitor<EXCEPTION> relationshipVisitor ) throws EntityNotFoundException, EXCEPTION\n    {\n        // TODO Please don't create a record for this, it's ridiculous\n        RelationshipRecord record;\n        try\n        {\n            record = relationshipStore.getRecord( relationshipId );\n        }\n        catch ( InvalidRecordException e )\n        {\n            throw new EntityNotFoundException( EntityType.RELATIONSHIP, relationshipId );\n        }\n        relationshipVisitor.visit( relationshipId, record.getType(), record.getFirstNode(), record.getSecondNode() );\n    }\n\n    @Override\n    public long highestNodeIdInUse()\n    {\n        return nodeStore.getHighestPossibleIdInUse();\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetAll()\n    {\n        return new PrimitiveLongBaseIterator()\n        {\n            private final NodeStore store = neoStore.getNodeStore();\n            private long highId = store.getHighestPossibleIdInUse();\n            private long currentId;\n            private final NodeRecord reusableNodeRecord = new NodeRecord( -1 ); // reused\n\n            @Override\n            protected boolean fetchNext()\n            {\n                while ( true )\n                {   // This outer loop is for checking if highId has changed since we started.\n                    while ( currentId <= highId )\n                    {\n                        try\n                        {\n                            NodeRecord record = store.loadRecord( currentId, reusableNodeRecord );\n                            if ( record != null && record.inUse() )\n                            {\n                                return next( record.getId() );\n                            }\n                        }\n                        finally\n                        {\n                            currentId++;\n                        }\n                    }\n\n                    long newHighId = store.getHighestPossibleIdInUse();\n                    if ( newHighId > highId )\n                    {\n                        highId = newHighId;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                return false;\n            }\n        };\n    }\n\n    @Override\n    public Cursor<NodeItem> nodesGetAllCursor( StoreStatement statement )\n    {\n        return statement.acquireIteratorNodeCursor( new AllStoreIdIterator( neoStore.getNodeStore() ) );\n    }\n\n    @Override\n    public RelationshipIterator relationshipsGetAll()\n    {\n        return new RelationshipIterator.BaseIterator()\n        {\n            private final RelationshipStore store = neoStore.getRelationshipStore();\n            private long highId = store.getHighestPossibleIdInUse();\n            private long currentId;\n            private final RelationshipRecord reusableRecord = new RelationshipRecord( -1 ); // reused\n\n            @Override\n            protected boolean fetchNext()\n            {\n                while ( true )\n                {   // This outer loop is for checking if highId has changed since we started.\n                    while ( currentId <= highId )\n                    {\n                        try\n                        {\n                            if ( store.fillRecord( currentId, reusableRecord, CHECK ) && reusableRecord.inUse() )\n                            {\n                                return next( reusableRecord.getId() );\n                            }\n                        }\n                        finally\n                        {\n                            currentId++;\n                        }\n                    }\n\n                    long newHighId = store.getHighestPossibleIdInUse();\n                    if ( newHighId > highId )\n                    {\n                        highId = newHighId;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                return false;\n            }\n\n            @Override\n            public <EXCEPTION extends Exception> boolean relationshipVisit( long relationshipId,\n                    RelationshipVisitor<EXCEPTION> visitor ) throws EXCEPTION\n            {\n                visitor.visit( relationshipId, reusableRecord.getType(),\n                        reusableRecord.getFirstNode(), reusableRecord.getSecondNode() );\n                return false;\n            }\n        };\n    }\n\n    @Override\n    public Cursor<RelationshipItem> relationshipsGetAllCursor( StoreStatement storeStatement )\n    {\n        return storeStatement.acquireIteratorRelationshipCursor(\n                new AllStoreIdIterator( neoStore.getRelationshipStore() ) );\n    }\n\n    @Override\n    public long reserveNode()\n    {\n        return nodeStore.nextId();\n    }\n\n    @Override\n    public long reserveRelationship()\n    {\n        return relationshipStore.nextId();\n    }\n\n    @Override\n    public void releaseNode( long id )\n    {\n        nodeStore.freeId( id );\n    }\n\n    @Override\n    public void releaseRelationship( long id )\n    {\n        relationshipStore.freeId( id );\n    }\n\n    @Override\n    public long countsForNode( int labelId )\n    {\n        return counts.nodeCount( labelId, newDoubleLongRegister() ).readSecond();\n    }\n\n    @Override\n    public long countsForRelationship( int startLabelId, int typeId, int endLabelId )\n    {\n        if ( !(startLabelId == ReadOperations.ANY_LABEL || endLabelId == ReadOperations.ANY_LABEL) )\n        {\n            throw new UnsupportedOperationException( \"not implemented\" );\n        }\n        return counts.relationshipCount( startLabelId, typeId, endLabelId, newDoubleLongRegister() ).readSecond();\n    }\n\n    private class AllStoreIdIterator extends PrimitiveLongBaseIterator\n    {\n        private final CommonAbstractStore store;\n        private long highId;\n        private long currentId;\n\n        public AllStoreIdIterator( CommonAbstractStore store )\n        {\n            this.store = store;\n            highId = store.getHighestPossibleIdInUse();\n        }\n\n        @Override\n        protected boolean fetchNext()\n        {\n            while ( true )\n            {   // This outer loop is for checking if highId has changed since we started.\n                if ( currentId <= highId )\n                {\n                    try\n                    {\n                        return next( currentId );\n                    }\n                    finally\n                    {\n                        currentId++;\n                    }\n          ",
    "ID_17": "public class DiskLayer implements StoreReadLayer\n{\n    private static final Function<PropertyConstraintRule, PropertyConstraint> RULE_TO_CONSTRAINT =\n            new Function<PropertyConstraintRule, PropertyConstraint>()\n            {\n                @Override\n                public PropertyConstraint apply( PropertyConstraintRule rule )\n                {\n                    // We can use propertyKeyId straight up here, without reading from the record, since we have\n                    // verified that it has that propertyKeyId in the predicate. And since we currently only support\n                    // uniqueness on single properties, there is nothing else to pass in to UniquenessConstraint.\n                    return rule.toConstraint();\n                }\n            };\n\n    private static final Function<NodePropertyConstraintRule,NodePropertyConstraint> NODE_RULE_TO_CONSTRAINT =\n            new Function<NodePropertyConstraintRule,NodePropertyConstraint>()\n            {\n                @Override\n                public NodePropertyConstraint apply( NodePropertyConstraintRule rule )\n                {\n                    return rule.toConstraint();\n                }\n            };\n\n    private static final Function<RelationshipPropertyConstraintRule,RelationshipPropertyConstraint> REL_RULE_TO_CONSTRAINT =\n            new Function<RelationshipPropertyConstraintRule,RelationshipPropertyConstraint>()\n            {\n                @Override\n                public RelationshipPropertyConstraint apply( RelationshipPropertyConstraintRule rule )\n                {\n                    return rule.toConstraint();\n                }\n            };\n\n    // These token holders should perhaps move to the cache layer.. not really any reason to have them here?\n    private final PropertyKeyTokenHolder propertyKeyTokenHolder;\n    private final LabelTokenHolder labelTokenHolder;\n    private final RelationshipTypeTokenHolder relationshipTokenHolder;\n\n    private final NeoStore neoStore;\n    private final IndexingService indexService;\n    private final NodeStore nodeStore;\n    private final RelationshipGroupStore relationshipGroupStore;\n    private final RelationshipStore relationshipStore;\n    private final SchemaStorage schemaStorage;\n    private final CountsAccessor counts;\n    private final PropertyLoader propertyLoader;\n\n    public DiskLayer( PropertyKeyTokenHolder propertyKeyTokenHolder, LabelTokenHolder labelTokenHolder,\n            RelationshipTypeTokenHolder relationshipTokenHolder, SchemaStorage schemaStorage, NeoStore neoStore,\n            IndexingService indexService )\n    {\n        this.relationshipTokenHolder = relationshipTokenHolder;\n        this.schemaStorage = schemaStorage;\n        this.indexService = indexService;\n        this.propertyKeyTokenHolder = propertyKeyTokenHolder;\n        this.labelTokenHolder = labelTokenHolder;\n        this.neoStore = neoStore;\n        this.nodeStore = this.neoStore.getNodeStore();\n        this.relationshipStore = this.neoStore.getRelationshipStore();\n        this.relationshipGroupStore = this.neoStore.getRelationshipGroupStore();\n        this.counts = neoStore.getCounts();\n        this.propertyLoader = new PropertyLoader( neoStore );\n\n    }\n\n    @Override\n    public StoreStatement acquireStatement()\n    {\n        return neoStore.acquireStatement();\n    }\n\n    @Override\n    public int labelGetOrCreateForName( String label ) throws TooManyLabelsException\n    {\n        try\n        {\n            return labelTokenHolder.getOrCreateId( label );\n        }\n        catch ( TransactionFailureException e )\n        {\n            // Temporary workaround for the property store based label\n            // implementation. Actual\n            // implementation should not depend on internal kernel exception\n            // messages like this.\n            if ( e.getCause() instanceof UnderlyingStorageException\n                    && e.getCause().getMessage().equals( \"Id capacity exceeded\" ) )\n            {\n                throw new TooManyLabelsException( e );\n            }\n            throw e;\n        }\n    }\n\n    @Override\n    public int labelGetForName( String label )\n    {\n        return labelTokenHolder.getIdByName( label );\n    }\n\n    @Override\n    public PrimitiveIntIterator nodeGetLabels( StoreStatement statement, long nodeId ) throws EntityNotFoundException\n    {\n        try ( Cursor<NodeItem> nodeCursor = statement.acquireSingleNodeCursor( nodeId ) )\n        {\n            if ( nodeCursor.next() )\n            {\n                return Cursors.intIterator( nodeCursor.get().labels(), LabelItem.GET_LABEL );\n            }\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n    }\n\n    @Override\n    public RelationshipIterator nodeListRelationships( StoreStatement statement,\n            long nodeId,\n            Direction direction )\n            throws EntityNotFoundException\n    {\n        return nodeListRelationships( statement, nodeId, direction, null );\n    }\n\n    @Override\n    public RelationshipIterator nodeListRelationships( final StoreStatement statement,\n            long nodeId,\n            Direction direction,\n            int[] relTypes )\n            throws EntityNotFoundException\n    {\n        try ( final Cursor<NodeItem> nodeCursor = statement.acquireSingleNodeCursor( nodeId ) )\n        {\n            if ( nodeCursor.next() )\n            {\n                return new CursorRelationshipIterator( nodeCursor.get().relationships( direction, relTypes ) );\n            }\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n    }\n\n    @Override\n    public int nodeGetDegree( StoreStatement statement,\n            long nodeId,\n            Direction direction ) throws EntityNotFoundException\n    {\n        NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n\n        if ( node.isDense() )\n        {\n            long groupId = node.getNextRel();\n            long count = 0;\n            while ( groupId != Record.NO_NEXT_RELATIONSHIP.intValue() )\n            {\n                RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                count += nodeDegreeByDirection( nodeId, group, direction );\n                groupId = group.getNext();\n            }\n            return (int) count;\n        }\n\n        return count( nodeListRelationships( statement, nodeId, direction ) );\n    }\n\n    @Override\n    public int nodeGetDegree( StoreStatement statement, long nodeId,\n            Direction direction,\n            int relType ) throws EntityNotFoundException\n    {\n        NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n\n        if ( node.isDense() )\n        {\n            long groupId = node.getNextRel();\n            while ( groupId != Record.NO_NEXT_RELATIONSHIP.intValue() )\n            {\n                RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                if ( group.getType() == relType )\n                {\n                    return (int) nodeDegreeByDirection( nodeId, group, direction );\n                }\n                groupId = group.getNext();\n            }\n            return 0;\n        }\n\n        return count( nodeListRelationships( statement, nodeId, direction, new int[]{relType} ) );\n    }\n\n    private long nodeDegreeByDirection( long nodeId, RelationshipGroupRecord group, Direction direction )\n    {\n        long loopCount = countByFirstPrevPointer( nodeId, group.getFirstLoop() );\n        switch ( direction )\n        {\n            case OUTGOING:\n                return countByFirstPrevPointer( nodeId, group.getFirstOut() ) + loopCount;\n            case INCOMING:\n                return countByFirstPrevPointer( nodeId, group.getFirstIn() ) + loopCount;\n            case BOTH:\n                return countByFirstPrevPointer( nodeId, group.getFirstOut() ) +\n                        countByFirstPrevPointer( nodeId, group.getFirstIn() ) + loopCount;\n            default:\n                throw new IllegalArgumentException( direction.name() );\n        }\n    }\n\n    @Override\n    public boolean nodeVisitDegrees( StoreStatement statement, final long nodeId, final DegreeVisitor visitor )\n    {\n        NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            return true;\n        }\n\n        if ( node.isDense() )\n        {\n            long groupId = node.getNextRel();\n            while ( groupId != Record.NO_NEXT_RELATIONSHIP.intValue() )\n            {\n                RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                long outCount = countByFirstPrevPointer( nodeId, group.getFirstOut() );\n                long inCount = countByFirstPrevPointer( nodeId, group.getFirstIn() );\n                long loopCount = countByFirstPrevPointer( nodeId, group.getFirstLoop() );\n                visitor.visitDegree( group.getType(), (int) (outCount + loopCount), (int) (inCount + loopCount) );\n                groupId = group.getNext();\n            }\n        }\n        else\n        {\n            final PrimitiveIntObjectMap<int[]> degrees = Primitive.intObjectMap( 5 );\n            RelationshipVisitor<RuntimeException> typeVisitor = new RelationshipVisitor<RuntimeException>()\n            {\n                @Override\n                public void visit( long relId, int type, long startNode, long endNode ) throws RuntimeException\n                {\n                    int[] byType = degrees.get( type );\n                    if ( byType == null )\n                    {\n                        degrees.put( type, byType = new int[3] );\n                    }\n                    byType[directionOf( nodeId, relId, startNode, endNode ).ordinal()]++;\n                }\n            };\n            RelationshipIterator relationships;\n            try\n            {\n                relationships = nodeListRelationships( statement, nodeId, Direction.BOTH );\n                while ( relationships.hasNext() )\n                {\n                    relationships.relationshipVisit( relationships.next(), typeVisitor );\n                }\n\n                degrees.visitEntries( new PrimitiveIntObjectVisitor<int[], RuntimeException>()\n                {\n                    @Override\n                    public boolean visited( int type, int[] degrees /*out,in,loop*/ ) throws RuntimeException\n                    {\n                        visitor.visitDegree( type, degrees[0] + degrees[2], degrees[1] + degrees[2] );\n                        return false;\n                    }\n                } );\n            }\n            catch ( EntityNotFoundException e )\n            {\n                // OK?\n            }\n        }\n        return false;\n    }\n\n    private Direction directionOf( long nodeId, long relationshipId, long startNode, long endNode )\n    {\n        if ( startNode == nodeId )\n        {\n            return endNode == nodeId ? Direction.BOTH : Direction.OUTGOING;\n        }\n        if ( endNode == nodeId )\n        {\n            return Direction.INCOMING;\n        }\n        throw new InvalidRecordException( \"Node \" + nodeId + \" neither start nor end node of relationship \" +\n                relationshipId + \" with startNode:\" + startNode + \" and endNode:\" + endNode );\n    }\n\n    private long countByFirstPrevPointer( long nodeId, long relationshipId )\n    {\n        if ( relationshipId == Record.NO_NEXT_RELATIONSHIP.intValue() )\n        {\n            return 0;\n        }\n        RelationshipRecord record = relationshipStore.getRecord( relationshipId );\n        if ( record.getFirstNode() == nodeId )\n        {\n            return record.getFirstPrevRel();\n        }\n        if ( record.getSecondNode() == nodeId )\n        {\n            return record.getSecondPrevRel();\n        }\n        throw new InvalidRecordException( \"Node \" + nodeId + \" neither start nor end node of \" + record );\n    }\n\n    @Override\n    public PrimitiveIntIterator nodeGetRelationshipTypes( StoreStatement statement,\n            long nodeId ) throws EntityNotFoundException\n    {\n        final NodeRecord node = nodeStore.loadRecord( nodeId, null );\n        if ( node == null )\n        {\n            throw new EntityNotFoundException( EntityType.NODE, nodeId );\n        }\n\n        if ( node.isDense() )\n        {\n            return new PrimitiveIntCollections.PrimitiveIntBaseIterator()\n            {\n                private long groupId = node.getNextRel();\n\n                @Override\n                protected boolean fetchNext()\n                {\n                    if ( groupId == Record.NO_NEXT_RELATIONSHIP.intValue() )\n                    {\n                        return false;\n                    }\n\n                    RelationshipGroupRecord group = relationshipGroupStore.getRecord( groupId );\n                    try\n                    {\n                        return next( group.getType() );\n                    }\n                    finally\n                    {\n                        groupId = group.getNext();\n                    }\n                }\n            };\n        }\n\n        final PrimitiveIntSet types = Primitive.intSet( 5 );\n        RelationshipVisitor<RuntimeException> visitor = new RelationshipVisitor<RuntimeException>()\n        {\n            @Override\n            public void visit( long relId, int type, long startNode, long endNode ) throws RuntimeException\n            {\n                types.add( type );\n            }\n        };\n        RelationshipIterator relationships = nodeListRelationships( statement, nodeId, Direction.BOTH );\n        while ( relationships.hasNext() )\n        {\n            relationships.relationshipVisit( relationships.next(), visitor );\n        }\n        return types.iterator();\n    }\n\n    @Override\n    public String labelGetName( int labelId ) throws LabelNotFoundKernelException\n    {\n        try\n        {\n            return labelTokenHolder.getTokenById( labelId ).name();\n        }\n        catch ( TokenNotFoundException e )\n        {\n            throw new LabelNotFoundKernelException( \"Label by id \" + labelId, e );\n        }\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetForLabel( KernelStatement state, int labelId )\n    {\n        return state.getLabelScanReader().nodesWithLabel( labelId );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexSeek( KernelStatement state, IndexDescriptor index,\n            Object value ) throws IndexNotFoundKernelException\n    {\n        IndexReader reader = state.getIndexReader( index );\n        return reader.seek( value );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexRangeSeekByNumber( KernelStatement statement,\n                                                                     IndexDescriptor index,\n                                                                     Number lower, boolean includeLower,\n                                                                     Number upper, boolean includeUpper )\n            throws IndexNotFoundKernelException\n\n    {\n        IndexReader reader = statement.getIndexReader( index );\n        return reader.rangeSeekByNumber( lower, includeLower, upper, includeUpper );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexRangeSeekByString( KernelStatement statement,\n                                                                     IndexDescriptor index,\n                                                                     String lower, boolean includeLower,\n                                                                     String upper, boolean includeUpper )\n            throws IndexNotFoundKernelException\n\n    {\n        IndexReader reader = statement.getIndexReader( index );\n        return reader.rangeSeekByString( lower, includeLower, upper, includeUpper );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexRangeSeekByPrefix( KernelStatement state,\n                                                                     IndexDescriptor index,\n                                                                     String prefix )\n            throws IndexNotFoundKernelException\n    {\n        IndexReader reader = state.getIndexReader( index );\n        return reader.rangeSeekByPrefix( prefix );\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetFromIndexScan( KernelStatement state, IndexDescriptor index ) throws\n            IndexNotFoundKernelException\n    {\n        IndexReader reader = state.getIndexReader( index );\n        return reader.scan();\n    }\n\n    @Override\n    public IndexDescriptor indexesGetForLabelAndPropertyKey( int labelId, int propertyKey )\n    {\n        return descriptor( schemaStorage.indexRule( labelId, propertyKey ) );\n    }\n\n    private static IndexDescriptor descriptor( IndexRule ruleRecord )\n    {\n        return new IndexDescriptor( ruleRecord.getLabel(), ruleRecord.getPropertyKey() );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> indexesGetForLabel( int labelId )\n    {\n        return getIndexDescriptorsFor( indexRules( labelId ) );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> indexesGetAll()\n    {\n        return getIndexDescriptorsFor( INDEX_RULES );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> uniqueIndexesGetForLabel( int labelId )\n    {\n        return getIndexDescriptorsFor( constraintIndexRules( labelId ) );\n    }\n\n    @Override\n    public Iterator<IndexDescriptor> uniqueIndexesGetAll()\n    {\n        return getIndexDescriptorsFor( CONSTRAINT_INDEX_RULES );\n    }\n\n    private static Predicate<SchemaRule> indexRules( final int labelId )\n    {\n        return new Predicate<SchemaRule>()\n        {\n\n            @Override\n            public boolean test( SchemaRule rule )\n            {\n                return rule.getLabel() == labelId && rule.getKind() == SchemaRule.Kind.INDEX_RULE;\n            }\n        };\n    }\n\n    private static Predicate<SchemaRule> constraintIndexRules( final int labelId )\n    {\n        return new Predicate<SchemaRule>()\n        {\n\n            @Override\n            public boolean test( SchemaRule rule )\n            {\n                return rule.getLabel() == labelId && rule.getKind() == SchemaRule.Kind.CONSTRAINT_INDEX_RULE;\n            }\n        };\n    }\n\n    private static final Predicate<SchemaRule> INDEX_RULES = new Predicate<SchemaRule>()\n    {\n\n        @Override\n        public boolean test( SchemaRule rule )\n        {\n            return rule.getKind() == SchemaRule.Kind.INDEX_RULE;\n        }\n    }, CONSTRAINT_INDEX_RULES = new Predicate<SchemaRule>()\n    {\n\n        @Override\n        public boolean test( SchemaRule rule )\n        {\n            return rule.getKind() == SchemaRule.Kind.CONSTRAINT_INDEX_RULE;\n        }\n    };\n\n    private Iterator<IndexDescriptor> getIndexDescriptorsFor( Predicate<SchemaRule> filter )\n    {\n        Iterator<SchemaRule> filtered = filter( filter, neoStore.getSchemaStore().loadAllSchemaRules() );\n\n        return map( new Function<SchemaRule, IndexDescriptor>()\n        {\n\n            @Override\n            public IndexDescriptor apply( SchemaRule from )\n            {\n                return descriptor( (IndexRule) from );\n            }\n        }, filtered );\n    }\n\n    @Override\n    public Long indexGetOwningUniquenessConstraintId( IndexDescriptor index )\n            throws SchemaRuleNotFoundException\n    {\n        return schemaStorage.indexRule( index.getLabelId(), index.getPropertyKeyId() ).getOwningConstraint();\n    }\n\n    @Override\n    public IndexRule indexRule( IndexDescriptor index, SchemaStorage.IndexRuleKind kind )\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public long indexGetCommittedId( IndexDescriptor index, SchemaStorage.IndexRuleKind kind )\n            throws SchemaRuleNotFoundException\n    {\n        return schemaStorage.indexRule( index.getLabelId(), index.getPropertyKeyId() ).getId();\n    }\n\n    @Override\n    public InternalIndexState indexGetState( IndexDescriptor descriptor )\n            throws IndexNotFoundKernelException\n    {\n        return indexService.getIndexProxy( descriptor ).getState();\n    }\n\n    @Override\n    public long indexSize( IndexDescriptor descriptor ) throws IndexNotFoundKernelException\n    {\n        return indexService.indexSize( descriptor );\n    }\n\n    @Override\n    public double indexUniqueValuesPercentage( IndexDescriptor descriptor ) throws IndexNotFoundKernelException\n    {\n        return indexService.indexUniqueValuesPercentage( descriptor );\n    }\n\n    @Override\n    public String indexGetFailure( IndexDescriptor descriptor ) throws IndexNotFoundKernelException\n    {\n        return indexService.getIndexProxy( descriptor ).getPopulationFailure().asString();\n    }\n\n    @Override\n    public Iterator<NodePropertyConstraint> constraintsGetForLabelAndPropertyKey( int labelId, final int propertyKeyId )\n    {\n        return schemaStorage.schemaRulesForNodes( NODE_RULE_TO_CONSTRAINT, NodePropertyConstraintRule.class,\n                labelId, new Predicate<NodePropertyConstraintRule>()\n                {\n                    @Override\n                    public boolean test( NodePropertyConstraintRule rule )\n                    {\n                        return rule.containsPropertyKeyId( propertyKeyId );\n                    }\n                } );\n    }\n\n    @Override\n    public Iterator<NodePropertyConstraint> constraintsGetForLabel( int labelId )\n    {\n        return schemaStorage.schemaRulesForNodes( NODE_RULE_TO_CONSTRAINT, NodePropertyConstraintRule.class,\n                labelId, Predicates.<NodePropertyConstraintRule>alwaysTrue() );\n    }\n\n    @Override\n    public Iterator<RelationshipPropertyConstraint> constraintsGetForRelationshipTypeAndPropertyKey( int typeId,\n            final int propertyKeyId )\n    {\n        return schemaStorage.schemaRulesForRelationships( REL_RULE_TO_CONSTRAINT,\n                RelationshipPropertyConstraintRule.class, typeId, new Predicate<RelationshipPropertyConstraintRule>()\n                {\n                    @Override\n                    public boolean test( RelationshipPropertyConstraintRule rule )\n                    {\n                        return rule.containsPropertyKeyId( propertyKeyId );\n                    }\n                } );\n    }\n\n    @Override\n    public Iterator<RelationshipPropertyConstraint> constraintsGetForRelationshipType( int typeId )\n    {\n        return schemaStorage.schemaRulesForRelationships( REL_RULE_TO_CONSTRAINT,\n                RelationshipPropertyConstraintRule.class, typeId,\n                Predicates.<RelationshipPropertyConstraintRule>alwaysTrue() );\n    }\n\n    @Override\n    public Iterator<PropertyConstraint> constraintsGetAll()\n    {\n        return schemaStorage.schemaRules( RULE_TO_CONSTRAINT, PropertyConstraintRule.class );\n    }\n\n    @Override\n    public PrimitiveLongResourceIterator nodeGetFromUniqueIndexSeek( KernelStatement state, IndexDescriptor descriptor,\n            Object value ) throws IndexNotFoundKernelException, IndexBrokenKernelException\n    {\n        /* Here we have an intricate scenario where we need to return the PrimitiveLongIterator\n         * since subsequent filtering will happen outside, but at the same time have the ability to\n         * close the IndexReader when done iterating over the lookup result. This is because we get\n         * a fresh reader that isn't associated with the current transaction and hence will not be\n         * automatically closed. */\n        IndexReader reader = state.getFreshIndexReader( descriptor );\n        return resourceIterator( reader.seek( value ), reader );\n    }\n\n    @Override\n    public int propertyKeyGetOrCreateForName( String propertyKey )\n    {\n        return propertyKeyTokenHolder.getOrCreateId( propertyKey );\n    }\n\n    @Override\n    public int propertyKeyGetForName( String propertyKey )\n    {\n        return propertyKeyTokenHolder.getIdByName( propertyKey );\n    }\n\n    @Override\n    public String propertyKeyGetName( int propertyKeyId )\n            throws PropertyKeyIdNotFoundKernelException\n    {\n        try\n        {\n            return propertyKeyTokenHolder.getTokenById( propertyKeyId ).name();\n        }\n        catch ( TokenNotFoundException e )\n        {\n            throw new PropertyKeyIdNotFoundKernelException( propertyKeyId, e );\n        }\n    }\n\n    @Override\n    public PrimitiveIntIterator graphGetPropertyKeys( KernelStatement state )\n    {\n        return new PropertyKeyIdIterator( propertyLoader.graphLoadProperties( new IteratingPropertyReceiver() ) );\n    }\n\n    @Override\n    public Object graphGetProperty( int propertyKeyId )\n    {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Iterator<DefinedProperty> graphGetAllProperties()\n    {\n        return propertyLoader.graphLoadProperties( new IteratingPropertyReceiver() );\n    }\n\n    @Override\n    public Iterator<Token> propertyKeyGetAllTokens()\n    {\n        return propertyKeyTokenHolder.getAllTokens().iterator();\n    }\n\n    @Override\n    public Iterator<Token> labelsGetAllTokens()\n    {\n        return labelTokenHolder.getAllTokens().iterator();\n    }\n\n    @Override\n    public int relationshipTypeGetForName( String relationshipTypeName )\n    {\n        return relationshipTokenHolder.getIdByName( relationshipTypeName );\n    }\n\n    @Override\n    public String relationshipTypeGetName( int relationshipTypeId ) throws RelationshipTypeIdNotFoundKernelException\n    {\n        try\n        {\n            return relationshipTokenHolder.getTokenById( relationshipTypeId ).name();\n        }\n        catch ( TokenNotFoundException e )\n        {\n            throw new RelationshipTypeIdNotFoundKernelException( relationshipTypeId, e );\n        }\n    }\n\n    @Override\n    public int relationshipTypeGetOrCreateForName( String relationshipTypeName )\n    {\n        return relationshipTokenHolder.getOrCreateId( relationshipTypeName );\n    }\n\n    @Override\n    public <EXCEPTION extends Exception> void relationshipVisit( long relationshipId,\n            RelationshipVisitor<EXCEPTION> relationshipVisitor ) throws EntityNotFoundException, EXCEPTION\n    {\n        // TODO Please don't create a record for this, it's ridiculous\n        RelationshipRecord record;\n        try\n        {\n            record = relationshipStore.getRecord( relationshipId );\n        }\n        catch ( InvalidRecordException e )\n        {\n            throw new EntityNotFoundException( EntityType.RELATIONSHIP, relationshipId );\n        }\n        relationshipVisitor.visit( relationshipId, record.getType(), record.getFirstNode(), record.getSecondNode() );\n    }\n\n    @Override\n    public long highestNodeIdInUse()\n    {\n        return nodeStore.getHighestPossibleIdInUse();\n    }\n\n    @Override\n    public PrimitiveLongIterator nodesGetAll()\n    {\n        return new PrimitiveLongBaseIterator()\n        {\n            private final NodeStore store = neoStore.getNodeStore();\n            private long highId = store.getHighestPossibleIdInUse();\n            private long currentId;\n            private final NodeRecord reusableNodeRecord = new NodeRecord( -1 ); // reused\n\n            @Override\n            protected boolean fetchNext()\n            {\n                while ( true )\n                {   // This outer loop is for checking if highId has changed since we started.\n                    while ( currentId <= highId )\n                    {\n                        try\n                        {\n                            NodeRecord record = store.loadRecord( currentId, reusableNodeRecord );\n                            if ( record != null && record.inUse() )\n                            {\n                                return next( record.getId() );\n                            }\n                        }\n                        finally\n                        {\n                            currentId++;\n                        }\n                    }\n\n                    long newHighId = store.getHighestPossibleIdInUse();\n                    if ( newHighId > highId )\n                    {\n                        highId = newHighId;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                return false;\n            }\n        };\n    }\n\n    @Override\n    public Cursor<NodeItem> nodesGetAllCursor( StoreStatement statement )\n    {\n        return statement.acquireIteratorNodeCursor( new AllStoreIdIterator( neoStore.getNodeStore() ) );\n    }\n\n    @Override\n    public RelationshipIterator relationshipsGetAll()\n    {\n        return new RelationshipIterator.BaseIterator()\n        {\n            private final RelationshipStore store = neoStore.getRelationshipStore();\n            private long highId = store.getHighestPossibleIdInUse();\n            private long currentId;\n            private final RelationshipRecord reusableRecord = new RelationshipRecord( -1 ); // reused\n\n            @Override\n            protected boolean fetchNext()\n            {\n                while ( true )\n                {   // This outer loop is for checking if highId has changed since we started.\n                    while ( currentId <= highId )\n                    {\n                        try\n                        {\n                            if ( store.fillRecord( currentId, reusableRecord, CHECK ) && reusableRecord.inUse() )\n                            {\n                                return next( reusableRecord.getId() );\n                            }\n                        }\n                        finally\n                        {\n                            currentId++;\n                        }\n                    }\n\n                    long newHighId = store.getHighestPossibleIdInUse();\n                    if ( newHighId > highId )\n                    {\n                        highId = newHighId;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n                return false;\n            }\n\n            @Override\n            public <EXCEPTION extends Exception> boolean relationshipVisit( long relationshipId,\n                    RelationshipVisitor<EXCEPTION> visitor ) throws EXCEPTION\n            {\n                visitor.visit( relationshipId, reusableRecord.getType(),\n                        reusableRecord.getFirstNode(), reusableRecord.getSecondNode() );\n                return false;\n            }\n        };\n    }\n\n    @Override\n    public Cursor<RelationshipItem> relationshipsGetAllCursor( StoreStatement storeStatement )\n    {\n        return storeStatement.acquireIteratorRelationshipCursor(\n                new AllStoreIdIterator( neoStore.getRelationshipStore() ) );\n    }\n\n    @Override\n    public long reserveNode()\n    {\n        return nodeStore.nextId();\n    }\n\n    @Override\n    public long reserveRelationship()\n    {\n        return relationshipStore.nextId();\n    }\n\n    @Override\n    public void releaseNode( long id )\n    {\n        nodeStore.freeId( id );\n    }\n\n    @Override\n    public void releaseRelationship( long id )\n    {\n        relationshipStore.freeId( id );\n    }\n\n    @Override\n    public long countsForNode( int labelId )\n    {\n        return counts.nodeCount( labelId, newDoubleLongRegister() ).readSecond();\n    }\n\n    @Override\n    public long countsForRelationship( int startLabelId, int typeId, int endLabelId )\n    {\n        if ( !(startLabelId == ReadOperations.ANY_LABEL || endLabelId == ReadOperations.ANY_LABEL) )\n        {\n            throw new UnsupportedOperationException( \"not implemented\" );\n        }\n        return counts.relationshipCount( startLabelId, typeId, endLabelId, newDoubleLongRegister() ).readSecond();\n    }\n\n    private class AllStoreIdIterator extends PrimitiveLongBaseIterator\n    {\n        private final CommonAbstractStore store;\n        private long highId;\n        private long currentId;\n\n        public AllStoreIdIterator( CommonAbstractStore store )\n        {\n            this.store = store;\n            highId = store.getHighestPossibleIdInUse();\n        }\n\n        @Override\n        protected boolean fetchNext()\n        {\n            while ( true )\n            {   // This outer loop is for checking if highId has changed since we started.\n                if ( currentId <= highId )\n                {\n                    try\n                    {\n                        return next( currentId );\n                    }\n                    finally\n                    {\n                        currentId++;\n                    }\n          ",
    "ID_18": "public final class Predicates {\n\n    //we don't want instances. private constructor.\n    private Predicates() {\n    }\n\n    public static Predicate instanceOf(final Class klass) {\n        return new InstanceOfPredicate(klass);\n    }\n\n    private static Comparable readAttribute(Map.Entry entry, String attribute) {\n        QueryableEntry queryableEntry = (QueryableEntry) entry;\n        Comparable value = queryableEntry.getAttribute(attribute);\n        if (value == null) {\n            return IndexImpl.NULL;\n        }\n        return value;\n    }\n\n    public static Predicate and(Predicate... predicates) {\n        return new AndPredicate(predicates);\n    }\n\n    public static Predicate not(Predicate predicate) {\n        return new NotPredicate(predicate);\n    }\n\n    /**\n     * Or predicate\n     *\n     * @param predicates\n     * @return\n     */\n    public static Predicate or(Predicate... predicates) {\n        return new OrPredicate(predicates);\n    }\n\n    public static Predicate notEqual(String attribute, Comparable y) {\n        return new NotEqualPredicate(attribute, y);\n    }\n\n    public static Predicate equal(String attribute, Comparable y) {\n        return new EqualPredicate(attribute, y);\n    }\n\n    public static Predicate like(String attribute, String pattern) {\n        return new LikePredicate(attribute, pattern);\n    }\n\n    public static Predicate ilike(String attribute, String pattern) {\n        return new ILikePredicate(attribute, pattern);\n    }\n\n    public static Predicate regex(String attribute, String pattern) {\n        return new RegexPredicate(attribute, pattern);\n    }\n\n    public static Predicate greaterThan(String x, Comparable y) {\n        return new GreaterLessPredicate(x, y, false, false);\n    }\n\n    public static Predicate greaterEqual(String x, Comparable y) {\n        return new GreaterLessPredicate(x, y, true, false);\n    }\n\n    public static Predicate lessThan(String x, Comparable y) {\n        return new GreaterLessPredicate(x, y, false, true);\n    }\n\n    public static Predicate lessEqual(String x, Comparable y) {\n        return new GreaterLessPredicate(x, y, true, true);\n    }\n\n    public static Predicate between(String attribute, Comparable from, Comparable to) {\n        return new BetweenPredicate(attribute, from, to);\n    }\n\n    public static Predicate in(String attribute, Comparable... values) {\n        return new InPredicate(attribute, values);\n    }\n\n    /**\n     * Between Predicate\n     */\n    public static class BetweenPredicate extends AbstractPredicate {\n        private Comparable to;\n        private Comparable from;\n\n        public BetweenPredicate() {\n        }\n\n        public BetweenPredicate(String first, Comparable from, Comparable to) {\n            super(first);\n            if (from == null || to == null) {\n                throw new NullPointerException(\"Arguments can't be null\");\n            }\n            this.from = from;\n            this.to = to;\n        }\n\n        @Override\n        public boolean apply(Map.Entry entry) {\n            Comparable entryValue = readAttribute(entry);\n            if (entryValue == null) {\n                return false;\n            }\n            Comparable fromConvertedValue = convert(entry, entryValue, from);\n            Comparable toConvertedValue = convert(entry, entryValue, to);\n            if (fromConvertedValue == null || toConvertedValue == null) {\n                return false;\n            }\n            return entryValue.compareTo(fromConvertedValue) >= 0 && entryValue.compareTo(toConvertedValue) <= 0;\n        }\n\n        @Override\n        public Set<QueryableEntry> filter(QueryContext queryContext) {\n            Index index = getIndex(queryContext);\n            return index.getSubRecordsBetween(from, to);\n        }\n\n        @Override\n        public void writeData(ObjectDataOutput out) throws IOException {\n            super.writeData(out);\n            out.writeObject(to);\n            out.writeObject(from);\n        }\n\n        @Override\n        public void readData(ObjectDataInput in) throws IOException {\n            super.readData(in);\n            to = in.readObject();\n            from = in.readObject();\n        }\n\n        @Override\n        public String toString() {\n            return attribute + \" BETWEEN \" + from + \" AND \" + to;\n        }\n    }\n\n    /**\n     * Not Predicate\n     */\n    public static class NotPredicate implements Predicate, DataSerializable {\n        private Predicate predicate;\n\n        public NotPredicate(Predicate predicate) {\n            this.predicate = predicate;\n        }\n\n        public NotPredicate() {\n        }\n\n        @Override\n        public boolean apply(Map.Entry mapEntry) {\n            return !predicate.apply(mapEntry);\n        }\n\n        @Override\n        public void writeData(ObjectDataOutput out) throws IOException {\n            out.writeObject(predicate);\n        }\n\n        @Override\n        public void readData(ObjectDataInput in) throws IOException {\n            predicate = in.readObject();\n        }\n\n        @Override\n        public String toString() {\n            return \"NOT(\" + predicate + \")\";\n        }\n    }\n\n    /**\n     * In Predicate\n     */\n    public static class InPredicate extends AbstractPredicate {\n        private Comparable[] values;\n        private volatile Set<Comparable> convertedInValues;\n\n        public InPredicate() {\n        }\n\n        public InPredicate(String attribute, Comparable... values) {\n            super(attribute);\n\n            if (values == null) {\n                throw new NullPointerException(\"Array can't be null\");\n            }\n            this.values = values;\n        }\n\n        @Override\n        public boolean apply(Map.Entry entry) {\n            Comparable entryValue = readAttribute(entry);\n            if (entryValue == null) {\n                return false;\n            }\n            Set<Comparable> set = convertedInValues;\n            if (set == null) {\n                set = new HashSet<Comparable>(values.length);\n                for (Comparable value : values) {\n                    set.add(convert(entry, entryValue, value));\n                }\n                convertedInValues = set;\n            }\n            return set.contains(entryValue);\n        }\n\n        @Override\n        public Set<QueryableEntry> filter(QueryContext queryContext) {\n            Index index = getIndex(queryContext);\n            if (index != null) {\n                return index.getRecords(values);\n            } else {\n                return null;\n            }\n        }\n\n        @Override\n        public void writeData(ObjectDataOutput out) throws IOException {\n            super.writeData(out);\n            out.writeInt(values.length);\n            for (Object value : values) {\n                out.writeObject(value);\n            }\n        }\n\n        @Override\n        public void readData(ObjectDataInput in) throws IOException {\n            super.readData(in);\n            int len = in.readInt();\n            values = new Comparable[len];\n            for (int i = 0; i < len; i++) {\n                values[i] = in.readObject();\n            }\n        }\n\n        @Override\n        public String toString() {\n            final StringBuilder sb = new StringBuilder();\n            sb.append(attribute);\n            sb.append(\" IN (\");\n            for (int i = 0; i < values.length; i++) {\n                if (i > 0) {\n                    sb.append(\",\");\n                }\n                sb.append(values[i]);\n            }\n            sb.append(\")\");\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Regex Predicate\n     */\n    public static class RegexPredicate implements Predicate, DataSerializable {\n        private String attribute;\n        private String regex;\n        private volatile Pattern pattern;\n\n        public RegexPredicate() {\n        }\n\n        public RegexPredicate(String attribute, String regex) {\n            this.attribute = attribute;\n            this.regex = regex;\n        }\n\n        @Override\n        public boolean apply(Map.Entry entry) {\n            Comparable attribute = readAttribute(entry, this.attribute);\n            String firstVal = attribute == IndexImpl.NULL ? null : (String) attribute;\n            if (firstVal == null) {\n                return (regex == null);\n            } else if (regex == null) {\n                return false;\n            } else {\n                if (pattern == null) {\n                    pattern = Pattern.compile(regex);\n                }\n                Matcher m = pattern.matcher(firstVal);\n                return m.matches();\n            }\n        }\n\n        @Override\n        public void writeData(ObjectDataOutput out) throws IOException {\n            out.writeUTF(attribute);\n            out.writeUTF(regex);\n        }\n\n        @Override\n        public void readData(ObjectDataInput in) throws IOException {\n            attribute = in.readUTF();\n            regex = in.readUTF();\n        }\n\n        @Override\n        public String toString() {\n            return attribute + \" REGEX '\" + regex + \"'\";\n        }\n    }\n\n    /**\n     * Like Predicate\n     */\n    public static class LikePredicate implements Predicate, DataSerializable {\n        protected String attribute;\n        protected String second;\n        private volatile Pattern pattern;\n\n        public LikePredicate() {\n        }\n\n        public LikePredicate(String attribute, String second) {\n            this.attribute = attribute;\n            this.second = second;\n        }\n\n        @Override\n        public boolean apply(Map.Entry entry) {\n            Comparable attribute = readAttribute(entry, this.attribute);\n            String firstVal = attribute == IndexImpl.NULL ? null : (String) attribute;\n            if (firstVal == null) {\n                return (second == null);\n            } else if (second == null) {\n                return false;\n            } else {\n                if (pattern == null) {\n                    // we quote the input string then escape then replace % and _\n                    // at the end we have a regex pattern look like : \\QSOME_STRING\\E.*\\QSOME_OTHER_STRING\\E\n                    final String quoted = Pattern.quote(second);\n                    String regex = quoted\n                            //escaped %\n                            .replaceAll(\"(?<!\\\\\\\\)[%]\", \"\\\\\\\\E.*\\\\\\\\Q\")\n                                    //escaped _\n                            .replaceAll(\"(?<!\\\\\\\\)[_]\", \"\\\\\\\\E.\\\\\\\\Q\")\n                                    //non escaped %\n                            .replaceAll(\"\\\\\\\\%\", \"%\")\n                                    //non escaped _\n                            .replaceAll(\"\\\\\\\\_\", \"_\");\n                    int flags = getFlags();\n                    pattern = Pattern.compile(regex, flags);\n                }\n                Matcher m = pattern.matcher(firstVal);\n                return m.matches();\n            }\n        }\n\n        @Override\n        public void writeData(ObjectDataOutput out) throws IOException {\n            out.writeUTF(attribute);\n            out.writeUTF(second);\n        }\n\n        @Override\n        public void readData(ObjectDataInput in) throws IOException {\n            attribute = in.readUTF();\n            second = in.readUTF();\n        }\n\n\n        protected int getFlags() {\n            //no addFlag\n            return 0;\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder builder = new StringBuilder(attribute)\n                    .append(\" LIKE '\")\n                    .append(second)\n                    .append(\"'\");\n            return builder.toString();\n        }\n    }\n\n    /**\n     * Ilike Predicate\n     */\n    public static class ILikePredicate extends LikePredicate {\n\n        public ILikePredicate() {\n        }\n\n        public ILikePredicate(String attribute, String second) {\n            super(attribute, second);\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder builder = new StringBuilder(attribute)\n                    .append(\" ILIKE '\")\n                    .append(second)\n                    .append(\"'\");\n            return builder.toString();\n        }\n\n\n        @Override\n        protected int getFlags() {\n            return Pattern.CASE_INSENSITIVE;\n        }\n    }\n\n    /**\n     * And Predicate\n     */\n    public static class AndPredicate implements IndexAwarePredicate, DataSerializable {\n\n        protected Predicate[] predicates;\n\n        public AndPredicate() {\n        }\n\n        public AndPredicate(Predicate... predicates) {\n            this.predicates = predicates;\n        }\n\n        @Override\n        public Set<QueryableEntry> filter(QueryContext queryContext) {\n            Set<QueryableEntry> smallestIndexedResult = null;\n            List<Set<QueryableEntry>> otherIndexedResults = new LinkedList<Set<QueryableEntry>>();\n            List<Predicate> lsNoIndexPredicates = null;\n            for (Predicate predicate : predicates) {\n                boolean indexed = false;\n                if (predicate instanceof IndexAwarePredicate) {\n                    IndexAwarePredicate iap = (IndexAwarePredicate) predicate;\n                    if (iap.isIndexed(queryContext)) {\n                        indexed = true;\n                        Set<QueryableEntry> s = iap.filter(queryContext);\n                        if (smallestIndexedResult == null) {\n                            smallestIndexedResult = s;\n                        } else if (s.size() < smallestIndexedResult.size()) {\n                            otherIndexedResults.add(smallestIndexedResult);\n                            smallestIndexedResult = s;\n                        } else {\n                            otherIndexedResults.add(s);\n                        }\n                    }\n                }\n                if (!indexed) {\n                    if (lsNoIndexPredicates == null) {\n                        lsNoIndexPredicates = new LinkedList<Predicate>();\n                    }\n                    lsNoIndexPredicates.add(predicate);\n                }\n            }\n            if (smallestIndexedResult == null) {\n                return null;\n            }\n            return new AndResultSet(smallestIndexedResult, otherIndexedResults, lsNoIndexPredicates);\n        }\n\n        @Override\n        public boolean isIndexed(QueryContext queryContext) {\n            for (Predicate predicate : predicates) {\n                if (predicate instanceof IndexAwarePredicate) {\n                    IndexAwarePredicate iap = (IndexAwarePredicate) predicate;\n                    if (iap.isIndexed(queryContext)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public boolean apply(Map.Entry mapEntry) {\n            for (Predicate predicate : predicates) {\n                if (!predicate.apply(mapEntry)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        @Override\n        public String toString() {\n            final StringBuilder sb = new StringBuilder();\n            sb.append(\"(\");\n            int size = predicates.length;\n            for (int i = 0; i < size; i++) {\n                if (i > 0) {\n                    sb.append(\" AND \");\n                }\n                sb.append(predicates[i]);\n            }\n            sb.append(\")\");\n            return sb.toString();\n        }\n\n        @Override\n        public void writeData(ObjectDataOutput out) throws IOException {\n            out.writeInt(predicates.length);\n            for (Predicate predicate : predicates) {\n                out.writeObject(predicate);\n            }\n        }\n\n        @Override\n        public void readData(ObjectDataInput in) throws IOException {\n            int size = in.readInt();\n            predicates = new Predicate[size];\n            for (int i = 0; i < size; i++) {\n                predicates[i] = in.readObject();\n            }\n        }\n    }\n\n    /**\n     * Or Predicate\n     */\n    public static class OrPredicate implements IndexAwarePredicate, DataSerializable {\n\n        private Predicate[] predicates;\n\n        public OrPredicate() {\n        }\n\n        public OrPredicate(Predicate... predicates) {\n            this.predicates = predicates;\n        }\n\n        @Override\n        public Set<QueryableEntry> filter(QueryContext queryContext) {\n            List<Set<QueryableEntry>> indexedResults = new LinkedList<Set<QueryableEntry>>();\n            for (Predicate predicate : predicates) {\n                if (predicate instanceof IndexAwarePredicate) {\n                    IndexAwarePredicate iap = (IndexAwarePredicate) predicate;\n                    if (iap.isIndexed(queryContext)) {\n                        Set<QueryableEntry> s = iap.filter(queryContext);\n                        if (s != null) {\n                            indexedResults.add(s);\n                        }\n                    } else {\n                        return null;\n                    }\n                }\n            }\n            return indexedResults.isEmpty() ? null : new OrResultSet(indexedResults);\n        }\n\n        @Override\n        public boolean isIndexed(QueryContext queryContext) {\n            for (Predicate predicate : predicates) {\n                if (predicate instanceof IndexAwarePredicate) {\n                    IndexAwarePredicate iap = (IndexAwarePredicate) predicate;\n                    if (!iap.isIndexed(queryContext)) {\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        @Override\n        public boolean apply(Map.Entry mapEntry) {\n            for (Predicate predicate : predicates) {\n                if (predicate.apply(mapEntry)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n\n        @Override\n        public void writeData(ObjectDataOutput out) throws IOException {\n            out.writeInt(predicates.length);\n            for (Predicate predicate : predicates) {\n                out.writeObject(predicate);\n            }\n        }\n\n        @Override\n        public void readData(ObjectDataInput in) throws IOException {\n            int size = in.readInt();\n            predicates = new Predicate[size];\n            for (int i = 0; i < size; i++) {\n                predicates[i] = in.readObject();\n            }\n        }\n\n        @Override\n        public String toString() {\n            final StringBuilder sb = new StringBuilder();\n            sb.append(\"(\");\n            int size = predicates.length;\n            for (int i = 0; i < size; i++) {\n                if (i > 0) {\n                    sb.append(\" OR \");\n                }\n                sb.append(predicates[i]);\n            }\n            sb.append(\")\");\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Greater Less Predicate\n     */\n    public static class GreaterLessPredicate extends EqualPredicate {\n        boolean equal;\n        boolean less;\n\n        public GreaterLessPredicate() {\n        }\n\n        public GreaterLessPredicate(String attribute, Comparable value, boolean equal, boolean less) {\n            super(attribute);\n\n            if (value == null) {\n                throw new NullPointerException(\"Arguments can't be null\");\n            }\n\n            this.value = value;\n            this.equal = equal;\n            this.less = less;\n        }\n\n        @Override\n        public boolean apply(Map.Entry mapEntry) {\n            final Comparable entryValue = readAttribute(mapEntry);\n            if (entryValue == null) {\n                return false;\n            }\n            final Comparable attributeValue = convert(mapEntry, entryValue, value);\n            final int result = entryValue.compareTo(attributeValue);\n            return equal && result == 0 || (less ? (result < 0) : (result > 0));\n        }\n\n        @Override\n        public Set<QueryableEntry> filter(QueryContext queryContext) {\n            Index index = getIndex(queryContext);\n            final ComparisonType comparisonType;\n            if (less) {\n                comparisonType = equal ? ComparisonType.LESSER_EQUAL : ComparisonType.LESSER;\n            } else {\n                comparisonType = equal ? ComparisonType.GREATER_EQUAL : ComparisonType.GREATER;\n            }\n            return index.getSubRecords(comparisonType, value);\n        }\n\n        @Override\n        public void readData(ObjectDataInput in) throws IOException {\n            super.readData(in);\n            equal = in.readBoolean();\n            less = in.readBoolean();\n        }\n\n        @Override\n        public void writeData(ObjectDataOutput out) throws IOException {\n            super.writeData(out);\n            out.writeBoolean(equal);\n            out.writeBoolean(less);\n        }\n\n        @Override\n        public String toString() {\n            final StringBuilder sb = new StringBuilder();\n            sb.append(attribute);\n            sb.append(less ? \"<\" : \">\");\n            if (equal) {\n                sb.append(\"=\");\n            }\n            sb.append(value);\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Not Equal Predicate\n     */\n    public static class NotEqualPredicate extends EqualPredicate {\n        public NotEqualPredicate() {\n        }\n\n        public NotEqualPredicate(String attribute, Comparable value) {\n            super(attribute, value);\n        }\n\n        @Override\n        public boolean apply(Map.Entry entry) {\n            Comparable entryValue = readAttribute(entry);\n            if (entryValue == null) {\n                return false;\n            }\n\n            return !super.apply(entry);\n        }\n\n        @Override\n        public Set<QueryableEntry> filter(QueryContext queryContext) {\n            Index index = getIndex(queryContext);\n            if (index != null) {\n                return index.getSubRecords(ComparisonType.NOT_EQUAL, value);\n            } else {\n                return null;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return attribute + \" != \" + value;\n        }\n    }\n\n    /**\n     * Equal Predicate\n     */\n    public static class EqualPredicate extends AbstractPredicate {\n        protected Comparable value;\n\n        public EqualPredicate() {\n        }\n\n        public EqualPredicate(String attribute) {\n            super(attribute);\n        }\n\n        public EqualPredicate(String attribute, Comparable value) {\n            super(attribute);\n            this.value = value;\n        }\n\n        @Override\n        public Set<QueryableEntry> filter(QueryContext queryContext) {\n            Index index = getIndex(queryContext);\n            return index.getRecords(value);\n        }\n\n        @Override\n        public boolean apply(Map.Entry mapEntry) {\n            Comparable entryValue = readAttribute(mapEntry);\n            if (entryValue == null) {\n                return value == null || value == IndexImpl.NULL;\n            }\n            value = convert(mapEntry, entryValue, value);\n            return entryValue.equals(value);\n        }\n\n        @Override\n        public void writeData(ObjectDataOutput out) throws IOException {\n            super.writeData(out);\n            out.writeObject(value);\n        }\n\n        @Override\n        public void readData(ObjectDataInput in) throws IOException {\n            super.readData(in);\n            value = in.readObject();\n        }\n\n        @Override\n        public String toString() {\n            return attribute + \"=\" + value;\n        }\n    }\n\n    /**\n     * Provides some functionality for some predicates\n     * such as Between, In.\n     */\n    public abstract static class AbstractPredicate implements IndexAwarePredicate, DataSerializable {\n\n        protected String attribute;\n        private transient volatile AttributeType attributeType;\n\n        protected AbstractPredicate() {\n        }\n\n        protected AbstractPredicate(String attribute) {\n            this.attribute = attribute;\n        }\n\n        protected Comparable convert(Map.Entry mapEntry, Comparable entryValue, Comparable attributeValue) {\n            if (attributeValue == null) {\n                return null;\n            }\n            if (attributeValue instanceof IndexImpl.NullObject) {\n                return IndexImpl.NULL;\n            }\n            AttributeType type = attributeType;\n            if (type == null) {\n                QueryableEntry queryableEntry = (QueryableEntry) mapEntry;\n                type = queryableEntry.getAttributeType(attribute);\n                attributeType = type;\n            }\n            if (type == AttributeType.ENUM) {\n                // if attribute type is enum, convert given attribute to enum string\n                return type.getConverter().convert(attributeValue);\n            } else {\n                // if given attribute value is already in expected type then there's no need for conversion.\n                if (entryValue != null && entryValue.getClass().isAssignableFrom(attributeValue.getClass())) {\n                    return attributeValue;\n                } else if (type != null) {\n                    return type.getConverter().convert(attributeValue);\n                } else {\n                    throw new QueryException(\"Unknown attribute type: \" + attributeValue.getClass().getName()\n                            + \" for attribute: \" + attribute);\n                }\n            }\n        }\n\n        @Override\n        public boolean isIndexed(QueryContext queryContext) {\n            return getIndex(queryContext) != null;\n        }\n\n        protected Index getIndex(QueryContext queryContext) {\n            return queryContext.getIndex(attribute);\n        }\n\n        protected Comparable readAttribute(Map.Entry entry) {\n            QueryableEntry queryableEntry = (QueryableEntry) entry;\n            Comparable val = queryableEntry.getAttribute(attribute);\n            if (val != null && val.getClass().isEnum()) {\n                val = val.toString();\n            }\n            return val;\n        }\n\n        @Override\n        public void writeData(ObjectDataOutput out) throws IOException {\n            out.writeUTF(attribute);\n        }\n\n        @Override\n        public void readData(ObjectDataInput in) throws IOException {\n            attribute = in.readUTF();\n        }\n    }\n\n    private static class InstanceOfPredicate implements Predicate, DataSerializable {\n        private Class klass;\n\n        public InstanceOfPredicate(Class klass) {\n            this.klass = klass;\n        }\n\n        @Override\n        public boolean apply(Map.Entry mapEntry) {\n            Object value = mapEntry.getValue();\n            if (value == null) {\n                return false;\n            }\n            return klass.isAssignableFrom(value.getClass());\n        }\n\n        @Override\n        public void writeData(ObjectDataOutput out) throws IOException {\n            out.writeUTF(klass.getName());\n        }\n\n        @Override\n        public void readData(ObjectDataInput in) throws IOException {\n            String klassName = in.readUTF();\n            try {\n                klass = in.getClassLoader().loadClass(klassName);\n            } catch (ClassNotFoundException e) {\n                throw new HazelcastSerializationException(\"Failed to load class: \" + klass, e);\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \" instanceOf (\" + klass.getName() + \")\";\n        }\n    }\n}",
    "ID_19": "public class CodecModel {\n\n    private static final String PARAMETERS_PACKAGE = \"com.hazelcast.client.impl.protocol.codec.\";\n    private static final String DATA_FULL_NAME = \"com.hazelcast.nio.serialization.Data\";\n\n    private final Lang lang;\n    private String name;\n    private String className;\n    private String parentName;\n    private String packageName;\n\n    private int retryable;\n    private int response;\n\n    private final List<ParameterModel> requestParams = new LinkedList();\n    private final List<ParameterModel> responseParams = new LinkedList();\n    private final List<EventModel> events = new LinkedList();\n\n    public CodecModel(TypeElement parent, ExecutableElement methodElement, ExecutableElement responseElement,\n                      List<ExecutableElement> eventElementList, boolean retryable, Lang lang) {\n        this.retryable = retryable ? 1 : 0;\n        this.lang = lang;\n\n        name = methodElement.getSimpleName().toString();\n        parentName = parent.getAnnotation(GenerateCodec.class).name();\n        className = CodeGenerationUtils.capitalizeFirstLetter(parentName)\n                + CodeGenerationUtils.capitalizeFirstLetter(name) + \"Codec\";\n        packageName = \"com.hazelcast.client.impl.protocol.codec\";\n\n        //        if (lang != Lang.JAVA) {\n        //            packageName = classElement.getAnnotation(GenerateParameters.class).ns();\n        //        }\n\n        response = methodElement.getAnnotation(Request.class).response();\n        initParameters(methodElement, responseElement, eventElementList, lang);\n\n    }\n\n    private void initParameters(ExecutableElement methodElement, ExecutableElement responseElement,\n                                List<ExecutableElement> eventElementList, Lang lang) {\n        //request parameters\n        for (VariableElement param : methodElement.getParameters()) {\n            final Nullable nullable = param.getAnnotation(Nullable.class);\n\n            ParameterModel pm = new ParameterModel();\n            pm.name = param.getSimpleName().toString();\n            pm.type = param.asType().toString();\n            pm.lang = lang;\n            pm.isPrimitive = param.asType().getKind().isPrimitive();\n            pm.isNullable = nullable != null;\n            requestParams.add(pm);\n        }\n\n        //response parameters\n        for (VariableElement param : responseElement.getParameters()) {\n            final Nullable nullable = param.getAnnotation(Nullable.class);\n            ParameterModel pm = new ParameterModel();\n            pm.name = param.getSimpleName().toString();\n            pm.type = param.asType().toString();\n            pm.lang = lang;\n            pm.isPrimitive = param.asType().getKind().isPrimitive();\n            pm.isNullable = nullable != null;\n            responseParams.add(pm);\n        }\n\n\n        //event parameters\n        for (ExecutableElement element : eventElementList) {\n            List<ParameterModel> eventParam = new ArrayList<ParameterModel>();\n            for (VariableElement param : element.getParameters()) {\n                final Nullable nullable = param.getAnnotation(Nullable.class);\n                ParameterModel pm = new ParameterModel();\n                pm.name = param.getSimpleName().toString();\n                pm.type = param.asType().toString();\n                pm.lang = lang;\n                pm.isPrimitive = param.asType().getKind().isPrimitive();\n                pm.isNullable = nullable != null;\n                eventParam.add(pm);\n            }\n\n            EventModel eventModel = new EventModel();\n            eventModel.type = element.getAnnotation(EventResponse.class).value();\n            eventModel.name = element.getSimpleName().toString();\n            eventModel.eventParams = eventParam;\n\n            events.add(eventModel);\n        }\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getClassName() {\n        return className;\n    }\n\n    public String getParentName() {\n        return parentName;\n    }\n\n    public String getPackageName() {\n        return packageName;\n    }\n\n    public int getResponse() {\n        return response;\n    }\n\n    public List<ParameterModel> getRequestParams() {\n        return requestParams;\n    }\n\n    public List<ParameterModel> getResponseParams() {\n        return responseParams;\n    }\n\n    public List<EventModel> getEvents() {\n        return events;\n    }\n\n    public int getRetryable() {\n        return retryable;\n    }\n\n    public static class EventModel {\n        private String name;\n        private List<ParameterModel> eventParams;\n        private int type;\n\n        public int getType() {\n            return type;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public String getTypeString() {\n            return \"EVENT_\" + name.toUpperCase();\n        }\n\n        public List<ParameterModel> getEventParams() {\n            return eventParams;\n        }\n    }\n\n    public static class ParameterModel {\n        private String name;\n        private String type;\n        private Lang lang;\n        private boolean isNullable;\n        private boolean isPrimitive;\n\n        public String getName() {\n            return name;\n        }\n\n        public String getType() {\n            if (lang == Lang.CSHARP) {\n                return convertTypeToCSharp(type);\n            }\n            if (type.startsWith(\"java.util.List<\") || type.startsWith(\"java.util.Set<\")\n                    || type.startsWith(\"java.util.Collection<\")) {\n                return type.replaceAll(\"java.util.*<(.*)>\", \"java.util.Collection<$1>\");\n            }\n            return type;\n        }\n\n        public String getSizeString() {\n            if (lang == Lang.CSHARP) {\n                return getSizeStringCSharp();\n            }\n            return getSizeStringJava();\n        }\n\n        public String getSizeStringJava() {\n            String stringJava = resolveSizeStringJava(type, name);\n            return getNullableCheckedSizeStringJava(stringJava);\n        }\n\n        private String getNullableCheckedSizeStringJava(String innerString) {\n            StringBuilder sizeString = new StringBuilder();\n            if (isNullable) {\n                sizeString.append(\"dataSize += Bits.BOOLEAN_SIZE_IN_BYTES;\\n\");\n                sizeString.append(\"        if (\" + name + \" != null) {\\n\");\n                sizeString.append(innerString);\n                sizeString.append(\"        }\\n\");\n                return sizeString.toString();\n            } else {\n                return innerString;\n            }\n        }\n\n        private String resolveSizeStringJava(String type, String name) {\n            StringBuilder sizeString = new StringBuilder();\n            if (type.equals(DATA_FULL_NAME)) {\n                sizeString.append(\"dataSize += ParameterUtil.calculateDataSize(\" + name + \");\");\n            } else if (type.equals(\"java.lang.Integer\")) {\n                sizeString.append(\"dataSize += Bits.INT_SIZE_IN_BYTES;\");\n            } else if (type.equals(\"java.lang.Boolean\")) {\n                sizeString.append(\"dataSize += Bits.BOOLEAN_SIZE_IN_BYTES;\");\n            } else if (type.equals(\"java.lang.String\")) {\n                sizeString.append(\"dataSize += ParameterUtil.calculateStringDataSize(\" + name + \");\");\n            } else if (type.equals(\"int\") || type.equals(\"long\") || type.equals(\"short\")\n                    || type.equals(\"byte\") || type.equals(\"boolean\")) {\n                sizeString.append(\"dataSize += Bits.\" + type.toUpperCase() + \"_SIZE_IN_BYTES;\");\n            } else if (type.equals(\"com.hazelcast.nio.Address\")) {\n                sizeString.append(\"dataSize += \" + PARAMETERS_PACKAGE + \"AddressCodec.calculateDataSize(\" + name + \");\");\n            } else if (type.equals(\"com.hazelcast.core.Member\")) {\n                sizeString.append(\"dataSize += \" + PARAMETERS_PACKAGE + \"MemberCodec.calculateDataSize(\" + name + \");\");\n            } else if (type.equals(\"com.hazelcast.cluster.client.MemberAttributeChange\")) {\n                sizeString.append(\"dataSize += \" + PARAMETERS_PACKAGE\n                        + \"MemberAttributeChangeCodec.calculateDataSize(\" + name + \");\");\n            } else if (type.equals(\"com.hazelcast.map.impl.SimpleEntryView<\" + DATA_FULL_NAME\n                    + \",\" + DATA_FULL_NAME + \">\")) {\n                sizeString.append(\"dataSize += \" + PARAMETERS_PACKAGE + \"EntryViewCodec.calculateDataSize(\" + name + \");\");\n            } else if (type.equals(\"com.hazelcast.client.impl.client.DistributedObjectInfo\")) {\n                sizeString.append(\"dataSize += \"\n                        + PARAMETERS_PACKAGE + \"DistributedObjectInfoCodec.calculateDataSize(\" + name + \");\");\n            } else if (type.equals(\"com.hazelcast.mapreduce.JobPartitionState\")) {\n                sizeString.append(\"dataSize += \"\n                        + PARAMETERS_PACKAGE + \"JobPartitionStateCodec.calculateDataSize(\" + name + \");\");\n            } else if (type.equals(\"javax.transaction.xa.Xid\")) {\n                sizeString.append(\"dataSize += \" + PARAMETERS_PACKAGE + \"XIDCodec.calculateDataSize(\" + name + \");\");\n            } else if (type.equals(\"com.hazelcast.map.impl.querycache.event.SingleEventData\")) {\n                sizeString.append(\"dataSize += \" + PARAMETERS_PACKAGE + \"SingleEventDataCodec.calculateDataSize(\" + name + \");\");\n            } else if (type.equals(\"com.hazelcast.cache.impl.CacheEventData\")) {\n                sizeString.append(\"dataSize += \" + PARAMETERS_PACKAGE + \"CacheEventDataCodec.calculateDataSize(\" + name + \");\");\n            } else if (type.startsWith(\"java.util.Map<\")) {\n                sizeString.append(getMapSizeStringJava(type, name));\n            } else if (type.startsWith(\"java.util.List<\") || type.startsWith(\"java.util.Set<\")\n                    || type.startsWith(\"java.util.Collection<\")) {\n\n                sizeString.append(getCollectionSizeString(name, type));\n\n            } else if (type.endsWith(\"[]\")) {\n                sizeString.append(getArraySizeString(type, name));\n            } else {\n                sizeString.append(CodeGenerationUtils.capitalizeFirstLetter(type) + \"Codec.calculateDataSize(\" + name + \");\");\n            }\n            return sizeString.toString();\n        }\n\n        private String getArraySizeString(String type, String name) {\n            String itemType = CodeGenerationUtils.getTypeInsideData(type);\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"dataSize += Bits.INT_SIZE_IN_BYTES;\\n        \");\n            builder.append(\"for (\" + itemType + \" \" + name + \"_item : \" + name + \" ) {\\n        \");\n            builder.append(\"    \" + resolveSizeStringJava(itemType, name + \"_item\") + \"\\n        \");\n            builder.append(\"}\\n        \");\n            return builder.toString();\n        }\n\n        private String getCollectionSizeString(String name, String type) {\n            String subType = CodeGenerationUtils.getTypeInsideCollection(type);\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"dataSize += Bits.INT_SIZE_IN_BYTES;\\n        \");\n            builder.append(\"for (\" + subType + \" \" + name + \"_item : \" + name + \" ) {\\n        \");\n            builder.append(\"    \" + resolveSizeStringJava(subType, name + \"_item\") + \"\\n        \");\n            builder.append(\"}\\n        \");\n            return builder.toString();\n        }\n\n        private String getMapSizeStringJava(String type, String name) {\n            StringBuilder builder = new StringBuilder();\n            String keyType = CodeGenerationUtils.getKeyTypeInsideMap(type);\n            builder.append(\"java.util.Collection<\" + keyType + \"> \" + name\n                    + \"_keySet = (java.util.Collection<\" + keyType + \">) \" + name + \".keySet();\\n     \");\n            builder.append(resolveSizeStringJava(\"java.util.Collection<\" + keyType + \"> \", name + \"_keySet\"));\n\n            String valueType = CodeGenerationUtils.getValueTypeInsideMap(type);\n            builder.append(\"java.util.Collection<\" + valueType + \"> \" + name\n                    + \"_values = (java.util.Collection<\" + valueType + \"> )\" + name + \".values();\\n       \");\n            builder.append(resolveSizeStringJava(\"java.util.Collection<\" + valueType + \">\", name + \"_values\"));\n            return builder.toString();\n        }\n\n\n        public String getSizeStringCSharp() {\n            if (type.equals(DATA_FULL_NAME)) {\n                return \"ParameterUtil.CalculateDataSize(\" + name + \")\";\n            } else if (type.equals(\"java.lang.String\")) {\n                return \"ParameterUtil.CalculateStringDataSize(\" + name + \")\";\n            } else if (type.equals(\"byte[]\")) {\n                return \"ParameterUtil.CalculateByteArrayDataSize(\" + name + \")\";\n            } else if (type.equals(\"java.util.List<\" + DATA_FULL_NAME + \" >\")\n                    || type.equals(\"java.util.Set<\" + DATA_FULL_NAME + \" >\")\n                    || type.equals(\"java.util.Collection<\" + DATA_FULL_NAME + \" >\")) {\n                return \"ParameterUtil.CalculateCollectionDataSize(\" + name + \")\";\n            }\n            return \"BitUtil.SizeOf\" + CodeGenerationUtils.capitalizeFirstLetter(type);\n        }\n\n        public String getDataGetterString() {\n            if (lang == Lang.CSHARP) {\n                return getDataGetterStringCSharp();\n            }\n            return getDataGetterStringJava();\n        }\n\n        public String getEventGetterString() {\n            String getterString = resolveDataGetterStringJava(type, name) + \"\\n        \";\n            return getNullableCheckedGetterStringJava(getterString);\n        }\n\n        public String getDataGetterStringJava() {\n            String getterString = resolveDataGetterStringJava(type, name) + \"\\n        \";\n            getterString += \"    parameters.\" + name + \" = \" + name + \"; \\n        \";\n            return getNullableCheckedGetterStringJava(getterString);\n        }\n\n        private String getNullableCheckedGetterStringJava(String innerGetterString) {\n            String getterString = type + \" \" + name + \";\\n        \";\n            if (!isPrimitive) {\n                getterString += name + \" = null ;\\n        \";\n            }\n\n            if (isNullable) {\n                getterString += \" boolean \" + name + \"_isNull = clientMessage.getBoolean();\\n        \";\n                getterString += \" if(!\" + name + \"_isNull) { \\n        \";\n            }\n\n            getterString += innerGetterString;\n\n            if (isNullable) {\n                getterString += \"\\n             }\\n        \";\n            }\n            return getterString;\n        }\n\n        private String resolveDataGetterStringJava(String type, String name) {\n            String getterString;\n\n            if (type.equals(DATA_FULL_NAME)) {\n                getterString = name + \" = clientMessage.getData();\";\n            } else if (type.equals(\"java.lang.Integer\")) {\n                getterString = name + \" = clientMessage.getInt();\";\n            } else if (type.equals(\"java.lang.Boolean\")) {\n                getterString = name + \" = clientMessage.getBoolean();\";\n            } else if (type.equals(\"java.lang.String\")) {\n                getterString = name + \" = clientMessage.getStringUtf8();\";\n            } else if (type.equals(\"com.hazelcast.nio.Address\")) {\n                getterString = name + \" = \" + PARAMETERS_PACKAGE + \"AddressCodec.decode(clientMessage);\";\n            } else if (type.equals(\"com.hazelcast.core.Member\")) {\n                getterString = name + \" = \" + PARAMETERS_PACKAGE + \"MemberCodec.decode(clientMessage);\";\n            } else if (type.equals(\"com.hazelcast.cluster.client.MemberAttributeChange\")) {\n                getterString = name + \" = \" + PARAMETERS_PACKAGE + \"MemberAttributeChangeCodec.decode(clientMessage);\";\n            } else if (type.equals(\"com.hazelcast.map.impl.SimpleEntryView<\" + DATA_FULL_NAME\n                    + \",\" + DATA_FULL_NAME + \">\")) {\n                getterString = name + \" = \" + PARAMETERS_PACKAGE + \"EntryViewCodec.decode(clientMessage);\";\n            } else if (type.equals(\"com.hazelcast.client.impl.client.DistributedObjectInfo\")) {\n                getterString = name + \" = \" + PARAMETERS_PACKAGE + \"DistributedObjectInfoCodec.decode(clientMessage);\";\n            } else if (type.equals(\"com.hazelcast.mapreduce.JobPartitionState\")) {\n                getterString = name + \" = \" + PARAMETERS_PACKAGE + \"JobPartitionStateCodec.decode(clientMessage);\";\n            } else if (type.equals(\"javax.transaction.xa.Xid\")) {\n                getterString = name + \" = \" + PARAMETERS_PACKAGE + \"XIDCodec.decode(clientMessage);\";\n            } else if (type.equals(\"com.hazelcast.cache.impl.CacheEventData\")) {\n                getterString = name + \" = \" + PARAMETERS_PACKAGE + \"CacheEventDataCodec.decode(clientMessage);\";\n            } else if (type.equals(\"com.hazelcast.map.impl.querycache.event.SingleEventData\")) {\n                getterString = name + \" = \" + PARAMETERS_PACKAGE + \"SingleEventDataCodec.decode(clientMessage);\";\n            } else if (type.startsWith(\"java.util.Map<\")) {\n                getterString = getMapGetterString(type, name);\n            } else if (type.startsWith(\"java.util.List<\") || type.startsWith(\"java.util.Set<\")\n                    || type.startsWith(\"java.util.Collection<\")) {\n                getterString = getCollectionGetterString(type, name);\n            } else if (type.endsWith(\"[]\")) {\n                getterString = getArrayGetterString(type, name);\n            } else {\n                getterString = name + \" = clientMessage.get\" + CodeGenerationUtils.capitalizeFirstLetter(type) + \"();\";\n            }\n\n\n            return getterString;\n        }\n\n        private String getArrayGetterString(String type, String name) {\n            String itemVariableType = CodeGenerationUtils.getTypeInsideData(type);\n            String itemVariableName = name + \"_item\";\n\n            String sizeVariableName = name + \"_size\";\n            String indexVariableName = name + \"_index\";\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"int \" + sizeVariableName + \" = clientMessage.getInt();\\n        \");\n            builder.append(name + \" = new \" + itemVariableType + \"[\" + sizeVariableName + \"];\\n        \");\n            builder.append(\"for (int \" + indexVariableName + \" = 0; \" + indexVariableName + \" < \"\n                    + sizeVariableName + \"; \" + indexVariableName + \"++) {\\n        \");\n            builder.append(\"    \" + itemVariableType + \" \"\n                    + resolveDataGetterStringJava(itemVariableType, itemVariableName) + \"\\n        \");\n            builder.append(\"    \" + name + \"[\" + indexVariableName + \"] = \" + itemVariableName + \";\");\n            builder.append(\"}\\n        \");\n            return builder.toString();\n        }\n\n        private String getCollectionGetterString(String type, String name) {\n            String itemVariableType = CodeGenerationUtils.getTypeInsideCollection(type);\n            String itemVariableName = name + \"_item\";\n\n            StringBuilder builder = new StringBuilder();\n            String sizeVariableName = name + \"_size\";\n            String indexVariableName = name + \"_index\";\n\n            builder.append(\"int \" + sizeVariableName + \" = clientMessage.getInt();\\n        \");\n            String collectionType = getCollectionType(type);\n            builder.append(name + \" = new \" + collectionType + \"<\" + itemVariableType + \">(\"\n                    + sizeVariableName + \");\\n        \");\n            builder.append(\"for (int \" + indexVariableName + \" = 0; \" + indexVariableName + \" < \"\n                    + sizeVariableName + \"; \" + indexVariableName + \"++) {\\n        \");\n            builder.append(\"    \" + itemVariableType + \" \" + itemVariableName + \";\\n        \");\n            builder.append(\"    \" + resolveDataGetterStringJava(itemVariableType, itemVariableName) + \"\\n        \");\n            builder.append(\"    \" + name + \".add( \" + itemVariableName + \");\\n      \");\n            builder.append(\"}\\n        \");\n            return builder.toString();\n        }\n\n        private String getMapGetterString(String type, String name) {\n            String keyType = CodeGenerationUtils.getKeyTypeInsideMap(type);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"java.util.List<\" + keyType + \"> \" + name + \"_keySet;\\n     \");\n            builder.append(resolveDataGetterStringJava(\"java.util.List<\" + keyType + \"> \", name + \"_keySet\"));\n\n            String valueType = CodeGenerationUtils.getValueTypeInsideMap(type);\n            builder.append(\"java.util.List<\" + valueType + \"> \" + name + \"_values;\\n       \");\n            builder.append(resolveDataGetterStringJava(\"java.util.List<\" + valueType + \">\", name + \"_values\"));\n\n\n            String mapIndexVariableName = name + \"_index\";\n            builder.append(name + \" = new java.util.HashMap<\" + keyType + \",\" + valueType + \">();\\n       \");\n\n            builder.append(\"for (int \" + mapIndexVariableName + \" = 0; \" + mapIndexVariableName + \" < \"\n                    + name + \"_keySet_size; \" + mapIndexVariableName + \"++) {\\n        \");\n            builder.append(\"    \" + name + \".put( \" + name + \"_keySet.get(\" + mapIndexVariableName + \") , \"\n                    + name + \"_values.get(\" + mapIndexVariableName + \") );\\n        \");\n            builder.append(\"}\\n        \");\n\n            return builder.toString();\n        }\n\n        private String getCollectionType(String name) {\n            if (name.startsWith(\"java.util.Set\")) {\n                return \"java.util.HashSet\";\n            } else {\n                return \"java.util.ArrayList\";\n            }\n        }\n\n        public String getDataGetterStringCSharp() {\n            String getterString;\n            if (type.equals(DATA_FULL_NAME + \" \")) {\n                getterString = \"GetData\";\n            } else if (type.equals(\"java.lang.String\")) {\n                getterString = \"GetStringUtf8\";\n            } else if (type.equals(\"byte[]\")) {\n                getterString = \"GetByteArray\";\n            } else if (type.equals(\"java.util.List<\" + DATA_FULL_NAME + \" >\")) {\n                getterString = \"GetDataList\";\n            } else if (type.equals(\"java.util.Set<\" + DATA_FULL_NAME + \" >\")) {\n                getterString = \"GetDataSet\";\n            } else if (type.equals(\"java.util.Collection<\" + DATA_FULL_NAME + \" >\")) {\n                getterString = \"GetDataSet\";\n            } else {\n                getterString = \"Get\" + CodeGenerationUtils.capitalizeFirstLetter(type);\n            }\n            return getterString;\n        }\n\n\n        public String getDataSetterString() {\n//            if (lang == Lang.CSHARP) {\n//                return getDataSetterStringCSharp();\n//            }\n            return getDataSetterStringJava();\n        }\n\n        public String getDataSetterStringJava() {\n            String setterString = resolveDataSetterStringJava(type, name);\n            return getNullableCheckedSetterStringJava(setterString);\n        }\n\n        private String getNullableCheckedSetterStringJava(String innerGetterString) {\n            StringBuilder setterString = new StringBuilder();\n\n\n            String isNullVariableName = name + \"_isNull\";\n            if (isNullable) {\n                setterString.append(\"boolean \" + isNullVariableName + \";\\n            \");\n                setterString.append(\"if (\" + name + \" == null) {\\n            \");\n                setterString.append(\"    \" + isNullVariableName + \" = true;\\n            \");\n                setterString.append(\"    clientMessage.set(\" + isNullVariableName + \");\\n            \");\n                setterString.append(\"} else {\\n            \");\n                setterString.append(\"\" + isNullVariableName + \" = false;\\n            \");\n                setterString.append(\"clientMessage.set(\" + isNullVariableName + \");\\n            \");\n                setterString.append(innerGetterString);\n                setterString.append(\"} \\n            \");\n\n                return setterString.toString();\n            } else {\n                return innerGetterString;\n            }\n\n        }\n\n        private String resolveDataSetterStringJava(String type, String name) {\n            StringBuilder setterString = new StringBuilder();\n            if (type.equals(\"com.hazelcast.nio.Address\")) {\n                setterString.append(PARAMETERS_PACKAGE + \"AddressCodec.encode(\" + name + \",clientMessage);\");\n            } else if (type.equals(\"com.hazelcast.core.Member\")) {\n                setterString.append(PARAMETERS_PACKAGE + \"MemberCodec.encode(\" + name + \", clientMessage);\");\n            } else if (type.equals(\"com.hazelcast.cluster.client.MemberAttributeChange\")) {\n                setterString.append(PARAMETERS_PACKAGE\n                        + \"MemberAttributeChangeCodec.encode(\" + name + \", clientMessage);\");\n            } else if (type.equals(\"com.hazelcast.map.impl.SimpleEntryView<\" + DATA_FULL_NAME\n                    + \",\" + DATA_FULL_NAME + \">\")) {\n                setterString.append(PARAMETERS_PACKAGE + \"EntryViewCodec.encode(\" + name + \", clientMessage);\");\n            } else if (type.equals(\"com.hazelcast.client.impl.client.DistributedObjectInfo\")) {\n                setterString.append(PARAMETERS_PACKAGE + \"DistributedObjectInfoCodec.encode(\" + name + \", clientMessage);\");\n            } else if (type.equals(\"com.hazelcast.mapreduce.JobPartitionState\")) {\n                setterString.append(PARAMETERS_PACKAGE + \"JobPartitionStateCodec.encode(\" + name + \", clientMessage);\");\n            } else if (type.equals(\"javax.transaction.xa.Xid\")) {\n                setterString.append(PARAMETERS_PACKAGE + \"XIDCodec.encode(\" + name + \", clientMessage);\");\n            } else if (type.equals(\"com.hazelcast.cache.impl.CacheEventData\")) {\n                setterString.append(PARAMETERS_PACKAGE + \"CacheEventDataCodec.encode(\" + name + \", clientMessage);\");\n            } else if (type.equals(\"com.hazelcast.map.impl.querycache.event.SingleEventData\")) {\n                setterString.append(PARAMETERS_PACKAGE + \"SingleEventDataCodec.encode(\" + name + \", clientMessage);\");\n            } else if (type.startsWith(\"java.util.Map<\")) {\n                setterString.append(getMapSetterString(type, name));\n            } else if (type.startsWith(\"java.util.List<\") || type.startsWith(\"java.util.Set<\")\n                    || type.startsWith(\"java.util.Collection<\")) {\n                setterString.append(getCollectionSetterString(type, name));\n            } else if (type.endsWith(\"[]\")) {\n                setterString.append(getArraySetterString(type, name));\n            } else {\n                setterString.append(\"clientMessage.set(\" + name + \");\");\n            }\n            return setterString.toString();\n        }\n\n        private String getArraySetterString(String type, String name) {\n            String itemVariableName = name + \"_item\";\n\n            String itemVariableType = CodeGenerationUtils.getTypeInsideData(type);\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"clientMessage.set(\" + name + \".length);\\n        \");\n            builder.append(\"for (\" + itemVariableType + \" \" + itemVariableName + \" : \" + name + \" ) {\\n        \");\n            builder.append(\"    \" + resolveDataSetterStringJava(itemVariableType, itemVariableName) + \"\\n        \");\n            builder.append(\"}\\n        \");\n            return builder.toString();\n        }\n\n        private String getCollectionSetterString(String type, String name) {\n            String itemType = CodeGenerationUtils.getTypeInsideCollection(type);\n            String itemVariableName = name + \"_item\";\n\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"clientMessage.set(\" + name + \".size());\\n        \");\n            builder.append(\"for (\" + itemType + \" \" + itemVariableName + \": \" + name + \" ) {\\n        \");\n            builder.append(\"    \" + resolveDataSetterStringJava(itemType, itemVariableName) + \"\\n        \");\n            builder.append(\"}\\n        \");\n            return builder.toString();\n        }\n\n        private String getMapSetterString(String type, String name) {\n            StringBuilder builder = new StringBuilder();\n\n            String keyType = CodeGenerationUtils.getKeyTypeInsideMap(type);\n            builder.append(\"java.util.Collection<\" + keyType + \"> \" + name\n                    + \"_keySet = (java.util.Collection<\" + keyType + \">) \" + name + \".keySet();\\n     \");\n            builder.append(resolveDataSetterStringJava(\"java.util.Collection<\" + keyType + \"> \", name + \"_keySet\"));\n\n            String valueType = CodeGenerationUtils.getValueTypeInsideMap(type);\n            builder.append(\"java.util.Collection<\" + valueType + \"> \" + name\n                    + \"_values = (java.util.Collection<\" + valueType + \"> )\" + name + \".values();\\n       \");\n            builder.append(resolveDataSetterStringJava(\"java.util.Collection<\" + valueType + \">\", name + \"_values\"));\n\n            return builder.toString();\n        }\n//\n//        public String getDataSetterStringCSharp() {\n//            String getterString;\n//            if (type.equals(DATA_FULL_NAME  + \" \")) {\n//                getterString = \"GetData\";\n//            } else if (type.equals(\"java.lang.String\")) {\n//                getterString = \"GetStringUtf8\";\n//            } else if (type.equals(\"byte[]\")) {\n//                getterString = \"GetByteArray\";\n//            } else if (type.equals(\"java.util.List<\" + DATA_FULL_NAME  + \" >\")) {\n//                getterString = \"GetDataList\";\n//            } else if (type.equals(\"java.util.Set<\" + DATA_FULL_NAME  + \" >\")) {\n//                getterString = \"GetDataSet\";\n//            } else if (type.equals(\"java.util.Collection<\" + DATA_FULL_NAME  + \" >\")) {\n//                getterString = \"GetDataSet\";\n//            } else {\n//                getterString = \"Get\" + CodeGenerationUtils.capitalizeFirstLetter(type);\n//            }\n//            return getterString;\n//        }\n\n        public String convertTypeToCSharp(String type) {\n            String getterString;\n            if (type.equals(DATA_FULL_NAME + \" \")) {\n                getterString = \"IData\";\n            } else if (type.equals(\"java.lang.String\")) {\n                getterString = \"string\";\n            } else if (type.equals(\"boolean\")) {\n                getterString = \"bool\";\n            } else if (type.equals(\"java.util.List<\" + DATA_FULL_NAME + \" >\")) {\n                getterString = \"IList<IData>\";\n            } else if (type.equals(\"java.util.Set<\" + DATA_FULL_NAME + \" >\")) {\n                getterString = \"ISet<IData>\";\n            } else if (type.equals(\"java.util.Collection<\" + DATA_FULL_NAME + \" >\")) {\n                getterString = \"ICollection<IData>\";\n            } else {\n                getterString = type;\n            }\n            return getterString;\n        }\n\n        @Override\n        public String toString() {\n            return \"ParameterModel{\"\n                    + \"name='\" + name + '\\''\n                    + \", type='\" + type + '\\''\n                    + \", lang=\" + lang\n                    + '}';\n        }\n    }\n}",
    "ID_20": "public class CreateTableStatement extends SchemaAlteringStatement\n{\n    private List<AbstractType<?>> keyTypes;\n    private List<AbstractType<?>> clusteringTypes;\n\n    private Map<ByteBuffer, CollectionType> collections = new HashMap<>();\n\n    private final List<ColumnIdentifier> keyAliases = new ArrayList<>();\n    private final List<ColumnIdentifier> columnAliases = new ArrayList<>();\n    private ByteBuffer valueAlias;\n\n    private boolean isDense;\n    private boolean isCompound;\n    private boolean hasCounters;\n\n    // use a TreeMap to preserve ordering across JDK versions (see CASSANDRA-9492)\n    private final Map<ColumnIdentifier, AbstractType> columns = new TreeMap<>(new Comparator<ColumnIdentifier>()\n    {\n        public int compare(ColumnIdentifier o1, ColumnIdentifier o2)\n        {\n            return o1.bytes.compareTo(o2.bytes);\n        }\n    });\n    private final Set<ColumnIdentifier> staticColumns;\n    private final CFPropDefs properties;\n    private final boolean ifNotExists;\n\n    public CreateTableStatement(CFName name, CFPropDefs properties, boolean ifNotExists, Set<ColumnIdentifier> staticColumns)\n    {\n        super(name);\n        this.properties = properties;\n        this.ifNotExists = ifNotExists;\n        this.staticColumns = staticColumns;\n\n        if (!this.properties.hasProperty(CFPropDefs.KW_COMPRESSION) && CFMetaData.DEFAULT_COMPRESSOR != null)\n            this.properties.addProperty(CFPropDefs.KW_COMPRESSION,\n                                        new HashMap<String, String>()\n                                        {{\n                                            put(CompressionParameters.CLASS, CFMetaData.DEFAULT_COMPRESSOR);\n                                        }});\n    }\n\n    public void checkAccess(ClientState state) throws UnauthorizedException, InvalidRequestException\n    {\n        state.hasKeyspaceAccess(keyspace(), Permission.CREATE);\n    }\n\n    public void validate(ClientState state)\n    {\n        // validated in announceMigration()\n    }\n\n    public boolean announceMigration(boolean isLocalOnly) throws RequestValidationException\n    {\n        try\n        {\n            MigrationManager.announceNewColumnFamily(getCFMetaData(), isLocalOnly);\n            return true;\n        }\n        catch (AlreadyExistsException e)\n        {\n            if (ifNotExists)\n                return false;\n            throw e;\n        }\n    }\n\n    public Event.SchemaChange changeEvent()\n    {\n        return new Event.SchemaChange(Event.SchemaChange.Change.CREATED, Event.SchemaChange.Target.TABLE, keyspace(), columnFamily());\n    }\n\n    protected void grantPermissionsToCreator(QueryState state)\n    {\n        try\n        {\n            IResource resource = DataResource.table(keyspace(), columnFamily());\n            DatabaseDescriptor.getAuthorizer().grant(AuthenticatedUser.SYSTEM_USER,\n                                                     resource.applicablePermissions(),\n                                                     resource,\n                                                     RoleResource.role(state.getClientState().getUser().getName()));\n        }\n        catch (RequestExecutionException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public CFMetaData.Builder metadataBuilder()\n    {\n        CFMetaData.Builder builder = CFMetaData.Builder.create(keyspace(), columnFamily(), isDense, isCompound, hasCounters);\n        for (int i = 0; i < keyAliases.size(); i++)\n            builder.addPartitionKey(keyAliases.get(i), keyTypes.get(i));\n        for (int i = 0; i < columnAliases.size(); i++)\n            builder.addClusteringColumn(columnAliases.get(i), clusteringTypes.get(i));\n\n        boolean isStaticCompact = !isDense && !isCompound;\n        for (Map.Entry<ColumnIdentifier, AbstractType> entry : columns.entrySet())\n        {\n            ColumnIdentifier name = entry.getKey();\n            // Note that for \"static\" no-clustering compact storage we use static for the defined columns\n            if (staticColumns.contains(name) || isStaticCompact)\n                builder.addStaticColumn(name, entry.getValue());\n            else\n                builder.addRegularColumn(name, entry.getValue());\n        }\n\n        boolean isCompactTable = isDense || !isCompound;\n        if (isCompactTable)\n        {\n            CompactTables.DefaultNames names = CompactTables.defaultNameGenerator(builder.usedColumnNames());\n            // Compact tables always have a clustering and a single regular value.\n            if (isStaticCompact)\n            {\n                builder.addClusteringColumn(names.defaultClusteringName(), UTF8Type.instance);\n                builder.addRegularColumn(names.defaultCompactValueName(), hasCounters ? CounterColumnType.instance : BytesType.instance);\n            }\n            else if (isDense && !builder.hasRegulars())\n            {\n                // Even for dense, we might not have our regular column if it wasn't part of the declaration. If\n                // that's the case, add it but with a specific EmptyType so we can recognize that case later\n                builder.addRegularColumn(names.defaultCompactValueName(), EmptyType.instance);\n            }\n        }\n\n        return builder;\n    }\n\n    /**\n     * Returns a CFMetaData instance based on the parameters parsed from this\n     * <code>CREATE</code> statement, or defaults where applicable.\n     *\n     * @return a CFMetaData instance corresponding to the values parsed from this statement\n     * @throws InvalidRequestException on failure to validate parsed parameters\n     */\n    public CFMetaData getCFMetaData() throws RequestValidationException\n    {\n        CFMetaData newCFMD = metadataBuilder().build();\n        applyPropertiesTo(newCFMD);\n        return newCFMD;\n    }\n\n    public void applyPropertiesTo(CFMetaData cfmd) throws RequestValidationException\n    {\n        properties.applyToCFMetadata(cfmd);\n    }\n\n    public static class RawStatement extends CFStatement\n    {\n        private final Map<ColumnIdentifier, CQL3Type.Raw> definitions = new HashMap<>();\n        public final CFPropDefs properties = new CFPropDefs();\n\n        private final List<List<ColumnIdentifier>> keyAliases = new ArrayList<List<ColumnIdentifier>>();\n        private final List<ColumnIdentifier> columnAliases = new ArrayList<ColumnIdentifier>();\n        private final Map<ColumnIdentifier, Boolean> definedOrdering = new LinkedHashMap<ColumnIdentifier, Boolean>(); // Insertion ordering is important\n        private final Set<ColumnIdentifier> staticColumns = new HashSet<ColumnIdentifier>();\n\n        private boolean useCompactStorage;\n        private final Multiset<ColumnIdentifier> definedNames = HashMultiset.create(1);\n\n        private final boolean ifNotExists;\n\n        public RawStatement(CFName name, boolean ifNotExists)\n        {\n            super(name);\n            this.ifNotExists = ifNotExists;\n        }\n\n        /**\n         * Transform this raw statement into a CreateTableStatement.\n         */\n        public ParsedStatement.Prepared prepare() throws RequestValidationException\n        {\n            // Column family name\n            if (!columnFamily().matches(\"\\\\w+\"))\n                throw new InvalidRequestException(String.format(\"\\\"%s\\\" is not a valid table name (must be alphanumeric character only: [0-9A-Za-z]+)\", columnFamily()));\n            if (columnFamily().length() > Schema.NAME_LENGTH)\n                throw new InvalidRequestException(String.format(\"Table names shouldn't be more than %s characters long (got \\\"%s\\\")\", Schema.NAME_LENGTH, columnFamily()));\n\n            for (Multiset.Entry<ColumnIdentifier> entry : definedNames.entrySet())\n                if (entry.getCount() > 1)\n                    throw new InvalidRequestException(String.format(\"Multiple definition of identifier %s\", entry.getElement()));\n\n            properties.validate();\n\n            CreateTableStatement stmt = new CreateTableStatement(cfName, properties, ifNotExists, staticColumns);\n\n            for (Map.Entry<ColumnIdentifier, CQL3Type.Raw> entry : definitions.entrySet())\n            {\n                ColumnIdentifier id = entry.getKey();\n                CQL3Type pt = entry.getValue().prepare(keyspace());\n                if (pt.isCollection() && ((CollectionType)pt.getType()).isMultiCell())\n                    stmt.collections.put(id.bytes, (CollectionType)pt.getType());\n                if (entry.getValue().isCounter())\n                    stmt.hasCounters = true;\n                stmt.columns.put(id, pt.getType()); // we'll remove what is not a column below\n            }\n\n            if (keyAliases.isEmpty())\n                throw new InvalidRequestException(\"No PRIMARY KEY specifed (exactly one required)\");\n            if (keyAliases.size() > 1)\n                throw new InvalidRequestException(\"Multiple PRIMARY KEYs specifed (exactly one required)\");\n            if (stmt.hasCounters && properties.getDefaultTimeToLive() > 0)\n                throw new InvalidRequestException(\"Cannot set default_time_to_live on a table with counters\");\n\n            List<ColumnIdentifier> kAliases = keyAliases.get(0);\n            stmt.keyTypes = new ArrayList<AbstractType<?>>(kAliases.size());\n            for (ColumnIdentifier alias : kAliases)\n            {\n                stmt.keyAliases.add(alias);\n                AbstractType<?> t = getTypeAndRemove(stmt.columns, alias);\n                if (t instanceof CounterColumnType)\n                    throw new InvalidRequestException(String.format(\"counter type is not supported for PRIMARY KEY part %s\", alias));\n                if (staticColumns.contains(alias))\n                    throw new InvalidRequestException(String.format(\"Static column %s cannot be part of the PRIMARY KEY\", alias));\n                stmt.keyTypes.add(t);\n            }\n\n            stmt.clusteringTypes = new ArrayList<>(columnAliases.size());\n            // Handle column aliases\n            for (ColumnIdentifier t : columnAliases)\n            {\n                stmt.columnAliases.add(t);\n\n                AbstractType<?> type = getTypeAndRemove(stmt.columns, t);\n                if (type instanceof CounterColumnType)\n                    throw new InvalidRequestException(String.format(\"counter type is not supported for PRIMARY KEY part %s\", t));\n                if (staticColumns.contains(t))\n                    throw new InvalidRequestException(String.format(\"Static column %s cannot be part of the PRIMARY KEY\", t));\n                stmt.clusteringTypes.add(type);\n            }\n\n            // We've handled anything that is not a rpimary key so stmt.columns only contains NON-PK columns. So\n            // if it's a counter table, make sure we don't have non-counter types\n            if (stmt.hasCounters)\n            {\n                for (AbstractType<?> type : stmt.columns.values())\n                    if (!type.isCounter())\n                        throw new InvalidRequestException(\"Cannot mix counter and non counter columns in the same table\");\n            }\n\n            // Dense means that on the thrift side, no part of the \"thrift column name\" stores a \"CQL/metadata column name\".\n            // This means COMPACT STORAGE with at least one clustering type (otherwise it's a thrift \"static\" CF).\n            stmt.isDense = useCompactStorage && !stmt.clusteringTypes.isEmpty();\n            // Compound means that on the thrift side, the \"thrift column name\" is a composite one. It's the case unless\n            // we use compact storage COMPACT STORAGE and we have either no clustering columns (thrift \"static\" CF) or\n            // only one of them (if more than one, it's a \"dense composite\").\n            stmt.isCompound = !(useCompactStorage && stmt.clusteringTypes.size() <= 1);\n\n            // For COMPACT STORAGE, we reject any \"feature\" that we wouldn't be able to translate back to thrift.\n            if (useCompactStorage)\n            {\n                if (!stmt.collections.isEmpty())\n                    throw new InvalidRequestException(\"Non-frozen collection types are not supported with COMPACT STORAGE\");\n                if (!staticColumns.isEmpty())\n                    throw new InvalidRequestException(\"Static columns are not supported in COMPACT STORAGE tables\");\n\n                if (stmt.clusteringTypes.isEmpty())\n                {\n                    // It's a thrift \"static CF\" so there should be some columns definition\n                    if (stmt.columns.isEmpty())\n                        throw new InvalidRequestException(\"No definition found that is not part of the PRIMARY KEY\");\n                }\n\n                if (stmt.isDense)\n                {\n                    // We can have no columns (only the PK), but we can't have more than one.\n                    if (stmt.columns.size() > 1)\n                        throw new InvalidRequestException(String.format(\"COMPACT STORAGE with composite PRIMARY KEY allows no more than one column not part of the PRIMARY KEY (got: %s)\", StringUtils.join(stmt.columns.keySet(), \", \")));\n                }\n                else\n                {\n                    // we are in the \"static\" case, so we need at least one column defined. For non-compact however, having\n                    // just the PK is fine.\n                    if (stmt.columns.isEmpty())\n                        throw new InvalidRequestException(\"COMPACT STORAGE with non-composite PRIMARY KEY require one column not part of the PRIMARY KEY, none given\");\n                }\n            }\n            else\n            {\n                if (stmt.clusteringTypes.isEmpty() && !staticColumns.isEmpty())\n                {\n                    // Static columns only make sense if we have at least one clustering column. Otherwise everything is static anyway\n                    if (columnAliases.isEmpty())\n                        throw new InvalidRequestException(\"Static columns are only useful (and thus allowed) if the table has at least one clustering column\");\n                }\n            }\n\n            // If we give a clustering order, we must explicitly do so for all aliases and in the order of the PK\n            if (!definedOrdering.isEmpty())\n            {\n                if (definedOrdering.size() > columnAliases.size())\n                    throw new InvalidRequestException(\"Only clustering key columns can be defined in CLUSTERING ORDER directive\");\n\n                int i = 0;\n                for (ColumnIdentifier id : definedOrdering.keySet())\n                {\n                    ColumnIdentifier c = columnAliases.get(i);\n                    if (!id.equals(c))\n                    {\n                        if (definedOrdering.containsKey(c))\n                            throw new InvalidRequestException(String.format(\"The order of columns in the CLUSTERING ORDER directive must be the one of the clustering key (%s must appear before %s)\", c, id));\n                        else\n                            throw new InvalidRequestException(String.format(\"Missing CLUSTERING ORDER for column %s\", c));\n                    }\n                    ++i;\n                }\n            }\n\n            return new ParsedStatement.Prepared(stmt);\n        }\n\n        private AbstractType<?> getTypeAndRemove(Map<ColumnIdentifier, AbstractType> columns, ColumnIdentifier t) throws InvalidRequestException\n        {\n            AbstractType type = columns.get(t);\n            if (type == null)\n                throw new InvalidRequestException(String.format(\"Unknown definition %s referenced in PRIMARY KEY\", t));\n            if (type.isCollection() && type.isMultiCell())\n                throw new InvalidRequestException(String.format(\"Invalid collection type for PRIMARY KEY component %s\", t));\n\n            columns.remove(t);\n            Boolean isReversed = definedOrdering.get(t);\n            return isReversed != null && isReversed ? ReversedType.getInstance(type) : type;\n        }\n\n        public void addDefinition(ColumnIdentifier def, CQL3Type.Raw type, boolean isStatic)\n        {\n            definedNames.add(def);\n            definitions.put(def, type);\n            if (isStatic)\n                staticColumns.add(def);\n        }\n\n        public void addKeyAliases(List<ColumnIdentifier> aliases)\n        {\n            keyAliases.add(aliases);\n        }\n\n        public void addColumnAlias(ColumnIdentifier alias)\n        {\n            columnAliases.add(alias);\n        }\n\n        public void setOrdering(ColumnIdentifier alias, boolean reversed)\n        {\n            definedOrdering.put(alias, reversed);\n        }\n\n        public void setCompactStorage()\n        {\n            useCompactStorage = true;\n        }\n    }\n}",
    "ID_21": "public class CreateTableStatement extends SchemaAlteringStatement\n{\n    private List<AbstractType<?>> keyTypes;\n    private List<AbstractType<?>> clusteringTypes;\n\n    private Map<ByteBuffer, CollectionType> collections = new HashMap<>();\n\n    private final List<ColumnIdentifier> keyAliases = new ArrayList<>();\n    private final List<ColumnIdentifier> columnAliases = new ArrayList<>();\n    private ByteBuffer valueAlias;\n\n    private boolean isDense;\n    private boolean isCompound;\n    private boolean hasCounters;\n\n    // use a TreeMap to preserve ordering across JDK versions (see CASSANDRA-9492)\n    private final Map<ColumnIdentifier, AbstractType> columns = new TreeMap<>(new Comparator<ColumnIdentifier>()\n    {\n        public int compare(ColumnIdentifier o1, ColumnIdentifier o2)\n        {\n            return o1.bytes.compareTo(o2.bytes);\n        }\n    });\n    private final Set<ColumnIdentifier> staticColumns;\n    private final CFPropDefs properties;\n    private final boolean ifNotExists;\n\n    public CreateTableStatement(CFName name, CFPropDefs properties, boolean ifNotExists, Set<ColumnIdentifier> staticColumns)\n    {\n        super(name);\n        this.properties = properties;\n        this.ifNotExists = ifNotExists;\n        this.staticColumns = staticColumns;\n\n        if (!this.properties.hasProperty(CFPropDefs.KW_COMPRESSION) && CFMetaData.DEFAULT_COMPRESSOR != null)\n            this.properties.addProperty(CFPropDefs.KW_COMPRESSION,\n                                        new HashMap<String, String>()\n                                        {{\n                                            put(CompressionParameters.CLASS, CFMetaData.DEFAULT_COMPRESSOR);\n                                        }});\n    }\n\n    public void checkAccess(ClientState state) throws UnauthorizedException, InvalidRequestException\n    {\n        state.hasKeyspaceAccess(keyspace(), Permission.CREATE);\n    }\n\n    public void validate(ClientState state)\n    {\n        // validated in announceMigration()\n    }\n\n    public boolean announceMigration(boolean isLocalOnly) throws RequestValidationException\n    {\n        try\n        {\n            MigrationManager.announceNewColumnFamily(getCFMetaData(), isLocalOnly);\n            return true;\n        }\n        catch (AlreadyExistsException e)\n        {\n            if (ifNotExists)\n                return false;\n            throw e;\n        }\n    }\n\n    public Event.SchemaChange changeEvent()\n    {\n        return new Event.SchemaChange(Event.SchemaChange.Change.CREATED, Event.SchemaChange.Target.TABLE, keyspace(), columnFamily());\n    }\n\n    protected void grantPermissionsToCreator(QueryState state)\n    {\n        try\n        {\n            IResource resource = DataResource.table(keyspace(), columnFamily());\n            DatabaseDescriptor.getAuthorizer().grant(AuthenticatedUser.SYSTEM_USER,\n                                                     resource.applicablePermissions(),\n                                                     resource,\n                                                     RoleResource.role(state.getClientState().getUser().getName()));\n        }\n        catch (RequestExecutionException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public CFMetaData.Builder metadataBuilder()\n    {\n        CFMetaData.Builder builder = CFMetaData.Builder.create(keyspace(), columnFamily(), isDense, isCompound, hasCounters);\n        for (int i = 0; i < keyAliases.size(); i++)\n            builder.addPartitionKey(keyAliases.get(i), keyTypes.get(i));\n        for (int i = 0; i < columnAliases.size(); i++)\n            builder.addClusteringColumn(columnAliases.get(i), clusteringTypes.get(i));\n\n        boolean isStaticCompact = !isDense && !isCompound;\n        for (Map.Entry<ColumnIdentifier, AbstractType> entry : columns.entrySet())\n        {\n            ColumnIdentifier name = entry.getKey();\n            // Note that for \"static\" no-clustering compact storage we use static for the defined columns\n            if (staticColumns.contains(name) || isStaticCompact)\n                builder.addStaticColumn(name, entry.getValue());\n            else\n                builder.addRegularColumn(name, entry.getValue());\n        }\n\n        boolean isCompactTable = isDense || !isCompound;\n        if (isCompactTable)\n        {\n            CompactTables.DefaultNames names = CompactTables.defaultNameGenerator(builder.usedColumnNames());\n            // Compact tables always have a clustering and a single regular value.\n            if (isStaticCompact)\n            {\n                builder.addClusteringColumn(names.defaultClusteringName(), UTF8Type.instance);\n                builder.addRegularColumn(names.defaultCompactValueName(), hasCounters ? CounterColumnType.instance : BytesType.instance);\n            }\n            else if (isDense && !builder.hasRegulars())\n            {\n                // Even for dense, we might not have our regular column if it wasn't part of the declaration. If\n                // that's the case, add it but with a specific EmptyType so we can recognize that case later\n                builder.addRegularColumn(names.defaultCompactValueName(), EmptyType.instance);\n            }\n        }\n\n        return builder;\n    }\n\n    /**\n     * Returns a CFMetaData instance based on the parameters parsed from this\n     * <code>CREATE</code> statement, or defaults where applicable.\n     *\n     * @return a CFMetaData instance corresponding to the values parsed from this statement\n     * @throws InvalidRequestException on failure to validate parsed parameters\n     */\n    public CFMetaData getCFMetaData() throws RequestValidationException\n    {\n        CFMetaData newCFMD = metadataBuilder().build();\n        applyPropertiesTo(newCFMD);\n        return newCFMD;\n    }\n\n    public void applyPropertiesTo(CFMetaData cfmd) throws RequestValidationException\n    {\n        properties.applyToCFMetadata(cfmd);\n    }\n\n    public static class RawStatement extends CFStatement\n    {\n        private final Map<ColumnIdentifier, CQL3Type.Raw> definitions = new HashMap<>();\n        public final CFPropDefs properties = new CFPropDefs();\n\n        private final List<List<ColumnIdentifier>> keyAliases = new ArrayList<List<ColumnIdentifier>>();\n        private final List<ColumnIdentifier> columnAliases = new ArrayList<ColumnIdentifier>();\n        private final Map<ColumnIdentifier, Boolean> definedOrdering = new LinkedHashMap<ColumnIdentifier, Boolean>(); // Insertion ordering is important\n        private final Set<ColumnIdentifier> staticColumns = new HashSet<ColumnIdentifier>();\n\n        private boolean useCompactStorage;\n        private final Multiset<ColumnIdentifier> definedNames = HashMultiset.create(1);\n\n        private final boolean ifNotExists;\n\n        public RawStatement(CFName name, boolean ifNotExists)\n        {\n            super(name);\n            this.ifNotExists = ifNotExists;\n        }\n\n        /**\n         * Transform this raw statement into a CreateTableStatement.\n         */\n        public ParsedStatement.Prepared prepare() throws RequestValidationException\n        {\n            // Column family name\n            if (!columnFamily().matches(\"\\\\w+\"))\n                throw new InvalidRequestException(String.format(\"\\\"%s\\\" is not a valid table name (must be alphanumeric character only: [0-9A-Za-z]+)\", columnFamily()));\n            if (columnFamily().length() > Schema.NAME_LENGTH)\n                throw new InvalidRequestException(String.format(\"Table names shouldn't be more than %s characters long (got \\\"%s\\\")\", Schema.NAME_LENGTH, columnFamily()));\n\n            for (Multiset.Entry<ColumnIdentifier> entry : definedNames.entrySet())\n                if (entry.getCount() > 1)\n                    throw new InvalidRequestException(String.format(\"Multiple definition of identifier %s\", entry.getElement()));\n\n            properties.validate();\n\n            CreateTableStatement stmt = new CreateTableStatement(cfName, properties, ifNotExists, staticColumns);\n\n            for (Map.Entry<ColumnIdentifier, CQL3Type.Raw> entry : definitions.entrySet())\n            {\n                ColumnIdentifier id = entry.getKey();\n                CQL3Type pt = entry.getValue().prepare(keyspace());\n                if (pt.isCollection() && ((CollectionType)pt.getType()).isMultiCell())\n                    stmt.collections.put(id.bytes, (CollectionType)pt.getType());\n                if (entry.getValue().isCounter())\n                    stmt.hasCounters = true;\n                stmt.columns.put(id, pt.getType()); // we'll remove what is not a column below\n            }\n\n            if (keyAliases.isEmpty())\n                throw new InvalidRequestException(\"No PRIMARY KEY specifed (exactly one required)\");\n            if (keyAliases.size() > 1)\n                throw new InvalidRequestException(\"Multiple PRIMARY KEYs specifed (exactly one required)\");\n            if (stmt.hasCounters && properties.getDefaultTimeToLive() > 0)\n                throw new InvalidRequestException(\"Cannot set default_time_to_live on a table with counters\");\n\n            List<ColumnIdentifier> kAliases = keyAliases.get(0);\n            stmt.keyTypes = new ArrayList<AbstractType<?>>(kAliases.size());\n            for (ColumnIdentifier alias : kAliases)\n            {\n                stmt.keyAliases.add(alias);\n                AbstractType<?> t = getTypeAndRemove(stmt.columns, alias);\n                if (t instanceof CounterColumnType)\n                    throw new InvalidRequestException(String.format(\"counter type is not supported for PRIMARY KEY part %s\", alias));\n                if (staticColumns.contains(alias))\n                    throw new InvalidRequestException(String.format(\"Static column %s cannot be part of the PRIMARY KEY\", alias));\n                stmt.keyTypes.add(t);\n            }\n\n            stmt.clusteringTypes = new ArrayList<>(columnAliases.size());\n            // Handle column aliases\n            for (ColumnIdentifier t : columnAliases)\n            {\n                stmt.columnAliases.add(t);\n\n                AbstractType<?> type = getTypeAndRemove(stmt.columns, t);\n                if (type instanceof CounterColumnType)\n                    throw new InvalidRequestException(String.format(\"counter type is not supported for PRIMARY KEY part %s\", t));\n                if (staticColumns.contains(t))\n                    throw new InvalidRequestException(String.format(\"Static column %s cannot be part of the PRIMARY KEY\", t));\n                stmt.clusteringTypes.add(type);\n            }\n\n            // We've handled anything that is not a rpimary key so stmt.columns only contains NON-PK columns. So\n            // if it's a counter table, make sure we don't have non-counter types\n            if (stmt.hasCounters)\n            {\n                for (AbstractType<?> type : stmt.columns.values())\n                    if (!type.isCounter())\n                        throw new InvalidRequestException(\"Cannot mix counter and non counter columns in the same table\");\n            }\n\n            // Dense means that on the thrift side, no part of the \"thrift column name\" stores a \"CQL/metadata column name\".\n            // This means COMPACT STORAGE with at least one clustering type (otherwise it's a thrift \"static\" CF).\n            stmt.isDense = useCompactStorage && !stmt.clusteringTypes.isEmpty();\n            // Compound means that on the thrift side, the \"thrift column name\" is a composite one. It's the case unless\n            // we use compact storage COMPACT STORAGE and we have either no clustering columns (thrift \"static\" CF) or\n            // only one of them (if more than one, it's a \"dense composite\").\n            stmt.isCompound = !(useCompactStorage && stmt.clusteringTypes.size() <= 1);\n\n            // For COMPACT STORAGE, we reject any \"feature\" that we wouldn't be able to translate back to thrift.\n            if (useCompactStorage)\n            {\n                if (!stmt.collections.isEmpty())\n                    throw new InvalidRequestException(\"Non-frozen collection types are not supported with COMPACT STORAGE\");\n                if (!staticColumns.isEmpty())\n                    throw new InvalidRequestException(\"Static columns are not supported in COMPACT STORAGE tables\");\n\n                if (stmt.clusteringTypes.isEmpty())\n                {\n                    // It's a thrift \"static CF\" so there should be some columns definition\n                    if (stmt.columns.isEmpty())\n                        throw new InvalidRequestException(\"No definition found that is not part of the PRIMARY KEY\");\n                }\n\n                if (stmt.isDense)\n                {\n                    // We can have no columns (only the PK), but we can't have more than one.\n                    if (stmt.columns.size() > 1)\n                        throw new InvalidRequestException(String.format(\"COMPACT STORAGE with composite PRIMARY KEY allows no more than one column not part of the PRIMARY KEY (got: %s)\", StringUtils.join(stmt.columns.keySet(), \", \")));\n                }\n                else\n                {\n                    // we are in the \"static\" case, so we need at least one column defined. For non-compact however, having\n                    // just the PK is fine.\n                    if (stmt.columns.isEmpty())\n                        throw new InvalidRequestException(\"COMPACT STORAGE with non-composite PRIMARY KEY require one column not part of the PRIMARY KEY, none given\");\n                }\n            }\n            else\n            {\n                if (stmt.clusteringTypes.isEmpty() && !staticColumns.isEmpty())\n                {\n                    // Static columns only make sense if we have at least one clustering column. Otherwise everything is static anyway\n                    if (columnAliases.isEmpty())\n                        throw new InvalidRequestException(\"Static columns are only useful (and thus allowed) if the table has at least one clustering column\");\n                }\n            }\n\n            // If we give a clustering order, we must explicitly do so for all aliases and in the order of the PK\n            if (!definedOrdering.isEmpty())\n            {\n                if (definedOrdering.size() > columnAliases.size())\n                    throw new InvalidRequestException(\"Only clustering key columns can be defined in CLUSTERING ORDER directive\");\n\n                int i = 0;\n                for (ColumnIdentifier id : definedOrdering.keySet())\n                {\n                    ColumnIdentifier c = columnAliases.get(i);\n                    if (!id.equals(c))\n                    {\n                        if (definedOrdering.containsKey(c))\n                            throw new InvalidRequestException(String.format(\"The order of columns in the CLUSTERING ORDER directive must be the one of the clustering key (%s must appear before %s)\", c, id));\n                        else\n                            throw new InvalidRequestException(String.format(\"Missing CLUSTERING ORDER for column %s\", c));\n                    }\n                    ++i;\n                }\n            }\n\n            return new ParsedStatement.Prepared(stmt);\n        }\n\n        private AbstractType<?> getTypeAndRemove(Map<ColumnIdentifier, AbstractType> columns, ColumnIdentifier t) throws InvalidRequestException\n        {\n            AbstractType type = columns.get(t);\n            if (type == null)\n                throw new InvalidRequestException(String.format(\"Unknown definition %s referenced in PRIMARY KEY\", t));\n            if (type.isCollection() && type.isMultiCell())\n                throw new InvalidRequestException(String.format(\"Invalid collection type for PRIMARY KEY component %s\", t));\n\n            columns.remove(t);\n            Boolean isReversed = definedOrdering.get(t);\n            return isReversed != null && isReversed ? ReversedType.getInstance(type) : type;\n        }\n\n        public void addDefinition(ColumnIdentifier def, CQL3Type.Raw type, boolean isStatic)\n        {\n            definedNames.add(def);\n            definitions.put(def, type);\n            if (isStatic)\n                staticColumns.add(def);\n        }\n\n        public void addKeyAliases(List<ColumnIdentifier> aliases)\n        {\n            keyAliases.add(aliases);\n        }\n\n        public void addColumnAlias(ColumnIdentifier alias)\n        {\n            columnAliases.add(alias);\n        }\n\n        public void setOrdering(ColumnIdentifier alias, boolean reversed)\n        {\n            definedOrdering.put(alias, reversed);\n        }\n\n        public void setCompactStorage()\n        {\n            useCompactStorage = true;\n        }\n    }\n}"
}