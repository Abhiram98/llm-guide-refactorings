[
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "1e49334209d1f14170f4b359de247636f0a4c933",
        "url": "https://github.com/spring-projects/spring-framework/commit/1e49334209d1f14170f4b359de247636f0a4c933",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private getUriToLog(uri URI) : URI from class org.springframework.web.reactive.function.client.DefaultWebClient.DefaultResponseSpec to private getUriToLog(uri URI) : URI from class org.springframework.web.reactive.function.client.DefaultWebClient",
            "leftSideLocations": [
                {
                    "filePath": "spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClient.java",
                    "startLine": 701,
                    "endLine": 711,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private getUriToLog(uri URI) : URI"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClient.java",
                    "startLine": 198,
                    "endLine": 208,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "private getUriToLog(uri URI) : URI"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "b495f15f-dff9-4178-a462-1b7222e41f46",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 689,
                "lineStart": 64,
                "lineEnd": 752,
                "bodyLineStart": 64,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-webflux/src/main/java/org/springframework/web/reactive/function/client/DefaultWebClient.java",
                "sourceCode": "/**\n * The default implementation of {@link WebClient},\n * as created by the static factory methods.\n *\n * @author Rossen Stoyanchev\n * @author Brian Clozel\n * @author Sebastien Deleuze\n * @since 5.0\n * @see WebClient#create()\n * @see WebClient#create(String)\n */\nfinal class DefaultWebClient implements WebClient {\n\n\tprivate static final String URI_TEMPLATE_ATTRIBUTE = WebClient.class.getName() + \".uriTemplate\";\n\n\tprivate static final Mono<ClientResponse> NO_HTTP_CLIENT_RESPONSE_ERROR = Mono.error(\n\t\t\t() -> new IllegalStateException(\"The underlying HTTP client completed without emitting a response.\"));\n\n\tprivate static final DefaultClientRequestObservationConvention DEFAULT_OBSERVATION_CONVENTION =\n\t\t\tnew DefaultClientRequestObservationConvention();\n\n\n\tprivate final ExchangeFunction exchangeFunction;\n\n\t@Nullable\n\tprivate final ExchangeFilterFunction filterFunctions;\n\n\tprivate final UriBuilderFactory uriBuilderFactory;\n\n\t@Nullable\n\tprivate final HttpHeaders defaultHeaders;\n\n\t@Nullable\n\tprivate final MultiValueMap<String, String> defaultCookies;\n\n\t@Nullable\n\tprivate final Consumer<RequestHeadersSpec<?>> defaultRequest;\n\n\tprivate final List<DefaultResponseSpec.StatusHandler> defaultStatusHandlers;\n\n\tprivate final ObservationRegistry observationRegistry;\n\n\t@Nullable\n\tprivate final ClientRequestObservationConvention observationConvention;\n\n\tprivate final DefaultWebClientBuilder builder;\n\n\n\tDefaultWebClient(ExchangeFunction exchangeFunction, @Nullable ExchangeFilterFunction filterFunctions,\n\t\t\tUriBuilderFactory uriBuilderFactory, @Nullable HttpHeaders defaultHeaders,\n\t\t\t@Nullable MultiValueMap<String, String> defaultCookies, @Nullable Consumer<RequestHeadersSpec<?>> defaultRequest,\n\t\t\t@Nullable Map<Predicate<HttpStatusCode>, Function<ClientResponse, Mono<? extends Throwable>>> statusHandlerMap,\n\t\t\tObservationRegistry observationRegistry, @Nullable ClientRequestObservationConvention observationConvention,\n\t\t\tDefaultWebClientBuilder builder) {\n\n\t\tthis.exchangeFunction = exchangeFunction;\n\t\tthis.filterFunctions = filterFunctions;\n\t\tthis.uriBuilderFactory = uriBuilderFactory;\n\t\tthis.defaultHeaders = defaultHeaders;\n\t\tthis.defaultCookies = defaultCookies;\n\t\tthis.defaultRequest = defaultRequest;\n\t\tthis.defaultStatusHandlers = initStatusHandlers(statusHandlerMap);\n\t\tthis.observationRegistry = observationRegistry;\n\t\tthis.observationConvention = observationConvention;\n\t\tthis.builder = builder;\n\t}\n\n\tprivate static List<DefaultResponseSpec.StatusHandler> initStatusHandlers(\n\t\t\t@Nullable Map<Predicate<HttpStatusCode>, Function<ClientResponse, Mono<? extends Throwable>>> handlerMap) {\n\n\t\treturn (CollectionUtils.isEmpty(handlerMap) ? Collections.emptyList() :\n\t\t\t\thandlerMap.entrySet().stream()\n\t\t\t\t\t\t.map(entry -> new DefaultResponseSpec.StatusHandler(entry.getKey(), entry.getValue()))\n\t\t\t\t\t\t.toList());\n\t}\n\n\n\t@Override\n\tpublic RequestHeadersUriSpec<?> get() {\n\t\treturn methodInternal(HttpMethod.GET);\n\t}\n\n\t@Override\n\tpublic RequestHeadersUriSpec<?> head() {\n\t\treturn methodInternal(HttpMethod.HEAD);\n\t}\n\n\t@Override\n\tpublic RequestBodyUriSpec post() {\n\t\treturn methodInternal(HttpMethod.POST);\n\t}\n\n\t@Override\n\tpublic RequestBodyUriSpec put() {\n\t\treturn methodInternal(HttpMethod.PUT);\n\t}\n\n\t@Override\n\tpublic RequestBodyUriSpec patch() {\n\t\treturn methodInternal(HttpMethod.PATCH);\n\t}\n\n\t@Override\n\tpublic RequestHeadersUriSpec<?> delete() {\n\t\treturn methodInternal(HttpMethod.DELETE);\n\t}\n\n\t@Override\n\tpublic RequestHeadersUriSpec<?> options() {\n\t\treturn methodInternal(HttpMethod.OPTIONS);\n\t}\n\n\t@Override\n\tpublic RequestBodyUriSpec method(HttpMethod httpMethod) {\n\t\treturn methodInternal(httpMethod);\n\t}\n\n\tprivate RequestBodyUriSpec methodInternal(HttpMethod httpMethod) {\n\t\treturn new DefaultRequestBodyUriSpec(httpMethod);\n\t}\n\n\t@Override\n\tpublic Builder mutate() {\n\t\treturn new DefaultWebClientBuilder(this.builder);\n\t}\n\n\tprivate static Mono<Void> releaseIfNotConsumed(ClientResponse response) {\n\t\treturn response.releaseBody().onErrorComplete();\n\t}\n\n\tprivate static <T> Mono<T> releaseIfNotConsumed(ClientResponse response, Throwable ex) {\n\t\treturn response.releaseBody().onErrorComplete().then(Mono.error(ex));\n\t}\n\n\n\tprivate class DefaultRequestBodyUriSpec implements RequestBodyUriSpec {\n\n\t\tprivate final HttpMethod httpMethod;\n\n\t\t@Nullable\n\t\tprivate URI uri;\n\n\t\t@Nullable\n\t\tprivate HttpHeaders headers;\n\n\t\t@Nullable\n\t\tprivate MultiValueMap<String, String> cookies;\n\n\t\t@Nullable\n\t\tprivate BodyInserter<?, ? super ClientHttpRequest> inserter;\n\n\t\tprivate final Map<String, Object> attributes = new LinkedHashMap<>(4);\n\n\t\t@Nullable\n\t\tprivate Function<Context, Context> contextModifier;\n\n\t\t@Nullable\n\t\tprivate Consumer<ClientHttpRequest> httpRequestConsumer;\n\n\t\tDefaultRequestBodyUriSpec(HttpMethod httpMethod) {\n\t\t\tthis.httpMethod = httpMethod;\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestBodySpec uri(String uriTemplate, Object... uriVariables) {\n\t\t\tUriBuilder uriBuilder = uriBuilderFactory.uriString(uriTemplate);\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriBuilder.toUriString());\n\t\t\treturn uri(uriBuilder.build(uriVariables));\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestBodySpec uri(String uriTemplate, Map<String, ?> uriVariables) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(uriBuilderFactory.expand(uriTemplate, uriVariables));\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestBodySpec uri(String uriTemplate, Function<UriBuilder, URI> uriFunction) {\n\t\t\tattribute(URI_TEMPLATE_ATTRIBUTE, uriTemplate);\n\t\t\treturn uri(uriFunction.apply(uriBuilderFactory.uriString(uriTemplate)));\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestBodySpec uri(Function<UriBuilder, URI> uriFunction) {\n\t\t\treturn uri(uriFunction.apply(uriBuilderFactory.builder()));\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestBodySpec uri(URI uri) {\n\t\t\tthis.uri = uri;\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate HttpHeaders getHeaders() {\n\t\t\tif (this.headers == null) {\n\t\t\t\tthis.headers = new HttpHeaders();\n\t\t\t}\n\t\t\treturn this.headers;\n\t\t}\n\n\t\tprivate MultiValueMap<String, String> getCookies() {\n\t\t\tif (this.cookies == null) {\n\t\t\t\tthis.cookies = new LinkedMultiValueMap<>(3);\n\t\t\t}\n\t\t\treturn this.cookies;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultRequestBodyUriSpec header(String headerName, String... headerValues) {\n\t\t\tfor (String headerValue : headerValues) {\n\t\t\t\tgetHeaders().add(headerName, headerValue);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultRequestBodyUriSpec headers(Consumer<HttpHeaders> headersConsumer) {\n\t\t\theadersConsumer.accept(getHeaders());\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultRequestBodyUriSpec accept(MediaType... acceptableMediaTypes) {\n\t\t\tgetHeaders().setAccept(Arrays.asList(acceptableMediaTypes));\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultRequestBodyUriSpec acceptCharset(Charset... acceptableCharsets) {\n\t\t\tgetHeaders().setAcceptCharset(Arrays.asList(acceptableCharsets));\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultRequestBodyUriSpec contentType(MediaType contentType) {\n\t\t\tgetHeaders().setContentType(contentType);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultRequestBodyUriSpec contentLength(long contentLength) {\n\t\t\tgetHeaders().setContentLength(contentLength);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultRequestBodyUriSpec cookie(String name, String value) {\n\t\t\tgetCookies().add(name, value);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultRequestBodyUriSpec cookies(Consumer<MultiValueMap<String, String>> cookiesConsumer) {\n\t\t\tcookiesConsumer.accept(getCookies());\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultRequestBodyUriSpec ifModifiedSince(ZonedDateTime ifModifiedSince) {\n\t\t\tgetHeaders().setIfModifiedSince(ifModifiedSince);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic DefaultRequestBodyUriSpec ifNoneMatch(String... ifNoneMatches) {\n\t\t\tgetHeaders().setIfNoneMatch(Arrays.asList(ifNoneMatches));\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestBodySpec attribute(String name, Object value) {\n\t\t\tthis.attributes.put(name, value);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestBodySpec attributes(Consumer<Map<String, Object>> attributesConsumer) {\n\t\t\tattributesConsumer.accept(this.attributes);\n\t\t\treturn this;\n\t\t}\n\n\t\t@SuppressWarnings(\"deprecation\")\n\t\t@Override\n\t\tpublic RequestBodySpec context(Function<Context, Context> contextModifier) {\n\t\t\tthis.contextModifier = (this.contextModifier != null ?\n\t\t\t\t\tthis.contextModifier.andThen(contextModifier) : contextModifier);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestBodySpec httpRequest(Consumer<ClientHttpRequest> requestConsumer) {\n\t\t\tthis.httpRequestConsumer = (this.httpRequestConsumer != null ?\n\t\t\t\t\tthis.httpRequestConsumer.andThen(requestConsumer) : requestConsumer);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestHeadersSpec<?> bodyValue(Object body) {\n\t\t\tthis.inserter = BodyInserters.fromValue(body);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, P extends Publisher<T>> RequestHeadersSpec<?> body(\n\t\t\t\tP publisher, ParameterizedTypeReference<T> elementTypeRef) {\n\t\t\tthis.inserter = BodyInserters.fromPublisher(publisher, elementTypeRef);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic <T, P extends Publisher<T>> RequestHeadersSpec<?> body(P publisher, Class<T> elementClass) {\n\t\t\tthis.inserter = BodyInserters.fromPublisher(publisher, elementClass);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestHeadersSpec<?> body(Object producer, Class<?> elementClass) {\n\t\t\tthis.inserter = BodyInserters.fromProducer(producer, elementClass);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestHeadersSpec<?> body(Object producer, ParameterizedTypeReference<?> elementTypeRef) {\n\t\t\tthis.inserter = BodyInserters.fromProducer(producer, elementTypeRef);\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestHeadersSpec<?> body(BodyInserter<?, ? super ClientHttpRequest> inserter) {\n\t\t\tthis.inserter = inserter;\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic RequestHeadersSpec<?> syncBody(Object body) {\n\t\t\treturn bodyValue(body);\n\t\t}\n\n\t\t@Override\n\t\tpublic ResponseSpec retrieve() {\n\t\t\treturn new DefaultResponseSpec(\n\t\t\t\t\tthis.httpMethod, initUri(), exchange(), DefaultWebClient.this.defaultStatusHandlers);\n\t\t}\n\n\t\t@Override\n\t\tpublic <V> Mono<V> exchangeToMono(Function<ClientResponse, ? extends Mono<V>> responseHandler) {\n\t\t\treturn exchange().flatMap(response -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn responseHandler.apply(response)\n\t\t\t\t\t\t\t.flatMap(value -> releaseIfNotConsumed(response).thenReturn(value))\n\t\t\t\t\t\t\t.switchIfEmpty(Mono.defer(() -> releaseIfNotConsumed(response).then(Mono.empty())))\n\t\t\t\t\t\t\t.onErrorResume(ex -> releaseIfNotConsumed(response, ex));\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\treturn releaseIfNotConsumed(response, ex);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t@Override\n\t\tpublic <V> Flux<V> exchangeToFlux(Function<ClientResponse, ? extends Flux<V>> responseHandler) {\n\t\t\treturn exchange().flatMapMany(response -> {\n\t\t\t\ttry {\n\t\t\t\t\treturn responseHandler.apply(response)\n\t\t\t\t\t\t\t.concatWith(Flux.defer(() -> releaseIfNotConsumed(response).then(Mono.empty())))\n\t\t\t\t\t\t\t.onErrorResume(ex -> releaseIfNotConsumed(response, ex));\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\treturn releaseIfNotConsumed(response, ex);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t@SuppressWarnings(\"deprecation\")\n\t\t@Override\n\t\tpublic Mono<ClientResponse> exchange() {\n\t\t\tClientRequest.Builder requestBuilder = initRequestBuilder();\n\t\t\tClientRequestObservationContext observationContext = new ClientRequestObservationContext(requestBuilder);\n\t\t\treturn Mono.deferContextual(contextView -> {\n\t\t\t\tObservation observation = ClientHttpObservationDocumentation.HTTP_REACTIVE_CLIENT_EXCHANGES.observation(observationConvention,\n\t\t\t\t\t\tDEFAULT_OBSERVATION_CONVENTION, () -> observationContext, observationRegistry);\n\t\t\t\tobservation\n\t\t\t\t\t\t.parentObservation(contextView.getOrDefault(ObservationThreadLocalAccessor.KEY, null))\n\t\t\t\t\t\t.start();\n\t\t\t\tExchangeFilterFunction filterFunction = new ObservationFilterFunction(observationContext);\n\t\t\t\tif (filterFunctions != null) {\n\t\t\t\t\tfilterFunction = filterFunctions.andThen(filterFunction);\n\t\t\t\t}\n\t\t\t\tClientRequest request = requestBuilder\n\t\t\t\t\t\t.attribute(ClientRequestObservationContext.CURRENT_OBSERVATION_CONTEXT_ATTRIBUTE, observationContext)\n\t\t\t\t\t\t.build();\n\t\t\t\tobservationContext.setUriTemplate((String) request.attribute(URI_TEMPLATE_ATTRIBUTE).orElse(null));\n\t\t\t\tobservationContext.setRequest(request);\n\t\t\t\tMono<ClientResponse> responseMono = filterFunction.apply(exchangeFunction)\n\t\t\t\t\t\t.exchange(request)\n\t\t\t\t\t\t.checkpoint(\"Request to \" + this.httpMethod.name() + \" \" + this.uri + \" [DefaultWebClient]\")\n\t\t\t\t\t\t.switchIfEmpty(NO_HTTP_CLIENT_RESPONSE_ERROR);\n\t\t\t\tif (this.contextModifier != null) {\n\t\t\t\t\tresponseMono = responseMono.contextWrite(this.contextModifier);\n\t\t\t\t}\n\t\t\t\tfinal AtomicBoolean responseReceived = new AtomicBoolean();\n\t\t\t\treturn responseMono\n\t\t\t\t\t\t.doOnNext(response -> responseReceived.set(true))\n\t\t\t\t\t\t.doOnError(observationContext::setError)\n\t\t\t\t\t\t.doFinally(signalType -> {\n\t\t\t\t\t\t\tif (signalType == SignalType.CANCEL && !responseReceived.get()) {\n\t\t\t\t\t\t\t\tobservationContext.setAborted(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tobservation.stop();\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.contextWrite(context -> context.put(ObservationThreadLocalAccessor.KEY, observation));\n\t\t\t});\n\t\t}\n\n\t\tprivate ClientRequest.Builder initRequestBuilder() {\n\t\t\tif (defaultRequest != null) {\n\t\t\t\tdefaultRequest.accept(this);\n\t\t\t}\n\t\t\tClientRequest.Builder builder = ClientRequest.create(this.httpMethod, initUri())\n\t\t\t\t\t.headers(this::initHeaders)\n\t\t\t\t\t.cookies(this::initCookies)\n\t\t\t\t\t.attributes(attributes -> attributes.putAll(this.attributes));\n\t\t\tif (this.httpRequestConsumer != null) {\n\t\t\t\tbuilder.httpRequest(this.httpRequestConsumer);\n\t\t\t}\n\t\t\tif (this.inserter != null) {\n\t\t\t\tbuilder.body(this.inserter);\n\t\t\t}\n\t\t\treturn builder;\n\t\t}\n\n\t\tprivate URI initUri() {\n\t\t\treturn (this.uri != null ? this.uri : uriBuilderFactory.expand(\"\"));\n\t\t}\n\n\t\tprivate void initHeaders(HttpHeaders out) {\n\t\t\tif (!CollectionUtils.isEmpty(defaultHeaders)) {\n\t\t\t\tout.putAll(defaultHeaders);\n\t\t\t}\n\t\t\tif (!CollectionUtils.isEmpty(this.headers)) {\n\t\t\t\tout.putAll(this.headers);\n\t\t\t}\n\t\t}\n\n\t\tprivate void initCookies(MultiValueMap<String, String> out) {\n\t\t\tif (!CollectionUtils.isEmpty(defaultCookies)) {\n\t\t\t\tout.putAll(defaultCookies);\n\t\t\t}\n\t\t\tif (!CollectionUtils.isEmpty(this.cookies)) {\n\t\t\t\tout.putAll(this.cookies);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class DefaultResponseSpec implements ResponseSpec {\n\n\t\tprivate static final StatusHandler DEFAULT_STATUS_HANDLER =\n\t\t\t\tnew StatusHandler(code -> code.value() >= 400, ClientResponse::createException);\n\n\n\t\tprivate final HttpMethod httpMethod;\n\n\t\tprivate final URI uri;\n\n\t\tprivate final Mono<ClientResponse> responseMono;\n\n\t\tprivate final List<StatusHandler> statusHandlers = new ArrayList<>(1);\n\n\t\tprivate final int defaultStatusHandlerCount;\n\n\t\tDefaultResponseSpec(HttpMethod httpMethod, URI uri, Mono<ClientResponse> responseMono,\n\t\t\t\tList<StatusHandler> defaultStatusHandlers) {\n\n\t\t\tthis.httpMethod = httpMethod;\n\t\t\tthis.uri = uri;\n\t\t\tthis.responseMono = responseMono;\n\t\t\tthis.statusHandlers.addAll(defaultStatusHandlers);\n\t\t\tthis.statusHandlers.add(DEFAULT_STATUS_HANDLER);\n\t\t\tthis.defaultStatusHandlerCount = this.statusHandlers.size();\n\t\t}\n\n\t\t@Override\n\t\tpublic ResponseSpec onStatus(Predicate<HttpStatusCode> statusCodePredicate,\n\t\t\t\tFunction<ClientResponse, Mono<? extends Throwable>> exceptionFunction) {\n\n\t\t\tAssert.notNull(statusCodePredicate, \"StatusCodePredicate must not be null\");\n\t\t\tAssert.notNull(exceptionFunction, \"Function must not be null\");\n\t\t\tint index = this.statusHandlers.size() - this.defaultStatusHandlerCount;  // Default handlers always last\n\t\t\tthis.statusHandlers.add(index, new StatusHandler(statusCodePredicate, exceptionFunction));\n\t\t\treturn this;\n\t\t}\n\n\t\t@Override\n\t\tpublic ResponseSpec onRawStatus(IntPredicate statusCodePredicate,\n\t\t\t\tFunction<ClientResponse, Mono<? extends Throwable>> exceptionFunction) {\n\n\t\t\treturn onStatus(toStatusCodePredicate(statusCodePredicate), exceptionFunction);\n\t\t}\n\n\t\tprivate static Predicate<HttpStatusCode> toStatusCodePredicate(IntPredicate predicate) {\n\t\t\treturn value -> predicate.test(value.value());\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Mono<T> bodyToMono(Class<T> elementClass) {\n\t\t\tAssert.notNull(elementClass, \"Class must not be null\");\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\thandleBodyMono(response, response.bodyToMono(elementClass)));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Mono<T> bodyToMono(ParameterizedTypeReference<T> elementTypeRef) {\n\t\t\tAssert.notNull(elementTypeRef, \"ParameterizedTypeReference must not be null\");\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\thandleBodyMono(response, response.bodyToMono(elementTypeRef)));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Flux<T> bodyToFlux(Class<T> elementClass) {\n\t\t\tAssert.notNull(elementClass, \"Class must not be null\");\n\t\t\treturn this.responseMono.flatMapMany(response ->\n\t\t\t\t\thandleBodyFlux(response, response.bodyToFlux(elementClass)));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Flux<T> bodyToFlux(ParameterizedTypeReference<T> elementTypeRef) {\n\t\t\tAssert.notNull(elementTypeRef, \"ParameterizedTypeReference must not be null\");\n\t\t\treturn this.responseMono.flatMapMany(response ->\n\t\t\t\t\thandleBodyFlux(response, response.bodyToFlux(elementTypeRef)));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Mono<ResponseEntity<T>> toEntity(Class<T> bodyClass) {\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\tWebClientUtils.mapToEntity(response,\n\t\t\t\t\t\t\thandleBodyMono(response, response.bodyToMono(bodyClass))));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Mono<ResponseEntity<T>> toEntity(ParameterizedTypeReference<T> bodyTypeRef) {\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\tWebClientUtils.mapToEntity(response,\n\t\t\t\t\t\t\thandleBodyMono(response, response.bodyToMono(bodyTypeRef))));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Mono<ResponseEntity<List<T>>> toEntityList(Class<T> elementClass) {\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\tWebClientUtils.mapToEntityList(response,\n\t\t\t\t\t\t\thandleBodyFlux(response, response.bodyToFlux(elementClass))));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Mono<ResponseEntity<List<T>>> toEntityList(ParameterizedTypeReference<T> elementTypeRef) {\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\tWebClientUtils.mapToEntityList(response,\n\t\t\t\t\t\t\thandleBodyFlux(response, response.bodyToFlux(elementTypeRef))));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Mono<ResponseEntity<Flux<T>>> toEntityFlux(Class<T> elementType) {\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\thandlerEntityFlux(response, response.bodyToFlux(elementType)));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Mono<ResponseEntity<Flux<T>>> toEntityFlux(ParameterizedTypeReference<T> elementTypeRef) {\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\thandlerEntityFlux(response, response.bodyToFlux(elementTypeRef)));\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Mono<ResponseEntity<Flux<T>>> toEntityFlux(BodyExtractor<Flux<T>, ? super ClientHttpResponse> bodyExtractor) {\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\thandlerEntityFlux(response, response.body(bodyExtractor)));\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<ResponseEntity<Void>> toBodilessEntity() {\n\t\t\treturn this.responseMono.flatMap(response ->\n\t\t\t\t\tWebClientUtils.mapToEntity(response, handleBodyMono(response, Mono.<Void>empty()))\n\t\t\t\t\t\t\t.flatMap(entity -> response.releaseBody()\n\t\t\t\t\t\t\t\t\t.onErrorResume(WebClientUtils.WRAP_EXCEPTION_PREDICATE, exceptionWrappingFunction(response))\n\t\t\t\t\t\t\t\t\t.thenReturn(entity))\n\t\t\t);\n\t\t}\n\n\t\tprivate <T> Mono<T> handleBodyMono(ClientResponse response, Mono<T> body) {\n\t\t\tbody = body.onErrorResume(WebClientUtils.WRAP_EXCEPTION_PREDICATE, exceptionWrappingFunction(response));\n\t\t\tMono<T> result = applyStatusHandlers(response);\n\t\t\treturn (result != null ? result.switchIfEmpty(body) : body);\n\t\t}\n\n\t\tprivate <T> Publisher<T> handleBodyFlux(ClientResponse response, Flux<T> body) {\n\t\t\tbody = body.onErrorResume(WebClientUtils.WRAP_EXCEPTION_PREDICATE, exceptionWrappingFunction(response));\n\t\t\tMono<T> result = applyStatusHandlers(response);\n\t\t\treturn (result != null ? result.flux().switchIfEmpty(body) : body);\n\t\t}\n\n\t\tprivate <T> Mono<? extends ResponseEntity<Flux<T>>> handlerEntityFlux(ClientResponse response, Flux<T> body) {\n\t\t\tResponseEntity<Flux<T>> entity = new ResponseEntity<>(\n\t\t\t\t\tbody.onErrorResume(WebClientUtils.WRAP_EXCEPTION_PREDICATE, exceptionWrappingFunction(response)),\n\t\t\t\t\tresponse.headers().asHttpHeaders(),\n\t\t\t\t\tresponse.statusCode());\n\n\t\t\tMono<ResponseEntity<Flux<T>>> result = applyStatusHandlers(response);\n\t\t\treturn (result != null ? result.defaultIfEmpty(entity) : Mono.just(entity));\n\t\t}\n\n\t\tprivate <T> Function<Throwable, Mono<? extends T>> exceptionWrappingFunction(ClientResponse response) {\n\t\t\treturn t -> response.createException().flatMap(ex -> Mono.error(ex.initCause(t)));\n\t\t}\n\n\t\t@Nullable\n\t\tprivate <T> Mono<T> applyStatusHandlers(ClientResponse response) {\n\t\t\tHttpStatusCode statusCode = response.statusCode();\n\t\t\tfor (StatusHandler handler : this.statusHandlers) {\n\t\t\t\tif (handler.test(statusCode)) {\n\t\t\t\t\tMono<? extends Throwable> exMono;\n\t\t\t\t\ttry {\n\t\t\t\t\t\texMono = handler.apply(response);\n\t\t\t\t\t\texMono = exMono.flatMap(ex -> releaseIfNotConsumed(response, ex));\n\t\t\t\t\t\texMono = exMono.onErrorResume(ex -> releaseIfNotConsumed(response, ex));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex2) {\n\t\t\t\t\t\texMono = releaseIfNotConsumed(response, ex2);\n\t\t\t\t\t}\n\t\t\t\t\tMono<T> result = exMono.flatMap(Mono::error);\n\t\t\t\t\treturn result.checkpoint(statusCode + \" from \" +\n\t\t\t\t\t\t\tthis.httpMethod + \" \" + getUriToLog(this.uri) + \" [DefaultWebClient]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate static URI getUriToLog(URI uri) {\n\t\t\tif (StringUtils.hasText(uri.getQuery())) {\n\t\t\t\ttry {\n\t\t\t\t\turi = new URI(uri.getScheme(), null, uri.getHost(), uri.getPort(), uri.getPath(), null, null);\n\t\t\t\t}\n\t\t\t\tcatch (URISyntaxException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uri;\n\t\t}\n\n\n\t\tprivate static class StatusHandler {\n\n\t\t\tprivate final Predicate<HttpStatusCode> predicate;\n\n\t\t\tprivate final Function<ClientResponse, Mono<? extends Throwable>> exceptionFunction;\n\n\t\t\tpublic StatusHandler(Predicate<HttpStatusCode> predicate,\n\t\t\t\t\tFunction<ClientResponse, Mono<? extends Throwable>> exceptionFunction) {\n\n\t\t\t\tthis.predicate = predicate;\n\t\t\t\tthis.exceptionFunction = exceptionFunction;\n\t\t\t}\n\n\t\t\tpublic boolean test(HttpStatusCode status) {\n\t\t\t\treturn this.predicate.test(status);\n\t\t\t}\n\n\t\t\tpublic Mono<? extends Throwable> apply(ClientResponse response) {\n\t\t\t\treturn this.exceptionFunction.apply(response);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class ObservationFilterFunction implements ExchangeFilterFunction {\n\n\t\tprivate final ClientRequestObservationContext observationContext;\n\n\t\tObservationFilterFunction(ClientRequestObservationContext observationContext) {\n\t\t\tthis.observationContext = observationContext;\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<ClientResponse> filter(ClientRequest request, ExchangeFunction next) {\n\t\t\treturn next.exchange(request).doOnNext(this.observationContext::setResponse);\n\t\t}\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 193,
                        "lineEnd": 195,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method releaseIfNotConsumed to class DefaultClientResponse",
                        "description": "move method to org.springframework.web.reactive.function.client.DefaultClientResponse\nRationale: The method involves processing of 'ClientResponse', making the 'DefaultClientResponse' class the most related and appropriate for this method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "failed to unparse",
                            "method_signature": "failed to unparse",
                            "target_class": "failed to unparse",
                            "rationale": "No methods were found that would benefit from being relocated to a different class. The methods in the provided class are appropriately encapsulated in their respective classes according to their functionality."
                        }
                    ],
                    "llm_response_time": 4979
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "initStatusHandlers",
                            "method_signature": "private static List<DefaultResponseSpec.StatusHandler> initStatusHandlers(Map<Predicate<HttpStatusCode>, Function<ClientResponse, Mono<? extends Throwable>>> handlerMap)",
                            "target_class": "DefaultResponseSpec",
                            "rationale": "The method initStatusHandlers() is related to the setting up of status handlers which is related more to DefaultResponseSpec and not to DefaultWebClient. Moving it to the DefaultResponseSpec can enhance cohesion and make it simpler."
                        },
                        {
                            "method_name": "releaseIfNotConsumed",
                            "method_signature": "private static Mono<Void> releaseIfNotConsumed(ClientResponse response)",
                            "target_class": "ClientResponse",
                            "rationale": "The method releaseIfNotConsumed(ClientResponse response) operates directly on a ClientResponse. Therefore, it may be more cohesive to place this method in the ClientResponse class."
                        },
                        {
                            "method_name": "releaseIfNotConsumed",
                            "method_signature": "private static <T> Mono<T> releaseIfNotConsumed(ClientResponse response, Throwable ex)",
                            "target_class": "ClientResponse",
                            "rationale": "The method releaseIfNotConsumed(ClientResponse response, Throwable ex) operates directly on a ClientResponse. Therefore, it may be more cohesive to place this method in the ClientResponse class."
                        }
                    ],
                    "llm_response_time": 17056
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "releaseIfNotConsumed",
                            "method_signature": "private static Mono<Void> releaseIfNotConsumed(ClientResponse response)",
                            "target_class": "ClientResponse",
                            "rationale": "'releaseIfNotConsumed' method is logically related to the lifecycle of 'ClientResponse', so it might fit better in that class."
                        },
                        {
                            "method_name": "releaseIfNotConsumed",
                            "method_signature": "private static <T> Mono<T> releaseIfNotConsumed(ClientResponse response, Throwable ex)",
                            "target_class": "ClientResponse",
                            "rationale": "'releaseIfNotConsumed' method is logically related to the lifecycle of 'ClientResponse', so it might fit better in that class."
                        }
                    ],
                    "llm_response_time": 8105
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "initStatusHandlers",
                            "method_signature": "private static List<DefaultResponseSpec.StatusHandler> initStatusHandlers(Map<Predicate<HttpStatusCode>, Function<ClientResponse, Mono<? extends Throwable>>> handlerMap)",
                            "target_class": "DefaultResponseSpec",
                            "rationale": "The method initStatusHandlers() is related to the setting up of status handlers which is related more to DefaultResponseSpec and not to DefaultWebClient. Moving it to the DefaultResponseSpec can enhance cohesion and make it simpler."
                        },
                        {
                            "method_name": "releaseIfNotConsumed",
                            "method_signature": "private static Mono<Void> releaseIfNotConsumed(ClientResponse response)",
                            "target_class": "ClientResponse",
                            "rationale": "The method releaseIfNotConsumed(ClientResponse response) operates directly on a ClientResponse. Therefore, it may be more cohesive to place this method in the ClientResponse class."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "releaseIfNotConsumed",
                    "initStatusHandlers"
                ],
                "llm_response_time": 2821
            },
            "targetClassMap": {
                "releaseIfNotConsumed": {
                    "target_classes": [
                        {
                            "class_name": "WebClient",
                            "similarity_score": 0.03276849714084054
                        },
                        {
                            "class_name": "ClientRequest",
                            "similarity_score": 0.04997097256296886
                        },
                        {
                            "class_name": "ClientResponse",
                            "similarity_score": 0.08472377240334535
                        },
                        {
                            "class_name": "WebClientUtils",
                            "similarity_score": 0.3067191794659487
                        },
                        {
                            "class_name": "ExchangeFunction",
                            "similarity_score": 0.03753144575925375
                        },
                        {
                            "class_name": "ExchangeFunctions",
                            "similarity_score": 0.3902373364728103
                        },
                        {
                            "class_name": "ExchangeStrategies",
                            "similarity_score": 0.1732409627787675
                        },
                        {
                            "class_name": "WebClientException",
                            "similarity_score": 0.17129717745688292
                        },
                        {
                            "class_name": "DefaultClientResponse",
                            "similarity_score": 0.4826565999587173
                        },
                        {
                            "class_name": "ExchangeFilterFunction",
                            "similarity_score": 0.0834416757409494
                        },
                        {
                            "class_name": "DefaultWebClientBuilder",
                            "similarity_score": 0.41734413716987423
                        },
                        {
                            "class_name": "ExchangeFilterFunctions",
                            "similarity_score": 0.18488360570611082
                        },
                        {
                            "class_name": "WebClientRequestException",
                            "similarity_score": 0.34752402342845795
                        },
                        {
                            "class_name": "WebClientResponseException",
                            "similarity_score": 0.22472013061956775
                        },
                        {
                            "class_name": "DefaultClientRequestBuilder",
                            "similarity_score": 0.39438104254799167
                        },
                        {
                            "class_name": "DefaultClientResponseBuilder",
                            "similarity_score": 0.4082304626383359
                        },
                        {
                            "class_name": "UnknownHttpStatusCodeException",
                            "similarity_score": 0.10957958257972944
                        },
                        {
                            "class_name": "ClientRequestObservationContext",
                            "similarity_score": 0.19993283151472624
                        },
                        {
                            "class_name": "DefaultExchangeStrategiesBuilder",
                            "similarity_score": 0.42159809442763413
                        },
                        {
                            "class_name": "ClientHttpObservationDocumentation",
                            "similarity_score": 0.2785007551836717
                        },
                        {
                            "class_name": "ClientRequestObservationConvention",
                            "similarity_score": 0.17129717745688292
                        },
                        {
                            "class_name": "DefaultClientRequestObservationConvention",
                            "similarity_score": 0.48956913588212814
                        },
                        {
                            "class_name": "WebClientExtensionsKt",
                            "similarity_score": 0.0485471603829513
                        },
                        {
                            "class_name": "ClientResponseExtensionsKt",
                            "similarity_score": 0.00252178138612001
                        },
                        {
                            "class_name": "CoExchangeFilterFunction",
                            "similarity_score": 0.10503377248537309
                        },
                        {
                            "class_name": "CoExchangeFunction",
                            "similarity_score": 0.029462782549439483
                        },
                        {
                            "class_name": "ClientResponseExtensionsKt",
                            "similarity_score": 0.00252178138612001
                        },
                        {
                            "class_name": "WebClientExtensionsKt",
                            "similarity_score": 0.0485471603829513
                        },
                        {
                            "class_name": "CoExchangeFilterFunction",
                            "similarity_score": 0.10503377248537309
                        },
                        {
                            "class_name": "CoExchangeFunction",
                            "similarity_score": 0.029462782549439483
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "DefaultClientResponse",
                        "WebClientUtils",
                        "ClientResponse",
                        "DefaultClientRequestObservationConvention",
                        "DefaultExchangeStrategiesBuilder",
                        "DefaultWebClientBuilder",
                        "DefaultClientResponseBuilder",
                        "DefaultClientRequestBuilder",
                        "ExchangeFunctions",
                        "WebClientRequestException",
                        "ClientHttpObservationDocumentation",
                        "WebClientResponseException",
                        "ClientRequestObservationContext",
                        "ExchangeFilterFunctions",
                        "ExchangeStrategies",
                        "WebClientException",
                        "ClientRequestObservationConvention",
                        "UnknownHttpStatusCodeException",
                        "CoExchangeFilterFunction",
                        "ExchangeFilterFunction",
                        "ClientRequest",
                        "WebClientExtensionsKt",
                        "ExchangeFunction",
                        "WebClient",
                        "CoExchangeFunction",
                        "ClientResponseExtensionsKt"
                    ],
                    "llm_response_time": 9061,
                    "similarity_computation_time": 72,
                    "similarity_metric": "cosine"
                },
                "initStatusHandlers": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 9719,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "6691ff207244ef46cdf18e16df17f3cd19c9ce2a",
        "url": "https://github.com/spring-projects/spring-framework/commit/6691ff207244ef46cdf18e16df17f3cd19c9ce2a",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method public initializeRequestValuesBuilder() : HttpRequestValues.Builder from class org.springframework.web.service.invoker.HttpServiceMethod to public initializeRequestValuesBuilder() : HttpRequestValues.Builder from class org.springframework.web.service.invoker.HttpServiceMethod.HttpRequestValuesInitializer",
            "leftSideLocations": [
                {
                    "filePath": "spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                    "startLine": 155,
                    "endLine": 170,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "public initializeRequestValuesBuilder() : HttpRequestValues.Builder"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                    "startLine": 161,
                    "endLine": 176,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "public initializeRequestValuesBuilder() : HttpRequestValues.Builder"
                }
            ],
            "isStatic": false
        },
        "telemetry": {
            "id": "39b832f2-1963-4f2b-83f1-753016cc85b4",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 409,
                "lineStart": 49,
                "lineEnd": 457,
                "bodyLineStart": 49,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                "sourceCode": "/**\n * Implements the invocation of an {@link HttpExchange @HttpExchange}-annotated,\n * {@link HttpServiceProxyFactory#createClient(Class) HTTP service proxy} method\n * by delegating to an {@link HttpExchangeAdapter} to perform actual requests.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @author Olga Maciaszek-Sharma\n * @since 6.0\n */\nfinal class HttpServiceMethod {\n\n\tprivate static final boolean REACTOR_PRESENT =\n\t\t\tClassUtils.isPresent(\"reactor.core.publisher.Mono\", HttpServiceMethod.class.getClassLoader());\n\n\n\tprivate final Method method;\n\n\tprivate final MethodParameter[] parameters;\n\n\tprivate final List<HttpServiceArgumentResolver> argumentResolvers;\n\n\tprivate final HttpRequestValuesInitializer requestValuesInitializer;\n\n\tprivate final ResponseFunction responseFunction;\n\n\n\tHttpServiceMethod(\n\t\t\tMethod method, Class<?> containingClass, List<HttpServiceArgumentResolver> argumentResolvers,\n\t\t\tHttpExchangeAdapter adapter, @Nullable StringValueResolver embeddedValueResolver) {\n\n\t\tthis.method = method;\n\t\tthis.parameters = initMethodParameters(method);\n\t\tthis.argumentResolvers = argumentResolvers;\n\n\t\tboolean isReactorAdapter = (REACTOR_PRESENT && adapter instanceof ReactorHttpExchangeAdapter);\n\n\t\tthis.requestValuesInitializer =\n\t\t\t\tHttpRequestValuesInitializer.create(\n\t\t\t\t\t\tmethod, containingClass, embeddedValueResolver,\n\t\t\t\t\t\t(isReactorAdapter ? ReactiveHttpRequestValues::builder : HttpRequestValues::builder));\n\n\t\tthis.responseFunction = (isReactorAdapter ?\n\t\t\t\tReactorExchangeResponseFunction.create((ReactorHttpExchangeAdapter) adapter, method) :\n\t\t\t\tExchangeResponseFunction.create(adapter, method));\n\t}\n\n\tprivate static MethodParameter[] initMethodParameters(Method method) {\n\t\tint count = method.getParameterCount();\n\t\tif (count == 0) {\n\t\t\treturn new MethodParameter[0];\n\t\t}\n\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\tcount -= 1;\n\t\t}\n\n\t\tDefaultParameterNameDiscoverer nameDiscoverer = new DefaultParameterNameDiscoverer();\n\t\tMethodParameter[] parameters = new MethodParameter[count];\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tparameters[i] = new SynthesizingMethodParameter(method, i);\n\t\t\tparameters[i].initParameterNameDiscovery(nameDiscoverer);\n\t\t}\n\t\treturn parameters;\n\t}\n\n\n\tpublic Method getMethod() {\n\t\treturn this.method;\n\t}\n\n\n\t@Nullable\n\tpublic Object invoke(Object[] arguments) {\n\t\tHttpRequestValues.Builder requestValues = this.requestValuesInitializer.initializeRequestValuesBuilder();\n\t\tapplyArguments(requestValues, arguments);\n\t\treturn this.responseFunction.execute(requestValues.build());\n\t}\n\n\tprivate void applyArguments(HttpRequestValues.Builder requestValues, Object[] arguments) {\n\t\tAssert.isTrue(arguments.length == this.parameters.length, \"Method argument mismatch\");\n\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\tObject value = arguments[i];\n\t\t\tboolean resolved = false;\n\t\t\tfor (HttpServiceArgumentResolver resolver : this.argumentResolvers) {\n\t\t\t\tif (resolver.resolve(value, this.parameters[i], requestValues)) {\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint index = i;\n\t\t\tAssert.state(resolved, () ->\n\t\t\t\t\t\"Could not resolve parameter [\" + this.parameters[index].getParameterIndex() + \"] in \" +\n\t\t\t\t\t\t\tthis.parameters[index].getExecutable().toGenericString() + \": No suitable resolver\");\n\t\t}\n\t}\n\n\n\t/**\n\t * Factory for {@link HttpRequestValues} with values extracted from the type\n\t * and method-level {@link HttpExchange @HttpRequest} annotations.\n\t */\n\tprivate record HttpRequestValuesInitializer(\n\t\t\t@Nullable HttpMethod httpMethod, @Nullable String url,\n\t\t\t@Nullable MediaType contentType, @Nullable List<MediaType> acceptMediaTypes,\n\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier) {\n\n\t\tpublic HttpRequestValues.Builder initializeRequestValuesBuilder() {\n\t\t\tHttpRequestValues.Builder requestValues = this.requestValuesSupplier.get();\n\t\t\tif (this.httpMethod != null) {\n\t\t\t\trequestValues.setHttpMethod(this.httpMethod);\n\t\t\t}\n\t\t\tif (this.url != null) {\n\t\t\t\trequestValues.setUriTemplate(this.url);\n\t\t\t}\n\t\t\tif (this.contentType != null) {\n\t\t\t\trequestValues.setContentType(this.contentType);\n\t\t\t}\n\t\t\tif (this.acceptMediaTypes != null) {\n\t\t\t\trequestValues.setAccept(this.acceptMediaTypes);\n\t\t\t}\n\t\t\treturn requestValues;\n\t\t}\n\n\n\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */\n\t\tpublic static HttpRequestValuesInitializer create(\n\t\t\t\tMethod method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver,\n\t\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier) {\n\n\t\t\tHttpExchange typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(containingClass, HttpExchange.class);\n\t\t\tHttpExchange methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, HttpExchange.class);\n\n\t\t\tAssert.notNull(methodAnnotation, () -> \"Expected @HttpRequest annotation on method \" + method.toGenericString());\n\n\t\t\tHttpMethod httpMethod = initHttpMethod(typeAnnotation, methodAnnotation);\n\t\t\tString url = initUrl(typeAnnotation, methodAnnotation, embeddedValueResolver);\n\t\t\tMediaType contentType = initContentType(typeAnnotation, methodAnnotation);\n\t\t\tList<MediaType> acceptableMediaTypes = initAccept(typeAnnotation, methodAnnotation);\n\n\t\t\treturn new HttpRequestValuesInitializer(\n\t\t\t\t\thttpMethod, url, contentType, acceptableMediaTypes, requestValuesSupplier);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static HttpMethod initHttpMethod(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString methodLevelMethod = methodAnnotation.method();\n\t\t\tif (StringUtils.hasText(methodLevelMethod)) {\n\t\t\t\treturn HttpMethod.valueOf(methodLevelMethod);\n\t\t\t}\n\n\t\t\tString typeLevelMethod = (typeAnnotation != null ? typeAnnotation.method() : null);\n\t\t\tif (StringUtils.hasText(typeLevelMethod)) {\n\t\t\t\treturn HttpMethod.valueOf(typeLevelMethod);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static String initUrl(\n\t\t\t\t@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation,\n\t\t\t\t@Nullable StringValueResolver embeddedValueResolver) {\n\n\t\t\tString typeLevelUrl = (typeAnnotation != null ? typeAnnotation.url() : null);\n\t\t\tString methodLevelUrl = methodAnnotation.url();\n\n\t\t\tif (embeddedValueResolver != null) {\n\t\t\t\ttypeLevelUrl = (typeLevelUrl != null ? embeddedValueResolver.resolveStringValue(typeLevelUrl) : null);\n\t\t\t\tmethodLevelUrl = embeddedValueResolver.resolveStringValue(methodLevelUrl);\n\t\t\t}\n\n\t\t\tboolean hasTypeLevelUrl = StringUtils.hasText(typeLevelUrl);\n\t\t\tboolean hasMethodLevelUrl = StringUtils.hasText(methodLevelUrl);\n\n\t\t\tif (hasTypeLevelUrl && hasMethodLevelUrl) {\n\t\t\t\treturn (typeLevelUrl + (!typeLevelUrl.endsWith(\"/\") && !methodLevelUrl.startsWith(\"/\") ? \"/\" : \"\") + methodLevelUrl);\n\t\t\t}\n\n\t\t\tif (!hasTypeLevelUrl && !hasMethodLevelUrl) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn (hasMethodLevelUrl ? methodLevelUrl : typeLevelUrl);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static MediaType initContentType(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString methodLevelContentType = methodAnnotation.contentType();\n\t\t\tif (StringUtils.hasText(methodLevelContentType)) {\n\t\t\t\treturn MediaType.parseMediaType(methodLevelContentType);\n\t\t\t}\n\n\t\t\tString typeLevelContentType = (typeAnnotation != null ? typeAnnotation.contentType() : null);\n\t\t\tif (StringUtils.hasText(typeLevelContentType)) {\n\t\t\t\treturn MediaType.parseMediaType(typeLevelContentType);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static List<MediaType> initAccept(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString[] methodLevelAccept = methodAnnotation.accept();\n\t\t\tif (!ObjectUtils.isEmpty(methodLevelAccept)) {\n\t\t\t\treturn MediaType.parseMediaTypes(List.of(methodLevelAccept));\n\t\t\t}\n\n\t\t\tString[] typeLevelAccept = (typeAnnotation != null ? typeAnnotation.accept() : null);\n\t\t\tif (!ObjectUtils.isEmpty(typeLevelAccept)) {\n\t\t\t\treturn MediaType.parseMediaTypes(List.of(typeLevelAccept));\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * Execute a request, obtain a response, and adapt to the expected return type.\n\t */\n\tprivate interface ResponseFunction {\n\n\t\t@Nullable\n\t\tObject execute(HttpRequestValues requestValues);\n\n\t}\n\n\tprivate record ExchangeResponseFunction(\n\t\t\tFunction<HttpRequestValues, Object> responseFunction) implements ResponseFunction {\n\n\t\t@Override\n\t\tpublic Object execute(HttpRequestValues requestValues) {\n\t\t\treturn this.responseFunction.apply(requestValues);\n\t\t}\n\n\n\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */\n\t\tpublic static ResponseFunction create(HttpExchangeAdapter client, Method method) {\n\t\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Kotlin Coroutines are only supported with reactive implementations\");\n\t\t\t}\n\n\t\t\tMethodParameter param = new MethodParameter(method, -1).nestedIfOptional();\n\t\t\tClass<?> paramType = param.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Object> responseFunction;\n\t\t\tif (paramType.equals(void.class) || paramType.equals(Void.class)) {\n\t\t\t\tresponseFunction = requestValues -> {\n\t\t\t\t\tclient.exchange(requestValues);\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if (paramType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = request -> asOptionalIfNecessary(client.exchangeForHeaders(request), param);\n\t\t\t}\n\t\t\telse if (paramType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = param.nested();\n\t\t\t\tif (bodyParam.getNestedParameterType().equals(Void.class)) {\n\t\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForBodilessEntity(request), param);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tParameterizedTypeReference<?> bodyTypeRef =\n\t\t\t\t\t\t\tParameterizedTypeReference.forType(bodyParam.getNestedGenericParameterType());\n\t\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForEntity(request, bodyTypeRef), param);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tParameterizedTypeReference<?> bodyTypeRef =\n\t\t\t\t\t\tParameterizedTypeReference.forType(param.getNestedGenericParameterType());\n\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForBody(request, bodyTypeRef), param);\n\t\t\t}\n\n\t\t\treturn new ExchangeResponseFunction(responseFunction);\n\t\t}\n\n\t\tprivate static @Nullable Object asOptionalIfNecessary(@Nullable Object response, MethodParameter param) {\n\t\t\treturn param.getParameterType().equals(Optional.class) ? Optional.ofNullable(response) : response;\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link ResponseFunction} for {@link ReactorHttpExchangeAdapter}.\n\t */\n\tprivate record ReactorExchangeResponseFunction(\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction,\n\t\t\t@Nullable ReactiveAdapter returnTypeAdapter,\n\t\t\tboolean blockForOptional, @Nullable Duration blockTimeout) implements ResponseFunction {\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object execute(HttpRequestValues requestValues) {\n\n\t\t\tPublisher<?> responsePublisher = this.responseFunction.apply(requestValues);\n\n\t\t\tif (this.returnTypeAdapter != null) {\n\t\t\t\treturn this.returnTypeAdapter.fromPublisher(responsePublisher);\n\t\t\t}\n\n\t\t\tif (this.blockForOptional) {\n\t\t\t\treturn (this.blockTimeout != null ?\n\t\t\t\t\t\t((Mono<?>) responsePublisher).blockOptional(this.blockTimeout) :\n\t\t\t\t\t\t((Mono<?>) responsePublisher).blockOptional());\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (this.blockTimeout != null ?\n\t\t\t\t\t\t((Mono<?>) responsePublisher).block(this.blockTimeout) :\n\t\t\t\t\t\t((Mono<?>) responsePublisher).block());\n\t\t\t}\n\t\t}\n\n\n\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */\n\t\tpublic static ResponseFunction create(ReactorHttpExchangeAdapter client, Method method) {\n\t\t\tMethodParameter returnParam = new MethodParameter(method, -1);\n\t\t\tClass<?> returnType = returnParam.getParameterType();\n\t\t\tboolean isSuspending = KotlinDetector.isSuspendingFunction(method);\n\t\t\tif (isSuspending) {\n\t\t\t\treturnType = Mono.class;\n\t\t\t}\n\n\t\t\tReactiveAdapter reactiveAdapter = client.getReactiveAdapterRegistry().getAdapter(returnType);\n\n\t\t\tMethodParameter actualParam = (reactiveAdapter != null ? returnParam.nested() : returnParam.nestedIfOptional());\n\t\t\tClass<?> actualType = isSuspending ? actualParam.getParameterType() : actualParam.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction;\n\t\t\tif (actualType.equals(void.class) || actualType.equals(Void.class)) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (reactiveAdapter != null && reactiveAdapter.isNoValue()) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = client::exchangeForHeadersMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = isSuspending ? actualParam : actualParam.nested();\n\t\t\t\tClass<?> bodyType = bodyParam.getNestedParameterType();\n\t\t\t\tif (bodyType.equals(Void.class)) {\n\t\t\t\t\tresponseFunction = client::exchangeForBodilessEntityMono;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReactiveAdapter bodyAdapter = client.getReactiveAdapterRegistry().getAdapter(bodyType);\n\t\t\t\t\tresponseFunction = initResponseEntityFunction(client, bodyParam, bodyAdapter, isSuspending);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponseFunction = initBodyFunction(client, actualParam, reactiveAdapter, isSuspending);\n\t\t\t}\n\n\t\t\treturn new ReactorExchangeResponseFunction(\n\t\t\t\t\tresponseFunction, reactiveAdapter, returnType.equals(Optional.class), client.getBlockTimeout());\n\t\t}\n\n\t\t@SuppressWarnings(\"ConstantConditions\")\n\t\tprivate static Function<HttpRequestValues, Publisher<?>> initResponseEntityFunction(\n\t\t\t\tReactorHttpExchangeAdapter client, MethodParameter methodParam,\n\t\t\t\t@Nullable ReactiveAdapter reactiveAdapter, boolean isSuspending) {\n\n\t\t\tif (reactiveAdapter == null) {\n\t\t\t\treturn request -> client.exchangeForEntityMono(\n\t\t\t\t\t\trequest, ParameterizedTypeReference.forType(methodParam.getNestedGenericParameterType()));\n\t\t\t}\n\n\t\t\tAssert.isTrue(reactiveAdapter.isMultiValue(),\n\t\t\t\t\t\"ResponseEntity body must be a concrete value or a multi-value Publisher\");\n\n\t\t\tParameterizedTypeReference<?> bodyType =\n\t\t\t\t\tParameterizedTypeReference.forType(isSuspending ? methodParam.nested().getGenericParameterType() :\n\t\t\t\t\t\t\tmethodParam.nested().getNestedGenericParameterType());\n\n\t\t\t// Shortcut for Flux\n\t\t\tif (reactiveAdapter.getReactiveType().equals(Flux.class)) {\n\t\t\t\treturn request -> client.exchangeForEntityFlux(request, bodyType);\n\t\t\t}\n\n\t\t\treturn request -> client.exchangeForEntityFlux(request, bodyType)\n\t\t\t\t\t.map(entity -> {\n\t\t\t\t\t\tObject body = reactiveAdapter.fromPublisher(entity.getBody());\n\t\t\t\t\t\treturn new ResponseEntity<>(body, entity.getHeaders(), entity.getStatusCode());\n\t\t\t\t\t});\n\t\t}\n\n\t\tprivate static Function<HttpRequestValues, Publisher<?>> initBodyFunction(\n\t\t\t\tReactorHttpExchangeAdapter client, MethodParameter methodParam,\n\t\t\t\t@Nullable ReactiveAdapter reactiveAdapter, boolean isSuspending) {\n\n\t\t\tParameterizedTypeReference<?> bodyType =\n\t\t\t\t\tParameterizedTypeReference.forType(isSuspending ? methodParam.getGenericParameterType() :\n\t\t\t\t\t\t\tmethodParam.getNestedGenericParameterType());\n\n\t\t\treturn (reactiveAdapter != null && reactiveAdapter.isMultiValue() ?\n\t\t\t\t\trequest -> client.exchangeForBodyFlux(request, bodyType) :\n\t\t\t\t\trequest -> client.exchangeForBodyMono(request, bodyType));\n\t\t}\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 3,
                "candidates": [
                    {
                        "lineStart": 368,
                        "lineEnd": 411,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method create to class HttpServiceMethod",
                        "description": "move method to org.springframework.web.service.invoker.HttpServiceMethod\nRationale: This method is heavily involved in processing HTTP service method exchanges, arranging responses, and working with reactive programming components. As such, it would be a good fit for the 'HttpServiceMethod' class, where it can more directly access and manipulate the details of service methods and their associated exchanges.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 119,
                        "lineEnd": 124,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method invoke to class ResponseFunction",
                        "description": "Move method to org.springframework.web.service.invoker.HttpServiceMethod.ResponseFunction\nRationale: The method invokes the 'execute' function of 'this.responseFunction', which implies that it is tightly coupled with the functionality of the 'ResponseFunction' class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 95,
                        "lineEnd": 111,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method initMethodParameters to class HttpMethodArgumentResolver",
                        "description": "move method to org.springframework.web.service.invoker.HttpMethodArgumentResolver\nRationale: This method is involved in the handling and processing of Method instances, it is suspected to do some argument resolution as well - which would be the key responsibility of a class like 'HttpMethodArgumentResolver'.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [],
                    "llm_response_time": 2834
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "invoke",
                            "method_signature": "public Object invoke(Object[] arguments): Object",
                            "target_class": "HttpClient",
                            "rationale": "The 'invoke' method is making HTTP exchange which is better to be in HttpClient class as a part of the external service communication."
                        },
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static MethodParameter[] initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "ReflectionUtils",
                            "rationale": "The 'initMethodParameters' method is purely related to reflection and parameter extraction which is better suited in a utility class such as ReflectionUtils."
                        }
                    ],
                    "llm_response_time": 7625
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "MethodInitialization",
                            "rationale": "initMethodParameters() is a utility method that focuses on initializing method parameters. It does not handle any HTTP Service specific procedures and is more related to general method initialization, so it could be moved to a 'MethodInitialization' utility class."
                        },
                        {
                            "method_name": "create",
                            "method_signature": "public static create(HttpExchangeAdapter client, Method method): ResponseFunction",
                            "target_class": "ResponseFunctionFactory",
                            "rationale": "create() method is used to create instances of 'ResponseFunction' according to the method return type. This method essentially performs the role of a factory for creating 'ResponseFunction' instances, so it would make sense to move it to a dedicated factory class, 'ResponseFunctionFactory'."
                        }
                    ],
                    "llm_response_time": 18512
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "invoke",
                            "method_signature": "public Object invoke(Object[] arguments): Object",
                            "target_class": "HttpClient",
                            "rationale": "The 'invoke' method is making HTTP exchange which is better to be in HttpClient class as a part of the external service communication."
                        },
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static MethodParameter[] initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "ReflectionUtils",
                            "rationale": "The 'initMethodParameters' method is purely related to reflection and parameter extraction which is better suited in a utility class such as ReflectionUtils."
                        },
                        {
                            "method_name": "create",
                            "method_signature": "public static create(HttpExchangeAdapter client, Method method): ResponseFunction",
                            "target_class": "ResponseFunctionFactory",
                            "rationale": "create() method is used to create instances of 'ResponseFunction' according to the method return type. This method essentially performs the role of a factory for creating 'ResponseFunction' instances, so it would make sense to move it to a dedicated factory class, 'ResponseFunctionFactory'."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "create",
                    "invoke",
                    "initMethodParameters"
                ],
                "llm_response_time": 4151
            },
            "targetClassMap": {
                "create": {
                    "target_classes": [
                        {
                            "class_name": "HttpServiceMethod",
                            "similarity_score": 0.8426924708817681
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HttpServiceMethod"
                    ],
                    "llm_response_time": 4717,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "invoke": {
                    "target_classes": [
                        {
                            "class_name": "ResponseFunction",
                            "similarity_score": 0.24845199749997662
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ResponseFunction"
                    ],
                    "llm_response_time": 3715,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "initMethodParameters": {
                    "target_classes": [
                        {
                            "class_name": "HttpClientAdapter",
                            "similarity_score": 0.16335892281539527
                        },
                        {
                            "class_name": "HttpRequestValues",
                            "similarity_score": 0.43755735048290084
                        },
                        {
                            "class_name": "HttpExchangeAdapter",
                            "similarity_score": 0.025823475817683298
                        },
                        {
                            "class_name": "UrlArgumentResolver",
                            "similarity_score": 0.34464735255878187
                        },
                        {
                            "class_name": "HttpServiceProxyFactory",
                            "similarity_score": 0.4152750858686238
                        },
                        {
                            "class_name": "ReactiveHttpRequestValues",
                            "similarity_score": 0.4023666452760909
                        },
                        {
                            "class_name": "HttpMethodArgumentResolver",
                            "similarity_score": 0.3745371356605301
                        },
                        {
                            "class_name": "ReactorHttpExchangeAdapter",
                            "similarity_score": 0.023074792438534632
                        },
                        {
                            "class_name": "CookieValueArgumentResolver",
                            "similarity_score": 0.1342464417333466
                        },
                        {
                            "class_name": "HttpServiceArgumentResolver",
                            "similarity_score": 0.062365251721675424
                        },
                        {
                            "class_name": "RequestBodyArgumentResolver",
                            "similarity_score": 0.5677222062762607
                        },
                        {
                            "class_name": "RequestPartArgumentResolver",
                            "similarity_score": 0.5527201115750559
                        },
                        {
                            "class_name": "PathVariableArgumentResolver",
                            "similarity_score": 0.1701983272637592
                        },
                        {
                            "class_name": "RequestParamArgumentResolver",
                            "similarity_score": 0.12152698052680239
                        },
                        {
                            "class_name": "RequestHeaderArgumentResolver",
                            "similarity_score": 0.13034228089960004
                        },
                        {
                            "class_name": "RequestAttributeArgumentResolver",
                            "similarity_score": 0.16523456360801006
                        },
                        {
                            "class_name": "UriBuilderFactoryArgumentResolver",
                            "similarity_score": 0.20838949718155603
                        },
                        {
                            "class_name": "AbstractNamedValueArgumentResolver",
                            "similarity_score": 0.5237768448548211
                        },
                        {
                            "class_name": "AbstractReactorHttpExchangeAdapter",
                            "similarity_score": 0.42686638447117015
                        },
                        {
                            "class_name": "HttpServiceProxyFactoryExtensionsKt",
                            "similarity_score": 0.02825752575780252
                        },
                        {
                            "class_name": "HttpServiceProxyFactoryExtensionsKt",
                            "similarity_score": 0.02825752575780252
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HttpMethodArgumentResolver",
                        "RequestParamArgumentResolver",
                        "RequestBodyArgumentResolver",
                        "RequestPartArgumentResolver",
                        "AbstractNamedValueArgumentResolver",
                        "HttpRequestValues",
                        "AbstractReactorHttpExchangeAdapter",
                        "HttpServiceProxyFactory",
                        "ReactiveHttpRequestValues",
                        "UrlArgumentResolver",
                        "UriBuilderFactoryArgumentResolver",
                        "PathVariableArgumentResolver",
                        "RequestAttributeArgumentResolver",
                        "HttpClientAdapter",
                        "CookieValueArgumentResolver",
                        "RequestHeaderArgumentResolver",
                        "HttpServiceArgumentResolver",
                        "HttpServiceProxyFactoryExtensionsKt",
                        "HttpExchangeAdapter",
                        "ReactorHttpExchangeAdapter"
                    ],
                    "llm_response_time": 9513,
                    "similarity_computation_time": 43,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "6691ff207244ef46cdf18e16df17f3cd19c9ce2a",
        "url": "https://github.com/spring-projects/spring-framework/commit/6691ff207244ef46cdf18e16df17f3cd19c9ce2a",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method public create(method Method, containingClass Class<?>, embeddedValueResolver StringValueResolver, requestValuesSupplier Supplier<HttpRequestValues.Builder>) : HttpRequestValuesInitializer from class org.springframework.web.service.invoker.HttpServiceMethod to public create(method Method, containingClass Class<?>, embeddedValueResolver StringValueResolver, requestValuesSupplier Supplier<HttpRequestValues.Builder>) : HttpRequestValuesInitializer from class org.springframework.web.service.invoker.HttpServiceMethod.HttpRequestValuesInitializer",
            "leftSideLocations": [
                {
                    "filePath": "spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                    "startLine": 173,
                    "endLine": 192,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "public create(method Method, containingClass Class<?>, embeddedValueResolver StringValueResolver, requestValuesSupplier Supplier<HttpRequestValues.Builder>) : HttpRequestValuesInitializer"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                    "startLine": 179,
                    "endLine": 208,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "public create(method Method, containingClass Class<?>, embeddedValueResolver StringValueResolver, requestValuesSupplier Supplier<HttpRequestValues.Builder>) : HttpRequestValuesInitializer"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "39b832f2-1963-4f2b-83f1-753016cc85b4",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 409,
                "lineStart": 49,
                "lineEnd": 457,
                "bodyLineStart": 49,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                "sourceCode": "/**\n * Implements the invocation of an {@link HttpExchange @HttpExchange}-annotated,\n * {@link HttpServiceProxyFactory#createClient(Class) HTTP service proxy} method\n * by delegating to an {@link HttpExchangeAdapter} to perform actual requests.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @author Olga Maciaszek-Sharma\n * @since 6.0\n */\nfinal class HttpServiceMethod {\n\n\tprivate static final boolean REACTOR_PRESENT =\n\t\t\tClassUtils.isPresent(\"reactor.core.publisher.Mono\", HttpServiceMethod.class.getClassLoader());\n\n\n\tprivate final Method method;\n\n\tprivate final MethodParameter[] parameters;\n\n\tprivate final List<HttpServiceArgumentResolver> argumentResolvers;\n\n\tprivate final HttpRequestValuesInitializer requestValuesInitializer;\n\n\tprivate final ResponseFunction responseFunction;\n\n\n\tHttpServiceMethod(\n\t\t\tMethod method, Class<?> containingClass, List<HttpServiceArgumentResolver> argumentResolvers,\n\t\t\tHttpExchangeAdapter adapter, @Nullable StringValueResolver embeddedValueResolver) {\n\n\t\tthis.method = method;\n\t\tthis.parameters = initMethodParameters(method);\n\t\tthis.argumentResolvers = argumentResolvers;\n\n\t\tboolean isReactorAdapter = (REACTOR_PRESENT && adapter instanceof ReactorHttpExchangeAdapter);\n\n\t\tthis.requestValuesInitializer =\n\t\t\t\tHttpRequestValuesInitializer.create(\n\t\t\t\t\t\tmethod, containingClass, embeddedValueResolver,\n\t\t\t\t\t\t(isReactorAdapter ? ReactiveHttpRequestValues::builder : HttpRequestValues::builder));\n\n\t\tthis.responseFunction = (isReactorAdapter ?\n\t\t\t\tReactorExchangeResponseFunction.create((ReactorHttpExchangeAdapter) adapter, method) :\n\t\t\t\tExchangeResponseFunction.create(adapter, method));\n\t}\n\n\tprivate static MethodParameter[] initMethodParameters(Method method) {\n\t\tint count = method.getParameterCount();\n\t\tif (count == 0) {\n\t\t\treturn new MethodParameter[0];\n\t\t}\n\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\tcount -= 1;\n\t\t}\n\n\t\tDefaultParameterNameDiscoverer nameDiscoverer = new DefaultParameterNameDiscoverer();\n\t\tMethodParameter[] parameters = new MethodParameter[count];\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tparameters[i] = new SynthesizingMethodParameter(method, i);\n\t\t\tparameters[i].initParameterNameDiscovery(nameDiscoverer);\n\t\t}\n\t\treturn parameters;\n\t}\n\n\n\tpublic Method getMethod() {\n\t\treturn this.method;\n\t}\n\n\n\t@Nullable\n\tpublic Object invoke(Object[] arguments) {\n\t\tHttpRequestValues.Builder requestValues = this.requestValuesInitializer.initializeRequestValuesBuilder();\n\t\tapplyArguments(requestValues, arguments);\n\t\treturn this.responseFunction.execute(requestValues.build());\n\t}\n\n\tprivate void applyArguments(HttpRequestValues.Builder requestValues, Object[] arguments) {\n\t\tAssert.isTrue(arguments.length == this.parameters.length, \"Method argument mismatch\");\n\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\tObject value = arguments[i];\n\t\t\tboolean resolved = false;\n\t\t\tfor (HttpServiceArgumentResolver resolver : this.argumentResolvers) {\n\t\t\t\tif (resolver.resolve(value, this.parameters[i], requestValues)) {\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint index = i;\n\t\t\tAssert.state(resolved, () ->\n\t\t\t\t\t\"Could not resolve parameter [\" + this.parameters[index].getParameterIndex() + \"] in \" +\n\t\t\t\t\t\t\tthis.parameters[index].getExecutable().toGenericString() + \": No suitable resolver\");\n\t\t}\n\t}\n\n\n\t/**\n\t * Factory for {@link HttpRequestValues} with values extracted from the type\n\t * and method-level {@link HttpExchange @HttpRequest} annotations.\n\t */\n\tprivate record HttpRequestValuesInitializer(\n\t\t\t@Nullable HttpMethod httpMethod, @Nullable String url,\n\t\t\t@Nullable MediaType contentType, @Nullable List<MediaType> acceptMediaTypes,\n\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier) {\n\n\t\tpublic HttpRequestValues.Builder initializeRequestValuesBuilder() {\n\t\t\tHttpRequestValues.Builder requestValues = this.requestValuesSupplier.get();\n\t\t\tif (this.httpMethod != null) {\n\t\t\t\trequestValues.setHttpMethod(this.httpMethod);\n\t\t\t}\n\t\t\tif (this.url != null) {\n\t\t\t\trequestValues.setUriTemplate(this.url);\n\t\t\t}\n\t\t\tif (this.contentType != null) {\n\t\t\t\trequestValues.setContentType(this.contentType);\n\t\t\t}\n\t\t\tif (this.acceptMediaTypes != null) {\n\t\t\t\trequestValues.setAccept(this.acceptMediaTypes);\n\t\t\t}\n\t\t\treturn requestValues;\n\t\t}\n\n\n\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */\n\t\tpublic static HttpRequestValuesInitializer create(\n\t\t\t\tMethod method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver,\n\t\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier) {\n\n\t\t\tHttpExchange typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(containingClass, HttpExchange.class);\n\t\t\tHttpExchange methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, HttpExchange.class);\n\n\t\t\tAssert.notNull(methodAnnotation, () -> \"Expected @HttpRequest annotation on method \" + method.toGenericString());\n\n\t\t\tHttpMethod httpMethod = initHttpMethod(typeAnnotation, methodAnnotation);\n\t\t\tString url = initUrl(typeAnnotation, methodAnnotation, embeddedValueResolver);\n\t\t\tMediaType contentType = initContentType(typeAnnotation, methodAnnotation);\n\t\t\tList<MediaType> acceptableMediaTypes = initAccept(typeAnnotation, methodAnnotation);\n\n\t\t\treturn new HttpRequestValuesInitializer(\n\t\t\t\t\thttpMethod, url, contentType, acceptableMediaTypes, requestValuesSupplier);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static HttpMethod initHttpMethod(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString methodLevelMethod = methodAnnotation.method();\n\t\t\tif (StringUtils.hasText(methodLevelMethod)) {\n\t\t\t\treturn HttpMethod.valueOf(methodLevelMethod);\n\t\t\t}\n\n\t\t\tString typeLevelMethod = (typeAnnotation != null ? typeAnnotation.method() : null);\n\t\t\tif (StringUtils.hasText(typeLevelMethod)) {\n\t\t\t\treturn HttpMethod.valueOf(typeLevelMethod);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static String initUrl(\n\t\t\t\t@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation,\n\t\t\t\t@Nullable StringValueResolver embeddedValueResolver) {\n\n\t\t\tString typeLevelUrl = (typeAnnotation != null ? typeAnnotation.url() : null);\n\t\t\tString methodLevelUrl = methodAnnotation.url();\n\n\t\t\tif (embeddedValueResolver != null) {\n\t\t\t\ttypeLevelUrl = (typeLevelUrl != null ? embeddedValueResolver.resolveStringValue(typeLevelUrl) : null);\n\t\t\t\tmethodLevelUrl = embeddedValueResolver.resolveStringValue(methodLevelUrl);\n\t\t\t}\n\n\t\t\tboolean hasTypeLevelUrl = StringUtils.hasText(typeLevelUrl);\n\t\t\tboolean hasMethodLevelUrl = StringUtils.hasText(methodLevelUrl);\n\n\t\t\tif (hasTypeLevelUrl && hasMethodLevelUrl) {\n\t\t\t\treturn (typeLevelUrl + (!typeLevelUrl.endsWith(\"/\") && !methodLevelUrl.startsWith(\"/\") ? \"/\" : \"\") + methodLevelUrl);\n\t\t\t}\n\n\t\t\tif (!hasTypeLevelUrl && !hasMethodLevelUrl) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn (hasMethodLevelUrl ? methodLevelUrl : typeLevelUrl);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static MediaType initContentType(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString methodLevelContentType = methodAnnotation.contentType();\n\t\t\tif (StringUtils.hasText(methodLevelContentType)) {\n\t\t\t\treturn MediaType.parseMediaType(methodLevelContentType);\n\t\t\t}\n\n\t\t\tString typeLevelContentType = (typeAnnotation != null ? typeAnnotation.contentType() : null);\n\t\t\tif (StringUtils.hasText(typeLevelContentType)) {\n\t\t\t\treturn MediaType.parseMediaType(typeLevelContentType);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static List<MediaType> initAccept(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString[] methodLevelAccept = methodAnnotation.accept();\n\t\t\tif (!ObjectUtils.isEmpty(methodLevelAccept)) {\n\t\t\t\treturn MediaType.parseMediaTypes(List.of(methodLevelAccept));\n\t\t\t}\n\n\t\t\tString[] typeLevelAccept = (typeAnnotation != null ? typeAnnotation.accept() : null);\n\t\t\tif (!ObjectUtils.isEmpty(typeLevelAccept)) {\n\t\t\t\treturn MediaType.parseMediaTypes(List.of(typeLevelAccept));\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * Execute a request, obtain a response, and adapt to the expected return type.\n\t */\n\tprivate interface ResponseFunction {\n\n\t\t@Nullable\n\t\tObject execute(HttpRequestValues requestValues);\n\n\t}\n\n\tprivate record ExchangeResponseFunction(\n\t\t\tFunction<HttpRequestValues, Object> responseFunction) implements ResponseFunction {\n\n\t\t@Override\n\t\tpublic Object execute(HttpRequestValues requestValues) {\n\t\t\treturn this.responseFunction.apply(requestValues);\n\t\t}\n\n\n\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */\n\t\tpublic static ResponseFunction create(HttpExchangeAdapter client, Method method) {\n\t\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Kotlin Coroutines are only supported with reactive implementations\");\n\t\t\t}\n\n\t\t\tMethodParameter param = new MethodParameter(method, -1).nestedIfOptional();\n\t\t\tClass<?> paramType = param.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Object> responseFunction;\n\t\t\tif (paramType.equals(void.class) || paramType.equals(Void.class)) {\n\t\t\t\tresponseFunction = requestValues -> {\n\t\t\t\t\tclient.exchange(requestValues);\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if (paramType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = request -> asOptionalIfNecessary(client.exchangeForHeaders(request), param);\n\t\t\t}\n\t\t\telse if (paramType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = param.nested();\n\t\t\t\tif (bodyParam.getNestedParameterType().equals(Void.class)) {\n\t\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForBodilessEntity(request), param);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tParameterizedTypeReference<?> bodyTypeRef =\n\t\t\t\t\t\t\tParameterizedTypeReference.forType(bodyParam.getNestedGenericParameterType());\n\t\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForEntity(request, bodyTypeRef), param);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tParameterizedTypeReference<?> bodyTypeRef =\n\t\t\t\t\t\tParameterizedTypeReference.forType(param.getNestedGenericParameterType());\n\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForBody(request, bodyTypeRef), param);\n\t\t\t}\n\n\t\t\treturn new ExchangeResponseFunction(responseFunction);\n\t\t}\n\n\t\tprivate static @Nullable Object asOptionalIfNecessary(@Nullable Object response, MethodParameter param) {\n\t\t\treturn param.getParameterType().equals(Optional.class) ? Optional.ofNullable(response) : response;\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link ResponseFunction} for {@link ReactorHttpExchangeAdapter}.\n\t */\n\tprivate record ReactorExchangeResponseFunction(\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction,\n\t\t\t@Nullable ReactiveAdapter returnTypeAdapter,\n\t\t\tboolean blockForOptional, @Nullable Duration blockTimeout) implements ResponseFunction {\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object execute(HttpRequestValues requestValues) {\n\n\t\t\tPublisher<?> responsePublisher = this.responseFunction.apply(requestValues);\n\n\t\t\tif (this.returnTypeAdapter != null) {\n\t\t\t\treturn this.returnTypeAdapter.fromPublisher(responsePublisher);\n\t\t\t}\n\n\t\t\tif (this.blockForOptional) {\n\t\t\t\treturn (this.blockTimeout != null ?\n\t\t\t\t\t\t((Mono<?>) responsePublisher).blockOptional(this.blockTimeout) :\n\t\t\t\t\t\t((Mono<?>) responsePublisher).blockOptional());\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (this.blockTimeout != null ?\n\t\t\t\t\t\t((Mono<?>) responsePublisher).block(this.blockTimeout) :\n\t\t\t\t\t\t((Mono<?>) responsePublisher).block());\n\t\t\t}\n\t\t}\n\n\n\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */\n\t\tpublic static ResponseFunction create(ReactorHttpExchangeAdapter client, Method method) {\n\t\t\tMethodParameter returnParam = new MethodParameter(method, -1);\n\t\t\tClass<?> returnType = returnParam.getParameterType();\n\t\t\tboolean isSuspending = KotlinDetector.isSuspendingFunction(method);\n\t\t\tif (isSuspending) {\n\t\t\t\treturnType = Mono.class;\n\t\t\t}\n\n\t\t\tReactiveAdapter reactiveAdapter = client.getReactiveAdapterRegistry().getAdapter(returnType);\n\n\t\t\tMethodParameter actualParam = (reactiveAdapter != null ? returnParam.nested() : returnParam.nestedIfOptional());\n\t\t\tClass<?> actualType = isSuspending ? actualParam.getParameterType() : actualParam.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction;\n\t\t\tif (actualType.equals(void.class) || actualType.equals(Void.class)) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (reactiveAdapter != null && reactiveAdapter.isNoValue()) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = client::exchangeForHeadersMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = isSuspending ? actualParam : actualParam.nested();\n\t\t\t\tClass<?> bodyType = bodyParam.getNestedParameterType();\n\t\t\t\tif (bodyType.equals(Void.class)) {\n\t\t\t\t\tresponseFunction = client::exchangeForBodilessEntityMono;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReactiveAdapter bodyAdapter = client.getReactiveAdapterRegistry().getAdapter(bodyType);\n\t\t\t\t\tresponseFunction = initResponseEntityFunction(client, bodyParam, bodyAdapter, isSuspending);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponseFunction = initBodyFunction(client, actualParam, reactiveAdapter, isSuspending);\n\t\t\t}\n\n\t\t\treturn new ReactorExchangeResponseFunction(\n\t\t\t\t\tresponseFunction, reactiveAdapter, returnType.equals(Optional.class), client.getBlockTimeout());\n\t\t}\n\n\t\t@SuppressWarnings(\"ConstantConditions\")\n\t\tprivate static Function<HttpRequestValues, Publisher<?>> initResponseEntityFunction(\n\t\t\t\tReactorHttpExchangeAdapter client, MethodParameter methodParam,\n\t\t\t\t@Nullable ReactiveAdapter reactiveAdapter, boolean isSuspending) {\n\n\t\t\tif (reactiveAdapter == null) {\n\t\t\t\treturn request -> client.exchangeForEntityMono(\n\t\t\t\t\t\trequest, ParameterizedTypeReference.forType(methodParam.getNestedGenericParameterType()));\n\t\t\t}\n\n\t\t\tAssert.isTrue(reactiveAdapter.isMultiValue(),\n\t\t\t\t\t\"ResponseEntity body must be a concrete value or a multi-value Publisher\");\n\n\t\t\tParameterizedTypeReference<?> bodyType =\n\t\t\t\t\tParameterizedTypeReference.forType(isSuspending ? methodParam.nested().getGenericParameterType() :\n\t\t\t\t\t\t\tmethodParam.nested().getNestedGenericParameterType());\n\n\t\t\t// Shortcut for Flux\n\t\t\tif (reactiveAdapter.getReactiveType().equals(Flux.class)) {\n\t\t\t\treturn request -> client.exchangeForEntityFlux(request, bodyType);\n\t\t\t}\n\n\t\t\treturn request -> client.exchangeForEntityFlux(request, bodyType)\n\t\t\t\t\t.map(entity -> {\n\t\t\t\t\t\tObject body = reactiveAdapter.fromPublisher(entity.getBody());\n\t\t\t\t\t\treturn new ResponseEntity<>(body, entity.getHeaders(), entity.getStatusCode());\n\t\t\t\t\t});\n\t\t}\n\n\t\tprivate static Function<HttpRequestValues, Publisher<?>> initBodyFunction(\n\t\t\t\tReactorHttpExchangeAdapter client, MethodParameter methodParam,\n\t\t\t\t@Nullable ReactiveAdapter reactiveAdapter, boolean isSuspending) {\n\n\t\t\tParameterizedTypeReference<?> bodyType =\n\t\t\t\t\tParameterizedTypeReference.forType(isSuspending ? methodParam.getGenericParameterType() :\n\t\t\t\t\t\t\tmethodParam.getNestedGenericParameterType());\n\n\t\t\treturn (reactiveAdapter != null && reactiveAdapter.isMultiValue() ?\n\t\t\t\t\trequest -> client.exchangeForBodyFlux(request, bodyType) :\n\t\t\t\t\trequest -> client.exchangeForBodyMono(request, bodyType));\n\t\t}\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 3,
                "candidates": [
                    {
                        "lineStart": 368,
                        "lineEnd": 411,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method create to class HttpServiceMethod",
                        "description": "move method to org.springframework.web.service.invoker.HttpServiceMethod\nRationale: This method is heavily involved in processing HTTP service method exchanges, arranging responses, and working with reactive programming components. As such, it would be a good fit for the 'HttpServiceMethod' class, where it can more directly access and manipulate the details of service methods and their associated exchanges.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 119,
                        "lineEnd": 124,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method invoke to class ResponseFunction",
                        "description": "Move method to org.springframework.web.service.invoker.HttpServiceMethod.ResponseFunction\nRationale: The method invokes the 'execute' function of 'this.responseFunction', which implies that it is tightly coupled with the functionality of the 'ResponseFunction' class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 95,
                        "lineEnd": 111,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method initMethodParameters to class HttpMethodArgumentResolver",
                        "description": "move method to org.springframework.web.service.invoker.HttpMethodArgumentResolver\nRationale: This method is involved in the handling and processing of Method instances, it is suspected to do some argument resolution as well - which would be the key responsibility of a class like 'HttpMethodArgumentResolver'.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [],
                    "llm_response_time": 2834
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "invoke",
                            "method_signature": "public Object invoke(Object[] arguments): Object",
                            "target_class": "HttpClient",
                            "rationale": "The 'invoke' method is making HTTP exchange which is better to be in HttpClient class as a part of the external service communication."
                        },
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static MethodParameter[] initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "ReflectionUtils",
                            "rationale": "The 'initMethodParameters' method is purely related to reflection and parameter extraction which is better suited in a utility class such as ReflectionUtils."
                        }
                    ],
                    "llm_response_time": 7625
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "MethodInitialization",
                            "rationale": "initMethodParameters() is a utility method that focuses on initializing method parameters. It does not handle any HTTP Service specific procedures and is more related to general method initialization, so it could be moved to a 'MethodInitialization' utility class."
                        },
                        {
                            "method_name": "create",
                            "method_signature": "public static create(HttpExchangeAdapter client, Method method): ResponseFunction",
                            "target_class": "ResponseFunctionFactory",
                            "rationale": "create() method is used to create instances of 'ResponseFunction' according to the method return type. This method essentially performs the role of a factory for creating 'ResponseFunction' instances, so it would make sense to move it to a dedicated factory class, 'ResponseFunctionFactory'."
                        }
                    ],
                    "llm_response_time": 18512
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "invoke",
                            "method_signature": "public Object invoke(Object[] arguments): Object",
                            "target_class": "HttpClient",
                            "rationale": "The 'invoke' method is making HTTP exchange which is better to be in HttpClient class as a part of the external service communication."
                        },
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static MethodParameter[] initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "ReflectionUtils",
                            "rationale": "The 'initMethodParameters' method is purely related to reflection and parameter extraction which is better suited in a utility class such as ReflectionUtils."
                        },
                        {
                            "method_name": "create",
                            "method_signature": "public static create(HttpExchangeAdapter client, Method method): ResponseFunction",
                            "target_class": "ResponseFunctionFactory",
                            "rationale": "create() method is used to create instances of 'ResponseFunction' according to the method return type. This method essentially performs the role of a factory for creating 'ResponseFunction' instances, so it would make sense to move it to a dedicated factory class, 'ResponseFunctionFactory'."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "create",
                    "invoke",
                    "initMethodParameters"
                ],
                "llm_response_time": 4151
            },
            "targetClassMap": {
                "create": {
                    "target_classes": [
                        {
                            "class_name": "HttpServiceMethod",
                            "similarity_score": 0.8426924708817681
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HttpServiceMethod"
                    ],
                    "llm_response_time": 4717,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "invoke": {
                    "target_classes": [
                        {
                            "class_name": "ResponseFunction",
                            "similarity_score": 0.24845199749997662
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ResponseFunction"
                    ],
                    "llm_response_time": 3715,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "initMethodParameters": {
                    "target_classes": [
                        {
                            "class_name": "HttpClientAdapter",
                            "similarity_score": 0.16335892281539527
                        },
                        {
                            "class_name": "HttpRequestValues",
                            "similarity_score": 0.43755735048290084
                        },
                        {
                            "class_name": "HttpExchangeAdapter",
                            "similarity_score": 0.025823475817683298
                        },
                        {
                            "class_name": "UrlArgumentResolver",
                            "similarity_score": 0.34464735255878187
                        },
                        {
                            "class_name": "HttpServiceProxyFactory",
                            "similarity_score": 0.4152750858686238
                        },
                        {
                            "class_name": "ReactiveHttpRequestValues",
                            "similarity_score": 0.4023666452760909
                        },
                        {
                            "class_name": "HttpMethodArgumentResolver",
                            "similarity_score": 0.3745371356605301
                        },
                        {
                            "class_name": "ReactorHttpExchangeAdapter",
                            "similarity_score": 0.023074792438534632
                        },
                        {
                            "class_name": "CookieValueArgumentResolver",
                            "similarity_score": 0.1342464417333466
                        },
                        {
                            "class_name": "HttpServiceArgumentResolver",
                            "similarity_score": 0.062365251721675424
                        },
                        {
                            "class_name": "RequestBodyArgumentResolver",
                            "similarity_score": 0.5677222062762607
                        },
                        {
                            "class_name": "RequestPartArgumentResolver",
                            "similarity_score": 0.5527201115750559
                        },
                        {
                            "class_name": "PathVariableArgumentResolver",
                            "similarity_score": 0.1701983272637592
                        },
                        {
                            "class_name": "RequestParamArgumentResolver",
                            "similarity_score": 0.12152698052680239
                        },
                        {
                            "class_name": "RequestHeaderArgumentResolver",
                            "similarity_score": 0.13034228089960004
                        },
                        {
                            "class_name": "RequestAttributeArgumentResolver",
                            "similarity_score": 0.16523456360801006
                        },
                        {
                            "class_name": "UriBuilderFactoryArgumentResolver",
                            "similarity_score": 0.20838949718155603
                        },
                        {
                            "class_name": "AbstractNamedValueArgumentResolver",
                            "similarity_score": 0.5237768448548211
                        },
                        {
                            "class_name": "AbstractReactorHttpExchangeAdapter",
                            "similarity_score": 0.42686638447117015
                        },
                        {
                            "class_name": "HttpServiceProxyFactoryExtensionsKt",
                            "similarity_score": 0.02825752575780252
                        },
                        {
                            "class_name": "HttpServiceProxyFactoryExtensionsKt",
                            "similarity_score": 0.02825752575780252
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HttpMethodArgumentResolver",
                        "RequestParamArgumentResolver",
                        "RequestBodyArgumentResolver",
                        "RequestPartArgumentResolver",
                        "AbstractNamedValueArgumentResolver",
                        "HttpRequestValues",
                        "AbstractReactorHttpExchangeAdapter",
                        "HttpServiceProxyFactory",
                        "ReactiveHttpRequestValues",
                        "UrlArgumentResolver",
                        "UriBuilderFactoryArgumentResolver",
                        "PathVariableArgumentResolver",
                        "RequestAttributeArgumentResolver",
                        "HttpClientAdapter",
                        "CookieValueArgumentResolver",
                        "RequestHeaderArgumentResolver",
                        "HttpServiceArgumentResolver",
                        "HttpServiceProxyFactoryExtensionsKt",
                        "HttpExchangeAdapter",
                        "ReactorHttpExchangeAdapter"
                    ],
                    "llm_response_time": 9513,
                    "similarity_computation_time": 43,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "6691ff207244ef46cdf18e16df17f3cd19c9ce2a",
        "url": "https://github.com/spring-projects/spring-framework/commit/6691ff207244ef46cdf18e16df17f3cd19c9ce2a",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private initHttpMethod(typeAnnotation HttpExchange, methodAnnotation HttpExchange) : HttpMethod from class org.springframework.web.service.invoker.HttpServiceMethod to private initHttpMethod(typeAnnotation HttpExchange, methodAnnotation HttpExchange) : HttpMethod from class org.springframework.web.service.invoker.HttpServiceMethod.HttpRequestValuesInitializer",
            "leftSideLocations": [
                {
                    "filePath": "spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                    "startLine": 194,
                    "endLine": 207,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private initHttpMethod(typeAnnotation HttpExchange, methodAnnotation HttpExchange) : HttpMethod"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                    "startLine": 210,
                    "endLine": 223,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "private initHttpMethod(typeAnnotation HttpExchange, methodAnnotation HttpExchange) : HttpMethod"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "39b832f2-1963-4f2b-83f1-753016cc85b4",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 409,
                "lineStart": 49,
                "lineEnd": 457,
                "bodyLineStart": 49,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                "sourceCode": "/**\n * Implements the invocation of an {@link HttpExchange @HttpExchange}-annotated,\n * {@link HttpServiceProxyFactory#createClient(Class) HTTP service proxy} method\n * by delegating to an {@link HttpExchangeAdapter} to perform actual requests.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @author Olga Maciaszek-Sharma\n * @since 6.0\n */\nfinal class HttpServiceMethod {\n\n\tprivate static final boolean REACTOR_PRESENT =\n\t\t\tClassUtils.isPresent(\"reactor.core.publisher.Mono\", HttpServiceMethod.class.getClassLoader());\n\n\n\tprivate final Method method;\n\n\tprivate final MethodParameter[] parameters;\n\n\tprivate final List<HttpServiceArgumentResolver> argumentResolvers;\n\n\tprivate final HttpRequestValuesInitializer requestValuesInitializer;\n\n\tprivate final ResponseFunction responseFunction;\n\n\n\tHttpServiceMethod(\n\t\t\tMethod method, Class<?> containingClass, List<HttpServiceArgumentResolver> argumentResolvers,\n\t\t\tHttpExchangeAdapter adapter, @Nullable StringValueResolver embeddedValueResolver) {\n\n\t\tthis.method = method;\n\t\tthis.parameters = initMethodParameters(method);\n\t\tthis.argumentResolvers = argumentResolvers;\n\n\t\tboolean isReactorAdapter = (REACTOR_PRESENT && adapter instanceof ReactorHttpExchangeAdapter);\n\n\t\tthis.requestValuesInitializer =\n\t\t\t\tHttpRequestValuesInitializer.create(\n\t\t\t\t\t\tmethod, containingClass, embeddedValueResolver,\n\t\t\t\t\t\t(isReactorAdapter ? ReactiveHttpRequestValues::builder : HttpRequestValues::builder));\n\n\t\tthis.responseFunction = (isReactorAdapter ?\n\t\t\t\tReactorExchangeResponseFunction.create((ReactorHttpExchangeAdapter) adapter, method) :\n\t\t\t\tExchangeResponseFunction.create(adapter, method));\n\t}\n\n\tprivate static MethodParameter[] initMethodParameters(Method method) {\n\t\tint count = method.getParameterCount();\n\t\tif (count == 0) {\n\t\t\treturn new MethodParameter[0];\n\t\t}\n\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\tcount -= 1;\n\t\t}\n\n\t\tDefaultParameterNameDiscoverer nameDiscoverer = new DefaultParameterNameDiscoverer();\n\t\tMethodParameter[] parameters = new MethodParameter[count];\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tparameters[i] = new SynthesizingMethodParameter(method, i);\n\t\t\tparameters[i].initParameterNameDiscovery(nameDiscoverer);\n\t\t}\n\t\treturn parameters;\n\t}\n\n\n\tpublic Method getMethod() {\n\t\treturn this.method;\n\t}\n\n\n\t@Nullable\n\tpublic Object invoke(Object[] arguments) {\n\t\tHttpRequestValues.Builder requestValues = this.requestValuesInitializer.initializeRequestValuesBuilder();\n\t\tapplyArguments(requestValues, arguments);\n\t\treturn this.responseFunction.execute(requestValues.build());\n\t}\n\n\tprivate void applyArguments(HttpRequestValues.Builder requestValues, Object[] arguments) {\n\t\tAssert.isTrue(arguments.length == this.parameters.length, \"Method argument mismatch\");\n\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\tObject value = arguments[i];\n\t\t\tboolean resolved = false;\n\t\t\tfor (HttpServiceArgumentResolver resolver : this.argumentResolvers) {\n\t\t\t\tif (resolver.resolve(value, this.parameters[i], requestValues)) {\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint index = i;\n\t\t\tAssert.state(resolved, () ->\n\t\t\t\t\t\"Could not resolve parameter [\" + this.parameters[index].getParameterIndex() + \"] in \" +\n\t\t\t\t\t\t\tthis.parameters[index].getExecutable().toGenericString() + \": No suitable resolver\");\n\t\t}\n\t}\n\n\n\t/**\n\t * Factory for {@link HttpRequestValues} with values extracted from the type\n\t * and method-level {@link HttpExchange @HttpRequest} annotations.\n\t */\n\tprivate record HttpRequestValuesInitializer(\n\t\t\t@Nullable HttpMethod httpMethod, @Nullable String url,\n\t\t\t@Nullable MediaType contentType, @Nullable List<MediaType> acceptMediaTypes,\n\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier) {\n\n\t\tpublic HttpRequestValues.Builder initializeRequestValuesBuilder() {\n\t\t\tHttpRequestValues.Builder requestValues = this.requestValuesSupplier.get();\n\t\t\tif (this.httpMethod != null) {\n\t\t\t\trequestValues.setHttpMethod(this.httpMethod);\n\t\t\t}\n\t\t\tif (this.url != null) {\n\t\t\t\trequestValues.setUriTemplate(this.url);\n\t\t\t}\n\t\t\tif (this.contentType != null) {\n\t\t\t\trequestValues.setContentType(this.contentType);\n\t\t\t}\n\t\t\tif (this.acceptMediaTypes != null) {\n\t\t\t\trequestValues.setAccept(this.acceptMediaTypes);\n\t\t\t}\n\t\t\treturn requestValues;\n\t\t}\n\n\n\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */\n\t\tpublic static HttpRequestValuesInitializer create(\n\t\t\t\tMethod method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver,\n\t\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier) {\n\n\t\t\tHttpExchange typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(containingClass, HttpExchange.class);\n\t\t\tHttpExchange methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, HttpExchange.class);\n\n\t\t\tAssert.notNull(methodAnnotation, () -> \"Expected @HttpRequest annotation on method \" + method.toGenericString());\n\n\t\t\tHttpMethod httpMethod = initHttpMethod(typeAnnotation, methodAnnotation);\n\t\t\tString url = initUrl(typeAnnotation, methodAnnotation, embeddedValueResolver);\n\t\t\tMediaType contentType = initContentType(typeAnnotation, methodAnnotation);\n\t\t\tList<MediaType> acceptableMediaTypes = initAccept(typeAnnotation, methodAnnotation);\n\n\t\t\treturn new HttpRequestValuesInitializer(\n\t\t\t\t\thttpMethod, url, contentType, acceptableMediaTypes, requestValuesSupplier);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static HttpMethod initHttpMethod(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString methodLevelMethod = methodAnnotation.method();\n\t\t\tif (StringUtils.hasText(methodLevelMethod)) {\n\t\t\t\treturn HttpMethod.valueOf(methodLevelMethod);\n\t\t\t}\n\n\t\t\tString typeLevelMethod = (typeAnnotation != null ? typeAnnotation.method() : null);\n\t\t\tif (StringUtils.hasText(typeLevelMethod)) {\n\t\t\t\treturn HttpMethod.valueOf(typeLevelMethod);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static String initUrl(\n\t\t\t\t@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation,\n\t\t\t\t@Nullable StringValueResolver embeddedValueResolver) {\n\n\t\t\tString typeLevelUrl = (typeAnnotation != null ? typeAnnotation.url() : null);\n\t\t\tString methodLevelUrl = methodAnnotation.url();\n\n\t\t\tif (embeddedValueResolver != null) {\n\t\t\t\ttypeLevelUrl = (typeLevelUrl != null ? embeddedValueResolver.resolveStringValue(typeLevelUrl) : null);\n\t\t\t\tmethodLevelUrl = embeddedValueResolver.resolveStringValue(methodLevelUrl);\n\t\t\t}\n\n\t\t\tboolean hasTypeLevelUrl = StringUtils.hasText(typeLevelUrl);\n\t\t\tboolean hasMethodLevelUrl = StringUtils.hasText(methodLevelUrl);\n\n\t\t\tif (hasTypeLevelUrl && hasMethodLevelUrl) {\n\t\t\t\treturn (typeLevelUrl + (!typeLevelUrl.endsWith(\"/\") && !methodLevelUrl.startsWith(\"/\") ? \"/\" : \"\") + methodLevelUrl);\n\t\t\t}\n\n\t\t\tif (!hasTypeLevelUrl && !hasMethodLevelUrl) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn (hasMethodLevelUrl ? methodLevelUrl : typeLevelUrl);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static MediaType initContentType(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString methodLevelContentType = methodAnnotation.contentType();\n\t\t\tif (StringUtils.hasText(methodLevelContentType)) {\n\t\t\t\treturn MediaType.parseMediaType(methodLevelContentType);\n\t\t\t}\n\n\t\t\tString typeLevelContentType = (typeAnnotation != null ? typeAnnotation.contentType() : null);\n\t\t\tif (StringUtils.hasText(typeLevelContentType)) {\n\t\t\t\treturn MediaType.parseMediaType(typeLevelContentType);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static List<MediaType> initAccept(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString[] methodLevelAccept = methodAnnotation.accept();\n\t\t\tif (!ObjectUtils.isEmpty(methodLevelAccept)) {\n\t\t\t\treturn MediaType.parseMediaTypes(List.of(methodLevelAccept));\n\t\t\t}\n\n\t\t\tString[] typeLevelAccept = (typeAnnotation != null ? typeAnnotation.accept() : null);\n\t\t\tif (!ObjectUtils.isEmpty(typeLevelAccept)) {\n\t\t\t\treturn MediaType.parseMediaTypes(List.of(typeLevelAccept));\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * Execute a request, obtain a response, and adapt to the expected return type.\n\t */\n\tprivate interface ResponseFunction {\n\n\t\t@Nullable\n\t\tObject execute(HttpRequestValues requestValues);\n\n\t}\n\n\tprivate record ExchangeResponseFunction(\n\t\t\tFunction<HttpRequestValues, Object> responseFunction) implements ResponseFunction {\n\n\t\t@Override\n\t\tpublic Object execute(HttpRequestValues requestValues) {\n\t\t\treturn this.responseFunction.apply(requestValues);\n\t\t}\n\n\n\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */\n\t\tpublic static ResponseFunction create(HttpExchangeAdapter client, Method method) {\n\t\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Kotlin Coroutines are only supported with reactive implementations\");\n\t\t\t}\n\n\t\t\tMethodParameter param = new MethodParameter(method, -1).nestedIfOptional();\n\t\t\tClass<?> paramType = param.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Object> responseFunction;\n\t\t\tif (paramType.equals(void.class) || paramType.equals(Void.class)) {\n\t\t\t\tresponseFunction = requestValues -> {\n\t\t\t\t\tclient.exchange(requestValues);\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if (paramType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = request -> asOptionalIfNecessary(client.exchangeForHeaders(request), param);\n\t\t\t}\n\t\t\telse if (paramType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = param.nested();\n\t\t\t\tif (bodyParam.getNestedParameterType().equals(Void.class)) {\n\t\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForBodilessEntity(request), param);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tParameterizedTypeReference<?> bodyTypeRef =\n\t\t\t\t\t\t\tParameterizedTypeReference.forType(bodyParam.getNestedGenericParameterType());\n\t\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForEntity(request, bodyTypeRef), param);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tParameterizedTypeReference<?> bodyTypeRef =\n\t\t\t\t\t\tParameterizedTypeReference.forType(param.getNestedGenericParameterType());\n\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForBody(request, bodyTypeRef), param);\n\t\t\t}\n\n\t\t\treturn new ExchangeResponseFunction(responseFunction);\n\t\t}\n\n\t\tprivate static @Nullable Object asOptionalIfNecessary(@Nullable Object response, MethodParameter param) {\n\t\t\treturn param.getParameterType().equals(Optional.class) ? Optional.ofNullable(response) : response;\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link ResponseFunction} for {@link ReactorHttpExchangeAdapter}.\n\t */\n\tprivate record ReactorExchangeResponseFunction(\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction,\n\t\t\t@Nullable ReactiveAdapter returnTypeAdapter,\n\t\t\tboolean blockForOptional, @Nullable Duration blockTimeout) implements ResponseFunction {\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object execute(HttpRequestValues requestValues) {\n\n\t\t\tPublisher<?> responsePublisher = this.responseFunction.apply(requestValues);\n\n\t\t\tif (this.returnTypeAdapter != null) {\n\t\t\t\treturn this.returnTypeAdapter.fromPublisher(responsePublisher);\n\t\t\t}\n\n\t\t\tif (this.blockForOptional) {\n\t\t\t\treturn (this.blockTimeout != null ?\n\t\t\t\t\t\t((Mono<?>) responsePublisher).blockOptional(this.blockTimeout) :\n\t\t\t\t\t\t((Mono<?>) responsePublisher).blockOptional());\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (this.blockTimeout != null ?\n\t\t\t\t\t\t((Mono<?>) responsePublisher).block(this.blockTimeout) :\n\t\t\t\t\t\t((Mono<?>) responsePublisher).block());\n\t\t\t}\n\t\t}\n\n\n\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */\n\t\tpublic static ResponseFunction create(ReactorHttpExchangeAdapter client, Method method) {\n\t\t\tMethodParameter returnParam = new MethodParameter(method, -1);\n\t\t\tClass<?> returnType = returnParam.getParameterType();\n\t\t\tboolean isSuspending = KotlinDetector.isSuspendingFunction(method);\n\t\t\tif (isSuspending) {\n\t\t\t\treturnType = Mono.class;\n\t\t\t}\n\n\t\t\tReactiveAdapter reactiveAdapter = client.getReactiveAdapterRegistry().getAdapter(returnType);\n\n\t\t\tMethodParameter actualParam = (reactiveAdapter != null ? returnParam.nested() : returnParam.nestedIfOptional());\n\t\t\tClass<?> actualType = isSuspending ? actualParam.getParameterType() : actualParam.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction;\n\t\t\tif (actualType.equals(void.class) || actualType.equals(Void.class)) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (reactiveAdapter != null && reactiveAdapter.isNoValue()) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = client::exchangeForHeadersMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = isSuspending ? actualParam : actualParam.nested();\n\t\t\t\tClass<?> bodyType = bodyParam.getNestedParameterType();\n\t\t\t\tif (bodyType.equals(Void.class)) {\n\t\t\t\t\tresponseFunction = client::exchangeForBodilessEntityMono;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReactiveAdapter bodyAdapter = client.getReactiveAdapterRegistry().getAdapter(bodyType);\n\t\t\t\t\tresponseFunction = initResponseEntityFunction(client, bodyParam, bodyAdapter, isSuspending);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponseFunction = initBodyFunction(client, actualParam, reactiveAdapter, isSuspending);\n\t\t\t}\n\n\t\t\treturn new ReactorExchangeResponseFunction(\n\t\t\t\t\tresponseFunction, reactiveAdapter, returnType.equals(Optional.class), client.getBlockTimeout());\n\t\t}\n\n\t\t@SuppressWarnings(\"ConstantConditions\")\n\t\tprivate static Function<HttpRequestValues, Publisher<?>> initResponseEntityFunction(\n\t\t\t\tReactorHttpExchangeAdapter client, MethodParameter methodParam,\n\t\t\t\t@Nullable ReactiveAdapter reactiveAdapter, boolean isSuspending) {\n\n\t\t\tif (reactiveAdapter == null) {\n\t\t\t\treturn request -> client.exchangeForEntityMono(\n\t\t\t\t\t\trequest, ParameterizedTypeReference.forType(methodParam.getNestedGenericParameterType()));\n\t\t\t}\n\n\t\t\tAssert.isTrue(reactiveAdapter.isMultiValue(),\n\t\t\t\t\t\"ResponseEntity body must be a concrete value or a multi-value Publisher\");\n\n\t\t\tParameterizedTypeReference<?> bodyType =\n\t\t\t\t\tParameterizedTypeReference.forType(isSuspending ? methodParam.nested().getGenericParameterType() :\n\t\t\t\t\t\t\tmethodParam.nested().getNestedGenericParameterType());\n\n\t\t\t// Shortcut for Flux\n\t\t\tif (reactiveAdapter.getReactiveType().equals(Flux.class)) {\n\t\t\t\treturn request -> client.exchangeForEntityFlux(request, bodyType);\n\t\t\t}\n\n\t\t\treturn request -> client.exchangeForEntityFlux(request, bodyType)\n\t\t\t\t\t.map(entity -> {\n\t\t\t\t\t\tObject body = reactiveAdapter.fromPublisher(entity.getBody());\n\t\t\t\t\t\treturn new ResponseEntity<>(body, entity.getHeaders(), entity.getStatusCode());\n\t\t\t\t\t});\n\t\t}\n\n\t\tprivate static Function<HttpRequestValues, Publisher<?>> initBodyFunction(\n\t\t\t\tReactorHttpExchangeAdapter client, MethodParameter methodParam,\n\t\t\t\t@Nullable ReactiveAdapter reactiveAdapter, boolean isSuspending) {\n\n\t\t\tParameterizedTypeReference<?> bodyType =\n\t\t\t\t\tParameterizedTypeReference.forType(isSuspending ? methodParam.getGenericParameterType() :\n\t\t\t\t\t\t\tmethodParam.getNestedGenericParameterType());\n\n\t\t\treturn (reactiveAdapter != null && reactiveAdapter.isMultiValue() ?\n\t\t\t\t\trequest -> client.exchangeForBodyFlux(request, bodyType) :\n\t\t\t\t\trequest -> client.exchangeForBodyMono(request, bodyType));\n\t\t}\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 3,
                "candidates": [
                    {
                        "lineStart": 368,
                        "lineEnd": 411,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method create to class HttpServiceMethod",
                        "description": "move method to org.springframework.web.service.invoker.HttpServiceMethod\nRationale: This method is heavily involved in processing HTTP service method exchanges, arranging responses, and working with reactive programming components. As such, it would be a good fit for the 'HttpServiceMethod' class, where it can more directly access and manipulate the details of service methods and their associated exchanges.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 119,
                        "lineEnd": 124,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method invoke to class ResponseFunction",
                        "description": "Move method to org.springframework.web.service.invoker.HttpServiceMethod.ResponseFunction\nRationale: The method invokes the 'execute' function of 'this.responseFunction', which implies that it is tightly coupled with the functionality of the 'ResponseFunction' class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 95,
                        "lineEnd": 111,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method initMethodParameters to class HttpMethodArgumentResolver",
                        "description": "move method to org.springframework.web.service.invoker.HttpMethodArgumentResolver\nRationale: This method is involved in the handling and processing of Method instances, it is suspected to do some argument resolution as well - which would be the key responsibility of a class like 'HttpMethodArgumentResolver'.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [],
                    "llm_response_time": 2834
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "invoke",
                            "method_signature": "public Object invoke(Object[] arguments): Object",
                            "target_class": "HttpClient",
                            "rationale": "The 'invoke' method is making HTTP exchange which is better to be in HttpClient class as a part of the external service communication."
                        },
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static MethodParameter[] initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "ReflectionUtils",
                            "rationale": "The 'initMethodParameters' method is purely related to reflection and parameter extraction which is better suited in a utility class such as ReflectionUtils."
                        }
                    ],
                    "llm_response_time": 7625
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "MethodInitialization",
                            "rationale": "initMethodParameters() is a utility method that focuses on initializing method parameters. It does not handle any HTTP Service specific procedures and is more related to general method initialization, so it could be moved to a 'MethodInitialization' utility class."
                        },
                        {
                            "method_name": "create",
                            "method_signature": "public static create(HttpExchangeAdapter client, Method method): ResponseFunction",
                            "target_class": "ResponseFunctionFactory",
                            "rationale": "create() method is used to create instances of 'ResponseFunction' according to the method return type. This method essentially performs the role of a factory for creating 'ResponseFunction' instances, so it would make sense to move it to a dedicated factory class, 'ResponseFunctionFactory'."
                        }
                    ],
                    "llm_response_time": 18512
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "invoke",
                            "method_signature": "public Object invoke(Object[] arguments): Object",
                            "target_class": "HttpClient",
                            "rationale": "The 'invoke' method is making HTTP exchange which is better to be in HttpClient class as a part of the external service communication."
                        },
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static MethodParameter[] initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "ReflectionUtils",
                            "rationale": "The 'initMethodParameters' method is purely related to reflection and parameter extraction which is better suited in a utility class such as ReflectionUtils."
                        },
                        {
                            "method_name": "create",
                            "method_signature": "public static create(HttpExchangeAdapter client, Method method): ResponseFunction",
                            "target_class": "ResponseFunctionFactory",
                            "rationale": "create() method is used to create instances of 'ResponseFunction' according to the method return type. This method essentially performs the role of a factory for creating 'ResponseFunction' instances, so it would make sense to move it to a dedicated factory class, 'ResponseFunctionFactory'."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "create",
                    "invoke",
                    "initMethodParameters"
                ],
                "llm_response_time": 4151
            },
            "targetClassMap": {
                "create": {
                    "target_classes": [
                        {
                            "class_name": "HttpServiceMethod",
                            "similarity_score": 0.8426924708817681
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HttpServiceMethod"
                    ],
                    "llm_response_time": 4717,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "invoke": {
                    "target_classes": [
                        {
                            "class_name": "ResponseFunction",
                            "similarity_score": 0.24845199749997662
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ResponseFunction"
                    ],
                    "llm_response_time": 3715,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "initMethodParameters": {
                    "target_classes": [
                        {
                            "class_name": "HttpClientAdapter",
                            "similarity_score": 0.16335892281539527
                        },
                        {
                            "class_name": "HttpRequestValues",
                            "similarity_score": 0.43755735048290084
                        },
                        {
                            "class_name": "HttpExchangeAdapter",
                            "similarity_score": 0.025823475817683298
                        },
                        {
                            "class_name": "UrlArgumentResolver",
                            "similarity_score": 0.34464735255878187
                        },
                        {
                            "class_name": "HttpServiceProxyFactory",
                            "similarity_score": 0.4152750858686238
                        },
                        {
                            "class_name": "ReactiveHttpRequestValues",
                            "similarity_score": 0.4023666452760909
                        },
                        {
                            "class_name": "HttpMethodArgumentResolver",
                            "similarity_score": 0.3745371356605301
                        },
                        {
                            "class_name": "ReactorHttpExchangeAdapter",
                            "similarity_score": 0.023074792438534632
                        },
                        {
                            "class_name": "CookieValueArgumentResolver",
                            "similarity_score": 0.1342464417333466
                        },
                        {
                            "class_name": "HttpServiceArgumentResolver",
                            "similarity_score": 0.062365251721675424
                        },
                        {
                            "class_name": "RequestBodyArgumentResolver",
                            "similarity_score": 0.5677222062762607
                        },
                        {
                            "class_name": "RequestPartArgumentResolver",
                            "similarity_score": 0.5527201115750559
                        },
                        {
                            "class_name": "PathVariableArgumentResolver",
                            "similarity_score": 0.1701983272637592
                        },
                        {
                            "class_name": "RequestParamArgumentResolver",
                            "similarity_score": 0.12152698052680239
                        },
                        {
                            "class_name": "RequestHeaderArgumentResolver",
                            "similarity_score": 0.13034228089960004
                        },
                        {
                            "class_name": "RequestAttributeArgumentResolver",
                            "similarity_score": 0.16523456360801006
                        },
                        {
                            "class_name": "UriBuilderFactoryArgumentResolver",
                            "similarity_score": 0.20838949718155603
                        },
                        {
                            "class_name": "AbstractNamedValueArgumentResolver",
                            "similarity_score": 0.5237768448548211
                        },
                        {
                            "class_name": "AbstractReactorHttpExchangeAdapter",
                            "similarity_score": 0.42686638447117015
                        },
                        {
                            "class_name": "HttpServiceProxyFactoryExtensionsKt",
                            "similarity_score": 0.02825752575780252
                        },
                        {
                            "class_name": "HttpServiceProxyFactoryExtensionsKt",
                            "similarity_score": 0.02825752575780252
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HttpMethodArgumentResolver",
                        "RequestParamArgumentResolver",
                        "RequestBodyArgumentResolver",
                        "RequestPartArgumentResolver",
                        "AbstractNamedValueArgumentResolver",
                        "HttpRequestValues",
                        "AbstractReactorHttpExchangeAdapter",
                        "HttpServiceProxyFactory",
                        "ReactiveHttpRequestValues",
                        "UrlArgumentResolver",
                        "UriBuilderFactoryArgumentResolver",
                        "PathVariableArgumentResolver",
                        "RequestAttributeArgumentResolver",
                        "HttpClientAdapter",
                        "CookieValueArgumentResolver",
                        "RequestHeaderArgumentResolver",
                        "HttpServiceArgumentResolver",
                        "HttpServiceProxyFactoryExtensionsKt",
                        "HttpExchangeAdapter",
                        "ReactorHttpExchangeAdapter"
                    ],
                    "llm_response_time": 9513,
                    "similarity_computation_time": 43,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "6691ff207244ef46cdf18e16df17f3cd19c9ce2a",
        "url": "https://github.com/spring-projects/spring-framework/commit/6691ff207244ef46cdf18e16df17f3cd19c9ce2a",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private initUrl(typeAnnotation HttpExchange, methodAnnotation HttpExchange, embeddedValueResolver StringValueResolver) : String from class org.springframework.web.service.invoker.HttpServiceMethod to private initUrl(typeAnnotation HttpExchange, methodAnnotation HttpExchange, embeddedValueResolver StringValueResolver) : String from class org.springframework.web.service.invoker.HttpServiceMethod.HttpRequestValuesInitializer",
            "leftSideLocations": [
                {
                    "filePath": "spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                    "startLine": 209,
                    "endLine": 234,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private initUrl(typeAnnotation HttpExchange, methodAnnotation HttpExchange, embeddedValueResolver StringValueResolver) : String"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                    "startLine": 225,
                    "endLine": 250,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "private initUrl(typeAnnotation HttpExchange, methodAnnotation HttpExchange, embeddedValueResolver StringValueResolver) : String"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "39b832f2-1963-4f2b-83f1-753016cc85b4",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 409,
                "lineStart": 49,
                "lineEnd": 457,
                "bodyLineStart": 49,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                "sourceCode": "/**\n * Implements the invocation of an {@link HttpExchange @HttpExchange}-annotated,\n * {@link HttpServiceProxyFactory#createClient(Class) HTTP service proxy} method\n * by delegating to an {@link HttpExchangeAdapter} to perform actual requests.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @author Olga Maciaszek-Sharma\n * @since 6.0\n */\nfinal class HttpServiceMethod {\n\n\tprivate static final boolean REACTOR_PRESENT =\n\t\t\tClassUtils.isPresent(\"reactor.core.publisher.Mono\", HttpServiceMethod.class.getClassLoader());\n\n\n\tprivate final Method method;\n\n\tprivate final MethodParameter[] parameters;\n\n\tprivate final List<HttpServiceArgumentResolver> argumentResolvers;\n\n\tprivate final HttpRequestValuesInitializer requestValuesInitializer;\n\n\tprivate final ResponseFunction responseFunction;\n\n\n\tHttpServiceMethod(\n\t\t\tMethod method, Class<?> containingClass, List<HttpServiceArgumentResolver> argumentResolvers,\n\t\t\tHttpExchangeAdapter adapter, @Nullable StringValueResolver embeddedValueResolver) {\n\n\t\tthis.method = method;\n\t\tthis.parameters = initMethodParameters(method);\n\t\tthis.argumentResolvers = argumentResolvers;\n\n\t\tboolean isReactorAdapter = (REACTOR_PRESENT && adapter instanceof ReactorHttpExchangeAdapter);\n\n\t\tthis.requestValuesInitializer =\n\t\t\t\tHttpRequestValuesInitializer.create(\n\t\t\t\t\t\tmethod, containingClass, embeddedValueResolver,\n\t\t\t\t\t\t(isReactorAdapter ? ReactiveHttpRequestValues::builder : HttpRequestValues::builder));\n\n\t\tthis.responseFunction = (isReactorAdapter ?\n\t\t\t\tReactorExchangeResponseFunction.create((ReactorHttpExchangeAdapter) adapter, method) :\n\t\t\t\tExchangeResponseFunction.create(adapter, method));\n\t}\n\n\tprivate static MethodParameter[] initMethodParameters(Method method) {\n\t\tint count = method.getParameterCount();\n\t\tif (count == 0) {\n\t\t\treturn new MethodParameter[0];\n\t\t}\n\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\tcount -= 1;\n\t\t}\n\n\t\tDefaultParameterNameDiscoverer nameDiscoverer = new DefaultParameterNameDiscoverer();\n\t\tMethodParameter[] parameters = new MethodParameter[count];\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tparameters[i] = new SynthesizingMethodParameter(method, i);\n\t\t\tparameters[i].initParameterNameDiscovery(nameDiscoverer);\n\t\t}\n\t\treturn parameters;\n\t}\n\n\n\tpublic Method getMethod() {\n\t\treturn this.method;\n\t}\n\n\n\t@Nullable\n\tpublic Object invoke(Object[] arguments) {\n\t\tHttpRequestValues.Builder requestValues = this.requestValuesInitializer.initializeRequestValuesBuilder();\n\t\tapplyArguments(requestValues, arguments);\n\t\treturn this.responseFunction.execute(requestValues.build());\n\t}\n\n\tprivate void applyArguments(HttpRequestValues.Builder requestValues, Object[] arguments) {\n\t\tAssert.isTrue(arguments.length == this.parameters.length, \"Method argument mismatch\");\n\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\tObject value = arguments[i];\n\t\t\tboolean resolved = false;\n\t\t\tfor (HttpServiceArgumentResolver resolver : this.argumentResolvers) {\n\t\t\t\tif (resolver.resolve(value, this.parameters[i], requestValues)) {\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint index = i;\n\t\t\tAssert.state(resolved, () ->\n\t\t\t\t\t\"Could not resolve parameter [\" + this.parameters[index].getParameterIndex() + \"] in \" +\n\t\t\t\t\t\t\tthis.parameters[index].getExecutable().toGenericString() + \": No suitable resolver\");\n\t\t}\n\t}\n\n\n\t/**\n\t * Factory for {@link HttpRequestValues} with values extracted from the type\n\t * and method-level {@link HttpExchange @HttpRequest} annotations.\n\t */\n\tprivate record HttpRequestValuesInitializer(\n\t\t\t@Nullable HttpMethod httpMethod, @Nullable String url,\n\t\t\t@Nullable MediaType contentType, @Nullable List<MediaType> acceptMediaTypes,\n\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier) {\n\n\t\tpublic HttpRequestValues.Builder initializeRequestValuesBuilder() {\n\t\t\tHttpRequestValues.Builder requestValues = this.requestValuesSupplier.get();\n\t\t\tif (this.httpMethod != null) {\n\t\t\t\trequestValues.setHttpMethod(this.httpMethod);\n\t\t\t}\n\t\t\tif (this.url != null) {\n\t\t\t\trequestValues.setUriTemplate(this.url);\n\t\t\t}\n\t\t\tif (this.contentType != null) {\n\t\t\t\trequestValues.setContentType(this.contentType);\n\t\t\t}\n\t\t\tif (this.acceptMediaTypes != null) {\n\t\t\t\trequestValues.setAccept(this.acceptMediaTypes);\n\t\t\t}\n\t\t\treturn requestValues;\n\t\t}\n\n\n\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */\n\t\tpublic static HttpRequestValuesInitializer create(\n\t\t\t\tMethod method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver,\n\t\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier) {\n\n\t\t\tHttpExchange typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(containingClass, HttpExchange.class);\n\t\t\tHttpExchange methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, HttpExchange.class);\n\n\t\t\tAssert.notNull(methodAnnotation, () -> \"Expected @HttpRequest annotation on method \" + method.toGenericString());\n\n\t\t\tHttpMethod httpMethod = initHttpMethod(typeAnnotation, methodAnnotation);\n\t\t\tString url = initUrl(typeAnnotation, methodAnnotation, embeddedValueResolver);\n\t\t\tMediaType contentType = initContentType(typeAnnotation, methodAnnotation);\n\t\t\tList<MediaType> acceptableMediaTypes = initAccept(typeAnnotation, methodAnnotation);\n\n\t\t\treturn new HttpRequestValuesInitializer(\n\t\t\t\t\thttpMethod, url, contentType, acceptableMediaTypes, requestValuesSupplier);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static HttpMethod initHttpMethod(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString methodLevelMethod = methodAnnotation.method();\n\t\t\tif (StringUtils.hasText(methodLevelMethod)) {\n\t\t\t\treturn HttpMethod.valueOf(methodLevelMethod);\n\t\t\t}\n\n\t\t\tString typeLevelMethod = (typeAnnotation != null ? typeAnnotation.method() : null);\n\t\t\tif (StringUtils.hasText(typeLevelMethod)) {\n\t\t\t\treturn HttpMethod.valueOf(typeLevelMethod);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static String initUrl(\n\t\t\t\t@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation,\n\t\t\t\t@Nullable StringValueResolver embeddedValueResolver) {\n\n\t\t\tString typeLevelUrl = (typeAnnotation != null ? typeAnnotation.url() : null);\n\t\t\tString methodLevelUrl = methodAnnotation.url();\n\n\t\t\tif (embeddedValueResolver != null) {\n\t\t\t\ttypeLevelUrl = (typeLevelUrl != null ? embeddedValueResolver.resolveStringValue(typeLevelUrl) : null);\n\t\t\t\tmethodLevelUrl = embeddedValueResolver.resolveStringValue(methodLevelUrl);\n\t\t\t}\n\n\t\t\tboolean hasTypeLevelUrl = StringUtils.hasText(typeLevelUrl);\n\t\t\tboolean hasMethodLevelUrl = StringUtils.hasText(methodLevelUrl);\n\n\t\t\tif (hasTypeLevelUrl && hasMethodLevelUrl) {\n\t\t\t\treturn (typeLevelUrl + (!typeLevelUrl.endsWith(\"/\") && !methodLevelUrl.startsWith(\"/\") ? \"/\" : \"\") + methodLevelUrl);\n\t\t\t}\n\n\t\t\tif (!hasTypeLevelUrl && !hasMethodLevelUrl) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn (hasMethodLevelUrl ? methodLevelUrl : typeLevelUrl);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static MediaType initContentType(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString methodLevelContentType = methodAnnotation.contentType();\n\t\t\tif (StringUtils.hasText(methodLevelContentType)) {\n\t\t\t\treturn MediaType.parseMediaType(methodLevelContentType);\n\t\t\t}\n\n\t\t\tString typeLevelContentType = (typeAnnotation != null ? typeAnnotation.contentType() : null);\n\t\t\tif (StringUtils.hasText(typeLevelContentType)) {\n\t\t\t\treturn MediaType.parseMediaType(typeLevelContentType);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static List<MediaType> initAccept(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString[] methodLevelAccept = methodAnnotation.accept();\n\t\t\tif (!ObjectUtils.isEmpty(methodLevelAccept)) {\n\t\t\t\treturn MediaType.parseMediaTypes(List.of(methodLevelAccept));\n\t\t\t}\n\n\t\t\tString[] typeLevelAccept = (typeAnnotation != null ? typeAnnotation.accept() : null);\n\t\t\tif (!ObjectUtils.isEmpty(typeLevelAccept)) {\n\t\t\t\treturn MediaType.parseMediaTypes(List.of(typeLevelAccept));\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * Execute a request, obtain a response, and adapt to the expected return type.\n\t */\n\tprivate interface ResponseFunction {\n\n\t\t@Nullable\n\t\tObject execute(HttpRequestValues requestValues);\n\n\t}\n\n\tprivate record ExchangeResponseFunction(\n\t\t\tFunction<HttpRequestValues, Object> responseFunction) implements ResponseFunction {\n\n\t\t@Override\n\t\tpublic Object execute(HttpRequestValues requestValues) {\n\t\t\treturn this.responseFunction.apply(requestValues);\n\t\t}\n\n\n\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */\n\t\tpublic static ResponseFunction create(HttpExchangeAdapter client, Method method) {\n\t\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Kotlin Coroutines are only supported with reactive implementations\");\n\t\t\t}\n\n\t\t\tMethodParameter param = new MethodParameter(method, -1).nestedIfOptional();\n\t\t\tClass<?> paramType = param.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Object> responseFunction;\n\t\t\tif (paramType.equals(void.class) || paramType.equals(Void.class)) {\n\t\t\t\tresponseFunction = requestValues -> {\n\t\t\t\t\tclient.exchange(requestValues);\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if (paramType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = request -> asOptionalIfNecessary(client.exchangeForHeaders(request), param);\n\t\t\t}\n\t\t\telse if (paramType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = param.nested();\n\t\t\t\tif (bodyParam.getNestedParameterType().equals(Void.class)) {\n\t\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForBodilessEntity(request), param);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tParameterizedTypeReference<?> bodyTypeRef =\n\t\t\t\t\t\t\tParameterizedTypeReference.forType(bodyParam.getNestedGenericParameterType());\n\t\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForEntity(request, bodyTypeRef), param);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tParameterizedTypeReference<?> bodyTypeRef =\n\t\t\t\t\t\tParameterizedTypeReference.forType(param.getNestedGenericParameterType());\n\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForBody(request, bodyTypeRef), param);\n\t\t\t}\n\n\t\t\treturn new ExchangeResponseFunction(responseFunction);\n\t\t}\n\n\t\tprivate static @Nullable Object asOptionalIfNecessary(@Nullable Object response, MethodParameter param) {\n\t\t\treturn param.getParameterType().equals(Optional.class) ? Optional.ofNullable(response) : response;\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link ResponseFunction} for {@link ReactorHttpExchangeAdapter}.\n\t */\n\tprivate record ReactorExchangeResponseFunction(\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction,\n\t\t\t@Nullable ReactiveAdapter returnTypeAdapter,\n\t\t\tboolean blockForOptional, @Nullable Duration blockTimeout) implements ResponseFunction {\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object execute(HttpRequestValues requestValues) {\n\n\t\t\tPublisher<?> responsePublisher = this.responseFunction.apply(requestValues);\n\n\t\t\tif (this.returnTypeAdapter != null) {\n\t\t\t\treturn this.returnTypeAdapter.fromPublisher(responsePublisher);\n\t\t\t}\n\n\t\t\tif (this.blockForOptional) {\n\t\t\t\treturn (this.blockTimeout != null ?\n\t\t\t\t\t\t((Mono<?>) responsePublisher).blockOptional(this.blockTimeout) :\n\t\t\t\t\t\t((Mono<?>) responsePublisher).blockOptional());\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (this.blockTimeout != null ?\n\t\t\t\t\t\t((Mono<?>) responsePublisher).block(this.blockTimeout) :\n\t\t\t\t\t\t((Mono<?>) responsePublisher).block());\n\t\t\t}\n\t\t}\n\n\n\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */\n\t\tpublic static ResponseFunction create(ReactorHttpExchangeAdapter client, Method method) {\n\t\t\tMethodParameter returnParam = new MethodParameter(method, -1);\n\t\t\tClass<?> returnType = returnParam.getParameterType();\n\t\t\tboolean isSuspending = KotlinDetector.isSuspendingFunction(method);\n\t\t\tif (isSuspending) {\n\t\t\t\treturnType = Mono.class;\n\t\t\t}\n\n\t\t\tReactiveAdapter reactiveAdapter = client.getReactiveAdapterRegistry().getAdapter(returnType);\n\n\t\t\tMethodParameter actualParam = (reactiveAdapter != null ? returnParam.nested() : returnParam.nestedIfOptional());\n\t\t\tClass<?> actualType = isSuspending ? actualParam.getParameterType() : actualParam.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction;\n\t\t\tif (actualType.equals(void.class) || actualType.equals(Void.class)) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (reactiveAdapter != null && reactiveAdapter.isNoValue()) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = client::exchangeForHeadersMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = isSuspending ? actualParam : actualParam.nested();\n\t\t\t\tClass<?> bodyType = bodyParam.getNestedParameterType();\n\t\t\t\tif (bodyType.equals(Void.class)) {\n\t\t\t\t\tresponseFunction = client::exchangeForBodilessEntityMono;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReactiveAdapter bodyAdapter = client.getReactiveAdapterRegistry().getAdapter(bodyType);\n\t\t\t\t\tresponseFunction = initResponseEntityFunction(client, bodyParam, bodyAdapter, isSuspending);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponseFunction = initBodyFunction(client, actualParam, reactiveAdapter, isSuspending);\n\t\t\t}\n\n\t\t\treturn new ReactorExchangeResponseFunction(\n\t\t\t\t\tresponseFunction, reactiveAdapter, returnType.equals(Optional.class), client.getBlockTimeout());\n\t\t}\n\n\t\t@SuppressWarnings(\"ConstantConditions\")\n\t\tprivate static Function<HttpRequestValues, Publisher<?>> initResponseEntityFunction(\n\t\t\t\tReactorHttpExchangeAdapter client, MethodParameter methodParam,\n\t\t\t\t@Nullable ReactiveAdapter reactiveAdapter, boolean isSuspending) {\n\n\t\t\tif (reactiveAdapter == null) {\n\t\t\t\treturn request -> client.exchangeForEntityMono(\n\t\t\t\t\t\trequest, ParameterizedTypeReference.forType(methodParam.getNestedGenericParameterType()));\n\t\t\t}\n\n\t\t\tAssert.isTrue(reactiveAdapter.isMultiValue(),\n\t\t\t\t\t\"ResponseEntity body must be a concrete value or a multi-value Publisher\");\n\n\t\t\tParameterizedTypeReference<?> bodyType =\n\t\t\t\t\tParameterizedTypeReference.forType(isSuspending ? methodParam.nested().getGenericParameterType() :\n\t\t\t\t\t\t\tmethodParam.nested().getNestedGenericParameterType());\n\n\t\t\t// Shortcut for Flux\n\t\t\tif (reactiveAdapter.getReactiveType().equals(Flux.class)) {\n\t\t\t\treturn request -> client.exchangeForEntityFlux(request, bodyType);\n\t\t\t}\n\n\t\t\treturn request -> client.exchangeForEntityFlux(request, bodyType)\n\t\t\t\t\t.map(entity -> {\n\t\t\t\t\t\tObject body = reactiveAdapter.fromPublisher(entity.getBody());\n\t\t\t\t\t\treturn new ResponseEntity<>(body, entity.getHeaders(), entity.getStatusCode());\n\t\t\t\t\t});\n\t\t}\n\n\t\tprivate static Function<HttpRequestValues, Publisher<?>> initBodyFunction(\n\t\t\t\tReactorHttpExchangeAdapter client, MethodParameter methodParam,\n\t\t\t\t@Nullable ReactiveAdapter reactiveAdapter, boolean isSuspending) {\n\n\t\t\tParameterizedTypeReference<?> bodyType =\n\t\t\t\t\tParameterizedTypeReference.forType(isSuspending ? methodParam.getGenericParameterType() :\n\t\t\t\t\t\t\tmethodParam.getNestedGenericParameterType());\n\n\t\t\treturn (reactiveAdapter != null && reactiveAdapter.isMultiValue() ?\n\t\t\t\t\trequest -> client.exchangeForBodyFlux(request, bodyType) :\n\t\t\t\t\trequest -> client.exchangeForBodyMono(request, bodyType));\n\t\t}\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 3,
                "candidates": [
                    {
                        "lineStart": 368,
                        "lineEnd": 411,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method create to class HttpServiceMethod",
                        "description": "move method to org.springframework.web.service.invoker.HttpServiceMethod\nRationale: This method is heavily involved in processing HTTP service method exchanges, arranging responses, and working with reactive programming components. As such, it would be a good fit for the 'HttpServiceMethod' class, where it can more directly access and manipulate the details of service methods and their associated exchanges.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 119,
                        "lineEnd": 124,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method invoke to class ResponseFunction",
                        "description": "Move method to org.springframework.web.service.invoker.HttpServiceMethod.ResponseFunction\nRationale: The method invokes the 'execute' function of 'this.responseFunction', which implies that it is tightly coupled with the functionality of the 'ResponseFunction' class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 95,
                        "lineEnd": 111,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method initMethodParameters to class HttpMethodArgumentResolver",
                        "description": "move method to org.springframework.web.service.invoker.HttpMethodArgumentResolver\nRationale: This method is involved in the handling and processing of Method instances, it is suspected to do some argument resolution as well - which would be the key responsibility of a class like 'HttpMethodArgumentResolver'.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [],
                    "llm_response_time": 2834
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "invoke",
                            "method_signature": "public Object invoke(Object[] arguments): Object",
                            "target_class": "HttpClient",
                            "rationale": "The 'invoke' method is making HTTP exchange which is better to be in HttpClient class as a part of the external service communication."
                        },
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static MethodParameter[] initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "ReflectionUtils",
                            "rationale": "The 'initMethodParameters' method is purely related to reflection and parameter extraction which is better suited in a utility class such as ReflectionUtils."
                        }
                    ],
                    "llm_response_time": 7625
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "MethodInitialization",
                            "rationale": "initMethodParameters() is a utility method that focuses on initializing method parameters. It does not handle any HTTP Service specific procedures and is more related to general method initialization, so it could be moved to a 'MethodInitialization' utility class."
                        },
                        {
                            "method_name": "create",
                            "method_signature": "public static create(HttpExchangeAdapter client, Method method): ResponseFunction",
                            "target_class": "ResponseFunctionFactory",
                            "rationale": "create() method is used to create instances of 'ResponseFunction' according to the method return type. This method essentially performs the role of a factory for creating 'ResponseFunction' instances, so it would make sense to move it to a dedicated factory class, 'ResponseFunctionFactory'."
                        }
                    ],
                    "llm_response_time": 18512
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "invoke",
                            "method_signature": "public Object invoke(Object[] arguments): Object",
                            "target_class": "HttpClient",
                            "rationale": "The 'invoke' method is making HTTP exchange which is better to be in HttpClient class as a part of the external service communication."
                        },
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static MethodParameter[] initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "ReflectionUtils",
                            "rationale": "The 'initMethodParameters' method is purely related to reflection and parameter extraction which is better suited in a utility class such as ReflectionUtils."
                        },
                        {
                            "method_name": "create",
                            "method_signature": "public static create(HttpExchangeAdapter client, Method method): ResponseFunction",
                            "target_class": "ResponseFunctionFactory",
                            "rationale": "create() method is used to create instances of 'ResponseFunction' according to the method return type. This method essentially performs the role of a factory for creating 'ResponseFunction' instances, so it would make sense to move it to a dedicated factory class, 'ResponseFunctionFactory'."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "create",
                    "invoke",
                    "initMethodParameters"
                ],
                "llm_response_time": 4151
            },
            "targetClassMap": {
                "create": {
                    "target_classes": [
                        {
                            "class_name": "HttpServiceMethod",
                            "similarity_score": 0.8426924708817681
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HttpServiceMethod"
                    ],
                    "llm_response_time": 4717,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "invoke": {
                    "target_classes": [
                        {
                            "class_name": "ResponseFunction",
                            "similarity_score": 0.24845199749997662
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ResponseFunction"
                    ],
                    "llm_response_time": 3715,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "initMethodParameters": {
                    "target_classes": [
                        {
                            "class_name": "HttpClientAdapter",
                            "similarity_score": 0.16335892281539527
                        },
                        {
                            "class_name": "HttpRequestValues",
                            "similarity_score": 0.43755735048290084
                        },
                        {
                            "class_name": "HttpExchangeAdapter",
                            "similarity_score": 0.025823475817683298
                        },
                        {
                            "class_name": "UrlArgumentResolver",
                            "similarity_score": 0.34464735255878187
                        },
                        {
                            "class_name": "HttpServiceProxyFactory",
                            "similarity_score": 0.4152750858686238
                        },
                        {
                            "class_name": "ReactiveHttpRequestValues",
                            "similarity_score": 0.4023666452760909
                        },
                        {
                            "class_name": "HttpMethodArgumentResolver",
                            "similarity_score": 0.3745371356605301
                        },
                        {
                            "class_name": "ReactorHttpExchangeAdapter",
                            "similarity_score": 0.023074792438534632
                        },
                        {
                            "class_name": "CookieValueArgumentResolver",
                            "similarity_score": 0.1342464417333466
                        },
                        {
                            "class_name": "HttpServiceArgumentResolver",
                            "similarity_score": 0.062365251721675424
                        },
                        {
                            "class_name": "RequestBodyArgumentResolver",
                            "similarity_score": 0.5677222062762607
                        },
                        {
                            "class_name": "RequestPartArgumentResolver",
                            "similarity_score": 0.5527201115750559
                        },
                        {
                            "class_name": "PathVariableArgumentResolver",
                            "similarity_score": 0.1701983272637592
                        },
                        {
                            "class_name": "RequestParamArgumentResolver",
                            "similarity_score": 0.12152698052680239
                        },
                        {
                            "class_name": "RequestHeaderArgumentResolver",
                            "similarity_score": 0.13034228089960004
                        },
                        {
                            "class_name": "RequestAttributeArgumentResolver",
                            "similarity_score": 0.16523456360801006
                        },
                        {
                            "class_name": "UriBuilderFactoryArgumentResolver",
                            "similarity_score": 0.20838949718155603
                        },
                        {
                            "class_name": "AbstractNamedValueArgumentResolver",
                            "similarity_score": 0.5237768448548211
                        },
                        {
                            "class_name": "AbstractReactorHttpExchangeAdapter",
                            "similarity_score": 0.42686638447117015
                        },
                        {
                            "class_name": "HttpServiceProxyFactoryExtensionsKt",
                            "similarity_score": 0.02825752575780252
                        },
                        {
                            "class_name": "HttpServiceProxyFactoryExtensionsKt",
                            "similarity_score": 0.02825752575780252
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HttpMethodArgumentResolver",
                        "RequestParamArgumentResolver",
                        "RequestBodyArgumentResolver",
                        "RequestPartArgumentResolver",
                        "AbstractNamedValueArgumentResolver",
                        "HttpRequestValues",
                        "AbstractReactorHttpExchangeAdapter",
                        "HttpServiceProxyFactory",
                        "ReactiveHttpRequestValues",
                        "UrlArgumentResolver",
                        "UriBuilderFactoryArgumentResolver",
                        "PathVariableArgumentResolver",
                        "RequestAttributeArgumentResolver",
                        "HttpClientAdapter",
                        "CookieValueArgumentResolver",
                        "RequestHeaderArgumentResolver",
                        "HttpServiceArgumentResolver",
                        "HttpServiceProxyFactoryExtensionsKt",
                        "HttpExchangeAdapter",
                        "ReactorHttpExchangeAdapter"
                    ],
                    "llm_response_time": 9513,
                    "similarity_computation_time": 43,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "6691ff207244ef46cdf18e16df17f3cd19c9ce2a",
        "url": "https://github.com/spring-projects/spring-framework/commit/6691ff207244ef46cdf18e16df17f3cd19c9ce2a",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private initContentType(typeAnnotation HttpExchange, methodAnnotation HttpExchange) : MediaType from class org.springframework.web.service.invoker.HttpServiceMethod to private initContentType(typeAnnotation HttpExchange, methodAnnotation HttpExchange) : MediaType from class org.springframework.web.service.invoker.HttpServiceMethod.HttpRequestValuesInitializer",
            "leftSideLocations": [
                {
                    "filePath": "spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                    "startLine": 236,
                    "endLine": 249,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private initContentType(typeAnnotation HttpExchange, methodAnnotation HttpExchange) : MediaType"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                    "startLine": 252,
                    "endLine": 265,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "private initContentType(typeAnnotation HttpExchange, methodAnnotation HttpExchange) : MediaType"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "39b832f2-1963-4f2b-83f1-753016cc85b4",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 409,
                "lineStart": 49,
                "lineEnd": 457,
                "bodyLineStart": 49,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                "sourceCode": "/**\n * Implements the invocation of an {@link HttpExchange @HttpExchange}-annotated,\n * {@link HttpServiceProxyFactory#createClient(Class) HTTP service proxy} method\n * by delegating to an {@link HttpExchangeAdapter} to perform actual requests.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @author Olga Maciaszek-Sharma\n * @since 6.0\n */\nfinal class HttpServiceMethod {\n\n\tprivate static final boolean REACTOR_PRESENT =\n\t\t\tClassUtils.isPresent(\"reactor.core.publisher.Mono\", HttpServiceMethod.class.getClassLoader());\n\n\n\tprivate final Method method;\n\n\tprivate final MethodParameter[] parameters;\n\n\tprivate final List<HttpServiceArgumentResolver> argumentResolvers;\n\n\tprivate final HttpRequestValuesInitializer requestValuesInitializer;\n\n\tprivate final ResponseFunction responseFunction;\n\n\n\tHttpServiceMethod(\n\t\t\tMethod method, Class<?> containingClass, List<HttpServiceArgumentResolver> argumentResolvers,\n\t\t\tHttpExchangeAdapter adapter, @Nullable StringValueResolver embeddedValueResolver) {\n\n\t\tthis.method = method;\n\t\tthis.parameters = initMethodParameters(method);\n\t\tthis.argumentResolvers = argumentResolvers;\n\n\t\tboolean isReactorAdapter = (REACTOR_PRESENT && adapter instanceof ReactorHttpExchangeAdapter);\n\n\t\tthis.requestValuesInitializer =\n\t\t\t\tHttpRequestValuesInitializer.create(\n\t\t\t\t\t\tmethod, containingClass, embeddedValueResolver,\n\t\t\t\t\t\t(isReactorAdapter ? ReactiveHttpRequestValues::builder : HttpRequestValues::builder));\n\n\t\tthis.responseFunction = (isReactorAdapter ?\n\t\t\t\tReactorExchangeResponseFunction.create((ReactorHttpExchangeAdapter) adapter, method) :\n\t\t\t\tExchangeResponseFunction.create(adapter, method));\n\t}\n\n\tprivate static MethodParameter[] initMethodParameters(Method method) {\n\t\tint count = method.getParameterCount();\n\t\tif (count == 0) {\n\t\t\treturn new MethodParameter[0];\n\t\t}\n\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\tcount -= 1;\n\t\t}\n\n\t\tDefaultParameterNameDiscoverer nameDiscoverer = new DefaultParameterNameDiscoverer();\n\t\tMethodParameter[] parameters = new MethodParameter[count];\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tparameters[i] = new SynthesizingMethodParameter(method, i);\n\t\t\tparameters[i].initParameterNameDiscovery(nameDiscoverer);\n\t\t}\n\t\treturn parameters;\n\t}\n\n\n\tpublic Method getMethod() {\n\t\treturn this.method;\n\t}\n\n\n\t@Nullable\n\tpublic Object invoke(Object[] arguments) {\n\t\tHttpRequestValues.Builder requestValues = this.requestValuesInitializer.initializeRequestValuesBuilder();\n\t\tapplyArguments(requestValues, arguments);\n\t\treturn this.responseFunction.execute(requestValues.build());\n\t}\n\n\tprivate void applyArguments(HttpRequestValues.Builder requestValues, Object[] arguments) {\n\t\tAssert.isTrue(arguments.length == this.parameters.length, \"Method argument mismatch\");\n\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\tObject value = arguments[i];\n\t\t\tboolean resolved = false;\n\t\t\tfor (HttpServiceArgumentResolver resolver : this.argumentResolvers) {\n\t\t\t\tif (resolver.resolve(value, this.parameters[i], requestValues)) {\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint index = i;\n\t\t\tAssert.state(resolved, () ->\n\t\t\t\t\t\"Could not resolve parameter [\" + this.parameters[index].getParameterIndex() + \"] in \" +\n\t\t\t\t\t\t\tthis.parameters[index].getExecutable().toGenericString() + \": No suitable resolver\");\n\t\t}\n\t}\n\n\n\t/**\n\t * Factory for {@link HttpRequestValues} with values extracted from the type\n\t * and method-level {@link HttpExchange @HttpRequest} annotations.\n\t */\n\tprivate record HttpRequestValuesInitializer(\n\t\t\t@Nullable HttpMethod httpMethod, @Nullable String url,\n\t\t\t@Nullable MediaType contentType, @Nullable List<MediaType> acceptMediaTypes,\n\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier) {\n\n\t\tpublic HttpRequestValues.Builder initializeRequestValuesBuilder() {\n\t\t\tHttpRequestValues.Builder requestValues = this.requestValuesSupplier.get();\n\t\t\tif (this.httpMethod != null) {\n\t\t\t\trequestValues.setHttpMethod(this.httpMethod);\n\t\t\t}\n\t\t\tif (this.url != null) {\n\t\t\t\trequestValues.setUriTemplate(this.url);\n\t\t\t}\n\t\t\tif (this.contentType != null) {\n\t\t\t\trequestValues.setContentType(this.contentType);\n\t\t\t}\n\t\t\tif (this.acceptMediaTypes != null) {\n\t\t\t\trequestValues.setAccept(this.acceptMediaTypes);\n\t\t\t}\n\t\t\treturn requestValues;\n\t\t}\n\n\n\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */\n\t\tpublic static HttpRequestValuesInitializer create(\n\t\t\t\tMethod method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver,\n\t\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier) {\n\n\t\t\tHttpExchange typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(containingClass, HttpExchange.class);\n\t\t\tHttpExchange methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, HttpExchange.class);\n\n\t\t\tAssert.notNull(methodAnnotation, () -> \"Expected @HttpRequest annotation on method \" + method.toGenericString());\n\n\t\t\tHttpMethod httpMethod = initHttpMethod(typeAnnotation, methodAnnotation);\n\t\t\tString url = initUrl(typeAnnotation, methodAnnotation, embeddedValueResolver);\n\t\t\tMediaType contentType = initContentType(typeAnnotation, methodAnnotation);\n\t\t\tList<MediaType> acceptableMediaTypes = initAccept(typeAnnotation, methodAnnotation);\n\n\t\t\treturn new HttpRequestValuesInitializer(\n\t\t\t\t\thttpMethod, url, contentType, acceptableMediaTypes, requestValuesSupplier);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static HttpMethod initHttpMethod(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString methodLevelMethod = methodAnnotation.method();\n\t\t\tif (StringUtils.hasText(methodLevelMethod)) {\n\t\t\t\treturn HttpMethod.valueOf(methodLevelMethod);\n\t\t\t}\n\n\t\t\tString typeLevelMethod = (typeAnnotation != null ? typeAnnotation.method() : null);\n\t\t\tif (StringUtils.hasText(typeLevelMethod)) {\n\t\t\t\treturn HttpMethod.valueOf(typeLevelMethod);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static String initUrl(\n\t\t\t\t@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation,\n\t\t\t\t@Nullable StringValueResolver embeddedValueResolver) {\n\n\t\t\tString typeLevelUrl = (typeAnnotation != null ? typeAnnotation.url() : null);\n\t\t\tString methodLevelUrl = methodAnnotation.url();\n\n\t\t\tif (embeddedValueResolver != null) {\n\t\t\t\ttypeLevelUrl = (typeLevelUrl != null ? embeddedValueResolver.resolveStringValue(typeLevelUrl) : null);\n\t\t\t\tmethodLevelUrl = embeddedValueResolver.resolveStringValue(methodLevelUrl);\n\t\t\t}\n\n\t\t\tboolean hasTypeLevelUrl = StringUtils.hasText(typeLevelUrl);\n\t\t\tboolean hasMethodLevelUrl = StringUtils.hasText(methodLevelUrl);\n\n\t\t\tif (hasTypeLevelUrl && hasMethodLevelUrl) {\n\t\t\t\treturn (typeLevelUrl + (!typeLevelUrl.endsWith(\"/\") && !methodLevelUrl.startsWith(\"/\") ? \"/\" : \"\") + methodLevelUrl);\n\t\t\t}\n\n\t\t\tif (!hasTypeLevelUrl && !hasMethodLevelUrl) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn (hasMethodLevelUrl ? methodLevelUrl : typeLevelUrl);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static MediaType initContentType(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString methodLevelContentType = methodAnnotation.contentType();\n\t\t\tif (StringUtils.hasText(methodLevelContentType)) {\n\t\t\t\treturn MediaType.parseMediaType(methodLevelContentType);\n\t\t\t}\n\n\t\t\tString typeLevelContentType = (typeAnnotation != null ? typeAnnotation.contentType() : null);\n\t\t\tif (StringUtils.hasText(typeLevelContentType)) {\n\t\t\t\treturn MediaType.parseMediaType(typeLevelContentType);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static List<MediaType> initAccept(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString[] methodLevelAccept = methodAnnotation.accept();\n\t\t\tif (!ObjectUtils.isEmpty(methodLevelAccept)) {\n\t\t\t\treturn MediaType.parseMediaTypes(List.of(methodLevelAccept));\n\t\t\t}\n\n\t\t\tString[] typeLevelAccept = (typeAnnotation != null ? typeAnnotation.accept() : null);\n\t\t\tif (!ObjectUtils.isEmpty(typeLevelAccept)) {\n\t\t\t\treturn MediaType.parseMediaTypes(List.of(typeLevelAccept));\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * Execute a request, obtain a response, and adapt to the expected return type.\n\t */\n\tprivate interface ResponseFunction {\n\n\t\t@Nullable\n\t\tObject execute(HttpRequestValues requestValues);\n\n\t}\n\n\tprivate record ExchangeResponseFunction(\n\t\t\tFunction<HttpRequestValues, Object> responseFunction) implements ResponseFunction {\n\n\t\t@Override\n\t\tpublic Object execute(HttpRequestValues requestValues) {\n\t\t\treturn this.responseFunction.apply(requestValues);\n\t\t}\n\n\n\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */\n\t\tpublic static ResponseFunction create(HttpExchangeAdapter client, Method method) {\n\t\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Kotlin Coroutines are only supported with reactive implementations\");\n\t\t\t}\n\n\t\t\tMethodParameter param = new MethodParameter(method, -1).nestedIfOptional();\n\t\t\tClass<?> paramType = param.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Object> responseFunction;\n\t\t\tif (paramType.equals(void.class) || paramType.equals(Void.class)) {\n\t\t\t\tresponseFunction = requestValues -> {\n\t\t\t\t\tclient.exchange(requestValues);\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if (paramType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = request -> asOptionalIfNecessary(client.exchangeForHeaders(request), param);\n\t\t\t}\n\t\t\telse if (paramType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = param.nested();\n\t\t\t\tif (bodyParam.getNestedParameterType().equals(Void.class)) {\n\t\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForBodilessEntity(request), param);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tParameterizedTypeReference<?> bodyTypeRef =\n\t\t\t\t\t\t\tParameterizedTypeReference.forType(bodyParam.getNestedGenericParameterType());\n\t\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForEntity(request, bodyTypeRef), param);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tParameterizedTypeReference<?> bodyTypeRef =\n\t\t\t\t\t\tParameterizedTypeReference.forType(param.getNestedGenericParameterType());\n\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForBody(request, bodyTypeRef), param);\n\t\t\t}\n\n\t\t\treturn new ExchangeResponseFunction(responseFunction);\n\t\t}\n\n\t\tprivate static @Nullable Object asOptionalIfNecessary(@Nullable Object response, MethodParameter param) {\n\t\t\treturn param.getParameterType().equals(Optional.class) ? Optional.ofNullable(response) : response;\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link ResponseFunction} for {@link ReactorHttpExchangeAdapter}.\n\t */\n\tprivate record ReactorExchangeResponseFunction(\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction,\n\t\t\t@Nullable ReactiveAdapter returnTypeAdapter,\n\t\t\tboolean blockForOptional, @Nullable Duration blockTimeout) implements ResponseFunction {\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object execute(HttpRequestValues requestValues) {\n\n\t\t\tPublisher<?> responsePublisher = this.responseFunction.apply(requestValues);\n\n\t\t\tif (this.returnTypeAdapter != null) {\n\t\t\t\treturn this.returnTypeAdapter.fromPublisher(responsePublisher);\n\t\t\t}\n\n\t\t\tif (this.blockForOptional) {\n\t\t\t\treturn (this.blockTimeout != null ?\n\t\t\t\t\t\t((Mono<?>) responsePublisher).blockOptional(this.blockTimeout) :\n\t\t\t\t\t\t((Mono<?>) responsePublisher).blockOptional());\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (this.blockTimeout != null ?\n\t\t\t\t\t\t((Mono<?>) responsePublisher).block(this.blockTimeout) :\n\t\t\t\t\t\t((Mono<?>) responsePublisher).block());\n\t\t\t}\n\t\t}\n\n\n\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */\n\t\tpublic static ResponseFunction create(ReactorHttpExchangeAdapter client, Method method) {\n\t\t\tMethodParameter returnParam = new MethodParameter(method, -1);\n\t\t\tClass<?> returnType = returnParam.getParameterType();\n\t\t\tboolean isSuspending = KotlinDetector.isSuspendingFunction(method);\n\t\t\tif (isSuspending) {\n\t\t\t\treturnType = Mono.class;\n\t\t\t}\n\n\t\t\tReactiveAdapter reactiveAdapter = client.getReactiveAdapterRegistry().getAdapter(returnType);\n\n\t\t\tMethodParameter actualParam = (reactiveAdapter != null ? returnParam.nested() : returnParam.nestedIfOptional());\n\t\t\tClass<?> actualType = isSuspending ? actualParam.getParameterType() : actualParam.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction;\n\t\t\tif (actualType.equals(void.class) || actualType.equals(Void.class)) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (reactiveAdapter != null && reactiveAdapter.isNoValue()) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = client::exchangeForHeadersMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = isSuspending ? actualParam : actualParam.nested();\n\t\t\t\tClass<?> bodyType = bodyParam.getNestedParameterType();\n\t\t\t\tif (bodyType.equals(Void.class)) {\n\t\t\t\t\tresponseFunction = client::exchangeForBodilessEntityMono;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReactiveAdapter bodyAdapter = client.getReactiveAdapterRegistry().getAdapter(bodyType);\n\t\t\t\t\tresponseFunction = initResponseEntityFunction(client, bodyParam, bodyAdapter, isSuspending);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponseFunction = initBodyFunction(client, actualParam, reactiveAdapter, isSuspending);\n\t\t\t}\n\n\t\t\treturn new ReactorExchangeResponseFunction(\n\t\t\t\t\tresponseFunction, reactiveAdapter, returnType.equals(Optional.class), client.getBlockTimeout());\n\t\t}\n\n\t\t@SuppressWarnings(\"ConstantConditions\")\n\t\tprivate static Function<HttpRequestValues, Publisher<?>> initResponseEntityFunction(\n\t\t\t\tReactorHttpExchangeAdapter client, MethodParameter methodParam,\n\t\t\t\t@Nullable ReactiveAdapter reactiveAdapter, boolean isSuspending) {\n\n\t\t\tif (reactiveAdapter == null) {\n\t\t\t\treturn request -> client.exchangeForEntityMono(\n\t\t\t\t\t\trequest, ParameterizedTypeReference.forType(methodParam.getNestedGenericParameterType()));\n\t\t\t}\n\n\t\t\tAssert.isTrue(reactiveAdapter.isMultiValue(),\n\t\t\t\t\t\"ResponseEntity body must be a concrete value or a multi-value Publisher\");\n\n\t\t\tParameterizedTypeReference<?> bodyType =\n\t\t\t\t\tParameterizedTypeReference.forType(isSuspending ? methodParam.nested().getGenericParameterType() :\n\t\t\t\t\t\t\tmethodParam.nested().getNestedGenericParameterType());\n\n\t\t\t// Shortcut for Flux\n\t\t\tif (reactiveAdapter.getReactiveType().equals(Flux.class)) {\n\t\t\t\treturn request -> client.exchangeForEntityFlux(request, bodyType);\n\t\t\t}\n\n\t\t\treturn request -> client.exchangeForEntityFlux(request, bodyType)\n\t\t\t\t\t.map(entity -> {\n\t\t\t\t\t\tObject body = reactiveAdapter.fromPublisher(entity.getBody());\n\t\t\t\t\t\treturn new ResponseEntity<>(body, entity.getHeaders(), entity.getStatusCode());\n\t\t\t\t\t});\n\t\t}\n\n\t\tprivate static Function<HttpRequestValues, Publisher<?>> initBodyFunction(\n\t\t\t\tReactorHttpExchangeAdapter client, MethodParameter methodParam,\n\t\t\t\t@Nullable ReactiveAdapter reactiveAdapter, boolean isSuspending) {\n\n\t\t\tParameterizedTypeReference<?> bodyType =\n\t\t\t\t\tParameterizedTypeReference.forType(isSuspending ? methodParam.getGenericParameterType() :\n\t\t\t\t\t\t\tmethodParam.getNestedGenericParameterType());\n\n\t\t\treturn (reactiveAdapter != null && reactiveAdapter.isMultiValue() ?\n\t\t\t\t\trequest -> client.exchangeForBodyFlux(request, bodyType) :\n\t\t\t\t\trequest -> client.exchangeForBodyMono(request, bodyType));\n\t\t}\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 3,
                "candidates": [
                    {
                        "lineStart": 368,
                        "lineEnd": 411,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method create to class HttpServiceMethod",
                        "description": "move method to org.springframework.web.service.invoker.HttpServiceMethod\nRationale: This method is heavily involved in processing HTTP service method exchanges, arranging responses, and working with reactive programming components. As such, it would be a good fit for the 'HttpServiceMethod' class, where it can more directly access and manipulate the details of service methods and their associated exchanges.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 119,
                        "lineEnd": 124,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method invoke to class ResponseFunction",
                        "description": "Move method to org.springframework.web.service.invoker.HttpServiceMethod.ResponseFunction\nRationale: The method invokes the 'execute' function of 'this.responseFunction', which implies that it is tightly coupled with the functionality of the 'ResponseFunction' class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 95,
                        "lineEnd": 111,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method initMethodParameters to class HttpMethodArgumentResolver",
                        "description": "move method to org.springframework.web.service.invoker.HttpMethodArgumentResolver\nRationale: This method is involved in the handling and processing of Method instances, it is suspected to do some argument resolution as well - which would be the key responsibility of a class like 'HttpMethodArgumentResolver'.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [],
                    "llm_response_time": 2834
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "invoke",
                            "method_signature": "public Object invoke(Object[] arguments): Object",
                            "target_class": "HttpClient",
                            "rationale": "The 'invoke' method is making HTTP exchange which is better to be in HttpClient class as a part of the external service communication."
                        },
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static MethodParameter[] initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "ReflectionUtils",
                            "rationale": "The 'initMethodParameters' method is purely related to reflection and parameter extraction which is better suited in a utility class such as ReflectionUtils."
                        }
                    ],
                    "llm_response_time": 7625
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "MethodInitialization",
                            "rationale": "initMethodParameters() is a utility method that focuses on initializing method parameters. It does not handle any HTTP Service specific procedures and is more related to general method initialization, so it could be moved to a 'MethodInitialization' utility class."
                        },
                        {
                            "method_name": "create",
                            "method_signature": "public static create(HttpExchangeAdapter client, Method method): ResponseFunction",
                            "target_class": "ResponseFunctionFactory",
                            "rationale": "create() method is used to create instances of 'ResponseFunction' according to the method return type. This method essentially performs the role of a factory for creating 'ResponseFunction' instances, so it would make sense to move it to a dedicated factory class, 'ResponseFunctionFactory'."
                        }
                    ],
                    "llm_response_time": 18512
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "invoke",
                            "method_signature": "public Object invoke(Object[] arguments): Object",
                            "target_class": "HttpClient",
                            "rationale": "The 'invoke' method is making HTTP exchange which is better to be in HttpClient class as a part of the external service communication."
                        },
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static MethodParameter[] initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "ReflectionUtils",
                            "rationale": "The 'initMethodParameters' method is purely related to reflection and parameter extraction which is better suited in a utility class such as ReflectionUtils."
                        },
                        {
                            "method_name": "create",
                            "method_signature": "public static create(HttpExchangeAdapter client, Method method): ResponseFunction",
                            "target_class": "ResponseFunctionFactory",
                            "rationale": "create() method is used to create instances of 'ResponseFunction' according to the method return type. This method essentially performs the role of a factory for creating 'ResponseFunction' instances, so it would make sense to move it to a dedicated factory class, 'ResponseFunctionFactory'."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "create",
                    "invoke",
                    "initMethodParameters"
                ],
                "llm_response_time": 4151
            },
            "targetClassMap": {
                "create": {
                    "target_classes": [
                        {
                            "class_name": "HttpServiceMethod",
                            "similarity_score": 0.8426924708817681
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HttpServiceMethod"
                    ],
                    "llm_response_time": 4717,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "invoke": {
                    "target_classes": [
                        {
                            "class_name": "ResponseFunction",
                            "similarity_score": 0.24845199749997662
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ResponseFunction"
                    ],
                    "llm_response_time": 3715,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "initMethodParameters": {
                    "target_classes": [
                        {
                            "class_name": "HttpClientAdapter",
                            "similarity_score": 0.16335892281539527
                        },
                        {
                            "class_name": "HttpRequestValues",
                            "similarity_score": 0.43755735048290084
                        },
                        {
                            "class_name": "HttpExchangeAdapter",
                            "similarity_score": 0.025823475817683298
                        },
                        {
                            "class_name": "UrlArgumentResolver",
                            "similarity_score": 0.34464735255878187
                        },
                        {
                            "class_name": "HttpServiceProxyFactory",
                            "similarity_score": 0.4152750858686238
                        },
                        {
                            "class_name": "ReactiveHttpRequestValues",
                            "similarity_score": 0.4023666452760909
                        },
                        {
                            "class_name": "HttpMethodArgumentResolver",
                            "similarity_score": 0.3745371356605301
                        },
                        {
                            "class_name": "ReactorHttpExchangeAdapter",
                            "similarity_score": 0.023074792438534632
                        },
                        {
                            "class_name": "CookieValueArgumentResolver",
                            "similarity_score": 0.1342464417333466
                        },
                        {
                            "class_name": "HttpServiceArgumentResolver",
                            "similarity_score": 0.062365251721675424
                        },
                        {
                            "class_name": "RequestBodyArgumentResolver",
                            "similarity_score": 0.5677222062762607
                        },
                        {
                            "class_name": "RequestPartArgumentResolver",
                            "similarity_score": 0.5527201115750559
                        },
                        {
                            "class_name": "PathVariableArgumentResolver",
                            "similarity_score": 0.1701983272637592
                        },
                        {
                            "class_name": "RequestParamArgumentResolver",
                            "similarity_score": 0.12152698052680239
                        },
                        {
                            "class_name": "RequestHeaderArgumentResolver",
                            "similarity_score": 0.13034228089960004
                        },
                        {
                            "class_name": "RequestAttributeArgumentResolver",
                            "similarity_score": 0.16523456360801006
                        },
                        {
                            "class_name": "UriBuilderFactoryArgumentResolver",
                            "similarity_score": 0.20838949718155603
                        },
                        {
                            "class_name": "AbstractNamedValueArgumentResolver",
                            "similarity_score": 0.5237768448548211
                        },
                        {
                            "class_name": "AbstractReactorHttpExchangeAdapter",
                            "similarity_score": 0.42686638447117015
                        },
                        {
                            "class_name": "HttpServiceProxyFactoryExtensionsKt",
                            "similarity_score": 0.02825752575780252
                        },
                        {
                            "class_name": "HttpServiceProxyFactoryExtensionsKt",
                            "similarity_score": 0.02825752575780252
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HttpMethodArgumentResolver",
                        "RequestParamArgumentResolver",
                        "RequestBodyArgumentResolver",
                        "RequestPartArgumentResolver",
                        "AbstractNamedValueArgumentResolver",
                        "HttpRequestValues",
                        "AbstractReactorHttpExchangeAdapter",
                        "HttpServiceProxyFactory",
                        "ReactiveHttpRequestValues",
                        "UrlArgumentResolver",
                        "UriBuilderFactoryArgumentResolver",
                        "PathVariableArgumentResolver",
                        "RequestAttributeArgumentResolver",
                        "HttpClientAdapter",
                        "CookieValueArgumentResolver",
                        "RequestHeaderArgumentResolver",
                        "HttpServiceArgumentResolver",
                        "HttpServiceProxyFactoryExtensionsKt",
                        "HttpExchangeAdapter",
                        "ReactorHttpExchangeAdapter"
                    ],
                    "llm_response_time": 9513,
                    "similarity_computation_time": 43,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "6691ff207244ef46cdf18e16df17f3cd19c9ce2a",
        "url": "https://github.com/spring-projects/spring-framework/commit/6691ff207244ef46cdf18e16df17f3cd19c9ce2a",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private initAccept(typeAnnotation HttpExchange, methodAnnotation HttpExchange) : List<MediaType> from class org.springframework.web.service.invoker.HttpServiceMethod to private initAccept(typeAnnotation HttpExchange, methodAnnotation HttpExchange) : List<MediaType> from class org.springframework.web.service.invoker.HttpServiceMethod.HttpRequestValuesInitializer",
            "leftSideLocations": [
                {
                    "filePath": "spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                    "startLine": 251,
                    "endLine": 264,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private initAccept(typeAnnotation HttpExchange, methodAnnotation HttpExchange) : List<MediaType>"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                    "startLine": 267,
                    "endLine": 280,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "private initAccept(typeAnnotation HttpExchange, methodAnnotation HttpExchange) : List<MediaType>"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "39b832f2-1963-4f2b-83f1-753016cc85b4",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 409,
                "lineStart": 49,
                "lineEnd": 457,
                "bodyLineStart": 49,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-web/src/main/java/org/springframework/web/service/invoker/HttpServiceMethod.java",
                "sourceCode": "/**\n * Implements the invocation of an {@link HttpExchange @HttpExchange}-annotated,\n * {@link HttpServiceProxyFactory#createClient(Class) HTTP service proxy} method\n * by delegating to an {@link HttpExchangeAdapter} to perform actual requests.\n *\n * @author Rossen Stoyanchev\n * @author Sebastien Deleuze\n * @author Olga Maciaszek-Sharma\n * @since 6.0\n */\nfinal class HttpServiceMethod {\n\n\tprivate static final boolean REACTOR_PRESENT =\n\t\t\tClassUtils.isPresent(\"reactor.core.publisher.Mono\", HttpServiceMethod.class.getClassLoader());\n\n\n\tprivate final Method method;\n\n\tprivate final MethodParameter[] parameters;\n\n\tprivate final List<HttpServiceArgumentResolver> argumentResolvers;\n\n\tprivate final HttpRequestValuesInitializer requestValuesInitializer;\n\n\tprivate final ResponseFunction responseFunction;\n\n\n\tHttpServiceMethod(\n\t\t\tMethod method, Class<?> containingClass, List<HttpServiceArgumentResolver> argumentResolvers,\n\t\t\tHttpExchangeAdapter adapter, @Nullable StringValueResolver embeddedValueResolver) {\n\n\t\tthis.method = method;\n\t\tthis.parameters = initMethodParameters(method);\n\t\tthis.argumentResolvers = argumentResolvers;\n\n\t\tboolean isReactorAdapter = (REACTOR_PRESENT && adapter instanceof ReactorHttpExchangeAdapter);\n\n\t\tthis.requestValuesInitializer =\n\t\t\t\tHttpRequestValuesInitializer.create(\n\t\t\t\t\t\tmethod, containingClass, embeddedValueResolver,\n\t\t\t\t\t\t(isReactorAdapter ? ReactiveHttpRequestValues::builder : HttpRequestValues::builder));\n\n\t\tthis.responseFunction = (isReactorAdapter ?\n\t\t\t\tReactorExchangeResponseFunction.create((ReactorHttpExchangeAdapter) adapter, method) :\n\t\t\t\tExchangeResponseFunction.create(adapter, method));\n\t}\n\n\tprivate static MethodParameter[] initMethodParameters(Method method) {\n\t\tint count = method.getParameterCount();\n\t\tif (count == 0) {\n\t\t\treturn new MethodParameter[0];\n\t\t}\n\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\tcount -= 1;\n\t\t}\n\n\t\tDefaultParameterNameDiscoverer nameDiscoverer = new DefaultParameterNameDiscoverer();\n\t\tMethodParameter[] parameters = new MethodParameter[count];\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tparameters[i] = new SynthesizingMethodParameter(method, i);\n\t\t\tparameters[i].initParameterNameDiscovery(nameDiscoverer);\n\t\t}\n\t\treturn parameters;\n\t}\n\n\n\tpublic Method getMethod() {\n\t\treturn this.method;\n\t}\n\n\n\t@Nullable\n\tpublic Object invoke(Object[] arguments) {\n\t\tHttpRequestValues.Builder requestValues = this.requestValuesInitializer.initializeRequestValuesBuilder();\n\t\tapplyArguments(requestValues, arguments);\n\t\treturn this.responseFunction.execute(requestValues.build());\n\t}\n\n\tprivate void applyArguments(HttpRequestValues.Builder requestValues, Object[] arguments) {\n\t\tAssert.isTrue(arguments.length == this.parameters.length, \"Method argument mismatch\");\n\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\tObject value = arguments[i];\n\t\t\tboolean resolved = false;\n\t\t\tfor (HttpServiceArgumentResolver resolver : this.argumentResolvers) {\n\t\t\t\tif (resolver.resolve(value, this.parameters[i], requestValues)) {\n\t\t\t\t\tresolved = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint index = i;\n\t\t\tAssert.state(resolved, () ->\n\t\t\t\t\t\"Could not resolve parameter [\" + this.parameters[index].getParameterIndex() + \"] in \" +\n\t\t\t\t\t\t\tthis.parameters[index].getExecutable().toGenericString() + \": No suitable resolver\");\n\t\t}\n\t}\n\n\n\t/**\n\t * Factory for {@link HttpRequestValues} with values extracted from the type\n\t * and method-level {@link HttpExchange @HttpRequest} annotations.\n\t */\n\tprivate record HttpRequestValuesInitializer(\n\t\t\t@Nullable HttpMethod httpMethod, @Nullable String url,\n\t\t\t@Nullable MediaType contentType, @Nullable List<MediaType> acceptMediaTypes,\n\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier) {\n\n\t\tpublic HttpRequestValues.Builder initializeRequestValuesBuilder() {\n\t\t\tHttpRequestValues.Builder requestValues = this.requestValuesSupplier.get();\n\t\t\tif (this.httpMethod != null) {\n\t\t\t\trequestValues.setHttpMethod(this.httpMethod);\n\t\t\t}\n\t\t\tif (this.url != null) {\n\t\t\t\trequestValues.setUriTemplate(this.url);\n\t\t\t}\n\t\t\tif (this.contentType != null) {\n\t\t\t\trequestValues.setContentType(this.contentType);\n\t\t\t}\n\t\t\tif (this.acceptMediaTypes != null) {\n\t\t\t\trequestValues.setAccept(this.acceptMediaTypes);\n\t\t\t}\n\t\t\treturn requestValues;\n\t\t}\n\n\n\t\t/**\n\t\t * Introspect the method and create the request factory for it.\n\t\t */\n\t\tpublic static HttpRequestValuesInitializer create(\n\t\t\t\tMethod method, Class<?> containingClass, @Nullable StringValueResolver embeddedValueResolver,\n\t\t\t\tSupplier<HttpRequestValues.Builder> requestValuesSupplier) {\n\n\t\t\tHttpExchange typeAnnotation = AnnotatedElementUtils.findMergedAnnotation(containingClass, HttpExchange.class);\n\t\t\tHttpExchange methodAnnotation = AnnotatedElementUtils.findMergedAnnotation(method, HttpExchange.class);\n\n\t\t\tAssert.notNull(methodAnnotation, () -> \"Expected @HttpRequest annotation on method \" + method.toGenericString());\n\n\t\t\tHttpMethod httpMethod = initHttpMethod(typeAnnotation, methodAnnotation);\n\t\t\tString url = initUrl(typeAnnotation, methodAnnotation, embeddedValueResolver);\n\t\t\tMediaType contentType = initContentType(typeAnnotation, methodAnnotation);\n\t\t\tList<MediaType> acceptableMediaTypes = initAccept(typeAnnotation, methodAnnotation);\n\n\t\t\treturn new HttpRequestValuesInitializer(\n\t\t\t\t\thttpMethod, url, contentType, acceptableMediaTypes, requestValuesSupplier);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static HttpMethod initHttpMethod(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString methodLevelMethod = methodAnnotation.method();\n\t\t\tif (StringUtils.hasText(methodLevelMethod)) {\n\t\t\t\treturn HttpMethod.valueOf(methodLevelMethod);\n\t\t\t}\n\n\t\t\tString typeLevelMethod = (typeAnnotation != null ? typeAnnotation.method() : null);\n\t\t\tif (StringUtils.hasText(typeLevelMethod)) {\n\t\t\t\treturn HttpMethod.valueOf(typeLevelMethod);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static String initUrl(\n\t\t\t\t@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation,\n\t\t\t\t@Nullable StringValueResolver embeddedValueResolver) {\n\n\t\t\tString typeLevelUrl = (typeAnnotation != null ? typeAnnotation.url() : null);\n\t\t\tString methodLevelUrl = methodAnnotation.url();\n\n\t\t\tif (embeddedValueResolver != null) {\n\t\t\t\ttypeLevelUrl = (typeLevelUrl != null ? embeddedValueResolver.resolveStringValue(typeLevelUrl) : null);\n\t\t\t\tmethodLevelUrl = embeddedValueResolver.resolveStringValue(methodLevelUrl);\n\t\t\t}\n\n\t\t\tboolean hasTypeLevelUrl = StringUtils.hasText(typeLevelUrl);\n\t\t\tboolean hasMethodLevelUrl = StringUtils.hasText(methodLevelUrl);\n\n\t\t\tif (hasTypeLevelUrl && hasMethodLevelUrl) {\n\t\t\t\treturn (typeLevelUrl + (!typeLevelUrl.endsWith(\"/\") && !methodLevelUrl.startsWith(\"/\") ? \"/\" : \"\") + methodLevelUrl);\n\t\t\t}\n\n\t\t\tif (!hasTypeLevelUrl && !hasMethodLevelUrl) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn (hasMethodLevelUrl ? methodLevelUrl : typeLevelUrl);\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static MediaType initContentType(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString methodLevelContentType = methodAnnotation.contentType();\n\t\t\tif (StringUtils.hasText(methodLevelContentType)) {\n\t\t\t\treturn MediaType.parseMediaType(methodLevelContentType);\n\t\t\t}\n\n\t\t\tString typeLevelContentType = (typeAnnotation != null ? typeAnnotation.contentType() : null);\n\t\t\tif (StringUtils.hasText(typeLevelContentType)) {\n\t\t\t\treturn MediaType.parseMediaType(typeLevelContentType);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t@Nullable\n\t\tprivate static List<MediaType> initAccept(@Nullable HttpExchange typeAnnotation, HttpExchange methodAnnotation) {\n\t\t\tString[] methodLevelAccept = methodAnnotation.accept();\n\t\t\tif (!ObjectUtils.isEmpty(methodLevelAccept)) {\n\t\t\t\treturn MediaType.parseMediaTypes(List.of(methodLevelAccept));\n\t\t\t}\n\n\t\t\tString[] typeLevelAccept = (typeAnnotation != null ? typeAnnotation.accept() : null);\n\t\t\tif (!ObjectUtils.isEmpty(typeLevelAccept)) {\n\t\t\t\treturn MediaType.parseMediaTypes(List.of(typeLevelAccept));\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * Execute a request, obtain a response, and adapt to the expected return type.\n\t */\n\tprivate interface ResponseFunction {\n\n\t\t@Nullable\n\t\tObject execute(HttpRequestValues requestValues);\n\n\t}\n\n\tprivate record ExchangeResponseFunction(\n\t\t\tFunction<HttpRequestValues, Object> responseFunction) implements ResponseFunction {\n\n\t\t@Override\n\t\tpublic Object execute(HttpRequestValues requestValues) {\n\t\t\treturn this.responseFunction.apply(requestValues);\n\t\t}\n\n\n\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */\n\t\tpublic static ResponseFunction create(HttpExchangeAdapter client, Method method) {\n\t\t\tif (KotlinDetector.isSuspendingFunction(method)) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Kotlin Coroutines are only supported with reactive implementations\");\n\t\t\t}\n\n\t\t\tMethodParameter param = new MethodParameter(method, -1).nestedIfOptional();\n\t\t\tClass<?> paramType = param.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Object> responseFunction;\n\t\t\tif (paramType.equals(void.class) || paramType.equals(Void.class)) {\n\t\t\t\tresponseFunction = requestValues -> {\n\t\t\t\t\tclient.exchange(requestValues);\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if (paramType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = request -> asOptionalIfNecessary(client.exchangeForHeaders(request), param);\n\t\t\t}\n\t\t\telse if (paramType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = param.nested();\n\t\t\t\tif (bodyParam.getNestedParameterType().equals(Void.class)) {\n\t\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForBodilessEntity(request), param);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tParameterizedTypeReference<?> bodyTypeRef =\n\t\t\t\t\t\t\tParameterizedTypeReference.forType(bodyParam.getNestedGenericParameterType());\n\t\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForEntity(request, bodyTypeRef), param);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tParameterizedTypeReference<?> bodyTypeRef =\n\t\t\t\t\t\tParameterizedTypeReference.forType(param.getNestedGenericParameterType());\n\t\t\t\tresponseFunction = request ->\n\t\t\t\t\t\tasOptionalIfNecessary(client.exchangeForBody(request, bodyTypeRef), param);\n\t\t\t}\n\n\t\t\treturn new ExchangeResponseFunction(responseFunction);\n\t\t}\n\n\t\tprivate static @Nullable Object asOptionalIfNecessary(@Nullable Object response, MethodParameter param) {\n\t\t\treturn param.getParameterType().equals(Optional.class) ? Optional.ofNullable(response) : response;\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link ResponseFunction} for {@link ReactorHttpExchangeAdapter}.\n\t */\n\tprivate record ReactorExchangeResponseFunction(\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction,\n\t\t\t@Nullable ReactiveAdapter returnTypeAdapter,\n\t\t\tboolean blockForOptional, @Nullable Duration blockTimeout) implements ResponseFunction {\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object execute(HttpRequestValues requestValues) {\n\n\t\t\tPublisher<?> responsePublisher = this.responseFunction.apply(requestValues);\n\n\t\t\tif (this.returnTypeAdapter != null) {\n\t\t\t\treturn this.returnTypeAdapter.fromPublisher(responsePublisher);\n\t\t\t}\n\n\t\t\tif (this.blockForOptional) {\n\t\t\t\treturn (this.blockTimeout != null ?\n\t\t\t\t\t\t((Mono<?>) responsePublisher).blockOptional(this.blockTimeout) :\n\t\t\t\t\t\t((Mono<?>) responsePublisher).blockOptional());\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn (this.blockTimeout != null ?\n\t\t\t\t\t\t((Mono<?>) responsePublisher).block(this.blockTimeout) :\n\t\t\t\t\t\t((Mono<?>) responsePublisher).block());\n\t\t\t}\n\t\t}\n\n\n\t\t/**\n\t\t * Create the {@code ResponseFunction} that matches the method return type.\n\t\t */\n\t\tpublic static ResponseFunction create(ReactorHttpExchangeAdapter client, Method method) {\n\t\t\tMethodParameter returnParam = new MethodParameter(method, -1);\n\t\t\tClass<?> returnType = returnParam.getParameterType();\n\t\t\tboolean isSuspending = KotlinDetector.isSuspendingFunction(method);\n\t\t\tif (isSuspending) {\n\t\t\t\treturnType = Mono.class;\n\t\t\t}\n\n\t\t\tReactiveAdapter reactiveAdapter = client.getReactiveAdapterRegistry().getAdapter(returnType);\n\n\t\t\tMethodParameter actualParam = (reactiveAdapter != null ? returnParam.nested() : returnParam.nestedIfOptional());\n\t\t\tClass<?> actualType = isSuspending ? actualParam.getParameterType() : actualParam.getNestedParameterType();\n\n\t\t\tFunction<HttpRequestValues, Publisher<?>> responseFunction;\n\t\t\tif (actualType.equals(void.class) || actualType.equals(Void.class)) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (reactiveAdapter != null && reactiveAdapter.isNoValue()) {\n\t\t\t\tresponseFunction = client::exchangeForMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(HttpHeaders.class)) {\n\t\t\t\tresponseFunction = client::exchangeForHeadersMono;\n\t\t\t}\n\t\t\telse if (actualType.equals(ResponseEntity.class)) {\n\t\t\t\tMethodParameter bodyParam = isSuspending ? actualParam : actualParam.nested();\n\t\t\t\tClass<?> bodyType = bodyParam.getNestedParameterType();\n\t\t\t\tif (bodyType.equals(Void.class)) {\n\t\t\t\t\tresponseFunction = client::exchangeForBodilessEntityMono;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReactiveAdapter bodyAdapter = client.getReactiveAdapterRegistry().getAdapter(bodyType);\n\t\t\t\t\tresponseFunction = initResponseEntityFunction(client, bodyParam, bodyAdapter, isSuspending);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresponseFunction = initBodyFunction(client, actualParam, reactiveAdapter, isSuspending);\n\t\t\t}\n\n\t\t\treturn new ReactorExchangeResponseFunction(\n\t\t\t\t\tresponseFunction, reactiveAdapter, returnType.equals(Optional.class), client.getBlockTimeout());\n\t\t}\n\n\t\t@SuppressWarnings(\"ConstantConditions\")\n\t\tprivate static Function<HttpRequestValues, Publisher<?>> initResponseEntityFunction(\n\t\t\t\tReactorHttpExchangeAdapter client, MethodParameter methodParam,\n\t\t\t\t@Nullable ReactiveAdapter reactiveAdapter, boolean isSuspending) {\n\n\t\t\tif (reactiveAdapter == null) {\n\t\t\t\treturn request -> client.exchangeForEntityMono(\n\t\t\t\t\t\trequest, ParameterizedTypeReference.forType(methodParam.getNestedGenericParameterType()));\n\t\t\t}\n\n\t\t\tAssert.isTrue(reactiveAdapter.isMultiValue(),\n\t\t\t\t\t\"ResponseEntity body must be a concrete value or a multi-value Publisher\");\n\n\t\t\tParameterizedTypeReference<?> bodyType =\n\t\t\t\t\tParameterizedTypeReference.forType(isSuspending ? methodParam.nested().getGenericParameterType() :\n\t\t\t\t\t\t\tmethodParam.nested().getNestedGenericParameterType());\n\n\t\t\t// Shortcut for Flux\n\t\t\tif (reactiveAdapter.getReactiveType().equals(Flux.class)) {\n\t\t\t\treturn request -> client.exchangeForEntityFlux(request, bodyType);\n\t\t\t}\n\n\t\t\treturn request -> client.exchangeForEntityFlux(request, bodyType)\n\t\t\t\t\t.map(entity -> {\n\t\t\t\t\t\tObject body = reactiveAdapter.fromPublisher(entity.getBody());\n\t\t\t\t\t\treturn new ResponseEntity<>(body, entity.getHeaders(), entity.getStatusCode());\n\t\t\t\t\t});\n\t\t}\n\n\t\tprivate static Function<HttpRequestValues, Publisher<?>> initBodyFunction(\n\t\t\t\tReactorHttpExchangeAdapter client, MethodParameter methodParam,\n\t\t\t\t@Nullable ReactiveAdapter reactiveAdapter, boolean isSuspending) {\n\n\t\t\tParameterizedTypeReference<?> bodyType =\n\t\t\t\t\tParameterizedTypeReference.forType(isSuspending ? methodParam.getGenericParameterType() :\n\t\t\t\t\t\t\tmethodParam.getNestedGenericParameterType());\n\n\t\t\treturn (reactiveAdapter != null && reactiveAdapter.isMultiValue() ?\n\t\t\t\t\trequest -> client.exchangeForBodyFlux(request, bodyType) :\n\t\t\t\t\trequest -> client.exchangeForBodyMono(request, bodyType));\n\t\t}\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 3,
                "candidates": [
                    {
                        "lineStart": 368,
                        "lineEnd": 411,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method create to class HttpServiceMethod",
                        "description": "move method to org.springframework.web.service.invoker.HttpServiceMethod\nRationale: This method is heavily involved in processing HTTP service method exchanges, arranging responses, and working with reactive programming components. As such, it would be a good fit for the 'HttpServiceMethod' class, where it can more directly access and manipulate the details of service methods and their associated exchanges.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 119,
                        "lineEnd": 124,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "refactoringInfo": "Move method invoke to class ResponseFunction",
                        "description": "Move method to org.springframework.web.service.invoker.HttpServiceMethod.ResponseFunction\nRationale: The method invokes the 'execute' function of 'this.responseFunction', which implies that it is tightly coupled with the functionality of the 'ResponseFunction' class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 95,
                        "lineEnd": 111,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method initMethodParameters to class HttpMethodArgumentResolver",
                        "description": "move method to org.springframework.web.service.invoker.HttpMethodArgumentResolver\nRationale: This method is involved in the handling and processing of Method instances, it is suspected to do some argument resolution as well - which would be the key responsibility of a class like 'HttpMethodArgumentResolver'.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [],
                    "llm_response_time": 2834
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "invoke",
                            "method_signature": "public Object invoke(Object[] arguments): Object",
                            "target_class": "HttpClient",
                            "rationale": "The 'invoke' method is making HTTP exchange which is better to be in HttpClient class as a part of the external service communication."
                        },
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static MethodParameter[] initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "ReflectionUtils",
                            "rationale": "The 'initMethodParameters' method is purely related to reflection and parameter extraction which is better suited in a utility class such as ReflectionUtils."
                        }
                    ],
                    "llm_response_time": 7625
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "MethodInitialization",
                            "rationale": "initMethodParameters() is a utility method that focuses on initializing method parameters. It does not handle any HTTP Service specific procedures and is more related to general method initialization, so it could be moved to a 'MethodInitialization' utility class."
                        },
                        {
                            "method_name": "create",
                            "method_signature": "public static create(HttpExchangeAdapter client, Method method): ResponseFunction",
                            "target_class": "ResponseFunctionFactory",
                            "rationale": "create() method is used to create instances of 'ResponseFunction' according to the method return type. This method essentially performs the role of a factory for creating 'ResponseFunction' instances, so it would make sense to move it to a dedicated factory class, 'ResponseFunctionFactory'."
                        }
                    ],
                    "llm_response_time": 18512
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "invoke",
                            "method_signature": "public Object invoke(Object[] arguments): Object",
                            "target_class": "HttpClient",
                            "rationale": "The 'invoke' method is making HTTP exchange which is better to be in HttpClient class as a part of the external service communication."
                        },
                        {
                            "method_name": "initMethodParameters",
                            "method_signature": "private static MethodParameter[] initMethodParameters(Method method): MethodParameter[]",
                            "target_class": "ReflectionUtils",
                            "rationale": "The 'initMethodParameters' method is purely related to reflection and parameter extraction which is better suited in a utility class such as ReflectionUtils."
                        },
                        {
                            "method_name": "create",
                            "method_signature": "public static create(HttpExchangeAdapter client, Method method): ResponseFunction",
                            "target_class": "ResponseFunctionFactory",
                            "rationale": "create() method is used to create instances of 'ResponseFunction' according to the method return type. This method essentially performs the role of a factory for creating 'ResponseFunction' instances, so it would make sense to move it to a dedicated factory class, 'ResponseFunctionFactory'."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "create",
                    "invoke",
                    "initMethodParameters"
                ],
                "llm_response_time": 4151
            },
            "targetClassMap": {
                "create": {
                    "target_classes": [
                        {
                            "class_name": "HttpServiceMethod",
                            "similarity_score": 0.8426924708817681
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HttpServiceMethod"
                    ],
                    "llm_response_time": 4717,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "invoke": {
                    "target_classes": [
                        {
                            "class_name": "ResponseFunction",
                            "similarity_score": 0.24845199749997662
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ResponseFunction"
                    ],
                    "llm_response_time": 3715,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "initMethodParameters": {
                    "target_classes": [
                        {
                            "class_name": "HttpClientAdapter",
                            "similarity_score": 0.16335892281539527
                        },
                        {
                            "class_name": "HttpRequestValues",
                            "similarity_score": 0.43755735048290084
                        },
                        {
                            "class_name": "HttpExchangeAdapter",
                            "similarity_score": 0.025823475817683298
                        },
                        {
                            "class_name": "UrlArgumentResolver",
                            "similarity_score": 0.34464735255878187
                        },
                        {
                            "class_name": "HttpServiceProxyFactory",
                            "similarity_score": 0.4152750858686238
                        },
                        {
                            "class_name": "ReactiveHttpRequestValues",
                            "similarity_score": 0.4023666452760909
                        },
                        {
                            "class_name": "HttpMethodArgumentResolver",
                            "similarity_score": 0.3745371356605301
                        },
                        {
                            "class_name": "ReactorHttpExchangeAdapter",
                            "similarity_score": 0.023074792438534632
                        },
                        {
                            "class_name": "CookieValueArgumentResolver",
                            "similarity_score": 0.1342464417333466
                        },
                        {
                            "class_name": "HttpServiceArgumentResolver",
                            "similarity_score": 0.062365251721675424
                        },
                        {
                            "class_name": "RequestBodyArgumentResolver",
                            "similarity_score": 0.5677222062762607
                        },
                        {
                            "class_name": "RequestPartArgumentResolver",
                            "similarity_score": 0.5527201115750559
                        },
                        {
                            "class_name": "PathVariableArgumentResolver",
                            "similarity_score": 0.1701983272637592
                        },
                        {
                            "class_name": "RequestParamArgumentResolver",
                            "similarity_score": 0.12152698052680239
                        },
                        {
                            "class_name": "RequestHeaderArgumentResolver",
                            "similarity_score": 0.13034228089960004
                        },
                        {
                            "class_name": "RequestAttributeArgumentResolver",
                            "similarity_score": 0.16523456360801006
                        },
                        {
                            "class_name": "UriBuilderFactoryArgumentResolver",
                            "similarity_score": 0.20838949718155603
                        },
                        {
                            "class_name": "AbstractNamedValueArgumentResolver",
                            "similarity_score": 0.5237768448548211
                        },
                        {
                            "class_name": "AbstractReactorHttpExchangeAdapter",
                            "similarity_score": 0.42686638447117015
                        },
                        {
                            "class_name": "HttpServiceProxyFactoryExtensionsKt",
                            "similarity_score": 0.02825752575780252
                        },
                        {
                            "class_name": "HttpServiceProxyFactoryExtensionsKt",
                            "similarity_score": 0.02825752575780252
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HttpMethodArgumentResolver",
                        "RequestParamArgumentResolver",
                        "RequestBodyArgumentResolver",
                        "RequestPartArgumentResolver",
                        "AbstractNamedValueArgumentResolver",
                        "HttpRequestValues",
                        "AbstractReactorHttpExchangeAdapter",
                        "HttpServiceProxyFactory",
                        "ReactiveHttpRequestValues",
                        "UrlArgumentResolver",
                        "UriBuilderFactoryArgumentResolver",
                        "PathVariableArgumentResolver",
                        "RequestAttributeArgumentResolver",
                        "HttpClientAdapter",
                        "CookieValueArgumentResolver",
                        "RequestHeaderArgumentResolver",
                        "HttpServiceArgumentResolver",
                        "HttpServiceProxyFactoryExtensionsKt",
                        "HttpExchangeAdapter",
                        "ReactorHttpExchangeAdapter"
                    ],
                    "llm_response_time": 9513,
                    "similarity_computation_time": 43,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "750cb739023a4ceb52e91ea66ce09f98638a8821",
        "url": "https://github.com/spring-projects/spring-framework/commit/750cb739023a4ceb52e91ea66ce09f98638a8821",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private method(request ServerRequest) : HttpMethod from class org.springframework.web.reactive.function.server.RequestPredicates.HttpMethodPredicate to package method(request ServerRequest) : HttpMethod from class org.springframework.web.reactive.function.server.RequestPredicates.SingleHttpMethodPredicate",
            "leftSideLocations": [
                {
                    "filePath": "spring-webflux/src/main/java/org/springframework/web/reactive/function/server/RequestPredicates.java",
                    "startLine": 554,
                    "endLine": 563,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private method(request ServerRequest) : HttpMethod"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-webflux/src/main/java/org/springframework/web/reactive/function/server/RequestPredicates.java",
                    "startLine": 564,
                    "endLine": 573,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "package method(request ServerRequest) : HttpMethod"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "80e6de4c-9b49-40e1-a8ac-1f040bbdf8bb",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1276,
                "lineStart": 66,
                "lineEnd": 1341,
                "bodyLineStart": 66,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-webflux/src/main/java/org/springframework/web/reactive/function/server/RequestPredicates.java",
                "sourceCode": "/**\n * Implementations of {@link RequestPredicate} that implement various useful\n * request matching operations, such as matching based on path, HTTP method, etc.\n *\n * @author Arjen Poutsma\n * @since 5.0\n */\npublic abstract class RequestPredicates {\n\n\tprivate static final Log logger = LogFactory.getLog(RequestPredicates.class);\n\n\n\t/**\n\t * Return a {@code RequestPredicate} that always matches.\n\t * @return a predicate that always matches\n\t */\n\tpublic static RequestPredicate all() {\n\t\treturn request -> true;\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's\n\t * HTTP method is equal to the given method.\n\t * @param httpMethod the HTTP method to match against\n\t * @return a predicate that tests against the given HTTP method\n\t */\n\tpublic static RequestPredicate method(HttpMethod httpMethod) {\n\t\treturn new HttpMethodPredicate(httpMethod);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's\n\t * HTTP method is equal to one the of the given methods.\n\t * @param httpMethods the HTTP methods to match against\n\t * @return a predicate that tests against the given HTTP methods\n\t * @since 5.1\n\t */\n\tpublic static RequestPredicate methods(HttpMethod... httpMethods) {\n\t\treturn new HttpMethodPredicate(httpMethods);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that tests the request path\n\t * against the given path pattern.\n\t * @param pattern the pattern to match to\n\t * @return a predicate that tests against the given path pattern\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate path(String pattern) {\n\t\tAssert.notNull(pattern, \"'pattern' must not be null\");\n\t\tPathPatternParser parser = PathPatternParser.defaultInstance;\n\t\tpattern = parser.initFullPathPattern(pattern);\n\t\treturn pathPredicates(parser).apply(pattern);\n\t}\n\n\t/**\n\t * Return a function that creates new path-matching {@code RequestPredicates}\n\t * from pattern Strings using the given {@link PathPatternParser}.\n\t * <p>This method can be used to specify a non-default, customized\n\t * {@code PathPatternParser} when resolving path patterns.\n\t * @param patternParser the parser used to parse patterns given to the returned function\n\t * @return a function that resolves a pattern String into a path-matching\n\t * {@code RequestPredicates} instance\n\t */\n\tpublic static Function<String, RequestPredicate> pathPredicates(PathPatternParser patternParser) {\n\t\tAssert.notNull(patternParser, \"PathPatternParser must not be null\");\n\t\treturn pattern -> new PathPatternPredicate(patternParser.parse(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that tests the request's headers\n\t * against the given headers predicate.\n\t * @param headersPredicate a predicate that tests against the request headers\n\t * @return a predicate that tests against the given header predicate\n\t */\n\tpublic static RequestPredicate headers(Predicate<ServerRequest.Headers> headersPredicate) {\n\t\treturn new HeadersPredicate(headersPredicate);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that tests if the request's\n\t * {@linkplain ServerRequest.Headers#contentType() content type} is\n\t * {@linkplain MediaType#includes(MediaType) included} by any of the given media types.\n\t * @param mediaTypes the media types to match the request's content type against\n\t * @return a predicate that tests the request's content type against the given media types\n\t */\n\tpublic static RequestPredicate contentType(MediaType... mediaTypes) {\n\t\tAssert.notEmpty(mediaTypes, \"'mediaTypes' must not be empty\");\n\t\treturn new ContentTypePredicate(mediaTypes);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that tests if the request's\n\t * {@linkplain ServerRequest.Headers#accept() accept} header is\n\t * {@linkplain MediaType#isCompatibleWith(MediaType) compatible} with any of the given media types.\n\t * @param mediaTypes the media types to match the request's accept header against\n\t * @return a predicate that tests the request's accept header against the given media types\n\t */\n\tpublic static RequestPredicate accept(MediaType... mediaTypes) {\n\t\tAssert.notEmpty(mediaTypes, \"'mediaTypes' must not be empty\");\n\t\treturn new AcceptPredicate(mediaTypes);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code GET}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is GET and if the given pattern\n\t * matches against the request path\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate GET(String pattern) {\n\t\treturn method(HttpMethod.GET).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code HEAD}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is HEAD and if the given pattern\n\t * matches against the request path\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate HEAD(String pattern) {\n\t\treturn method(HttpMethod.HEAD).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code POST}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is POST and if the given pattern\n\t * matches against the request path\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate POST(String pattern) {\n\t\treturn method(HttpMethod.POST).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PUT}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is PUT and if the given pattern\n\t * matches against the request path\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate PUT(String pattern) {\n\t\treturn method(HttpMethod.PUT).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PATCH}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is PATCH and if the given pattern\n\t * matches against the request path\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate PATCH(String pattern) {\n\t\treturn method(HttpMethod.PATCH).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code DELETE}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is DELETE and if the given pattern\n\t * matches against the request path\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate DELETE(String pattern) {\n\t\treturn method(HttpMethod.DELETE).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code OPTIONS}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is OPTIONS and if the given pattern\n\t * matches against the request path\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate OPTIONS(String pattern) {\n\t\treturn method(HttpMethod.OPTIONS).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's path has the given extension.\n\t * @param extension the path extension to match against, ignoring case\n\t * @return a predicate that matches if the request's path has the given file extension\n\t */\n\tpublic static RequestPredicate pathExtension(String extension) {\n\t\tAssert.notNull(extension, \"'extension' must not be null\");\n\t\treturn new PathExtensionPredicate(extension);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's path matches the given\n\t * predicate.\n\t * @param extensionPredicate the predicate to test against the request path extension\n\t * @return a predicate that matches if the given predicate matches against the request's path\n\t * file extension\n\t */\n\tpublic static RequestPredicate pathExtension(Predicate<String> extensionPredicate) {\n\t\treturn new PathExtensionPredicate(extensionPredicate);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's query parameter of the given name\n\t * has the given value.\n\t * @param name the name of the query parameter to test against\n\t * @param value the value of the query parameter to test against\n\t * @return a predicate that matches if the query parameter has the given value\n\t * @since 5.0.7\n\t * @see ServerRequest#queryParam(String)\n\t */\n\tpublic static RequestPredicate queryParam(String name, String value) {\n\t\treturn new QueryParamPredicate(name, value);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that tests the request's query parameter of the given name\n\t * against the given predicate.\n\t * @param name the name of the query parameter to test against\n\t * @param predicate the predicate to test against the query parameter value\n\t * @return a predicate that matches the given predicate against the query parameter of the given name\n\t * @see ServerRequest#queryParam(String)\n\t */\n\tpublic static RequestPredicate queryParam(String name, Predicate<String> predicate) {\n\t\treturn new QueryParamPredicate(name, predicate);\n\t}\n\n\n\tprivate static void traceMatch(String prefix, Object desired, @Nullable Object actual, boolean match) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(String.format(\"%s \\\"%s\\\" %s against value \\\"%s\\\"\",\n\t\t\t\t\tprefix, desired, match ? \"matches\" : \"does not match\", actual));\n\t\t}\n\t}\n\n\tprivate static PathPattern mergePatterns(@Nullable PathPattern oldPattern, PathPattern newPattern) {\n\t\tif (oldPattern != null) {\n\t\t\treturn oldPattern.combine(newPattern);\n\t\t}\n\t\telse {\n\t\t\treturn newPattern;\n\t\t}\n\t}\n\n\tprivate static <K, V> Map<K, V> mergeMaps(Map<K, V> left, Map<K, V> right) {\n\t\tif (left.isEmpty()) {\n\t\t\tif (right.isEmpty()) {\n\t\t\t\treturn Collections.emptyMap();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn right;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (right.isEmpty()) {\n\t\t\t\treturn left;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMap<K, V> result = CollectionUtils.newLinkedHashMap(left.size() + right.size());\n\t\t\t\tresult.putAll(left);\n\t\t\t\tresult.putAll(right);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Receives notifications from the logical structure of request predicates.\n\t */\n\tpublic interface Visitor {\n\n\t\t/**\n\t\t * Receive notification of an HTTP method predicate.\n\t\t * @param methods the HTTP methods that make up the predicate\n\t\t * @see RequestPredicates#method(HttpMethod)\n\t\t */\n\t\tvoid method(Set<HttpMethod> methods);\n\n\t\t/**\n\t\t * Receive notification of a path predicate.\n\t\t * @param pattern the path pattern that makes up the predicate\n\t\t * @see RequestPredicates#path(String)\n\t\t * @see org.springframework.web.util.pattern.PathPattern\n\t\t */\n\t\tvoid path(String pattern);\n\n\t\t/**\n\t\t * Receive notification of a path extension predicate.\n\t\t * @param extension the path extension that makes up the predicate\n\t\t * @see RequestPredicates#pathExtension(String)\n\t\t */\n\t\tvoid pathExtension(String extension);\n\n\t\t/**\n\t\t * Receive notification of an HTTP header predicate.\n\t\t * @param name the name of the HTTP header to check\n\t\t * @param value the desired value of the HTTP header\n\t\t * @see RequestPredicates#headers(Predicate)\n\t\t * @see RequestPredicates#contentType(MediaType...)\n\t\t * @see RequestPredicates#accept(MediaType...)\n\t\t */\n\t\tvoid header(String name, String value);\n\n\t\t/**\n\t\t * Receive notification of a query parameter predicate.\n\t\t * @param name the name of the query parameter\n\t\t * @param value the desired value of the parameter\n\t\t * @see RequestPredicates#queryParam(String, String)\n\t\t */\n\t\tvoid queryParam(String name, String value);\n\n\t\t/**\n\t\t * Receive first notification of a logical AND predicate.\n\t\t * The first subsequent notification will contain the left-hand side of the AND-predicate;\n\t\t * followed by {@link #and()}, followed by the right-hand side, followed by {@link #endAnd()}.\n\t\t * @see RequestPredicate#and(RequestPredicate)\n\t\t */\n\t\tvoid startAnd();\n\n\t\t/**\n\t\t * Receive \"middle\" notification of a logical AND predicate.\n\t\t * The following notification contains the right-hand side, followed by {@link #endAnd()}.\n\t\t * @see RequestPredicate#and(RequestPredicate)\n\t\t */\n\t\tvoid and();\n\n\t\t/**\n\t\t * Receive last notification of a logical AND predicate.\n\t\t * @see RequestPredicate#and(RequestPredicate)\n\t\t */\n\t\tvoid endAnd();\n\n\t\t/**\n\t\t * Receive first notification of a logical OR predicate.\n\t\t * The first subsequent notification will contain the left-hand side of the OR-predicate;\n\t\t * the second notification contains the right-hand side, followed by {@link #endOr()}.\n\t\t * @see RequestPredicate#or(RequestPredicate)\n\t\t */\n\t\tvoid startOr();\n\n\t\t/**\n\t\t * Receive \"middle\" notification of a logical OR predicate.\n\t\t * The following notification contains the right-hand side, followed by {@link #endOr()}.\n\t\t * @see RequestPredicate#or(RequestPredicate)\n\t\t */\n\t\tvoid or();\n\n\t\t/**\n\t\t * Receive last notification of a logical OR predicate.\n\t\t * @see RequestPredicate#or(RequestPredicate)\n\t\t */\n\t\tvoid endOr();\n\n\t\t/**\n\t\t * Receive first notification of a negated predicate.\n\t\t * The first subsequent notification will contain the negated predicated, followed\n\t\t * by {@link #endNegate()}.\n\t\t * @see RequestPredicate#negate()\n\t\t */\n\t\tvoid startNegate();\n\n\t\t/**\n\t\t * Receive last notification of a negated predicate.\n\t\t * @see RequestPredicate#negate()\n\t\t */\n\t\tvoid endNegate();\n\n\t\t/**\n\t\t * Receive first notification of an unknown predicate.\n\t\t */\n\t\tvoid unknown(RequestPredicate predicate);\n\t}\n\n\n\t/**\n\t * Extension of {@code RequestPredicate} that can modify the {@code ServerRequest}.\n\t */\n\tabstract static class RequestModifyingPredicate implements RequestPredicate {\n\n\n\t\tpublic static RequestModifyingPredicate of(RequestPredicate requestPredicate) {\n\t\t\tif (requestPredicate instanceof RequestModifyingPredicate modifyingPredicate) {\n\t\t\t\treturn modifyingPredicate;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new RequestModifyingPredicate() {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\t\t\t\treturn Result.of(requestPredicate.test(request));\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\n\t\t@Override\n\t\tpublic final boolean test(ServerRequest request) {\n\t\t\tResult result = testInternal(request);\n\t\t\tboolean value = result.value();\n\t\t\tif (value) {\n\t\t\t\tresult.modifyAttributes(request.attributes());\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tprotected abstract Result testInternal(ServerRequest request);\n\n\n\t\tprotected static final class Result {\n\n\t\t\tprivate static final Result TRUE = new Result(true, null);\n\n\t\t\tprivate static final Result FALSE = new Result(false, null);\n\n\n\t\t\tprivate final boolean value;\n\n\t\t\t@Nullable\n\t\t\tprivate final Consumer<Map<String, Object>> modifyAttributes;\n\n\n\t\t\tprivate Result(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes) {\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.modifyAttributes = modifyAttributes;\n\t\t\t}\n\n\n\t\t\tpublic static Result of(boolean value) {\n\t\t\t\treturn of(value, null);\n\t\t\t}\n\n\t\t\tpublic static Result of(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes) {\n\t\t\t\tif (modifyAttributes == null) {\n\t\t\t\t\treturn value ? TRUE : FALSE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Result(value, modifyAttributes);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tpublic boolean value() {\n\t\t\t\treturn this.value;\n\t\t\t}\n\n\t\t\tpublic void modifyAttributes(Map<String, Object> attributes) {\n\t\t\t\tif (this.modifyAttributes != null) {\n\t\t\t\t\tthis.modifyAttributes.accept(attributes);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic boolean modifiesAttributes() {\n\t\t\t\treturn this.modifyAttributes != null;\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\tprivate static class HttpMethodPredicate implements RequestPredicate {\n\n\t\tprivate final Set<HttpMethod> httpMethods;\n\n\t\tpublic HttpMethodPredicate(HttpMethod httpMethod) {\n\t\t\tAssert.notNull(httpMethod, \"HttpMethod must not be null\");\n\t\t\tthis.httpMethods = Set.of(httpMethod);\n\t\t}\n\n\t\tpublic HttpMethodPredicate(HttpMethod... httpMethods) {\n\t\t\tAssert.notEmpty(httpMethods, \"HttpMethods must not be empty\");\n\t\t\tthis.httpMethods = new LinkedHashSet<>(Arrays.asList(httpMethods));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tHttpMethod method = method(request);\n\t\t\tboolean match = this.httpMethods.contains(method);\n\t\t\ttraceMatch(\"Method\", this.httpMethods, method, match);\n\t\t\treturn match;\n\t\t}\n\n\t\tprivate static HttpMethod method(ServerRequest request) {\n\t\t\tif (CorsUtils.isPreFlightRequest(request.exchange().getRequest())) {\n\t\t\t\tString accessControlRequestMethod =\n\t\t\t\t\t\trequest.headers().firstHeader(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD);\n\t\t\t\tif (accessControlRequestMethod != null) {\n\t\t\t\t\treturn HttpMethod.valueOf(accessControlRequestMethod);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn request.method();\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.method(Collections.unmodifiableSet(this.httpMethods));\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (this.httpMethods.size() == 1) {\n\t\t\t\treturn this.httpMethods.iterator().next().toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.httpMethods.toString();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class PathPatternPredicate extends RequestModifyingPredicate\n\t\t\timplements ChangePathPatternParserVisitor.Target {\n\n\t\tprivate PathPattern pattern;\n\n\n\t\tpublic PathPatternPredicate(PathPattern pattern) {\n\t\t\tAssert.notNull(pattern, \"'pattern' must not be null\");\n\t\t\tthis.pattern = pattern;\n\t\t}\n\n\n\t\t@Override\n\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\tPathContainer pathContainer = request.requestPath().pathWithinApplication();\n\t\t\tPathPattern.PathMatchInfo info = this.pattern.matchAndExtract(pathContainer);\n\t\t\ttraceMatch(\"Pattern\", this.pattern.getPatternString(), request.path(), info != null);\n\t\t\tif (info != null) {\n\t\t\t\treturn Result.of(true, attributes -> modifyAttributes(attributes, request, info.getUriVariables()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Result.of(false);\n\t\t\t}\n\t\t}\n\n\t\tprivate void modifyAttributes(Map<String, Object> attributes, ServerRequest request,\n\t\t\t\tMap<String, String> variables) {\n\n\t\t\tMap<String, String> pathVariables = mergeMaps(request.pathVariables(), variables);\n\n\t\t\tattributes.put(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE,\n\t\t\t\t\tCollections.unmodifiableMap(pathVariables));\n\n\t\t\tPathPattern pattern = mergePatterns(\n\t\t\t\t\t(PathPattern) attributes.get(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE),\n\t\t\t\t\tthis.pattern);\n\n\t\t\tattributes.put(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE, pattern);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<ServerRequest> nest(ServerRequest request) {\n\t\t\treturn Optional.ofNullable(this.pattern.matchStartOfPath(request.requestPath().pathWithinApplication()))\n\t\t\t\t\t.map(info -> new NestedPathPatternServerRequestWrapper(request, info, this.pattern));\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.path(this.pattern.getPatternString());\n\t\t}\n\n\t\t@Override\n\t\tpublic void changeParser(PathPatternParser parser) {\n\t\t\tString patternString = this.pattern.getPatternString();\n\t\t\tthis.pattern = parser.parse(patternString);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.pattern.getPatternString();\n\t\t}\n\t}\n\n\n\tprivate static class HeadersPredicate implements RequestPredicate {\n\n\t\tprivate final Predicate<ServerRequest.Headers> headersPredicate;\n\n\t\tpublic HeadersPredicate(Predicate<ServerRequest.Headers> headersPredicate) {\n\t\t\tAssert.notNull(headersPredicate, \"Predicate must not be null\");\n\t\t\tthis.headersPredicate = headersPredicate;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tif (CorsUtils.isPreFlightRequest(request.exchange().getRequest())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.headersPredicate.test(request.headers());\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.headersPredicate.toString();\n\t\t}\n\t}\n\n\n\tprivate static class ContentTypePredicate extends HeadersPredicate {\n\n\t\tprivate final Set<MediaType> mediaTypes;\n\n\t\tpublic ContentTypePredicate(MediaType... mediaTypes) {\n\t\t\tthis(Set.of(mediaTypes));\n\t\t}\n\n\t\tprivate ContentTypePredicate(Set<MediaType> mediaTypes) {\n\t\t\tsuper(headers -> {\n\t\t\t\tMediaType contentType =\n\t\t\t\t\t\theaders.contentType().orElse(MediaType.APPLICATION_OCTET_STREAM);\n\t\t\t\tboolean match = mediaTypes.stream()\n\t\t\t\t\t\t.anyMatch(mediaType -> mediaType.includes(contentType));\n\t\t\t\ttraceMatch(\"Content-Type\", mediaTypes, contentType, match);\n\t\t\t\treturn match;\n\t\t\t});\n\t\t\tthis.mediaTypes = mediaTypes;\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.header(HttpHeaders.CONTENT_TYPE,\n\t\t\t\t\t(this.mediaTypes.size() == 1) ?\n\t\t\t\t\t\t\tthis.mediaTypes.iterator().next().toString() :\n\t\t\t\t\t\t\tthis.mediaTypes.toString());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"Content-Type: %s\",\n\t\t\t\t\t(this.mediaTypes.size() == 1) ?\n\t\t\t\t\t\t\tthis.mediaTypes.iterator().next().toString() :\n\t\t\t\t\t\t\tthis.mediaTypes.toString());\n\t\t}\n\t}\n\n\n\tprivate static class AcceptPredicate extends HeadersPredicate {\n\n\t\tprivate final Set<MediaType> mediaTypes;\n\n\t\tpublic AcceptPredicate(MediaType... mediaTypes) {\n\t\t\tthis(Set.of(mediaTypes));\n\t\t}\n\n\t\tprivate AcceptPredicate(Set<MediaType> mediaTypes) {\n\t\t\tsuper(headers -> {\n\t\t\t\tList<MediaType> acceptedMediaTypes = acceptedMediaTypes(headers);\n\t\t\t\tboolean match = acceptedMediaTypes.stream()\n\t\t\t\t\t\t.anyMatch(acceptedMediaType -> mediaTypes.stream()\n\t\t\t\t\t\t\t\t.anyMatch(acceptedMediaType::isCompatibleWith));\n\t\t\t\ttraceMatch(\"Accept\", mediaTypes, acceptedMediaTypes, match);\n\t\t\t\treturn match;\n\t\t\t});\n\t\t\tthis.mediaTypes = mediaTypes;\n\t\t}\n\n\t\t@NonNull\n\t\tprivate static List<MediaType> acceptedMediaTypes(ServerRequest.Headers headers) {\n\t\t\tList<MediaType> acceptedMediaTypes = headers.accept();\n\t\t\tif (acceptedMediaTypes.isEmpty()) {\n\t\t\t\tacceptedMediaTypes = Collections.singletonList(MediaType.ALL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMimeTypeUtils.sortBySpecificity(acceptedMediaTypes);\n\t\t\t}\n\t\t\treturn acceptedMediaTypes;\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.header(HttpHeaders.ACCEPT,\n\t\t\t\t\t(this.mediaTypes.size() == 1) ?\n\t\t\t\t\t\t\tthis.mediaTypes.iterator().next().toString() :\n\t\t\t\t\t\t\tthis.mediaTypes.toString());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"Accept: %s\",\n\t\t\t\t\t(this.mediaTypes.size() == 1) ?\n\t\t\t\t\t\t\tthis.mediaTypes.iterator().next().toString() :\n\t\t\t\t\t\t\tthis.mediaTypes.toString());\n\t\t}\n\t}\n\n\n\tprivate static class PathExtensionPredicate implements RequestPredicate {\n\n\t\tprivate final Predicate<String> extensionPredicate;\n\n\t\t@Nullable\n\t\tprivate final String extension;\n\n\t\tpublic PathExtensionPredicate(Predicate<String> extensionPredicate) {\n\t\t\tAssert.notNull(extensionPredicate, \"Predicate must not be null\");\n\t\t\tthis.extensionPredicate = extensionPredicate;\n\t\t\tthis.extension = null;\n\t\t}\n\n\t\tpublic PathExtensionPredicate(String extension) {\n\t\t\tAssert.notNull(extension, \"Extension must not be null\");\n\n\t\t\tthis.extensionPredicate = s -> {\n\t\t\t\tboolean match = extension.equalsIgnoreCase(s);\n\t\t\t\ttraceMatch(\"Extension\", extension, s, match);\n\t\t\t\treturn match;\n\t\t\t};\n\t\t\tthis.extension = extension;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tString pathExtension = UriUtils.extractFileExtension(request.path());\n\t\t\treturn this.extensionPredicate.test(pathExtension);\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.pathExtension(\n\t\t\t\t\t(this.extension != null) ?\n\t\t\t\t\t\t\tthis.extension :\n\t\t\t\t\t\t\tthis.extensionPredicate.toString());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"*.%s\",\n\t\t\t\t\t(this.extension != null) ?\n\t\t\t\t\t\t\tthis.extension :\n\t\t\t\t\t\t\tthis.extensionPredicate);\n\t\t}\n\t}\n\n\n\tprivate static class QueryParamPredicate implements RequestPredicate {\n\n\t\tprivate final String name;\n\n\t\tprivate final Predicate<String> valuePredicate;\n\n\t\t@Nullable\n\t\tprivate final String value;\n\n\t\tpublic QueryParamPredicate(String name, Predicate<String> valuePredicate) {\n\t\t\tAssert.notNull(name, \"Name must not be null\");\n\t\t\tAssert.notNull(valuePredicate, \"Predicate must not be null\");\n\t\t\tthis.name = name;\n\t\t\tthis.valuePredicate = valuePredicate;\n\t\t\tthis.value = null;\n\t\t}\n\n\t\tpublic QueryParamPredicate(String name, String value) {\n\t\t\tAssert.notNull(name, \"Name must not be null\");\n\t\t\tAssert.notNull(value, \"Value must not be null\");\n\t\t\tthis.name = name;\n\t\t\tthis.valuePredicate = value::equals;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tOptional<String> s = request.queryParam(this.name);\n\t\t\treturn s.filter(this.valuePredicate).isPresent();\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.queryParam(this.name,\n\t\t\t\t\t(this.value != null) ?\n\t\t\t\t\t\t\tthis.value :\n\t\t\t\t\t\t\tthis.valuePredicate.toString());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"?%s %s\", this.name,\n\t\t\t\t\t(this.value != null) ?\n\t\t\t\t\t\t\tthis.value :\n\t\t\t\t\t\t\tthis.valuePredicate);\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link RequestPredicate} for where both {@code left} and {@code right} predicates\n\t * must match.\n\t */\n\tstatic class AndRequestPredicate extends RequestModifyingPredicate\n\t\t\timplements ChangePathPatternParserVisitor.Target {\n\n\t\tprivate final RequestPredicate left;\n\n\t\tprivate final RequestModifyingPredicate leftModifying;\n\n\t\tprivate final RequestPredicate right;\n\n\t\tprivate final RequestModifyingPredicate rightModifying;\n\n\n\t\tpublic AndRequestPredicate(RequestPredicate left, RequestPredicate right) {\n\t\t\tAssert.notNull(left, \"Left RequestPredicate must not be null\");\n\t\t\tAssert.notNull(right, \"Right RequestPredicate must not be null\");\n\t\t\tthis.left = left;\n\t\t\tthis.leftModifying = of(left);\n\t\t\tthis.right = right;\n\t\t\tthis.rightModifying = of(right);\n\t\t}\n\n\n\t\t@Override\n\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\tResult leftResult = this.leftModifying.testInternal(request);\n\t\t\tif (!leftResult.value()) {\n\t\t\t\treturn leftResult;\n\t\t\t}\n\t\t\t// ensure that attributes (and uri variables) set in left and available in right\n\t\t\tServerRequest rightRequest;\n\t\t\tif (leftResult.modifiesAttributes()) {\n\t\t\t\tMap<String, Object> leftAttributes = new LinkedHashMap<>(2);\n\t\t\t\tleftResult.modifyAttributes(leftAttributes);\n\t\t\t\trightRequest = new ExtendedAttributesServerRequestWrapper(request, leftAttributes);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trightRequest = request;\n\t\t\t}\n\t\t\tResult rightResult = this.rightModifying.testInternal(rightRequest);\n\t\t\tif (!rightResult.value()) {\n\t\t\t\treturn rightResult;\n\t\t\t}\n\t\t\treturn Result.of(true, attributes -> {\n\t\t\t\tleftResult.modifyAttributes(attributes);\n\t\t\t\trightResult.modifyAttributes(attributes);\n\t\t\t});\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<ServerRequest> nest(ServerRequest request) {\n\t\t\treturn this.left.nest(request).flatMap(this.right::nest);\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.startAnd();\n\t\t\tthis.left.accept(visitor);\n\t\t\tvisitor.and();\n\t\t\tthis.right.accept(visitor);\n\t\t\tvisitor.endAnd();\n\t\t}\n\n\t\t@Override\n\t\tpublic void changeParser(PathPatternParser parser) {\n\t\t\tif (this.left instanceof ChangePathPatternParserVisitor.Target target) {\n\t\t\t\ttarget.changeParser(parser);\n\t\t\t}\n\t\t\tif (this.right instanceof ChangePathPatternParserVisitor.Target target) {\n\t\t\t\ttarget.changeParser(parser);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"(%s && %s)\", this.left, this.right);\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link RequestPredicate} that negates a delegate predicate.\n\t */\n\tstatic class NegateRequestPredicate extends RequestModifyingPredicate\n\t\t\timplements ChangePathPatternParserVisitor.Target {\n\n\t\tprivate final RequestPredicate delegate;\n\n\t\tprivate final RequestModifyingPredicate delegateModifying;\n\n\n\t\tpublic NegateRequestPredicate(RequestPredicate delegate) {\n\t\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\t\tthis.delegate = delegate;\n\t\t\tthis.delegateModifying = of(delegate);\n\t\t}\n\n\n\t\t@Override\n\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\tResult result = this.delegateModifying.testInternal(request);\n\t\t\treturn Result.of(!result.value(), result::modifyAttributes);\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.startNegate();\n\t\t\tthis.delegate.accept(visitor);\n\t\t\tvisitor.endNegate();\n\t\t}\n\n\t\t@Override\n\t\tpublic void changeParser(PathPatternParser parser) {\n\t\t\tif (this.delegate instanceof ChangePathPatternParserVisitor.Target target) {\n\t\t\t\ttarget.changeParser(parser);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"!\" + this.delegate.toString();\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link RequestPredicate} where either {@code left} or {@code right} predicates\n\t * may match.\n\t */\n\tstatic class OrRequestPredicate extends RequestModifyingPredicate\n\t\t\timplements ChangePathPatternParserVisitor.Target {\n\n\t\tprivate final RequestPredicate left;\n\n\t\tprivate final RequestModifyingPredicate leftModifying;\n\n\t\tprivate final RequestPredicate right;\n\n\t\tprivate final RequestModifyingPredicate rightModifying;\n\n\n\t\tpublic OrRequestPredicate(RequestPredicate left, RequestPredicate right) {\n\t\t\tAssert.notNull(left, \"Left RequestPredicate must not be null\");\n\t\t\tAssert.notNull(right, \"Right RequestPredicate must not be null\");\n\t\t\tthis.left = left;\n\t\t\tthis.leftModifying = of(left);\n\t\t\tthis.right = right;\n\t\t\tthis.rightModifying = of(right);\n\t\t}\n\n\t\t@Override\n\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\tResult leftResult = this.leftModifying.testInternal(request);\n\t\t\tif (leftResult.value()) {\n\t\t\t\treturn leftResult;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.rightModifying.testInternal(request);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<ServerRequest> nest(ServerRequest request) {\n\t\t\tOptional<ServerRequest> leftResult = this.left.nest(request);\n\t\t\tif (leftResult.isPresent()) {\n\t\t\t\treturn leftResult;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.right.nest(request);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.startOr();\n\t\t\tthis.left.accept(visitor);\n\t\t\tvisitor.or();\n\t\t\tthis.right.accept(visitor);\n\t\t\tvisitor.endOr();\n\t\t}\n\n\t\t@Override\n\t\tpublic void changeParser(PathPatternParser parser) {\n\t\t\tif (this.left instanceof ChangePathPatternParserVisitor.Target target) {\n\t\t\t\ttarget.changeParser(parser);\n\t\t\t}\n\t\t\tif (this.right instanceof ChangePathPatternParserVisitor.Target target) {\n\t\t\t\ttarget.changeParser(parser);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"(%s || %s)\", this.left, this.right);\n\t\t}\n\t}\n\n\n\n\tprivate abstract static class DelegatingServerRequest implements ServerRequest {\n\n\t\tprivate final ServerRequest delegate;\n\n\n\t\tprotected DelegatingServerRequest(ServerRequest delegate) {\n\t\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\t\tthis.delegate = delegate;\n\t\t}\n\n\t\t@Override\n\t\tpublic HttpMethod method() {\n\t\t\treturn this.delegate.method();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic String methodName() {\n\t\t\treturn this.delegate.methodName();\n\t\t}\n\n\t\t@Override\n\t\tpublic URI uri() {\n\t\t\treturn this.delegate.uri();\n\t\t}\n\n\t\t@Override\n\t\tpublic UriBuilder uriBuilder() {\n\t\t\treturn this.delegate.uriBuilder();\n\t\t}\n\n\t\t@Override\n\t\tpublic String path() {\n\t\t\treturn this.delegate.path();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic PathContainer pathContainer() {\n\t\t\treturn this.delegate.pathContainer();\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestPath requestPath() {\n\t\t\treturn this.delegate.requestPath();\n\t\t}\n\n\t\t@Override\n\t\tpublic Headers headers() {\n\t\t\treturn this.delegate.headers();\n\t\t}\n\n\t\t@Override\n\t\tpublic MultiValueMap<String, HttpCookie> cookies() {\n\t\t\treturn this.delegate.cookies();\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<InetSocketAddress> remoteAddress() {\n\t\t\treturn this.delegate.remoteAddress();\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<InetSocketAddress> localAddress() {\n\t\t\treturn this.delegate.localAddress();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<HttpMessageReader<?>> messageReaders() {\n\t\t\treturn this.delegate.messageReaders();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor) {\n\t\t\treturn this.delegate.body(extractor);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T body(BodyExtractor<T, ? super ServerHttpRequest> extractor, Map<String, Object> hints) {\n\t\t\treturn this.delegate.body(extractor, hints);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Mono<T> bodyToMono(Class<? extends T> elementClass) {\n\t\t\treturn this.delegate.bodyToMono(elementClass);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Mono<T> bodyToMono(ParameterizedTypeReference<T> typeReference) {\n\t\t\treturn this.delegate.bodyToMono(typeReference);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Flux<T> bodyToFlux(Class<? extends T> elementClass) {\n\t\t\treturn this.delegate.bodyToFlux(elementClass);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Flux<T> bodyToFlux(ParameterizedTypeReference<T> typeReference) {\n\t\t\treturn this.delegate.bodyToFlux(typeReference);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Mono<T> bind(Class<T> bindType) {\n\t\t\treturn this.delegate.bind(bindType);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> Mono<T> bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) {\n\t\t\treturn this.delegate.bind(bindType, dataBinderCustomizer);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<Object> attribute(String name) {\n\t\t\treturn this.delegate.attribute(name);\n\t\t}\n\n\t\t@Override\n\t\tpublic Map<String, Object> attributes() {\n\t\t\treturn this.delegate.attributes();\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<String> queryParam(String name) {\n\t\t\treturn this.delegate.queryParam(name);\n\t\t}\n\n\t\t@Override\n\t\tpublic MultiValueMap<String, String> queryParams() {\n\t\t\treturn this.delegate.queryParams();\n\t\t}\n\n\t\t@Override\n\t\tpublic String pathVariable(String name) {\n\t\t\treturn this.delegate.pathVariable(name);\n\t\t}\n\n\t\t@Override\n\t\tpublic Map<String, String> pathVariables() {\n\t\t\treturn this.delegate.pathVariables();\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<WebSession> session() {\n\t\t\treturn this.delegate.session();\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<? extends Principal> principal() {\n\t\t\treturn this.delegate.principal();\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<MultiValueMap<String, String>> formData() {\n\t\t\treturn this.delegate.formData();\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<MultiValueMap<String, Part>> multipartData() {\n\t\t\treturn this.delegate.multipartData();\n\t\t}\n\n\t\t@Override\n\t\tpublic ServerWebExchange exchange() {\n\t\t\treturn this.delegate.exchange();\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<ServerResponse> checkNotModified(Instant lastModified) {\n\t\t\treturn this.delegate.checkNotModified(lastModified);\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<ServerResponse> checkNotModified(String etag) {\n\t\t\treturn this.delegate.checkNotModified(etag);\n\t\t}\n\n\t\t@Override\n\t\tpublic Mono<ServerResponse> checkNotModified(Instant lastModified, String etag) {\n\t\t\treturn this.delegate.checkNotModified(lastModified, etag);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"HTTP %s %s\", method(), path());\n\t\t}\n\t}\n\n\n\tprivate static class ExtendedAttributesServerRequestWrapper extends DelegatingServerRequest {\n\n\t\tprivate final Map<String, Object> attributes;\n\n\n\t\tpublic ExtendedAttributesServerRequestWrapper(ServerRequest delegate, Map<String, Object> newAttributes) {\n\t\t\tsuper(delegate);\n\t\t\tAssert.notNull(newAttributes, \"NewAttributes must not be null\");\n\t\t\tthis.attributes = mergeMaps(delegate.attributes(), newAttributes);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<Object> attribute(String name) {\n\t\t\treturn Optional.ofNullable(this.attributes.get(name));\n\t\t}\n\n\t\t@Override\n\t\tpublic Map<String, Object> attributes() {\n\t\t\treturn this.attributes;\n\t\t}\n\n\t\t@Override\n\t\tpublic String pathVariable(String name) {\n\t\t\tMap<String, String> pathVariables = pathVariables();\n\t\t\tif (pathVariables.containsKey(name)) {\n\t\t\t\treturn pathVariables().get(name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"No path variable with name \\\"\" + name + \"\\\" available\");\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Map<String, String> pathVariables() {\n\t\t\treturn (Map<String, String>) this.attributes.getOrDefault(\n\t\t\t\t\tRouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap());\n\t\t}\n\t}\n\n\n\tprivate static class NestedPathPatternServerRequestWrapper extends ExtendedAttributesServerRequestWrapper {\n\n\t\tprivate final RequestPath requestPath;\n\n\n\t\tpublic NestedPathPatternServerRequestWrapper(ServerRequest request,\n\t\t\t\tPathPattern.PathRemainingMatchInfo info, PathPattern pattern) {\n\t\t\tsuper(request, mergeAttributes(request, info.getUriVariables(), pattern));\n\t\t\tthis.requestPath = requestPath(request.requestPath(), info);\n\t\t}\n\n\t\tprivate static Map<String, Object> mergeAttributes(ServerRequest request, Map<String, String> newPathVariables,\n\t\t\t\tPathPattern newPathPattern) {\n\n\n\t\t\tMap<String, String> oldPathVariables = request.pathVariables();\n\t\t\tPathPattern oldPathPattern = (PathPattern) request.attribute(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE)\n\t\t\t\t\t.orElse(null);\n\n\t\t\tMap<String, Object> result = new LinkedHashMap<>(2);\n\t\t\tresult.put(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE, mergeMaps(oldPathVariables, newPathVariables));\n\t\t\tresult.put(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE, mergePatterns(oldPathPattern, newPathPattern));\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate static RequestPath requestPath(RequestPath original, PathPattern.PathRemainingMatchInfo info) {\n\t\t\tStringBuilder contextPath = new StringBuilder(original.contextPath().value());\n\t\t\tcontextPath.append(info.getPathMatched().value());\n\t\t\tint length = contextPath.length();\n\t\t\tif (length > 0 && contextPath.charAt(length - 1) == '/') {\n\t\t\t\tcontextPath.setLength(length - 1);\n\t\t\t}\n\t\t\treturn original.modifyContextPath(contextPath.toString());\n\t\t}\n\n\n\t\t@Override\n\t\tpublic RequestPath requestPath() {\n\t\t\treturn this.requestPath;\n\t\t}\n\n\t\t@Override\n\t\tpublic String path() {\n\t\t\treturn this.requestPath.pathWithinApplication().value();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic PathContainer pathContainer() {\n\t\t\treturn this.requestPath;\n\t\t}\n\t}\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "iterationData": [],
            "targetClassMap": {}
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "750cb739023a4ceb52e91ea66ce09f98638a8821",
        "url": "https://github.com/spring-projects/spring-framework/commit/750cb739023a4ceb52e91ea66ce09f98638a8821",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private method(request ServerRequest) : HttpMethod from class org.springframework.web.servlet.function.RequestPredicates.HttpMethodPredicate to package method(request ServerRequest) : HttpMethod from class org.springframework.web.servlet.function.RequestPredicates.SingleHttpMethodPredicate",
            "leftSideLocations": [
                {
                    "filePath": "spring-webmvc/src/main/java/org/springframework/web/servlet/function/RequestPredicates.java",
                    "startLine": 552,
                    "endLine": 561,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private method(request ServerRequest) : HttpMethod"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-webmvc/src/main/java/org/springframework/web/servlet/function/RequestPredicates.java",
                    "startLine": 562,
                    "endLine": 571,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "package method(request ServerRequest) : HttpMethod"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "becb2d58-20ba-402b-89f3-04c80ca70f67",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1245,
                "lineStart": 65,
                "lineEnd": 1309,
                "bodyLineStart": 65,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-webmvc/src/main/java/org/springframework/web/servlet/function/RequestPredicates.java",
                "sourceCode": "/**\n * Implementations of {@link RequestPredicate} that implement various useful\n * request matching operations, such as matching based on path, HTTP method, etc.\n *\n * @author Arjen Poutsma\n * @author Sam Brannen\n * @since 5.2\n */\npublic abstract class RequestPredicates {\n\n\tprivate static final Log logger = LogFactory.getLog(RequestPredicates.class);\n\n\n\t/**\n\t * Return a {@code RequestPredicate} that always matches.\n\t * @return a predicate that always matches\n\t */\n\tpublic static RequestPredicate all() {\n\t\treturn request -> true;\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's\n\t * HTTP method is equal to the given method.\n\t * @param httpMethod the HTTP method to match against\n\t * @return a predicate that tests against the given HTTP method\n\t */\n\tpublic static RequestPredicate method(HttpMethod httpMethod) {\n\t\treturn new HttpMethodPredicate(httpMethod);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's\n\t * HTTP method is equal to one the of the given methods.\n\t * @param httpMethods the HTTP methods to match against\n\t * @return a predicate that tests against the given HTTP methods\n\t */\n\tpublic static RequestPredicate methods(HttpMethod... httpMethods) {\n\t\treturn new HttpMethodPredicate(httpMethods);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that tests the request path\n\t * against the given path pattern.\n\t * @param pattern the pattern to match to\n\t * @return a predicate that tests against the given path pattern\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate path(String pattern) {\n\t\tAssert.notNull(pattern, \"'pattern' must not be null\");\n\t\tPathPatternParser parser = PathPatternParser.defaultInstance;\n\t\tpattern = parser.initFullPathPattern(pattern);\n\t\treturn pathPredicates(parser).apply(pattern);\n\t}\n\n\t/**\n\t * Return a function that creates new path-matching {@code RequestPredicates}\n\t * from pattern Strings using the given {@link PathPatternParser}.\n\t * <p>This method can be used to specify a non-default, customized\n\t * {@code PathPatternParser} when resolving path patterns.\n\t * @param patternParser the parser used to parse patterns given to the returned function\n\t * @return a function that resolves a pattern String into a path-matching\n\t * {@code RequestPredicates} instance\n\t */\n\tpublic static Function<String, RequestPredicate> pathPredicates(PathPatternParser patternParser) {\n\t\tAssert.notNull(patternParser, \"PathPatternParser must not be null\");\n\t\treturn pattern -> new PathPatternPredicate(patternParser.parse(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that tests the request's headers\n\t * against the given headers predicate.\n\t * @param headersPredicate a predicate that tests against the request headers\n\t * @return a predicate that tests against the given header predicate\n\t */\n\tpublic static RequestPredicate headers(Predicate<ServerRequest.Headers> headersPredicate) {\n\t\treturn new HeadersPredicate(headersPredicate);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that tests if the request's\n\t * {@linkplain ServerRequest.Headers#contentType() content type} is\n\t * {@linkplain MediaType#includes(MediaType) included} by any of the given media types.\n\t * @param mediaTypes the media types to match the request's content type against\n\t * @return a predicate that tests the request's content type against the given media types\n\t */\n\tpublic static RequestPredicate contentType(MediaType... mediaTypes) {\n\t\tAssert.notEmpty(mediaTypes, \"'mediaTypes' must not be empty\");\n\t\treturn new ContentTypePredicate(mediaTypes);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that tests if the request's\n\t * {@linkplain ServerRequest.Headers#accept() accept} header is\n\t * {@linkplain MediaType#isCompatibleWith(MediaType) compatible} with any of the given media types.\n\t * @param mediaTypes the media types to match the request's accept header against\n\t * @return a predicate that tests the request's accept header against the given media types\n\t */\n\tpublic static RequestPredicate accept(MediaType... mediaTypes) {\n\t\tAssert.notEmpty(mediaTypes, \"'mediaTypes' must not be empty\");\n\t\treturn new AcceptPredicate(mediaTypes);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code GET}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is GET and if the given pattern\n\t * matches against the request path\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate GET(String pattern) {\n\t\treturn method(HttpMethod.GET).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code HEAD}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is HEAD and if the given pattern\n\t * matches against the request path\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate HEAD(String pattern) {\n\t\treturn method(HttpMethod.HEAD).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code POST}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is POST and if the given pattern\n\t * matches against the request path\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate POST(String pattern) {\n\t\treturn method(HttpMethod.POST).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PUT}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is PUT and if the given pattern\n\t * matches against the request path\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate PUT(String pattern) {\n\t\treturn method(HttpMethod.PUT).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code PATCH}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is PATCH and if the given pattern\n\t * matches against the request path\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate PATCH(String pattern) {\n\t\treturn method(HttpMethod.PATCH).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code DELETE}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is DELETE and if the given pattern\n\t * matches against the request path\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate DELETE(String pattern) {\n\t\treturn method(HttpMethod.DELETE).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if request's HTTP method is {@code OPTIONS}\n\t * and the given {@code pattern} matches against the request path.\n\t * @param pattern the path pattern to match against\n\t * @return a predicate that matches if the request method is OPTIONS and if the given pattern\n\t * matches against the request path\n\t * @see org.springframework.web.util.pattern.PathPattern\n\t */\n\tpublic static RequestPredicate OPTIONS(String pattern) {\n\t\treturn method(HttpMethod.OPTIONS).and(path(pattern));\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's path has the given extension.\n\t * @param extension the path extension to match against, ignoring case\n\t * @return a predicate that matches if the request's path has the given file extension\n\t */\n\tpublic static RequestPredicate pathExtension(String extension) {\n\t\tAssert.notNull(extension, \"'extension' must not be null\");\n\t\treturn new PathExtensionPredicate(extension);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's path matches the given\n\t * predicate.\n\t * @param extensionPredicate the predicate to test against the request path extension\n\t * @return a predicate that matches if the given predicate matches against the request's path\n\t * file extension\n\t */\n\tpublic static RequestPredicate pathExtension(Predicate<String> extensionPredicate) {\n\t\treturn new PathExtensionPredicate(extensionPredicate);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that matches if the request's parameter of the given name\n\t * has the given value.\n\t * @param name the name of the parameter to test against\n\t * @param value the value of the parameter to test against\n\t * @return a predicate that matches if the parameter has the given value\n\t * @see ServerRequest#param(String)\n\t */\n\tpublic static RequestPredicate param(String name, String value) {\n\t\treturn new ParamPredicate(name, value);\n\t}\n\n\t/**\n\t * Return a {@code RequestPredicate} that tests the request's parameter of the given name\n\t * against the given predicate.\n\t * @param name the name of the parameter to test against\n\t * @param predicate the predicate to test against the parameter value\n\t * @return a predicate that matches the given predicate against the parameter of the given name\n\t * @see ServerRequest#param(String)\n\t */\n\tpublic static RequestPredicate param(String name, Predicate<String> predicate) {\n\t\treturn new ParamPredicate(name, predicate);\n\t}\n\n\n\tprivate static void traceMatch(String prefix, Object desired, @Nullable Object actual, boolean match) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(String.format(\"%s \\\"%s\\\" %s against value \\\"%s\\\"\",\n\t\t\t\t\tprefix, desired, match ? \"matches\" : \"does not match\", actual));\n\t\t}\n\t}\n\n\tprivate static PathPattern mergePatterns(@Nullable PathPattern oldPattern, PathPattern newPattern) {\n\t\tif (oldPattern != null) {\n\t\t\treturn oldPattern.combine(newPattern);\n\t\t}\n\t\telse {\n\t\t\treturn newPattern;\n\t\t}\n\t}\n\n\tprivate static <K, V> Map<K, V> mergeMaps(Map<K, V> left, Map<K, V> right) {\n\t\tif (left.isEmpty()) {\n\t\t\tif (right.isEmpty()) {\n\t\t\t\treturn Collections.emptyMap();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn right;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (right.isEmpty()) {\n\t\t\t\treturn left;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMap<K, V> result = CollectionUtils.newLinkedHashMap(left.size() + right.size());\n\t\t\t\tresult.putAll(left);\n\t\t\t\tresult.putAll(right);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Receives notifications from the logical structure of request predicates.\n\t */\n\tpublic interface Visitor {\n\n\t\t/**\n\t\t * Receive notification of an HTTP method predicate.\n\t\t * @param methods the HTTP methods that make up the predicate\n\t\t * @see RequestPredicates#method(HttpMethod)\n\t\t */\n\t\tvoid method(Set<HttpMethod> methods);\n\n\t\t/**\n\t\t * Receive notification of a path predicate.\n\t\t * @param pattern the path pattern that makes up the predicate\n\t\t * @see RequestPredicates#path(String)\n\t\t * @see org.springframework.web.util.pattern.PathPattern\n\t\t */\n\t\tvoid path(String pattern);\n\n\t\t/**\n\t\t * Receive notification of a path extension predicate.\n\t\t * @param extension the path extension that makes up the predicate\n\t\t * @see RequestPredicates#pathExtension(String)\n\t\t */\n\t\tvoid pathExtension(String extension);\n\n\t\t/**\n\t\t * Receive notification of an HTTP header predicate.\n\t\t * @param name the name of the HTTP header to check\n\t\t * @param value the desired value of the HTTP header\n\t\t * @see RequestPredicates#headers(Predicate)\n\t\t * @see RequestPredicates#contentType(MediaType...)\n\t\t * @see RequestPredicates#accept(MediaType...)\n\t\t */\n\t\tvoid header(String name, String value);\n\n\t\t/**\n\t\t * Receive notification of a parameter predicate.\n\t\t * @param name the name of the parameter\n\t\t * @param value the desired value of the parameter\n\t\t * @see RequestPredicates#param(String, String)\n\t\t */\n\t\tvoid param(String name, String value);\n\n\t\t/**\n\t\t * Receive first notification of a logical AND predicate.\n\t\t * The first subsequent notification will contain the left-hand side of the AND-predicate;\n\t\t * followed by {@link #and()}, followed by the right-hand side, followed by {@link #endAnd()}.\n\t\t * @see RequestPredicate#and(RequestPredicate)\n\t\t */\n\t\tvoid startAnd();\n\n\t\t/**\n\t\t * Receive \"middle\" notification of a logical AND predicate.\n\t\t * The following notification contains the right-hand side, followed by {@link #endAnd()}.\n\t\t * @see RequestPredicate#and(RequestPredicate)\n\t\t */\n\t\tvoid and();\n\n\t\t/**\n\t\t * Receive last notification of a logical AND predicate.\n\t\t * @see RequestPredicate#and(RequestPredicate)\n\t\t */\n\t\tvoid endAnd();\n\n\t\t/**\n\t\t * Receive first notification of a logical OR predicate.\n\t\t * The first subsequent notification will contain the left-hand side of the OR-predicate;\n\t\t * the second notification contains the right-hand side, followed by {@link #endOr()}.\n\t\t * @see RequestPredicate#or(RequestPredicate)\n\t\t */\n\t\tvoid startOr();\n\n\t\t/**\n\t\t * Receive \"middle\" notification of a logical OR predicate.\n\t\t * The following notification contains the right-hand side, followed by {@link #endOr()}.\n\t\t * @see RequestPredicate#or(RequestPredicate)\n\t\t */\n\t\tvoid or();\n\n\t\t/**\n\t\t * Receive last notification of a logical OR predicate.\n\t\t * @see RequestPredicate#or(RequestPredicate)\n\t\t */\n\t\tvoid endOr();\n\n\t\t/**\n\t\t * Receive first notification of a negated predicate.\n\t\t * The first subsequent notification will contain the negated predicated, followed\n\t\t * by {@link #endNegate()}.\n\t\t * @see RequestPredicate#negate()\n\t\t */\n\t\tvoid startNegate();\n\n\t\t/**\n\t\t * Receive last notification of a negated predicate.\n\t\t * @see RequestPredicate#negate()\n\t\t */\n\t\tvoid endNegate();\n\n\t\t/**\n\t\t * Receive first notification of an unknown predicate.\n\t\t */\n\t\tvoid unknown(RequestPredicate predicate);\n\t}\n\n\n\t/**\n\t * Extension of {@code RequestPredicate} that can modify the {@code ServerRequest}.\n\t */\n\tprivate abstract static class RequestModifyingPredicate implements RequestPredicate {\n\n\n\t\tpublic static RequestModifyingPredicate of(RequestPredicate requestPredicate) {\n\t\t\tif (requestPredicate instanceof RequestModifyingPredicate modifyingPredicate) {\n\t\t\t\treturn modifyingPredicate;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new RequestModifyingPredicate() {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\t\t\t\treturn Result.of(requestPredicate.test(request));\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\n\t\t@Override\n\t\tpublic final boolean test(ServerRequest request) {\n\t\t\tResult result = testInternal(request);\n\t\t\tboolean value = result.value();\n\t\t\tif (value) {\n\t\t\t\tresult.modifyAttributes(request.attributes());\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tprotected abstract Result testInternal(ServerRequest request);\n\n\n\t\tprotected static final class Result {\n\n\t\t\tprivate static final Result TRUE = new Result(true, null);\n\n\t\t\tprivate static final Result FALSE = new Result(false, null);\n\n\n\t\t\tprivate final boolean value;\n\n\t\t\t@Nullable\n\t\t\tprivate final Consumer<Map<String, Object>> modifyAttributes;\n\n\n\t\t\tprivate Result(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes) {\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.modifyAttributes = modifyAttributes;\n\t\t\t}\n\n\n\t\t\tpublic static Result of(boolean value) {\n\t\t\t\treturn of(value, null);\n\t\t\t}\n\n\t\t\tpublic static Result of(boolean value, @Nullable Consumer<Map<String, Object>> modifyAttributes) {\n\t\t\t\tif (modifyAttributes == null) {\n\t\t\t\t\treturn value ? TRUE : FALSE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new Result(value, modifyAttributes);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tpublic boolean value() {\n\t\t\t\treturn this.value;\n\t\t\t}\n\n\t\t\tpublic void modifyAttributes(Map<String, Object> attributes) {\n\t\t\t\tif (this.modifyAttributes != null) {\n\t\t\t\t\tthis.modifyAttributes.accept(attributes);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic boolean modifiesAttributes() {\n\t\t\t\treturn this.modifyAttributes != null;\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\tprivate static class HttpMethodPredicate implements RequestPredicate {\n\n\t\tprivate final Set<HttpMethod> httpMethods;\n\n\t\tpublic HttpMethodPredicate(HttpMethod httpMethod) {\n\t\t\tAssert.notNull(httpMethod, \"HttpMethod must not be null\");\n\t\t\tthis.httpMethods = Set.of(httpMethod);\n\t\t}\n\n\t\tpublic HttpMethodPredicate(HttpMethod... httpMethods) {\n\t\t\tAssert.notEmpty(httpMethods, \"HttpMethods must not be empty\");\n\t\t\tthis.httpMethods = new LinkedHashSet<>(Arrays.asList(httpMethods));\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tHttpMethod method = method(request);\n\t\t\tboolean match = this.httpMethods.contains(method);\n\t\t\ttraceMatch(\"Method\", this.httpMethods, method, match);\n\t\t\treturn match;\n\t\t}\n\n\t\tprivate static HttpMethod method(ServerRequest request) {\n\t\t\tif (CorsUtils.isPreFlightRequest(request.servletRequest())) {\n\t\t\t\tString accessControlRequestMethod =\n\t\t\t\t\t\trequest.headers().firstHeader(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD);\n\t\t\t\tif (accessControlRequestMethod != null) {\n\t\t\t\t\treturn HttpMethod.valueOf(accessControlRequestMethod);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn request.method();\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.method(Collections.unmodifiableSet(this.httpMethods));\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (this.httpMethods.size() == 1) {\n\t\t\t\treturn this.httpMethods.iterator().next().toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.httpMethods.toString();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate static class PathPatternPredicate extends RequestModifyingPredicate\n\t\t\timplements ChangePathPatternParserVisitor.Target {\n\n\t\tprivate PathPattern pattern;\n\n\n\t\tpublic PathPatternPredicate(PathPattern pattern) {\n\t\t\tAssert.notNull(pattern, \"'pattern' must not be null\");\n\t\t\tthis.pattern = pattern;\n\t\t}\n\n\n\t\t@Override\n\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\tPathContainer pathContainer = request.requestPath().pathWithinApplication();\n\t\t\tPathPattern.PathMatchInfo info = this.pattern.matchAndExtract(pathContainer);\n\t\t\ttraceMatch(\"Pattern\", this.pattern.getPatternString(), request.path(), info != null);\n\t\t\tif (info != null) {\n\t\t\t\treturn Result.of(true, attributes -> modifyAttributes(attributes, request, info.getUriVariables()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Result.of(false);\n\t\t\t}\n\t\t}\n\n\t\tprivate void modifyAttributes(Map<String, Object> attributes, ServerRequest request,\n\t\t\t\tMap<String, String> variables) {\n\n\t\t\tMap<String, String> pathVariables = mergeMaps(request.pathVariables(), variables);\n\n\t\t\tattributes.put(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE,\n\t\t\t\t\tCollections.unmodifiableMap(pathVariables));\n\n\t\t\tPathPattern pattern = mergePatterns(\n\t\t\t\t\t(PathPattern) attributes.get(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE),\n\t\t\t\t\tthis.pattern);\n\n\t\t\tattributes.put(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE, pattern);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<ServerRequest> nest(ServerRequest request) {\n\t\t\treturn Optional.ofNullable(this.pattern.matchStartOfPath(request.requestPath().pathWithinApplication()))\n\t\t\t\t\t.map(info -> new NestedPathPatternServerRequestWrapper(request, info, this.pattern));\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.path(this.pattern.getPatternString());\n\t\t}\n\n\t\t@Override\n\t\tpublic void changeParser(PathPatternParser parser) {\n\t\t\tString patternString = this.pattern.getPatternString();\n\t\t\tthis.pattern = parser.parse(patternString);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.pattern.getPatternString();\n\t\t}\n\t}\n\n\n\tprivate static class HeadersPredicate implements RequestPredicate {\n\n\t\tprivate final Predicate<ServerRequest.Headers> headersPredicate;\n\n\t\tpublic HeadersPredicate(Predicate<ServerRequest.Headers> headersPredicate) {\n\t\t\tAssert.notNull(headersPredicate, \"Predicate must not be null\");\n\t\t\tthis.headersPredicate = headersPredicate;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tif (CorsUtils.isPreFlightRequest(request.servletRequest())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.headersPredicate.test(request.headers());\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.headersPredicate.toString();\n\t\t}\n\t}\n\n\n\tprivate static class ContentTypePredicate extends HeadersPredicate {\n\n\t\tprivate final Set<MediaType> mediaTypes;\n\n\t\tpublic ContentTypePredicate(MediaType... mediaTypes) {\n\t\t\tthis(Set.of(mediaTypes));\n\t\t}\n\n\t\tprivate ContentTypePredicate(Set<MediaType> mediaTypes) {\n\t\t\tsuper(headers -> {\n\t\t\t\tMediaType contentType =\n\t\t\t\t\t\theaders.contentType().orElse(MediaType.APPLICATION_OCTET_STREAM);\n\t\t\t\tboolean match = mediaTypes.stream()\n\t\t\t\t\t\t.anyMatch(mediaType -> mediaType.includes(contentType));\n\t\t\t\ttraceMatch(\"Content-Type\", mediaTypes, contentType, match);\n\t\t\t\treturn match;\n\t\t\t});\n\t\t\tthis.mediaTypes = mediaTypes;\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.header(HttpHeaders.CONTENT_TYPE,\n\t\t\t\t\t(this.mediaTypes.size() == 1) ?\n\t\t\t\t\t\t\tthis.mediaTypes.iterator().next().toString() :\n\t\t\t\t\t\t\tthis.mediaTypes.toString());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"Content-Type: %s\",\n\t\t\t\t\t(this.mediaTypes.size() == 1) ?\n\t\t\t\t\t\t\tthis.mediaTypes.iterator().next().toString() :\n\t\t\t\t\t\t\tthis.mediaTypes.toString());\n\t\t}\n\t}\n\n\n\tprivate static class AcceptPredicate extends HeadersPredicate {\n\n\t\tprivate final Set<MediaType> mediaTypes;\n\n\t\tpublic AcceptPredicate(MediaType... mediaTypes) {\n\t\t\tthis(Set.of(mediaTypes));\n\t\t}\n\n\t\tprivate AcceptPredicate(Set<MediaType> mediaTypes) {\n\t\t\tsuper(headers -> {\n\t\t\t\tList<MediaType> acceptedMediaTypes = acceptedMediaTypes(headers);\n\t\t\t\tboolean match = acceptedMediaTypes.stream()\n\t\t\t\t\t\t.anyMatch(acceptedMediaType -> mediaTypes.stream()\n\t\t\t\t\t\t\t\t.anyMatch(acceptedMediaType::isCompatibleWith));\n\t\t\t\ttraceMatch(\"Accept\", mediaTypes, acceptedMediaTypes, match);\n\t\t\t\treturn match;\n\t\t\t});\n\t\t\tthis.mediaTypes = mediaTypes;\n\t\t}\n\n\t\t@NonNull\n\t\tprivate static List<MediaType> acceptedMediaTypes(ServerRequest.Headers headers) {\n\t\t\tList<MediaType> acceptedMediaTypes = headers.accept();\n\t\t\tif (acceptedMediaTypes.isEmpty()) {\n\t\t\t\tacceptedMediaTypes = Collections.singletonList(MediaType.ALL);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMimeTypeUtils.sortBySpecificity(acceptedMediaTypes);\n\t\t\t}\n\t\t\treturn acceptedMediaTypes;\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.header(HttpHeaders.ACCEPT,\n\t\t\t\t\t(this.mediaTypes.size() == 1) ?\n\t\t\t\t\t\t\tthis.mediaTypes.iterator().next().toString() :\n\t\t\t\t\t\t\tthis.mediaTypes.toString());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"Accept: %s\",\n\t\t\t\t\t(this.mediaTypes.size() == 1) ?\n\t\t\t\t\t\t\tthis.mediaTypes.iterator().next().toString() :\n\t\t\t\t\t\t\tthis.mediaTypes.toString());\n\t\t}\n\t}\n\n\n\tprivate static class PathExtensionPredicate implements RequestPredicate {\n\n\t\tprivate final Predicate<String> extensionPredicate;\n\n\t\t@Nullable\n\t\tprivate final String extension;\n\n\t\tpublic PathExtensionPredicate(Predicate<String> extensionPredicate) {\n\t\t\tAssert.notNull(extensionPredicate, \"Predicate must not be null\");\n\t\t\tthis.extensionPredicate = extensionPredicate;\n\t\t\tthis.extension = null;\n\t\t}\n\n\t\tpublic PathExtensionPredicate(String extension) {\n\t\t\tAssert.notNull(extension, \"Extension must not be null\");\n\n\t\t\tthis.extensionPredicate = s -> {\n\t\t\t\tboolean match = extension.equalsIgnoreCase(s);\n\t\t\t\ttraceMatch(\"Extension\", extension, s, match);\n\t\t\t\treturn match;\n\t\t\t};\n\t\t\tthis.extension = extension;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tString pathExtension = UriUtils.extractFileExtension(request.path());\n\t\t\treturn this.extensionPredicate.test(pathExtension);\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.pathExtension(\n\t\t\t\t\t(this.extension != null) ?\n\t\t\t\t\t\t\tthis.extension :\n\t\t\t\t\t\t\tthis.extensionPredicate.toString());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"*.%s\",\n\t\t\t\t\t(this.extension != null) ?\n\t\t\t\t\t\t\tthis.extension :\n\t\t\t\t\t\t\tthis.extensionPredicate);\n\t\t}\n\t}\n\n\n\tprivate static class ParamPredicate implements RequestPredicate {\n\n\t\tprivate final String name;\n\n\t\tprivate final Predicate<String> valuePredicate;\n\n\t\t@Nullable\n\t\tprivate final String value;\n\n\t\tpublic ParamPredicate(String name, Predicate<String> valuePredicate) {\n\t\t\tAssert.notNull(name, \"Name must not be null\");\n\t\t\tAssert.notNull(valuePredicate, \"Predicate must not be null\");\n\t\t\tthis.name = name;\n\t\t\tthis.valuePredicate = valuePredicate;\n\t\t\tthis.value = null;\n\t\t}\n\n\t\tpublic ParamPredicate(String name, String value) {\n\t\t\tAssert.notNull(name, \"Name must not be null\");\n\t\t\tAssert.notNull(value, \"Value must not be null\");\n\t\t\tthis.name = name;\n\t\t\tthis.valuePredicate = value::equals;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(ServerRequest request) {\n\t\t\tOptional<String> s = request.param(this.name);\n\t\t\treturn s.filter(this.valuePredicate).isPresent();\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.param(this.name,\n\t\t\t\t\t(this.value != null) ?\n\t\t\t\t\t\t\tthis.value :\n\t\t\t\t\t\t\tthis.valuePredicate.toString());\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"?%s %s\", this.name,\n\t\t\t\t\t(this.value != null) ?\n\t\t\t\t\t\t\tthis.value :\n\t\t\t\t\t\t\tthis.valuePredicate);\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link RequestPredicate} for where both {@code left} and {@code right} predicates\n\t * must match.\n\t */\n\tstatic class AndRequestPredicate extends RequestModifyingPredicate\n\t\t\timplements ChangePathPatternParserVisitor.Target {\n\n\t\tprivate final RequestPredicate left;\n\n\t\tprivate final RequestModifyingPredicate leftModifying;\n\n\t\tprivate final RequestPredicate right;\n\n\t\tprivate final RequestModifyingPredicate rightModifying;\n\n\n\t\tpublic AndRequestPredicate(RequestPredicate left, RequestPredicate right) {\n\t\t\tAssert.notNull(left, \"Left RequestPredicate must not be null\");\n\t\t\tAssert.notNull(right, \"Right RequestPredicate must not be null\");\n\t\t\tthis.left = left;\n\t\t\tthis.leftModifying = of(left);\n\t\t\tthis.right = right;\n\t\t\tthis.rightModifying = of(right);\n\t\t}\n\n\n\t\t@Override\n\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\tResult leftResult = this.leftModifying.testInternal(request);\n\t\t\tif (!leftResult.value()) {\n\t\t\t\treturn leftResult;\n\t\t\t}\n\t\t\t// ensure that attributes (and uri variables) set in left and available in right\n\t\t\tServerRequest rightRequest;\n\t\t\tif (leftResult.modifiesAttributes()) {\n\t\t\t\tMap<String, Object> leftAttributes = new LinkedHashMap<>(2);\n\t\t\t\tleftResult.modifyAttributes(leftAttributes);\n\t\t\t\trightRequest = new ExtendedAttributesServerRequestWrapper(request, leftAttributes);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trightRequest = request;\n\t\t\t}\n\t\t\tResult rightResult = this.rightModifying.testInternal(rightRequest);\n\t\t\tif (!rightResult.value()) {\n\t\t\t\treturn rightResult;\n\t\t\t}\n\t\t\treturn Result.of(true, attributes -> {\n\t\t\t\tleftResult.modifyAttributes(attributes);\n\t\t\t\trightResult.modifyAttributes(attributes);\n\t\t\t});\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<ServerRequest> nest(ServerRequest request) {\n\t\t\treturn this.left.nest(request).flatMap(this.right::nest);\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.startAnd();\n\t\t\tthis.left.accept(visitor);\n\t\t\tvisitor.and();\n\t\t\tthis.right.accept(visitor);\n\t\t\tvisitor.endAnd();\n\t\t}\n\n\t\t@Override\n\t\tpublic void changeParser(PathPatternParser parser) {\n\t\t\tif (this.left instanceof ChangePathPatternParserVisitor.Target target) {\n\t\t\t\ttarget.changeParser(parser);\n\t\t\t}\n\t\t\tif (this.right instanceof ChangePathPatternParserVisitor.Target target) {\n\t\t\t\ttarget.changeParser(parser);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"(%s && %s)\", this.left, this.right);\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link RequestPredicate} that negates a delegate predicate.\n\t */\n\tstatic class NegateRequestPredicate extends RequestModifyingPredicate\n\t\t\timplements ChangePathPatternParserVisitor.Target {\n\n\t\tprivate final RequestPredicate delegate;\n\n\t\tprivate final RequestModifyingPredicate delegateModifying;\n\n\n\t\tpublic NegateRequestPredicate(RequestPredicate delegate) {\n\t\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\t\tthis.delegate = delegate;\n\t\t\tthis.delegateModifying = of(delegate);\n\t\t}\n\n\n\t\t@Override\n\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\tResult result = this.delegateModifying.testInternal(request);\n\t\t\treturn Result.of(!result.value(), result::modifyAttributes);\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.startNegate();\n\t\t\tthis.delegate.accept(visitor);\n\t\t\tvisitor.endNegate();\n\t\t}\n\n\t\t@Override\n\t\tpublic void changeParser(PathPatternParser parser) {\n\t\t\tif (this.delegate instanceof ChangePathPatternParserVisitor.Target target) {\n\t\t\t\ttarget.changeParser(parser);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"!\" + this.delegate.toString();\n\t\t}\n\t}\n\n\n\t/**\n\t * {@link RequestPredicate} where either {@code left} or {@code right} predicates\n\t * may match.\n\t */\n\tstatic class OrRequestPredicate extends RequestModifyingPredicate\n\t\t\timplements ChangePathPatternParserVisitor.Target {\n\n\t\tprivate final RequestPredicate left;\n\n\t\tprivate final RequestModifyingPredicate leftModifying;\n\n\t\tprivate final RequestPredicate right;\n\n\t\tprivate final RequestModifyingPredicate rightModifying;\n\n\n\t\tpublic OrRequestPredicate(RequestPredicate left, RequestPredicate right) {\n\t\t\tAssert.notNull(left, \"Left RequestPredicate must not be null\");\n\t\t\tAssert.notNull(right, \"Right RequestPredicate must not be null\");\n\t\t\tthis.left = left;\n\t\t\tthis.leftModifying = of(left);\n\t\t\tthis.right = right;\n\t\t\tthis.rightModifying = of(right);\n\t\t}\n\n\t\t@Override\n\t\tprotected Result testInternal(ServerRequest request) {\n\t\t\tResult leftResult = this.leftModifying.testInternal(request);\n\t\t\tif (leftResult.value()) {\n\t\t\t\treturn leftResult;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.rightModifying.testInternal(request);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<ServerRequest> nest(ServerRequest request) {\n\t\t\tOptional<ServerRequest> leftResult = this.left.nest(request);\n\t\t\tif (leftResult.isPresent()) {\n\t\t\t\treturn leftResult;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.right.nest(request);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void accept(Visitor visitor) {\n\t\t\tvisitor.startOr();\n\t\t\tthis.left.accept(visitor);\n\t\t\tvisitor.or();\n\t\t\tthis.right.accept(visitor);\n\t\t\tvisitor.endOr();\n\t\t}\n\n\t\t@Override\n\t\tpublic void changeParser(PathPatternParser parser) {\n\t\t\tif (this.left instanceof ChangePathPatternParserVisitor.Target target) {\n\t\t\t\ttarget.changeParser(parser);\n\t\t\t}\n\t\t\tif (this.right instanceof ChangePathPatternParserVisitor.Target target) {\n\t\t\t\ttarget.changeParser(parser);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"(%s || %s)\", this.left, this.right);\n\t\t}\n\t}\n\n\n\n\tprivate abstract static class DelegatingServerRequest implements ServerRequest {\n\n\t\tprivate final ServerRequest delegate;\n\n\n\t\tprotected DelegatingServerRequest(ServerRequest delegate) {\n\t\t\tAssert.notNull(delegate, \"Delegate must not be null\");\n\t\t\tthis.delegate = delegate;\n\t\t}\n\n\t\t@Override\n\t\tpublic HttpMethod method() {\n\t\t\treturn this.delegate.method();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic String methodName() {\n\t\t\treturn this.delegate.methodName();\n\t\t}\n\n\t\t@Override\n\t\tpublic URI uri() {\n\t\t\treturn this.delegate.uri();\n\t\t}\n\n\t\t@Override\n\t\tpublic UriBuilder uriBuilder() {\n\t\t\treturn this.delegate.uriBuilder();\n\t\t}\n\n\t\t@Override\n\t\tpublic String path() {\n\t\t\treturn this.delegate.path();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic PathContainer pathContainer() {\n\t\t\treturn this.delegate.pathContainer();\n\t\t}\n\n\t\t@Override\n\t\tpublic RequestPath requestPath() {\n\t\t\treturn this.delegate.requestPath();\n\t\t}\n\n\t\t@Override\n\t\tpublic Headers headers() {\n\t\t\treturn this.delegate.headers();\n\t\t}\n\n\t\t@Override\n\t\tpublic MultiValueMap<String, Cookie> cookies() {\n\t\t\treturn this.delegate.cookies();\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<InetSocketAddress> remoteAddress() {\n\t\t\treturn this.delegate.remoteAddress();\n\t\t}\n\n\t\t@Override\n\t\tpublic List<HttpMessageConverter<?>> messageConverters() {\n\t\t\treturn this.delegate.messageConverters();\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T body(Class<T> bodyType) throws ServletException, IOException {\n\t\t\treturn this.delegate.body(bodyType);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T body(ParameterizedTypeReference<T> bodyType) throws ServletException, IOException {\n\t\t\treturn this.delegate.body(bodyType);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T bind(Class<T> bindType) throws BindException {\n\t\t\treturn this.delegate.bind(bindType);\n\t\t}\n\n\t\t@Override\n\t\tpublic <T> T bind(Class<T> bindType, Consumer<WebDataBinder> dataBinderCustomizer) throws BindException {\n\t\t\treturn this.delegate.bind(bindType, dataBinderCustomizer);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<Object> attribute(String name) {\n\t\t\treturn this.delegate.attribute(name);\n\t\t}\n\n\t\t@Override\n\t\tpublic Map<String, Object> attributes() {\n\t\t\treturn this.delegate.attributes();\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<String> param(String name) {\n\t\t\treturn this.delegate.param(name);\n\t\t}\n\n\t\t@Override\n\t\tpublic MultiValueMap<String, String> params() {\n\t\t\treturn this.delegate.params();\n\t\t}\n\n\t\t@Override\n\t\tpublic MultiValueMap<String, Part> multipartData() throws IOException, ServletException {\n\t\t\treturn this.delegate.multipartData();\n\t\t}\n\n\t\t@Override\n\t\tpublic String pathVariable(String name) {\n\t\t\treturn this.delegate.pathVariable(name);\n\t\t}\n\n\t\t@Override\n\t\tpublic Map<String, String> pathVariables() {\n\t\t\treturn this.delegate.pathVariables();\n\t\t}\n\n\t\t@Override\n\t\tpublic HttpSession session() {\n\t\t\treturn this.delegate.session();\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<Principal> principal() {\n\t\t\treturn this.delegate.principal();\n\t\t}\n\n\t\t@Override\n\t\tpublic HttpServletRequest servletRequest() {\n\t\t\treturn this.delegate.servletRequest();\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<ServerResponse> checkNotModified(Instant lastModified) {\n\t\t\treturn this.delegate.checkNotModified(lastModified);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<ServerResponse> checkNotModified(String etag) {\n\t\t\treturn this.delegate.checkNotModified(etag);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<ServerResponse> checkNotModified(Instant lastModified, String etag) {\n\t\t\treturn this.delegate.checkNotModified(lastModified, etag);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.delegate.toString();\n\t\t}\n\t}\n\n\n\tprivate static class ExtendedAttributesServerRequestWrapper extends DelegatingServerRequest {\n\n\t\tprivate final Map<String, Object> attributes;\n\n\n\t\tpublic ExtendedAttributesServerRequestWrapper(ServerRequest delegate, Map<String, Object> newAttributes) {\n\t\t\tsuper(delegate);\n\t\t\tAssert.notNull(newAttributes, \"NewAttributes must not be null\");\n\t\t\tthis.attributes = mergeMaps(delegate.attributes(), newAttributes);\n\t\t}\n\n\t\t@Override\n\t\tpublic Optional<Object> attribute(String name) {\n\t\t\treturn Optional.ofNullable(this.attributes.get(name));\n\t\t}\n\n\t\t@Override\n\t\tpublic Map<String, Object> attributes() {\n\t\t\treturn this.attributes;\n\t\t}\n\n\t\t@Override\n\t\tpublic String pathVariable(String name) {\n\t\t\tMap<String, String> pathVariables = pathVariables();\n\t\t\tif (pathVariables.containsKey(name)) {\n\t\t\t\treturn pathVariables().get(name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"No path variable with name \\\"\" + name + \"\\\" available\");\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Map<String, String> pathVariables() {\n\t\t\treturn (Map<String, String>) this.attributes.getOrDefault(\n\t\t\t\t\tRouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE, Collections.emptyMap());\n\t\t}\n\t}\n\n\n\tprivate static class NestedPathPatternServerRequestWrapper extends ExtendedAttributesServerRequestWrapper {\n\n\t\tprivate final RequestPath requestPath;\n\n\n\t\tpublic NestedPathPatternServerRequestWrapper(ServerRequest request,\n\t\t\t\tPathPattern.PathRemainingMatchInfo info, PathPattern pattern) {\n\t\t\tsuper(request, mergeAttributes(request, info.getUriVariables(), pattern));\n\t\t\tthis.requestPath = requestPath(request.requestPath(), info);\n\t\t}\n\n\t\tprivate static Map<String, Object> mergeAttributes(ServerRequest request, Map<String, String> newPathVariables,\n\t\t\t\tPathPattern newPathPattern) {\n\n\n\t\t\tMap<String, String> oldPathVariables = request.pathVariables();\n\t\t\tPathPattern oldPathPattern = (PathPattern) request.attribute(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE)\n\t\t\t\t\t.orElse(null);\n\n\t\t\tMap<String, Object> result = CollectionUtils.newLinkedHashMap(2);\n\t\t\tresult.put(RouterFunctions.URI_TEMPLATE_VARIABLES_ATTRIBUTE, mergeMaps(oldPathVariables, newPathVariables));\n\t\t\tresult.put(RouterFunctions.MATCHING_PATTERN_ATTRIBUTE, mergePatterns(oldPathPattern, newPathPattern));\n\t\t\treturn result;\n\t\t}\n\n\t\tprivate static RequestPath requestPath(RequestPath original, PathPattern.PathRemainingMatchInfo info) {\n\t\t\tStringBuilder contextPath = new StringBuilder(original.contextPath().value());\n\t\t\tcontextPath.append(info.getPathMatched().value());\n\t\t\tint length = contextPath.length();\n\t\t\tif (length > 0 && contextPath.charAt(length - 1) == '/') {\n\t\t\t\tcontextPath.setLength(length - 1);\n\t\t\t}\n\t\t\treturn original.modifyContextPath(contextPath.toString());\n\t\t}\n\n\n\t\t@Override\n\t\tpublic RequestPath requestPath() {\n\t\t\treturn this.requestPath;\n\t\t}\n\n\t\t@Override\n\t\tpublic String path() {\n\t\t\treturn this.requestPath.pathWithinApplication().value();\n\t\t}\n\n\t\t@Override\n\t\t@Deprecated\n\t\tpublic PathContainer pathContainer() {\n\t\t\treturn this.requestPath;\n\t\t}\n\t}\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "iterationData": [],
            "targetClassMap": {}
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "38c831f15fadef0f5ca4ecf032a5d4ccdb293e90",
        "url": "https://github.com/spring-projects/spring-framework/commit/38c831f15fadef0f5ca4ecf032a5d4ccdb293e90",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method public findPublicDeclaringClass(method Method) : Class<?> from class org.springframework.expression.spel.support.ReflectionHelper to public findPublicDeclaringClass(method Method) : Class<?> from class org.springframework.expression.spel.CodeFlow",
            "leftSideLocations": [
                {
                    "filePath": "spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectionHelper.java",
                    "startLine": 502,
                    "endLine": 539,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "public findPublicDeclaringClass(method Method) : Class<?>"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-expression/src/main/java/org/springframework/expression/spel/CodeFlow.java",
                    "startLine": 412,
                    "endLine": 449,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "public findPublicDeclaringClass(method Method) : Class<?>"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "aff952de-8e22-47d2-a3ed-2b4c8fa7f7b9",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 567,
                "lineStart": 42,
                "lineEnd": 608,
                "bodyLineStart": 42,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectionHelper.java",
                "sourceCode": "/**\n * Utility methods used by the reflection resolver code to discover the appropriate\n * methods, constructors, and fields that should be used in expressions.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 3.0\n */\npublic abstract class ReflectionHelper {\n\n\t/**\n\t * Cache for equivalent methods in a public declaring class in the type\n\t * hierarchy of the method's declaring class.\n\t * @since 6.2\n\t */\n\tprivate static final Map<Method, Class<?>> publicDeclaringClassCache = new ConcurrentReferenceHashMap<>(256);\n\n\n\t/**\n\t * Compare argument arrays and return information about whether they match.\n\t * <p>A supplied type converter and conversionAllowed flag allow for matches to take\n\t * into account that a type may be transformed into a different type by the converter.\n\t * @param expectedArgTypes the types the method/constructor is expecting\n\t * @param suppliedArgTypes the types that are being supplied at the point of invocation\n\t * @param typeConverter a registered type converter\n\t * @return a MatchInfo object indicating what kind of match it was,\n\t * or {@code null} if it was not a match\n\t */\n\t@Nullable\n\tstatic ArgumentsMatchInfo compareArguments(\n\t\t\tList<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {\n\n\t\tAssert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),\n\t\t\t\t\"Expected argument types and supplied argument types should be arrays of same length\");\n\n\t\tArgumentsMatchKind match = ArgumentsMatchKind.EXACT;\n\t\tfor (int i = 0; i < expectedArgTypes.size() && match != null; i++) {\n\t\t\tTypeDescriptor suppliedArg = suppliedArgTypes.get(i);\n\t\t\tTypeDescriptor expectedArg = expectedArgTypes.get(i);\n\t\t\t// The user may supply null, and that will be OK unless a primitive is expected.\n\t\t\tif (suppliedArg == null) {\n\t\t\t\tif (expectedArg.isPrimitive()) {\n\t\t\t\t\tmatch = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!expectedArg.equals(suppliedArg)) {\n\t\t\t\tif (suppliedArg.isAssignableTo(expectedArg)) {\n\t\t\t\t\tif (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {\n\t\t\t\t\t\tmatch = ArgumentsMatchKind.CLOSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (typeConverter.canConvert(suppliedArg, expectedArg)) {\n\t\t\t\t\tmatch = ArgumentsMatchKind.REQUIRES_CONVERSION;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmatch = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (match != null ? new ArgumentsMatchInfo(match) : null);\n\t}\n\n\t/**\n\t * Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.\n\t */\n\tpublic static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < paramTypes.size(); i++) {\n\t\t\tTypeDescriptor paramType = paramTypes.get(i);\n\t\t\tTypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null);\n\t\t\tif (argType == null) {\n\t\t\t\tif (paramType.isPrimitive()) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tClass<?> paramTypeClazz = paramType.getType();\n\t\t\t\tif (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isPrimitive()) {\n\t\t\t\t\tparamTypeClazz = Object.class;\n\t\t\t\t}\n\t\t\t\tClass<?> superClass = argType.getType().getSuperclass();\n\t\t\t\twhile (superClass != null) {\n\t\t\t\t\tif (paramTypeClazz.equals(superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = superClass.getSuperclass();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isInterface()) {\n\t\t\t\t\tresult = result + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Compare argument arrays and return information about whether they match.\n\t * <p>A supplied type converter and conversionAllowed flag allow for matches to\n\t * take into account that a type may be transformed into a different type by the\n\t * converter. This variant of {@link #compareArguments} also allows for a varargs match.\n\t * @param expectedArgTypes the types the method/constructor is expecting\n\t * @param suppliedArgTypes the types that are being supplied at the point of invocation\n\t * @param typeConverter a registered type converter\n\t * @return a MatchInfo object indicating what kind of match it was,\n\t * or {@code null} if it was not a match\n\t */\n\t@Nullable\n\tstatic ArgumentsMatchInfo compareArgumentsVarargs(\n\t\t\tList<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {\n\n\t\tAssert.isTrue(!CollectionUtils.isEmpty(expectedArgTypes),\n\t\t\t\t\"Expected arguments must at least include one array (the varargs parameter)\");\n\t\tAssert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),\n\t\t\t\t\"Final expected argument should be array type (the varargs parameter)\");\n\n\t\tArgumentsMatchKind match = ArgumentsMatchKind.EXACT;\n\n\t\t// Check up until the varargs argument:\n\n\t\t// Deal with the arguments up to 'expected number' - 1 (that is everything but the varargs argument)\n\t\tint argCountUpToVarargs = expectedArgTypes.size() - 1;\n\t\tfor (int i = 0; i < argCountUpToVarargs && match != null; i++) {\n\t\t\tTypeDescriptor suppliedArg = suppliedArgTypes.get(i);\n\t\t\tTypeDescriptor expectedArg = expectedArgTypes.get(i);\n\t\t\tif (suppliedArg == null) {\n\t\t\t\tif (expectedArg.isPrimitive()) {\n\t\t\t\t\tmatch = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!expectedArg.equals(suppliedArg)) {\n\t\t\t\t\tif (suppliedArg.isAssignableTo(expectedArg)) {\n\t\t\t\t\t\tif (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {\n\t\t\t\t\t\t\tmatch = ArgumentsMatchKind.CLOSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeConverter.canConvert(suppliedArg, expectedArg)) {\n\t\t\t\t\t\tmatch = ArgumentsMatchKind.REQUIRES_CONVERSION;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmatch = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If already confirmed it cannot be a match, then return\n\t\tif (match == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (suppliedArgTypes.size() == expectedArgTypes.size() &&\n\t\t\t\texpectedArgTypes.get(expectedArgTypes.size() - 1).equals(\n\t\t\t\t\t\tsuppliedArgTypes.get(suppliedArgTypes.size() - 1))) {\n\t\t\t// Special case: there is one parameter left and it is an array and it matches the varargs\n\t\t\t// expected argument - that is a match, the caller has already built the array. Proceed with it.\n\t\t}\n\t\telse {\n\t\t\t// Now... we have the final argument in the method we are checking as a match and we have 0\n\t\t\t// or more other arguments left to pass to it.\n\t\t\tTypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1);\n\t\t\tTypeDescriptor elementDesc = varargsDesc.getElementTypeDescriptor();\n\t\t\tAssert.state(elementDesc != null, \"No element type\");\n\t\t\tClass<?> varargsParamType = elementDesc.getType();\n\n\t\t\t// All remaining parameters must be of this type or convertible to this type\n\t\t\tfor (int i = expectedArgTypes.size() - 1; i < suppliedArgTypes.size(); i++) {\n\t\t\t\tTypeDescriptor suppliedArg = suppliedArgTypes.get(i);\n\t\t\t\tif (suppliedArg == null) {\n\t\t\t\t\tif (varargsParamType.isPrimitive()) {\n\t\t\t\t\t\tmatch = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (varargsParamType != suppliedArg.getType()) {\n\t\t\t\t\t\tif (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {\n\t\t\t\t\t\t\tif (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {\n\t\t\t\t\t\t\t\tmatch = ArgumentsMatchKind.CLOSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {\n\t\t\t\t\t\t\tmatch = ArgumentsMatchKind.REQUIRES_CONVERSION;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tmatch = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (match != null ? new ArgumentsMatchInfo(match) : null);\n\t}\n\n\t/**\n\t * Convert the supplied set of arguments into the parameter types specified\n\t * by the supplied {@link Method}.\n\t * <p>The arguments are converted 'in-place' in the input array.\n\t * <p>If the method accepts varargs, the final entry in its parameterTypes\n\t * array is going to be an array itself whose component type will be used as\n\t * the conversion target for any additional arguments. For example, if the\n\t * parameterTypes are {Integer, String[]} and the input arguments are\n\t * {Integer, boolean, float}, then both the boolean and float must be converted\n\t * to strings.\n\t * <p>This method does <strong>not</strong> repackage the arguments into a\n\t * form suitable for the varargs invocation. A subsequent call to\n\t * {@link #setupArgumentsForVarargsInvocation(Class[], Object...)} must be\n\t * used for that.\n\t * @param converter the converter to use for type conversions\n\t * @param arguments the arguments to convert to the parameter types of the\n\t * target method\n\t * @param method the target method\n\t * @return true if some kind of conversion occurred on an argument\n\t * @throws SpelEvaluationException if there is a problem with conversion\n\t */\n\tpublic static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)\n\t\t\tthrows SpelEvaluationException {\n\n\t\tInteger varargsPosition = (method.isVarArgs() ? method.getParameterCount() - 1 : null);\n\t\treturn convertArguments(converter, arguments, method, varargsPosition);\n\t}\n\n\t/**\n\t * Takes an input set of argument values and converts them to the parameter\n\t * types of the supplied {@link Executable} (i.e., constructor or method).\n\t * <p>The arguments are converted 'in-place' in the input array.\n\t * @param converter the type converter to use for attempting conversions\n\t * @param arguments the actual arguments that need conversion\n\t * @param executable the target Method or Constructor\n\t * @param varargsPosition the known position of the varargs argument, if any\n\t * ({@code null} if not varargs)\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws EvaluationException if a problem occurs during conversion\n\t */\n\tstatic boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable,\n\t\t\t@Nullable Integer varargsPosition) throws EvaluationException {\n\n\t\tboolean conversionOccurred = false;\n\t\tif (varargsPosition == null) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i));\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Convert everything up to the varargs position\n\t\t\tfor (int i = 0; i < varargsPosition; i++) {\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i));\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\n\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, varargsPosition);\n\n\t\t\t// If the target is varargs and there is just one more argument, then convert it here.\n\t\t\tif (varargsPosition == arguments.length - 1) {\n\t\t\t\tObject argument = arguments[varargsPosition];\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(methodParam);\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\tif (argument == null) {\n\t\t\t\t\t// Perform the equivalent of GenericConversionService.convertNullSource() for a single argument.\n\t\t\t\t\tif (targetType.getElementTypeDescriptor().getObjectType() == Optional.class) {\n\t\t\t\t\t\targuments[varargsPosition] = Optional.empty();\n\t\t\t\t\t\tconversionOccurred = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the argument type is equal to the varargs element type, there is no need to\n\t\t\t\t// convert it or wrap it in an array. For example, using StringToArrayConverter to\n\t\t\t\t// convert a String containing a comma would result in the String being split and\n\t\t\t\t// repackaged in an array when it should be used as-is.\n\t\t\t\telse if (!sourceType.equals(targetType.getElementTypeDescriptor())) {\n\t\t\t\t\targuments[varargsPosition] = converter.convertValue(argument, sourceType, targetType);\n\t\t\t\t}\n\t\t\t\t// Possible outcomes of the above if-else block:\n\t\t\t\t// 1) the input argument was null, and nothing was done.\n\t\t\t\t// 2) the input argument was null; the varargs element type is Optional; and the argument was converted to Optional.empty().\n\t\t\t\t// 3) the input argument was correct type but not wrapped in an array, and nothing was done.\n\t\t\t\t// 4) the input argument was already compatible (i.e., array of valid type), and nothing was done.\n\t\t\t\t// 5) the input argument was the wrong type and got converted and wrapped in an array.\n\t\t\t\tif (argument != arguments[varargsPosition] &&\n\t\t\t\t\t\t!isFirstEntryInArray(argument, arguments[varargsPosition])) {\n\t\t\t\t\tconversionOccurred = true; // case 5\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, convert remaining arguments to the varargs element type.\n\t\t\telse {\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor();\n\t\t\t\tAssert.state(targetType != null, \"No element type\");\n\t\t\t\tfor (int i = varargsPosition; i < arguments.length; i++) {\n\t\t\t\t\tObject argument = arguments[i];\n\t\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn conversionOccurred;\n\t}\n\n\t/**\n\t * Takes an input set of argument values and converts them to the parameter\n\t * types of the supplied {@link MethodHandle}.\n\t * <p>The arguments are converted 'in-place' in the input array.\n\t * @param converter the type converter to use for attempting conversions\n\t * @param arguments the actual arguments that need conversion\n\t * @param methodHandle the target MethodHandle\n\t * @param varargsPosition the known position of the varargs argument, if any\n\t * ({@code null} if not varargs)\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws EvaluationException if a problem occurs during conversion\n\t * @since 6.1\n\t */\n\tpublic static boolean convertAllMethodHandleArguments(TypeConverter converter, Object[] arguments,\n\t\t\tMethodHandle methodHandle, @Nullable Integer varargsPosition) throws EvaluationException {\n\n\t\tboolean conversionOccurred = false;\n\t\tfinal MethodType methodHandleArgumentTypes = methodHandle.type();\n\t\tif (varargsPosition == null) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tClass<?> argumentClass = methodHandleArgumentTypes.parameterType(i);\n\t\t\t\tResolvableType resolvableType = ResolvableType.forClass(argumentClass);\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(resolvableType, argumentClass, null);\n\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Convert everything up to the varargs position\n\t\t\tfor (int i = 0; i < varargsPosition; i++) {\n\t\t\t\tClass<?> argumentClass = methodHandleArgumentTypes.parameterType(i);\n\t\t\t\tResolvableType resolvableType = ResolvableType.forClass(argumentClass);\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(resolvableType, argumentClass, null);\n\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\n\t\t\tfinal Class<?> varArgClass = methodHandleArgumentTypes.lastParameterType().componentType();\n\t\t\tResolvableType varArgResolvableType = ResolvableType.forClass(varArgClass);\n\t\t\tTypeDescriptor varArgContentType = new TypeDescriptor(varArgResolvableType, varArgClass, null);\n\n\t\t\t// If the target is varargs and there is just one more argument, then convert it here.\n\t\t\tif (varargsPosition == arguments.length - 1) {\n\t\t\t\tObject argument = arguments[varargsPosition];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\tif (argument == null) {\n\t\t\t\t\t// Perform the equivalent of GenericConversionService.convertNullSource() for a single argument.\n\t\t\t\t\tif (varArgContentType.getElementTypeDescriptor().getObjectType() == Optional.class) {\n\t\t\t\t\t\targuments[varargsPosition] = Optional.empty();\n\t\t\t\t\t\tconversionOccurred = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the argument type is equal to the varargs element type, there is no need to\n\t\t\t\t// convert it or wrap it in an array. For example, using StringToArrayConverter to\n\t\t\t\t// convert a String containing a comma would result in the String being split and\n\t\t\t\t// repackaged in an array when it should be used as-is.\n\t\t\t\telse if (!sourceType.equals(varArgContentType.getElementTypeDescriptor())) {\n\t\t\t\t\targuments[varargsPosition] = converter.convertValue(argument, sourceType, varArgContentType);\n\t\t\t\t}\n\t\t\t\t// Possible outcomes of the above if-else block:\n\t\t\t\t// 1) the input argument was null, and nothing was done.\n\t\t\t\t// 2) the input argument was null; the varargs element type is Optional; and the argument was converted to Optional.empty().\n\t\t\t\t// 3) the input argument was correct type but not wrapped in an array, and nothing was done.\n\t\t\t\t// 4) the input argument was already compatible (i.e., array of valid type), and nothing was done.\n\t\t\t\t// 5) the input argument was the wrong type and got converted and wrapped in an array.\n\t\t\t\tif (argument != arguments[varargsPosition] &&\n\t\t\t\t\t\t!isFirstEntryInArray(argument, arguments[varargsPosition])) {\n\t\t\t\t\tconversionOccurred = true; // case 5\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, convert remaining arguments to the varargs element type.\n\t\t\telse {\n\t\t\t\tAssert.state(varArgContentType != null, \"No element type\");\n\t\t\t\tfor (int i = varargsPosition; i < arguments.length; i++) {\n\t\t\t\t\tObject argument = arguments[i];\n\t\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), varArgContentType);\n\t\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn conversionOccurred;\n\t}\n\n\t/**\n\t * Check if the supplied value is the first entry in the array represented by the possibleArray value.\n\t * @param value the value to check for in the array\n\t * @param possibleArray an array object that may have the supplied value as the first element\n\t * @return true if the supplied value is the first entry in the array\n\t */\n\tprivate static boolean isFirstEntryInArray(Object value, @Nullable Object possibleArray) {\n\t\tif (possibleArray == null) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> type = possibleArray.getClass();\n\t\tif (!type.isArray() || Array.getLength(possibleArray) == 0 ||\n\t\t\t\t!ClassUtils.isAssignableValue(type.componentType(), value)) {\n\t\t\treturn false;\n\t\t}\n\t\tObject arrayValue = Array.get(possibleArray, 0);\n\t\treturn (type.componentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value);\n\t}\n\n\t/**\n\t * Package up the arguments so that they correctly match what is expected in requiredParameterTypes.\n\t * <p>For example, if requiredParameterTypes is {@code (int, String[])} because the second parameter\n\t * was declared {@code String...}, then if arguments is {@code [1,\"a\",\"b\"]} then it must be\n\t * repackaged as {@code [1,new String[]{\"a\",\"b\"}]} in order to match the expected types.\n\t * @param requiredParameterTypes the types of the parameters for the invocation\n\t * @param args the arguments to be setup ready for the invocation\n\t * @return a repackaged array of arguments where any varargs setup has been done\n\t */\n\tpublic static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {\n\t\t// Check if array already built for final argument\n\t\tint parameterCount = requiredParameterTypes.length;\n\t\tint argumentCount = args.length;\n\n\t\t// Check if repackaging is needed...\n\t\tif (parameterCount != args.length ||\n\t\t\t\trequiredParameterTypes[parameterCount - 1] !=\n\t\t\t\t\t\t(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {\n\n\t\t\t// Create an array for the leading arguments plus the varargs array argument.\n\t\t\tObject[] newArgs = new Object[parameterCount];\n\t\t\t// Copy all leading arguments to the new array, omitting the varargs array argument.\n\t\t\tSystem.arraycopy(args, 0, newArgs, 0, newArgs.length - 1);\n\n\t\t\t// Now sort out the final argument, which is the varargs one. Before entering this method,\n\t\t\t// the arguments should have been converted to the box form of the required type.\n\t\t\tint varargsArraySize = 0;  // zero size array if nothing to pass as the varargs parameter\n\t\t\tif (argumentCount >= parameterCount) {\n\t\t\t\tvarargsArraySize = argumentCount - (parameterCount - 1);\n\t\t\t}\n\t\t\tClass<?> componentType = requiredParameterTypes[parameterCount - 1].componentType();\n\t\t\tObject varargsArray = Array.newInstance(componentType, varargsArraySize);\n\t\t\tfor (int i = 0; i < varargsArraySize; i++) {\n\t\t\t\tArray.set(varargsArray, i, args[parameterCount - 1 + i]);\n\t\t\t}\n\t\t\t// Finally, add the varargs array to the new arguments array.\n\t\t\tnewArgs[newArgs.length - 1] = varargsArray;\n\t\t\treturn newArgs;\n\t\t}\n\t\treturn args;\n\t}\n\n\t/**\n\t * Find the first public class or interface in the method's class hierarchy\n\t * that declares the supplied method.\n\t * <p>Sometimes the reflective method discovery logic finds a suitable method\n\t * that can easily be called via reflection but cannot be called from generated\n\t * code when compiling the expression because of visibility restrictions. For\n\t * example, if a non-public class overrides {@code toString()}, this method\n\t * will traverse up the type hierarchy to find the first public type that\n\t * declares the method (if there is one). For {@code toString()}, it may\n\t * traverse as far as {@link Object}.\n\t * @param method the method to process\n\t * @return the public class or interface that declares the method, or\n\t * {@code null} if no such public type could be found\n\t * @since 6.2\n\t */\n\t@Nullable\n\tpublic static Class<?> findPublicDeclaringClass(Method method) {\n\t\treturn publicDeclaringClassCache.computeIfAbsent(method, key -> {\n\t\t\t\t// If the method is already defined in a public type, return that type.\n\t\t\t\tif (Modifier.isPublic(key.getDeclaringClass().getModifiers())) {\n\t\t\t\t\treturn key.getDeclaringClass();\n\t\t\t\t}\n\t\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(key, null);\n\t\t\t\t// If we found an interface method whose type is public, return the interface type.\n\t\t\t\tif (!interfaceMethod.equals(key)) {\n\t\t\t\t\tif (Modifier.isPublic(interfaceMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\t\treturn interfaceMethod.getDeclaringClass();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Attempt to search the type hierarchy.\n\t\t\t\tClass<?> superclass = key.getDeclaringClass().getSuperclass();\n\t\t\t\tif (superclass != null) {\n\t\t\t\t\treturn findPublicDeclaringClass(superclass, key.getName(), key.getParameterTypes());\n\t\t\t\t}\n\t\t\t\t// Otherwise, no public declaring class found.\n\t\t\t\treturn null;\n\t\t\t});\n\t}\n\n\t@Nullable\n\tprivate static Class<?> findPublicDeclaringClass(\n\t\t\tClass<?> declaringClass, String methodName, Class<?>[] parameterTypes) {\n\n\t\tif (Modifier.isPublic(declaringClass.getModifiers())) {\n\t\t\ttry {\n\t\t\t\tdeclaringClass.getDeclaredMethod(methodName, parameterTypes);\n\t\t\t\treturn declaringClass;\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t// Continue below...\n\t\t\t}\n\t\t}\n\n\t\tClass<?> superclass = declaringClass.getSuperclass();\n\t\tif (superclass != null) {\n\t\t\treturn findPublicDeclaringClass(superclass, methodName, parameterTypes);\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * Arguments match kinds.\n\t */\n\tenum ArgumentsMatchKind {\n\n\t\t/** An exact match is where the parameter types exactly match what the method/constructor is expecting. */\n\t\tEXACT,\n\n\t\t/** A close match is where the parameter types either exactly match or are assignment-compatible. */\n\t\tCLOSE,\n\n\t\t/** A conversion match is where the type converter must be used to transform some of the parameter types. */\n\t\tREQUIRES_CONVERSION\n\t}\n\n\n\t/**\n\t * An instance of ArgumentsMatchInfo describes what kind of match was achieved\n\t * between two sets of arguments - the set that a method/constructor is expecting\n\t * and the set that are being supplied at the point of invocation. If the kind\n\t * indicates that conversion is required for some of the arguments then the arguments\n\t * that require conversion are listed in the argsRequiringConversion array.\n\t *\n\t * @param kind the kind of match that was achieved\n\t */\n\trecord ArgumentsMatchInfo(ArgumentsMatchKind kind) {\n\n\t\tpublic boolean isExactMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.EXACT);\n\t\t}\n\n\t\tpublic boolean isCloseMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.CLOSE);\n\t\t}\n\n\t\tpublic boolean isMatchRequiringConversion() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.REQUIRES_CONVERSION);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"ArgumentMatchInfo: \" + this.kind;\n\t\t}\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 6,
                "candidates": [
                    {
                        "lineStart": 60,
                        "lineEnd": 102,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method compareArguments to class ReflectiveMethodResolver",
                        "description": "move method to org.springframework.expression.spel.support.ReflectiveMethodResolver\nRationale: The method compareArguments involves deciding the match kind based on expected and supplied argument types which would be part of method resolution process. Therefore, it may be best to move this method to the ReflectiveMethodResolver class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 147,
                        "lineEnd": 244,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method compareArgumentsVarargs to class ReflectiveMethodResolver",
                        "description": "move method to org.springframework.expression.spel.support.ReflectiveMethodResolver\nRationale: This method is used for comparing argument arrays and possibly resolve methods. ReflectiveMethodResolver is the most suitable class as it is responsible for method resolution.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 459,
                        "lineEnd": 499,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method setupArgumentsForVarargsInvocation to class ReflectiveMethodResolver",
                        "description": "move method to org.springframework.expression.spel.support.ReflectiveMethodResolver\nRationale: The method `setupArgumentsForVarargsInvocation` is used for dynamically resolving methods at runtime and the parameter types provided, which aligns closely with the responsibilities of the ReflectiveMethodResolver class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 246,
                        "lineEnd": 272,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method convertAllArguments to class ReflectiveMethodExecutor",
                        "description": "move method to org.springframework.expression.spel.support.ReflectiveMethodExecutor\nRationale: Since this method is dealing with conversion of arguments for methods and does operations like checking if the method is varargs, setting up arguments and throwing SpelEvaluationExceptions, it seems to be related to reflection execution of methods. It should belong to 'ReflectiveMethodExecutor' class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 540,
                        "lineEnd": 559,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method findPublicDeclaringClass to class ReflectiveMethodResolver",
                        "description": "move method to org.springframework.expression.spel.support.ReflectiveMethodResolver\nRationale: The 'findPublicDeclaringClass' method is primarily involved with resolving methods based on the provided class, method name, and parameter types. This behaviour fits within the responsibilities of the 'ReflectiveMethodResolver' class, which is explicitly designed to handle such method resolution tasks.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 104,
                        "lineEnd": 145,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method getTypeDifferenceWeight to class ReflectiveMethodResolver",
                        "description": "move method to org.springframework.expression.spel.support.ReflectiveMethodResolver\nRationale: getTypeDifferenceWeight() method appears to be used for resolving method invocation based on the types of arguments, which is typical behavior for a method resolver. Among the options, ReflectiveMethodResolver is the most appropriate class for this method since it's related to method resolution using reflection.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "convertAllArguments",
                            "method_signature": "public convertAllArguments(TypeConverter, Object[], Method): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "The convertAllArguments() method primarily deals with converting types, which relates more to the functionality of the TypeConverter class."
                        },
                        {
                            "method_name": "convertArguments",
                            "method_signature": "static convertArguments(TypeConverter, Object[], Executable, Integer): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "The convertArguments() method primarily deals with converting types, so it would be more appropriately placed in the TypeConverter class."
                        },
                        {
                            "method_name": "convertAllMethodHandleArguments",
                            "method_signature": "public convertAllMethodHandleArguments(TypeConverter, Object[], MethodHandle, Integer): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "In line with the previous recommendations, the convertAllMethodHandleArguments() method should also be moved to the TypeConverter class as it is also concerned with type conversion."
                        },
                        {
                            "method_name": "setupArgumentsForVarargsInvocation",
                            "method_signature": "public setupArgumentsForVarargsInvocation(Class<?>[], Object...): Object[]",
                            "target_class": "VarargsUtil",
                            "rationale": "The method setupArgumentsForVarargsInvocation() deals specifically with varargs, it would make sense to create a separate utility class for handling varargs scenarios."
                        }
                    ],
                    "llm_response_time": 20190
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "compareArguments",
                            "method_signature": "static ArgumentsMatchInfo compareArguments(List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter)",
                            "target_class": "ArgumentsMatcher",
                            "rationale": "This method is more related to argument matching and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "getTypeDifferenceWeight",
                            "method_signature": "public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes)",
                            "target_class": "TypeComparator",
                            "rationale": "This method is more related to comparing types, and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "compareArgumentsVarargs",
                            "method_signature": "static ArgumentsMatchInfo compareArgumentsVarargs(List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter)",
                            "target_class": "ArgumentsMatcher",
                            "rationale": "This method is also more related to argument matching and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "convertAllArguments",
                            "method_signature": "public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException",
                            "target_class": "ArgumentsConverter",
                            "rationale": "This method is more related to converting arguments, and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "convertArguments",
                            "method_signature": "static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable, @Nullable Integer varargsPosition) throws EvaluationException",
                            "target_class": "ArgumentsConverter",
                            "rationale": "This method is also more related to converting arguments, and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "setupArgumentsForVarargsInvocation",
                            "method_signature": "public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args)",
                            "target_class": "VarargsHelper",
                            "rationale": "This method is more related to varargs processing, and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "findPublicDeclaringClass",
                            "method_signature": "@Nullable public static Class<?> findPublicDeclaringClass(Method method)",
                            "target_class": "ReflectionUtils",
                            "rationale": "This method seems better suited to a general utility class focused on reflection operations."
                        }
                    ],
                    "llm_response_time": 22592
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "convertAllArguments",
                            "method_signature": "public convertAllArguments(TypeConverter converter, Object[] arguments, Method method): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "convertAllArguments method relies heavily on the TypeConverter class, so it would be more cohesive to move this method to the TypeConverter class."
                        },
                        {
                            "method_name": "convertArguments",
                            "method_signature": "static convertArguments(TypeConverter converter, Object[] arguments, Executable executable, @Nullable Integer varargsPosition): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "convertArguments method relies heavily on the TypeConverter class, so it would be more cohesive to move this method to the TypeConverter class."
                        },
                        {
                            "method_name": "convertAllMethodHandleArguments",
                            "method_signature": "public convertAllMethodHandleArguments(TypeConverter converter, Object[] arguments, MethodHandle methodHandle, @Nullable Integer varargsPosition): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "convertAllMethodHandleArguments method relies heavily on the TypeConverter class, so it would be more cohesive to move this method to the TypeConverter class."
                        },
                        {
                            "method_name": "setupArgumentsForVarargsInvocation",
                            "method_signature": "public setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args): Object[]",
                            "target_class": "TypeUtil",
                            "rationale": "setupArgumentsForVarargsInvocation method is more related to Utilities for types, so TypeUtil would be a more appropriate class to move this method."
                        },
                        {
                            "method_name": "findPublicDeclaringClass",
                            "method_signature": "public findPublicDeclaringClass(Method method): Class<?>",
                            "target_class": "ClassUtil",
                            "rationale": "findPublicDeclaringClass method is more related to Utilities for classes, so ClassUtil would be a more appropriate class to move this method."
                        }
                    ],
                    "llm_response_time": 28120
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "convertAllArguments",
                            "method_signature": "public convertAllArguments(TypeConverter, Object[], Method): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "The convertAllArguments() method primarily deals with converting types, which relates more to the functionality of the TypeConverter class."
                        },
                        {
                            "method_name": "convertArguments",
                            "method_signature": "static convertArguments(TypeConverter, Object[], Executable, Integer): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "The convertArguments() method primarily deals with converting types, so it would be more appropriately placed in the TypeConverter class."
                        },
                        {
                            "method_name": "convertAllMethodHandleArguments",
                            "method_signature": "public convertAllMethodHandleArguments(TypeConverter, Object[], MethodHandle, Integer): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "In line with the previous recommendations, the convertAllMethodHandleArguments() method should also be moved to the TypeConverter class as it is also concerned with type conversion."
                        },
                        {
                            "method_name": "setupArgumentsForVarargsInvocation",
                            "method_signature": "public setupArgumentsForVarargsInvocation(Class<?>[], Object...): Object[]",
                            "target_class": "VarargsUtil",
                            "rationale": "The method setupArgumentsForVarargsInvocation() deals specifically with varargs, it would make sense to create a separate utility class for handling varargs scenarios."
                        },
                        {
                            "method_name": "compareArguments",
                            "method_signature": "static ArgumentsMatchInfo compareArguments(List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter)",
                            "target_class": "ArgumentsMatcher",
                            "rationale": "This method is more related to argument matching and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "getTypeDifferenceWeight",
                            "method_signature": "public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes)",
                            "target_class": "TypeComparator",
                            "rationale": "This method is more related to comparing types, and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "compareArgumentsVarargs",
                            "method_signature": "static ArgumentsMatchInfo compareArgumentsVarargs(List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter)",
                            "target_class": "ArgumentsMatcher",
                            "rationale": "This method is also more related to argument matching and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "findPublicDeclaringClass",
                            "method_signature": "@Nullable public static Class<?> findPublicDeclaringClass(Method method)",
                            "target_class": "ReflectionUtils",
                            "rationale": "This method seems better suited to a general utility class focused on reflection operations."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "compareArguments",
                    "compareArgumentsVarargs",
                    "setupArgumentsForVarargsInvocation",
                    "convertAllArguments",
                    "convertAllMethodHandleArguments",
                    "findPublicDeclaringClass",
                    "convertArguments",
                    "getTypeDifferenceWeight"
                ],
                "llm_response_time": 6528
            },
            "targetClassMap": {
                "compareArguments": {
                    "target_classes": [
                        {
                            "class_name": "BooleanTypedValue",
                            "similarity_score": 0.40028399009612253
                        },
                        {
                            "class_name": "StandardTypeLocator",
                            "similarity_score": 0.6218507902373729
                        },
                        {
                            "class_name": "StandardTypeConverter",
                            "similarity_score": 0.5551940070294571
                        },
                        {
                            "class_name": "StandardTypeComparator",
                            "similarity_score": 0.5106445287116335
                        },
                        {
                            "class_name": "SimpleEvaluationContext",
                            "similarity_score": 0.5438282883848101
                        },
                        {
                            "class_name": "ReflectiveMethodExecutor",
                            "similarity_score": 0.600583441116239
                        },
                        {
                            "class_name": "ReflectiveMethodResolver",
                            "similarity_score": 0.768839401599597
                        },
                        {
                            "class_name": "DataBindingMethodResolver",
                            "similarity_score": 0.5112191484764215
                        },
                        {
                            "class_name": "StandardEvaluationContext",
                            "similarity_score": 0.6404575772684243
                        },
                        {
                            "class_name": "ReflectivePropertyAccessor",
                            "similarity_score": 0.680292242838623
                        },
                        {
                            "class_name": "StandardOperatorOverloader",
                            "similarity_score": 0.34287613929136845
                        },
                        {
                            "class_name": "DataBindingPropertyAccessor",
                            "similarity_score": 0.4495405232406161
                        },
                        {
                            "class_name": "ReflectiveConstructorExecutor",
                            "similarity_score": 0.5647807988243394
                        },
                        {
                            "class_name": "ReflectiveConstructorResolver",
                            "similarity_score": 0.7736566974030129
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReflectiveMethodResolver",
                        "ReflectiveConstructorResolver",
                        "StandardTypeConverter",
                        "ReflectivePropertyAccessor",
                        "StandardEvaluationContext",
                        "StandardTypeLocator",
                        "ReflectiveMethodExecutor",
                        "ReflectiveConstructorExecutor",
                        "SimpleEvaluationContext",
                        "DataBindingMethodResolver",
                        "StandardTypeComparator",
                        "DataBindingPropertyAccessor",
                        "BooleanTypedValue",
                        "StandardOperatorOverloader"
                    ],
                    "llm_response_time": 6953,
                    "similarity_computation_time": 15,
                    "similarity_metric": "cosine"
                },
                "compareArgumentsVarargs": {
                    "target_classes": [
                        {
                            "class_name": "BooleanTypedValue",
                            "similarity_score": 0.3641661542608559
                        },
                        {
                            "class_name": "StandardTypeLocator",
                            "similarity_score": 0.5907728131988601
                        },
                        {
                            "class_name": "StandardTypeConverter",
                            "similarity_score": 0.5255611356971114
                        },
                        {
                            "class_name": "StandardTypeComparator",
                            "similarity_score": 0.5766752791935843
                        },
                        {
                            "class_name": "SimpleEvaluationContext",
                            "similarity_score": 0.4616813614705038
                        },
                        {
                            "class_name": "ReflectiveMethodExecutor",
                            "similarity_score": 0.5997601644929319
                        },
                        {
                            "class_name": "ReflectiveMethodResolver",
                            "similarity_score": 0.8111909245671576
                        },
                        {
                            "class_name": "DataBindingMethodResolver",
                            "similarity_score": 0.48339200108241454
                        },
                        {
                            "class_name": "StandardEvaluationContext",
                            "similarity_score": 0.6033065845068664
                        },
                        {
                            "class_name": "ReflectivePropertyAccessor",
                            "similarity_score": 0.7431371655130967
                        },
                        {
                            "class_name": "StandardOperatorOverloader",
                            "similarity_score": 0.31799872196498324
                        },
                        {
                            "class_name": "DataBindingPropertyAccessor",
                            "similarity_score": 0.36525137048775413
                        },
                        {
                            "class_name": "ReflectiveConstructorExecutor",
                            "similarity_score": 0.6095440682466583
                        },
                        {
                            "class_name": "ReflectiveConstructorResolver",
                            "similarity_score": 0.8130826867371875
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReflectiveMethodResolver",
                        "ReflectiveConstructorResolver",
                        "StandardTypeConverter",
                        "ReflectivePropertyAccessor",
                        "ReflectiveConstructorExecutor",
                        "StandardEvaluationContext",
                        "ReflectiveMethodExecutor",
                        "StandardTypeLocator",
                        "StandardTypeComparator",
                        "DataBindingMethodResolver",
                        "SimpleEvaluationContext",
                        "DataBindingPropertyAccessor",
                        "BooleanTypedValue",
                        "StandardOperatorOverloader"
                    ],
                    "llm_response_time": 7897,
                    "similarity_computation_time": 17,
                    "similarity_metric": "cosine"
                },
                "setupArgumentsForVarargsInvocation": {
                    "target_classes": [
                        {
                            "class_name": "BooleanTypedValue",
                            "similarity_score": 0.2590417211774742
                        },
                        {
                            "class_name": "StandardTypeLocator",
                            "similarity_score": 0.5231380307772263
                        },
                        {
                            "class_name": "StandardTypeConverter",
                            "similarity_score": 0.42776611144742394
                        },
                        {
                            "class_name": "StandardTypeComparator",
                            "similarity_score": 0.2906110807566539
                        },
                        {
                            "class_name": "SimpleEvaluationContext",
                            "similarity_score": 0.4169994120572662
                        },
                        {
                            "class_name": "ReflectiveMethodExecutor",
                            "similarity_score": 0.5210102416096528
                        },
                        {
                            "class_name": "ReflectiveMethodResolver",
                            "similarity_score": 0.6141982870980686
                        },
                        {
                            "class_name": "DataBindingMethodResolver",
                            "similarity_score": 0.304740462598988
                        },
                        {
                            "class_name": "StandardEvaluationContext",
                            "similarity_score": 0.5406575001405886
                        },
                        {
                            "class_name": "ReflectivePropertyAccessor",
                            "similarity_score": 0.4497235322653146
                        },
                        {
                            "class_name": "StandardOperatorOverloader",
                            "similarity_score": 0.19603110415214706
                        },
                        {
                            "class_name": "DataBindingPropertyAccessor",
                            "similarity_score": 0.2926872614116674
                        },
                        {
                            "class_name": "ReflectiveConstructorExecutor",
                            "similarity_score": 0.3119282858488108
                        },
                        {
                            "class_name": "ReflectiveConstructorResolver",
                            "similarity_score": 0.675657296823273
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReflectiveMethodResolver",
                        "ReflectiveMethodExecutor",
                        "ReflectiveConstructorResolver",
                        "StandardEvaluationContext",
                        "StandardTypeLocator",
                        "ReflectivePropertyAccessor",
                        "StandardTypeConverter",
                        "SimpleEvaluationContext",
                        "ReflectiveConstructorExecutor",
                        "DataBindingMethodResolver",
                        "DataBindingPropertyAccessor",
                        "StandardTypeComparator",
                        "BooleanTypedValue",
                        "StandardOperatorOverloader"
                    ],
                    "llm_response_time": 8362,
                    "similarity_computation_time": 34,
                    "similarity_metric": "cosine"
                },
                "convertAllArguments": {
                    "target_classes": [
                        {
                            "class_name": "BooleanTypedValue",
                            "similarity_score": 0.3709540577627336
                        },
                        {
                            "class_name": "StandardTypeLocator",
                            "similarity_score": 0.670043526401822
                        },
                        {
                            "class_name": "StandardTypeConverter",
                            "similarity_score": 0.571276375694701
                        },
                        {
                            "class_name": "StandardTypeComparator",
                            "similarity_score": 0.18284759913772286
                        },
                        {
                            "class_name": "SimpleEvaluationContext",
                            "similarity_score": 0.6824089337267754
                        },
                        {
                            "class_name": "ReflectiveMethodExecutor",
                            "similarity_score": 0.6346346644868486
                        },
                        {
                            "class_name": "ReflectiveMethodResolver",
                            "similarity_score": 0.588612531899537
                        },
                        {
                            "class_name": "DataBindingMethodResolver",
                            "similarity_score": 0.46706365800314503
                        },
                        {
                            "class_name": "StandardEvaluationContext",
                            "similarity_score": 0.7075251977736101
                        },
                        {
                            "class_name": "ReflectivePropertyAccessor",
                            "similarity_score": 0.36510041708349933
                        },
                        {
                            "class_name": "StandardOperatorOverloader",
                            "similarity_score": 0.2594378721924932
                        },
                        {
                            "class_name": "DataBindingPropertyAccessor",
                            "similarity_score": 0.5508515023795626
                        },
                        {
                            "class_name": "ReflectiveConstructorExecutor",
                            "similarity_score": 0.2867097085410729
                        },
                        {
                            "class_name": "ReflectiveConstructorResolver",
                            "similarity_score": 0.6072408331784407
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReflectiveMethodExecutor",
                        "StandardTypeConverter",
                        "StandardEvaluationContext",
                        "SimpleEvaluationContext",
                        "StandardTypeLocator",
                        "ReflectiveConstructorResolver",
                        "ReflectiveMethodResolver",
                        "DataBindingPropertyAccessor",
                        "DataBindingMethodResolver",
                        "BooleanTypedValue",
                        "ReflectivePropertyAccessor",
                        "ReflectiveConstructorExecutor",
                        "StandardOperatorOverloader",
                        "StandardTypeComparator"
                    ],
                    "llm_response_time": 7594,
                    "similarity_computation_time": 28,
                    "similarity_metric": "cosine"
                },
                "convertAllMethodHandleArguments": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 11840,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "findPublicDeclaringClass": {
                    "target_classes": [
                        {
                            "class_name": "BooleanTypedValue",
                            "similarity_score": 0.2948965571464163
                        },
                        {
                            "class_name": "StandardTypeLocator",
                            "similarity_score": 0.3775538019939049
                        },
                        {
                            "class_name": "StandardTypeConverter",
                            "similarity_score": 0.34564031698569353
                        },
                        {
                            "class_name": "StandardTypeComparator",
                            "similarity_score": 0.5813233085358505
                        },
                        {
                            "class_name": "SimpleEvaluationContext",
                            "similarity_score": 0.23470535485913493
                        },
                        {
                            "class_name": "ReflectiveMethodExecutor",
                            "similarity_score": 0.4225106791953807
                        },
                        {
                            "class_name": "ReflectiveMethodResolver",
                            "similarity_score": 0.5697628681961318
                        },
                        {
                            "class_name": "DataBindingMethodResolver",
                            "similarity_score": 0.45237292565365317
                        },
                        {
                            "class_name": "StandardEvaluationContext",
                            "similarity_score": 0.3410653666820637
                        },
                        {
                            "class_name": "ReflectivePropertyAccessor",
                            "similarity_score": 0.6664687435560802
                        },
                        {
                            "class_name": "StandardOperatorOverloader",
                            "similarity_score": 0.3124302001369961
                        },
                        {
                            "class_name": "DataBindingPropertyAccessor",
                            "similarity_score": 0.21742347154279043
                        },
                        {
                            "class_name": "ReflectiveConstructorExecutor",
                            "similarity_score": 0.583838669960598
                        },
                        {
                            "class_name": "ReflectiveConstructorResolver",
                            "similarity_score": 0.4869807930279584
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReflectiveMethodResolver",
                        "ReflectiveConstructorResolver",
                        "ReflectivePropertyAccessor",
                        "ReflectiveConstructorExecutor",
                        "StandardTypeComparator",
                        "DataBindingMethodResolver",
                        "ReflectiveMethodExecutor",
                        "StandardTypeLocator",
                        "StandardTypeConverter",
                        "StandardEvaluationContext",
                        "StandardOperatorOverloader",
                        "BooleanTypedValue",
                        "SimpleEvaluationContext",
                        "DataBindingPropertyAccessor"
                    ],
                    "llm_response_time": 7533,
                    "similarity_computation_time": 26,
                    "similarity_metric": "cosine"
                },
                "convertArguments": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 8988,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "getTypeDifferenceWeight": {
                    "target_classes": [
                        {
                            "class_name": "BooleanTypedValue",
                            "similarity_score": 0.366437555940004
                        },
                        {
                            "class_name": "StandardTypeLocator",
                            "similarity_score": 0.39454752660965775
                        },
                        {
                            "class_name": "StandardTypeConverter",
                            "similarity_score": 0.3968905129529466
                        },
                        {
                            "class_name": "StandardTypeComparator",
                            "similarity_score": 0.584926415150998
                        },
                        {
                            "class_name": "SimpleEvaluationContext",
                            "similarity_score": 0.28263446587352137
                        },
                        {
                            "class_name": "ReflectiveMethodExecutor",
                            "similarity_score": 0.4980218363351869
                        },
                        {
                            "class_name": "ReflectiveMethodResolver",
                            "similarity_score": 0.6823217371272611
                        },
                        {
                            "class_name": "DataBindingMethodResolver",
                            "similarity_score": 0.43137962484165293
                        },
                        {
                            "class_name": "StandardEvaluationContext",
                            "similarity_score": 0.4160648669892917
                        },
                        {
                            "class_name": "ReflectivePropertyAccessor",
                            "similarity_score": 0.7438819732675216
                        },
                        {
                            "class_name": "StandardOperatorOverloader",
                            "similarity_score": 0.3099536764398061
                        },
                        {
                            "class_name": "DataBindingPropertyAccessor",
                            "similarity_score": 0.23696623297685504
                        },
                        {
                            "class_name": "ReflectiveConstructorExecutor",
                            "similarity_score": 0.6351869321977228
                        },
                        {
                            "class_name": "ReflectiveConstructorResolver",
                            "similarity_score": 0.5956319353133275
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReflectiveMethodResolver",
                        "StandardTypeComparator",
                        "ReflectivePropertyAccessor",
                        "ReflectiveConstructorExecutor",
                        "ReflectiveConstructorResolver",
                        "ReflectiveMethodExecutor",
                        "DataBindingMethodResolver",
                        "StandardEvaluationContext",
                        "StandardTypeConverter",
                        "StandardTypeLocator",
                        "BooleanTypedValue",
                        "StandardOperatorOverloader",
                        "SimpleEvaluationContext",
                        "DataBindingPropertyAccessor"
                    ],
                    "llm_response_time": 11655,
                    "similarity_computation_time": 30,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "38c831f15fadef0f5ca4ecf032a5d4ccdb293e90",
        "url": "https://github.com/spring-projects/spring-framework/commit/38c831f15fadef0f5ca4ecf032a5d4ccdb293e90",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private findPublicDeclaringClass(declaringClass Class<?>, methodName String, parameterTypes Class<?>[]) : Class<?> from class org.springframework.expression.spel.support.ReflectionHelper to private findPublicDeclaringClass(declaringClass Class<?>, methodName String, parameterTypes Class<?>[]) : Class<?> from class org.springframework.expression.spel.CodeFlow",
            "leftSideLocations": [
                {
                    "filePath": "spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectionHelper.java",
                    "startLine": 541,
                    "endLine": 560,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private findPublicDeclaringClass(declaringClass Class<?>, methodName String, parameterTypes Class<?>[]) : Class<?>"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-expression/src/main/java/org/springframework/expression/spel/CodeFlow.java",
                    "startLine": 451,
                    "endLine": 470,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "private findPublicDeclaringClass(declaringClass Class<?>, methodName String, parameterTypes Class<?>[]) : Class<?>"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "aff952de-8e22-47d2-a3ed-2b4c8fa7f7b9",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 567,
                "lineStart": 42,
                "lineEnd": 608,
                "bodyLineStart": 42,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectionHelper.java",
                "sourceCode": "/**\n * Utility methods used by the reflection resolver code to discover the appropriate\n * methods, constructors, and fields that should be used in expressions.\n *\n * @author Andy Clement\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 3.0\n */\npublic abstract class ReflectionHelper {\n\n\t/**\n\t * Cache for equivalent methods in a public declaring class in the type\n\t * hierarchy of the method's declaring class.\n\t * @since 6.2\n\t */\n\tprivate static final Map<Method, Class<?>> publicDeclaringClassCache = new ConcurrentReferenceHashMap<>(256);\n\n\n\t/**\n\t * Compare argument arrays and return information about whether they match.\n\t * <p>A supplied type converter and conversionAllowed flag allow for matches to take\n\t * into account that a type may be transformed into a different type by the converter.\n\t * @param expectedArgTypes the types the method/constructor is expecting\n\t * @param suppliedArgTypes the types that are being supplied at the point of invocation\n\t * @param typeConverter a registered type converter\n\t * @return a MatchInfo object indicating what kind of match it was,\n\t * or {@code null} if it was not a match\n\t */\n\t@Nullable\n\tstatic ArgumentsMatchInfo compareArguments(\n\t\t\tList<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {\n\n\t\tAssert.isTrue(expectedArgTypes.size() == suppliedArgTypes.size(),\n\t\t\t\t\"Expected argument types and supplied argument types should be arrays of same length\");\n\n\t\tArgumentsMatchKind match = ArgumentsMatchKind.EXACT;\n\t\tfor (int i = 0; i < expectedArgTypes.size() && match != null; i++) {\n\t\t\tTypeDescriptor suppliedArg = suppliedArgTypes.get(i);\n\t\t\tTypeDescriptor expectedArg = expectedArgTypes.get(i);\n\t\t\t// The user may supply null, and that will be OK unless a primitive is expected.\n\t\t\tif (suppliedArg == null) {\n\t\t\t\tif (expectedArg.isPrimitive()) {\n\t\t\t\t\tmatch = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!expectedArg.equals(suppliedArg)) {\n\t\t\t\tif (suppliedArg.isAssignableTo(expectedArg)) {\n\t\t\t\t\tif (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {\n\t\t\t\t\t\tmatch = ArgumentsMatchKind.CLOSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (typeConverter.canConvert(suppliedArg, expectedArg)) {\n\t\t\t\t\tmatch = ArgumentsMatchKind.REQUIRES_CONVERSION;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmatch = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (match != null ? new ArgumentsMatchInfo(match) : null);\n\t}\n\n\t/**\n\t * Based on {@link MethodInvoker#getTypeDifferenceWeight(Class[], Object[])} but operates on TypeDescriptors.\n\t */\n\tpublic static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < paramTypes.size(); i++) {\n\t\t\tTypeDescriptor paramType = paramTypes.get(i);\n\t\t\tTypeDescriptor argType = (i < argTypes.size() ? argTypes.get(i) : null);\n\t\t\tif (argType == null) {\n\t\t\t\tif (paramType.isPrimitive()) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tClass<?> paramTypeClazz = paramType.getType();\n\t\t\t\tif (!ClassUtils.isAssignable(paramTypeClazz, argType.getType())) {\n\t\t\t\t\treturn Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isPrimitive()) {\n\t\t\t\t\tparamTypeClazz = Object.class;\n\t\t\t\t}\n\t\t\t\tClass<?> superClass = argType.getType().getSuperclass();\n\t\t\t\twhile (superClass != null) {\n\t\t\t\t\tif (paramTypeClazz.equals(superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ClassUtils.isAssignable(paramTypeClazz, superClass)) {\n\t\t\t\t\t\tresult = result + 2;\n\t\t\t\t\t\tsuperClass = superClass.getSuperclass();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsuperClass = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (paramTypeClazz.isInterface()) {\n\t\t\t\t\tresult = result + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Compare argument arrays and return information about whether they match.\n\t * <p>A supplied type converter and conversionAllowed flag allow for matches to\n\t * take into account that a type may be transformed into a different type by the\n\t * converter. This variant of {@link #compareArguments} also allows for a varargs match.\n\t * @param expectedArgTypes the types the method/constructor is expecting\n\t * @param suppliedArgTypes the types that are being supplied at the point of invocation\n\t * @param typeConverter a registered type converter\n\t * @return a MatchInfo object indicating what kind of match it was,\n\t * or {@code null} if it was not a match\n\t */\n\t@Nullable\n\tstatic ArgumentsMatchInfo compareArgumentsVarargs(\n\t\t\tList<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter) {\n\n\t\tAssert.isTrue(!CollectionUtils.isEmpty(expectedArgTypes),\n\t\t\t\t\"Expected arguments must at least include one array (the varargs parameter)\");\n\t\tAssert.isTrue(expectedArgTypes.get(expectedArgTypes.size() - 1).isArray(),\n\t\t\t\t\"Final expected argument should be array type (the varargs parameter)\");\n\n\t\tArgumentsMatchKind match = ArgumentsMatchKind.EXACT;\n\n\t\t// Check up until the varargs argument:\n\n\t\t// Deal with the arguments up to 'expected number' - 1 (that is everything but the varargs argument)\n\t\tint argCountUpToVarargs = expectedArgTypes.size() - 1;\n\t\tfor (int i = 0; i < argCountUpToVarargs && match != null; i++) {\n\t\t\tTypeDescriptor suppliedArg = suppliedArgTypes.get(i);\n\t\t\tTypeDescriptor expectedArg = expectedArgTypes.get(i);\n\t\t\tif (suppliedArg == null) {\n\t\t\t\tif (expectedArg.isPrimitive()) {\n\t\t\t\t\tmatch = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!expectedArg.equals(suppliedArg)) {\n\t\t\t\t\tif (suppliedArg.isAssignableTo(expectedArg)) {\n\t\t\t\t\t\tif (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {\n\t\t\t\t\t\t\tmatch = ArgumentsMatchKind.CLOSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (typeConverter.canConvert(suppliedArg, expectedArg)) {\n\t\t\t\t\t\tmatch = ArgumentsMatchKind.REQUIRES_CONVERSION;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmatch = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If already confirmed it cannot be a match, then return\n\t\tif (match == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (suppliedArgTypes.size() == expectedArgTypes.size() &&\n\t\t\t\texpectedArgTypes.get(expectedArgTypes.size() - 1).equals(\n\t\t\t\t\t\tsuppliedArgTypes.get(suppliedArgTypes.size() - 1))) {\n\t\t\t// Special case: there is one parameter left and it is an array and it matches the varargs\n\t\t\t// expected argument - that is a match, the caller has already built the array. Proceed with it.\n\t\t}\n\t\telse {\n\t\t\t// Now... we have the final argument in the method we are checking as a match and we have 0\n\t\t\t// or more other arguments left to pass to it.\n\t\t\tTypeDescriptor varargsDesc = expectedArgTypes.get(expectedArgTypes.size() - 1);\n\t\t\tTypeDescriptor elementDesc = varargsDesc.getElementTypeDescriptor();\n\t\t\tAssert.state(elementDesc != null, \"No element type\");\n\t\t\tClass<?> varargsParamType = elementDesc.getType();\n\n\t\t\t// All remaining parameters must be of this type or convertible to this type\n\t\t\tfor (int i = expectedArgTypes.size() - 1; i < suppliedArgTypes.size(); i++) {\n\t\t\t\tTypeDescriptor suppliedArg = suppliedArgTypes.get(i);\n\t\t\t\tif (suppliedArg == null) {\n\t\t\t\t\tif (varargsParamType.isPrimitive()) {\n\t\t\t\t\t\tmatch = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (varargsParamType != suppliedArg.getType()) {\n\t\t\t\t\t\tif (ClassUtils.isAssignable(varargsParamType, suppliedArg.getType())) {\n\t\t\t\t\t\t\tif (match != ArgumentsMatchKind.REQUIRES_CONVERSION) {\n\t\t\t\t\t\t\t\tmatch = ArgumentsMatchKind.CLOSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsParamType))) {\n\t\t\t\t\t\t\tmatch = ArgumentsMatchKind.REQUIRES_CONVERSION;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tmatch = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (match != null ? new ArgumentsMatchInfo(match) : null);\n\t}\n\n\t/**\n\t * Convert the supplied set of arguments into the parameter types specified\n\t * by the supplied {@link Method}.\n\t * <p>The arguments are converted 'in-place' in the input array.\n\t * <p>If the method accepts varargs, the final entry in its parameterTypes\n\t * array is going to be an array itself whose component type will be used as\n\t * the conversion target for any additional arguments. For example, if the\n\t * parameterTypes are {Integer, String[]} and the input arguments are\n\t * {Integer, boolean, float}, then both the boolean and float must be converted\n\t * to strings.\n\t * <p>This method does <strong>not</strong> repackage the arguments into a\n\t * form suitable for the varargs invocation. A subsequent call to\n\t * {@link #setupArgumentsForVarargsInvocation(Class[], Object...)} must be\n\t * used for that.\n\t * @param converter the converter to use for type conversions\n\t * @param arguments the arguments to convert to the parameter types of the\n\t * target method\n\t * @param method the target method\n\t * @return true if some kind of conversion occurred on an argument\n\t * @throws SpelEvaluationException if there is a problem with conversion\n\t */\n\tpublic static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method)\n\t\t\tthrows SpelEvaluationException {\n\n\t\tInteger varargsPosition = (method.isVarArgs() ? method.getParameterCount() - 1 : null);\n\t\treturn convertArguments(converter, arguments, method, varargsPosition);\n\t}\n\n\t/**\n\t * Takes an input set of argument values and converts them to the parameter\n\t * types of the supplied {@link Executable} (i.e., constructor or method).\n\t * <p>The arguments are converted 'in-place' in the input array.\n\t * @param converter the type converter to use for attempting conversions\n\t * @param arguments the actual arguments that need conversion\n\t * @param executable the target Method or Constructor\n\t * @param varargsPosition the known position of the varargs argument, if any\n\t * ({@code null} if not varargs)\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws EvaluationException if a problem occurs during conversion\n\t */\n\tstatic boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable,\n\t\t\t@Nullable Integer varargsPosition) throws EvaluationException {\n\n\t\tboolean conversionOccurred = false;\n\t\tif (varargsPosition == null) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i));\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Convert everything up to the varargs position\n\t\t\tfor (int i = 0; i < varargsPosition; i++) {\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(MethodParameter.forExecutable(executable, i));\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\n\t\t\tMethodParameter methodParam = MethodParameter.forExecutable(executable, varargsPosition);\n\n\t\t\t// If the target is varargs and there is just one more argument, then convert it here.\n\t\t\tif (varargsPosition == arguments.length - 1) {\n\t\t\t\tObject argument = arguments[varargsPosition];\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(methodParam);\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\tif (argument == null) {\n\t\t\t\t\t// Perform the equivalent of GenericConversionService.convertNullSource() for a single argument.\n\t\t\t\t\tif (targetType.getElementTypeDescriptor().getObjectType() == Optional.class) {\n\t\t\t\t\t\targuments[varargsPosition] = Optional.empty();\n\t\t\t\t\t\tconversionOccurred = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the argument type is equal to the varargs element type, there is no need to\n\t\t\t\t// convert it or wrap it in an array. For example, using StringToArrayConverter to\n\t\t\t\t// convert a String containing a comma would result in the String being split and\n\t\t\t\t// repackaged in an array when it should be used as-is.\n\t\t\t\telse if (!sourceType.equals(targetType.getElementTypeDescriptor())) {\n\t\t\t\t\targuments[varargsPosition] = converter.convertValue(argument, sourceType, targetType);\n\t\t\t\t}\n\t\t\t\t// Possible outcomes of the above if-else block:\n\t\t\t\t// 1) the input argument was null, and nothing was done.\n\t\t\t\t// 2) the input argument was null; the varargs element type is Optional; and the argument was converted to Optional.empty().\n\t\t\t\t// 3) the input argument was correct type but not wrapped in an array, and nothing was done.\n\t\t\t\t// 4) the input argument was already compatible (i.e., array of valid type), and nothing was done.\n\t\t\t\t// 5) the input argument was the wrong type and got converted and wrapped in an array.\n\t\t\t\tif (argument != arguments[varargsPosition] &&\n\t\t\t\t\t\t!isFirstEntryInArray(argument, arguments[varargsPosition])) {\n\t\t\t\t\tconversionOccurred = true; // case 5\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, convert remaining arguments to the varargs element type.\n\t\t\telse {\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor();\n\t\t\t\tAssert.state(targetType != null, \"No element type\");\n\t\t\t\tfor (int i = varargsPosition; i < arguments.length; i++) {\n\t\t\t\t\tObject argument = arguments[i];\n\t\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn conversionOccurred;\n\t}\n\n\t/**\n\t * Takes an input set of argument values and converts them to the parameter\n\t * types of the supplied {@link MethodHandle}.\n\t * <p>The arguments are converted 'in-place' in the input array.\n\t * @param converter the type converter to use for attempting conversions\n\t * @param arguments the actual arguments that need conversion\n\t * @param methodHandle the target MethodHandle\n\t * @param varargsPosition the known position of the varargs argument, if any\n\t * ({@code null} if not varargs)\n\t * @return {@code true} if some kind of conversion occurred on an argument\n\t * @throws EvaluationException if a problem occurs during conversion\n\t * @since 6.1\n\t */\n\tpublic static boolean convertAllMethodHandleArguments(TypeConverter converter, Object[] arguments,\n\t\t\tMethodHandle methodHandle, @Nullable Integer varargsPosition) throws EvaluationException {\n\n\t\tboolean conversionOccurred = false;\n\t\tfinal MethodType methodHandleArgumentTypes = methodHandle.type();\n\t\tif (varargsPosition == null) {\n\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\tClass<?> argumentClass = methodHandleArgumentTypes.parameterType(i);\n\t\t\t\tResolvableType resolvableType = ResolvableType.forClass(argumentClass);\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(resolvableType, argumentClass, null);\n\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Convert everything up to the varargs position\n\t\t\tfor (int i = 0; i < varargsPosition; i++) {\n\t\t\t\tClass<?> argumentClass = methodHandleArgumentTypes.parameterType(i);\n\t\t\t\tResolvableType resolvableType = ResolvableType.forClass(argumentClass);\n\t\t\t\tTypeDescriptor targetType = new TypeDescriptor(resolvableType, argumentClass, null);\n\n\t\t\t\tObject argument = arguments[i];\n\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t}\n\n\t\t\tfinal Class<?> varArgClass = methodHandleArgumentTypes.lastParameterType().componentType();\n\t\t\tResolvableType varArgResolvableType = ResolvableType.forClass(varArgClass);\n\t\t\tTypeDescriptor varArgContentType = new TypeDescriptor(varArgResolvableType, varArgClass, null);\n\n\t\t\t// If the target is varargs and there is just one more argument, then convert it here.\n\t\t\tif (varargsPosition == arguments.length - 1) {\n\t\t\t\tObject argument = arguments[varargsPosition];\n\t\t\t\tTypeDescriptor sourceType = TypeDescriptor.forObject(argument);\n\t\t\t\tif (argument == null) {\n\t\t\t\t\t// Perform the equivalent of GenericConversionService.convertNullSource() for a single argument.\n\t\t\t\t\tif (varArgContentType.getElementTypeDescriptor().getObjectType() == Optional.class) {\n\t\t\t\t\t\targuments[varargsPosition] = Optional.empty();\n\t\t\t\t\t\tconversionOccurred = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// If the argument type is equal to the varargs element type, there is no need to\n\t\t\t\t// convert it or wrap it in an array. For example, using StringToArrayConverter to\n\t\t\t\t// convert a String containing a comma would result in the String being split and\n\t\t\t\t// repackaged in an array when it should be used as-is.\n\t\t\t\telse if (!sourceType.equals(varArgContentType.getElementTypeDescriptor())) {\n\t\t\t\t\targuments[varargsPosition] = converter.convertValue(argument, sourceType, varArgContentType);\n\t\t\t\t}\n\t\t\t\t// Possible outcomes of the above if-else block:\n\t\t\t\t// 1) the input argument was null, and nothing was done.\n\t\t\t\t// 2) the input argument was null; the varargs element type is Optional; and the argument was converted to Optional.empty().\n\t\t\t\t// 3) the input argument was correct type but not wrapped in an array, and nothing was done.\n\t\t\t\t// 4) the input argument was already compatible (i.e., array of valid type), and nothing was done.\n\t\t\t\t// 5) the input argument was the wrong type and got converted and wrapped in an array.\n\t\t\t\tif (argument != arguments[varargsPosition] &&\n\t\t\t\t\t\t!isFirstEntryInArray(argument, arguments[varargsPosition])) {\n\t\t\t\t\tconversionOccurred = true; // case 5\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise, convert remaining arguments to the varargs element type.\n\t\t\telse {\n\t\t\t\tAssert.state(varArgContentType != null, \"No element type\");\n\t\t\t\tfor (int i = varargsPosition; i < arguments.length; i++) {\n\t\t\t\t\tObject argument = arguments[i];\n\t\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), varArgContentType);\n\t\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn conversionOccurred;\n\t}\n\n\t/**\n\t * Check if the supplied value is the first entry in the array represented by the possibleArray value.\n\t * @param value the value to check for in the array\n\t * @param possibleArray an array object that may have the supplied value as the first element\n\t * @return true if the supplied value is the first entry in the array\n\t */\n\tprivate static boolean isFirstEntryInArray(Object value, @Nullable Object possibleArray) {\n\t\tif (possibleArray == null) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> type = possibleArray.getClass();\n\t\tif (!type.isArray() || Array.getLength(possibleArray) == 0 ||\n\t\t\t\t!ClassUtils.isAssignableValue(type.componentType(), value)) {\n\t\t\treturn false;\n\t\t}\n\t\tObject arrayValue = Array.get(possibleArray, 0);\n\t\treturn (type.componentType().isPrimitive() ? arrayValue.equals(value) : arrayValue == value);\n\t}\n\n\t/**\n\t * Package up the arguments so that they correctly match what is expected in requiredParameterTypes.\n\t * <p>For example, if requiredParameterTypes is {@code (int, String[])} because the second parameter\n\t * was declared {@code String...}, then if arguments is {@code [1,\"a\",\"b\"]} then it must be\n\t * repackaged as {@code [1,new String[]{\"a\",\"b\"}]} in order to match the expected types.\n\t * @param requiredParameterTypes the types of the parameters for the invocation\n\t * @param args the arguments to be setup ready for the invocation\n\t * @return a repackaged array of arguments where any varargs setup has been done\n\t */\n\tpublic static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args) {\n\t\t// Check if array already built for final argument\n\t\tint parameterCount = requiredParameterTypes.length;\n\t\tint argumentCount = args.length;\n\n\t\t// Check if repackaging is needed...\n\t\tif (parameterCount != args.length ||\n\t\t\t\trequiredParameterTypes[parameterCount - 1] !=\n\t\t\t\t\t\t(args[argumentCount - 1] != null ? args[argumentCount - 1].getClass() : null)) {\n\n\t\t\t// Create an array for the leading arguments plus the varargs array argument.\n\t\t\tObject[] newArgs = new Object[parameterCount];\n\t\t\t// Copy all leading arguments to the new array, omitting the varargs array argument.\n\t\t\tSystem.arraycopy(args, 0, newArgs, 0, newArgs.length - 1);\n\n\t\t\t// Now sort out the final argument, which is the varargs one. Before entering this method,\n\t\t\t// the arguments should have been converted to the box form of the required type.\n\t\t\tint varargsArraySize = 0;  // zero size array if nothing to pass as the varargs parameter\n\t\t\tif (argumentCount >= parameterCount) {\n\t\t\t\tvarargsArraySize = argumentCount - (parameterCount - 1);\n\t\t\t}\n\t\t\tClass<?> componentType = requiredParameterTypes[parameterCount - 1].componentType();\n\t\t\tObject varargsArray = Array.newInstance(componentType, varargsArraySize);\n\t\t\tfor (int i = 0; i < varargsArraySize; i++) {\n\t\t\t\tArray.set(varargsArray, i, args[parameterCount - 1 + i]);\n\t\t\t}\n\t\t\t// Finally, add the varargs array to the new arguments array.\n\t\t\tnewArgs[newArgs.length - 1] = varargsArray;\n\t\t\treturn newArgs;\n\t\t}\n\t\treturn args;\n\t}\n\n\t/**\n\t * Find the first public class or interface in the method's class hierarchy\n\t * that declares the supplied method.\n\t * <p>Sometimes the reflective method discovery logic finds a suitable method\n\t * that can easily be called via reflection but cannot be called from generated\n\t * code when compiling the expression because of visibility restrictions. For\n\t * example, if a non-public class overrides {@code toString()}, this method\n\t * will traverse up the type hierarchy to find the first public type that\n\t * declares the method (if there is one). For {@code toString()}, it may\n\t * traverse as far as {@link Object}.\n\t * @param method the method to process\n\t * @return the public class or interface that declares the method, or\n\t * {@code null} if no such public type could be found\n\t * @since 6.2\n\t */\n\t@Nullable\n\tpublic static Class<?> findPublicDeclaringClass(Method method) {\n\t\treturn publicDeclaringClassCache.computeIfAbsent(method, key -> {\n\t\t\t\t// If the method is already defined in a public type, return that type.\n\t\t\t\tif (Modifier.isPublic(key.getDeclaringClass().getModifiers())) {\n\t\t\t\t\treturn key.getDeclaringClass();\n\t\t\t\t}\n\t\t\t\tMethod interfaceMethod = ClassUtils.getInterfaceMethodIfPossible(key, null);\n\t\t\t\t// If we found an interface method whose type is public, return the interface type.\n\t\t\t\tif (!interfaceMethod.equals(key)) {\n\t\t\t\t\tif (Modifier.isPublic(interfaceMethod.getDeclaringClass().getModifiers())) {\n\t\t\t\t\t\treturn interfaceMethod.getDeclaringClass();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Attempt to search the type hierarchy.\n\t\t\t\tClass<?> superclass = key.getDeclaringClass().getSuperclass();\n\t\t\t\tif (superclass != null) {\n\t\t\t\t\treturn findPublicDeclaringClass(superclass, key.getName(), key.getParameterTypes());\n\t\t\t\t}\n\t\t\t\t// Otherwise, no public declaring class found.\n\t\t\t\treturn null;\n\t\t\t});\n\t}\n\n\t@Nullable\n\tprivate static Class<?> findPublicDeclaringClass(\n\t\t\tClass<?> declaringClass, String methodName, Class<?>[] parameterTypes) {\n\n\t\tif (Modifier.isPublic(declaringClass.getModifiers())) {\n\t\t\ttry {\n\t\t\t\tdeclaringClass.getDeclaredMethod(methodName, parameterTypes);\n\t\t\t\treturn declaringClass;\n\t\t\t}\n\t\t\tcatch (NoSuchMethodException ex) {\n\t\t\t\t// Continue below...\n\t\t\t}\n\t\t}\n\n\t\tClass<?> superclass = declaringClass.getSuperclass();\n\t\tif (superclass != null) {\n\t\t\treturn findPublicDeclaringClass(superclass, methodName, parameterTypes);\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * Arguments match kinds.\n\t */\n\tenum ArgumentsMatchKind {\n\n\t\t/** An exact match is where the parameter types exactly match what the method/constructor is expecting. */\n\t\tEXACT,\n\n\t\t/** A close match is where the parameter types either exactly match or are assignment-compatible. */\n\t\tCLOSE,\n\n\t\t/** A conversion match is where the type converter must be used to transform some of the parameter types. */\n\t\tREQUIRES_CONVERSION\n\t}\n\n\n\t/**\n\t * An instance of ArgumentsMatchInfo describes what kind of match was achieved\n\t * between two sets of arguments - the set that a method/constructor is expecting\n\t * and the set that are being supplied at the point of invocation. If the kind\n\t * indicates that conversion is required for some of the arguments then the arguments\n\t * that require conversion are listed in the argsRequiringConversion array.\n\t *\n\t * @param kind the kind of match that was achieved\n\t */\n\trecord ArgumentsMatchInfo(ArgumentsMatchKind kind) {\n\n\t\tpublic boolean isExactMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.EXACT);\n\t\t}\n\n\t\tpublic boolean isCloseMatch() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.CLOSE);\n\t\t}\n\n\t\tpublic boolean isMatchRequiringConversion() {\n\t\t\treturn (this.kind == ArgumentsMatchKind.REQUIRES_CONVERSION);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"ArgumentMatchInfo: \" + this.kind;\n\t\t}\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 6,
                "candidates": [
                    {
                        "lineStart": 60,
                        "lineEnd": 102,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method compareArguments to class ReflectiveMethodResolver",
                        "description": "move method to org.springframework.expression.spel.support.ReflectiveMethodResolver\nRationale: The method compareArguments involves deciding the match kind based on expected and supplied argument types which would be part of method resolution process. Therefore, it may be best to move this method to the ReflectiveMethodResolver class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 147,
                        "lineEnd": 244,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method compareArgumentsVarargs to class ReflectiveMethodResolver",
                        "description": "move method to org.springframework.expression.spel.support.ReflectiveMethodResolver\nRationale: This method is used for comparing argument arrays and possibly resolve methods. ReflectiveMethodResolver is the most suitable class as it is responsible for method resolution.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 459,
                        "lineEnd": 499,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method setupArgumentsForVarargsInvocation to class ReflectiveMethodResolver",
                        "description": "move method to org.springframework.expression.spel.support.ReflectiveMethodResolver\nRationale: The method `setupArgumentsForVarargsInvocation` is used for dynamically resolving methods at runtime and the parameter types provided, which aligns closely with the responsibilities of the ReflectiveMethodResolver class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 246,
                        "lineEnd": 272,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method convertAllArguments to class ReflectiveMethodExecutor",
                        "description": "move method to org.springframework.expression.spel.support.ReflectiveMethodExecutor\nRationale: Since this method is dealing with conversion of arguments for methods and does operations like checking if the method is varargs, setting up arguments and throwing SpelEvaluationExceptions, it seems to be related to reflection execution of methods. It should belong to 'ReflectiveMethodExecutor' class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 540,
                        "lineEnd": 559,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method findPublicDeclaringClass to class ReflectiveMethodResolver",
                        "description": "move method to org.springframework.expression.spel.support.ReflectiveMethodResolver\nRationale: The 'findPublicDeclaringClass' method is primarily involved with resolving methods based on the provided class, method name, and parameter types. This behaviour fits within the responsibilities of the 'ReflectiveMethodResolver' class, which is explicitly designed to handle such method resolution tasks.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 104,
                        "lineEnd": 145,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method getTypeDifferenceWeight to class ReflectiveMethodResolver",
                        "description": "move method to org.springframework.expression.spel.support.ReflectiveMethodResolver\nRationale: getTypeDifferenceWeight() method appears to be used for resolving method invocation based on the types of arguments, which is typical behavior for a method resolver. Among the options, ReflectiveMethodResolver is the most appropriate class for this method since it's related to method resolution using reflection.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "convertAllArguments",
                            "method_signature": "public convertAllArguments(TypeConverter, Object[], Method): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "The convertAllArguments() method primarily deals with converting types, which relates more to the functionality of the TypeConverter class."
                        },
                        {
                            "method_name": "convertArguments",
                            "method_signature": "static convertArguments(TypeConverter, Object[], Executable, Integer): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "The convertArguments() method primarily deals with converting types, so it would be more appropriately placed in the TypeConverter class."
                        },
                        {
                            "method_name": "convertAllMethodHandleArguments",
                            "method_signature": "public convertAllMethodHandleArguments(TypeConverter, Object[], MethodHandle, Integer): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "In line with the previous recommendations, the convertAllMethodHandleArguments() method should also be moved to the TypeConverter class as it is also concerned with type conversion."
                        },
                        {
                            "method_name": "setupArgumentsForVarargsInvocation",
                            "method_signature": "public setupArgumentsForVarargsInvocation(Class<?>[], Object...): Object[]",
                            "target_class": "VarargsUtil",
                            "rationale": "The method setupArgumentsForVarargsInvocation() deals specifically with varargs, it would make sense to create a separate utility class for handling varargs scenarios."
                        }
                    ],
                    "llm_response_time": 20190
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "compareArguments",
                            "method_signature": "static ArgumentsMatchInfo compareArguments(List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter)",
                            "target_class": "ArgumentsMatcher",
                            "rationale": "This method is more related to argument matching and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "getTypeDifferenceWeight",
                            "method_signature": "public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes)",
                            "target_class": "TypeComparator",
                            "rationale": "This method is more related to comparing types, and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "compareArgumentsVarargs",
                            "method_signature": "static ArgumentsMatchInfo compareArgumentsVarargs(List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter)",
                            "target_class": "ArgumentsMatcher",
                            "rationale": "This method is also more related to argument matching and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "convertAllArguments",
                            "method_signature": "public static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException",
                            "target_class": "ArgumentsConverter",
                            "rationale": "This method is more related to converting arguments, and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "convertArguments",
                            "method_signature": "static boolean convertArguments(TypeConverter converter, Object[] arguments, Executable executable, @Nullable Integer varargsPosition) throws EvaluationException",
                            "target_class": "ArgumentsConverter",
                            "rationale": "This method is also more related to converting arguments, and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "setupArgumentsForVarargsInvocation",
                            "method_signature": "public static Object[] setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args)",
                            "target_class": "VarargsHelper",
                            "rationale": "This method is more related to varargs processing, and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "findPublicDeclaringClass",
                            "method_signature": "@Nullable public static Class<?> findPublicDeclaringClass(Method method)",
                            "target_class": "ReflectionUtils",
                            "rationale": "This method seems better suited to a general utility class focused on reflection operations."
                        }
                    ],
                    "llm_response_time": 22592
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "convertAllArguments",
                            "method_signature": "public convertAllArguments(TypeConverter converter, Object[] arguments, Method method): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "convertAllArguments method relies heavily on the TypeConverter class, so it would be more cohesive to move this method to the TypeConverter class."
                        },
                        {
                            "method_name": "convertArguments",
                            "method_signature": "static convertArguments(TypeConverter converter, Object[] arguments, Executable executable, @Nullable Integer varargsPosition): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "convertArguments method relies heavily on the TypeConverter class, so it would be more cohesive to move this method to the TypeConverter class."
                        },
                        {
                            "method_name": "convertAllMethodHandleArguments",
                            "method_signature": "public convertAllMethodHandleArguments(TypeConverter converter, Object[] arguments, MethodHandle methodHandle, @Nullable Integer varargsPosition): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "convertAllMethodHandleArguments method relies heavily on the TypeConverter class, so it would be more cohesive to move this method to the TypeConverter class."
                        },
                        {
                            "method_name": "setupArgumentsForVarargsInvocation",
                            "method_signature": "public setupArgumentsForVarargsInvocation(Class<?>[] requiredParameterTypes, Object... args): Object[]",
                            "target_class": "TypeUtil",
                            "rationale": "setupArgumentsForVarargsInvocation method is more related to Utilities for types, so TypeUtil would be a more appropriate class to move this method."
                        },
                        {
                            "method_name": "findPublicDeclaringClass",
                            "method_signature": "public findPublicDeclaringClass(Method method): Class<?>",
                            "target_class": "ClassUtil",
                            "rationale": "findPublicDeclaringClass method is more related to Utilities for classes, so ClassUtil would be a more appropriate class to move this method."
                        }
                    ],
                    "llm_response_time": 28120
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "convertAllArguments",
                            "method_signature": "public convertAllArguments(TypeConverter, Object[], Method): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "The convertAllArguments() method primarily deals with converting types, which relates more to the functionality of the TypeConverter class."
                        },
                        {
                            "method_name": "convertArguments",
                            "method_signature": "static convertArguments(TypeConverter, Object[], Executable, Integer): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "The convertArguments() method primarily deals with converting types, so it would be more appropriately placed in the TypeConverter class."
                        },
                        {
                            "method_name": "convertAllMethodHandleArguments",
                            "method_signature": "public convertAllMethodHandleArguments(TypeConverter, Object[], MethodHandle, Integer): boolean",
                            "target_class": "TypeConverter",
                            "rationale": "In line with the previous recommendations, the convertAllMethodHandleArguments() method should also be moved to the TypeConverter class as it is also concerned with type conversion."
                        },
                        {
                            "method_name": "setupArgumentsForVarargsInvocation",
                            "method_signature": "public setupArgumentsForVarargsInvocation(Class<?>[], Object...): Object[]",
                            "target_class": "VarargsUtil",
                            "rationale": "The method setupArgumentsForVarargsInvocation() deals specifically with varargs, it would make sense to create a separate utility class for handling varargs scenarios."
                        },
                        {
                            "method_name": "compareArguments",
                            "method_signature": "static ArgumentsMatchInfo compareArguments(List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter)",
                            "target_class": "ArgumentsMatcher",
                            "rationale": "This method is more related to argument matching and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "getTypeDifferenceWeight",
                            "method_signature": "public static int getTypeDifferenceWeight(List<TypeDescriptor> paramTypes, List<TypeDescriptor> argTypes)",
                            "target_class": "TypeComparator",
                            "rationale": "This method is more related to comparing types, and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "compareArgumentsVarargs",
                            "method_signature": "static ArgumentsMatchInfo compareArgumentsVarargs(List<TypeDescriptor> expectedArgTypes, List<TypeDescriptor> suppliedArgTypes, TypeConverter typeConverter)",
                            "target_class": "ArgumentsMatcher",
                            "rationale": "This method is also more related to argument matching and would fit better in a class focused on that."
                        },
                        {
                            "method_name": "findPublicDeclaringClass",
                            "method_signature": "@Nullable public static Class<?> findPublicDeclaringClass(Method method)",
                            "target_class": "ReflectionUtils",
                            "rationale": "This method seems better suited to a general utility class focused on reflection operations."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "compareArguments",
                    "compareArgumentsVarargs",
                    "setupArgumentsForVarargsInvocation",
                    "convertAllArguments",
                    "convertAllMethodHandleArguments",
                    "findPublicDeclaringClass",
                    "convertArguments",
                    "getTypeDifferenceWeight"
                ],
                "llm_response_time": 6528
            },
            "targetClassMap": {
                "compareArguments": {
                    "target_classes": [
                        {
                            "class_name": "BooleanTypedValue",
                            "similarity_score": 0.40028399009612253
                        },
                        {
                            "class_name": "StandardTypeLocator",
                            "similarity_score": 0.6218507902373729
                        },
                        {
                            "class_name": "StandardTypeConverter",
                            "similarity_score": 0.5551940070294571
                        },
                        {
                            "class_name": "StandardTypeComparator",
                            "similarity_score": 0.5106445287116335
                        },
                        {
                            "class_name": "SimpleEvaluationContext",
                            "similarity_score": 0.5438282883848101
                        },
                        {
                            "class_name": "ReflectiveMethodExecutor",
                            "similarity_score": 0.600583441116239
                        },
                        {
                            "class_name": "ReflectiveMethodResolver",
                            "similarity_score": 0.768839401599597
                        },
                        {
                            "class_name": "DataBindingMethodResolver",
                            "similarity_score": 0.5112191484764215
                        },
                        {
                            "class_name": "StandardEvaluationContext",
                            "similarity_score": 0.6404575772684243
                        },
                        {
                            "class_name": "ReflectivePropertyAccessor",
                            "similarity_score": 0.680292242838623
                        },
                        {
                            "class_name": "StandardOperatorOverloader",
                            "similarity_score": 0.34287613929136845
                        },
                        {
                            "class_name": "DataBindingPropertyAccessor",
                            "similarity_score": 0.4495405232406161
                        },
                        {
                            "class_name": "ReflectiveConstructorExecutor",
                            "similarity_score": 0.5647807988243394
                        },
                        {
                            "class_name": "ReflectiveConstructorResolver",
                            "similarity_score": 0.7736566974030129
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReflectiveMethodResolver",
                        "ReflectiveConstructorResolver",
                        "StandardTypeConverter",
                        "ReflectivePropertyAccessor",
                        "StandardEvaluationContext",
                        "StandardTypeLocator",
                        "ReflectiveMethodExecutor",
                        "ReflectiveConstructorExecutor",
                        "SimpleEvaluationContext",
                        "DataBindingMethodResolver",
                        "StandardTypeComparator",
                        "DataBindingPropertyAccessor",
                        "BooleanTypedValue",
                        "StandardOperatorOverloader"
                    ],
                    "llm_response_time": 6953,
                    "similarity_computation_time": 15,
                    "similarity_metric": "cosine"
                },
                "compareArgumentsVarargs": {
                    "target_classes": [
                        {
                            "class_name": "BooleanTypedValue",
                            "similarity_score": 0.3641661542608559
                        },
                        {
                            "class_name": "StandardTypeLocator",
                            "similarity_score": 0.5907728131988601
                        },
                        {
                            "class_name": "StandardTypeConverter",
                            "similarity_score": 0.5255611356971114
                        },
                        {
                            "class_name": "StandardTypeComparator",
                            "similarity_score": 0.5766752791935843
                        },
                        {
                            "class_name": "SimpleEvaluationContext",
                            "similarity_score": 0.4616813614705038
                        },
                        {
                            "class_name": "ReflectiveMethodExecutor",
                            "similarity_score": 0.5997601644929319
                        },
                        {
                            "class_name": "ReflectiveMethodResolver",
                            "similarity_score": 0.8111909245671576
                        },
                        {
                            "class_name": "DataBindingMethodResolver",
                            "similarity_score": 0.48339200108241454
                        },
                        {
                            "class_name": "StandardEvaluationContext",
                            "similarity_score": 0.6033065845068664
                        },
                        {
                            "class_name": "ReflectivePropertyAccessor",
                            "similarity_score": 0.7431371655130967
                        },
                        {
                            "class_name": "StandardOperatorOverloader",
                            "similarity_score": 0.31799872196498324
                        },
                        {
                            "class_name": "DataBindingPropertyAccessor",
                            "similarity_score": 0.36525137048775413
                        },
                        {
                            "class_name": "ReflectiveConstructorExecutor",
                            "similarity_score": 0.6095440682466583
                        },
                        {
                            "class_name": "ReflectiveConstructorResolver",
                            "similarity_score": 0.8130826867371875
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReflectiveMethodResolver",
                        "ReflectiveConstructorResolver",
                        "StandardTypeConverter",
                        "ReflectivePropertyAccessor",
                        "ReflectiveConstructorExecutor",
                        "StandardEvaluationContext",
                        "ReflectiveMethodExecutor",
                        "StandardTypeLocator",
                        "StandardTypeComparator",
                        "DataBindingMethodResolver",
                        "SimpleEvaluationContext",
                        "DataBindingPropertyAccessor",
                        "BooleanTypedValue",
                        "StandardOperatorOverloader"
                    ],
                    "llm_response_time": 7897,
                    "similarity_computation_time": 17,
                    "similarity_metric": "cosine"
                },
                "setupArgumentsForVarargsInvocation": {
                    "target_classes": [
                        {
                            "class_name": "BooleanTypedValue",
                            "similarity_score": 0.2590417211774742
                        },
                        {
                            "class_name": "StandardTypeLocator",
                            "similarity_score": 0.5231380307772263
                        },
                        {
                            "class_name": "StandardTypeConverter",
                            "similarity_score": 0.42776611144742394
                        },
                        {
                            "class_name": "StandardTypeComparator",
                            "similarity_score": 0.2906110807566539
                        },
                        {
                            "class_name": "SimpleEvaluationContext",
                            "similarity_score": 0.4169994120572662
                        },
                        {
                            "class_name": "ReflectiveMethodExecutor",
                            "similarity_score": 0.5210102416096528
                        },
                        {
                            "class_name": "ReflectiveMethodResolver",
                            "similarity_score": 0.6141982870980686
                        },
                        {
                            "class_name": "DataBindingMethodResolver",
                            "similarity_score": 0.304740462598988
                        },
                        {
                            "class_name": "StandardEvaluationContext",
                            "similarity_score": 0.5406575001405886
                        },
                        {
                            "class_name": "ReflectivePropertyAccessor",
                            "similarity_score": 0.4497235322653146
                        },
                        {
                            "class_name": "StandardOperatorOverloader",
                            "similarity_score": 0.19603110415214706
                        },
                        {
                            "class_name": "DataBindingPropertyAccessor",
                            "similarity_score": 0.2926872614116674
                        },
                        {
                            "class_name": "ReflectiveConstructorExecutor",
                            "similarity_score": 0.3119282858488108
                        },
                        {
                            "class_name": "ReflectiveConstructorResolver",
                            "similarity_score": 0.675657296823273
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReflectiveMethodResolver",
                        "ReflectiveMethodExecutor",
                        "ReflectiveConstructorResolver",
                        "StandardEvaluationContext",
                        "StandardTypeLocator",
                        "ReflectivePropertyAccessor",
                        "StandardTypeConverter",
                        "SimpleEvaluationContext",
                        "ReflectiveConstructorExecutor",
                        "DataBindingMethodResolver",
                        "DataBindingPropertyAccessor",
                        "StandardTypeComparator",
                        "BooleanTypedValue",
                        "StandardOperatorOverloader"
                    ],
                    "llm_response_time": 8362,
                    "similarity_computation_time": 34,
                    "similarity_metric": "cosine"
                },
                "convertAllArguments": {
                    "target_classes": [
                        {
                            "class_name": "BooleanTypedValue",
                            "similarity_score": 0.3709540577627336
                        },
                        {
                            "class_name": "StandardTypeLocator",
                            "similarity_score": 0.670043526401822
                        },
                        {
                            "class_name": "StandardTypeConverter",
                            "similarity_score": 0.571276375694701
                        },
                        {
                            "class_name": "StandardTypeComparator",
                            "similarity_score": 0.18284759913772286
                        },
                        {
                            "class_name": "SimpleEvaluationContext",
                            "similarity_score": 0.6824089337267754
                        },
                        {
                            "class_name": "ReflectiveMethodExecutor",
                            "similarity_score": 0.6346346644868486
                        },
                        {
                            "class_name": "ReflectiveMethodResolver",
                            "similarity_score": 0.588612531899537
                        },
                        {
                            "class_name": "DataBindingMethodResolver",
                            "similarity_score": 0.46706365800314503
                        },
                        {
                            "class_name": "StandardEvaluationContext",
                            "similarity_score": 0.7075251977736101
                        },
                        {
                            "class_name": "ReflectivePropertyAccessor",
                            "similarity_score": 0.36510041708349933
                        },
                        {
                            "class_name": "StandardOperatorOverloader",
                            "similarity_score": 0.2594378721924932
                        },
                        {
                            "class_name": "DataBindingPropertyAccessor",
                            "similarity_score": 0.5508515023795626
                        },
                        {
                            "class_name": "ReflectiveConstructorExecutor",
                            "similarity_score": 0.2867097085410729
                        },
                        {
                            "class_name": "ReflectiveConstructorResolver",
                            "similarity_score": 0.6072408331784407
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReflectiveMethodExecutor",
                        "StandardTypeConverter",
                        "StandardEvaluationContext",
                        "SimpleEvaluationContext",
                        "StandardTypeLocator",
                        "ReflectiveConstructorResolver",
                        "ReflectiveMethodResolver",
                        "DataBindingPropertyAccessor",
                        "DataBindingMethodResolver",
                        "BooleanTypedValue",
                        "ReflectivePropertyAccessor",
                        "ReflectiveConstructorExecutor",
                        "StandardOperatorOverloader",
                        "StandardTypeComparator"
                    ],
                    "llm_response_time": 7594,
                    "similarity_computation_time": 28,
                    "similarity_metric": "cosine"
                },
                "convertAllMethodHandleArguments": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 11840,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "findPublicDeclaringClass": {
                    "target_classes": [
                        {
                            "class_name": "BooleanTypedValue",
                            "similarity_score": 0.2948965571464163
                        },
                        {
                            "class_name": "StandardTypeLocator",
                            "similarity_score": 0.3775538019939049
                        },
                        {
                            "class_name": "StandardTypeConverter",
                            "similarity_score": 0.34564031698569353
                        },
                        {
                            "class_name": "StandardTypeComparator",
                            "similarity_score": 0.5813233085358505
                        },
                        {
                            "class_name": "SimpleEvaluationContext",
                            "similarity_score": 0.23470535485913493
                        },
                        {
                            "class_name": "ReflectiveMethodExecutor",
                            "similarity_score": 0.4225106791953807
                        },
                        {
                            "class_name": "ReflectiveMethodResolver",
                            "similarity_score": 0.5697628681961318
                        },
                        {
                            "class_name": "DataBindingMethodResolver",
                            "similarity_score": 0.45237292565365317
                        },
                        {
                            "class_name": "StandardEvaluationContext",
                            "similarity_score": 0.3410653666820637
                        },
                        {
                            "class_name": "ReflectivePropertyAccessor",
                            "similarity_score": 0.6664687435560802
                        },
                        {
                            "class_name": "StandardOperatorOverloader",
                            "similarity_score": 0.3124302001369961
                        },
                        {
                            "class_name": "DataBindingPropertyAccessor",
                            "similarity_score": 0.21742347154279043
                        },
                        {
                            "class_name": "ReflectiveConstructorExecutor",
                            "similarity_score": 0.583838669960598
                        },
                        {
                            "class_name": "ReflectiveConstructorResolver",
                            "similarity_score": 0.4869807930279584
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReflectiveMethodResolver",
                        "ReflectiveConstructorResolver",
                        "ReflectivePropertyAccessor",
                        "ReflectiveConstructorExecutor",
                        "StandardTypeComparator",
                        "DataBindingMethodResolver",
                        "ReflectiveMethodExecutor",
                        "StandardTypeLocator",
                        "StandardTypeConverter",
                        "StandardEvaluationContext",
                        "StandardOperatorOverloader",
                        "BooleanTypedValue",
                        "SimpleEvaluationContext",
                        "DataBindingPropertyAccessor"
                    ],
                    "llm_response_time": 7533,
                    "similarity_computation_time": 26,
                    "similarity_metric": "cosine"
                },
                "convertArguments": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 8988,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "getTypeDifferenceWeight": {
                    "target_classes": [
                        {
                            "class_name": "BooleanTypedValue",
                            "similarity_score": 0.366437555940004
                        },
                        {
                            "class_name": "StandardTypeLocator",
                            "similarity_score": 0.39454752660965775
                        },
                        {
                            "class_name": "StandardTypeConverter",
                            "similarity_score": 0.3968905129529466
                        },
                        {
                            "class_name": "StandardTypeComparator",
                            "similarity_score": 0.584926415150998
                        },
                        {
                            "class_name": "SimpleEvaluationContext",
                            "similarity_score": 0.28263446587352137
                        },
                        {
                            "class_name": "ReflectiveMethodExecutor",
                            "similarity_score": 0.4980218363351869
                        },
                        {
                            "class_name": "ReflectiveMethodResolver",
                            "similarity_score": 0.6823217371272611
                        },
                        {
                            "class_name": "DataBindingMethodResolver",
                            "similarity_score": 0.43137962484165293
                        },
                        {
                            "class_name": "StandardEvaluationContext",
                            "similarity_score": 0.4160648669892917
                        },
                        {
                            "class_name": "ReflectivePropertyAccessor",
                            "similarity_score": 0.7438819732675216
                        },
                        {
                            "class_name": "StandardOperatorOverloader",
                            "similarity_score": 0.3099536764398061
                        },
                        {
                            "class_name": "DataBindingPropertyAccessor",
                            "similarity_score": 0.23696623297685504
                        },
                        {
                            "class_name": "ReflectiveConstructorExecutor",
                            "similarity_score": 0.6351869321977228
                        },
                        {
                            "class_name": "ReflectiveConstructorResolver",
                            "similarity_score": 0.5956319353133275
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReflectiveMethodResolver",
                        "StandardTypeComparator",
                        "ReflectivePropertyAccessor",
                        "ReflectiveConstructorExecutor",
                        "ReflectiveConstructorResolver",
                        "ReflectiveMethodExecutor",
                        "DataBindingMethodResolver",
                        "StandardEvaluationContext",
                        "StandardTypeConverter",
                        "StandardTypeLocator",
                        "BooleanTypedValue",
                        "StandardOperatorOverloader",
                        "SimpleEvaluationContext",
                        "DataBindingPropertyAccessor"
                    ],
                    "llm_response_time": 11655,
                    "similarity_computation_time": 30,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "9202c0ad41300babd10cd1a63599b30a35e1ede8",
        "url": "https://github.com/spring-projects/spring-framework/commit/9202c0ad41300babd10cd1a63599b30a35e1ede8",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method package compiledByAjc(clazz Class<?>) : boolean from class org.springframework.aop.aspectj.annotation.AbstractAspectJAdvisorFactory to private compiledByAjc(clazz Class<?>) : boolean from class org.springframework.aop.aspectj.annotation.AspectJAdvisorBeanRegistrationAotProcessor",
            "leftSideLocations": [
                {
                    "filePath": "spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactory.java",
                    "startLine": 86,
                    "endLine": 100,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "package compiledByAjc(clazz Class<?>) : boolean"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AspectJAdvisorBeanRegistrationAotProcessor.java",
                    "startLine": 57,
                    "endLine": 64,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "private compiledByAjc(clazz Class<?>) : boolean"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "cf0f2083-3193-44fe-8deb-d73f88be2e25",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 231,
                "lineStart": 44,
                "lineEnd": 274,
                "bodyLineStart": 44,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-aop/src/main/java/org/springframework/aop/aspectj/annotation/AbstractAspectJAdvisorFactory.java",
                "sourceCode": "/**\n * Abstract base class for factories that can create Spring AOP Advisors\n * given AspectJ classes from classes honoring the AspectJ 5 annotation syntax.\n *\n * <p>This class handles annotation parsing and validation functionality.\n * It does not actually generate Spring AOP Advisors, which is deferred to subclasses.\n *\n * @author Rod Johnson\n * @author Adrian Colyer\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @since 2.0\n */\npublic abstract class AbstractAspectJAdvisorFactory implements AspectJAdvisorFactory {\n\n\tprivate static final String AJC_MAGIC = \"ajc$\";\n\n\tprivate static final Class<?>[] ASPECTJ_ANNOTATION_CLASSES = new Class<?>[] {\n\t\t\tPointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class};\n\n\n\t/** Logger available to subclasses. */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprotected final ParameterNameDiscoverer parameterNameDiscoverer = new AspectJAnnotationParameterNameDiscoverer();\n\n\n\t/**\n\t * We consider something to be an AspectJ aspect suitable for use by the Spring AOP system\n\t * if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test\n\t * is that aspects written in the code-style (AspectJ language) also have the annotation present\n\t * when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.\n\t */\n\t@Override\n\tpublic boolean isAspect(Class<?> clazz) {\n\t\treturn (hasAspectAnnotation(clazz) && !compiledByAjc(clazz));\n\t}\n\n\tprivate boolean hasAspectAnnotation(Class<?> clazz) {\n\t\treturn (AnnotationUtils.findAnnotation(clazz, Aspect.class) != null);\n\t}\n\n\t/**\n\t * We need to detect this as \"code-style\" AspectJ aspects should not be\n\t * interpreted by Spring AOP.\n\t */\n\tstatic boolean compiledByAjc(Class<?> clazz) {\n\t\t// The AJTypeSystem goes to great lengths to provide a uniform appearance between code-style and\n\t\t// annotation-style aspects. Therefore there is no 'clean' way to tell them apart. Here we rely on\n\t\t// an implementation detail of the AspectJ compiler.\n\t\tfor (Field field : clazz.getDeclaredFields()) {\n\t\t\tif (field.getName().startsWith(AJC_MAGIC)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void validate(Class<?> aspectClass) throws AopConfigException {\n\t\tAjType<?> ajType = AjTypeSystem.getAjType(aspectClass);\n\t\tif (!ajType.isAspect()) {\n\t\t\tthrow new NotAnAtAspectException(aspectClass);\n\t\t}\n\t\tif (ajType.getPerClause().getKind() == PerClauseKind.PERCFLOW) {\n\t\t\tthrow new AopConfigException(aspectClass.getName() + \" uses percflow instantiation model: \" +\n\t\t\t\t\t\"This is not supported in Spring AOP.\");\n\t\t}\n\t\tif (ajType.getPerClause().getKind() == PerClauseKind.PERCFLOWBELOW) {\n\t\t\tthrow new AopConfigException(aspectClass.getName() + \" uses percflowbelow instantiation model: \" +\n\t\t\t\t\t\"This is not supported in Spring AOP.\");\n\t\t}\n\t}\n\n\t/**\n\t * Find and return the first AspectJ annotation on the given method\n\t * (there <i>should</i> only be one anyway...).\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tprotected static AspectJAnnotation findAspectJAnnotationOnMethod(Method method) {\n\t\tfor (Class<?> annotationType : ASPECTJ_ANNOTATION_CLASSES) {\n\t\t\tAspectJAnnotation annotation = findAnnotation(method, (Class<Annotation>) annotationType);\n\t\t\tif (annotation != null) {\n\t\t\t\treturn annotation;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Nullable\n\tprivate static AspectJAnnotation findAnnotation(Method method, Class<? extends Annotation> annotationType) {\n\t\tAnnotation annotation = AnnotationUtils.findAnnotation(method, annotationType);\n\t\tif (annotation != null) {\n\t\t\treturn new AspectJAnnotation(annotation);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\t/**\n\t * Enum for AspectJ annotation types.\n\t * @see AspectJAnnotation#getAnnotationType()\n\t */\n\tprotected enum AspectJAnnotationType {\n\n\t\tAtPointcut, AtAround, AtBefore, AtAfter, AtAfterReturning, AtAfterThrowing\n\t}\n\n\n\t/**\n\t * Class modeling an AspectJ annotation, exposing its type enumeration and\n\t * pointcut String.\n\t */\n\tprotected static class AspectJAnnotation {\n\n\t\tprivate static final String[] EXPRESSION_ATTRIBUTES = {\"pointcut\", \"value\"};\n\n\t\tprivate static final Map<Class<?>, AspectJAnnotationType> annotationTypeMap = Map.of(\n\t\t\t\tPointcut.class, AspectJAnnotationType.AtPointcut, //\n\t\t\t\tAround.class, AspectJAnnotationType.AtAround, //\n\t\t\t\tBefore.class, AspectJAnnotationType.AtBefore, //\n\t\t\t\tAfter.class, AspectJAnnotationType.AtAfter, //\n\t\t\t\tAfterReturning.class, AspectJAnnotationType.AtAfterReturning, //\n\t\t\t\tAfterThrowing.class, AspectJAnnotationType.AtAfterThrowing //\n\t\t\t);\n\n\t\tprivate final Annotation annotation;\n\n\t\tprivate final AspectJAnnotationType annotationType;\n\n\t\tprivate final String pointcutExpression;\n\n\t\tprivate final String argumentNames;\n\n\t\tpublic AspectJAnnotation(Annotation annotation) {\n\t\t\tthis.annotation = annotation;\n\t\t\tthis.annotationType = determineAnnotationType(annotation);\n\t\t\ttry {\n\t\t\t\tthis.pointcutExpression = resolvePointcutExpression(annotation);\n\t\t\t\tObject argNames = AnnotationUtils.getValue(annotation, \"argNames\");\n\t\t\t\tthis.argumentNames = (argNames instanceof String names ? names : \"\");\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalArgumentException(annotation + \" is not a valid AspectJ annotation\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate AspectJAnnotationType determineAnnotationType(Annotation annotation) {\n\t\t\tAspectJAnnotationType type = annotationTypeMap.get(annotation.annotationType());\n\t\t\tif (type != null) {\n\t\t\t\treturn type;\n\t\t\t}\n\t\t\tthrow new IllegalStateException(\"Unknown annotation type: \" + annotation);\n\t\t}\n\n\t\tprivate String resolvePointcutExpression(Annotation annotation) {\n\t\t\tfor (String attributeName : EXPRESSION_ATTRIBUTES) {\n\t\t\t\tObject val = AnnotationUtils.getValue(annotation, attributeName);\n\t\t\t\tif (val instanceof String str && !str.isEmpty()) {\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new IllegalStateException(\"Failed to resolve pointcut expression in: \" + annotation);\n\t\t}\n\n\t\tpublic AspectJAnnotationType getAnnotationType() {\n\t\t\treturn this.annotationType;\n\t\t}\n\n\t\tpublic Annotation getAnnotation() {\n\t\t\treturn this.annotation;\n\t\t}\n\n\t\tpublic String getPointcutExpression() {\n\t\t\treturn this.pointcutExpression;\n\t\t}\n\n\t\tpublic String getArgumentNames() {\n\t\t\treturn this.argumentNames;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.annotation.toString();\n\t\t}\n\t}\n\n\n\t/**\n\t * ParameterNameDiscoverer implementation that analyzes the arg names\n\t * specified at the AspectJ annotation level.\n\t */\n\tprivate static class AspectJAnnotationParameterNameDiscoverer implements ParameterNameDiscoverer {\n\n\t\tprivate static final String[] EMPTY_ARRAY = new String[0];\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic String[] getParameterNames(Method method) {\n\t\t\tif (method.getParameterCount() == 0) {\n\t\t\t\treturn EMPTY_ARRAY;\n\t\t\t}\n\t\t\tAspectJAnnotation annotation = findAspectJAnnotationOnMethod(method);\n\t\t\tif (annotation == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tStringTokenizer nameTokens = new StringTokenizer(annotation.getArgumentNames(), \",\");\n\t\t\tint numTokens = nameTokens.countTokens();\n\t\t\tif (numTokens > 0) {\n\t\t\t\tString[] names = new String[numTokens];\n\t\t\t\tfor (int i = 0; i < names.length; i++) {\n\t\t\t\t\tnames[i] = nameTokens.nextToken();\n\t\t\t\t}\n\t\t\t\treturn names;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic String[] getParameterNames(Constructor<?> ctor) {\n\t\t\tthrow new UnsupportedOperationException(\"Spring AOP cannot handle constructor advice\");\n\t\t}\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "compiledByAjc",
                            "method_signature": "static boolean compiledByAjc(Class<?> clazz)",
                            "target_class": "AjcHelper",
                            "rationale": "The method 'compiledByAjc' checks if a class has been compiled by ajc. This is a general utility that could be used by outer components or classes and does not strictly belong to 'AbstractAspectJAdvisorFactory'."
                        },
                        {
                            "method_name": "findAspectJAnnotationOnMethod",
                            "method_signature": "static AspectJAnnotation findAspectJAnnotationOnMethod(Method method)",
                            "target_class": "AspectJAnnotationUtils",
                            "rationale": "The method 'findAspectJAnnotationOnMethod' checks for AspectJ annotations on a method. This utility function may be useful in other classes for detecting annotations and should thus not tightly belong to 'AbstractAspectJAdvisorFactory'."
                        },
                        {
                            "method_name": "findAnnotation",
                            "method_signature": "static AspectJAnnotation findAnnotation(Method method, Class<? extends Annotation> annotationType)",
                            "target_class": "AspectJAnnotationUtils",
                            "rationale": "The method 'findAnnotation' checks for a specific annotation type on a method. This operation does not have a clear reliance on 'AbstractAspectJAdvisorFactory' intersal state and could be utilized by other components or classes to find AspectJ annotations."
                        }
                    ],
                    "llm_response_time": 23039
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "compiledByAjc",
                            "method_signature": "static boolean compiledByAjc(Class<?> clazz)",
                            "target_class": "AspectJUtils",
                            "rationale": "compiledByAjc() is a utility operation, it may be more cleanly encapsulated in a utility/helper class like AspectJUtils."
                        },
                        {
                            "method_name": "findAspectJAnnotationOnMethod",
                            "method_signature": "protected static AspectJAnnotation findAspectJAnnotationOnMethod(Method method)",
                            "target_class": "AspectJAnnotationUtils",
                            "rationale": "Operations on annotations like findAspectJAnnotationOnMethod() are better off in a utility/helper class."
                        },
                        {
                            "method_name": "findAnnotation",
                            "method_signature": "@Nullable private static AspectJAnnotation findAnnotation(Method method, Class<? extends Annotation> annotationType)",
                            "target_class": "AspectJAnnotationUtils",
                            "rationale": "Operations on annotations like findAnnotation() are better off in a utility/helper class."
                        }
                    ],
                    "llm_response_time": 16450
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "compiledByAjc",
                            "method_signature": "static boolean compiledByAjc(Class<?> clazz)",
                            "target_class": "AjcCompiler",
                            "rationale": "compiledByAjc() method is for checking if a class was compiled by Ajc, it would be more suitable to be placed inside a class that specifically deals with operations related to Ajc compiler."
                        },
                        {
                            "method_name": "getParameterNames",
                            "method_signature": "public String[] getParameterNames(Method method)",
                            "target_class": "MethodParameterResolver",
                            "rationale": "getParameterNames() method deals with processing method level details, hence it should be moved inside a class like MethodParameterResolver which specifically deals with processing method informations."
                        },
                        {
                            "method_name": "getParameterNames",
                            "method_signature": "public String[] getParameterNames(Constructor<?> ctor)",
                            "target_class": "ConstructorParameterResolver",
                            "rationale": "getParameterNames() method deals with processing constructor level details, hence it should be moved inside a class like ConstructorParameterResolver which specifically deals with processing constructor informations."
                        }
                    ],
                    "llm_response_time": 14029
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "compiledByAjc",
                            "method_signature": "static boolean compiledByAjc(Class<?> clazz)",
                            "target_class": "AjcHelper",
                            "rationale": "The method 'compiledByAjc' checks if a class has been compiled by ajc. This is a general utility that could be used by outer components or classes and does not strictly belong to 'AbstractAspectJAdvisorFactory'."
                        },
                        {
                            "method_name": "findAspectJAnnotationOnMethod",
                            "method_signature": "static AspectJAnnotation findAspectJAnnotationOnMethod(Method method)",
                            "target_class": "AspectJAnnotationUtils",
                            "rationale": "The method 'findAspectJAnnotationOnMethod' checks for AspectJ annotations on a method. This utility function may be useful in other classes for detecting annotations and should thus not tightly belong to 'AbstractAspectJAdvisorFactory'."
                        },
                        {
                            "method_name": "findAnnotation",
                            "method_signature": "static AspectJAnnotation findAnnotation(Method method, Class<? extends Annotation> annotationType)",
                            "target_class": "AspectJAnnotationUtils",
                            "rationale": "The method 'findAnnotation' checks for a specific annotation type on a method. This operation does not have a clear reliance on 'AbstractAspectJAdvisorFactory' intersal state and could be utilized by other components or classes to find AspectJ annotations."
                        },
                        {
                            "method_name": "getParameterNames",
                            "method_signature": "public String[] getParameterNames(Method method)",
                            "target_class": "MethodParameterResolver",
                            "rationale": "getParameterNames() method deals with processing method level details, hence it should be moved inside a class like MethodParameterResolver which specifically deals with processing method informations."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "explanation": "While all the listed methods seem to be implemented in a logically correct and efficient manner where they are, if I had to rank the move-method suggestions, here would be my prioritized list:\n\n1. \"compiledByAjc\"\n2. \"findAspectJAnnotationOnMethod\"\n3. \"findAnnotation\"\n4. \"getParameterNames\"\n\nBut it's also important to note that these methods are likely well-placed in this class. \"compiledByAjc\", \"findAspectJAnnotationOnMethod\" and \"findAnnotation\", all contribute directly towards the implementation of this factory class and extract AspectJ specific details. The method \"getParameterNames\" also provides utility specific to this factory invoking an AspectJAnnotation to get argument names.\n\nSo, generally I would recommend keeping their implementation inside this class. However, if you plan to make these utility methods more generic and reusable, it would make sense to move them to a utility class. But, always remember to analyse the impacts on other parts of the codes and the principles of cohesion and coupling while performing such refactorings.\n   \nYou can ignore this part if you explicitly need them to be moved for some reason.",
                "llm_response_time": 15312
            },
            "targetClassMap": {}
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "0ac7e41bebd9624dcabedc8ed122fe0d530af565",
        "url": "https://github.com/spring-projects/spring-framework/commit/0ac7e41bebd9624dcabedc8ed122fe0d530af565",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private compare(expectedJson String, actualJson String, compareFunction ThrowingBiFunction<String,String,JSONCompareResult>) : JsonComparison from class org.springframework.test.json.JsonAssert to public compare(expectedJson String, actualJson String) : JsonComparison from class org.springframework.test.json.JsonAssert.JsonAssertJsonComparator",
            "leftSideLocations": [
                {
                    "filePath": "spring-test/src/main/java/org/springframework/test/json/JsonAssert.java",
                    "startLine": 72,
                    "endLine": 87,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private compare(expectedJson String, actualJson String, compareFunction ThrowingBiFunction<String,String,JSONCompareResult>) : JsonComparison"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-test/src/main/java/org/springframework/test/json/JsonAssert.java",
                    "startLine": 81,
                    "endLine": 100,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "public compare(expectedJson String, actualJson String) : JsonComparison"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "f5ad73d4-d07f-4bfc-979d-de821f6f591b",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 67,
                "lineStart": 27,
                "lineEnd": 93,
                "bodyLineStart": 27,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-test/src/main/java/org/springframework/test/json/JsonAssert.java",
                "sourceCode": "/**\n * Useful methods that can be used with {@code org.skyscreamer.jsonassert}.\n *\n * @author Phillip Webb\n * @since 6.2\n */\npublic abstract class JsonAssert {\n\n\t/**\n\t * Create a {@link JsonComparator} from the given {@link JsonCompareMode}.\n\t * @param compareMode the mode to use\n\t * @return a new {@link JsonComparator} instance\n\t * @see JSONCompareMode#STRICT\n\t * @see JSONCompareMode#LENIENT\n\t */\n\tpublic static JsonComparator comparator(JsonCompareMode compareMode) {\n\t\treturn comparator(toJSONCompareMode(compareMode));\n\t}\n\n\t/**\n\t * Create a new {@link JsonComparator} from the given JSONAssert\n\t * {@link JSONComparator}.\n\t * @param comparator the JSON Assert {@link JSONComparator}\n\t * @return a new {@link JsonComparator} instance\n\t */\n\tpublic static JsonComparator comparator(JSONComparator comparator) {\n\t\treturn comparator((expectedJson, actualJson) -> JSONCompare\n\t\t\t\t.compareJSON(expectedJson, actualJson, comparator));\n\t}\n\n\t/**\n\t * Create a new {@link JsonComparator} from the given JSONAssert\n\t * {@link JSONCompareMode}.\n\t * @param mode the JSON Assert {@link JSONCompareMode}\n\t * @return a new {@link JsonComparator} instance\n\t */\n\tpublic static JsonComparator comparator(JSONCompareMode mode) {\n\t\treturn comparator((expectedJson, actualJson) -> JSONCompare\n\t\t\t\t.compareJSON(expectedJson, actualJson, mode));\n\t}\n\n\tprivate static JsonComparator comparator(ThrowingBiFunction<String, String, JSONCompareResult> compareFunction) {\n\t\treturn (expectedJson, actualJson) -> compare(expectedJson, actualJson, compareFunction);\n\t}\n\n\tprivate static JsonComparison compare(@Nullable String expectedJson, @Nullable String actualJson,\n\t\t\tThrowingBiFunction<String, String, JSONCompareResult> compareFunction) {\n\n\t\tif (actualJson == null) {\n\t\t\treturn (expectedJson != null)\n\t\t\t\t\t? JsonComparison.mismatch(\"Expected null JSON\")\n\t\t\t\t\t: JsonComparison.match();\n\t\t}\n\t\tif (expectedJson == null) {\n\t\t\treturn JsonComparison.mismatch(\"Expected non-null JSON\");\n\t\t}\n\t\tJSONCompareResult result = compareFunction.throwing(IllegalStateException::new).apply(expectedJson, actualJson);\n\t\treturn (!result.passed())\n\t\t\t\t? JsonComparison.mismatch(result.getMessage())\n\t\t\t\t: JsonComparison.match();\n\t}\n\n\tprivate static JSONCompareMode toJSONCompareMode(JsonCompareMode compareMode) {\n\t\treturn (compareMode != JsonCompareMode.LENIENT ? JSONCompareMode.STRICT : JSONCompareMode.LENIENT);\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "failed to unparse",
                            "method_signature": "failed to unparse",
                            "target_class": "failed to unparse",
                            "rationale": "No suggestions for moving methods for this class. All methods in the JsonAssert class are cohesive and relate to JSON comparison. So, there's no need for a move method refactoring."
                        }
                    ],
                    "llm_response_time": 3591
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "failed to unparse",
                            "method_signature": "failed to unparse",
                            "target_class": "failed to unparse",
                            "rationale": "[]\nThere are no methods that need to be moved to different classes. The methods in this class, JsonAssert, are all related to the functionality of this class and use its properties properly. Therefore, no actions are needed in terms of the Move Method refactoring operation."
                        }
                    ],
                    "llm_response_time": 3746
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "failed to unparse",
                            "method_signature": "failed to unparse",
                            "target_class": "failed to unparse",
                            "rationale": "The class \"JsonAssert\" doesn't seem to have any methods that don't belong in it, hence there's no need of moving any method to a different class. Each method in this class is performing actions relevant to its responsibility for handling JSON comparison. So there are no methods that need to be moved to a different class for the purpose of refactoring."
                        }
                    ],
                    "llm_response_time": 6516
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [],
                    "llm_response_time": 0
                }
            ],
            "targetClassMap": {}
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "url": "https://github.com/spring-projects/spring-framework/commit/ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private assertPubliclyAccessible(method Method) : void from class org.springframework.util.ClassUtilsTests.GetPubliclyAccessibleMethodTests to private assertPubliclyAccessible(method Method) : void from class org.springframework.util.ClassUtilsTests",
            "leftSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 711,
                    "endLine": 714,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private assertPubliclyAccessible(method Method) : void"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 870,
                    "endLine": 873,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "private assertPubliclyAccessible(method Method) : void"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "5f09b383-079e-4a7e-af48-b51f954de7b8",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 861,
                "lineStart": 57,
                "lineEnd": 917,
                "bodyLineStart": 57,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                "sourceCode": "/**\n * Tests for {@link ClassUtils}.\n *\n * @author Colin Sampaleanu\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rick Evans\n * @author Sam Brannen\n */\nclass ClassUtilsTests {\n\n\tprivate final ClassLoader classLoader = getClass().getClassLoader();\n\n\n\t@Test\n\tvoid isPresent() {\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.String\", classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.MySpecialString\", classLoader)).isFalse();\n\t}\n\n\t@Test\n\tvoid forName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"java.lang.String\", classLoader)).isEqualTo(String.class);\n\t\tassertThat(ClassUtils.forName(\"java.lang.String[]\", classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[].class.getName(), classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[][].class.getName(), classLoader)).isEqualTo(String[][].class);\n\t\tassertThat(ClassUtils.forName(String[][][].class.getName(), classLoader)).isEqualTo(String[][][].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject\", classLoader)).isEqualTo(TestObject.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[]\", classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(TestObject[].class.getName(), classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[][]\", classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(TestObject[][].class.getName(), classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(\"[[[S\", classLoader)).isEqualTo(short[][][].class);\n\t}\n\n\t@Test\n\tvoid forNameWithNestedType() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests$NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests.NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\n\t\t// Precondition: package name must have length == 1.\n\t\tassertThat(ClassHavingNestedClass.class.getPackageName().length()).isEqualTo(1);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass$NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass.NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveClasses() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean\", classLoader)).isEqualTo(boolean.class);\n\t\tassertThat(ClassUtils.forName(\"byte\", classLoader)).isEqualTo(byte.class);\n\t\tassertThat(ClassUtils.forName(\"char\", classLoader)).isEqualTo(char.class);\n\t\tassertThat(ClassUtils.forName(\"short\", classLoader)).isEqualTo(short.class);\n\t\tassertThat(ClassUtils.forName(\"int\", classLoader)).isEqualTo(int.class);\n\t\tassertThat(ClassUtils.forName(\"long\", classLoader)).isEqualTo(long.class);\n\t\tassertThat(ClassUtils.forName(\"float\", classLoader)).isEqualTo(float.class);\n\t\tassertThat(ClassUtils.forName(\"double\", classLoader)).isEqualTo(double.class);\n\t\tassertThat(ClassUtils.forName(\"void\", classLoader)).isEqualTo(void.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArrays() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean[]\", classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(\"byte[]\", classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(\"char[]\", classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(\"short[]\", classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(\"int[]\", classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(\"long[]\", classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(\"float[]\", classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(\"double[]\", classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArraysInternalName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(boolean[].class.getName(), classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(byte[].class.getName(), classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(char[].class.getName(), classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(short[].class.getName(), classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(int[].class.getName(), classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(long[].class.getName(), classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(float[].class.getName(), classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(double[].class.getName(), classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid isCacheSafe() {\n\t\tClassLoader childLoader1 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader2 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader3 = new ClassLoader(classLoader) {\n\t\t\t@Override\n\t\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\t\t\treturn childLoader1.loadClass(name);\n\t\t\t}\n\t\t};\n\t\tClass<?> composite = ClassUtils.createCompositeInterface(\n\t\t\t\tnew Class<?>[] {Serializable.class, Externalizable.class}, childLoader1);\n\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, null)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, classLoader)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader2)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader3)).isTrue();\n\t}\n\n\t@ParameterizedTest(name = \"''{0}'' -> {1}\")\n\t@CsvSource(textBlock = \"\"\"\n\t\tboolean, boolean\n\t\tbyte, byte\n\t\tchar, char\n\t\tshort, short\n\t\tint, int\n\t\tlong, long\n\t\tfloat, float\n\t\tdouble, double\n\t\t[Z, boolean[]\n\t\t[B, byte[]\n\t\t[C, char[]\n\t\t[S, short[]\n\t\t[I, int[]\n\t\t[J, long[]\n\t\t[F, float[]\n\t\t[D, double[]\n\t\t\"\"\")\n\tvoid resolvePrimitiveClassName(String input, Class<?> output) {\n\t\tassertThat(ClassUtils.resolvePrimitiveClassName(input)).isEqualTo(output);\n\t}\n\n\t@Test\n\tvoid getShortName() {\n\t\tString className = ClassUtils.getShortName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getShortNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[][][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForNestedClass() {\n\t\tString className = ClassUtils.getShortName(NestedClass.class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests.NestedClass\");\n\t}\n\n\t@Test\n\tvoid getShortNameAsProperty() {\n\t\tString shortName = ClassUtils.getShortNameAsProperty(this.getClass());\n\t\tassertThat(shortName).as(\"Class name did not match\").isEqualTo(\"classUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getClassFileName() {\n\t\tassertThat(ClassUtils.getClassFileName(String.class)).isEqualTo(\"String.class\");\n\t\tassertThat(ClassUtils.getClassFileName(getClass())).isEqualTo(\"ClassUtilsTests.class\");\n\t}\n\n\t@Test\n\tvoid getPackageName() {\n\t\tassertThat(ClassUtils.getPackageName(String.class)).isEqualTo(\"java.lang\");\n\t\tassertThat(ClassUtils.getPackageName(getClass())).isEqualTo(getClass().getPackage().getName());\n\t}\n\n\t@Test\n\tvoid getQualifiedName() {\n\t\tString className = ClassUtils.getQualifiedName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"org.springframework.util.ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[][]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][]\");\n\t}\n\n\t@Test\n\tvoid hasMethod() {\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"size\")).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\", Object.class)).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\")).isFalse();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"someOtherMethod\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getMethodIfAvailable() {\n\t\tMethod method = ClassUtils.getMethodIfAvailable(Collection.class, \"size\");\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"size\");\n\n\t\tmethod = ClassUtils.getMethodIfAvailable(Collection.class, \"remove\", Object.class);\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"remove\");\n\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"remove\")).isNull();\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"someOtherMethod\")).isNull();\n\t}\n\n\t@Test\n\tvoid getMethodCountForName() {\n\t\tassertThat(ClassUtils.getMethodCountForName(OverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for OverloadedMethodsClass.\").isEqualTo(2);\n\t\tassertThat(ClassUtils.getMethodCountForName(SubOverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for SubOverloadedMethodsClass.\").isEqualTo(4);\n\t}\n\n\t@Test\n\tvoid countOverloadedMethods() {\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"foobar\")).isFalse();\n\t\t// no args\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"hashCode\")).isTrue();\n\t\t// matches although it takes an arg\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"setAge\")).isTrue();\n\t}\n\n\t@Test\n\tvoid isAssignable() {\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Object.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(int.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, Object.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, Number.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, double.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(double.class, Integer.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid classPackageAsResourcePath() {\n\t\tString result = ClassUtils.classPackageAsResourcePath(Proxy.class);\n\t\tassertThat(result).isEqualTo(\"java/lang/reflect\");\n\t}\n\n\t@Test\n\tvoid addResourcePathToPackagePath() {\n\t\tString result = \"java/lang/reflect/xyzabc.xml\";\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"xyzabc.xml\")).isEqualTo(result);\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"/xyzabc.xml\")).isEqualTo(result);\n\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"a/b/c/d.xml\")).isEqualTo(\"java/lang/reflect/a/b/c/d.xml\");\n\t}\n\n\t@Test\n\tvoid getAllInterfaces() {\n\t\tDerivedTestObject testBean = new DerivedTestObject();\n\t\tList<Class<?>> ifcs = Arrays.asList(ClassUtils.getAllInterfaces(testBean));\n\t\tassertThat(ifcs).as(\"Correct number of interfaces\").hasSize(4);\n\t\tassertThat(ifcs.contains(Serializable.class)).as(\"Contains Serializable\").isTrue();\n\t\tassertThat(ifcs.contains(ITestObject.class)).as(\"Contains ITestBean\").isTrue();\n\t\tassertThat(ifcs.contains(ITestInterface.class)).as(\"Contains IOther\").isTrue();\n\t}\n\n\t@Test\n\tvoid classNamesToString() {\n\t\tList<Class<?>> ifcs = new ArrayList<>();\n\t\tifcs.add(Serializable.class);\n\t\tifcs.add(Runnable.class);\n\t\tassertThat(ifcs.toString()).isEqualTo(\"[interface java.io.Serializable, interface java.lang.Runnable]\");\n\t\tassertThat(ClassUtils.classNamesToString(ifcs)).isEqualTo(\"[java.io.Serializable, java.lang.Runnable]\");\n\n\t\tList<Class<?>> classes = new ArrayList<>();\n\t\tclasses.add(ArrayList.class);\n\t\tclasses.add(Integer.class);\n\t\tassertThat(classes.toString()).isEqualTo(\"[class java.util.ArrayList, class java.lang.Integer]\");\n\t\tassertThat(ClassUtils.classNamesToString(classes)).isEqualTo(\"[java.util.ArrayList, java.lang.Integer]\");\n\n\t\tassertThat(Collections.singletonList(List.class).toString()).isEqualTo(\"[interface java.util.List]\");\n\t\tassertThat(ClassUtils.classNamesToString(List.class)).isEqualTo(\"[java.util.List]\");\n\n\t\tassertThat(Collections.EMPTY_LIST.toString()).isEqualTo(\"[]\");\n\t\tassertThat(ClassUtils.classNamesToString(Collections.emptyList())).isEqualTo(\"[]\");\n\t}\n\n\t@Test\n\tvoid determineCommonAncestor() {\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Number.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, null)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, Integer.class)).isEqualTo(Integer.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Integer.class)).isEqualTo(Integer.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Float.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Float.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, Integer.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Collection.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, List.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, null)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, List.class)).isEqualTo(List.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Set.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Set.class, List.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Runnable.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Runnable.class, List.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, ArrayList.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(ArrayList.class, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, List.class)).isNull();\n\t}\n\n\t@Test\n\tvoid getMostSpecificMethod() throws NoSuchMethodException {\n\t\tMethod defaultPrintMethod = ClassUtils.getMethod(MethodsInterface.class, \"defaultPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\n\t\tMethod printMethod = ClassUtils.getMethod(MethodsInterface.class, \"print\", String.class);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isNotEqualTo(printMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\n\t\tMethod protectedPrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(protectedPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(SubMethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\"));\n\n\t\tMethod packageAccessiblePrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"packageAccessiblePrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(packageAccessiblePrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(SubMethodsInterfaceImplementation.class, \"packageAccessiblePrint\"));\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@PrimitiveTypes\n\tvoid isPrimitiveOrWrapperWithPrimitive(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveOrWrapperWithWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@Test\n\tvoid isLambda() {\n\t\tassertIsLambda(ClassUtilsTests.staticLambdaExpression);\n\t\tassertIsLambda(ClassUtilsTests::staticStringFactory);\n\n\t\tassertIsLambda(this.instanceLambdaExpression);\n\t\tassertIsLambda(this::instanceStringFactory);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"Convert2Lambda\")\n\tvoid isNotLambda() {\n\t\tassertIsNotLambda(new EnigmaSupplier());\n\n\t\tassertIsNotLambda(new Supplier<>() {\n\t\t\t@Override\n\t\t\tpublic String get() {\n\t\t\t\treturn \"anonymous inner class\";\n\t\t\t}\n\t\t});\n\n\t\tassertIsNotLambda(new Fake$$LambdaSupplier());\n\t}\n\n\n\t@Nested\n\tclass GetStaticMethodTests {\n\n\t\t@BeforeEach\n\t\tvoid clearStatics() {\n\t\t\tNestedClass.noArgCalled = false;\n\t\t\tNestedClass.argCalled = false;\n\t\t\tNestedClass.overloadedCalled = false;\n\t\t}\n\n\t\t@Test\n\t\tvoid noArgsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\");\n\t\t\tmethod.invoke(null, (Object[]) null);\n\t\t\tassertThat(NestedClass.noArgCalled).as(\"no argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid argsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"argStaticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.argCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid overloadedStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.overloadedCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t}\n\n\n\t@Nested  // gh-33216\n\tclass GetPubliclyAccessibleMethodTests {\n\n\t\t@Test\n\t\tvoid nonPublicMethod(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(originalMethod);\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\t// This method is intentionally public.\n\t\tpublic void publicMethodInNonPublicType(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = String.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = ArrayList.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"size\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in List.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaLangObjectDeclaredInNonPublicType() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Object.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"toString\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaTimeZoneIdDeclaredInNonPublicSubclass() throws Exception {\n\t\t\t// Returns a package-private java.time.ZoneRegion.\n\t\t\tZoneId zoneId = ZoneId.of(\"CET\");\n\t\t\tClass<?> targetClass = zoneId.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getDeclaredMethod(\"getId\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(ZoneId.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getId\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodDeclaredInNonPublicTypeWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\n\t\t\tHashMap<String, String> hashMap = new HashMap<>();\n\t\t\t// Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\n\t\t\t// which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\n\t\t\t// implements HashIterator.\n\t\t\tIterator<String> iterator = hashMap.keySet().iterator();\n\t\t\tClass<?> targetClass = iterator.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"hasNext\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, targetClass);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Iterator.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"hasNext\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getText\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in PrivateInterface.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getMessage\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getNumber\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getNumber\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"contains\", Object.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Collection.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"contains\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(Object.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"greet\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(String.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"process\", int.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"process\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(int.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\tprivate static void assertPubliclyAccessible(Method method) {\n\t\t\tassertPublic(method);\n\t\t\tassertPublic(method.getDeclaringClass());\n\t\t}\n\n\t\tprivate static void assertNotPubliclyAccessible(Method method) {\n\t\t\tassertThat(!isPublic(method) || !isPublic(method.getDeclaringClass()))\n\t\t\t\t\t.as(\"%s must not be publicly accessible\", method)\n\t\t\t\t\t.isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Member member) {\n\t\t\tassertThat(isPublic(member)).as(\"%s must be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Class<?> clazz) {\n\t\t\tassertThat(isPublic(clazz)).as(\"%s must be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Member member) {\n\t\t\tassertThat(!isPublic(member)).as(\"%s must be not be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Class<?> clazz) {\n\t\t\tassertThat(!isPublic(clazz)).as(\"%s must be not be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static boolean isPublic(Class<?> clazz) {\n\t\t\treturn Modifier.isPublic(clazz.getModifiers());\n\t\t}\n\n\t\tprivate static boolean isPublic(Member member) {\n\t\t\treturn Modifier.isPublic(member.getModifiers());\n\t\t}\n\n\t\tprivate interface PrivateInterface {\n\n\t\t\tString getMessage();\n\n\t\t\tString greet(String name);\n\t\t}\n\n\t\tprivate static class PrivateSubclass extends PublicSuperclass implements PublicInterface, PrivateInterface {\n\n\t\t\t@Override\n\t\t\tpublic int getNumber() {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getMessage() {\n\t\t\t\treturn \"hello\";\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String greet(String name) {\n\t\t\t\treturn \"Hello, \" + name;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int process(int num) {\n\t\t\t\treturn num * 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getText() {\n\t\t\t\treturn \"enigma\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { Boolean.class, Character.class, Byte.class, Short.class,\n\t\tInteger.class, Long.class, Float.class, Double.class, Void.class })\n\t@interface WrapperTypes {\n\t}\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { boolean.class, char.class, byte.class, short.class,\n\t\tint.class, long.class, float.class, double.class, void.class })\n\t@interface PrimitiveTypes {\n\t}\n\n\tpublic static class NestedClass {\n\n\t\tstatic boolean noArgCalled;\n\t\tstatic boolean argCalled;\n\t\tstatic boolean overloadedCalled;\n\n\t\tpublic static void staticMethod() {\n\t\t\tnoArgCalled = true;\n\t\t}\n\n\t\tpublic static void staticMethod(String anArg) {\n\t\t\toverloadedCalled = true;\n\t\t}\n\n\t\tpublic static void argStaticMethod(String anArg) {\n\t\t\targCalled = true;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class OverloadedMethodsClass {\n\n\t\tpublic void print(String messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tpublic void print(String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class SubOverloadedMethodsClass extends OverloadedMethodsClass {\n\n\t\tpublic void print(String header, String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tvoid print(String header, String[] messages, String footer) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\tprivate static void assertIsLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isTrue();\n\t}\n\n\tprivate static void assertIsNotLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isFalse();\n\t}\n\n\tprivate static final Supplier<String> staticLambdaExpression = () -> \"static lambda expression\";\n\n\tprivate final Supplier<String> instanceLambdaExpression = () -> \"instance lambda expressions\";\n\n\tprivate static String staticStringFactory() {\n\t\treturn \"static string factory\";\n\t}\n\n\tprivate String instanceStringFactory() {\n\t\treturn \"instance string factory\";\n\t}\n\n\tprivate static class EnigmaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"enigma\";\n\t\t}\n\t}\n\n\tprivate static class Fake$$LambdaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"fake lambda\";\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate interface MethodsInterface {\n\n\t\tdefault void defaultPrint() {\n\n\t\t}\n\n\t\tvoid print(String messages);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class MethodsInterfaceImplementation implements MethodsInterface {\n\n\t\t@Override\n\t\tpublic void print(String message) {\n\n\t\t}\n\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\tvoid packageAccessiblePrint() {\n\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class SubMethodsInterfaceImplementation extends MethodsInterfaceImplementation {\n\n\t\t@Override\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\t@Override\n\t\tpublic void packageAccessiblePrint() {\n\n\t\t}\n\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "iterationData": [],
            "targetClassMap": {}
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "url": "https://github.com/spring-projects/spring-framework/commit/ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private assertNotPubliclyAccessible(method Method) : void from class org.springframework.util.ClassUtilsTests.GetPubliclyAccessibleMethodTests to private assertNotPubliclyAccessible(method Method) : void from class org.springframework.util.ClassUtilsTests",
            "leftSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 716,
                    "endLine": 720,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private assertNotPubliclyAccessible(method Method) : void"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 875,
                    "endLine": 879,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "private assertNotPubliclyAccessible(method Method) : void"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "5f09b383-079e-4a7e-af48-b51f954de7b8",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 861,
                "lineStart": 57,
                "lineEnd": 917,
                "bodyLineStart": 57,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                "sourceCode": "/**\n * Tests for {@link ClassUtils}.\n *\n * @author Colin Sampaleanu\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rick Evans\n * @author Sam Brannen\n */\nclass ClassUtilsTests {\n\n\tprivate final ClassLoader classLoader = getClass().getClassLoader();\n\n\n\t@Test\n\tvoid isPresent() {\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.String\", classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.MySpecialString\", classLoader)).isFalse();\n\t}\n\n\t@Test\n\tvoid forName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"java.lang.String\", classLoader)).isEqualTo(String.class);\n\t\tassertThat(ClassUtils.forName(\"java.lang.String[]\", classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[].class.getName(), classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[][].class.getName(), classLoader)).isEqualTo(String[][].class);\n\t\tassertThat(ClassUtils.forName(String[][][].class.getName(), classLoader)).isEqualTo(String[][][].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject\", classLoader)).isEqualTo(TestObject.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[]\", classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(TestObject[].class.getName(), classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[][]\", classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(TestObject[][].class.getName(), classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(\"[[[S\", classLoader)).isEqualTo(short[][][].class);\n\t}\n\n\t@Test\n\tvoid forNameWithNestedType() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests$NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests.NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\n\t\t// Precondition: package name must have length == 1.\n\t\tassertThat(ClassHavingNestedClass.class.getPackageName().length()).isEqualTo(1);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass$NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass.NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveClasses() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean\", classLoader)).isEqualTo(boolean.class);\n\t\tassertThat(ClassUtils.forName(\"byte\", classLoader)).isEqualTo(byte.class);\n\t\tassertThat(ClassUtils.forName(\"char\", classLoader)).isEqualTo(char.class);\n\t\tassertThat(ClassUtils.forName(\"short\", classLoader)).isEqualTo(short.class);\n\t\tassertThat(ClassUtils.forName(\"int\", classLoader)).isEqualTo(int.class);\n\t\tassertThat(ClassUtils.forName(\"long\", classLoader)).isEqualTo(long.class);\n\t\tassertThat(ClassUtils.forName(\"float\", classLoader)).isEqualTo(float.class);\n\t\tassertThat(ClassUtils.forName(\"double\", classLoader)).isEqualTo(double.class);\n\t\tassertThat(ClassUtils.forName(\"void\", classLoader)).isEqualTo(void.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArrays() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean[]\", classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(\"byte[]\", classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(\"char[]\", classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(\"short[]\", classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(\"int[]\", classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(\"long[]\", classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(\"float[]\", classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(\"double[]\", classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArraysInternalName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(boolean[].class.getName(), classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(byte[].class.getName(), classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(char[].class.getName(), classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(short[].class.getName(), classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(int[].class.getName(), classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(long[].class.getName(), classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(float[].class.getName(), classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(double[].class.getName(), classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid isCacheSafe() {\n\t\tClassLoader childLoader1 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader2 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader3 = new ClassLoader(classLoader) {\n\t\t\t@Override\n\t\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\t\t\treturn childLoader1.loadClass(name);\n\t\t\t}\n\t\t};\n\t\tClass<?> composite = ClassUtils.createCompositeInterface(\n\t\t\t\tnew Class<?>[] {Serializable.class, Externalizable.class}, childLoader1);\n\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, null)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, classLoader)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader2)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader3)).isTrue();\n\t}\n\n\t@ParameterizedTest(name = \"''{0}'' -> {1}\")\n\t@CsvSource(textBlock = \"\"\"\n\t\tboolean, boolean\n\t\tbyte, byte\n\t\tchar, char\n\t\tshort, short\n\t\tint, int\n\t\tlong, long\n\t\tfloat, float\n\t\tdouble, double\n\t\t[Z, boolean[]\n\t\t[B, byte[]\n\t\t[C, char[]\n\t\t[S, short[]\n\t\t[I, int[]\n\t\t[J, long[]\n\t\t[F, float[]\n\t\t[D, double[]\n\t\t\"\"\")\n\tvoid resolvePrimitiveClassName(String input, Class<?> output) {\n\t\tassertThat(ClassUtils.resolvePrimitiveClassName(input)).isEqualTo(output);\n\t}\n\n\t@Test\n\tvoid getShortName() {\n\t\tString className = ClassUtils.getShortName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getShortNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[][][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForNestedClass() {\n\t\tString className = ClassUtils.getShortName(NestedClass.class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests.NestedClass\");\n\t}\n\n\t@Test\n\tvoid getShortNameAsProperty() {\n\t\tString shortName = ClassUtils.getShortNameAsProperty(this.getClass());\n\t\tassertThat(shortName).as(\"Class name did not match\").isEqualTo(\"classUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getClassFileName() {\n\t\tassertThat(ClassUtils.getClassFileName(String.class)).isEqualTo(\"String.class\");\n\t\tassertThat(ClassUtils.getClassFileName(getClass())).isEqualTo(\"ClassUtilsTests.class\");\n\t}\n\n\t@Test\n\tvoid getPackageName() {\n\t\tassertThat(ClassUtils.getPackageName(String.class)).isEqualTo(\"java.lang\");\n\t\tassertThat(ClassUtils.getPackageName(getClass())).isEqualTo(getClass().getPackage().getName());\n\t}\n\n\t@Test\n\tvoid getQualifiedName() {\n\t\tString className = ClassUtils.getQualifiedName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"org.springframework.util.ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[][]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][]\");\n\t}\n\n\t@Test\n\tvoid hasMethod() {\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"size\")).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\", Object.class)).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\")).isFalse();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"someOtherMethod\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getMethodIfAvailable() {\n\t\tMethod method = ClassUtils.getMethodIfAvailable(Collection.class, \"size\");\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"size\");\n\n\t\tmethod = ClassUtils.getMethodIfAvailable(Collection.class, \"remove\", Object.class);\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"remove\");\n\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"remove\")).isNull();\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"someOtherMethod\")).isNull();\n\t}\n\n\t@Test\n\tvoid getMethodCountForName() {\n\t\tassertThat(ClassUtils.getMethodCountForName(OverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for OverloadedMethodsClass.\").isEqualTo(2);\n\t\tassertThat(ClassUtils.getMethodCountForName(SubOverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for SubOverloadedMethodsClass.\").isEqualTo(4);\n\t}\n\n\t@Test\n\tvoid countOverloadedMethods() {\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"foobar\")).isFalse();\n\t\t// no args\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"hashCode\")).isTrue();\n\t\t// matches although it takes an arg\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"setAge\")).isTrue();\n\t}\n\n\t@Test\n\tvoid isAssignable() {\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Object.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(int.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, Object.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, Number.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, double.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(double.class, Integer.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid classPackageAsResourcePath() {\n\t\tString result = ClassUtils.classPackageAsResourcePath(Proxy.class);\n\t\tassertThat(result).isEqualTo(\"java/lang/reflect\");\n\t}\n\n\t@Test\n\tvoid addResourcePathToPackagePath() {\n\t\tString result = \"java/lang/reflect/xyzabc.xml\";\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"xyzabc.xml\")).isEqualTo(result);\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"/xyzabc.xml\")).isEqualTo(result);\n\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"a/b/c/d.xml\")).isEqualTo(\"java/lang/reflect/a/b/c/d.xml\");\n\t}\n\n\t@Test\n\tvoid getAllInterfaces() {\n\t\tDerivedTestObject testBean = new DerivedTestObject();\n\t\tList<Class<?>> ifcs = Arrays.asList(ClassUtils.getAllInterfaces(testBean));\n\t\tassertThat(ifcs).as(\"Correct number of interfaces\").hasSize(4);\n\t\tassertThat(ifcs.contains(Serializable.class)).as(\"Contains Serializable\").isTrue();\n\t\tassertThat(ifcs.contains(ITestObject.class)).as(\"Contains ITestBean\").isTrue();\n\t\tassertThat(ifcs.contains(ITestInterface.class)).as(\"Contains IOther\").isTrue();\n\t}\n\n\t@Test\n\tvoid classNamesToString() {\n\t\tList<Class<?>> ifcs = new ArrayList<>();\n\t\tifcs.add(Serializable.class);\n\t\tifcs.add(Runnable.class);\n\t\tassertThat(ifcs.toString()).isEqualTo(\"[interface java.io.Serializable, interface java.lang.Runnable]\");\n\t\tassertThat(ClassUtils.classNamesToString(ifcs)).isEqualTo(\"[java.io.Serializable, java.lang.Runnable]\");\n\n\t\tList<Class<?>> classes = new ArrayList<>();\n\t\tclasses.add(ArrayList.class);\n\t\tclasses.add(Integer.class);\n\t\tassertThat(classes.toString()).isEqualTo(\"[class java.util.ArrayList, class java.lang.Integer]\");\n\t\tassertThat(ClassUtils.classNamesToString(classes)).isEqualTo(\"[java.util.ArrayList, java.lang.Integer]\");\n\n\t\tassertThat(Collections.singletonList(List.class).toString()).isEqualTo(\"[interface java.util.List]\");\n\t\tassertThat(ClassUtils.classNamesToString(List.class)).isEqualTo(\"[java.util.List]\");\n\n\t\tassertThat(Collections.EMPTY_LIST.toString()).isEqualTo(\"[]\");\n\t\tassertThat(ClassUtils.classNamesToString(Collections.emptyList())).isEqualTo(\"[]\");\n\t}\n\n\t@Test\n\tvoid determineCommonAncestor() {\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Number.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, null)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, Integer.class)).isEqualTo(Integer.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Integer.class)).isEqualTo(Integer.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Float.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Float.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, Integer.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Collection.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, List.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, null)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, List.class)).isEqualTo(List.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Set.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Set.class, List.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Runnable.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Runnable.class, List.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, ArrayList.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(ArrayList.class, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, List.class)).isNull();\n\t}\n\n\t@Test\n\tvoid getMostSpecificMethod() throws NoSuchMethodException {\n\t\tMethod defaultPrintMethod = ClassUtils.getMethod(MethodsInterface.class, \"defaultPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\n\t\tMethod printMethod = ClassUtils.getMethod(MethodsInterface.class, \"print\", String.class);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isNotEqualTo(printMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\n\t\tMethod protectedPrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(protectedPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(SubMethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\"));\n\n\t\tMethod packageAccessiblePrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"packageAccessiblePrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(packageAccessiblePrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(SubMethodsInterfaceImplementation.class, \"packageAccessiblePrint\"));\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@PrimitiveTypes\n\tvoid isPrimitiveOrWrapperWithPrimitive(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveOrWrapperWithWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@Test\n\tvoid isLambda() {\n\t\tassertIsLambda(ClassUtilsTests.staticLambdaExpression);\n\t\tassertIsLambda(ClassUtilsTests::staticStringFactory);\n\n\t\tassertIsLambda(this.instanceLambdaExpression);\n\t\tassertIsLambda(this::instanceStringFactory);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"Convert2Lambda\")\n\tvoid isNotLambda() {\n\t\tassertIsNotLambda(new EnigmaSupplier());\n\n\t\tassertIsNotLambda(new Supplier<>() {\n\t\t\t@Override\n\t\t\tpublic String get() {\n\t\t\t\treturn \"anonymous inner class\";\n\t\t\t}\n\t\t});\n\n\t\tassertIsNotLambda(new Fake$$LambdaSupplier());\n\t}\n\n\n\t@Nested\n\tclass GetStaticMethodTests {\n\n\t\t@BeforeEach\n\t\tvoid clearStatics() {\n\t\t\tNestedClass.noArgCalled = false;\n\t\t\tNestedClass.argCalled = false;\n\t\t\tNestedClass.overloadedCalled = false;\n\t\t}\n\n\t\t@Test\n\t\tvoid noArgsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\");\n\t\t\tmethod.invoke(null, (Object[]) null);\n\t\t\tassertThat(NestedClass.noArgCalled).as(\"no argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid argsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"argStaticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.argCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid overloadedStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.overloadedCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t}\n\n\n\t@Nested  // gh-33216\n\tclass GetPubliclyAccessibleMethodTests {\n\n\t\t@Test\n\t\tvoid nonPublicMethod(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(originalMethod);\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\t// This method is intentionally public.\n\t\tpublic void publicMethodInNonPublicType(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = String.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = ArrayList.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"size\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in List.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaLangObjectDeclaredInNonPublicType() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Object.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"toString\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaTimeZoneIdDeclaredInNonPublicSubclass() throws Exception {\n\t\t\t// Returns a package-private java.time.ZoneRegion.\n\t\t\tZoneId zoneId = ZoneId.of(\"CET\");\n\t\t\tClass<?> targetClass = zoneId.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getDeclaredMethod(\"getId\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(ZoneId.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getId\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodDeclaredInNonPublicTypeWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\n\t\t\tHashMap<String, String> hashMap = new HashMap<>();\n\t\t\t// Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\n\t\t\t// which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\n\t\t\t// implements HashIterator.\n\t\t\tIterator<String> iterator = hashMap.keySet().iterator();\n\t\t\tClass<?> targetClass = iterator.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"hasNext\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, targetClass);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Iterator.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"hasNext\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getText\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in PrivateInterface.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getMessage\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getNumber\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getNumber\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"contains\", Object.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Collection.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"contains\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(Object.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"greet\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(String.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"process\", int.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"process\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(int.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\tprivate static void assertPubliclyAccessible(Method method) {\n\t\t\tassertPublic(method);\n\t\t\tassertPublic(method.getDeclaringClass());\n\t\t}\n\n\t\tprivate static void assertNotPubliclyAccessible(Method method) {\n\t\t\tassertThat(!isPublic(method) || !isPublic(method.getDeclaringClass()))\n\t\t\t\t\t.as(\"%s must not be publicly accessible\", method)\n\t\t\t\t\t.isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Member member) {\n\t\t\tassertThat(isPublic(member)).as(\"%s must be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Class<?> clazz) {\n\t\t\tassertThat(isPublic(clazz)).as(\"%s must be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Member member) {\n\t\t\tassertThat(!isPublic(member)).as(\"%s must be not be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Class<?> clazz) {\n\t\t\tassertThat(!isPublic(clazz)).as(\"%s must be not be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static boolean isPublic(Class<?> clazz) {\n\t\t\treturn Modifier.isPublic(clazz.getModifiers());\n\t\t}\n\n\t\tprivate static boolean isPublic(Member member) {\n\t\t\treturn Modifier.isPublic(member.getModifiers());\n\t\t}\n\n\t\tprivate interface PrivateInterface {\n\n\t\t\tString getMessage();\n\n\t\t\tString greet(String name);\n\t\t}\n\n\t\tprivate static class PrivateSubclass extends PublicSuperclass implements PublicInterface, PrivateInterface {\n\n\t\t\t@Override\n\t\t\tpublic int getNumber() {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getMessage() {\n\t\t\t\treturn \"hello\";\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String greet(String name) {\n\t\t\t\treturn \"Hello, \" + name;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int process(int num) {\n\t\t\t\treturn num * 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getText() {\n\t\t\t\treturn \"enigma\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { Boolean.class, Character.class, Byte.class, Short.class,\n\t\tInteger.class, Long.class, Float.class, Double.class, Void.class })\n\t@interface WrapperTypes {\n\t}\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { boolean.class, char.class, byte.class, short.class,\n\t\tint.class, long.class, float.class, double.class, void.class })\n\t@interface PrimitiveTypes {\n\t}\n\n\tpublic static class NestedClass {\n\n\t\tstatic boolean noArgCalled;\n\t\tstatic boolean argCalled;\n\t\tstatic boolean overloadedCalled;\n\n\t\tpublic static void staticMethod() {\n\t\t\tnoArgCalled = true;\n\t\t}\n\n\t\tpublic static void staticMethod(String anArg) {\n\t\t\toverloadedCalled = true;\n\t\t}\n\n\t\tpublic static void argStaticMethod(String anArg) {\n\t\t\targCalled = true;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class OverloadedMethodsClass {\n\n\t\tpublic void print(String messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tpublic void print(String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class SubOverloadedMethodsClass extends OverloadedMethodsClass {\n\n\t\tpublic void print(String header, String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tvoid print(String header, String[] messages, String footer) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\tprivate static void assertIsLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isTrue();\n\t}\n\n\tprivate static void assertIsNotLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isFalse();\n\t}\n\n\tprivate static final Supplier<String> staticLambdaExpression = () -> \"static lambda expression\";\n\n\tprivate final Supplier<String> instanceLambdaExpression = () -> \"instance lambda expressions\";\n\n\tprivate static String staticStringFactory() {\n\t\treturn \"static string factory\";\n\t}\n\n\tprivate String instanceStringFactory() {\n\t\treturn \"instance string factory\";\n\t}\n\n\tprivate static class EnigmaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"enigma\";\n\t\t}\n\t}\n\n\tprivate static class Fake$$LambdaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"fake lambda\";\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate interface MethodsInterface {\n\n\t\tdefault void defaultPrint() {\n\n\t\t}\n\n\t\tvoid print(String messages);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class MethodsInterfaceImplementation implements MethodsInterface {\n\n\t\t@Override\n\t\tpublic void print(String message) {\n\n\t\t}\n\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\tvoid packageAccessiblePrint() {\n\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class SubMethodsInterfaceImplementation extends MethodsInterfaceImplementation {\n\n\t\t@Override\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\t@Override\n\t\tpublic void packageAccessiblePrint() {\n\n\t\t}\n\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "iterationData": [],
            "targetClassMap": {}
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "url": "https://github.com/spring-projects/spring-framework/commit/ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private assertPublic(member Member) : void from class org.springframework.util.ClassUtilsTests.GetPubliclyAccessibleMethodTests to private assertPublic(member Member) : void from class org.springframework.util.ClassUtilsTests",
            "leftSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 722,
                    "endLine": 724,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private assertPublic(member Member) : void"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 881,
                    "endLine": 883,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "private assertPublic(member Member) : void"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "5f09b383-079e-4a7e-af48-b51f954de7b8",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 861,
                "lineStart": 57,
                "lineEnd": 917,
                "bodyLineStart": 57,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                "sourceCode": "/**\n * Tests for {@link ClassUtils}.\n *\n * @author Colin Sampaleanu\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rick Evans\n * @author Sam Brannen\n */\nclass ClassUtilsTests {\n\n\tprivate final ClassLoader classLoader = getClass().getClassLoader();\n\n\n\t@Test\n\tvoid isPresent() {\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.String\", classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.MySpecialString\", classLoader)).isFalse();\n\t}\n\n\t@Test\n\tvoid forName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"java.lang.String\", classLoader)).isEqualTo(String.class);\n\t\tassertThat(ClassUtils.forName(\"java.lang.String[]\", classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[].class.getName(), classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[][].class.getName(), classLoader)).isEqualTo(String[][].class);\n\t\tassertThat(ClassUtils.forName(String[][][].class.getName(), classLoader)).isEqualTo(String[][][].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject\", classLoader)).isEqualTo(TestObject.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[]\", classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(TestObject[].class.getName(), classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[][]\", classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(TestObject[][].class.getName(), classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(\"[[[S\", classLoader)).isEqualTo(short[][][].class);\n\t}\n\n\t@Test\n\tvoid forNameWithNestedType() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests$NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests.NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\n\t\t// Precondition: package name must have length == 1.\n\t\tassertThat(ClassHavingNestedClass.class.getPackageName().length()).isEqualTo(1);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass$NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass.NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveClasses() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean\", classLoader)).isEqualTo(boolean.class);\n\t\tassertThat(ClassUtils.forName(\"byte\", classLoader)).isEqualTo(byte.class);\n\t\tassertThat(ClassUtils.forName(\"char\", classLoader)).isEqualTo(char.class);\n\t\tassertThat(ClassUtils.forName(\"short\", classLoader)).isEqualTo(short.class);\n\t\tassertThat(ClassUtils.forName(\"int\", classLoader)).isEqualTo(int.class);\n\t\tassertThat(ClassUtils.forName(\"long\", classLoader)).isEqualTo(long.class);\n\t\tassertThat(ClassUtils.forName(\"float\", classLoader)).isEqualTo(float.class);\n\t\tassertThat(ClassUtils.forName(\"double\", classLoader)).isEqualTo(double.class);\n\t\tassertThat(ClassUtils.forName(\"void\", classLoader)).isEqualTo(void.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArrays() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean[]\", classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(\"byte[]\", classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(\"char[]\", classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(\"short[]\", classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(\"int[]\", classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(\"long[]\", classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(\"float[]\", classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(\"double[]\", classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArraysInternalName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(boolean[].class.getName(), classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(byte[].class.getName(), classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(char[].class.getName(), classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(short[].class.getName(), classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(int[].class.getName(), classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(long[].class.getName(), classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(float[].class.getName(), classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(double[].class.getName(), classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid isCacheSafe() {\n\t\tClassLoader childLoader1 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader2 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader3 = new ClassLoader(classLoader) {\n\t\t\t@Override\n\t\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\t\t\treturn childLoader1.loadClass(name);\n\t\t\t}\n\t\t};\n\t\tClass<?> composite = ClassUtils.createCompositeInterface(\n\t\t\t\tnew Class<?>[] {Serializable.class, Externalizable.class}, childLoader1);\n\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, null)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, classLoader)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader2)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader3)).isTrue();\n\t}\n\n\t@ParameterizedTest(name = \"''{0}'' -> {1}\")\n\t@CsvSource(textBlock = \"\"\"\n\t\tboolean, boolean\n\t\tbyte, byte\n\t\tchar, char\n\t\tshort, short\n\t\tint, int\n\t\tlong, long\n\t\tfloat, float\n\t\tdouble, double\n\t\t[Z, boolean[]\n\t\t[B, byte[]\n\t\t[C, char[]\n\t\t[S, short[]\n\t\t[I, int[]\n\t\t[J, long[]\n\t\t[F, float[]\n\t\t[D, double[]\n\t\t\"\"\")\n\tvoid resolvePrimitiveClassName(String input, Class<?> output) {\n\t\tassertThat(ClassUtils.resolvePrimitiveClassName(input)).isEqualTo(output);\n\t}\n\n\t@Test\n\tvoid getShortName() {\n\t\tString className = ClassUtils.getShortName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getShortNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[][][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForNestedClass() {\n\t\tString className = ClassUtils.getShortName(NestedClass.class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests.NestedClass\");\n\t}\n\n\t@Test\n\tvoid getShortNameAsProperty() {\n\t\tString shortName = ClassUtils.getShortNameAsProperty(this.getClass());\n\t\tassertThat(shortName).as(\"Class name did not match\").isEqualTo(\"classUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getClassFileName() {\n\t\tassertThat(ClassUtils.getClassFileName(String.class)).isEqualTo(\"String.class\");\n\t\tassertThat(ClassUtils.getClassFileName(getClass())).isEqualTo(\"ClassUtilsTests.class\");\n\t}\n\n\t@Test\n\tvoid getPackageName() {\n\t\tassertThat(ClassUtils.getPackageName(String.class)).isEqualTo(\"java.lang\");\n\t\tassertThat(ClassUtils.getPackageName(getClass())).isEqualTo(getClass().getPackage().getName());\n\t}\n\n\t@Test\n\tvoid getQualifiedName() {\n\t\tString className = ClassUtils.getQualifiedName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"org.springframework.util.ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[][]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][]\");\n\t}\n\n\t@Test\n\tvoid hasMethod() {\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"size\")).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\", Object.class)).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\")).isFalse();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"someOtherMethod\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getMethodIfAvailable() {\n\t\tMethod method = ClassUtils.getMethodIfAvailable(Collection.class, \"size\");\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"size\");\n\n\t\tmethod = ClassUtils.getMethodIfAvailable(Collection.class, \"remove\", Object.class);\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"remove\");\n\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"remove\")).isNull();\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"someOtherMethod\")).isNull();\n\t}\n\n\t@Test\n\tvoid getMethodCountForName() {\n\t\tassertThat(ClassUtils.getMethodCountForName(OverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for OverloadedMethodsClass.\").isEqualTo(2);\n\t\tassertThat(ClassUtils.getMethodCountForName(SubOverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for SubOverloadedMethodsClass.\").isEqualTo(4);\n\t}\n\n\t@Test\n\tvoid countOverloadedMethods() {\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"foobar\")).isFalse();\n\t\t// no args\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"hashCode\")).isTrue();\n\t\t// matches although it takes an arg\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"setAge\")).isTrue();\n\t}\n\n\t@Test\n\tvoid isAssignable() {\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Object.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(int.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, Object.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, Number.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, double.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(double.class, Integer.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid classPackageAsResourcePath() {\n\t\tString result = ClassUtils.classPackageAsResourcePath(Proxy.class);\n\t\tassertThat(result).isEqualTo(\"java/lang/reflect\");\n\t}\n\n\t@Test\n\tvoid addResourcePathToPackagePath() {\n\t\tString result = \"java/lang/reflect/xyzabc.xml\";\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"xyzabc.xml\")).isEqualTo(result);\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"/xyzabc.xml\")).isEqualTo(result);\n\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"a/b/c/d.xml\")).isEqualTo(\"java/lang/reflect/a/b/c/d.xml\");\n\t}\n\n\t@Test\n\tvoid getAllInterfaces() {\n\t\tDerivedTestObject testBean = new DerivedTestObject();\n\t\tList<Class<?>> ifcs = Arrays.asList(ClassUtils.getAllInterfaces(testBean));\n\t\tassertThat(ifcs).as(\"Correct number of interfaces\").hasSize(4);\n\t\tassertThat(ifcs.contains(Serializable.class)).as(\"Contains Serializable\").isTrue();\n\t\tassertThat(ifcs.contains(ITestObject.class)).as(\"Contains ITestBean\").isTrue();\n\t\tassertThat(ifcs.contains(ITestInterface.class)).as(\"Contains IOther\").isTrue();\n\t}\n\n\t@Test\n\tvoid classNamesToString() {\n\t\tList<Class<?>> ifcs = new ArrayList<>();\n\t\tifcs.add(Serializable.class);\n\t\tifcs.add(Runnable.class);\n\t\tassertThat(ifcs.toString()).isEqualTo(\"[interface java.io.Serializable, interface java.lang.Runnable]\");\n\t\tassertThat(ClassUtils.classNamesToString(ifcs)).isEqualTo(\"[java.io.Serializable, java.lang.Runnable]\");\n\n\t\tList<Class<?>> classes = new ArrayList<>();\n\t\tclasses.add(ArrayList.class);\n\t\tclasses.add(Integer.class);\n\t\tassertThat(classes.toString()).isEqualTo(\"[class java.util.ArrayList, class java.lang.Integer]\");\n\t\tassertThat(ClassUtils.classNamesToString(classes)).isEqualTo(\"[java.util.ArrayList, java.lang.Integer]\");\n\n\t\tassertThat(Collections.singletonList(List.class).toString()).isEqualTo(\"[interface java.util.List]\");\n\t\tassertThat(ClassUtils.classNamesToString(List.class)).isEqualTo(\"[java.util.List]\");\n\n\t\tassertThat(Collections.EMPTY_LIST.toString()).isEqualTo(\"[]\");\n\t\tassertThat(ClassUtils.classNamesToString(Collections.emptyList())).isEqualTo(\"[]\");\n\t}\n\n\t@Test\n\tvoid determineCommonAncestor() {\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Number.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, null)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, Integer.class)).isEqualTo(Integer.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Integer.class)).isEqualTo(Integer.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Float.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Float.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, Integer.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Collection.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, List.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, null)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, List.class)).isEqualTo(List.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Set.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Set.class, List.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Runnable.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Runnable.class, List.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, ArrayList.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(ArrayList.class, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, List.class)).isNull();\n\t}\n\n\t@Test\n\tvoid getMostSpecificMethod() throws NoSuchMethodException {\n\t\tMethod defaultPrintMethod = ClassUtils.getMethod(MethodsInterface.class, \"defaultPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\n\t\tMethod printMethod = ClassUtils.getMethod(MethodsInterface.class, \"print\", String.class);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isNotEqualTo(printMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\n\t\tMethod protectedPrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(protectedPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(SubMethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\"));\n\n\t\tMethod packageAccessiblePrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"packageAccessiblePrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(packageAccessiblePrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(SubMethodsInterfaceImplementation.class, \"packageAccessiblePrint\"));\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@PrimitiveTypes\n\tvoid isPrimitiveOrWrapperWithPrimitive(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveOrWrapperWithWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@Test\n\tvoid isLambda() {\n\t\tassertIsLambda(ClassUtilsTests.staticLambdaExpression);\n\t\tassertIsLambda(ClassUtilsTests::staticStringFactory);\n\n\t\tassertIsLambda(this.instanceLambdaExpression);\n\t\tassertIsLambda(this::instanceStringFactory);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"Convert2Lambda\")\n\tvoid isNotLambda() {\n\t\tassertIsNotLambda(new EnigmaSupplier());\n\n\t\tassertIsNotLambda(new Supplier<>() {\n\t\t\t@Override\n\t\t\tpublic String get() {\n\t\t\t\treturn \"anonymous inner class\";\n\t\t\t}\n\t\t});\n\n\t\tassertIsNotLambda(new Fake$$LambdaSupplier());\n\t}\n\n\n\t@Nested\n\tclass GetStaticMethodTests {\n\n\t\t@BeforeEach\n\t\tvoid clearStatics() {\n\t\t\tNestedClass.noArgCalled = false;\n\t\t\tNestedClass.argCalled = false;\n\t\t\tNestedClass.overloadedCalled = false;\n\t\t}\n\n\t\t@Test\n\t\tvoid noArgsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\");\n\t\t\tmethod.invoke(null, (Object[]) null);\n\t\t\tassertThat(NestedClass.noArgCalled).as(\"no argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid argsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"argStaticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.argCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid overloadedStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.overloadedCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t}\n\n\n\t@Nested  // gh-33216\n\tclass GetPubliclyAccessibleMethodTests {\n\n\t\t@Test\n\t\tvoid nonPublicMethod(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(originalMethod);\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\t// This method is intentionally public.\n\t\tpublic void publicMethodInNonPublicType(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = String.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = ArrayList.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"size\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in List.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaLangObjectDeclaredInNonPublicType() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Object.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"toString\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaTimeZoneIdDeclaredInNonPublicSubclass() throws Exception {\n\t\t\t// Returns a package-private java.time.ZoneRegion.\n\t\t\tZoneId zoneId = ZoneId.of(\"CET\");\n\t\t\tClass<?> targetClass = zoneId.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getDeclaredMethod(\"getId\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(ZoneId.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getId\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodDeclaredInNonPublicTypeWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\n\t\t\tHashMap<String, String> hashMap = new HashMap<>();\n\t\t\t// Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\n\t\t\t// which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\n\t\t\t// implements HashIterator.\n\t\t\tIterator<String> iterator = hashMap.keySet().iterator();\n\t\t\tClass<?> targetClass = iterator.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"hasNext\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, targetClass);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Iterator.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"hasNext\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getText\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in PrivateInterface.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getMessage\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getNumber\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getNumber\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"contains\", Object.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Collection.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"contains\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(Object.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"greet\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(String.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"process\", int.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"process\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(int.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\tprivate static void assertPubliclyAccessible(Method method) {\n\t\t\tassertPublic(method);\n\t\t\tassertPublic(method.getDeclaringClass());\n\t\t}\n\n\t\tprivate static void assertNotPubliclyAccessible(Method method) {\n\t\t\tassertThat(!isPublic(method) || !isPublic(method.getDeclaringClass()))\n\t\t\t\t\t.as(\"%s must not be publicly accessible\", method)\n\t\t\t\t\t.isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Member member) {\n\t\t\tassertThat(isPublic(member)).as(\"%s must be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Class<?> clazz) {\n\t\t\tassertThat(isPublic(clazz)).as(\"%s must be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Member member) {\n\t\t\tassertThat(!isPublic(member)).as(\"%s must be not be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Class<?> clazz) {\n\t\t\tassertThat(!isPublic(clazz)).as(\"%s must be not be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static boolean isPublic(Class<?> clazz) {\n\t\t\treturn Modifier.isPublic(clazz.getModifiers());\n\t\t}\n\n\t\tprivate static boolean isPublic(Member member) {\n\t\t\treturn Modifier.isPublic(member.getModifiers());\n\t\t}\n\n\t\tprivate interface PrivateInterface {\n\n\t\t\tString getMessage();\n\n\t\t\tString greet(String name);\n\t\t}\n\n\t\tprivate static class PrivateSubclass extends PublicSuperclass implements PublicInterface, PrivateInterface {\n\n\t\t\t@Override\n\t\t\tpublic int getNumber() {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getMessage() {\n\t\t\t\treturn \"hello\";\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String greet(String name) {\n\t\t\t\treturn \"Hello, \" + name;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int process(int num) {\n\t\t\t\treturn num * 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getText() {\n\t\t\t\treturn \"enigma\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { Boolean.class, Character.class, Byte.class, Short.class,\n\t\tInteger.class, Long.class, Float.class, Double.class, Void.class })\n\t@interface WrapperTypes {\n\t}\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { boolean.class, char.class, byte.class, short.class,\n\t\tint.class, long.class, float.class, double.class, void.class })\n\t@interface PrimitiveTypes {\n\t}\n\n\tpublic static class NestedClass {\n\n\t\tstatic boolean noArgCalled;\n\t\tstatic boolean argCalled;\n\t\tstatic boolean overloadedCalled;\n\n\t\tpublic static void staticMethod() {\n\t\t\tnoArgCalled = true;\n\t\t}\n\n\t\tpublic static void staticMethod(String anArg) {\n\t\t\toverloadedCalled = true;\n\t\t}\n\n\t\tpublic static void argStaticMethod(String anArg) {\n\t\t\targCalled = true;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class OverloadedMethodsClass {\n\n\t\tpublic void print(String messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tpublic void print(String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class SubOverloadedMethodsClass extends OverloadedMethodsClass {\n\n\t\tpublic void print(String header, String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tvoid print(String header, String[] messages, String footer) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\tprivate static void assertIsLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isTrue();\n\t}\n\n\tprivate static void assertIsNotLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isFalse();\n\t}\n\n\tprivate static final Supplier<String> staticLambdaExpression = () -> \"static lambda expression\";\n\n\tprivate final Supplier<String> instanceLambdaExpression = () -> \"instance lambda expressions\";\n\n\tprivate static String staticStringFactory() {\n\t\treturn \"static string factory\";\n\t}\n\n\tprivate String instanceStringFactory() {\n\t\treturn \"instance string factory\";\n\t}\n\n\tprivate static class EnigmaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"enigma\";\n\t\t}\n\t}\n\n\tprivate static class Fake$$LambdaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"fake lambda\";\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate interface MethodsInterface {\n\n\t\tdefault void defaultPrint() {\n\n\t\t}\n\n\t\tvoid print(String messages);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class MethodsInterfaceImplementation implements MethodsInterface {\n\n\t\t@Override\n\t\tpublic void print(String message) {\n\n\t\t}\n\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\tvoid packageAccessiblePrint() {\n\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class SubMethodsInterfaceImplementation extends MethodsInterfaceImplementation {\n\n\t\t@Override\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\t@Override\n\t\tpublic void packageAccessiblePrint() {\n\n\t\t}\n\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "iterationData": [],
            "targetClassMap": {}
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "url": "https://github.com/spring-projects/spring-framework/commit/ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private assertPublic(clazz Class<?>) : void from class org.springframework.util.ClassUtilsTests.GetPubliclyAccessibleMethodTests to private assertPublic(clazz Class<?>) : void from class org.springframework.util.ClassUtilsTests",
            "leftSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 726,
                    "endLine": 728,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private assertPublic(clazz Class<?>) : void"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 885,
                    "endLine": 887,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "private assertPublic(clazz Class<?>) : void"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "5f09b383-079e-4a7e-af48-b51f954de7b8",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 861,
                "lineStart": 57,
                "lineEnd": 917,
                "bodyLineStart": 57,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                "sourceCode": "/**\n * Tests for {@link ClassUtils}.\n *\n * @author Colin Sampaleanu\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rick Evans\n * @author Sam Brannen\n */\nclass ClassUtilsTests {\n\n\tprivate final ClassLoader classLoader = getClass().getClassLoader();\n\n\n\t@Test\n\tvoid isPresent() {\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.String\", classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.MySpecialString\", classLoader)).isFalse();\n\t}\n\n\t@Test\n\tvoid forName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"java.lang.String\", classLoader)).isEqualTo(String.class);\n\t\tassertThat(ClassUtils.forName(\"java.lang.String[]\", classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[].class.getName(), classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[][].class.getName(), classLoader)).isEqualTo(String[][].class);\n\t\tassertThat(ClassUtils.forName(String[][][].class.getName(), classLoader)).isEqualTo(String[][][].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject\", classLoader)).isEqualTo(TestObject.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[]\", classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(TestObject[].class.getName(), classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[][]\", classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(TestObject[][].class.getName(), classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(\"[[[S\", classLoader)).isEqualTo(short[][][].class);\n\t}\n\n\t@Test\n\tvoid forNameWithNestedType() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests$NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests.NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\n\t\t// Precondition: package name must have length == 1.\n\t\tassertThat(ClassHavingNestedClass.class.getPackageName().length()).isEqualTo(1);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass$NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass.NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveClasses() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean\", classLoader)).isEqualTo(boolean.class);\n\t\tassertThat(ClassUtils.forName(\"byte\", classLoader)).isEqualTo(byte.class);\n\t\tassertThat(ClassUtils.forName(\"char\", classLoader)).isEqualTo(char.class);\n\t\tassertThat(ClassUtils.forName(\"short\", classLoader)).isEqualTo(short.class);\n\t\tassertThat(ClassUtils.forName(\"int\", classLoader)).isEqualTo(int.class);\n\t\tassertThat(ClassUtils.forName(\"long\", classLoader)).isEqualTo(long.class);\n\t\tassertThat(ClassUtils.forName(\"float\", classLoader)).isEqualTo(float.class);\n\t\tassertThat(ClassUtils.forName(\"double\", classLoader)).isEqualTo(double.class);\n\t\tassertThat(ClassUtils.forName(\"void\", classLoader)).isEqualTo(void.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArrays() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean[]\", classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(\"byte[]\", classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(\"char[]\", classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(\"short[]\", classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(\"int[]\", classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(\"long[]\", classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(\"float[]\", classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(\"double[]\", classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArraysInternalName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(boolean[].class.getName(), classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(byte[].class.getName(), classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(char[].class.getName(), classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(short[].class.getName(), classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(int[].class.getName(), classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(long[].class.getName(), classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(float[].class.getName(), classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(double[].class.getName(), classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid isCacheSafe() {\n\t\tClassLoader childLoader1 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader2 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader3 = new ClassLoader(classLoader) {\n\t\t\t@Override\n\t\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\t\t\treturn childLoader1.loadClass(name);\n\t\t\t}\n\t\t};\n\t\tClass<?> composite = ClassUtils.createCompositeInterface(\n\t\t\t\tnew Class<?>[] {Serializable.class, Externalizable.class}, childLoader1);\n\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, null)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, classLoader)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader2)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader3)).isTrue();\n\t}\n\n\t@ParameterizedTest(name = \"''{0}'' -> {1}\")\n\t@CsvSource(textBlock = \"\"\"\n\t\tboolean, boolean\n\t\tbyte, byte\n\t\tchar, char\n\t\tshort, short\n\t\tint, int\n\t\tlong, long\n\t\tfloat, float\n\t\tdouble, double\n\t\t[Z, boolean[]\n\t\t[B, byte[]\n\t\t[C, char[]\n\t\t[S, short[]\n\t\t[I, int[]\n\t\t[J, long[]\n\t\t[F, float[]\n\t\t[D, double[]\n\t\t\"\"\")\n\tvoid resolvePrimitiveClassName(String input, Class<?> output) {\n\t\tassertThat(ClassUtils.resolvePrimitiveClassName(input)).isEqualTo(output);\n\t}\n\n\t@Test\n\tvoid getShortName() {\n\t\tString className = ClassUtils.getShortName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getShortNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[][][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForNestedClass() {\n\t\tString className = ClassUtils.getShortName(NestedClass.class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests.NestedClass\");\n\t}\n\n\t@Test\n\tvoid getShortNameAsProperty() {\n\t\tString shortName = ClassUtils.getShortNameAsProperty(this.getClass());\n\t\tassertThat(shortName).as(\"Class name did not match\").isEqualTo(\"classUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getClassFileName() {\n\t\tassertThat(ClassUtils.getClassFileName(String.class)).isEqualTo(\"String.class\");\n\t\tassertThat(ClassUtils.getClassFileName(getClass())).isEqualTo(\"ClassUtilsTests.class\");\n\t}\n\n\t@Test\n\tvoid getPackageName() {\n\t\tassertThat(ClassUtils.getPackageName(String.class)).isEqualTo(\"java.lang\");\n\t\tassertThat(ClassUtils.getPackageName(getClass())).isEqualTo(getClass().getPackage().getName());\n\t}\n\n\t@Test\n\tvoid getQualifiedName() {\n\t\tString className = ClassUtils.getQualifiedName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"org.springframework.util.ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[][]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][]\");\n\t}\n\n\t@Test\n\tvoid hasMethod() {\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"size\")).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\", Object.class)).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\")).isFalse();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"someOtherMethod\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getMethodIfAvailable() {\n\t\tMethod method = ClassUtils.getMethodIfAvailable(Collection.class, \"size\");\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"size\");\n\n\t\tmethod = ClassUtils.getMethodIfAvailable(Collection.class, \"remove\", Object.class);\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"remove\");\n\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"remove\")).isNull();\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"someOtherMethod\")).isNull();\n\t}\n\n\t@Test\n\tvoid getMethodCountForName() {\n\t\tassertThat(ClassUtils.getMethodCountForName(OverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for OverloadedMethodsClass.\").isEqualTo(2);\n\t\tassertThat(ClassUtils.getMethodCountForName(SubOverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for SubOverloadedMethodsClass.\").isEqualTo(4);\n\t}\n\n\t@Test\n\tvoid countOverloadedMethods() {\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"foobar\")).isFalse();\n\t\t// no args\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"hashCode\")).isTrue();\n\t\t// matches although it takes an arg\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"setAge\")).isTrue();\n\t}\n\n\t@Test\n\tvoid isAssignable() {\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Object.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(int.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, Object.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, Number.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, double.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(double.class, Integer.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid classPackageAsResourcePath() {\n\t\tString result = ClassUtils.classPackageAsResourcePath(Proxy.class);\n\t\tassertThat(result).isEqualTo(\"java/lang/reflect\");\n\t}\n\n\t@Test\n\tvoid addResourcePathToPackagePath() {\n\t\tString result = \"java/lang/reflect/xyzabc.xml\";\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"xyzabc.xml\")).isEqualTo(result);\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"/xyzabc.xml\")).isEqualTo(result);\n\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"a/b/c/d.xml\")).isEqualTo(\"java/lang/reflect/a/b/c/d.xml\");\n\t}\n\n\t@Test\n\tvoid getAllInterfaces() {\n\t\tDerivedTestObject testBean = new DerivedTestObject();\n\t\tList<Class<?>> ifcs = Arrays.asList(ClassUtils.getAllInterfaces(testBean));\n\t\tassertThat(ifcs).as(\"Correct number of interfaces\").hasSize(4);\n\t\tassertThat(ifcs.contains(Serializable.class)).as(\"Contains Serializable\").isTrue();\n\t\tassertThat(ifcs.contains(ITestObject.class)).as(\"Contains ITestBean\").isTrue();\n\t\tassertThat(ifcs.contains(ITestInterface.class)).as(\"Contains IOther\").isTrue();\n\t}\n\n\t@Test\n\tvoid classNamesToString() {\n\t\tList<Class<?>> ifcs = new ArrayList<>();\n\t\tifcs.add(Serializable.class);\n\t\tifcs.add(Runnable.class);\n\t\tassertThat(ifcs.toString()).isEqualTo(\"[interface java.io.Serializable, interface java.lang.Runnable]\");\n\t\tassertThat(ClassUtils.classNamesToString(ifcs)).isEqualTo(\"[java.io.Serializable, java.lang.Runnable]\");\n\n\t\tList<Class<?>> classes = new ArrayList<>();\n\t\tclasses.add(ArrayList.class);\n\t\tclasses.add(Integer.class);\n\t\tassertThat(classes.toString()).isEqualTo(\"[class java.util.ArrayList, class java.lang.Integer]\");\n\t\tassertThat(ClassUtils.classNamesToString(classes)).isEqualTo(\"[java.util.ArrayList, java.lang.Integer]\");\n\n\t\tassertThat(Collections.singletonList(List.class).toString()).isEqualTo(\"[interface java.util.List]\");\n\t\tassertThat(ClassUtils.classNamesToString(List.class)).isEqualTo(\"[java.util.List]\");\n\n\t\tassertThat(Collections.EMPTY_LIST.toString()).isEqualTo(\"[]\");\n\t\tassertThat(ClassUtils.classNamesToString(Collections.emptyList())).isEqualTo(\"[]\");\n\t}\n\n\t@Test\n\tvoid determineCommonAncestor() {\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Number.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, null)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, Integer.class)).isEqualTo(Integer.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Integer.class)).isEqualTo(Integer.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Float.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Float.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, Integer.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Collection.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, List.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, null)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, List.class)).isEqualTo(List.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Set.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Set.class, List.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Runnable.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Runnable.class, List.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, ArrayList.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(ArrayList.class, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, List.class)).isNull();\n\t}\n\n\t@Test\n\tvoid getMostSpecificMethod() throws NoSuchMethodException {\n\t\tMethod defaultPrintMethod = ClassUtils.getMethod(MethodsInterface.class, \"defaultPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\n\t\tMethod printMethod = ClassUtils.getMethod(MethodsInterface.class, \"print\", String.class);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isNotEqualTo(printMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\n\t\tMethod protectedPrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(protectedPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(SubMethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\"));\n\n\t\tMethod packageAccessiblePrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"packageAccessiblePrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(packageAccessiblePrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(SubMethodsInterfaceImplementation.class, \"packageAccessiblePrint\"));\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@PrimitiveTypes\n\tvoid isPrimitiveOrWrapperWithPrimitive(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveOrWrapperWithWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@Test\n\tvoid isLambda() {\n\t\tassertIsLambda(ClassUtilsTests.staticLambdaExpression);\n\t\tassertIsLambda(ClassUtilsTests::staticStringFactory);\n\n\t\tassertIsLambda(this.instanceLambdaExpression);\n\t\tassertIsLambda(this::instanceStringFactory);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"Convert2Lambda\")\n\tvoid isNotLambda() {\n\t\tassertIsNotLambda(new EnigmaSupplier());\n\n\t\tassertIsNotLambda(new Supplier<>() {\n\t\t\t@Override\n\t\t\tpublic String get() {\n\t\t\t\treturn \"anonymous inner class\";\n\t\t\t}\n\t\t});\n\n\t\tassertIsNotLambda(new Fake$$LambdaSupplier());\n\t}\n\n\n\t@Nested\n\tclass GetStaticMethodTests {\n\n\t\t@BeforeEach\n\t\tvoid clearStatics() {\n\t\t\tNestedClass.noArgCalled = false;\n\t\t\tNestedClass.argCalled = false;\n\t\t\tNestedClass.overloadedCalled = false;\n\t\t}\n\n\t\t@Test\n\t\tvoid noArgsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\");\n\t\t\tmethod.invoke(null, (Object[]) null);\n\t\t\tassertThat(NestedClass.noArgCalled).as(\"no argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid argsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"argStaticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.argCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid overloadedStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.overloadedCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t}\n\n\n\t@Nested  // gh-33216\n\tclass GetPubliclyAccessibleMethodTests {\n\n\t\t@Test\n\t\tvoid nonPublicMethod(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(originalMethod);\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\t// This method is intentionally public.\n\t\tpublic void publicMethodInNonPublicType(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = String.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = ArrayList.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"size\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in List.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaLangObjectDeclaredInNonPublicType() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Object.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"toString\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaTimeZoneIdDeclaredInNonPublicSubclass() throws Exception {\n\t\t\t// Returns a package-private java.time.ZoneRegion.\n\t\t\tZoneId zoneId = ZoneId.of(\"CET\");\n\t\t\tClass<?> targetClass = zoneId.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getDeclaredMethod(\"getId\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(ZoneId.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getId\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodDeclaredInNonPublicTypeWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\n\t\t\tHashMap<String, String> hashMap = new HashMap<>();\n\t\t\t// Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\n\t\t\t// which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\n\t\t\t// implements HashIterator.\n\t\t\tIterator<String> iterator = hashMap.keySet().iterator();\n\t\t\tClass<?> targetClass = iterator.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"hasNext\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, targetClass);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Iterator.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"hasNext\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getText\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in PrivateInterface.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getMessage\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getNumber\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getNumber\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"contains\", Object.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Collection.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"contains\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(Object.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"greet\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(String.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"process\", int.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"process\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(int.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\tprivate static void assertPubliclyAccessible(Method method) {\n\t\t\tassertPublic(method);\n\t\t\tassertPublic(method.getDeclaringClass());\n\t\t}\n\n\t\tprivate static void assertNotPubliclyAccessible(Method method) {\n\t\t\tassertThat(!isPublic(method) || !isPublic(method.getDeclaringClass()))\n\t\t\t\t\t.as(\"%s must not be publicly accessible\", method)\n\t\t\t\t\t.isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Member member) {\n\t\t\tassertThat(isPublic(member)).as(\"%s must be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Class<?> clazz) {\n\t\t\tassertThat(isPublic(clazz)).as(\"%s must be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Member member) {\n\t\t\tassertThat(!isPublic(member)).as(\"%s must be not be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Class<?> clazz) {\n\t\t\tassertThat(!isPublic(clazz)).as(\"%s must be not be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static boolean isPublic(Class<?> clazz) {\n\t\t\treturn Modifier.isPublic(clazz.getModifiers());\n\t\t}\n\n\t\tprivate static boolean isPublic(Member member) {\n\t\t\treturn Modifier.isPublic(member.getModifiers());\n\t\t}\n\n\t\tprivate interface PrivateInterface {\n\n\t\t\tString getMessage();\n\n\t\t\tString greet(String name);\n\t\t}\n\n\t\tprivate static class PrivateSubclass extends PublicSuperclass implements PublicInterface, PrivateInterface {\n\n\t\t\t@Override\n\t\t\tpublic int getNumber() {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getMessage() {\n\t\t\t\treturn \"hello\";\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String greet(String name) {\n\t\t\t\treturn \"Hello, \" + name;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int process(int num) {\n\t\t\t\treturn num * 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getText() {\n\t\t\t\treturn \"enigma\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { Boolean.class, Character.class, Byte.class, Short.class,\n\t\tInteger.class, Long.class, Float.class, Double.class, Void.class })\n\t@interface WrapperTypes {\n\t}\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { boolean.class, char.class, byte.class, short.class,\n\t\tint.class, long.class, float.class, double.class, void.class })\n\t@interface PrimitiveTypes {\n\t}\n\n\tpublic static class NestedClass {\n\n\t\tstatic boolean noArgCalled;\n\t\tstatic boolean argCalled;\n\t\tstatic boolean overloadedCalled;\n\n\t\tpublic static void staticMethod() {\n\t\t\tnoArgCalled = true;\n\t\t}\n\n\t\tpublic static void staticMethod(String anArg) {\n\t\t\toverloadedCalled = true;\n\t\t}\n\n\t\tpublic static void argStaticMethod(String anArg) {\n\t\t\targCalled = true;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class OverloadedMethodsClass {\n\n\t\tpublic void print(String messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tpublic void print(String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class SubOverloadedMethodsClass extends OverloadedMethodsClass {\n\n\t\tpublic void print(String header, String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tvoid print(String header, String[] messages, String footer) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\tprivate static void assertIsLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isTrue();\n\t}\n\n\tprivate static void assertIsNotLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isFalse();\n\t}\n\n\tprivate static final Supplier<String> staticLambdaExpression = () -> \"static lambda expression\";\n\n\tprivate final Supplier<String> instanceLambdaExpression = () -> \"instance lambda expressions\";\n\n\tprivate static String staticStringFactory() {\n\t\treturn \"static string factory\";\n\t}\n\n\tprivate String instanceStringFactory() {\n\t\treturn \"instance string factory\";\n\t}\n\n\tprivate static class EnigmaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"enigma\";\n\t\t}\n\t}\n\n\tprivate static class Fake$$LambdaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"fake lambda\";\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate interface MethodsInterface {\n\n\t\tdefault void defaultPrint() {\n\n\t\t}\n\n\t\tvoid print(String messages);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class MethodsInterfaceImplementation implements MethodsInterface {\n\n\t\t@Override\n\t\tpublic void print(String message) {\n\n\t\t}\n\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\tvoid packageAccessiblePrint() {\n\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class SubMethodsInterfaceImplementation extends MethodsInterfaceImplementation {\n\n\t\t@Override\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\t@Override\n\t\tpublic void packageAccessiblePrint() {\n\n\t\t}\n\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "iterationData": [],
            "targetClassMap": {}
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "url": "https://github.com/spring-projects/spring-framework/commit/ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private assertNotPublic(member Member) : void from class org.springframework.util.ClassUtilsTests.GetPubliclyAccessibleMethodTests to private assertNotPublic(member Member) : void from class org.springframework.util.ClassUtilsTests",
            "leftSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 730,
                    "endLine": 732,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private assertNotPublic(member Member) : void"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 889,
                    "endLine": 891,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "private assertNotPublic(member Member) : void"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "5f09b383-079e-4a7e-af48-b51f954de7b8",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 861,
                "lineStart": 57,
                "lineEnd": 917,
                "bodyLineStart": 57,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                "sourceCode": "/**\n * Tests for {@link ClassUtils}.\n *\n * @author Colin Sampaleanu\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rick Evans\n * @author Sam Brannen\n */\nclass ClassUtilsTests {\n\n\tprivate final ClassLoader classLoader = getClass().getClassLoader();\n\n\n\t@Test\n\tvoid isPresent() {\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.String\", classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.MySpecialString\", classLoader)).isFalse();\n\t}\n\n\t@Test\n\tvoid forName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"java.lang.String\", classLoader)).isEqualTo(String.class);\n\t\tassertThat(ClassUtils.forName(\"java.lang.String[]\", classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[].class.getName(), classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[][].class.getName(), classLoader)).isEqualTo(String[][].class);\n\t\tassertThat(ClassUtils.forName(String[][][].class.getName(), classLoader)).isEqualTo(String[][][].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject\", classLoader)).isEqualTo(TestObject.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[]\", classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(TestObject[].class.getName(), classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[][]\", classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(TestObject[][].class.getName(), classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(\"[[[S\", classLoader)).isEqualTo(short[][][].class);\n\t}\n\n\t@Test\n\tvoid forNameWithNestedType() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests$NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests.NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\n\t\t// Precondition: package name must have length == 1.\n\t\tassertThat(ClassHavingNestedClass.class.getPackageName().length()).isEqualTo(1);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass$NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass.NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveClasses() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean\", classLoader)).isEqualTo(boolean.class);\n\t\tassertThat(ClassUtils.forName(\"byte\", classLoader)).isEqualTo(byte.class);\n\t\tassertThat(ClassUtils.forName(\"char\", classLoader)).isEqualTo(char.class);\n\t\tassertThat(ClassUtils.forName(\"short\", classLoader)).isEqualTo(short.class);\n\t\tassertThat(ClassUtils.forName(\"int\", classLoader)).isEqualTo(int.class);\n\t\tassertThat(ClassUtils.forName(\"long\", classLoader)).isEqualTo(long.class);\n\t\tassertThat(ClassUtils.forName(\"float\", classLoader)).isEqualTo(float.class);\n\t\tassertThat(ClassUtils.forName(\"double\", classLoader)).isEqualTo(double.class);\n\t\tassertThat(ClassUtils.forName(\"void\", classLoader)).isEqualTo(void.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArrays() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean[]\", classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(\"byte[]\", classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(\"char[]\", classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(\"short[]\", classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(\"int[]\", classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(\"long[]\", classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(\"float[]\", classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(\"double[]\", classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArraysInternalName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(boolean[].class.getName(), classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(byte[].class.getName(), classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(char[].class.getName(), classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(short[].class.getName(), classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(int[].class.getName(), classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(long[].class.getName(), classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(float[].class.getName(), classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(double[].class.getName(), classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid isCacheSafe() {\n\t\tClassLoader childLoader1 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader2 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader3 = new ClassLoader(classLoader) {\n\t\t\t@Override\n\t\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\t\t\treturn childLoader1.loadClass(name);\n\t\t\t}\n\t\t};\n\t\tClass<?> composite = ClassUtils.createCompositeInterface(\n\t\t\t\tnew Class<?>[] {Serializable.class, Externalizable.class}, childLoader1);\n\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, null)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, classLoader)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader2)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader3)).isTrue();\n\t}\n\n\t@ParameterizedTest(name = \"''{0}'' -> {1}\")\n\t@CsvSource(textBlock = \"\"\"\n\t\tboolean, boolean\n\t\tbyte, byte\n\t\tchar, char\n\t\tshort, short\n\t\tint, int\n\t\tlong, long\n\t\tfloat, float\n\t\tdouble, double\n\t\t[Z, boolean[]\n\t\t[B, byte[]\n\t\t[C, char[]\n\t\t[S, short[]\n\t\t[I, int[]\n\t\t[J, long[]\n\t\t[F, float[]\n\t\t[D, double[]\n\t\t\"\"\")\n\tvoid resolvePrimitiveClassName(String input, Class<?> output) {\n\t\tassertThat(ClassUtils.resolvePrimitiveClassName(input)).isEqualTo(output);\n\t}\n\n\t@Test\n\tvoid getShortName() {\n\t\tString className = ClassUtils.getShortName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getShortNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[][][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForNestedClass() {\n\t\tString className = ClassUtils.getShortName(NestedClass.class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests.NestedClass\");\n\t}\n\n\t@Test\n\tvoid getShortNameAsProperty() {\n\t\tString shortName = ClassUtils.getShortNameAsProperty(this.getClass());\n\t\tassertThat(shortName).as(\"Class name did not match\").isEqualTo(\"classUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getClassFileName() {\n\t\tassertThat(ClassUtils.getClassFileName(String.class)).isEqualTo(\"String.class\");\n\t\tassertThat(ClassUtils.getClassFileName(getClass())).isEqualTo(\"ClassUtilsTests.class\");\n\t}\n\n\t@Test\n\tvoid getPackageName() {\n\t\tassertThat(ClassUtils.getPackageName(String.class)).isEqualTo(\"java.lang\");\n\t\tassertThat(ClassUtils.getPackageName(getClass())).isEqualTo(getClass().getPackage().getName());\n\t}\n\n\t@Test\n\tvoid getQualifiedName() {\n\t\tString className = ClassUtils.getQualifiedName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"org.springframework.util.ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[][]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][]\");\n\t}\n\n\t@Test\n\tvoid hasMethod() {\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"size\")).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\", Object.class)).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\")).isFalse();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"someOtherMethod\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getMethodIfAvailable() {\n\t\tMethod method = ClassUtils.getMethodIfAvailable(Collection.class, \"size\");\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"size\");\n\n\t\tmethod = ClassUtils.getMethodIfAvailable(Collection.class, \"remove\", Object.class);\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"remove\");\n\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"remove\")).isNull();\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"someOtherMethod\")).isNull();\n\t}\n\n\t@Test\n\tvoid getMethodCountForName() {\n\t\tassertThat(ClassUtils.getMethodCountForName(OverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for OverloadedMethodsClass.\").isEqualTo(2);\n\t\tassertThat(ClassUtils.getMethodCountForName(SubOverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for SubOverloadedMethodsClass.\").isEqualTo(4);\n\t}\n\n\t@Test\n\tvoid countOverloadedMethods() {\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"foobar\")).isFalse();\n\t\t// no args\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"hashCode\")).isTrue();\n\t\t// matches although it takes an arg\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"setAge\")).isTrue();\n\t}\n\n\t@Test\n\tvoid isAssignable() {\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Object.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(int.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, Object.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, Number.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, double.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(double.class, Integer.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid classPackageAsResourcePath() {\n\t\tString result = ClassUtils.classPackageAsResourcePath(Proxy.class);\n\t\tassertThat(result).isEqualTo(\"java/lang/reflect\");\n\t}\n\n\t@Test\n\tvoid addResourcePathToPackagePath() {\n\t\tString result = \"java/lang/reflect/xyzabc.xml\";\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"xyzabc.xml\")).isEqualTo(result);\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"/xyzabc.xml\")).isEqualTo(result);\n\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"a/b/c/d.xml\")).isEqualTo(\"java/lang/reflect/a/b/c/d.xml\");\n\t}\n\n\t@Test\n\tvoid getAllInterfaces() {\n\t\tDerivedTestObject testBean = new DerivedTestObject();\n\t\tList<Class<?>> ifcs = Arrays.asList(ClassUtils.getAllInterfaces(testBean));\n\t\tassertThat(ifcs).as(\"Correct number of interfaces\").hasSize(4);\n\t\tassertThat(ifcs.contains(Serializable.class)).as(\"Contains Serializable\").isTrue();\n\t\tassertThat(ifcs.contains(ITestObject.class)).as(\"Contains ITestBean\").isTrue();\n\t\tassertThat(ifcs.contains(ITestInterface.class)).as(\"Contains IOther\").isTrue();\n\t}\n\n\t@Test\n\tvoid classNamesToString() {\n\t\tList<Class<?>> ifcs = new ArrayList<>();\n\t\tifcs.add(Serializable.class);\n\t\tifcs.add(Runnable.class);\n\t\tassertThat(ifcs.toString()).isEqualTo(\"[interface java.io.Serializable, interface java.lang.Runnable]\");\n\t\tassertThat(ClassUtils.classNamesToString(ifcs)).isEqualTo(\"[java.io.Serializable, java.lang.Runnable]\");\n\n\t\tList<Class<?>> classes = new ArrayList<>();\n\t\tclasses.add(ArrayList.class);\n\t\tclasses.add(Integer.class);\n\t\tassertThat(classes.toString()).isEqualTo(\"[class java.util.ArrayList, class java.lang.Integer]\");\n\t\tassertThat(ClassUtils.classNamesToString(classes)).isEqualTo(\"[java.util.ArrayList, java.lang.Integer]\");\n\n\t\tassertThat(Collections.singletonList(List.class).toString()).isEqualTo(\"[interface java.util.List]\");\n\t\tassertThat(ClassUtils.classNamesToString(List.class)).isEqualTo(\"[java.util.List]\");\n\n\t\tassertThat(Collections.EMPTY_LIST.toString()).isEqualTo(\"[]\");\n\t\tassertThat(ClassUtils.classNamesToString(Collections.emptyList())).isEqualTo(\"[]\");\n\t}\n\n\t@Test\n\tvoid determineCommonAncestor() {\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Number.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, null)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, Integer.class)).isEqualTo(Integer.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Integer.class)).isEqualTo(Integer.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Float.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Float.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, Integer.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Collection.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, List.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, null)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, List.class)).isEqualTo(List.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Set.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Set.class, List.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Runnable.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Runnable.class, List.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, ArrayList.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(ArrayList.class, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, List.class)).isNull();\n\t}\n\n\t@Test\n\tvoid getMostSpecificMethod() throws NoSuchMethodException {\n\t\tMethod defaultPrintMethod = ClassUtils.getMethod(MethodsInterface.class, \"defaultPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\n\t\tMethod printMethod = ClassUtils.getMethod(MethodsInterface.class, \"print\", String.class);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isNotEqualTo(printMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\n\t\tMethod protectedPrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(protectedPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(SubMethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\"));\n\n\t\tMethod packageAccessiblePrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"packageAccessiblePrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(packageAccessiblePrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(SubMethodsInterfaceImplementation.class, \"packageAccessiblePrint\"));\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@PrimitiveTypes\n\tvoid isPrimitiveOrWrapperWithPrimitive(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveOrWrapperWithWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@Test\n\tvoid isLambda() {\n\t\tassertIsLambda(ClassUtilsTests.staticLambdaExpression);\n\t\tassertIsLambda(ClassUtilsTests::staticStringFactory);\n\n\t\tassertIsLambda(this.instanceLambdaExpression);\n\t\tassertIsLambda(this::instanceStringFactory);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"Convert2Lambda\")\n\tvoid isNotLambda() {\n\t\tassertIsNotLambda(new EnigmaSupplier());\n\n\t\tassertIsNotLambda(new Supplier<>() {\n\t\t\t@Override\n\t\t\tpublic String get() {\n\t\t\t\treturn \"anonymous inner class\";\n\t\t\t}\n\t\t});\n\n\t\tassertIsNotLambda(new Fake$$LambdaSupplier());\n\t}\n\n\n\t@Nested\n\tclass GetStaticMethodTests {\n\n\t\t@BeforeEach\n\t\tvoid clearStatics() {\n\t\t\tNestedClass.noArgCalled = false;\n\t\t\tNestedClass.argCalled = false;\n\t\t\tNestedClass.overloadedCalled = false;\n\t\t}\n\n\t\t@Test\n\t\tvoid noArgsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\");\n\t\t\tmethod.invoke(null, (Object[]) null);\n\t\t\tassertThat(NestedClass.noArgCalled).as(\"no argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid argsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"argStaticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.argCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid overloadedStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.overloadedCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t}\n\n\n\t@Nested  // gh-33216\n\tclass GetPubliclyAccessibleMethodTests {\n\n\t\t@Test\n\t\tvoid nonPublicMethod(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(originalMethod);\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\t// This method is intentionally public.\n\t\tpublic void publicMethodInNonPublicType(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = String.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = ArrayList.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"size\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in List.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaLangObjectDeclaredInNonPublicType() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Object.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"toString\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaTimeZoneIdDeclaredInNonPublicSubclass() throws Exception {\n\t\t\t// Returns a package-private java.time.ZoneRegion.\n\t\t\tZoneId zoneId = ZoneId.of(\"CET\");\n\t\t\tClass<?> targetClass = zoneId.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getDeclaredMethod(\"getId\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(ZoneId.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getId\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodDeclaredInNonPublicTypeWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\n\t\t\tHashMap<String, String> hashMap = new HashMap<>();\n\t\t\t// Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\n\t\t\t// which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\n\t\t\t// implements HashIterator.\n\t\t\tIterator<String> iterator = hashMap.keySet().iterator();\n\t\t\tClass<?> targetClass = iterator.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"hasNext\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, targetClass);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Iterator.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"hasNext\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getText\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in PrivateInterface.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getMessage\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getNumber\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getNumber\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"contains\", Object.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Collection.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"contains\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(Object.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"greet\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(String.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"process\", int.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"process\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(int.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\tprivate static void assertPubliclyAccessible(Method method) {\n\t\t\tassertPublic(method);\n\t\t\tassertPublic(method.getDeclaringClass());\n\t\t}\n\n\t\tprivate static void assertNotPubliclyAccessible(Method method) {\n\t\t\tassertThat(!isPublic(method) || !isPublic(method.getDeclaringClass()))\n\t\t\t\t\t.as(\"%s must not be publicly accessible\", method)\n\t\t\t\t\t.isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Member member) {\n\t\t\tassertThat(isPublic(member)).as(\"%s must be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Class<?> clazz) {\n\t\t\tassertThat(isPublic(clazz)).as(\"%s must be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Member member) {\n\t\t\tassertThat(!isPublic(member)).as(\"%s must be not be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Class<?> clazz) {\n\t\t\tassertThat(!isPublic(clazz)).as(\"%s must be not be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static boolean isPublic(Class<?> clazz) {\n\t\t\treturn Modifier.isPublic(clazz.getModifiers());\n\t\t}\n\n\t\tprivate static boolean isPublic(Member member) {\n\t\t\treturn Modifier.isPublic(member.getModifiers());\n\t\t}\n\n\t\tprivate interface PrivateInterface {\n\n\t\t\tString getMessage();\n\n\t\t\tString greet(String name);\n\t\t}\n\n\t\tprivate static class PrivateSubclass extends PublicSuperclass implements PublicInterface, PrivateInterface {\n\n\t\t\t@Override\n\t\t\tpublic int getNumber() {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getMessage() {\n\t\t\t\treturn \"hello\";\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String greet(String name) {\n\t\t\t\treturn \"Hello, \" + name;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int process(int num) {\n\t\t\t\treturn num * 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getText() {\n\t\t\t\treturn \"enigma\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { Boolean.class, Character.class, Byte.class, Short.class,\n\t\tInteger.class, Long.class, Float.class, Double.class, Void.class })\n\t@interface WrapperTypes {\n\t}\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { boolean.class, char.class, byte.class, short.class,\n\t\tint.class, long.class, float.class, double.class, void.class })\n\t@interface PrimitiveTypes {\n\t}\n\n\tpublic static class NestedClass {\n\n\t\tstatic boolean noArgCalled;\n\t\tstatic boolean argCalled;\n\t\tstatic boolean overloadedCalled;\n\n\t\tpublic static void staticMethod() {\n\t\t\tnoArgCalled = true;\n\t\t}\n\n\t\tpublic static void staticMethod(String anArg) {\n\t\t\toverloadedCalled = true;\n\t\t}\n\n\t\tpublic static void argStaticMethod(String anArg) {\n\t\t\targCalled = true;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class OverloadedMethodsClass {\n\n\t\tpublic void print(String messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tpublic void print(String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class SubOverloadedMethodsClass extends OverloadedMethodsClass {\n\n\t\tpublic void print(String header, String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tvoid print(String header, String[] messages, String footer) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\tprivate static void assertIsLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isTrue();\n\t}\n\n\tprivate static void assertIsNotLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isFalse();\n\t}\n\n\tprivate static final Supplier<String> staticLambdaExpression = () -> \"static lambda expression\";\n\n\tprivate final Supplier<String> instanceLambdaExpression = () -> \"instance lambda expressions\";\n\n\tprivate static String staticStringFactory() {\n\t\treturn \"static string factory\";\n\t}\n\n\tprivate String instanceStringFactory() {\n\t\treturn \"instance string factory\";\n\t}\n\n\tprivate static class EnigmaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"enigma\";\n\t\t}\n\t}\n\n\tprivate static class Fake$$LambdaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"fake lambda\";\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate interface MethodsInterface {\n\n\t\tdefault void defaultPrint() {\n\n\t\t}\n\n\t\tvoid print(String messages);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class MethodsInterfaceImplementation implements MethodsInterface {\n\n\t\t@Override\n\t\tpublic void print(String message) {\n\n\t\t}\n\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\tvoid packageAccessiblePrint() {\n\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class SubMethodsInterfaceImplementation extends MethodsInterfaceImplementation {\n\n\t\t@Override\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\t@Override\n\t\tpublic void packageAccessiblePrint() {\n\n\t\t}\n\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "iterationData": [],
            "targetClassMap": {}
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "url": "https://github.com/spring-projects/spring-framework/commit/ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private assertNotPublic(clazz Class<?>) : void from class org.springframework.util.ClassUtilsTests.GetPubliclyAccessibleMethodTests to private assertNotPublic(clazz Class<?>) : void from class org.springframework.util.ClassUtilsTests",
            "leftSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 734,
                    "endLine": 736,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private assertNotPublic(clazz Class<?>) : void"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 893,
                    "endLine": 895,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "private assertNotPublic(clazz Class<?>) : void"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "5f09b383-079e-4a7e-af48-b51f954de7b8",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 861,
                "lineStart": 57,
                "lineEnd": 917,
                "bodyLineStart": 57,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                "sourceCode": "/**\n * Tests for {@link ClassUtils}.\n *\n * @author Colin Sampaleanu\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rick Evans\n * @author Sam Brannen\n */\nclass ClassUtilsTests {\n\n\tprivate final ClassLoader classLoader = getClass().getClassLoader();\n\n\n\t@Test\n\tvoid isPresent() {\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.String\", classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.MySpecialString\", classLoader)).isFalse();\n\t}\n\n\t@Test\n\tvoid forName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"java.lang.String\", classLoader)).isEqualTo(String.class);\n\t\tassertThat(ClassUtils.forName(\"java.lang.String[]\", classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[].class.getName(), classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[][].class.getName(), classLoader)).isEqualTo(String[][].class);\n\t\tassertThat(ClassUtils.forName(String[][][].class.getName(), classLoader)).isEqualTo(String[][][].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject\", classLoader)).isEqualTo(TestObject.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[]\", classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(TestObject[].class.getName(), classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[][]\", classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(TestObject[][].class.getName(), classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(\"[[[S\", classLoader)).isEqualTo(short[][][].class);\n\t}\n\n\t@Test\n\tvoid forNameWithNestedType() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests$NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests.NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\n\t\t// Precondition: package name must have length == 1.\n\t\tassertThat(ClassHavingNestedClass.class.getPackageName().length()).isEqualTo(1);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass$NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass.NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveClasses() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean\", classLoader)).isEqualTo(boolean.class);\n\t\tassertThat(ClassUtils.forName(\"byte\", classLoader)).isEqualTo(byte.class);\n\t\tassertThat(ClassUtils.forName(\"char\", classLoader)).isEqualTo(char.class);\n\t\tassertThat(ClassUtils.forName(\"short\", classLoader)).isEqualTo(short.class);\n\t\tassertThat(ClassUtils.forName(\"int\", classLoader)).isEqualTo(int.class);\n\t\tassertThat(ClassUtils.forName(\"long\", classLoader)).isEqualTo(long.class);\n\t\tassertThat(ClassUtils.forName(\"float\", classLoader)).isEqualTo(float.class);\n\t\tassertThat(ClassUtils.forName(\"double\", classLoader)).isEqualTo(double.class);\n\t\tassertThat(ClassUtils.forName(\"void\", classLoader)).isEqualTo(void.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArrays() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean[]\", classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(\"byte[]\", classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(\"char[]\", classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(\"short[]\", classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(\"int[]\", classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(\"long[]\", classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(\"float[]\", classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(\"double[]\", classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArraysInternalName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(boolean[].class.getName(), classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(byte[].class.getName(), classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(char[].class.getName(), classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(short[].class.getName(), classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(int[].class.getName(), classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(long[].class.getName(), classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(float[].class.getName(), classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(double[].class.getName(), classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid isCacheSafe() {\n\t\tClassLoader childLoader1 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader2 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader3 = new ClassLoader(classLoader) {\n\t\t\t@Override\n\t\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\t\t\treturn childLoader1.loadClass(name);\n\t\t\t}\n\t\t};\n\t\tClass<?> composite = ClassUtils.createCompositeInterface(\n\t\t\t\tnew Class<?>[] {Serializable.class, Externalizable.class}, childLoader1);\n\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, null)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, classLoader)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader2)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader3)).isTrue();\n\t}\n\n\t@ParameterizedTest(name = \"''{0}'' -> {1}\")\n\t@CsvSource(textBlock = \"\"\"\n\t\tboolean, boolean\n\t\tbyte, byte\n\t\tchar, char\n\t\tshort, short\n\t\tint, int\n\t\tlong, long\n\t\tfloat, float\n\t\tdouble, double\n\t\t[Z, boolean[]\n\t\t[B, byte[]\n\t\t[C, char[]\n\t\t[S, short[]\n\t\t[I, int[]\n\t\t[J, long[]\n\t\t[F, float[]\n\t\t[D, double[]\n\t\t\"\"\")\n\tvoid resolvePrimitiveClassName(String input, Class<?> output) {\n\t\tassertThat(ClassUtils.resolvePrimitiveClassName(input)).isEqualTo(output);\n\t}\n\n\t@Test\n\tvoid getShortName() {\n\t\tString className = ClassUtils.getShortName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getShortNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[][][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForNestedClass() {\n\t\tString className = ClassUtils.getShortName(NestedClass.class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests.NestedClass\");\n\t}\n\n\t@Test\n\tvoid getShortNameAsProperty() {\n\t\tString shortName = ClassUtils.getShortNameAsProperty(this.getClass());\n\t\tassertThat(shortName).as(\"Class name did not match\").isEqualTo(\"classUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getClassFileName() {\n\t\tassertThat(ClassUtils.getClassFileName(String.class)).isEqualTo(\"String.class\");\n\t\tassertThat(ClassUtils.getClassFileName(getClass())).isEqualTo(\"ClassUtilsTests.class\");\n\t}\n\n\t@Test\n\tvoid getPackageName() {\n\t\tassertThat(ClassUtils.getPackageName(String.class)).isEqualTo(\"java.lang\");\n\t\tassertThat(ClassUtils.getPackageName(getClass())).isEqualTo(getClass().getPackage().getName());\n\t}\n\n\t@Test\n\tvoid getQualifiedName() {\n\t\tString className = ClassUtils.getQualifiedName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"org.springframework.util.ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[][]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][]\");\n\t}\n\n\t@Test\n\tvoid hasMethod() {\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"size\")).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\", Object.class)).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\")).isFalse();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"someOtherMethod\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getMethodIfAvailable() {\n\t\tMethod method = ClassUtils.getMethodIfAvailable(Collection.class, \"size\");\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"size\");\n\n\t\tmethod = ClassUtils.getMethodIfAvailable(Collection.class, \"remove\", Object.class);\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"remove\");\n\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"remove\")).isNull();\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"someOtherMethod\")).isNull();\n\t}\n\n\t@Test\n\tvoid getMethodCountForName() {\n\t\tassertThat(ClassUtils.getMethodCountForName(OverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for OverloadedMethodsClass.\").isEqualTo(2);\n\t\tassertThat(ClassUtils.getMethodCountForName(SubOverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for SubOverloadedMethodsClass.\").isEqualTo(4);\n\t}\n\n\t@Test\n\tvoid countOverloadedMethods() {\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"foobar\")).isFalse();\n\t\t// no args\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"hashCode\")).isTrue();\n\t\t// matches although it takes an arg\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"setAge\")).isTrue();\n\t}\n\n\t@Test\n\tvoid isAssignable() {\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Object.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(int.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, Object.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, Number.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, double.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(double.class, Integer.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid classPackageAsResourcePath() {\n\t\tString result = ClassUtils.classPackageAsResourcePath(Proxy.class);\n\t\tassertThat(result).isEqualTo(\"java/lang/reflect\");\n\t}\n\n\t@Test\n\tvoid addResourcePathToPackagePath() {\n\t\tString result = \"java/lang/reflect/xyzabc.xml\";\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"xyzabc.xml\")).isEqualTo(result);\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"/xyzabc.xml\")).isEqualTo(result);\n\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"a/b/c/d.xml\")).isEqualTo(\"java/lang/reflect/a/b/c/d.xml\");\n\t}\n\n\t@Test\n\tvoid getAllInterfaces() {\n\t\tDerivedTestObject testBean = new DerivedTestObject();\n\t\tList<Class<?>> ifcs = Arrays.asList(ClassUtils.getAllInterfaces(testBean));\n\t\tassertThat(ifcs).as(\"Correct number of interfaces\").hasSize(4);\n\t\tassertThat(ifcs.contains(Serializable.class)).as(\"Contains Serializable\").isTrue();\n\t\tassertThat(ifcs.contains(ITestObject.class)).as(\"Contains ITestBean\").isTrue();\n\t\tassertThat(ifcs.contains(ITestInterface.class)).as(\"Contains IOther\").isTrue();\n\t}\n\n\t@Test\n\tvoid classNamesToString() {\n\t\tList<Class<?>> ifcs = new ArrayList<>();\n\t\tifcs.add(Serializable.class);\n\t\tifcs.add(Runnable.class);\n\t\tassertThat(ifcs.toString()).isEqualTo(\"[interface java.io.Serializable, interface java.lang.Runnable]\");\n\t\tassertThat(ClassUtils.classNamesToString(ifcs)).isEqualTo(\"[java.io.Serializable, java.lang.Runnable]\");\n\n\t\tList<Class<?>> classes = new ArrayList<>();\n\t\tclasses.add(ArrayList.class);\n\t\tclasses.add(Integer.class);\n\t\tassertThat(classes.toString()).isEqualTo(\"[class java.util.ArrayList, class java.lang.Integer]\");\n\t\tassertThat(ClassUtils.classNamesToString(classes)).isEqualTo(\"[java.util.ArrayList, java.lang.Integer]\");\n\n\t\tassertThat(Collections.singletonList(List.class).toString()).isEqualTo(\"[interface java.util.List]\");\n\t\tassertThat(ClassUtils.classNamesToString(List.class)).isEqualTo(\"[java.util.List]\");\n\n\t\tassertThat(Collections.EMPTY_LIST.toString()).isEqualTo(\"[]\");\n\t\tassertThat(ClassUtils.classNamesToString(Collections.emptyList())).isEqualTo(\"[]\");\n\t}\n\n\t@Test\n\tvoid determineCommonAncestor() {\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Number.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, null)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, Integer.class)).isEqualTo(Integer.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Integer.class)).isEqualTo(Integer.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Float.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Float.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, Integer.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Collection.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, List.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, null)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, List.class)).isEqualTo(List.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Set.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Set.class, List.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Runnable.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Runnable.class, List.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, ArrayList.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(ArrayList.class, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, List.class)).isNull();\n\t}\n\n\t@Test\n\tvoid getMostSpecificMethod() throws NoSuchMethodException {\n\t\tMethod defaultPrintMethod = ClassUtils.getMethod(MethodsInterface.class, \"defaultPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\n\t\tMethod printMethod = ClassUtils.getMethod(MethodsInterface.class, \"print\", String.class);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isNotEqualTo(printMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\n\t\tMethod protectedPrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(protectedPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(SubMethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\"));\n\n\t\tMethod packageAccessiblePrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"packageAccessiblePrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(packageAccessiblePrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(SubMethodsInterfaceImplementation.class, \"packageAccessiblePrint\"));\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@PrimitiveTypes\n\tvoid isPrimitiveOrWrapperWithPrimitive(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveOrWrapperWithWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@Test\n\tvoid isLambda() {\n\t\tassertIsLambda(ClassUtilsTests.staticLambdaExpression);\n\t\tassertIsLambda(ClassUtilsTests::staticStringFactory);\n\n\t\tassertIsLambda(this.instanceLambdaExpression);\n\t\tassertIsLambda(this::instanceStringFactory);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"Convert2Lambda\")\n\tvoid isNotLambda() {\n\t\tassertIsNotLambda(new EnigmaSupplier());\n\n\t\tassertIsNotLambda(new Supplier<>() {\n\t\t\t@Override\n\t\t\tpublic String get() {\n\t\t\t\treturn \"anonymous inner class\";\n\t\t\t}\n\t\t});\n\n\t\tassertIsNotLambda(new Fake$$LambdaSupplier());\n\t}\n\n\n\t@Nested\n\tclass GetStaticMethodTests {\n\n\t\t@BeforeEach\n\t\tvoid clearStatics() {\n\t\t\tNestedClass.noArgCalled = false;\n\t\t\tNestedClass.argCalled = false;\n\t\t\tNestedClass.overloadedCalled = false;\n\t\t}\n\n\t\t@Test\n\t\tvoid noArgsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\");\n\t\t\tmethod.invoke(null, (Object[]) null);\n\t\t\tassertThat(NestedClass.noArgCalled).as(\"no argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid argsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"argStaticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.argCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid overloadedStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.overloadedCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t}\n\n\n\t@Nested  // gh-33216\n\tclass GetPubliclyAccessibleMethodTests {\n\n\t\t@Test\n\t\tvoid nonPublicMethod(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(originalMethod);\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\t// This method is intentionally public.\n\t\tpublic void publicMethodInNonPublicType(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = String.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = ArrayList.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"size\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in List.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaLangObjectDeclaredInNonPublicType() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Object.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"toString\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaTimeZoneIdDeclaredInNonPublicSubclass() throws Exception {\n\t\t\t// Returns a package-private java.time.ZoneRegion.\n\t\t\tZoneId zoneId = ZoneId.of(\"CET\");\n\t\t\tClass<?> targetClass = zoneId.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getDeclaredMethod(\"getId\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(ZoneId.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getId\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodDeclaredInNonPublicTypeWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\n\t\t\tHashMap<String, String> hashMap = new HashMap<>();\n\t\t\t// Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\n\t\t\t// which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\n\t\t\t// implements HashIterator.\n\t\t\tIterator<String> iterator = hashMap.keySet().iterator();\n\t\t\tClass<?> targetClass = iterator.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"hasNext\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, targetClass);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Iterator.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"hasNext\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getText\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in PrivateInterface.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getMessage\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getNumber\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getNumber\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"contains\", Object.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Collection.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"contains\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(Object.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"greet\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(String.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"process\", int.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"process\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(int.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\tprivate static void assertPubliclyAccessible(Method method) {\n\t\t\tassertPublic(method);\n\t\t\tassertPublic(method.getDeclaringClass());\n\t\t}\n\n\t\tprivate static void assertNotPubliclyAccessible(Method method) {\n\t\t\tassertThat(!isPublic(method) || !isPublic(method.getDeclaringClass()))\n\t\t\t\t\t.as(\"%s must not be publicly accessible\", method)\n\t\t\t\t\t.isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Member member) {\n\t\t\tassertThat(isPublic(member)).as(\"%s must be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Class<?> clazz) {\n\t\t\tassertThat(isPublic(clazz)).as(\"%s must be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Member member) {\n\t\t\tassertThat(!isPublic(member)).as(\"%s must be not be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Class<?> clazz) {\n\t\t\tassertThat(!isPublic(clazz)).as(\"%s must be not be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static boolean isPublic(Class<?> clazz) {\n\t\t\treturn Modifier.isPublic(clazz.getModifiers());\n\t\t}\n\n\t\tprivate static boolean isPublic(Member member) {\n\t\t\treturn Modifier.isPublic(member.getModifiers());\n\t\t}\n\n\t\tprivate interface PrivateInterface {\n\n\t\t\tString getMessage();\n\n\t\t\tString greet(String name);\n\t\t}\n\n\t\tprivate static class PrivateSubclass extends PublicSuperclass implements PublicInterface, PrivateInterface {\n\n\t\t\t@Override\n\t\t\tpublic int getNumber() {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getMessage() {\n\t\t\t\treturn \"hello\";\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String greet(String name) {\n\t\t\t\treturn \"Hello, \" + name;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int process(int num) {\n\t\t\t\treturn num * 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getText() {\n\t\t\t\treturn \"enigma\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { Boolean.class, Character.class, Byte.class, Short.class,\n\t\tInteger.class, Long.class, Float.class, Double.class, Void.class })\n\t@interface WrapperTypes {\n\t}\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { boolean.class, char.class, byte.class, short.class,\n\t\tint.class, long.class, float.class, double.class, void.class })\n\t@interface PrimitiveTypes {\n\t}\n\n\tpublic static class NestedClass {\n\n\t\tstatic boolean noArgCalled;\n\t\tstatic boolean argCalled;\n\t\tstatic boolean overloadedCalled;\n\n\t\tpublic static void staticMethod() {\n\t\t\tnoArgCalled = true;\n\t\t}\n\n\t\tpublic static void staticMethod(String anArg) {\n\t\t\toverloadedCalled = true;\n\t\t}\n\n\t\tpublic static void argStaticMethod(String anArg) {\n\t\t\targCalled = true;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class OverloadedMethodsClass {\n\n\t\tpublic void print(String messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tpublic void print(String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class SubOverloadedMethodsClass extends OverloadedMethodsClass {\n\n\t\tpublic void print(String header, String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tvoid print(String header, String[] messages, String footer) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\tprivate static void assertIsLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isTrue();\n\t}\n\n\tprivate static void assertIsNotLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isFalse();\n\t}\n\n\tprivate static final Supplier<String> staticLambdaExpression = () -> \"static lambda expression\";\n\n\tprivate final Supplier<String> instanceLambdaExpression = () -> \"instance lambda expressions\";\n\n\tprivate static String staticStringFactory() {\n\t\treturn \"static string factory\";\n\t}\n\n\tprivate String instanceStringFactory() {\n\t\treturn \"instance string factory\";\n\t}\n\n\tprivate static class EnigmaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"enigma\";\n\t\t}\n\t}\n\n\tprivate static class Fake$$LambdaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"fake lambda\";\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate interface MethodsInterface {\n\n\t\tdefault void defaultPrint() {\n\n\t\t}\n\n\t\tvoid print(String messages);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class MethodsInterfaceImplementation implements MethodsInterface {\n\n\t\t@Override\n\t\tpublic void print(String message) {\n\n\t\t}\n\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\tvoid packageAccessiblePrint() {\n\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class SubMethodsInterfaceImplementation extends MethodsInterfaceImplementation {\n\n\t\t@Override\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\t@Override\n\t\tpublic void packageAccessiblePrint() {\n\n\t\t}\n\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "iterationData": [],
            "targetClassMap": {}
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "url": "https://github.com/spring-projects/spring-framework/commit/ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private isPublic(clazz Class<?>) : boolean from class org.springframework.util.ClassUtilsTests.GetPubliclyAccessibleMethodTests to private isPublic(clazz Class<?>) : boolean from class org.springframework.util.ClassUtilsTests",
            "leftSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 738,
                    "endLine": 740,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private isPublic(clazz Class<?>) : boolean"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 897,
                    "endLine": 899,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "private isPublic(clazz Class<?>) : boolean"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "5f09b383-079e-4a7e-af48-b51f954de7b8",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 861,
                "lineStart": 57,
                "lineEnd": 917,
                "bodyLineStart": 57,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                "sourceCode": "/**\n * Tests for {@link ClassUtils}.\n *\n * @author Colin Sampaleanu\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rick Evans\n * @author Sam Brannen\n */\nclass ClassUtilsTests {\n\n\tprivate final ClassLoader classLoader = getClass().getClassLoader();\n\n\n\t@Test\n\tvoid isPresent() {\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.String\", classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.MySpecialString\", classLoader)).isFalse();\n\t}\n\n\t@Test\n\tvoid forName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"java.lang.String\", classLoader)).isEqualTo(String.class);\n\t\tassertThat(ClassUtils.forName(\"java.lang.String[]\", classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[].class.getName(), classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[][].class.getName(), classLoader)).isEqualTo(String[][].class);\n\t\tassertThat(ClassUtils.forName(String[][][].class.getName(), classLoader)).isEqualTo(String[][][].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject\", classLoader)).isEqualTo(TestObject.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[]\", classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(TestObject[].class.getName(), classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[][]\", classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(TestObject[][].class.getName(), classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(\"[[[S\", classLoader)).isEqualTo(short[][][].class);\n\t}\n\n\t@Test\n\tvoid forNameWithNestedType() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests$NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests.NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\n\t\t// Precondition: package name must have length == 1.\n\t\tassertThat(ClassHavingNestedClass.class.getPackageName().length()).isEqualTo(1);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass$NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass.NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveClasses() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean\", classLoader)).isEqualTo(boolean.class);\n\t\tassertThat(ClassUtils.forName(\"byte\", classLoader)).isEqualTo(byte.class);\n\t\tassertThat(ClassUtils.forName(\"char\", classLoader)).isEqualTo(char.class);\n\t\tassertThat(ClassUtils.forName(\"short\", classLoader)).isEqualTo(short.class);\n\t\tassertThat(ClassUtils.forName(\"int\", classLoader)).isEqualTo(int.class);\n\t\tassertThat(ClassUtils.forName(\"long\", classLoader)).isEqualTo(long.class);\n\t\tassertThat(ClassUtils.forName(\"float\", classLoader)).isEqualTo(float.class);\n\t\tassertThat(ClassUtils.forName(\"double\", classLoader)).isEqualTo(double.class);\n\t\tassertThat(ClassUtils.forName(\"void\", classLoader)).isEqualTo(void.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArrays() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean[]\", classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(\"byte[]\", classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(\"char[]\", classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(\"short[]\", classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(\"int[]\", classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(\"long[]\", classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(\"float[]\", classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(\"double[]\", classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArraysInternalName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(boolean[].class.getName(), classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(byte[].class.getName(), classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(char[].class.getName(), classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(short[].class.getName(), classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(int[].class.getName(), classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(long[].class.getName(), classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(float[].class.getName(), classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(double[].class.getName(), classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid isCacheSafe() {\n\t\tClassLoader childLoader1 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader2 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader3 = new ClassLoader(classLoader) {\n\t\t\t@Override\n\t\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\t\t\treturn childLoader1.loadClass(name);\n\t\t\t}\n\t\t};\n\t\tClass<?> composite = ClassUtils.createCompositeInterface(\n\t\t\t\tnew Class<?>[] {Serializable.class, Externalizable.class}, childLoader1);\n\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, null)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, classLoader)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader2)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader3)).isTrue();\n\t}\n\n\t@ParameterizedTest(name = \"''{0}'' -> {1}\")\n\t@CsvSource(textBlock = \"\"\"\n\t\tboolean, boolean\n\t\tbyte, byte\n\t\tchar, char\n\t\tshort, short\n\t\tint, int\n\t\tlong, long\n\t\tfloat, float\n\t\tdouble, double\n\t\t[Z, boolean[]\n\t\t[B, byte[]\n\t\t[C, char[]\n\t\t[S, short[]\n\t\t[I, int[]\n\t\t[J, long[]\n\t\t[F, float[]\n\t\t[D, double[]\n\t\t\"\"\")\n\tvoid resolvePrimitiveClassName(String input, Class<?> output) {\n\t\tassertThat(ClassUtils.resolvePrimitiveClassName(input)).isEqualTo(output);\n\t}\n\n\t@Test\n\tvoid getShortName() {\n\t\tString className = ClassUtils.getShortName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getShortNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[][][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForNestedClass() {\n\t\tString className = ClassUtils.getShortName(NestedClass.class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests.NestedClass\");\n\t}\n\n\t@Test\n\tvoid getShortNameAsProperty() {\n\t\tString shortName = ClassUtils.getShortNameAsProperty(this.getClass());\n\t\tassertThat(shortName).as(\"Class name did not match\").isEqualTo(\"classUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getClassFileName() {\n\t\tassertThat(ClassUtils.getClassFileName(String.class)).isEqualTo(\"String.class\");\n\t\tassertThat(ClassUtils.getClassFileName(getClass())).isEqualTo(\"ClassUtilsTests.class\");\n\t}\n\n\t@Test\n\tvoid getPackageName() {\n\t\tassertThat(ClassUtils.getPackageName(String.class)).isEqualTo(\"java.lang\");\n\t\tassertThat(ClassUtils.getPackageName(getClass())).isEqualTo(getClass().getPackage().getName());\n\t}\n\n\t@Test\n\tvoid getQualifiedName() {\n\t\tString className = ClassUtils.getQualifiedName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"org.springframework.util.ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[][]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][]\");\n\t}\n\n\t@Test\n\tvoid hasMethod() {\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"size\")).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\", Object.class)).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\")).isFalse();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"someOtherMethod\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getMethodIfAvailable() {\n\t\tMethod method = ClassUtils.getMethodIfAvailable(Collection.class, \"size\");\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"size\");\n\n\t\tmethod = ClassUtils.getMethodIfAvailable(Collection.class, \"remove\", Object.class);\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"remove\");\n\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"remove\")).isNull();\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"someOtherMethod\")).isNull();\n\t}\n\n\t@Test\n\tvoid getMethodCountForName() {\n\t\tassertThat(ClassUtils.getMethodCountForName(OverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for OverloadedMethodsClass.\").isEqualTo(2);\n\t\tassertThat(ClassUtils.getMethodCountForName(SubOverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for SubOverloadedMethodsClass.\").isEqualTo(4);\n\t}\n\n\t@Test\n\tvoid countOverloadedMethods() {\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"foobar\")).isFalse();\n\t\t// no args\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"hashCode\")).isTrue();\n\t\t// matches although it takes an arg\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"setAge\")).isTrue();\n\t}\n\n\t@Test\n\tvoid isAssignable() {\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Object.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(int.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, Object.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, Number.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, double.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(double.class, Integer.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid classPackageAsResourcePath() {\n\t\tString result = ClassUtils.classPackageAsResourcePath(Proxy.class);\n\t\tassertThat(result).isEqualTo(\"java/lang/reflect\");\n\t}\n\n\t@Test\n\tvoid addResourcePathToPackagePath() {\n\t\tString result = \"java/lang/reflect/xyzabc.xml\";\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"xyzabc.xml\")).isEqualTo(result);\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"/xyzabc.xml\")).isEqualTo(result);\n\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"a/b/c/d.xml\")).isEqualTo(\"java/lang/reflect/a/b/c/d.xml\");\n\t}\n\n\t@Test\n\tvoid getAllInterfaces() {\n\t\tDerivedTestObject testBean = new DerivedTestObject();\n\t\tList<Class<?>> ifcs = Arrays.asList(ClassUtils.getAllInterfaces(testBean));\n\t\tassertThat(ifcs).as(\"Correct number of interfaces\").hasSize(4);\n\t\tassertThat(ifcs.contains(Serializable.class)).as(\"Contains Serializable\").isTrue();\n\t\tassertThat(ifcs.contains(ITestObject.class)).as(\"Contains ITestBean\").isTrue();\n\t\tassertThat(ifcs.contains(ITestInterface.class)).as(\"Contains IOther\").isTrue();\n\t}\n\n\t@Test\n\tvoid classNamesToString() {\n\t\tList<Class<?>> ifcs = new ArrayList<>();\n\t\tifcs.add(Serializable.class);\n\t\tifcs.add(Runnable.class);\n\t\tassertThat(ifcs.toString()).isEqualTo(\"[interface java.io.Serializable, interface java.lang.Runnable]\");\n\t\tassertThat(ClassUtils.classNamesToString(ifcs)).isEqualTo(\"[java.io.Serializable, java.lang.Runnable]\");\n\n\t\tList<Class<?>> classes = new ArrayList<>();\n\t\tclasses.add(ArrayList.class);\n\t\tclasses.add(Integer.class);\n\t\tassertThat(classes.toString()).isEqualTo(\"[class java.util.ArrayList, class java.lang.Integer]\");\n\t\tassertThat(ClassUtils.classNamesToString(classes)).isEqualTo(\"[java.util.ArrayList, java.lang.Integer]\");\n\n\t\tassertThat(Collections.singletonList(List.class).toString()).isEqualTo(\"[interface java.util.List]\");\n\t\tassertThat(ClassUtils.classNamesToString(List.class)).isEqualTo(\"[java.util.List]\");\n\n\t\tassertThat(Collections.EMPTY_LIST.toString()).isEqualTo(\"[]\");\n\t\tassertThat(ClassUtils.classNamesToString(Collections.emptyList())).isEqualTo(\"[]\");\n\t}\n\n\t@Test\n\tvoid determineCommonAncestor() {\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Number.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, null)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, Integer.class)).isEqualTo(Integer.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Integer.class)).isEqualTo(Integer.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Float.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Float.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, Integer.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Collection.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, List.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, null)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, List.class)).isEqualTo(List.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Set.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Set.class, List.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Runnable.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Runnable.class, List.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, ArrayList.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(ArrayList.class, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, List.class)).isNull();\n\t}\n\n\t@Test\n\tvoid getMostSpecificMethod() throws NoSuchMethodException {\n\t\tMethod defaultPrintMethod = ClassUtils.getMethod(MethodsInterface.class, \"defaultPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\n\t\tMethod printMethod = ClassUtils.getMethod(MethodsInterface.class, \"print\", String.class);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isNotEqualTo(printMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\n\t\tMethod protectedPrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(protectedPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(SubMethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\"));\n\n\t\tMethod packageAccessiblePrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"packageAccessiblePrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(packageAccessiblePrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(SubMethodsInterfaceImplementation.class, \"packageAccessiblePrint\"));\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@PrimitiveTypes\n\tvoid isPrimitiveOrWrapperWithPrimitive(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveOrWrapperWithWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@Test\n\tvoid isLambda() {\n\t\tassertIsLambda(ClassUtilsTests.staticLambdaExpression);\n\t\tassertIsLambda(ClassUtilsTests::staticStringFactory);\n\n\t\tassertIsLambda(this.instanceLambdaExpression);\n\t\tassertIsLambda(this::instanceStringFactory);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"Convert2Lambda\")\n\tvoid isNotLambda() {\n\t\tassertIsNotLambda(new EnigmaSupplier());\n\n\t\tassertIsNotLambda(new Supplier<>() {\n\t\t\t@Override\n\t\t\tpublic String get() {\n\t\t\t\treturn \"anonymous inner class\";\n\t\t\t}\n\t\t});\n\n\t\tassertIsNotLambda(new Fake$$LambdaSupplier());\n\t}\n\n\n\t@Nested\n\tclass GetStaticMethodTests {\n\n\t\t@BeforeEach\n\t\tvoid clearStatics() {\n\t\t\tNestedClass.noArgCalled = false;\n\t\t\tNestedClass.argCalled = false;\n\t\t\tNestedClass.overloadedCalled = false;\n\t\t}\n\n\t\t@Test\n\t\tvoid noArgsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\");\n\t\t\tmethod.invoke(null, (Object[]) null);\n\t\t\tassertThat(NestedClass.noArgCalled).as(\"no argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid argsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"argStaticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.argCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid overloadedStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.overloadedCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t}\n\n\n\t@Nested  // gh-33216\n\tclass GetPubliclyAccessibleMethodTests {\n\n\t\t@Test\n\t\tvoid nonPublicMethod(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(originalMethod);\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\t// This method is intentionally public.\n\t\tpublic void publicMethodInNonPublicType(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = String.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = ArrayList.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"size\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in List.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaLangObjectDeclaredInNonPublicType() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Object.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"toString\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaTimeZoneIdDeclaredInNonPublicSubclass() throws Exception {\n\t\t\t// Returns a package-private java.time.ZoneRegion.\n\t\t\tZoneId zoneId = ZoneId.of(\"CET\");\n\t\t\tClass<?> targetClass = zoneId.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getDeclaredMethod(\"getId\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(ZoneId.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getId\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodDeclaredInNonPublicTypeWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\n\t\t\tHashMap<String, String> hashMap = new HashMap<>();\n\t\t\t// Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\n\t\t\t// which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\n\t\t\t// implements HashIterator.\n\t\t\tIterator<String> iterator = hashMap.keySet().iterator();\n\t\t\tClass<?> targetClass = iterator.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"hasNext\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, targetClass);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Iterator.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"hasNext\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getText\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in PrivateInterface.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getMessage\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getNumber\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getNumber\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"contains\", Object.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Collection.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"contains\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(Object.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"greet\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(String.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"process\", int.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"process\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(int.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\tprivate static void assertPubliclyAccessible(Method method) {\n\t\t\tassertPublic(method);\n\t\t\tassertPublic(method.getDeclaringClass());\n\t\t}\n\n\t\tprivate static void assertNotPubliclyAccessible(Method method) {\n\t\t\tassertThat(!isPublic(method) || !isPublic(method.getDeclaringClass()))\n\t\t\t\t\t.as(\"%s must not be publicly accessible\", method)\n\t\t\t\t\t.isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Member member) {\n\t\t\tassertThat(isPublic(member)).as(\"%s must be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Class<?> clazz) {\n\t\t\tassertThat(isPublic(clazz)).as(\"%s must be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Member member) {\n\t\t\tassertThat(!isPublic(member)).as(\"%s must be not be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Class<?> clazz) {\n\t\t\tassertThat(!isPublic(clazz)).as(\"%s must be not be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static boolean isPublic(Class<?> clazz) {\n\t\t\treturn Modifier.isPublic(clazz.getModifiers());\n\t\t}\n\n\t\tprivate static boolean isPublic(Member member) {\n\t\t\treturn Modifier.isPublic(member.getModifiers());\n\t\t}\n\n\t\tprivate interface PrivateInterface {\n\n\t\t\tString getMessage();\n\n\t\t\tString greet(String name);\n\t\t}\n\n\t\tprivate static class PrivateSubclass extends PublicSuperclass implements PublicInterface, PrivateInterface {\n\n\t\t\t@Override\n\t\t\tpublic int getNumber() {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getMessage() {\n\t\t\t\treturn \"hello\";\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String greet(String name) {\n\t\t\t\treturn \"Hello, \" + name;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int process(int num) {\n\t\t\t\treturn num * 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getText() {\n\t\t\t\treturn \"enigma\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { Boolean.class, Character.class, Byte.class, Short.class,\n\t\tInteger.class, Long.class, Float.class, Double.class, Void.class })\n\t@interface WrapperTypes {\n\t}\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { boolean.class, char.class, byte.class, short.class,\n\t\tint.class, long.class, float.class, double.class, void.class })\n\t@interface PrimitiveTypes {\n\t}\n\n\tpublic static class NestedClass {\n\n\t\tstatic boolean noArgCalled;\n\t\tstatic boolean argCalled;\n\t\tstatic boolean overloadedCalled;\n\n\t\tpublic static void staticMethod() {\n\t\t\tnoArgCalled = true;\n\t\t}\n\n\t\tpublic static void staticMethod(String anArg) {\n\t\t\toverloadedCalled = true;\n\t\t}\n\n\t\tpublic static void argStaticMethod(String anArg) {\n\t\t\targCalled = true;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class OverloadedMethodsClass {\n\n\t\tpublic void print(String messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tpublic void print(String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class SubOverloadedMethodsClass extends OverloadedMethodsClass {\n\n\t\tpublic void print(String header, String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tvoid print(String header, String[] messages, String footer) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\tprivate static void assertIsLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isTrue();\n\t}\n\n\tprivate static void assertIsNotLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isFalse();\n\t}\n\n\tprivate static final Supplier<String> staticLambdaExpression = () -> \"static lambda expression\";\n\n\tprivate final Supplier<String> instanceLambdaExpression = () -> \"instance lambda expressions\";\n\n\tprivate static String staticStringFactory() {\n\t\treturn \"static string factory\";\n\t}\n\n\tprivate String instanceStringFactory() {\n\t\treturn \"instance string factory\";\n\t}\n\n\tprivate static class EnigmaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"enigma\";\n\t\t}\n\t}\n\n\tprivate static class Fake$$LambdaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"fake lambda\";\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate interface MethodsInterface {\n\n\t\tdefault void defaultPrint() {\n\n\t\t}\n\n\t\tvoid print(String messages);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class MethodsInterfaceImplementation implements MethodsInterface {\n\n\t\t@Override\n\t\tpublic void print(String message) {\n\n\t\t}\n\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\tvoid packageAccessiblePrint() {\n\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class SubMethodsInterfaceImplementation extends MethodsInterfaceImplementation {\n\n\t\t@Override\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\t@Override\n\t\tpublic void packageAccessiblePrint() {\n\n\t\t}\n\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "iterationData": [],
            "targetClassMap": {}
        }
    },
    {
        "repository": "https://github.com/spring-projects/spring-framework.git",
        "sha1": "ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "url": "https://github.com/spring-projects/spring-framework/commit/ba774c6290cf5a91329ed68e1ea60d0904bedbb4",
        "move_method_refactoring": {
            "type": "Move Method",
            "description": "Move Method private isPublic(member Member) : boolean from class org.springframework.util.ClassUtilsTests.GetPubliclyAccessibleMethodTests to private isPublic(member Member) : boolean from class org.springframework.util.ClassUtilsTests",
            "leftSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 742,
                    "endLine": 744,
                    "startColumn": 3,
                    "endColumn": 4,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "original method declaration",
                    "codeElement": "private isPublic(member Member) : boolean"
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                    "startLine": 901,
                    "endLine": 903,
                    "startColumn": 2,
                    "endColumn": 3,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "moved method declaration",
                    "codeElement": "private isPublic(member Member) : boolean"
                }
            ],
            "isStatic": true
        },
        "telemetry": {
            "id": "5f09b383-079e-4a7e-af48-b51f954de7b8",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 861,
                "lineStart": 57,
                "lineEnd": 917,
                "bodyLineStart": 57,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/spring-framework/spring-core/src/test/java/org/springframework/util/ClassUtilsTests.java",
                "sourceCode": "/**\n * Tests for {@link ClassUtils}.\n *\n * @author Colin Sampaleanu\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Rick Evans\n * @author Sam Brannen\n */\nclass ClassUtilsTests {\n\n\tprivate final ClassLoader classLoader = getClass().getClassLoader();\n\n\n\t@Test\n\tvoid isPresent() {\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.String\", classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isPresent(\"java.lang.MySpecialString\", classLoader)).isFalse();\n\t}\n\n\t@Test\n\tvoid forName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"java.lang.String\", classLoader)).isEqualTo(String.class);\n\t\tassertThat(ClassUtils.forName(\"java.lang.String[]\", classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[].class.getName(), classLoader)).isEqualTo(String[].class);\n\t\tassertThat(ClassUtils.forName(String[][].class.getName(), classLoader)).isEqualTo(String[][].class);\n\t\tassertThat(ClassUtils.forName(String[][][].class.getName(), classLoader)).isEqualTo(String[][][].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject\", classLoader)).isEqualTo(TestObject.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[]\", classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(TestObject[].class.getName(), classLoader)).isEqualTo(TestObject[].class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.tests.sample.objects.TestObject[][]\", classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(TestObject[][].class.getName(), classLoader)).isEqualTo(TestObject[][].class);\n\t\tassertThat(ClassUtils.forName(\"[[[S\", classLoader)).isEqualTo(short[][][].class);\n\t}\n\n\t@Test\n\tvoid forNameWithNestedType() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests$NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"org.springframework.util.ClassUtilsTests.NestedClass\", classLoader)).isEqualTo(NestedClass.class);\n\n\t\t// Precondition: package name must have length == 1.\n\t\tassertThat(ClassHavingNestedClass.class.getPackageName().length()).isEqualTo(1);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass$NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t\tassertThat(ClassUtils.forName(\"a.ClassHavingNestedClass.NestedClass\", classLoader)).isEqualTo(ClassHavingNestedClass.NestedClass.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveClasses() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean\", classLoader)).isEqualTo(boolean.class);\n\t\tassertThat(ClassUtils.forName(\"byte\", classLoader)).isEqualTo(byte.class);\n\t\tassertThat(ClassUtils.forName(\"char\", classLoader)).isEqualTo(char.class);\n\t\tassertThat(ClassUtils.forName(\"short\", classLoader)).isEqualTo(short.class);\n\t\tassertThat(ClassUtils.forName(\"int\", classLoader)).isEqualTo(int.class);\n\t\tassertThat(ClassUtils.forName(\"long\", classLoader)).isEqualTo(long.class);\n\t\tassertThat(ClassUtils.forName(\"float\", classLoader)).isEqualTo(float.class);\n\t\tassertThat(ClassUtils.forName(\"double\", classLoader)).isEqualTo(double.class);\n\t\tassertThat(ClassUtils.forName(\"void\", classLoader)).isEqualTo(void.class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArrays() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(\"boolean[]\", classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(\"byte[]\", classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(\"char[]\", classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(\"short[]\", classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(\"int[]\", classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(\"long[]\", classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(\"float[]\", classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(\"double[]\", classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid forNameWithPrimitiveArraysInternalName() throws ClassNotFoundException {\n\t\tassertThat(ClassUtils.forName(boolean[].class.getName(), classLoader)).isEqualTo(boolean[].class);\n\t\tassertThat(ClassUtils.forName(byte[].class.getName(), classLoader)).isEqualTo(byte[].class);\n\t\tassertThat(ClassUtils.forName(char[].class.getName(), classLoader)).isEqualTo(char[].class);\n\t\tassertThat(ClassUtils.forName(short[].class.getName(), classLoader)).isEqualTo(short[].class);\n\t\tassertThat(ClassUtils.forName(int[].class.getName(), classLoader)).isEqualTo(int[].class);\n\t\tassertThat(ClassUtils.forName(long[].class.getName(), classLoader)).isEqualTo(long[].class);\n\t\tassertThat(ClassUtils.forName(float[].class.getName(), classLoader)).isEqualTo(float[].class);\n\t\tassertThat(ClassUtils.forName(double[].class.getName(), classLoader)).isEqualTo(double[].class);\n\t}\n\n\t@Test\n\tvoid isCacheSafe() {\n\t\tClassLoader childLoader1 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader2 = new ClassLoader(classLoader) {};\n\t\tClassLoader childLoader3 = new ClassLoader(classLoader) {\n\t\t\t@Override\n\t\t\tpublic Class<?> loadClass(String name) throws ClassNotFoundException {\n\t\t\t\treturn childLoader1.loadClass(name);\n\t\t\t}\n\t\t};\n\t\tClass<?> composite = ClassUtils.createCompositeInterface(\n\t\t\t\tnew Class<?>[] {Serializable.class, Externalizable.class}, childLoader1);\n\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, null)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(String.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, classLoader)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader2)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(NestedClass.class, childLoader3)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, null)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, classLoader)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader1)).isTrue();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader2)).isFalse();\n\t\tassertThat(ClassUtils.isCacheSafe(composite, childLoader3)).isTrue();\n\t}\n\n\t@ParameterizedTest(name = \"''{0}'' -> {1}\")\n\t@CsvSource(textBlock = \"\"\"\n\t\tboolean, boolean\n\t\tbyte, byte\n\t\tchar, char\n\t\tshort, short\n\t\tint, int\n\t\tlong, long\n\t\tfloat, float\n\t\tdouble, double\n\t\t[Z, boolean[]\n\t\t[B, byte[]\n\t\t[C, char[]\n\t\t[S, short[]\n\t\t[I, int[]\n\t\t[J, long[]\n\t\t[F, float[]\n\t\t[D, double[]\n\t\t\"\"\")\n\tvoid resolvePrimitiveClassName(String input, Class<?> output) {\n\t\tassertThat(ClassUtils.resolvePrimitiveClassName(input)).isEqualTo(output);\n\t}\n\n\t@Test\n\tvoid getShortName() {\n\t\tString className = ClassUtils.getShortName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getShortNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getShortName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"Object[][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getShortName(byte[][][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][][]\");\n\t}\n\n\t@Test\n\tvoid getShortNameForNestedClass() {\n\t\tString className = ClassUtils.getShortName(NestedClass.class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"ClassUtilsTests.NestedClass\");\n\t}\n\n\t@Test\n\tvoid getShortNameAsProperty() {\n\t\tString shortName = ClassUtils.getShortNameAsProperty(this.getClass());\n\t\tassertThat(shortName).as(\"Class name did not match\").isEqualTo(\"classUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getClassFileName() {\n\t\tassertThat(ClassUtils.getClassFileName(String.class)).isEqualTo(\"String.class\");\n\t\tassertThat(ClassUtils.getClassFileName(getClass())).isEqualTo(\"ClassUtilsTests.class\");\n\t}\n\n\t@Test\n\tvoid getPackageName() {\n\t\tassertThat(ClassUtils.getPackageName(String.class)).isEqualTo(\"java.lang\");\n\t\tassertThat(ClassUtils.getPackageName(getClass())).isEqualTo(getClass().getPackage().getName());\n\t}\n\n\t@Test\n\tvoid getQualifiedName() {\n\t\tString className = ClassUtils.getQualifiedName(getClass());\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"org.springframework.util.ClassUtilsTests\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalObjectArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(Object[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"java.lang.Object[][]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[]\");\n\t}\n\n\t@Test\n\tvoid getQualifiedNameForMultiDimensionalPrimitiveArrayClass() {\n\t\tString className = ClassUtils.getQualifiedName(byte[][].class);\n\t\tassertThat(className).as(\"Class name did not match\").isEqualTo(\"byte[][]\");\n\t}\n\n\t@Test\n\tvoid hasMethod() {\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"size\")).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\", Object.class)).isTrue();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"remove\")).isFalse();\n\t\tassertThat(ClassUtils.hasMethod(Collection.class, \"someOtherMethod\")).isFalse();\n\t}\n\n\t@Test\n\tvoid getMethodIfAvailable() {\n\t\tMethod method = ClassUtils.getMethodIfAvailable(Collection.class, \"size\");\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"size\");\n\n\t\tmethod = ClassUtils.getMethodIfAvailable(Collection.class, \"remove\", Object.class);\n\t\tassertThat(method).isNotNull();\n\t\tassertThat(method.getName()).isEqualTo(\"remove\");\n\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"remove\")).isNull();\n\t\tassertThat(ClassUtils.getMethodIfAvailable(Collection.class, \"someOtherMethod\")).isNull();\n\t}\n\n\t@Test\n\tvoid getMethodCountForName() {\n\t\tassertThat(ClassUtils.getMethodCountForName(OverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for OverloadedMethodsClass.\").isEqualTo(2);\n\t\tassertThat(ClassUtils.getMethodCountForName(SubOverloadedMethodsClass.class, \"print\")).as(\"Verifying number of overloaded 'print' methods for SubOverloadedMethodsClass.\").isEqualTo(4);\n\t}\n\n\t@Test\n\tvoid countOverloadedMethods() {\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"foobar\")).isFalse();\n\t\t// no args\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"hashCode\")).isTrue();\n\t\t// matches although it takes an arg\n\t\tassertThat(ClassUtils.hasAtLeastOneMethodWithName(TestObject.class, \"setAge\")).isTrue();\n\t}\n\n\t@Test\n\tvoid isAssignable() {\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Object.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, String.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Object.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Number.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, int.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(int.class, Integer.class)).isTrue();\n\t\tassertThat(ClassUtils.isAssignable(String.class, Object.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, Number.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(Integer.class, double.class)).isFalse();\n\t\tassertThat(ClassUtils.isAssignable(double.class, Integer.class)).isFalse();\n\t}\n\n\t@Test\n\tvoid classPackageAsResourcePath() {\n\t\tString result = ClassUtils.classPackageAsResourcePath(Proxy.class);\n\t\tassertThat(result).isEqualTo(\"java/lang/reflect\");\n\t}\n\n\t@Test\n\tvoid addResourcePathToPackagePath() {\n\t\tString result = \"java/lang/reflect/xyzabc.xml\";\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"xyzabc.xml\")).isEqualTo(result);\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"/xyzabc.xml\")).isEqualTo(result);\n\n\t\tassertThat(ClassUtils.addResourcePathToPackagePath(Proxy.class, \"a/b/c/d.xml\")).isEqualTo(\"java/lang/reflect/a/b/c/d.xml\");\n\t}\n\n\t@Test\n\tvoid getAllInterfaces() {\n\t\tDerivedTestObject testBean = new DerivedTestObject();\n\t\tList<Class<?>> ifcs = Arrays.asList(ClassUtils.getAllInterfaces(testBean));\n\t\tassertThat(ifcs).as(\"Correct number of interfaces\").hasSize(4);\n\t\tassertThat(ifcs.contains(Serializable.class)).as(\"Contains Serializable\").isTrue();\n\t\tassertThat(ifcs.contains(ITestObject.class)).as(\"Contains ITestBean\").isTrue();\n\t\tassertThat(ifcs.contains(ITestInterface.class)).as(\"Contains IOther\").isTrue();\n\t}\n\n\t@Test\n\tvoid classNamesToString() {\n\t\tList<Class<?>> ifcs = new ArrayList<>();\n\t\tifcs.add(Serializable.class);\n\t\tifcs.add(Runnable.class);\n\t\tassertThat(ifcs.toString()).isEqualTo(\"[interface java.io.Serializable, interface java.lang.Runnable]\");\n\t\tassertThat(ClassUtils.classNamesToString(ifcs)).isEqualTo(\"[java.io.Serializable, java.lang.Runnable]\");\n\n\t\tList<Class<?>> classes = new ArrayList<>();\n\t\tclasses.add(ArrayList.class);\n\t\tclasses.add(Integer.class);\n\t\tassertThat(classes.toString()).isEqualTo(\"[class java.util.ArrayList, class java.lang.Integer]\");\n\t\tassertThat(ClassUtils.classNamesToString(classes)).isEqualTo(\"[java.util.ArrayList, java.lang.Integer]\");\n\n\t\tassertThat(Collections.singletonList(List.class).toString()).isEqualTo(\"[interface java.util.List]\");\n\t\tassertThat(ClassUtils.classNamesToString(List.class)).isEqualTo(\"[java.util.List]\");\n\n\t\tassertThat(Collections.EMPTY_LIST.toString()).isEqualTo(\"[]\");\n\t\tassertThat(ClassUtils.classNamesToString(Collections.emptyList())).isEqualTo(\"[]\");\n\t}\n\n\t@Test\n\tvoid determineCommonAncestor() {\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Number.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Number.class, null)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, Integer.class)).isEqualTo(Integer.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Integer.class)).isEqualTo(Integer.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, Float.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Float.class, Integer.class)).isEqualTo(Number.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Integer.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, Integer.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Collection.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, List.class)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(Collection.class, null)).isEqualTo(Collection.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(null, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, List.class)).isEqualTo(List.class);\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Set.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Set.class, List.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, Runnable.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(Runnable.class, List.class)).isNull();\n\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, ArrayList.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(ArrayList.class, List.class)).isEqualTo(List.class);\n\t\tassertThat(ClassUtils.determineCommonAncestor(List.class, String.class)).isNull();\n\t\tassertThat(ClassUtils.determineCommonAncestor(String.class, List.class)).isNull();\n\t}\n\n\t@Test\n\tvoid getMostSpecificMethod() throws NoSuchMethodException {\n\t\tMethod defaultPrintMethod = ClassUtils.getMethod(MethodsInterface.class, \"defaultPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(defaultPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(defaultPrintMethod);\n\n\t\tMethod printMethod = ClassUtils.getMethod(MethodsInterface.class, \"print\", String.class);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isNotEqualTo(printMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\t\tassertThat(ClassUtils.getMostSpecificMethod(printMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(MethodsInterfaceImplementation.class, \"print\", String.class));\n\n\t\tMethod protectedPrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(protectedPrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(protectedPrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(SubMethodsInterfaceImplementation.class.getDeclaredMethod(\"protectedPrint\"));\n\n\t\tMethod packageAccessiblePrintMethod = MethodsInterfaceImplementation.class.getDeclaredMethod(\"packageAccessiblePrint\");\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, MethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(packageAccessiblePrintMethod);\n\t\tassertThat(ClassUtils.getMostSpecificMethod(packageAccessiblePrintMethod, SubMethodsInterfaceImplementation.class))\n\t\t\t\t.isEqualTo(ClassUtils.getMethod(SubMethodsInterfaceImplementation.class, \"packageAccessiblePrint\"));\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@PrimitiveTypes\n\tvoid isPrimitiveOrWrapperWithPrimitive(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@ParameterizedTest\n\t@WrapperTypes\n\tvoid isPrimitiveOrWrapperWithWrapper(Class<?> type) {\n\t\tassertThat(ClassUtils.isPrimitiveOrWrapper(type)).isTrue();\n\t}\n\n\t@Test\n\tvoid isLambda() {\n\t\tassertIsLambda(ClassUtilsTests.staticLambdaExpression);\n\t\tassertIsLambda(ClassUtilsTests::staticStringFactory);\n\n\t\tassertIsLambda(this.instanceLambdaExpression);\n\t\tassertIsLambda(this::instanceStringFactory);\n\t}\n\n\t@Test\n\t@SuppressWarnings(\"Convert2Lambda\")\n\tvoid isNotLambda() {\n\t\tassertIsNotLambda(new EnigmaSupplier());\n\n\t\tassertIsNotLambda(new Supplier<>() {\n\t\t\t@Override\n\t\t\tpublic String get() {\n\t\t\t\treturn \"anonymous inner class\";\n\t\t\t}\n\t\t});\n\n\t\tassertIsNotLambda(new Fake$$LambdaSupplier());\n\t}\n\n\n\t@Nested\n\tclass GetStaticMethodTests {\n\n\t\t@BeforeEach\n\t\tvoid clearStatics() {\n\t\t\tNestedClass.noArgCalled = false;\n\t\t\tNestedClass.argCalled = false;\n\t\t\tNestedClass.overloadedCalled = false;\n\t\t}\n\n\t\t@Test\n\t\tvoid noArgsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\");\n\t\t\tmethod.invoke(null, (Object[]) null);\n\t\t\tassertThat(NestedClass.noArgCalled).as(\"no argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid argsStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"argStaticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.argCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t\t@Test\n\t\tvoid overloadedStaticMethod() throws IllegalAccessException, InvocationTargetException {\n\t\t\tMethod method = ClassUtils.getStaticMethod(NestedClass.class, \"staticMethod\", String.class);\n\t\t\tmethod.invoke(null, \"test\");\n\t\t\tassertThat(NestedClass.overloadedCalled).as(\"argument method was not invoked.\").isTrue();\n\t\t}\n\n\t}\n\n\n\t@Nested  // gh-33216\n\tclass GetPubliclyAccessibleMethodTests {\n\n\t\t@Test\n\t\tvoid nonPublicMethod(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(originalMethod);\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\t// This method is intentionally public.\n\t\tpublic void publicMethodInNonPublicType(TestInfo testInfo) {\n\t\t\tMethod originalMethod = testInfo.getTestMethod().get();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertPublic(originalMethod);\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertNotPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = String.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodInPublicType() throws Exception {\n\t\t\tClass<?> originalType = ArrayList.class;\n\t\t\tMethod originalMethod = originalType.getDeclaredMethod(\"size\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in List.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(originalType);\n\t\t\tassertThat(publiclyAccessibleMethod).isSameAs(originalMethod);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaLangObjectDeclaredInNonPublicType() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"toString\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Object.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"toString\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicMethodInJavaTimeZoneIdDeclaredInNonPublicSubclass() throws Exception {\n\t\t\t// Returns a package-private java.time.ZoneRegion.\n\t\t\tZoneId zoneId = ZoneId.of(\"CET\");\n\t\t\tClass<?> targetClass = zoneId.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getDeclaredMethod(\"getId\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(ZoneId.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getId\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid publicInterfaceMethodDeclaredInNonPublicTypeWithLateBindingOfClassMethodToSubclassDeclaredInterface() throws Exception {\n\t\t\tHashMap<String, String> hashMap = new HashMap<>();\n\t\t\t// Returns a package-private java.util.HashMap.KeyIterator which extends java.util.HashMap.HashIterator\n\t\t\t// which declares hasNext(), even though HashIterator does not implement Iterator. Rather, KeyIterator\n\t\t\t// implements HashIterator.\n\t\t\tIterator<String> iterator = hashMap.keySet().iterator();\n\t\t\tClass<?> targetClass = iterator.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"hasNext\");\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, targetClass);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Iterator.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"hasNext\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getText\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicInterface.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getText\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getMessage\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\t// Should not find the interface method in PrivateInterface.\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getMessage\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesPropertyInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getDeclaredMethod(\"getNumber\");\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"getNumber\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).isEmpty();\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid packagePrivateSubclassOverridesMethodInPublicInterface() throws Exception {\n\t\t\tList<String> unmodifiableList = Collections.unmodifiableList(Arrays.asList(\"foo\", \"bar\"));\n\t\t\tClass<?> targetClass = unmodifiableList.getClass();\n\n\t\t\t// Prerequisites for this use case:\n\t\t\tassertNotPublic(targetClass);\n\n\t\t\tMethod originalMethod = targetClass.getMethod(\"contains\", Object.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(Collection.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"contains\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(Object.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPrivateInterface() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"greet\", String.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"greet\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(String.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\t@Test\n\t\tvoid privateSubclassOverridesMethodInPublicSuperclass() throws Exception {\n\t\t\tMethod originalMethod = PrivateSubclass.class.getMethod(\"process\", int.class);\n\n\t\t\t// Prerequisite: type must not be public for this use case.\n\t\t\tassertNotPublic(originalMethod.getDeclaringClass());\n\n\t\t\tMethod publiclyAccessibleMethod = ClassUtils.getPubliclyAccessibleMethodIfPossible(originalMethod, null);\n\t\t\tassertThat(publiclyAccessibleMethod.getDeclaringClass()).isEqualTo(PublicSuperclass.class);\n\t\t\tassertThat(publiclyAccessibleMethod.getName()).isEqualTo(\"process\");\n\t\t\tassertThat(publiclyAccessibleMethod.getParameterTypes()).containsExactly(int.class);\n\t\t\tassertPubliclyAccessible(publiclyAccessibleMethod);\n\t\t}\n\n\t\tprivate static void assertPubliclyAccessible(Method method) {\n\t\t\tassertPublic(method);\n\t\t\tassertPublic(method.getDeclaringClass());\n\t\t}\n\n\t\tprivate static void assertNotPubliclyAccessible(Method method) {\n\t\t\tassertThat(!isPublic(method) || !isPublic(method.getDeclaringClass()))\n\t\t\t\t\t.as(\"%s must not be publicly accessible\", method)\n\t\t\t\t\t.isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Member member) {\n\t\t\tassertThat(isPublic(member)).as(\"%s must be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertPublic(Class<?> clazz) {\n\t\t\tassertThat(isPublic(clazz)).as(\"%s must be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Member member) {\n\t\t\tassertThat(!isPublic(member)).as(\"%s must be not be public\", member).isTrue();\n\t\t}\n\n\t\tprivate static void assertNotPublic(Class<?> clazz) {\n\t\t\tassertThat(!isPublic(clazz)).as(\"%s must be not be public\", clazz).isTrue();\n\t\t}\n\n\t\tprivate static boolean isPublic(Class<?> clazz) {\n\t\t\treturn Modifier.isPublic(clazz.getModifiers());\n\t\t}\n\n\t\tprivate static boolean isPublic(Member member) {\n\t\t\treturn Modifier.isPublic(member.getModifiers());\n\t\t}\n\n\t\tprivate interface PrivateInterface {\n\n\t\t\tString getMessage();\n\n\t\t\tString greet(String name);\n\t\t}\n\n\t\tprivate static class PrivateSubclass extends PublicSuperclass implements PublicInterface, PrivateInterface {\n\n\t\t\t@Override\n\t\t\tpublic int getNumber() {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getMessage() {\n\t\t\t\treturn \"hello\";\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String greet(String name) {\n\t\t\t\treturn \"Hello, \" + name;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int process(int num) {\n\t\t\t\treturn num * 2;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getText() {\n\t\t\t\treturn \"enigma\";\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { Boolean.class, Character.class, Byte.class, Short.class,\n\t\tInteger.class, Long.class, Float.class, Double.class, Void.class })\n\t@interface WrapperTypes {\n\t}\n\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ValueSource(classes = { boolean.class, char.class, byte.class, short.class,\n\t\tint.class, long.class, float.class, double.class, void.class })\n\t@interface PrimitiveTypes {\n\t}\n\n\tpublic static class NestedClass {\n\n\t\tstatic boolean noArgCalled;\n\t\tstatic boolean argCalled;\n\t\tstatic boolean overloadedCalled;\n\n\t\tpublic static void staticMethod() {\n\t\t\tnoArgCalled = true;\n\t\t}\n\n\t\tpublic static void staticMethod(String anArg) {\n\t\t\toverloadedCalled = true;\n\t\t}\n\n\t\tpublic static void argStaticMethod(String anArg) {\n\t\t\targCalled = true;\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class OverloadedMethodsClass {\n\n\t\tpublic void print(String messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tpublic void print(String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static class SubOverloadedMethodsClass extends OverloadedMethodsClass {\n\n\t\tpublic void print(String header, String[] messages) {\n\t\t\t/* no-op */\n\t\t}\n\n\t\tvoid print(String header, String[] messages, String footer) {\n\t\t\t/* no-op */\n\t\t}\n\t}\n\n\tprivate static void assertIsLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isTrue();\n\t}\n\n\tprivate static void assertIsNotLambda(Supplier<String> supplier) {\n\t\tassertThat(ClassUtils.isLambdaClass(supplier.getClass())).isFalse();\n\t}\n\n\tprivate static final Supplier<String> staticLambdaExpression = () -> \"static lambda expression\";\n\n\tprivate final Supplier<String> instanceLambdaExpression = () -> \"instance lambda expressions\";\n\n\tprivate static String staticStringFactory() {\n\t\treturn \"static string factory\";\n\t}\n\n\tprivate String instanceStringFactory() {\n\t\treturn \"instance string factory\";\n\t}\n\n\tprivate static class EnigmaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"enigma\";\n\t\t}\n\t}\n\n\tprivate static class Fake$$LambdaSupplier implements Supplier<String> {\n\t\t@Override\n\t\tpublic String get() {\n\t\t\treturn \"fake lambda\";\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate interface MethodsInterface {\n\n\t\tdefault void defaultPrint() {\n\n\t\t}\n\n\t\tvoid print(String messages);\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class MethodsInterfaceImplementation implements MethodsInterface {\n\n\t\t@Override\n\t\tpublic void print(String message) {\n\n\t\t}\n\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\tvoid packageAccessiblePrint() {\n\n\t\t}\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprivate class SubMethodsInterfaceImplementation extends MethodsInterfaceImplementation {\n\n\t\t@Override\n\t\tprotected void protectedPrint() {\n\n\t\t}\n\n\t\t@Override\n\t\tpublic void packageAccessiblePrint() {\n\n\t\t}\n\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "iterationData": [],
            "targetClassMap": {}
        }
    }
]