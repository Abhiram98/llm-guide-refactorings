[
  {
    "source_class": "org.apache.kafka.storage.internals.epoch.LeaderEpochFileCache",
    "source_method": "writeToFile",
    "target_class": "org.apache.kafka.storage.internals.checkpoint.LeaderEpochCheckpointFile"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.epoch.LeaderEpochFileCache",
    "source_method": "writeToFileForTruncation",
    "target_class": "org.apache.kafka.storage.internals.checkpoint.LeaderEpochCheckpointFile"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.FetchDataInfo",
    "source_method": "empty",
    "target_class": "org.apache.kafka.common.record.MemoryRecords"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogValidator",
    "source_method": "getFirstBatchAndMaybeValidateNoMoreBatches",
    "target_class": "org.apache.kafka.common.record.CompressionType):org.apache.kafka.common.record.MutableRecordBatch \t org.apache.kafka.common.record.MemoryRecords"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogValidator",
    "source_method": "convertAndAssignOffsetsNonCompressed",
    "target_class": "org.apache.kafka.storage.internals.log.LogValidator.MetricsRecorder):org.apache.kafka.storage.internals.log.LogValidator.ValidationResult \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogValidator",
    "source_method": "validateMessagesAndAssignOffsetsCompressed",
    "target_class": "org.apache.kafka.storage.internals.log.LogValidator.MetricsRecorder, org.apache.kafka.common.utils.BufferSupplier):org.apache.kafka.storage.internals.log.LogValidator.ValidationResult \t org.apache.kafka.common.record.MutableRecordBatch"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogValidator",
    "source_method": "buildRecordsAndAssignOffsets",
    "target_class": "long, org.apache.kafka.common.record.RecordBatch, java.util.List<org.apache.kafka.common.record.Record>, int):org.apache.kafka.storage.internals.log.LogValidator.ValidationResult \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.AbstractIndex",
    "source_method": "maybeLock",
    "target_class": "org.apache.kafka.storage.internals.log.StorageAction<T,E>):T \t org.apache.kafka.storage.internals.log.StorageAction"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.AbstractIndex",
    "source_method": "compareIndexEntry",
    "target_class": "long, org.apache.kafka.storage.internals.log.IndexSearchType):int \t org.apache.kafka.storage.internals.log.IndexEntry"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.TransactionIndex",
    "source_method": "append",
    "target_class": "org.apache.kafka.storage.internals.log.AbortedTxn"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.TransactionIndex",
    "source_method": "collectAbortedTxns",
    "target_class": "long):org.apache.kafka.storage.internals.log.TxnIndexSearchResult \t org.apache.kafka.storage.internals.log.AbortedTxn"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.TransactionIndex",
    "source_method": "iterable",
    "target_class": "org.apache.kafka.storage.internals.log.AbortedTxn"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogConfig",
    "source_method": "remoteStorageEnable",
    "target_class": "org.apache.kafka.storage.internals.log.LogConfig.RemoteLogConfig"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogConfig",
    "source_method": "localRetentionMs",
    "target_class": "org.apache.kafka.storage.internals.log.LogConfig.RemoteLogConfig"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogConfig",
    "source_method": "localRetentionBytes",
    "target_class": "org.apache.kafka.storage.internals.log.LogConfig.RemoteLogConfig"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogConfig",
    "source_method": "shouldIgnoreMessageFormatVersion",
    "target_class": "org.apache.kafka.server.common.MetadataVersion"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogConfig",
    "source_method": "configType",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogConfig",
    "source_method": "configNames",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LazyIndex",
    "source_method": "forOffset",
    "target_class": "long, int):org.apache.kafka.storage.internals.log.LazyIndex<org.apache.kafka.storage.internals.log.OffsetIndex> \t org.apache.kafka.storage.internals.log.LazyIndex.IndexType"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LazyIndex",
    "source_method": "forTime",
    "target_class": "long, int):org.apache.kafka.storage.internals.log.LazyIndex<org.apache.kafka.storage.internals.log.TimeIndex> \t org.apache.kafka.storage.internals.log.LazyIndex.IndexType"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LazyIndex",
    "source_method": "file",
    "target_class": "org.apache.kafka.storage.internals.log.LazyIndex.IndexWrapper"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LazyIndex",
    "source_method": "updateParentDir",
    "target_class": "org.apache.kafka.storage.internals.log.LazyIndex.IndexWrapper"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LazyIndex",
    "source_method": "renameTo",
    "target_class": "org.apache.kafka.storage.internals.log.LazyIndex.IndexWrapper"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LazyIndex",
    "source_method": "deleteIfExists",
    "target_class": "org.apache.kafka.storage.internals.log.LazyIndex.IndexWrapper"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LazyIndex",
    "source_method": "closeHandler",
    "target_class": "org.apache.kafka.storage.internals.log.LazyIndex.IndexWrapper"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateEntry",
    "source_method": "empty",
    "target_class": "org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateEntry",
    "source_method": "findDuplicateBatch",
    "target_class": "org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateEntry",
    "source_method": "batchWithSequenceRange",
    "target_class": "int):java.util.Optional<org.apache.kafka.storage.internals.log.BatchMetadata> \t org.apache.kafka.storage.internals.log.BatchMetadata"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.FetchIsolation",
    "source_method": "of",
    "target_class": "org.apache.kafka.common.requests.FetchRequest"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.FetchIsolation",
    "source_method": "of",
    "target_class": "org.apache.kafka.common.IsolationLevel):org.apache.kafka.storage.internals.log.FetchIsolation \t org.apache.kafka.common.requests.FetchRequest"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.RemoteIndexCache",
    "source_method": "createCacheEntry",
    "target_class": "org.apache.kafka.server.log.remote.storage.RemoteStorageManager"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.RemoteIndexCache.Entry",
    "source_method": "lookupOffset",
    "target_class": "org.apache.kafka.storage.internals.log.OffsetIndex"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.RemoteIndexCache.Entry",
    "source_method": "lookupTimestamp",
    "target_class": "long):org.apache.kafka.storage.internals.log.OffsetPosition \t org.apache.kafka.storage.internals.log.OffsetIndex"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.RemoteIndexCache.Entry",
    "source_method": "markForCleanup",
    "target_class": "org.apache.kafka.storage.internals.log.TransactionIndex"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.RemoteIndexCache",
    "source_method": "remoteLogSegmentIdFromRemoteIndexFileName",
    "target_class": "org.apache.kafka.common.Uuid"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.RemoteIndexCache",
    "source_method": "generateFileNamePrefixForIndex",
    "target_class": "org.apache.kafka.common.Uuid"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.RemoteIndexCache",
    "source_method": "remoteOffsetIndexFileName",
    "target_class": "org.apache.kafka.storage.internals.log.LogFileUtils"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.RemoteIndexCache",
    "source_method": "remoteTransactionIndexFileName",
    "target_class": "org.apache.kafka.storage.internals.log.LogFileUtils"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.RemoteIndexCache",
    "source_method": "remoteDeletedSuffixIndexFileName",
    "target_class": "org.apache.kafka.storage.internals.log.LogFileUtils"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "offsetIndex",
    "target_class": "org.apache.kafka.storage.internals.log.LazyIndex"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "offsetIndexFile",
    "target_class": "org.apache.kafka.storage.internals.log.LazyIndex"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "timeIndex",
    "target_class": "org.apache.kafka.storage.internals.log.LazyIndex"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "timeIndexFile",
    "target_class": "org.apache.kafka.storage.internals.log.LazyIndex"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "size",
    "target_class": "org.apache.kafka.common.record.FileRecords"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "appendChunkFromFile",
    "target_class": "int, org.apache.kafka.common.utils.BufferSupplier):int \t org.apache.kafka.common.record.FileLogInputStream.FileChannelRecordBatch"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "appendFromFile",
    "target_class": "int):int \t org.apache.kafka.common.record.FileRecords"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "updateProducerState",
    "target_class": "org.apache.kafka.common.record.RecordBatch):void \t org.apache.kafka.storage.internals.log.ProducerStateManager"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "read",
    "target_class": "int, java.util.Optional<java.lang.Long>, boolean):org.apache.kafka.storage.internals.log.FetchDataInfo \t org.apache.kafka.common.record.FileRecords.LogOffsetPosition"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "readLargestTimestamp",
    "target_class": "org.apache.kafka.common.record.FileRecords.TimestampAndOffset"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "readNextOffset",
    "target_class": "org.apache.kafka.storage.internals.log.FetchDataInfo"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "updateParentDir",
    "target_class": "org.apache.kafka.storage.internals.log.LazyIndex"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "changeFileSuffixes",
    "target_class": "java.lang.String):void \t org.apache.kafka.common.record.FileRecords"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "loadFirstBatchTimestamp",
    "target_class": "org.apache.kafka.common.record.FileRecords"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "lastModified",
    "target_class": "org.apache.kafka.common.record.FileRecords"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "open",
    "target_class": "long, org.apache.kafka.storage.internals.log.LogConfig, org.apache.kafka.common.utils.Time, boolean, int, boolean, java.lang.String):org.apache.kafka.storage.internals.log.LogSegment \t org.apache.kafka.storage.internals.log.LogFileUtils"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegment",
    "source_method": "deleteIfExists",
    "target_class": "long, java.lang.String):void \t org.apache.kafka.storage.internals.log.LogFileUtils"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateManager",
    "source_method": "maybeCreateVerificationStateEntry",
    "target_class": "int, short):org.apache.kafka.storage.internals.log.VerificationStateEntry \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateManager",
    "source_method": "removeStraySnapshots",
    "target_class": "org.apache.kafka.storage.internals.log.SnapshotFile"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateManager",
    "source_method": "loadProducerEntry",
    "target_class": "org.apache.kafka.storage.internals.log.ProducerStateEntry"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateManager",
    "source_method": "isProducerExpired",
    "target_class": "org.apache.kafka.storage.internals.log.ProducerStateEntry):boolean \t org.apache.kafka.storage.internals.log.ProducerStateManagerConfig"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateManager",
    "source_method": "removeExpiredProducers",
    "target_class": "org.apache.kafka.storage.internals.log.ProducerStateManagerConfig"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateManager",
    "source_method": "updateOldestTxnTimestamp",
    "target_class": "org.apache.kafka.storage.internals.log.ProducerStateEntry"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateManager",
    "source_method": "latestSnapshotOffset",
    "target_class": "org.apache.kafka.storage.internals.log.SnapshotFile"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateManager",
    "source_method": "oldestSnapshotOffset",
    "target_class": "org.apache.kafka.storage.internals.log.SnapshotFile"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateManager",
    "source_method": "lastStableOffset",
    "target_class": "org.apache.kafka.storage.internals.log.CompletedTxn"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateManager",
    "source_method": "fetchSnapshot",
    "target_class": "org.apache.kafka.storage.internals.log.SnapshotFile"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateManager",
    "source_method": "removeAndDeleteSnapshot",
    "target_class": "org.apache.kafka.storage.internals.log.SnapshotFile"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateManager",
    "source_method": "readSnapshot",
    "target_class": "org.apache.kafka.common.utils.Crc32C"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateManager",
    "source_method": "writeSnapshot",
    "target_class": "java.util.Map<java.lang.Long,org.apache.kafka.storage.internals.log.ProducerStateEntry>, boolean):void \t org.apache.kafka.common.utils.Crc32C"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerStateManager",
    "source_method": "isSnapshotFile",
    "target_class": "org.apache.kafka.storage.internals.log.LogFileUtils"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogSegments",
    "source_method": "nonActiveLogSegmentsFrom",
    "target_class": "org.apache.kafka.storage.internals.log.LogSegment"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerAppendInfo",
    "source_method": "checkSequence",
    "target_class": "int, long):void \t org.apache.kafka.storage.internals.log.ProducerStateEntry"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerAppendInfo",
    "source_method": "append",
    "target_class": "java.util.Optional<org.apache.kafka.storage.internals.log.LogOffsetMetadata>):java.util.Optional<org.apache.kafka.storage.internals.log.CompletedTxn> \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ProducerAppendInfo",
    "source_method": "appendDataBatch",
    "target_class": "int, int, long, org.apache.kafka.storage.internals.log.LogOffsetMetadata, long, boolean):void \t org.apache.kafka.storage.internals.log.ProducerStateEntry"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogAppendInfo",
    "source_method": "unknownLogAppendInfoWithLogStartOffset",
    "target_class": "org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.LogAppendInfo",
    "source_method": "unknownLogAppendInfoWithAdditionalInfo",
    "target_class": "java.util.List<org.apache.kafka.common.requests.ProduceResponse.RecordError>):org.apache.kafka.storage.internals.log.LogAppendInfo \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.log.ThrottledReplicaListValidator",
    "source_method": "ensureValidString",
    "target_class": "java.lang.String):void \t org.apache.kafka.common.config.ConfigDef.Validator"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.checkpoint.PartitionMetadataFile",
    "source_method": "record",
    "target_class": "org.apache.kafka.common.Uuid"
  },
  {
    "source_class": "org.apache.kafka.storage.internals.checkpoint.LeaderEpochCheckpointFile",
    "source_method": "writeForTruncation",
    "target_class": "org.apache.kafka.storage.internals.checkpoint.CheckpointFileWithFailureHandler"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "configDef",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "isRemoteStorageSystemEnabled",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteStorageManagerClassName",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteStorageManagerClassPath",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogMetadataManagerClassName",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogMetadataManagerClassPath",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogManagerThreadPoolSize",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogManagerCopierThreadPoolSize",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogManagerExpirationThreadPoolSize",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogManagerTaskIntervalMs",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogManagerTaskRetryBackoffMs",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogManagerTaskRetryBackoffMaxMs",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogManagerTaskRetryJitter",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogReaderThreads",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogReaderMaxPendingTasks",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogMetadataManagerListenerName",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogMetadataCustomMetadataMaxBytes",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteStorageManagerPrefix",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogMetadataManagerPrefix",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "getConfigProps",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogManagerCopyNumQuotaSamples",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogManagerCopyQuotaWindowSizeSeconds",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogManagerFetchNumQuotaSamples",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogManagerFetchQuotaWindowSizeSeconds",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogIndexFileCacheTotalSizeBytes",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogManagerCopyMaxBytesPerSecond",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteLogManagerFetchMaxBytesPerSecond",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig",
    "source_method": "remoteFetchMaxWaitMs",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.ClassLoaderAwareRemoteStorageManager",
    "source_method": "withClassLoader",
    "target_class": "org.apache.kafka.storage.internals.log.StorageAction"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.ConsumerTask",
    "source_method": "shouldProcess",
    "target_class": "long):boolean \t org.apache.kafka.server.log.remote.storage.RemoteLogMetadata"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.ConsumerTask",
    "source_method": "isUserPartitionAssigned",
    "target_class": "org.apache.kafka.server.log.remote.metadata.storage.ConsumerTask.UserTopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.ConsumerTask",
    "source_method": "fetchStartAndEndOffsets",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.ConsumerTask",
    "source_method": "newUserTopicIdPartition",
    "target_class": "org.apache.kafka.server.log.remote.metadata.storage.RemoteLogMetadataTopicPartitioner"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.RemoteLogMetadataTopicPartitioner",
    "source_method": "toBytes",
    "target_class": "org.apache.kafka.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.serialization.RemoteLogMetadataSerde",
    "source_method": "deserialize",
    "target_class": "org.apache.kafka.server.common.serialization.BytesApiMessageSerde"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.TopicBasedRemoteLogMetadataManager",
    "source_method": "assignPartitions",
    "target_class": "org.apache.kafka.server.log.remote.metadata.storage.ConsumerManager"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.TopicBasedRemoteLogMetadataManager",
    "source_method": "createRemoteLogMetadataTopicRequest",
    "target_class": "org.apache.kafka.server.log.remote.metadata.storage.TopicBasedRemoteLogMetadataManagerConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.ClassLoaderAwareRemoteLogMetadataManager",
    "source_method": "withClassLoader",
    "target_class": "org.apache.kafka.storage.internals.log.StorageAction"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.ConsumerManager",
    "source_method": "waitTillConsumptionCatchesUp",
    "target_class": "org.apache.kafka.server.log.remote.metadata.storage.TopicBasedRemoteLogMetadataManagerConfig"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.ConsumerManager",
    "source_method": "readOffsetForPartition",
    "target_class": "org.apache.kafka.server.log.remote.metadata.storage.ConsumerTask"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.RemoteLogMetadataCache",
    "source_method": "remoteLogSegmentMetadata",
    "target_class": "long):java.util.Optional<org.apache.kafka.server.log.remote.storage.RemoteLogSegmentMetadata> \t org.apache.kafka.server.log.remote.metadata.storage.RemoteLogLeaderEpochState"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.RemoteLogMetadataCache",
    "source_method": "doHandleSegmentStateTransitionForLeaderEpochs",
    "target_class": "org.apache.kafka.server.log.remote.metadata.storage.RemoteLogLeaderEpochState.Action):void \t org.apache.kafka.server.log.remote.storage.RemoteLogSegmentMetadata"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.RemoteLogMetadataCache",
    "source_method": "highestOffsetForEpoch",
    "target_class": "org.apache.kafka.server.log.remote.storage.RemoteLogSegmentMetadata):long \t org.apache.kafka.server.log.remote.storage.RemoteLogSegmentMetadata"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.RemoteLogMetadataCache",
    "source_method": "listRemoteLogSegments",
    "target_class": "org.apache.kafka.server.log.remote.metadata.storage.RemoteLogLeaderEpochState"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.RemoteLogMetadataCache",
    "source_method": "highestOffsetForEpoch",
    "target_class": "org.apache.kafka.server.log.remote.metadata.storage.RemoteLogLeaderEpochState"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.RemoteLogSegmentMetadataSnapshot",
    "source_method": "create",
    "target_class": "org.apache.kafka.server.log.remote.storage.RemoteLogSegmentMetadata"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.metadata.storage.RemotePartitionMetadataStore",
    "source_method": "getRemoteLogMetadataCache",
    "target_class": "org.apache.kafka.server.log.remote.metadata.storage.RemoteLogMetadataCache"
  },
  {
    "source_class": "org.apache.kafka.server.log.remote.storage.RemoteLogSegmentId",
    "source_method": "generateNew",
    "target_class": "org.apache.kafka.common.Uuid"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClientDriver",
    "source_method": "handleRequest",
    "target_class": "org.apache.kafka.common.requests.RequestHeader, org.apache.kafka.common.protocol.ApiMessage, long):java.util.concurrent.CompletableFuture<org.apache.kafka.common.protocol.ApiMessage> \t org.apache.kafka.raft.RaftRequest.Inbound"
  },
  {
    "source_class": "org.apache.kafka.raft.UnattachedState",
    "source_method": "remainingElectionTimeMs",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.UnattachedState",
    "source_method": "hasElectionTimeoutExpired",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.QuorumState",
    "source_method": "readElectionState",
    "target_class": "org.apache.kafka.raft.QuorumStateStore"
  },
  {
    "source_class": "org.apache.kafka.raft.QuorumState",
    "source_method": "leaderIdOrSentinel",
    "target_class": "org.apache.kafka.raft.EpochState"
  },
  {
    "source_class": "org.apache.kafka.raft.QuorumState",
    "source_method": "leaderId",
    "target_class": "org.apache.kafka.raft.EpochState"
  },
  {
    "source_class": "org.apache.kafka.raft.QuorumState",
    "source_method": "transitionToResigned",
    "target_class": "org.apache.kafka.raft.EpochState"
  },
  {
    "source_class": "org.apache.kafka.raft.QuorumState",
    "source_method": "transitionToVoted",
    "target_class": "org.apache.kafka.raft.internals.ReplicaKey):void \t org.apache.kafka.raft.EpochState"
  },
  {
    "source_class": "org.apache.kafka.raft.QuorumState",
    "source_method": "durableTransitionTo",
    "target_class": "org.apache.kafka.raft.EpochState"
  },
  {
    "source_class": "org.apache.kafka.raft.QuorumState",
    "source_method": "leaderAndEpoch",
    "target_class": "org.apache.kafka.raft.ElectionState"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.VoterSet",
    "source_method": "voterNode",
    "target_class": "org.apache.kafka.common.network.ListenerName):java.util.Optional<org.apache.kafka.common.Node> \t org.apache.kafka.raft.internals.VoterSet.VoterNode"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.VoterSet",
    "source_method": "isVoter",
    "target_class": "org.apache.kafka.raft.internals.ReplicaKey"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.VoterSet",
    "source_method": "addVoter",
    "target_class": "org.apache.kafka.raft.internals.VoterSet.VoterNode"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.VoterSet",
    "source_method": "removeVoter",
    "target_class": "org.apache.kafka.raft.internals.VoterSet.VoterNode"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.VoterSet.VoterNode",
    "source_method": "isVoter",
    "target_class": "org.apache.kafka.raft.internals.ReplicaKey"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.VoterSet",
    "source_method": "fromVotersRecord",
    "target_class": "org.apache.kafka.raft.Endpoints"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.VoterSet",
    "source_method": "fromInetSocketAddresses",
    "target_class": "java.util.Map<java.lang.Integer,java.net.InetSocketAddress>):org.apache.kafka.raft.internals.VoterSet \t org.apache.kafka.raft.Endpoints"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.RecordsIterator",
    "source_method": "readFileRecords",
    "target_class": "java.nio.ByteBuffer):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.FileRecords"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.RecordsIterator",
    "source_method": "readRecord",
    "target_class": "int, java.util.function.BiFunction<java.util.Optional<java.nio.ByteBuffer>,java.util.Optional<java.nio.ByteBuffer>,U>):U \t org.apache.kafka.common.utils.BufferSupplier"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.RecordsIterator",
    "source_method": "decodeControlRecord",
    "target_class": "java.util.Optional<java.nio.ByteBuffer>):org.apache.kafka.raft.ControlRecord \t org.apache.kafka.common.record.ControlRecordUtils"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.VoterSetHistory",
    "source_method": "addAt",
    "target_class": "org.apache.kafka.raft.internals.VoterSet):void \t org.apache.kafka.raft.internals.VoterSet"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.VoterSetHistory",
    "source_method": "lastValue",
    "target_class": "org.apache.kafka.raft.internals.LogHistory"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.KafkaRaftMetrics",
    "source_method": "updatePollEnd",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.KafkaRaftMetrics",
    "source_method": "updateAppendRecords",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.KafkaRaftMetrics",
    "source_method": "updateFetchedRecords",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.KafkaRaftMetrics",
    "source_method": "updateCommitLatency",
    "target_class": "long):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.KafkaRaftMetrics",
    "source_method": "maybeUpdateElectionLatency",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.MemoryBatchReader",
    "source_method": "of",
    "target_class": "org.apache.kafka.raft.internals.CloseListener<org.apache.kafka.raft.BatchReader<T>>):org.apache.kafka.raft.internals.MemoryBatchReader<T> \t org.apache.kafka.raft.Batch"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.BatchAccumulator",
    "source_method": "maybeResetLinger",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.BatchAccumulator",
    "source_method": "completeCurrentBatch",
    "target_class": "org.apache.kafka.raft.internals.BatchBuilder"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.BatchAccumulator",
    "source_method": "appendControlMessages",
    "target_class": "org.apache.kafka.raft.internals.BatchAccumulator.MemoryRecordsCreator"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.BatchAccumulator",
    "source_method": "validateMemoryRecordsAndReturnCount",
    "target_class": "org.apache.kafka.common.record.MemoryRecords"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.BatchAccumulator",
    "source_method": "maybeCompleteDrain",
    "target_class": "org.apache.kafka.raft.internals.BatchBuilder"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.BatchAccumulator",
    "source_method": "startNewBatch",
    "target_class": "org.apache.kafka.common.memory.MemoryPool"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.BatchAccumulator",
    "source_method": "timeUntilDrain",
    "target_class": "org.apache.kafka.raft.internals.BatchAccumulator.SimpleTimer"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.BatchAccumulator",
    "source_method": "isEmpty",
    "target_class": "org.apache.kafka.raft.internals.BatchAccumulator.SimpleTimer"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.BatchAccumulator.CompletedBatch",
    "source_method": "sizeInBytes",
    "target_class": "org.apache.kafka.common.record.MemoryRecords"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.KRaftControlRecordStateMachine",
    "source_method": "truncateNewEntries",
    "target_class": "org.apache.kafka.raft.internals.VoterSetHistory"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.KRaftControlRecordStateMachine",
    "source_method": "truncateOldEntries",
    "target_class": "org.apache.kafka.raft.internals.VoterSetHistory"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.KRaftControlRecordStateMachine",
    "source_method": "lastVoterSet",
    "target_class": "org.apache.kafka.raft.internals.VoterSetHistory"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.KRaftControlRecordStateMachine",
    "source_method": "lastKraftVersion",
    "target_class": "org.apache.kafka.raft.internals.LogHistory"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.KRaftControlRecordStateMachine",
    "source_method": "voterSetAtOffset",
    "target_class": "org.apache.kafka.raft.internals.VoterSetHistory"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.KRaftControlRecordStateMachine",
    "source_method": "maybeLoadLog",
    "target_class": "org.apache.kafka.raft.internals.RecordsIterator"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.BatchBuilder",
    "source_method": "flushedSizeInBytes",
    "target_class": "org.apache.kafka.common.utils.ByteBufferOutputStream"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.BatchBuilder",
    "source_method": "build",
    "target_class": "org.apache.kafka.common.protocol.DataOutputStreamWritable"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.BatchBuilder",
    "source_method": "batchHeaderSizeInBytes",
    "target_class": "org.apache.kafka.common.compress.Compression"
  },
  {
    "source_class": "org.apache.kafka.raft.internals.ReplicaKey",
    "source_method": "of",
    "target_class": "org.apache.kafka.common.Uuid):org.apache.kafka.raft.internals.ReplicaKey \t org.apache.kafka.common.Uuid"
  },
  {
    "source_class": "org.apache.kafka.raft.ResignedState",
    "source_method": "hasElectionTimeoutExpired",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.ResignedState",
    "source_method": "remainingElectionTimeMs",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "errorResponse",
    "target_class": "org.apache.kafka.common.protocol.Errors):org.apache.kafka.common.protocol.ApiMessage \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "singletonFetchRequest",
    "target_class": "org.apache.kafka.common.Uuid, java.util.function.Consumer<FetchRequestData.FetchPartition>):org.apache.kafka.raft.FetchRequestData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "singletonFetchResponse",
    "target_class": "short, org.apache.kafka.common.TopicPartition, org.apache.kafka.common.Uuid, org.apache.kafka.common.protocol.Errors, int, org.apache.kafka.raft.Endpoints, java.util.function.Consumer<FetchResponseData.PartitionData>):org.apache.kafka.raft.FetchResponseData \t org.apache.kafka.raft.Endpoints"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "singletonVoteRequest",
    "target_class": "java.lang.String, int, org.apache.kafka.raft.internals.ReplicaKey, org.apache.kafka.raft.internals.ReplicaKey, int, long):org.apache.kafka.raft.VoteRequestData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "singletonVoteResponse",
    "target_class": "short, org.apache.kafka.common.protocol.Errors, org.apache.kafka.common.TopicPartition, org.apache.kafka.common.protocol.Errors, int, int, boolean, org.apache.kafka.raft.Endpoints):org.apache.kafka.raft.VoteResponseData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "singletonFetchSnapshotRequest",
    "target_class": "org.apache.kafka.raft.internals.ReplicaKey, org.apache.kafka.common.TopicPartition, int, org.apache.kafka.raft.OffsetAndEpoch, int, long):org.apache.kafka.raft.FetchSnapshotRequestData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "singletonFetchSnapshotResponse",
    "target_class": "short, org.apache.kafka.common.TopicPartition, int, org.apache.kafka.raft.Endpoints, java.util.function.UnaryOperator<FetchSnapshotResponseData.PartitionSnapshot>):org.apache.kafka.raft.FetchSnapshotResponseData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "singletonBeginQuorumEpochRequest",
    "target_class": "java.lang.String, int, int, org.apache.kafka.raft.Endpoints, org.apache.kafka.raft.internals.ReplicaKey):org.apache.kafka.raft.BeginQuorumEpochRequestData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "singletonBeginQuorumEpochResponse",
    "target_class": "short, org.apache.kafka.common.protocol.Errors, org.apache.kafka.common.TopicPartition, org.apache.kafka.common.protocol.Errors, int, int, org.apache.kafka.raft.Endpoints):org.apache.kafka.raft.BeginQuorumEpochResponseData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "singletonEndQuorumEpochRequest",
    "target_class": "java.lang.String, int, int, java.util.List<org.apache.kafka.raft.internals.ReplicaKey>):org.apache.kafka.raft.EndQuorumEpochRequestData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "singletonEndQuorumEpochResponse",
    "target_class": "short, org.apache.kafka.common.protocol.Errors, org.apache.kafka.common.TopicPartition, org.apache.kafka.common.protocol.Errors, int, int, org.apache.kafka.raft.Endpoints):org.apache.kafka.raft.EndQuorumEpochResponseData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "singletonDescribeQuorumRequest",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "singletonDescribeQuorumResponse",
    "target_class": "org.apache.kafka.common.TopicPartition, DescribeQuorumResponseData.PartitionData, DescribeQuorumResponseData.NodeCollection):org.apache.kafka.raft.DescribeQuorumResponseData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "voteRequestVoterKey",
    "target_class": "VoteRequestData.PartitionData):java.util.Optional<org.apache.kafka.raft.internals.ReplicaKey> \t org.apache.kafka.raft.internals.ReplicaKey"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "beginQuorumEpochRequestVoterKey",
    "target_class": "BeginQuorumEpochRequestData.PartitionData):java.util.Optional<org.apache.kafka.raft.internals.ReplicaKey> \t org.apache.kafka.raft.internals.ReplicaKey"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "hasValidTopicPartition",
    "target_class": "org.apache.kafka.common.TopicPartition, org.apache.kafka.common.Uuid):boolean \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "hasValidTopicPartition",
    "target_class": "org.apache.kafka.common.TopicPartition, org.apache.kafka.common.Uuid):boolean \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "hasValidTopicPartition",
    "target_class": "org.apache.kafka.common.TopicPartition):boolean \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "hasValidTopicPartition",
    "target_class": "org.apache.kafka.common.TopicPartition):boolean \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "hasValidTopicPartition",
    "target_class": "org.apache.kafka.common.TopicPartition):boolean \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "hasValidTopicPartition",
    "target_class": "org.apache.kafka.common.TopicPartition):boolean \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "hasValidTopicPartition",
    "target_class": "org.apache.kafka.common.TopicPartition):boolean \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "hasValidTopicPartition",
    "target_class": "org.apache.kafka.common.TopicPartition):boolean \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.RaftUtil",
    "source_method": "hasValidTopicPartition",
    "target_class": "org.apache.kafka.common.TopicPartition):boolean \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.raft.LeaderState",
    "source_method": "updateFetchedVoters",
    "target_class": "org.apache.kafka.raft.LeaderState.ReplicaState"
  },
  {
    "source_class": "org.apache.kafka.raft.LeaderState",
    "source_method": "nonAcknowledgingVoters",
    "target_class": "org.apache.kafka.raft.internals.ReplicaKey"
  },
  {
    "source_class": "org.apache.kafka.raft.LeaderState",
    "source_method": "updateLocalState",
    "target_class": "org.apache.kafka.raft.internals.VoterSet):boolean \t org.apache.kafka.raft.LogOffsetMetadata"
  },
  {
    "source_class": "org.apache.kafka.raft.LeaderState",
    "source_method": "nonLeaderVotersByDescendingFetchOffset",
    "target_class": "org.apache.kafka.raft.LeaderState.ReplicaState"
  },
  {
    "source_class": "org.apache.kafka.raft.LeaderState",
    "source_method": "getOrCreateReplicaState",
    "target_class": "org.apache.kafka.raft.LeaderState.ReplicaState"
  },
  {
    "source_class": "org.apache.kafka.raft.LeaderState",
    "source_method": "getReplicaState",
    "target_class": "org.apache.kafka.raft.LeaderState.ReplicaState"
  },
  {
    "source_class": "org.apache.kafka.raft.LeaderState",
    "source_method": "clearInactiveObservers",
    "target_class": "org.apache.kafka.raft.internals.ReplicaKey"
  },
  {
    "source_class": "org.apache.kafka.raft.LeaderState",
    "source_method": "isVoter",
    "target_class": "org.apache.kafka.raft.LeaderState.ReplicaState"
  },
  {
    "source_class": "org.apache.kafka.raft.LeaderState.ReplicaState",
    "source_method": "setReplicaKey",
    "target_class": "org.apache.kafka.raft.internals.ReplicaKey"
  },
  {
    "source_class": "org.apache.kafka.raft.LeaderState.ReplicaState",
    "source_method": "matchesKey",
    "target_class": "org.apache.kafka.raft.internals.ReplicaKey"
  },
  {
    "source_class": "org.apache.kafka.raft.LeaderState.ReplicaState",
    "source_method": "updateFollowerState",
    "target_class": "org.apache.kafka.raft.LogOffsetMetadata, java.util.Optional<org.apache.kafka.raft.LogOffsetMetadata>):void \t org.apache.kafka.raft.LogOffsetMetadata"
  },
  {
    "source_class": "org.apache.kafka.raft.QuorumConfig",
    "source_method": "parseVoterConnections",
    "target_class": "boolean):java.util.Map<java.lang.Integer,java.net.InetSocketAddress> \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.raft.QuorumConfig",
    "source_method": "parseBootstrapServer",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.raft.VotedState",
    "source_method": "remainingElectionTimeMs",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.VotedState",
    "source_method": "hasElectionTimeoutExpired",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.CandidateState",
    "source_method": "startBackingOff",
    "target_class": "long):void \t org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.CandidateState",
    "source_method": "hasElectionTimeoutExpired",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.CandidateState",
    "source_method": "isBackoffComplete",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.CandidateState",
    "source_method": "remainingBackoffMs",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.CandidateState",
    "source_method": "remainingElectionTimeMs",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.FollowerState",
    "source_method": "remainingFetchTimeMs",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.FollowerState",
    "source_method": "leaderNode",
    "target_class": "org.apache.kafka.raft.Endpoints"
  },
  {
    "source_class": "org.apache.kafka.raft.FollowerState",
    "source_method": "hasFetchTimeoutExpired",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.FollowerState",
    "source_method": "resetFetchTimeout",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.FollowerState",
    "source_method": "overrideFetchTimeout",
    "target_class": "long):void \t org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.ValidOffsetAndEpoch",
    "source_method": "diverging",
    "target_class": "org.apache.kafka.raft.ValidOffsetAndEpoch.Kind"
  },
  {
    "source_class": "org.apache.kafka.raft.ValidOffsetAndEpoch",
    "source_method": "snapshot",
    "target_class": "org.apache.kafka.raft.ValidOffsetAndEpoch.Kind"
  },
  {
    "source_class": "org.apache.kafka.raft.ValidOffsetAndEpoch",
    "source_method": "valid",
    "target_class": "org.apache.kafka.raft.ValidOffsetAndEpoch.Kind"
  },
  {
    "source_class": "org.apache.kafka.raft.RequestManager",
    "source_method": "hasAnyInflightRequest",
    "target_class": "org.apache.kafka.raft.RequestManager.ConnectionState"
  },
  {
    "source_class": "org.apache.kafka.raft.RequestManager",
    "source_method": "backoffBeforeAvailableBootstrapServer",
    "target_class": "org.apache.kafka.raft.RequestManager.ConnectionState"
  },
  {
    "source_class": "org.apache.kafka.raft.RequestManager",
    "source_method": "hasRequestTimedOut",
    "target_class": "long):boolean \t org.apache.kafka.raft.RequestManager.ConnectionState"
  },
  {
    "source_class": "org.apache.kafka.raft.RequestManager",
    "source_method": "isReady",
    "target_class": "long):boolean \t org.apache.kafka.raft.RequestManager.ConnectionState"
  },
  {
    "source_class": "org.apache.kafka.raft.RequestManager",
    "source_method": "isBackingOff",
    "target_class": "long):boolean \t org.apache.kafka.raft.RequestManager.ConnectionState"
  },
  {
    "source_class": "org.apache.kafka.raft.RequestManager",
    "source_method": "remainingRequestTimeMs",
    "target_class": "long):long \t org.apache.kafka.raft.RequestManager.ConnectionState"
  },
  {
    "source_class": "org.apache.kafka.raft.RequestManager",
    "source_method": "remainingBackoffMs",
    "target_class": "long):long \t org.apache.kafka.common.Node"
  },
  {
    "source_class": "org.apache.kafka.raft.RequestManager",
    "source_method": "isResponseExpected",
    "target_class": "long):boolean \t org.apache.kafka.raft.RequestManager.ConnectionState"
  },
  {
    "source_class": "org.apache.kafka.raft.RequestManager",
    "source_method": "onRequestSent",
    "target_class": "long, long):void \t org.apache.kafka.raft.RequestManager.ConnectionState"
  },
  {
    "source_class": "org.apache.kafka.raft.RequestManager",
    "source_method": "reset",
    "target_class": "org.apache.kafka.common.Node"
  },
  {
    "source_class": "org.apache.kafka.raft.ElectionState",
    "source_method": "isVotedCandidate",
    "target_class": "org.apache.kafka.raft.internals.ReplicaKey"
  },
  {
    "source_class": "org.apache.kafka.raft.ElectionState",
    "source_method": "withVotedCandidate",
    "target_class": "org.apache.kafka.raft.internals.ReplicaKey, java.util.Set<java.lang.Integer>):org.apache.kafka.raft.ElectionState \t org.apache.kafka.raft.internals.ReplicaKey"
  },
  {
    "source_class": "org.apache.kafka.raft.ElectionState",
    "source_method": "fromQuorumStateData",
    "target_class": "org.apache.kafka.raft.internals.ReplicaKey"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "maybeFireLeaderChange",
    "target_class": "org.apache.kafka.raft.QuorumState"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "endOffset",
    "target_class": "org.apache.kafka.raft.ReplicatedLog"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "resetConnections",
    "target_class": "org.apache.kafka.raft.RequestManager"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "maybeTransitionToLeader",
    "target_class": "long):boolean \t org.apache.kafka.raft.CandidateState"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "transitionToCandidate",
    "target_class": "org.apache.kafka.raft.QuorumState"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "transitionToUnattached",
    "target_class": "org.apache.kafka.raft.QuorumState"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "transitionToResigned",
    "target_class": "org.apache.kafka.raft.internals.FuturePurgatory"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "transitionToVoted",
    "target_class": "int):void \t org.apache.kafka.raft.QuorumState"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "onBecomeFollower",
    "target_class": "org.apache.kafka.raft.internals.FuturePurgatory"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "transitionToFollower",
    "target_class": "int, org.apache.kafka.raft.Endpoints, long):void \t org.apache.kafka.raft.QuorumState"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "buildVoteResponse",
    "target_class": "short, org.apache.kafka.common.protocol.Errors, boolean):org.apache.kafka.raft.VoteResponseData \t org.apache.kafka.raft.ReplicatedLog"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "binaryExponentialElectionBackoffMs",
    "target_class": "org.apache.kafka.raft.QuorumConfig"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "strictExponentialElectionBackoffMs",
    "target_class": "int):int \t org.apache.kafka.raft.QuorumConfig"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "buildBeginQuorumEpochResponse",
    "target_class": "short, org.apache.kafka.common.protocol.Errors):org.apache.kafka.raft.BeginQuorumEpochResponseData \t org.apache.kafka.raft.ReplicatedLog"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "buildEndQuorumEpochResponse",
    "target_class": "short, org.apache.kafka.common.protocol.Errors):org.apache.kafka.raft.EndQuorumEpochResponseData \t org.apache.kafka.raft.ReplicatedLog"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "endEpochElectionBackoff",
    "target_class": "org.apache.kafka.common.Uuid"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "hasConsistentLeader",
    "target_class": "java.util.OptionalInt):boolean \t org.apache.kafka.raft.QuorumState"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "maybeHandleCommonResponse",
    "target_class": "java.util.OptionalInt, int, long):java.util.Optional<java.lang.Boolean> \t org.apache.kafka.raft.Endpoints"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "maybeTransition",
    "target_class": "int, org.apache.kafka.raft.Endpoints, long):void \t org.apache.kafka.raft.Endpoints"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "handleResponse",
    "target_class": "long):void \t org.apache.kafka.raft.RaftResponse.Inbound"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "validateVoterOnlyRequest",
    "target_class": "int):java.util.Optional<org.apache.kafka.common.protocol.Errors> \t org.apache.kafka.raft.QuorumState"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "isValidVoterKey",
    "target_class": "org.apache.kafka.raft.internals.ReplicaKey"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "validateLeaderOnlyRequest",
    "target_class": "org.apache.kafka.raft.QuorumState"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "buildEndQuorumEpochRequest",
    "target_class": "org.apache.kafka.raft.ResignedState"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "buildBeginQuorumEpochRequest",
    "target_class": "org.apache.kafka.raft.ReplicatedLog"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "buildVoteRequest",
    "target_class": "org.apache.kafka.raft.QuorumState"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "maybeSendAnyVoterFetch",
    "target_class": "org.apache.kafka.raft.RequestManager"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "isRunning",
    "target_class": "org.apache.kafka.raft.KafkaRaftClient.GracefulShutdown"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "isShuttingDown",
    "target_class": "org.apache.kafka.raft.KafkaRaftClient.GracefulShutdown"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "pollResigned",
    "target_class": "org.apache.kafka.raft.ResignedState"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "maybeSendVoteRequests",
    "target_class": "long):long \t org.apache.kafka.raft.NetworkChannel"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "pollFollowerAsObserver",
    "target_class": "long):long \t org.apache.kafka.raft.RequestManager"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "maybeSendFetchOrFetchSnapshot",
    "target_class": "long):long \t org.apache.kafka.snapshot.RawSnapshotWriter"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "pollVoted",
    "target_class": "org.apache.kafka.raft.KafkaRaftClient.GracefulShutdown"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "pollUnattachedAsVoter",
    "target_class": "long):long \t org.apache.kafka.raft.UnattachedState"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "pollUnattachedAsObserver",
    "target_class": "long):long \t org.apache.kafka.raft.UnattachedState"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "pollCurrentState",
    "target_class": "org.apache.kafka.raft.QuorumState"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "maybeCompleteShutdown",
    "target_class": "org.apache.kafka.raft.KafkaRaftClient.GracefulShutdown"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "wakeup",
    "target_class": "org.apache.kafka.raft.RaftMessageQueue"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "handle",
    "target_class": "org.apache.kafka.raft.RaftMessageQueue"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "poll",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient",
    "source_method": "voterNode",
    "target_class": "org.apache.kafka.common.network.ListenerName):java.util.Optional<org.apache.kafka.common.Node> \t org.apache.kafka.raft.internals.KRaftControlRecordStateMachine"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient.GracefulShutdown",
    "source_method": "update",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient.GracefulShutdown",
    "source_method": "hasTimedOut",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient.GracefulShutdown",
    "source_method": "remainingTimeMs",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient.Registration",
    "source_method": "unregister",
    "target_class": "org.apache.kafka.raft.KafkaRaftClient.Registration.Ops"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaRaftClient.ListenerContext",
    "source_method": "shouldFireLeaderChange",
    "target_class": "org.apache.kafka.raft.LeaderAndEpoch"
  },
  {
    "source_class": "org.apache.kafka.raft.Endpoints",
    "source_method": "fromVotersRecordEndpoints",
    "target_class": "org.apache.kafka.common.network.ListenerName"
  },
  {
    "source_class": "org.apache.kafka.raft.Endpoints",
    "source_method": "fromBeginQuorumEpochRequest",
    "target_class": "org.apache.kafka.common.network.ListenerName"
  },
  {
    "source_class": "org.apache.kafka.raft.Endpoints",
    "source_method": "fromEndQuorumEpochRequest",
    "target_class": "org.apache.kafka.common.network.ListenerName"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaNetworkChannel",
    "source_method": "sendCompleteFuture",
    "target_class": "org.apache.kafka.common.protocol.ApiMessage):void \t org.apache.kafka.raft.RaftRequest.Outbound"
  },
  {
    "source_class": "org.apache.kafka.raft.KafkaNetworkChannel",
    "source_method": "errorResponse",
    "target_class": "org.apache.kafka.common.protocol.Errors):org.apache.kafka.common.protocol.ApiMessage \t org.apache.kafka.common.protocol.ApiMessage"
  },
  {
    "source_class": "org.apache.kafka.snapshot.FileRawSnapshotWriter",
    "source_method": "create",
    "target_class": "org.apache.kafka.raft.OffsetAndEpoch):org.apache.kafka.snapshot.FileRawSnapshotWriter \t org.apache.kafka.snapshot.Snapshots"
  },
  {
    "source_class": "org.apache.kafka.snapshot.RecordsSnapshotReader",
    "source_method": "of",
    "target_class": "org.apache.kafka.server.common.serialization.RecordSerde<T>, org.apache.kafka.common.utils.BufferSupplier, int, boolean):org.apache.kafka.snapshot.RecordsSnapshotReader<T> \t org.apache.kafka.snapshot.RawSnapshotReader"
  },
  {
    "source_class": "org.apache.kafka.snapshot.FileRawSnapshotReader",
    "source_method": "open",
    "target_class": "org.apache.kafka.raft.OffsetAndEpoch):org.apache.kafka.snapshot.FileRawSnapshotReader \t org.apache.kafka.snapshot.Snapshots"
  },
  {
    "source_class": "org.apache.kafka.snapshot.Snapshots",
    "source_method": "filenameFromSnapshotId",
    "target_class": "org.apache.kafka.raft.OffsetAndEpoch"
  },
  {
    "source_class": "org.apache.kafka.snapshot.Snapshots",
    "source_method": "markForDelete",
    "target_class": "org.apache.kafka.raft.OffsetAndEpoch):java.nio.file.Path \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.snapshot.Snapshots",
    "source_method": "lastContainedLogTimestamp",
    "target_class": "org.apache.kafka.snapshot.RecordsSnapshotReader"
  },
  {
    "source_class": "org.apache.kafka.snapshot.Snapshots",
    "source_method": "lastContainedLogTimestamp",
    "target_class": "org.apache.kafka.raft.OffsetAndEpoch):long \t org.apache.kafka.snapshot.FileRawSnapshotReader"
  },
  {
    "source_class": "org.apache.kafka.connect.rest.basic.auth.extension.JaasBasicAuthFilter",
    "source_method": "isInternalRequest",
    "target_class": "org.apache.kafka.connect.rest.basic.auth.extension.JaasBasicAuthFilter.RequestMatcher"
  },
  {
    "source_class": "org.apache.kafka.connect.json.JsonConverter",
    "source_method": "convertToConnect",
    "target_class": "org.apache.kafka.connect.json.JsonNode, org.apache.kafka.connect.json.JsonConverterConfig):java.lang.Object \t org.apache.kafka.connect.json.JsonConverterConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.tools.VerifiableSourceTask",
    "source_method": "completeValue",
    "target_class": "org.apache.kafka.connect.data.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.tools.MockSinkTask",
    "source_method": "setTimeout",
    "target_class": "org.apache.kafka.connect.sink.SinkTaskContext"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConfig",
    "source_method": "defineSourceConfig",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorMaker",
    "source_method": "checkHerder",
    "target_class": "org.apache.kafka.connect.mirror.SourceAndTarget"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.OffsetSyncStore",
    "source_method": "createBackingStore",
    "target_class": "org.apache.kafka.clients.consumer.Consumer<byte[],byte[]>, org.apache.kafka.connect.util.TopicAdmin):org.apache.kafka.connect.util.KafkaBasedLog<byte[],byte[]> \t org.apache.kafka.connect.mirror.MirrorCheckpointConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.OffsetSyncStore",
    "source_method": "backingStoreStart",
    "target_class": "org.apache.kafka.connect.util.KafkaBasedLog"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.OffsetSyncStore",
    "source_method": "handleRecord",
    "target_class": "org.apache.kafka.connect.mirror.OffsetSync"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.OffsetSyncStore",
    "source_method": "invariantB",
    "target_class": "org.apache.kafka.connect.mirror.OffsetSync, int, int):boolean \t org.apache.kafka.connect.mirror.OffsetSync"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.OffsetSyncStore",
    "source_method": "invariantC",
    "target_class": "org.apache.kafka.connect.mirror.OffsetSync, int):boolean \t org.apache.kafka.connect.mirror.OffsetSync"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.OffsetSyncStore",
    "source_method": "lookupLatestSync",
    "target_class": "long):org.apache.kafka.connect.mirror.OffsetSync \t org.apache.kafka.connect.mirror.OffsetSync"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorCheckpointTask",
    "source_method": "checkpointRecord",
    "target_class": "long):org.apache.kafka.connect.source.SourceRecord \t org.apache.kafka.connect.mirror.Checkpoint"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorCheckpointTask",
    "source_method": "renameTopicPartition",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorCheckpointTask",
    "source_method": "shouldCheckpointTopic",
    "target_class": "org.apache.kafka.connect.mirror.TopicFilter"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorMakerConfig",
    "source_method": "transform",
    "target_class": "org.apache.kafka.connect.runtime.isolation.Plugins"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorMakerConfig",
    "source_method": "config",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorConnectorConfig",
    "source_method": "sourceConsumerConfig",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.CheckpointStore",
    "source_method": "readCheckpointsImpl",
    "target_class": "org.apache.kafka.connect.util.Callback<org.apache.kafka.clients.consumer.ConsumerRecord<byte[],byte[]>>):void \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorHeartbeatConfig",
    "source_method": "defineHeartbeatConfig",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConnector",
    "source_method": "findTargetTopicPartitions",
    "target_class": "org.apache.kafka.connect.mirror.ReplicationPolicy"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConnector",
    "source_method": "syncTopicAcls",
    "target_class": "org.apache.kafka.common.acl.AclBinding"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConnector",
    "source_method": "createOffsetSyncsTopic",
    "target_class": "org.apache.kafka.connect.mirror.MirrorSourceConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConnector",
    "source_method": "listTopics",
    "target_class": "org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConnector",
    "source_method": "describeTopics",
    "target_class": "java.util.Collection<java.lang.String>):java.util.Collection<org.apache.kafka.clients.admin.TopicDescription> \t org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConnector",
    "source_method": "configToMap",
    "target_class": "org.apache.kafka.clients.admin.Config"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConnector",
    "source_method": "expandTopicDescription",
    "target_class": "org.apache.kafka.clients.admin.TopicDescription"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConnector",
    "source_method": "describeTopicConfigs",
    "target_class": "org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConnector",
    "source_method": "targetConfig",
    "target_class": "boolean):org.apache.kafka.clients.admin.Config \t org.apache.kafka.clients.admin.ConfigEntry"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConnector",
    "source_method": "downgradeAllowAllACL",
    "target_class": "org.apache.kafka.common.acl.AccessControlEntry"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConnector",
    "source_method": "targetAclBinding",
    "target_class": "org.apache.kafka.common.acl.AclBinding"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConnector",
    "source_method": "shouldReplicateTopic",
    "target_class": "org.apache.kafka.connect.mirror.ReplicationPolicy"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConnector",
    "source_method": "shouldReplicateAcl",
    "target_class": "org.apache.kafka.common.acl.AclBinding"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConnector",
    "source_method": "shouldReplicateTopicConfigurationProperty",
    "target_class": "org.apache.kafka.connect.mirror.ConfigPropertyFilter"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceConnector",
    "source_method": "formatRemoteTopic",
    "target_class": "org.apache.kafka.connect.mirror.SourceAndTarget"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorCheckpointMetrics",
    "source_method": "group",
    "target_class": "java.lang.String):org.apache.kafka.connect.mirror.MirrorCheckpointMetrics.GroupMetrics \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorUtils",
    "source_method": "encodeTopicPartition",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorUtils",
    "source_method": "wrapPartition",
    "target_class": "java.lang.String):java.util.Map<java.lang.String,java.lang.Object> \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorUtils",
    "source_method": "createCompactedTopic",
    "target_class": "short, short, org.apache.kafka.clients.admin.Admin):void \t org.apache.kafka.connect.util.TopicAdmin"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorCheckpointConfig",
    "source_method": "defineCheckpointConfig",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.OffsetSync",
    "source_method": "serializeValue",
    "target_class": "org.apache.kafka.common.protocol.types.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.OffsetSync",
    "source_method": "serializeKey",
    "target_class": "org.apache.kafka.common.protocol.types.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.OffsetSync",
    "source_method": "deserializeRecord",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerRecord"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.OffsetSync",
    "source_method": "valueStruct",
    "target_class": "org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.OffsetSync",
    "source_method": "keyStruct",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorHeartbeatConnector",
    "source_method": "createInternalTopics",
    "target_class": "org.apache.kafka.connect.mirror.MirrorHeartbeatConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorCheckpointConnector",
    "source_method": "createInternalTopics",
    "target_class": "org.apache.kafka.connect.mirror.MirrorCheckpointConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorCheckpointConnector",
    "source_method": "shouldReplicateByGroupFilter",
    "target_class": "org.apache.kafka.connect.mirror.GroupFilter"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorCheckpointConnector",
    "source_method": "shouldReplicateByTopicFilter",
    "target_class": "org.apache.kafka.connect.mirror.TopicFilter"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceTask",
    "source_method": "maybeQueueOffsetSyncs",
    "target_class": "long, long):void \t org.apache.kafka.connect.mirror.MirrorSourceTask.PartitionState"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceTask",
    "source_method": "loadOffset",
    "target_class": "org.apache.kafka.connect.source.SourceTaskContext"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceTask",
    "source_method": "convertRecord",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerRecord"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorSourceTask",
    "source_method": "convertHeaders",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerRecord"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.Heartbeat",
    "source_method": "serializeKey",
    "target_class": "org.apache.kafka.common.protocol.types.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.Heartbeat",
    "source_method": "deserializeRecord",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerRecord"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.Heartbeat",
    "source_method": "headerStruct",
    "target_class": "org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.Heartbeat",
    "source_method": "valueStruct",
    "target_class": "org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.Heartbeat",
    "source_method": "keyStruct",
    "target_class": "org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorClient",
    "source_method": "remoteTopics",
    "target_class": "org.apache.kafka.connect.mirror.ReplicationPolicy"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorClient",
    "source_method": "countHopsForTopic",
    "target_class": "java.lang.String):int \t org.apache.kafka.connect.mirror.ReplicationPolicy"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorClient",
    "source_method": "isHeartbeatTopic",
    "target_class": "org.apache.kafka.connect.mirror.ReplicationPolicy"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorClient",
    "source_method": "isCheckpointTopic",
    "target_class": "org.apache.kafka.connect.mirror.ReplicationPolicy"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorClient",
    "source_method": "isRemoteTopic",
    "target_class": "org.apache.kafka.connect.mirror.ReplicationPolicy"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.MirrorClient",
    "source_method": "allSources",
    "target_class": "org.apache.kafka.connect.mirror.ReplicationPolicy"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.RemoteClusterUtils",
    "source_method": "replicationHops",
    "target_class": "java.lang.String):int \t org.apache.kafka.connect.mirror.MirrorClient"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.RemoteClusterUtils",
    "source_method": "heartbeatTopics",
    "target_class": "org.apache.kafka.connect.mirror.MirrorClient"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.RemoteClusterUtils",
    "source_method": "checkpointTopics",
    "target_class": "org.apache.kafka.connect.mirror.MirrorClient"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.RemoteClusterUtils",
    "source_method": "upstreamClusters",
    "target_class": "org.apache.kafka.connect.mirror.MirrorClient"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.RemoteClusterUtils",
    "source_method": "translateOffsets",
    "target_class": "java.lang.String, java.lang.String, java.time.Duration):java.util.Map<org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetAndMetadata> \t org.apache.kafka.connect.mirror.MirrorClient"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.Checkpoint",
    "source_method": "serializeValue",
    "target_class": "org.apache.kafka.common.protocol.types.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.Checkpoint",
    "source_method": "serializeKey",
    "target_class": "org.apache.kafka.common.protocol.types.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.Checkpoint",
    "source_method": "deserializeRecord",
    "target_class": "org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.Checkpoint",
    "source_method": "valueStruct",
    "target_class": "org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.Checkpoint",
    "source_method": "keyStruct",
    "target_class": "org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.Checkpoint",
    "source_method": "headerStruct",
    "target_class": "org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.mirror.Checkpoint",
    "source_method": "connectPartition",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.ConverterConfig",
    "source_method": "newConfigDef",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Time",
    "source_method": "builder",
    "target_class": "org.apache.kafka.connect.data.SchemaBuilder"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Time",
    "source_method": "fromLogical",
    "target_class": "java.util.Date):int \t org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Time",
    "source_method": "toLogical",
    "target_class": "int):java.util.Date \t org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "convertToBoolean",
    "target_class": "java.lang.Object):java.lang.Boolean \t org.apache.kafka.connect.data.SchemaAndValue"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "convertToTime",
    "target_class": "java.lang.Object):java.util.Date \t org.apache.kafka.connect.data.Time"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "convertToDate",
    "target_class": "java.lang.Object):java.util.Date \t org.apache.kafka.connect.data.Date"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "convertToTimestamp",
    "target_class": "java.lang.Object):java.util.Date \t org.apache.kafka.connect.data.Timestamp"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "convertToDecimal",
    "target_class": "java.lang.Object, int):java.math.BigDecimal \t org.apache.kafka.connect.data.Decimal"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "inferSchema",
    "target_class": "org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "inferListSchema",
    "target_class": "org.apache.kafka.connect.data.SchemaBuilder"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "inferMapSchema",
    "target_class": "org.apache.kafka.connect.data.SchemaBuilder"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "parseString",
    "target_class": "org.apache.kafka.connect.data.Values.ValueParser"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "convertToDecimal",
    "target_class": "java.lang.Object):java.math.BigDecimal \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "convertToBytes",
    "target_class": "java.lang.Object):byte[] \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "convertToDate",
    "target_class": "org.apache.kafka.connect.data.Schema, java.lang.Object):java.util.Date \t org.apache.kafka.connect.data.SchemaAndValue"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "convertToTime",
    "target_class": "org.apache.kafka.connect.data.Schema, java.lang.Object):java.util.Date \t org.apache.kafka.connect.data.Time"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "convertToTimestamp",
    "target_class": "org.apache.kafka.connect.data.Schema, java.lang.Object):java.util.Date \t org.apache.kafka.connect.data.Time"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "convertToArray",
    "target_class": "java.lang.Object):java.util.List<?> \t org.apache.kafka.connect.data.SchemaAndValue"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "convertToMapInternal",
    "target_class": "java.lang.Object):java.util.Map<?,?> \t org.apache.kafka.connect.data.SchemaAndValue"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "asLong",
    "target_class": "org.apache.kafka.connect.data.Schema, java.lang.Throwable):long \t org.apache.kafka.connect.data.Time"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values.ValueParser",
    "source_method": "canParseSingleTokenLiteral",
    "target_class": "java.lang.String):boolean \t org.apache.kafka.connect.data.Values.Parser"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values.ValueParser",
    "source_method": "parseNextToken",
    "target_class": "java.lang.String):org.apache.kafka.connect.data.SchemaAndValue \t org.apache.kafka.connect.data.Values.Parser"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values.ValueParser",
    "source_method": "parseQuotedString",
    "target_class": "org.apache.kafka.connect.data.Values.Parser"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values.ValueParser",
    "source_method": "parseArray",
    "target_class": "org.apache.kafka.connect.data.Values.Parser"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values.ValueParser",
    "source_method": "parseMap",
    "target_class": "org.apache.kafka.connect.data.Values.Parser"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values.ValueParser",
    "source_method": "parseMultipleTokensAsTemporal",
    "target_class": "org.apache.kafka.connect.data.Values.Parser"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values.ValueParser",
    "source_method": "parseAsNumber",
    "target_class": "org.apache.kafka.connect.data.Decimal"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values.ValueParser",
    "source_method": "parseAsTemporal",
    "target_class": "org.apache.kafka.connect.data.Time"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values.SchemaMerger",
    "source_method": "merge",
    "target_class": "org.apache.kafka.connect.data.SchemaAndValue"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "commonSchemaForInt8",
    "target_class": "org.apache.kafka.connect.data.Schema.Type):org.apache.kafka.connect.data.Schema \t org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "commonSchemaForInt16",
    "target_class": "org.apache.kafka.connect.data.Schema, org.apache.kafka.connect.data.Schema.Type):org.apache.kafka.connect.data.Schema \t org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "commonSchemaForInt32",
    "target_class": "org.apache.kafka.connect.data.Schema, org.apache.kafka.connect.data.Schema.Type):org.apache.kafka.connect.data.Schema \t org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "commonSchemaForInt64",
    "target_class": "org.apache.kafka.connect.data.Schema, org.apache.kafka.connect.data.Schema.Type):org.apache.kafka.connect.data.Schema \t org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "commonSchemaForFloat32",
    "target_class": "org.apache.kafka.connect.data.Schema, org.apache.kafka.connect.data.Schema.Type):org.apache.kafka.connect.data.Schema \t org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values",
    "source_method": "commonSchemaForFloat64",
    "target_class": "org.apache.kafka.connect.data.Schema.Type):org.apache.kafka.connect.data.Schema \t org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Values.SchemaDetector",
    "source_method": "canDetect",
    "target_class": "org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Decimal",
    "source_method": "builder",
    "target_class": "org.apache.kafka.connect.data.SchemaBuilder"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Timestamp",
    "source_method": "builder",
    "target_class": "org.apache.kafka.connect.data.SchemaBuilder"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Timestamp",
    "source_method": "fromLogical",
    "target_class": "java.util.Date):long \t org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Timestamp",
    "source_method": "toLogical",
    "target_class": "long):java.util.Date \t org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.data.SchemaBuilder",
    "source_method": "int8",
    "target_class": "org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.SchemaBuilder",
    "source_method": "int16",
    "target_class": "org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.SchemaBuilder",
    "source_method": "int32",
    "target_class": "org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.SchemaBuilder",
    "source_method": "int64",
    "target_class": "org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.SchemaBuilder",
    "source_method": "float32",
    "target_class": "org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.SchemaBuilder",
    "source_method": "float64",
    "target_class": "org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.SchemaBuilder",
    "source_method": "bool",
    "target_class": "org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.SchemaBuilder",
    "source_method": "string",
    "target_class": "org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.SchemaBuilder",
    "source_method": "bytes",
    "target_class": "org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.SchemaBuilder",
    "source_method": "struct",
    "target_class": "org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.SchemaBuilder",
    "source_method": "array",
    "target_class": "org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.SchemaBuilder",
    "source_method": "mapWithNullValues",
    "target_class": "org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.data.SchemaProjector",
    "source_method": "projectStruct",
    "target_class": "org.apache.kafka.connect.data.Struct, org.apache.kafka.connect.data.Schema):java.lang.Object \t org.apache.kafka.connect.data.Field"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Date",
    "source_method": "builder",
    "target_class": "org.apache.kafka.connect.data.SchemaBuilder"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Date",
    "source_method": "fromLogical",
    "target_class": "java.util.Date):int \t org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Date",
    "source_method": "toLogical",
    "target_class": "int):java.util.Date \t org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.data.ConnectSchema",
    "source_method": "validateValue",
    "target_class": "java.lang.Object, java.lang.String):void \t org.apache.kafka.connect.data.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Struct",
    "source_method": "get",
    "target_class": "org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Struct",
    "source_method": "getWithoutDefault",
    "target_class": "org.apache.kafka.connect.data.Field"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Struct",
    "source_method": "put",
    "target_class": "java.lang.Object):org.apache.kafka.connect.data.Struct \t org.apache.kafka.connect.data.Field"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Struct",
    "source_method": "validate",
    "target_class": "org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.data.Struct",
    "source_method": "lookupField",
    "target_class": "org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.header.ConnectHeaders",
    "source_method": "checkSchemaType",
    "target_class": "org.apache.kafka.connect.data.Schema.Type):void \t org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.header.ConnectHeaders",
    "source_method": "checkSchemaMatches",
    "target_class": "org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.ClusterConfigState",
    "source_method": "connectorConfig",
    "target_class": "org.apache.kafka.connect.runtime.WorkerConfigTransformer"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.ClusterConfigState",
    "source_method": "appliedConnectorConfig",
    "target_class": "org.apache.kafka.connect.storage.AppliedConnectorConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.ClusterConfigState",
    "source_method": "taskConfig",
    "target_class": "org.apache.kafka.connect.util.ConnectorTaskId"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.OffsetUtils",
    "source_method": "validateFormat",
    "target_class": "org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.OffsetUtils",
    "source_method": "processPartitionKey",
    "target_class": "byte[], org.apache.kafka.connect.storage.Converter, java.util.Map<java.lang.String,java.util.Set<java.util.Map<java.lang.String,java.lang.Object>>>):void \t org.apache.kafka.connect.util.ConnectUtils"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.ConnectorOffsetBackingStore",
    "source_method": "withConnectorAndWorkerStores",
    "target_class": "org.apache.kafka.connect.storage.OffsetBackingStore, org.apache.kafka.connect.storage.KafkaOffsetBackingStore, java.lang.String, org.apache.kafka.connect.util.TopicAdmin):org.apache.kafka.connect.storage.ConnectorOffsetBackingStore \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.ConnectorOffsetBackingStore",
    "source_method": "withOnlyWorkerStore",
    "target_class": "org.apache.kafka.connect.storage.OffsetBackingStore, java.lang.String):org.apache.kafka.connect.storage.ConnectorOffsetBackingStore \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.ConnectorOffsetBackingStore",
    "source_method": "withOnlyConnectorStore",
    "target_class": "org.apache.kafka.connect.storage.KafkaOffsetBackingStore, java.lang.String, org.apache.kafka.connect.util.TopicAdmin):org.apache.kafka.connect.storage.ConnectorOffsetBackingStore \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.ConnectorOffsetBackingStore.ChainedOffsetWriteFuture",
    "source_method": "onSecondWrite",
    "target_class": "java.lang.Void):void \t org.apache.kafka.connect.util.Callback"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.KafkaStatusBackingStore",
    "source_method": "sendTaskStatus",
    "target_class": "boolean):void \t org.apache.kafka.connect.util.ConnectorTaskId"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.KafkaStatusBackingStore",
    "source_method": "serialize",
    "target_class": "org.apache.kafka.connect.runtime.AbstractStatus"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.KafkaStatusBackingStore",
    "source_method": "serializeTopicStatus",
    "target_class": "org.apache.kafka.connect.data.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.KafkaConfigBackingStore",
    "source_method": "TASK_KEY",
    "target_class": "org.apache.kafka.connect.util.ConnectorTaskId"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.KafkaConfigBackingStore",
    "source_method": "baseProducerProps",
    "target_class": "org.apache.kafka.connect.runtime.WorkerConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.KafkaConfigBackingStore",
    "source_method": "fencableProducerProps",
    "target_class": "org.apache.kafka.connect.runtime.distributed.DistributedConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.KafkaConfigBackingStore",
    "source_method": "serializeTargetState",
    "target_class": "org.apache.kafka.connect.data.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.KafkaConfigBackingStore",
    "source_method": "processConnectorRemoval",
    "target_class": "org.apache.kafka.connect.util.ConnectorTaskId"
  },
  {
    "source_class": "org.apache.kafka.connect.storage.KafkaTopicBasedBackingStore",
    "source_method": "createTopics",
    "target_class": "org.apache.kafka.connect.util.TopicAdmin, org.apache.kafka.connect.runtime.WorkerConfig, org.apache.kafka.common.utils.Time):java.util.Set<java.lang.String> \t org.apache.kafka.connect.util.TopicAdmin"
  },
  {
    "source_class": "org.apache.kafka.connect.util.TopicCreationGroup",
    "source_method": "configuredGroups",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.util.TopicCreationGroup",
    "source_method": "newTopic",
    "target_class": "org.apache.kafka.connect.util.TopicAdmin.NewTopicBuilder"
  },
  {
    "source_class": "org.apache.kafka.connect.util.ConnectUtils",
    "source_method": "addMetricsContextProperties",
    "target_class": "org.apache.kafka.connect.runtime.WorkerConfig, java.lang.String):void \t org.apache.kafka.connect.runtime.WorkerConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.util.ConnectUtils",
    "source_method": "clientIdBase",
    "target_class": "org.apache.kafka.connect.runtime.WorkerConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.util.LoggingContext",
    "source_method": "forTask",
    "target_class": "org.apache.kafka.connect.util.ConnectorTaskId"
  },
  {
    "source_class": "org.apache.kafka.connect.util.LoggingContext",
    "source_method": "forOffsets",
    "target_class": "org.apache.kafka.connect.util.ConnectorTaskId"
  },
  {
    "source_class": "org.apache.kafka.connect.util.LoggingContext",
    "source_method": "prefixFor",
    "target_class": "org.apache.kafka.connect.util.LoggingContext.Scope, java.lang.Integer):java.lang.String \t org.apache.kafka.connect.util.LoggingContext.Scope"
  },
  {
    "source_class": "org.apache.kafka.connect.util.TopicCreation",
    "source_method": "newTopicCreation",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.connect.util.TopicCreationGroup>):org.apache.kafka.connect.util.TopicCreation \t org.apache.kafka.connect.runtime.WorkerConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.util.TopicCreation",
    "source_method": "findFirstGroup",
    "target_class": "org.apache.kafka.connect.util.TopicCreationGroup"
  },
  {
    "source_class": "org.apache.kafka.connect.util.SinkUtils",
    "source_method": "consumerGroupOffsetsToConnectorOffsets",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.connect.util.KafkaBasedLog",
    "source_method": "withExistingClients",
    "target_class": "org.apache.kafka.clients.consumer.Consumer<K,V>, org.apache.kafka.clients.producer.Producer<K,V>, org.apache.kafka.connect.util.TopicAdmin, org.apache.kafka.connect.util.Callback<org.apache.kafka.clients.consumer.ConsumerRecord<K,V>>, org.apache.kafka.common.utils.Time, java.util.function.Consumer<org.apache.kafka.connect.util.TopicAdmin>, java.util.function.Predicate<org.apache.kafka.common.TopicPartition>):org.apache.kafka.connect.util.KafkaBasedLog<K,V> \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.connect.util.TopicAdmin",
    "source_method": "createTopic",
    "target_class": "org.apache.kafka.clients.admin.NewTopic"
  },
  {
    "source_class": "org.apache.kafka.connect.util.TopicAdmin",
    "source_method": "createTopics",
    "target_class": "org.apache.kafka.connect.util.TopicAdmin.TopicCreationResponse"
  },
  {
    "source_class": "org.apache.kafka.connect.util.TopicAdmin",
    "source_method": "createOrFindTopic",
    "target_class": "org.apache.kafka.connect.util.TopicAdmin.TopicCreationResponse"
  },
  {
    "source_class": "org.apache.kafka.connect.util.TopicAdmin",
    "source_method": "endOffsets",
    "target_class": "org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "initConfigTransformer",
    "target_class": "org.apache.kafka.connect.runtime.isolation.Plugins"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "isSinkConnector",
    "target_class": "org.apache.kafka.connect.runtime.isolation.Plugins"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "awaitStopConnectors",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "isRunning",
    "target_class": "org.apache.kafka.connect.runtime.WorkerConnector"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "exactlyOnceSourceTaskProducerConfigs",
    "target_class": "org.apache.kafka.connect.runtime.WorkerConfig, org.apache.kafka.connect.runtime.ConnectorConfig, java.lang.Class<? extends org.apache.kafka.connect.connector.Connector>, org.apache.kafka.connect.connector.policy.ConnectorClientConfigOverridePolicy, java.lang.String):java.util.Map<java.lang.String,java.lang.Object> \t org.apache.kafka.connect.runtime.WorkerConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "baseProducerConfigs",
    "target_class": "java.lang.String, org.apache.kafka.connect.runtime.WorkerConfig, org.apache.kafka.connect.runtime.ConnectorConfig, java.lang.Class<? extends org.apache.kafka.connect.connector.Connector>, org.apache.kafka.connect.connector.policy.ConnectorClientConfigOverridePolicy, java.lang.String):java.util.Map<java.lang.String,java.lang.Object> \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "exactlyOnceSourceOffsetsConsumerConfigs",
    "target_class": "java.lang.String, org.apache.kafka.connect.runtime.WorkerConfig, org.apache.kafka.connect.runtime.ConnectorConfig, java.lang.Class<? extends org.apache.kafka.connect.connector.Connector>, org.apache.kafka.connect.connector.policy.ConnectorClientConfigOverridePolicy, java.lang.String):java.util.Map<java.lang.String,java.lang.Object> \t org.apache.kafka.connect.util.ConnectUtils"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "regularSourceOffsetsConsumerConfigs",
    "target_class": "java.lang.String, org.apache.kafka.connect.runtime.WorkerConfig, org.apache.kafka.connect.runtime.ConnectorConfig, java.lang.Class<? extends org.apache.kafka.connect.connector.Connector>, org.apache.kafka.connect.connector.policy.ConnectorClientConfigOverridePolicy, java.lang.String):java.util.Map<java.lang.String,java.lang.Object> \t org.apache.kafka.common.IsolationLevel"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "baseConsumerConfigs",
    "target_class": "java.lang.String, org.apache.kafka.connect.runtime.WorkerConfig, org.apache.kafka.connect.runtime.ConnectorConfig, java.lang.Class<? extends org.apache.kafka.connect.connector.Connector>, org.apache.kafka.connect.connector.policy.ConnectorClientConfigOverridePolicy, java.lang.String, org.apache.kafka.connect.health.ConnectorType):java.util.Map<java.lang.String,java.lang.Object> \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "adminConfigs",
    "target_class": "java.lang.String, org.apache.kafka.connect.runtime.WorkerConfig, org.apache.kafka.connect.runtime.ConnectorConfig, java.lang.Class<? extends org.apache.kafka.connect.connector.Connector>, org.apache.kafka.connect.connector.policy.ConnectorClientConfigOverridePolicy, java.lang.String, org.apache.kafka.connect.health.ConnectorType):java.util.Map<java.lang.String,java.lang.Object> \t org.apache.kafka.connect.runtime.WorkerConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "connectorClientConfigOverrides",
    "target_class": "org.apache.kafka.connect.runtime.ConnectorConfig, java.lang.Class<? extends org.apache.kafka.connect.connector.Connector>, java.lang.String, org.apache.kafka.connect.health.ConnectorType, org.apache.kafka.connect.connector.policy.ConnectorClientConfigRequest.ClientType, org.apache.kafka.connect.connector.policy.ConnectorClientConfigOverridePolicy):java.util.Map<java.lang.String,java.lang.Object> \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "taskTransactionalId",
    "target_class": "org.apache.kafka.connect.runtime.WorkerConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "sinkTaskReporters",
    "target_class": "org.apache.kafka.connect.runtime.SinkConnectorConfig, org.apache.kafka.connect.runtime.errors.ErrorHandlingMetrics, java.lang.Class<? extends org.apache.kafka.connect.connector.Connector>):java.util.List<org.apache.kafka.connect.runtime.errors.ErrorReporter<org.apache.kafka.clients.consumer.ConsumerRecord<byte[],byte[]>>> \t org.apache.kafka.connect.runtime.SinkConnectorConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "createWorkerErrantRecordReporter",
    "target_class": "org.apache.kafka.connect.runtime.errors.RetryWithToleranceOperator<org.apache.kafka.clients.consumer.ConsumerRecord<byte[],byte[]>>, org.apache.kafka.connect.storage.Converter, org.apache.kafka.connect.storage.Converter, org.apache.kafka.connect.storage.HeaderConverter):org.apache.kafka.connect.runtime.errors.WorkerErrantRecordReporter \t org.apache.kafka.connect.runtime.SinkConnectorConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "awaitStopTasks",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "isTopicCreationEnabled",
    "target_class": "org.apache.kafka.connect.runtime.WorkerConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "sourceConnectorOffsets",
    "target_class": "org.apache.kafka.connect.connector.Connector, java.util.Map<java.lang.String,java.lang.String>, org.apache.kafka.connect.util.Callback<org.apache.kafka.connect.runtime.rest.entities.ConnectorOffsets>):void \t org.apache.kafka.connect.runtime.WorkerConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "normalizeSourceConnectorOffsets",
    "target_class": "org.apache.kafka.connect.storage.Converter"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "completeModifyOffsetsCallback",
    "target_class": "boolean, org.apache.kafka.connect.util.Callback<org.apache.kafka.connect.runtime.rest.entities.Message>):void \t org.apache.kafka.connect.util.Callback"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "offsetStoreForRegularSourceTask",
    "target_class": "org.apache.kafka.connect.runtime.SourceConnectorConfig, java.lang.Class<? extends org.apache.kafka.connect.connector.Connector>, org.apache.kafka.clients.producer.Producer<byte[],byte[]>, java.util.Map<java.lang.String,java.lang.Object>, org.apache.kafka.connect.util.TopicAdmin):org.apache.kafka.connect.storage.ConnectorOffsetBackingStore \t org.apache.kafka.connect.util.ConnectorTaskId"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "offsetStoreForExactlyOnceSourceTask",
    "target_class": "org.apache.kafka.connect.runtime.SourceConnectorConfig, java.lang.Class<? extends org.apache.kafka.connect.connector.Connector>, org.apache.kafka.clients.producer.Producer<byte[],byte[]>, java.util.Map<java.lang.String,java.lang.Object>, org.apache.kafka.connect.util.TopicAdmin):org.apache.kafka.connect.storage.ConnectorOffsetBackingStore \t org.apache.kafka.connect.util.ConnectorTaskId"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "regularSourceTaskUsesConnectorSpecificOffsetsStore",
    "target_class": "org.apache.kafka.connect.runtime.SourceConnectorConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker",
    "source_method": "sourceConnectorTopicCreationEnabled",
    "target_class": "org.apache.kafka.connect.runtime.WorkerConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker.ConnectorStatusMetricsGroup",
    "source_method": "taskCounter",
    "target_class": "org.apache.kafka.connect.util.ConnectorTaskId"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.Worker.ConnectorStatusMetricsGroup",
    "source_method": "taskStatusCounter",
    "target_class": "org.apache.kafka.connect.runtime.AbstractStatus.State):org.apache.kafka.connect.runtime.ConnectMetrics.LiteralSupplier<java.lang.Long> \t org.apache.kafka.connect.runtime.WorkerTask"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.errors.ErrorHandlingMetrics",
    "source_method": "recordFailure",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.errors.ErrorHandlingMetrics",
    "source_method": "recordError",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.errors.ErrorHandlingMetrics",
    "source_method": "recordSkipped",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.errors.ErrorHandlingMetrics",
    "source_method": "recordRetry",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.errors.ErrorHandlingMetrics",
    "source_method": "recordErrorLogged",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.errors.ErrorHandlingMetrics",
    "source_method": "recordDeadLetterQueueProduceRequest",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.errors.ErrorHandlingMetrics",
    "source_method": "recordDeadLetterQueueProduceFailed",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.errors.ErrorHandlingMetrics",
    "source_method": "recordErrorTimestamp",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.errors.DeadLetterQueueReporter",
    "source_method": "createAndSetup",
    "target_class": "org.apache.kafka.connect.util.ConnectorTaskId, org.apache.kafka.connect.runtime.SinkConnectorConfig, java.util.Map<java.lang.String,java.lang.Object>, org.apache.kafka.connect.runtime.errors.ErrorHandlingMetrics):org.apache.kafka.connect.runtime.errors.DeadLetterQueueReporter \t org.apache.kafka.connect.runtime.SinkConnectorConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.SourceTaskOffsetCommitter",
    "source_method": "commit",
    "target_class": "org.apache.kafka.connect.runtime.WorkerSourceTask"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.ConnectorConfig",
    "source_method": "configDef",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.ConnectorConfig",
    "source_method": "aliasValidator",
    "target_class": "org.apache.kafka.common.config.ConfigDef.CompositeValidator"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.ConnectorConfig",
    "source_method": "enrich",
    "target_class": "org.apache.kafka.common.config.ConfigDef, java.util.Map<java.lang.String,java.lang.String>, boolean):org.apache.kafka.common.config.ConfigDef \t org.apache.kafka.connect.runtime.isolation.Plugins"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.SubmittedRecords",
    "source_method": "submit",
    "target_class": "org.apache.kafka.connect.source.SourceRecord"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.SubmittedRecords",
    "source_method": "submit",
    "target_class": "java.util.Map<java.lang.String,java.lang.Object>):org.apache.kafka.connect.runtime.SubmittedRecords.SubmittedRecord \t org.apache.kafka.connect.runtime.SubmittedRecords.SubmittedRecord"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.ExactlyOnceWorkerSourceTask",
    "source_method": "buildTransactionContext",
    "target_class": "org.apache.kafka.connect.runtime.SourceConnectorConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.ExactlyOnceWorkerSourceTask",
    "source_method": "maybeBeginTransaction",
    "target_class": "org.apache.kafka.clients.producer.Producer"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.ExactlyOnceWorkerSourceTask.TransactionMetricsGroup",
    "source_method": "commitTransaction",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSourceTask",
    "source_method": "updateCommittableOffsets",
    "target_class": "org.apache.kafka.connect.runtime.SubmittedRecords"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.StateTracker",
    "source_method": "changeState",
    "target_class": "long):void \t org.apache.kafka.connect.runtime.StateTracker.StateChange"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.standalone.StandaloneHerder",
    "source_method": "modifyConnectorOffsetsChecks",
    "target_class": "org.apache.kafka.connect.util.Callback<org.apache.kafka.connect.runtime.rest.entities.Message>):boolean \t org.apache.kafka.connect.storage.ClusterConfigState"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.standalone.StandaloneHerder",
    "source_method": "startConnector",
    "target_class": "org.apache.kafka.connect.util.Callback<org.apache.kafka.connect.runtime.TargetState>):void \t org.apache.kafka.connect.storage.ClusterConfigState"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.standalone.StandaloneHerder",
    "source_method": "createConnectorTasks",
    "target_class": "org.apache.kafka.connect.storage.ClusterConfigState"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.standalone.StandaloneHerder",
    "source_method": "createConnectorTasks",
    "target_class": "java.util.Collection<org.apache.kafka.connect.util.ConnectorTaskId>):void \t org.apache.kafka.connect.storage.ClusterConfigState"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.standalone.StandaloneHerder",
    "source_method": "removeConnectorTasks",
    "target_class": "org.apache.kafka.connect.storage.ClusterConfigState"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.SourceConnectorConfig",
    "source_method": "configDef",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.SourceConnectorConfig",
    "source_method": "embedDefaultGroup",
    "target_class": "org.apache.kafka.connect.runtime.TopicCreationConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.SourceConnectorConfig",
    "source_method": "enrich",
    "target_class": "java.util.Map<java.lang.String,java.lang.String>, org.apache.kafka.common.config.AbstractConfig):org.apache.kafka.common.config.ConfigDef \t org.apache.kafka.connect.runtime.TopicCreationConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerMetricsGroup",
    "source_method": "recordConnectorStartupFailure",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerMetricsGroup",
    "source_method": "recordConnectorStartupSuccess",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerMetricsGroup",
    "source_method": "recordTaskFailure",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerMetricsGroup",
    "source_method": "recordTaskSuccess",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.RestartPlan",
    "source_method": "shouldRestartConnector",
    "target_class": "org.apache.kafka.connect.runtime.rest.entities.ConnectorStateInfo"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.RestartPlan",
    "source_method": "totalTaskCount",
    "target_class": "org.apache.kafka.connect.runtime.rest.entities.ConnectorStateInfo"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.RestartPlan",
    "source_method": "isRestarting",
    "target_class": "org.apache.kafka.connect.runtime.rest.entities.ConnectorStateInfo.AbstractState"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerConfigTransformer",
    "source_method": "transform",
    "target_class": "java.util.Map<java.lang.String,java.lang.String>):java.util.Map<java.lang.String,java.lang.String> \t org.apache.kafka.common.config.ConfigTransformerResult"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.SinkConnectorConfig",
    "source_method": "validate",
    "target_class": "org.apache.kafka.common.config.ConfigValue"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.SinkConnectorConfig",
    "source_method": "validate",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.common.config.ConfigValue>):void \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.SinkConnectorConfig",
    "source_method": "addErrorMessage",
    "target_class": "java.lang.String, java.lang.String, java.lang.String):void \t org.apache.kafka.common.config.ConfigValue"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.SinkConnectorConfig",
    "source_method": "hasTopicsConfig",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.SinkConnectorConfig",
    "source_method": "hasDlqTopicConfig",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.SinkConnectorConfig",
    "source_method": "parseTopicsList",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.IncrementalCooperativeConnectProtocol",
    "source_method": "serializeMetadata",
    "target_class": "boolean):java.nio.ByteBuffer \t org.apache.kafka.connect.runtime.distributed.ConnectProtocol.WorkerState"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.IncrementalCooperativeConnectProtocol",
    "source_method": "metadataRequest",
    "target_class": "boolean):org.apache.kafka.connect.runtime.distributed.JoinGroupRequestProtocolCollection \t org.apache.kafka.connect.runtime.distributed.ConnectProtocol"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.IncrementalCooperativeConnectProtocol",
    "source_method": "serializeAssignment",
    "target_class": "boolean):java.nio.ByteBuffer \t org.apache.kafka.connect.runtime.distributed.ExtendedAssignment"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.IncrementalCooperativeConnectProtocol",
    "source_method": "deserializeAssignment",
    "target_class": "org.apache.kafka.connect.runtime.distributed.ExtendedAssignment"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.ConnectProtocol",
    "source_method": "serializeMetadata",
    "target_class": "org.apache.kafka.common.protocol.types.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.ConnectProtocol",
    "source_method": "serializeAssignment",
    "target_class": "org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.ConnectProtocol",
    "source_method": "deserializeAssignment",
    "target_class": "org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.IncrementalCooperativeAssignor",
    "source_method": "computePreviousAssignment",
    "target_class": "java.util.Map<java.lang.String,java.util.Collection<java.lang.String>>, java.util.Map<java.lang.String,java.util.Collection<org.apache.kafka.connect.util.ConnectorTaskId>>, org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks):org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks \t org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.IncrementalCooperativeAssignor",
    "source_method": "diff",
    "target_class": "org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks[]):org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks \t org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.IncrementalCooperativeAssignor",
    "source_method": "workerAssignment",
    "target_class": "org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks):java.util.List<org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.WorkerLoad> \t org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.IncrementalCooperativeAssignor",
    "source_method": "addAll",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks>):void \t org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks.Builder"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.IncrementalCooperativeAssignor",
    "source_method": "buildAll",
    "target_class": "org.apache.kafka.connect.util.ConnectUtils"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.IncrementalCooperativeAssignor",
    "source_method": "workerLoads",
    "target_class": "org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.IncrementalCooperativeAssignor",
    "source_method": "removeAll",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks>):void \t org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.IncrementalCooperativeAssignor",
    "source_method": "intersection",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks>):java.util.Map<java.lang.String,org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks> \t org.apache.kafka.connect.util.ConnectUtils"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.WorkerGroupMember",
    "source_method": "ensureActive",
    "target_class": "org.apache.kafka.connect.runtime.distributed.WorkerCoordinator"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.WorkerGroupMember",
    "source_method": "wakeup",
    "target_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.WorkerGroupMember",
    "source_method": "requestRejoin",
    "target_class": "org.apache.kafka.connect.runtime.distributed.WorkerCoordinator"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.ExtendedAssignment",
    "source_method": "revokedAsMap",
    "target_class": "org.apache.kafka.connect.util.ConnectorTaskId"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.ExtendedAssignment",
    "source_method": "taskAssignments",
    "target_class": "org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.ExtendedAssignment",
    "source_method": "extractConnectors",
    "target_class": "java.lang.String):java.util.Collection<java.lang.String> \t org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.ExtendedAssignment",
    "source_method": "extractTasks",
    "target_class": "java.lang.String):java.util.Collection<org.apache.kafka.connect.util.ConnectorTaskId> \t org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.DistributedHerder",
    "source_method": "validateSinkConnectorGroupId",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.common.config.ConfigValue>):void \t org.apache.kafka.common.config.ConfigValue"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.DistributedHerder",
    "source_method": "connectorUsesSeparateOffsetsTopicClients",
    "target_class": "java.util.Map<java.lang.String,java.lang.String>):boolean \t org.apache.kafka.connect.runtime.distributed.DistributedConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.DistributedHerder",
    "source_method": "isLeader",
    "target_class": "org.apache.kafka.connect.runtime.distributed.WorkerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.DistributedHerder",
    "source_method": "getTaskStoppingCallable",
    "target_class": "org.apache.kafka.connect.runtime.Worker"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.DistributedHerder",
    "source_method": "writeTaskConfigs",
    "target_class": "java.util.List<java.util.Map<java.lang.String,java.lang.String>>):void \t org.apache.kafka.connect.storage.ClusterConfigState"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.DistributedHerder",
    "source_method": "verifyTaskGenerationAndOwnership",
    "target_class": "int, org.apache.kafka.connect.util.Callback<java.lang.Void>):java.lang.Void \t org.apache.kafka.connect.storage.ClusterConfigState"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.DistributedHerder",
    "source_method": "checkRebalanceNeeded",
    "target_class": "org.apache.kafka.connect.util.Callback"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.DistributedHerder",
    "source_method": "addRequest",
    "target_class": "java.util.concurrent.Callable<java.lang.Void>, org.apache.kafka.connect.util.Callback<java.lang.Void>):org.apache.kafka.connect.runtime.distributed.DistributedHerder.DistributedHerderRequest \t org.apache.kafka.connect.runtime.distributed.WorkerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.DistributedHerder",
    "source_method": "runRequest",
    "target_class": "org.apache.kafka.connect.util.Callback<java.lang.Void>):void \t org.apache.kafka.connect.util.Callback"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.DistributedHerder",
    "source_method": "internalRequestValidationEnabled",
    "target_class": "org.apache.kafka.connect.runtime.distributed.WorkerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.DistributedHerder",
    "source_method": "updateDeletedTaskStatus",
    "target_class": "org.apache.kafka.connect.storage.ClusterConfigState"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.DistributedHerder",
    "source_method": "requestNotSignedProperly",
    "target_class": "org.apache.kafka.connect.util.Callback<?>):boolean \t org.apache.kafka.connect.runtime.rest.InternalRequestSignature"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.DistributedHerder.ZombieFencing",
    "source_method": "addCallback",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.DistributedHerder.HerderMetrics",
    "source_method": "rebalanceSucceeded",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.DistributedConfig",
    "source_method": "config",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.WorkerCoordinator",
    "source_method": "revokeAssignment",
    "target_class": "org.apache.kafka.connect.runtime.distributed.WorkerRebalanceListener"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.WorkerCoordinator",
    "source_method": "configFreshSnapshot",
    "target_class": "org.apache.kafka.connect.storage.ConfigBackingStore"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks.Builder",
    "source_method": "addAll",
    "target_class": "org.apache.kafka.connect.runtime.distributed.WorkerCoordinator.ConnectorsAndTasks"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.Plugins",
    "source_method": "initLoaders",
    "target_class": "org.apache.kafka.connect.runtime.isolation.PluginDiscoveryMode):org.apache.kafka.connect.runtime.isolation.PluginScanResult \t org.apache.kafka.connect.runtime.isolation.DelegatingClassLoader"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.Plugins",
    "source_method": "maybeReportHybridDiscoveryIssue",
    "target_class": "org.apache.kafka.connect.runtime.isolation.PluginScanResult, org.apache.kafka.connect.runtime.isolation.PluginScanResult):void \t org.apache.kafka.connect.runtime.isolation.PluginDesc"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.Plugins",
    "source_method": "pluginClassFromConfig",
    "target_class": "java.lang.String, java.lang.Class<U>, java.util.Collection<org.apache.kafka.connect.runtime.isolation.PluginDesc<U>>):java.lang.Class<? extends U> \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.Plugins",
    "source_method": "pluginClass",
    "target_class": "java.lang.String, java.lang.Class<U>):java.lang.Class<? extends U> \t org.apache.kafka.connect.runtime.isolation.DelegatingClassLoader"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.Plugins",
    "source_method": "connectorClass",
    "target_class": "extends org.apache.kafka.connect.connector.Connector> \t org.apache.kafka.connect.runtime.isolation.PluginDesc"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.Plugins",
    "source_method": "newConfigProvider",
    "target_class": "java.lang.String, org.apache.kafka.connect.runtime.isolation.Plugins.ClassLoaderUsage):org.apache.kafka.common.config.provider.ConfigProvider \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.Plugins",
    "source_method": "newPlugin",
    "target_class": "org.apache.kafka.common.config.AbstractConfig, java.lang.Class<T>):T \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.PluginScanner",
    "source_method": "pluginDesc",
    "target_class": "extends T>, java.lang.String, org.apache.kafka.connect.runtime.isolation.PluginType, org.apache.kafka.connect.runtime.isolation.PluginSource):org.apache.kafka.connect.runtime.isolation.PluginDesc<T> \t org.apache.kafka.connect.runtime.isolation.PluginSource"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.PluginScanner",
    "source_method": "versionFor",
    "target_class": "org.apache.kafka.connect.runtime.isolation.PluginDesc"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.PluginUtils",
    "source_method": "isolatedPluginSource",
    "target_class": "java.lang.ClassLoader, org.apache.kafka.connect.runtime.isolation.PluginClassLoaderFactory):org.apache.kafka.connect.runtime.isolation.PluginSource \t org.apache.kafka.connect.runtime.isolation.PluginClassLoaderFactory"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.PluginUtils",
    "source_method": "classpathPluginSource",
    "target_class": "org.apache.kafka.connect.runtime.isolation.PluginSource.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.PluginUtils",
    "source_method": "simpleName",
    "target_class": "org.apache.kafka.connect.runtime.isolation.PluginDesc"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.PluginUtils",
    "source_method": "prunedName",
    "target_class": "org.apache.kafka.connect.runtime.isolation.PluginDesc"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.PluginUtils",
    "source_method": "prunePluginName",
    "target_class": "java.lang.String):java.lang.String \t org.apache.kafka.connect.runtime.isolation.PluginDesc"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.PluginUtils",
    "source_method": "computeAliases",
    "target_class": "org.apache.kafka.connect.runtime.isolation.PluginDesc"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.isolation.DelegatingClassLoader",
    "source_method": "computePluginLoaders",
    "target_class": "org.apache.kafka.connect.runtime.isolation.PluginDesc"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractWorkerSourceTask",
    "source_method": "closeProducer",
    "target_class": "org.apache.kafka.clients.producer.Producer"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractWorkerSourceTask",
    "source_method": "convertHeaderFor",
    "target_class": "org.apache.kafka.connect.storage.HeaderConverter"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractWorkerSourceTask",
    "source_method": "recordPollReturned",
    "target_class": "long):void \t org.apache.kafka.connect.runtime.AbstractWorkerSourceTask.SourceTaskMetricsGroup"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractWorkerSourceTask.SourceRecordWriteCounter",
    "source_method": "finishedAllWrites",
    "target_class": "org.apache.kafka.connect.runtime.AbstractWorkerSourceTask.SourceTaskMetricsGroup"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractWorkerSourceTask.SourceTaskMetricsGroup",
    "source_method": "recordPoll",
    "target_class": "long):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractWorkerSourceTask.SourceTaskMetricsGroup",
    "source_method": "recordWrite",
    "target_class": "int):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerConfig",
    "source_method": "baseConfigDef",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerConfig",
    "source_method": "addTopicTrackingConfig",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerConfig",
    "source_method": "lookupKafkaClusterId",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerConfig",
    "source_method": "pluginDiscovery",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSinkTask",
    "source_method": "commitOffsets",
    "target_class": "boolean):void \t org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSinkTask",
    "source_method": "pollConsumer",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSinkTask",
    "source_method": "convertHeadersFor",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerRecord"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSinkTask",
    "source_method": "resumeAll",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSinkTask",
    "source_method": "pauseAll",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSinkTask",
    "source_method": "openPartitions",
    "target_class": "org.apache.kafka.connect.sink.SinkTask"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSinkTask",
    "source_method": "updatePartitionCount",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSinkTask.SinkTaskMetricsGroup",
    "source_method": "computeSinkRecordLag",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSinkTask.SinkTaskMetricsGroup",
    "source_method": "recordRead",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSinkTask.SinkTaskMetricsGroup",
    "source_method": "recordSend",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSinkTask.SinkTaskMetricsGroup",
    "source_method": "recordPut",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSinkTask.SinkTaskMetricsGroup",
    "source_method": "recordPartitionCount",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSinkTask.SinkTaskMetricsGroup",
    "source_method": "recordOffsetSequenceNumber",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSinkTask.SinkTaskMetricsGroup",
    "source_method": "recordOffsetCommitSuccess",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerSinkTask.SinkTaskMetricsGroup",
    "source_method": "recordOffsetCommitSkip",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.TopicCreationConfig",
    "source_method": "validatePartitions",
    "target_class": "int):void \t org.apache.kafka.connect.util.TopicAdmin"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.TopicCreationConfig",
    "source_method": "validateReplicationFactor",
    "target_class": "short):void \t org.apache.kafka.connect.util.TopicAdmin"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.TopicCreationConfig",
    "source_method": "configDef",
    "target_class": "short, int):org.apache.kafka.common.config.ConfigDef \t org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.TopicCreationConfig",
    "source_method": "defaultGroupConfigDef",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerConnector",
    "source_method": "resume",
    "target_class": "org.apache.kafka.connect.runtime.ConnectorStatus.Listener"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerConnector",
    "source_method": "start",
    "target_class": "org.apache.kafka.connect.runtime.ConnectorStatus.Listener"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerTask",
    "source_method": "cancel",
    "target_class": "org.apache.kafka.connect.runtime.errors.RetryWithToleranceOperator"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerTask",
    "source_method": "doStart",
    "target_class": "org.apache.kafka.connect.runtime.TaskStatus.Listener"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerTask",
    "source_method": "recordActiveTopic",
    "target_class": "org.apache.kafka.connect.util.ConnectorTaskId"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerTask",
    "source_method": "recordCommitSuccess",
    "target_class": "org.apache.kafka.connect.runtime.WorkerTask.TaskMetricsGroup"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerTask",
    "source_method": "recordCommitFailure",
    "target_class": "java.lang.Throwable):void \t org.apache.kafka.connect.runtime.WorkerTask.TaskMetricsGroup"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerTask",
    "source_method": "recordBatch",
    "target_class": "org.apache.kafka.connect.runtime.WorkerTask.TaskMetricsGroup"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerTask.TaskMetricsGroup",
    "source_method": "addRatioMetric",
    "target_class": "org.apache.kafka.common.MetricNameTemplate):void \t org.apache.kafka.connect.runtime.ConnectMetrics.MetricGroup"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerTask.TaskMetricsGroup",
    "source_method": "recordCommit",
    "target_class": "boolean, java.lang.Throwable):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerTask.TaskMetricsGroup",
    "source_method": "recordBatch",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerTask.TaskMetricsGroup",
    "source_method": "recordState",
    "target_class": "org.apache.kafka.connect.runtime.StateTracker"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.WorkerTask.TaskMetricsGroup",
    "source_method": "state",
    "target_class": "org.apache.kafka.connect.runtime.StateTracker"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.InternalRequestSignature",
    "source_method": "fromHeaders",
    "target_class": "byte[], org.apache.kafka.connect.runtime.rest.HttpHeaders):org.apache.kafka.connect.runtime.rest.InternalRequestSignature \t org.apache.kafka.connect.runtime.distributed.Crypto"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.RestServer",
    "source_method": "requestTimeout",
    "target_class": "org.apache.kafka.connect.runtime.rest.RestServer.RequestTimeout"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.RestServer",
    "source_method": "determineAdvertisedProtocol",
    "target_class": "org.apache.kafka.connect.runtime.rest.RestServerConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.RestServer",
    "source_method": "registerRestExtensions",
    "target_class": "org.apache.kafka.connect.runtime.rest.ResourceConfig):void \t org.apache.kafka.connect.runtime.Herder"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.RestServerConfig",
    "source_method": "addPublicConfig",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.RestServerConfig",
    "source_method": "addInternalConfig",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.RestServerConfig.InternalConfig",
    "source_method": "config",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.RestServerConfig.PublicConfig",
    "source_method": "config",
    "target_class": "org.apache.kafka.connect.runtime.WorkerConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.resources.ConnectorsResource",
    "source_method": "getConnector",
    "target_class": "org.apache.kafka.connect.runtime.rest.HerderRequestHandler"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.resources.ConnectorsResource",
    "source_method": "getConnectorConfig",
    "target_class": "org.apache.kafka.connect.runtime.rest.HerderRequestHandler"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.resources.ConnectorsResource",
    "source_method": "getConnectorStatus",
    "target_class": "org.apache.kafka.connect.runtime.Herder"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.resources.ConnectorsResource",
    "source_method": "stopConnector",
    "target_class": "org.apache.kafka.connect.runtime.rest.resources.HttpHeaders, java.lang.Boolean):void \t org.apache.kafka.connect.runtime.rest.HerderRequestHandler"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.resources.ConnectorsResource",
    "source_method": "getTaskConfigs",
    "target_class": "org.apache.kafka.connect.runtime.rest.HerderRequestHandler"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.resources.ConnectorsResource",
    "source_method": "getTaskStatus",
    "target_class": "org.apache.kafka.connect.runtime.rest.resources.HttpHeaders, java.lang.Integer):org.apache.kafka.connect.runtime.rest.entities.ConnectorStateInfo.TaskState \t org.apache.kafka.connect.runtime.Herder"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.resources.ConnectorsResource",
    "source_method": "restartTask",
    "target_class": "java.lang.Integer, org.apache.kafka.connect.runtime.rest.resources.HttpHeaders, java.lang.Boolean):void \t org.apache.kafka.connect.runtime.rest.HerderRequestHandler"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.resources.ConnectorsResource",
    "source_method": "destroyConnector",
    "target_class": "org.apache.kafka.connect.runtime.rest.resources.HttpHeaders, java.lang.Boolean):void \t org.apache.kafka.connect.runtime.rest.HerderRequestHandler"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.resources.ConnectorsResource",
    "source_method": "getOffsets",
    "target_class": "org.apache.kafka.connect.runtime.rest.HerderRequestHandler"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.resources.RootResource",
    "source_method": "serverInfo",
    "target_class": "org.apache.kafka.connect.runtime.Herder"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.resources.ConnectorPluginsResource",
    "source_method": "listConnectorPlugins",
    "target_class": "org.apache.kafka.connect.runtime.rest.entities.PluginInfo"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.resources.ConnectorPluginsResource",
    "source_method": "getConnectorConfigDef",
    "target_class": "org.apache.kafka.connect.runtime.Herder"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.util.SSLUtils",
    "source_method": "configureSslContextFactoryKeyStore",
    "target_class": "java.util.Map<java.lang.String,java.lang.Object>):void \t org.apache.kafka.common.config.types.Password"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.util.SSLUtils",
    "source_method": "configureSslContextFactoryTrustStore",
    "target_class": "java.util.Map<java.lang.String,java.lang.Object>):void \t org.apache.kafka.common.config.types.Password"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.util.SSLUtils",
    "source_method": "configureSslContextFactoryAlgorithms",
    "target_class": "java.util.Map<java.lang.String,java.lang.Object>):void \t org.apache.kafka.common.config.SslConfigs"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.rest.util.SSLUtils",
    "source_method": "configureSslContextFactoryEndpointIdentification",
    "target_class": "java.util.Map<java.lang.String,java.lang.Object>):void \t org.apache.kafka.common.config.SslConfigs"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "startServices",
    "target_class": "org.apache.kafka.connect.storage.StatusBackingStore"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "buildTasksConfig",
    "target_class": "org.apache.kafka.connect.storage.ClusterConfigState"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "validateSinkConnectorConfig",
    "target_class": "org.apache.kafka.common.config.ConfigDef, java.util.Map<java.lang.String,java.lang.String>):java.util.Map<java.lang.String,org.apache.kafka.common.config.ConfigValue> \t org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "validateSourceConnectorConfig",
    "target_class": "org.apache.kafka.common.config.ConfigDef, java.util.Map<java.lang.String,java.lang.String>):java.util.Map<java.lang.String,org.apache.kafka.common.config.ConfigValue> \t org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "buildRestartPlan",
    "target_class": "org.apache.kafka.connect.runtime.RestartRequest"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "connectorUsesConsumer",
    "target_class": "java.util.Map<java.lang.String,java.lang.String>):boolean \t org.apache.kafka.connect.health.ConnectorType"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "connectorUsesAdmin",
    "target_class": "java.util.Map<java.lang.String,java.lang.String>):boolean \t org.apache.kafka.connect.health.ConnectorType"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "connectorUsesProducer",
    "target_class": "java.util.Map<java.lang.String,java.lang.String>):boolean \t org.apache.kafka.connect.health.ConnectorType"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "mergeConfigInfos",
    "target_class": "org.apache.kafka.connect.runtime.rest.entities.ConfigInfos[]):org.apache.kafka.connect.runtime.rest.entities.ConfigInfos \t org.apache.kafka.connect.runtime.rest.entities.ConfigInfos"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "validateClientOverrides",
    "target_class": "java.lang.String, org.apache.kafka.common.config.AbstractConfig, org.apache.kafka.common.config.ConfigDef, java.lang.Class<? extends org.apache.kafka.connect.connector.Connector>, org.apache.kafka.connect.health.ConnectorType, org.apache.kafka.connect.connector.policy.ConnectorClientConfigRequest.ClientType, org.apache.kafka.connect.connector.policy.ConnectorClientConfigOverridePolicy):org.apache.kafka.connect.runtime.rest.entities.ConfigInfos \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "prefixedConfigInfos",
    "target_class": "java.util.List<org.apache.kafka.common.config.ConfigValue>, java.lang.String):org.apache.kafka.connect.runtime.rest.entities.ConfigInfos \t org.apache.kafka.common.config.ConfigValue"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "generateResult",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.common.config.ConfigDef.ConfigKey>, java.util.List<org.apache.kafka.common.config.ConfigValue>, java.util.List<java.lang.String>):org.apache.kafka.connect.runtime.rest.entities.ConfigInfos \t org.apache.kafka.common.config.ConfigValue"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "convertConfigKey",
    "target_class": "java.lang.String):org.apache.kafka.connect.runtime.rest.entities.ConfigKeyInfo \t org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "convertConfigValue",
    "target_class": "org.apache.kafka.common.config.ConfigDef.Type):org.apache.kafka.connect.runtime.rest.entities.ConfigValueInfo \t org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "maybeAddConfigErrors",
    "target_class": "org.apache.kafka.connect.util.Callback<org.apache.kafka.connect.runtime.Herder.Created<org.apache.kafka.connect.runtime.rest.entities.ConnectorInfo>>):boolean \t org.apache.kafka.connect.runtime.rest.entities.ConfigInfos"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "reverseTransform",
    "target_class": "org.apache.kafka.connect.storage.ClusterConfigState, java.util.List<java.util.Map<java.lang.String,java.lang.String>>):java.util.List<java.util.Map<java.lang.String,java.lang.String>> \t org.apache.kafka.common.config.ConfigTransformer"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.AbstractHerder",
    "source_method": "taskConfigsChanged",
    "target_class": "java.lang.String, java.util.List<java.util.Map<java.lang.String,java.lang.String>>):boolean \t org.apache.kafka.connect.storage.ClusterConfigState"
  },
  {
    "source_class": "org.apache.kafka.connect.runtime.ConnectMetrics.MetricGroupId",
    "source_method": "includes",
    "target_class": "org.apache.kafka.common.MetricName"
  },
  {
    "source_class": "org.apache.kafka.connect.tools.PredicateDoc",
    "source_method": "printPredicateHtml",
    "target_class": "org.apache.kafka.connect.tools.PredicateDoc.DocInfo):void \t org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.tools.TransformationDoc",
    "source_method": "printTransformationHtml",
    "target_class": "org.apache.kafka.connect.tools.TransformationDoc.DocInfo):void \t org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.HeaderFrom",
    "source_method": "moveSchema",
    "target_class": "org.apache.kafka.connect.data.SchemaBuilder"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.Flatten",
    "source_method": "buildUpdatedSchema",
    "target_class": "java.lang.String, org.apache.kafka.connect.data.SchemaBuilder, boolean, org.apache.kafka.connect.data.Struct):void \t org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.Flatten",
    "source_method": "convertFieldSchema",
    "target_class": "boolean, java.lang.Object):org.apache.kafka.connect.data.Schema \t org.apache.kafka.connect.data.SchemaBuilder"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.Flatten",
    "source_method": "buildWithSchema",
    "target_class": "java.lang.String, org.apache.kafka.connect.data.Struct):void \t org.apache.kafka.connect.data.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.Cast",
    "source_method": "getOrBuildSchema",
    "target_class": "org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.Cast",
    "source_method": "encodeLogicalType",
    "target_class": "java.lang.Object):java.lang.Object \t org.apache.kafka.connect.data.Time"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.Cast",
    "source_method": "castToString",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.Cast",
    "source_method": "parseFieldTypes",
    "target_class": "org.apache.kafka.connect.data.Schema.Type"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.field.FieldSyntaxVersion",
    "source_method": "appendConfigTo",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.field.FieldSyntaxVersion",
    "source_method": "fromConfig",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.field.SingleFieldPath",
    "source_method": "valueFrom",
    "target_class": "org.apache.kafka.connect.data.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.SetSchemaMetadata",
    "source_method": "updateSchemaIn",
    "target_class": "org.apache.kafka.connect.data.Schema):java.lang.Object \t org.apache.kafka.connect.data.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.ReplaceField",
    "source_method": "makeUpdatedSchema",
    "target_class": "org.apache.kafka.connect.data.SchemaBuilder"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.util.SchemaUtil",
    "source_method": "copySchemaBasics",
    "target_class": "org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.util.SchemaUtil",
    "source_method": "copySchemaBasics",
    "target_class": "org.apache.kafka.connect.data.SchemaBuilder):org.apache.kafka.connect.data.SchemaBuilder \t org.apache.kafka.connect.data.SchemaBuilder"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.TimestampConverter",
    "source_method": "applyValueWithSchema",
    "target_class": "org.apache.kafka.connect.data.Schema):org.apache.kafka.connect.data.Struct \t org.apache.kafka.connect.data.Struct"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.TimestampConverter",
    "source_method": "timestampTypeFromSchema",
    "target_class": "org.apache.kafka.connect.data.Schema"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.TimestampConverter",
    "source_method": "convertTimestamp",
    "target_class": "java.lang.String):java.lang.Object \t org.apache.kafka.connect.transforms.TimestampConverter.TimestampTranslator"
  },
  {
    "source_class": "org.apache.kafka.connect.transforms.InsertField",
    "source_method": "makeUpdatedSchema",
    "target_class": "org.apache.kafka.connect.data.SchemaBuilder"
  },
  {
    "source_class": "org.apache.kafka.jmh.storage.ProducerStateManagerBench",
    "source_method": "setup",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.jmh.storage.ProducerStateManagerBench",
    "source_method": "testDeleteExpiringIds",
    "target_class": "org.apache.kafka.storage.internals.log.ProducerStateManager"
  },
  {
    "source_class": "org.apache.kafka.jmh.timeline.TimelineHashMapBenchmark",
    "source_method": "testAddEntriesInTimelineMap",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.jmh.timeline.TimelineHashMapBenchmark",
    "source_method": "testAddEntriesWithSnapshots",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.jmh.connect.JsonConverterBenchmark.Data",
    "source_method": "buildValueSchema",
    "target_class": "org.apache.kafka.connect.data.SchemaBuilder"
  },
  {
    "source_class": "org.apache.kafka.jmh.connect.JsonConverterBenchmark.Data",
    "source_method": "buildSourceSchema",
    "target_class": "org.apache.kafka.connect.data.SchemaBuilder"
  },
  {
    "source_class": "org.apache.kafka.jmh.connect.JsonConverterBenchmark.Data",
    "source_method": "buildTransactionSchema",
    "target_class": "org.apache.kafka.connect.data.SchemaBuilder"
  },
  {
    "source_class": "org.apache.kafka.jmh.connect.ReplaceFieldBenchmark",
    "source_method": "includeExcludeReplaceFieldBenchmark",
    "target_class": "org.apache.kafka.connect.transforms.ReplaceField"
  },
  {
    "source_class": "org.apache.kafka.jmh.fetchsession.FetchSessionBenchmark",
    "source_method": "incrementalFetchSessionBuild",
    "target_class": "org.apache.kafka.clients.FetchSessionHandler"
  },
  {
    "source_class": "org.apache.kafka.jmh.common.ImplicitLinkedHashCollectionBenchmark",
    "source_method": "testCollectionSort",
    "target_class": "org.apache.kafka.common.utils.ImplicitLinkedHashCollection"
  },
  {
    "source_class": "org.apache.kafka.jmh.common.FetchResponseBenchmark",
    "source_method": "testSerializeFetchResponse",
    "target_class": "org.apache.kafka.common.requests.ByteBufferChannel"
  },
  {
    "source_class": "org.apache.kafka.jmh.common.FetchRequestBenchmark",
    "source_method": "testFetchRequestForConsumer",
    "target_class": "org.apache.kafka.common.requests.FetchRequest"
  },
  {
    "source_class": "org.apache.kafka.jmh.common.FetchRequestBenchmark",
    "source_method": "testFetchRequestForReplica",
    "target_class": "org.apache.kafka.common.requests.FetchRequest"
  },
  {
    "source_class": "org.apache.kafka.jmh.common.FetchRequestBenchmark",
    "source_method": "testSerializeFetchRequestForConsumer",
    "target_class": "org.apache.kafka.common.requests.ByteBufferChannel"
  },
  {
    "source_class": "org.apache.kafka.jmh.common.FetchRequestBenchmark",
    "source_method": "testSerializeFetchRequestForReplica",
    "target_class": "org.apache.kafka.common.requests.ByteBufferChannel"
  },
  {
    "source_class": "org.apache.kafka.jmh.consumer.SubscriptionStateBenchmark",
    "source_method": "testHasAllFetchPositions",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.jmh.consumer.SubscriptionStateBenchmark",
    "source_method": "testFetchablePartitions",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.jmh.consumer.SubscriptionStateBenchmark",
    "source_method": "testPartitionsNeedingValidation",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.jmh.producer.ProducerRequestBenchmark",
    "source_method": "request",
    "target_class": "org.apache.kafka.common.requests.ProduceRequest"
  },
  {
    "source_class": "org.apache.kafka.jmh.producer.ProducerRequestBenchmark",
    "source_method": "constructorErrorResponse",
    "target_class": "org.apache.kafka.common.requests.ProduceRequest"
  },
  {
    "source_class": "org.apache.kafka.jmh.cache.LRUCacheBenchmark",
    "source_method": "testCachePerformance",
    "target_class": "org.apache.kafka.common.cache.LRUCache"
  },
  {
    "source_class": "org.apache.kafka.jmh.util.ByteUtilsBenchmark",
    "source_method": "testUnsignedWriteVarintUnrolled",
    "target_class": "org.apache.kafka.jmh.util.ByteUtilsBenchmark.IterationStateForInt"
  },
  {
    "source_class": "org.apache.kafka.jmh.util.ByteUtilsBenchmark",
    "source_method": "testUnsignedWriteVarintLegacy",
    "target_class": "org.apache.kafka.jmh.util.ByteUtilsBenchmark.IterationStateForInt"
  },
  {
    "source_class": "org.apache.kafka.jmh.util.ByteUtilsBenchmark",
    "source_method": "testUnsignedWriteVarlongUnrolled",
    "target_class": "org.apache.kafka.jmh.util.ByteUtilsBenchmark.IterationStateForLong"
  },
  {
    "source_class": "org.apache.kafka.jmh.util.ByteUtilsBenchmark",
    "source_method": "testUnsignedWriteVarlongLegacy",
    "target_class": "org.apache.kafka.jmh.util.ByteUtilsBenchmark.IterationStateForLong"
  },
  {
    "source_class": "org.apache.kafka.jmh.assignor.AssignorBenchmarkUtils",
    "source_method": "computeInvertedTargetAssignment",
    "target_class": "org.apache.kafka.coordinator.group.api.assignor.GroupAssignment"
  },
  {
    "source_class": "org.apache.kafka.jmh.assignor.AssignorBenchmarkUtils",
    "source_method": "addTopic",
    "target_class": "org.apache.kafka.common.Uuid, java.lang.String, int):void \t org.apache.kafka.image.MetadataDelta"
  },
  {
    "source_class": "org.apache.kafka.jmh.assignor.TargetAssignmentBuilderBenchmark",
    "source_method": "setup",
    "target_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.jmh.assignor.TargetAssignmentBuilderBenchmark",
    "source_method": "generateMockSubscriptionMetadata",
    "target_class": "org.apache.kafka.image.MetadataDelta"
  },
  {
    "source_class": "org.apache.kafka.jmh.assignor.TargetAssignmentBuilderBenchmark",
    "source_method": "generateMockInitialTargetAssignmentAndUpdateInvertedTargetAssignment",
    "target_class": "org.apache.kafka.coordinator.group.consumer.TopicMetadata"
  },
  {
    "source_class": "org.apache.kafka.jmh.assignor.ClientSideAssignorBenchmark",
    "source_method": "subscriptionWithOwnedPartitions",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription):org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription \t org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription"
  },
  {
    "source_class": "org.apache.kafka.jmh.assignor.ClientSideAssignorBenchmark",
    "source_method": "simulateIncrementalRebalance",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerPartitionAssignor"
  },
  {
    "source_class": "org.apache.kafka.jmh.assignor.ClientSideAssignorBenchmark",
    "source_method": "doAssignment",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerPartitionAssignor"
  },
  {
    "source_class": "org.apache.kafka.jmh.assignor.ServerSideAssignorBenchmark",
    "source_method": "simulateIncrementalRebalance",
    "target_class": "org.apache.kafka.coordinator.group.api.assignor.GroupAssignment"
  },
  {
    "source_class": "org.apache.kafka.jmh.assignor.ServerSideAssignorBenchmark",
    "source_method": "doAssignment",
    "target_class": "org.apache.kafka.coordinator.group.api.assignor.PartitionAssignor"
  },
  {
    "source_class": "org.apache.kafka.jmh.acl.StandardAuthorizerUpdateBenchmark",
    "source_method": "tearDown",
    "target_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizer"
  },
  {
    "source_class": "org.apache.kafka.jmh.acl.StandardAuthorizerUpdateBenchmark",
    "source_method": "testAddAcl",
    "target_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizer"
  },
  {
    "source_class": "org.apache.kafka.jmh.acl.StandardAuthorizerUpdateBenchmark",
    "source_method": "aclsForResource",
    "target_class": "org.apache.kafka.common.security.auth.KafkaPrincipal"
  },
  {
    "source_class": "org.apache.kafka.jmh.acl.StandardAuthorizerUpdateBenchmark",
    "source_method": "withId",
    "target_class": "org.apache.kafka.metadata.authorizer.StandardAcl"
  },
  {
    "source_class": "org.apache.kafka.jmh.acl.StandardAuthorizerUpdateBenchmark",
    "source_method": "addAcls",
    "target_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizer"
  },
  {
    "source_class": "org.apache.kafka.jmh.acl.AuthorizerBenchmark",
    "source_method": "testAclsIterator",
    "target_class": "org.apache.kafka.server.authorizer.Authorizer"
  },
  {
    "source_class": "org.apache.kafka.jmh.acl.AuthorizerBenchmark",
    "source_method": "testAuthorizer",
    "target_class": "org.apache.kafka.server.authorizer.Authorizer"
  },
  {
    "source_class": "org.apache.kafka.jmh.acl.AuthorizerBenchmark",
    "source_method": "testAuthorizeByResourceType",
    "target_class": "org.apache.kafka.server.authorizer.Authorizer"
  },
  {
    "source_class": "org.apache.kafka.jmh.record.BaseRecordBatchBenchmark",
    "source_method": "createBatch",
    "target_class": "org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.jmh.metadata.TopicsImageSingleRecordChangeBenchmark",
    "source_method": "testTopicsDeltaSingleTopicAdd",
    "target_class": "org.apache.kafka.image.TopicsDelta"
  },
  {
    "source_class": "org.apache.kafka.jmh.metadata.TopicsImageZonalOutageBenchmark",
    "source_method": "testTopicsDeltaZonalOutage",
    "target_class": "org.apache.kafka.image.TopicsDelta"
  },
  {
    "source_class": "org.apache.kafka.jmh.metadata.TopicsImageSnapshotLoadBenchmark",
    "source_method": "testTopicsDeltaSnapshotLoad",
    "target_class": "org.apache.kafka.image.TopicsDelta"
  },
  {
    "source_class": "org.apache.kafka.message.Target",
    "source_method": "nonNullableCopy",
    "target_class": "org.apache.kafka.message.FieldSpec"
  },
  {
    "source_class": "org.apache.kafka.message.Target",
    "source_method": "arrayElementTarget",
    "target_class": "org.apache.kafka.message.FieldType.ArrayType"
  },
  {
    "source_class": "org.apache.kafka.message.FieldType.ArrayType",
    "source_method": "elementName",
    "target_class": "org.apache.kafka.message.FieldType"
  },
  {
    "source_class": "org.apache.kafka.message.FieldType",
    "source_method": "parse",
    "target_class": "org.apache.kafka.message.FieldType.RecordsFieldType"
  },
  {
    "source_class": "org.apache.kafka.message.FieldSpec",
    "source_method": "checkTagInvariants",
    "target_class": "org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.FieldSpec",
    "source_method": "versionsString",
    "target_class": "org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.FieldSpec",
    "source_method": "typeString",
    "target_class": "org.apache.kafka.message.FieldType"
  },
  {
    "source_class": "org.apache.kafka.message.FieldSpec",
    "source_method": "nullableVersionsString",
    "target_class": "org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.FieldSpec",
    "source_method": "taggedVersionsString",
    "target_class": "org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.FieldSpec",
    "source_method": "flexibleVersionsString",
    "target_class": "org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.FieldSpec",
    "source_method": "fieldDefault",
    "target_class": "org.apache.kafka.message.StructRegistry):java.lang.String \t org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.FieldSpec",
    "source_method": "validateNullDefault",
    "target_class": "org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.FieldSpec",
    "source_method": "fieldAbstractJavaType",
    "target_class": "org.apache.kafka.message.StructRegistry):java.lang.String \t org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.FieldSpec",
    "source_method": "concreteJavaType",
    "target_class": "org.apache.kafka.message.StructRegistry):java.lang.String \t org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generate",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "write",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateClassHeader",
    "target_class": "boolean, boolean):void \t org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateSubclasses",
    "target_class": "org.apache.kafka.message.StructSpec, org.apache.kafka.message.Versions, boolean):void \t org.apache.kafka.message.StructRegistry"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateHashSetZeroArgConstructor",
    "target_class": "org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateHashSetSizeArgConstructor",
    "target_class": "org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateHashSetIteratorConstructor",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateKeyElement",
    "target_class": "org.apache.kafka.message.StructSpec):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "commaSeparatedHashSetFieldAndTypes",
    "target_class": "org.apache.kafka.message.FieldSpec"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateCollectionDuplicateMethod",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateFieldDeclarations",
    "target_class": "boolean):void \t org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateFieldDeclaration",
    "target_class": "org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateUnknownTaggedFieldsAccessor",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateClassConstructors",
    "target_class": "org.apache.kafka.message.StructSpec, boolean):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateConstructorEpilogue",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateShortAccessor",
    "target_class": "short):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateStructReader",
    "target_class": "org.apache.kafka.message.Versions, boolean):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "primitiveReadExpression",
    "target_class": "org.apache.kafka.message.FieldType"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateClassWriter",
    "target_class": "org.apache.kafka.message.StructSpec, org.apache.kafka.message.Versions):void \t org.apache.kafka.message.VersionConditional"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateCheckForUnsupportedNumTaggedFields",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateVariableLengthArrayElementSize",
    "target_class": "java.lang.String, org.apache.kafka.message.FieldType, org.apache.kafka.message.Versions):void \t org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateFixedLengthFieldSize",
    "target_class": "boolean):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateStringToBytes",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateClassEquals",
    "target_class": "org.apache.kafka.message.StructSpec, boolean):void \t org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateFieldEquals",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateClassHashCode",
    "target_class": "boolean):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateFieldHashCode",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateClassDuplicate",
    "target_class": "org.apache.kafka.message.StructSpec):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateClassToString",
    "target_class": "org.apache.kafka.message.StructSpec):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateFieldToString",
    "target_class": "org.apache.kafka.message.FieldSpec):void \t org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateFieldAccessor",
    "target_class": "org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateAccessor",
    "target_class": "java.lang.String, java.lang.String):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateFieldMutator",
    "target_class": "org.apache.kafka.message.FieldSpec):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "generateSetter",
    "target_class": "java.lang.String, java.lang.String):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MessageDataGenerator",
    "source_method": "fieldFlexibleVersions",
    "target_class": "org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.VersionConditional",
    "source_method": "generateFullRangeCheck",
    "target_class": "org.apache.kafka.message.Versions, org.apache.kafka.message.CodeBuffer):void \t org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.VersionConditional",
    "source_method": "generateLowerRangeCheck",
    "target_class": "org.apache.kafka.message.Versions, org.apache.kafka.message.CodeBuffer):void \t org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.VersionConditional",
    "source_method": "generateUpperRangeCheck",
    "target_class": "org.apache.kafka.message.Versions, org.apache.kafka.message.CodeBuffer):void \t org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.VersionConditional",
    "source_method": "generateAlwaysTrueCheck",
    "target_class": "org.apache.kafka.message.CodeBuffer):void \t org.apache.kafka.message.ClauseGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.VersionConditional",
    "source_method": "generateAlwaysFalseCheck",
    "target_class": "org.apache.kafka.message.CodeBuffer):void \t org.apache.kafka.message.ClauseGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.VersionConditional",
    "source_method": "generate",
    "target_class": "org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.MetadataRecordTypeGenerator",
    "source_method": "generateEnumValues",
    "target_class": "org.apache.kafka.message.MessageSpec"
  },
  {
    "source_class": "org.apache.kafka.message.MetadataRecordTypeGenerator",
    "source_method": "generateInstanceVariables",
    "target_class": "org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MetadataRecordTypeGenerator",
    "source_method": "generateEnumConstructor",
    "target_class": "org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MetadataRecordTypeGenerator",
    "source_method": "generateFromApiKey",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MetadataRecordTypeGenerator",
    "source_method": "generateNewMetadataRecord",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MetadataRecordTypeGenerator",
    "source_method": "generateAccessor",
    "target_class": "java.lang.String):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MetadataRecordTypeGenerator",
    "source_method": "generateToString",
    "target_class": "org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.MetadataRecordTypeGenerator",
    "source_method": "write",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.StructSpec",
    "source_method": "versionsString",
    "target_class": "org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.MessageGenerator",
    "source_method": "processDirectories",
    "target_class": "java.lang.String, java.lang.String, java.util.List<java.lang.String>, java.util.List<java.lang.String>):void \t org.apache.kafka.message.TypeClassGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.ApiMessageTypeGenerator.ApiData",
    "source_method": "name",
    "target_class": "org.apache.kafka.message.MessageSpec"
  },
  {
    "source_class": "org.apache.kafka.message.ApiMessageTypeGenerator.ApiData",
    "source_method": "requestSchema",
    "target_class": "org.apache.kafka.message.MessageSpec"
  },
  {
    "source_class": "org.apache.kafka.message.ApiMessageTypeGenerator.ApiData",
    "source_method": "responseSchema",
    "target_class": "org.apache.kafka.message.MessageSpec"
  },
  {
    "source_class": "org.apache.kafka.message.ApiMessageTypeGenerator",
    "source_method": "generateInstanceVariables",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.ApiMessageTypeGenerator",
    "source_method": "generateEnumConstructor",
    "target_class": "org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.ApiMessageTypeGenerator",
    "source_method": "generateFromApiKey",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.ApiMessageTypeGenerator",
    "source_method": "generateNewApiMessageMethod",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.ApiMessageTypeGenerator",
    "source_method": "generateAccessor",
    "target_class": "java.lang.String):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.ApiMessageTypeGenerator",
    "source_method": "generateToString",
    "target_class": "org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.ApiMessageTypeGenerator",
    "source_method": "generateHeaderVersion",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.ApiMessageTypeGenerator",
    "source_method": "generateListenerTypesEnum",
    "target_class": "org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.ApiMessageTypeGenerator",
    "source_method": "generateHighestSupportedVersion",
    "target_class": "org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.ApiMessageTypeGenerator",
    "source_method": "write",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MetadataJsonConvertersGenerator",
    "source_method": "generateWriteJson",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MetadataJsonConvertersGenerator",
    "source_method": "generateReadJson",
    "target_class": "org.apache.kafka.message.HeaderGenerator"
  },
  {
    "source_class": "org.apache.kafka.message.MessageSpec",
    "source_method": "validVersions",
    "target_class": "org.apache.kafka.message.StructSpec"
  },
  {
    "source_class": "org.apache.kafka.message.MessageSpec",
    "source_method": "validVersionsString",
    "target_class": "org.apache.kafka.message.StructSpec"
  },
  {
    "source_class": "org.apache.kafka.message.MessageSpec",
    "source_method": "flexibleVersionsString",
    "target_class": "org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.MessageSpec",
    "source_method": "dataClassName",
    "target_class": "org.apache.kafka.message.StructSpec"
  },
  {
    "source_class": "org.apache.kafka.message.HeaderGenerator",
    "source_method": "generate",
    "target_class": "org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.SchemaGenerator",
    "source_method": "generateTaggedFieldsSchemaForVersion",
    "target_class": "short, org.apache.kafka.message.CodeBuffer):void \t org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.SchemaGenerator",
    "source_method": "fieldTypeToSchemaType",
    "target_class": "short, org.apache.kafka.message.Versions):java.lang.String \t org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.SchemaGenerator",
    "source_method": "writeSchema",
    "target_class": "org.apache.kafka.message.CodeBuffer):void \t org.apache.kafka.message.Versions"
  },
  {
    "source_class": "org.apache.kafka.message.JsonConverterGenerator",
    "source_method": "generateRead",
    "target_class": "org.apache.kafka.message.StructSpec, org.apache.kafka.message.Versions):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.JsonConverterGenerator",
    "source_method": "generateTargetFromJson",
    "target_class": "org.apache.kafka.message.Versions):void \t org.apache.kafka.message.Target"
  },
  {
    "source_class": "org.apache.kafka.message.JsonConverterGenerator",
    "source_method": "generateVariableLengthTargetFromJson",
    "target_class": "org.apache.kafka.message.Versions):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.JsonConverterGenerator",
    "source_method": "generateOverloadWrite",
    "target_class": "org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.JsonConverterGenerator",
    "source_method": "generateWrite",
    "target_class": "org.apache.kafka.message.StructSpec, org.apache.kafka.message.Versions):void \t org.apache.kafka.message.VersionConditional"
  },
  {
    "source_class": "org.apache.kafka.message.JsonConverterGenerator",
    "source_method": "generateTargetToJson",
    "target_class": "org.apache.kafka.message.Versions):void \t org.apache.kafka.message.Target"
  },
  {
    "source_class": "org.apache.kafka.message.JsonConverterGenerator",
    "source_method": "generateVariableLengthTargetToJson",
    "target_class": "org.apache.kafka.message.Versions):void \t org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.message.StructRegistry",
    "source_method": "findStruct",
    "target_class": "org.apache.kafka.message.FieldType.ArrayType"
  },
  {
    "source_class": "org.apache.kafka.message.StructRegistry",
    "source_method": "isStructArrayWithKeys",
    "target_class": "org.apache.kafka.message.FieldType.ArrayType"
  },
  {
    "source_class": "org.apache.kafka.message.IsNullConditional",
    "source_method": "generate",
    "target_class": "org.apache.kafka.message.CodeBuffer"
  },
  {
    "source_class": "org.apache.kafka.timeline.SnapshotRegistry",
    "source_method": "iterator",
    "target_class": "org.apache.kafka.timeline.Snapshot"
  },
  {
    "source_class": "org.apache.kafka.timeline.SnapshotRegistry",
    "source_method": "latestEpoch",
    "target_class": "org.apache.kafka.timeline.Snapshot"
  },
  {
    "source_class": "org.apache.kafka.admin.AdminUtils",
    "source_method": "assignReplicasToBrokersRackAware",
    "target_class": "int, java.util.Collection<org.apache.kafka.admin.BrokerMetadata>, int, int):java.util.Map<java.lang.Integer,java.util.List<java.lang.Integer>> \t org.apache.kafka.admin.BrokerMetadata"
  },
  {
    "source_class": "org.apache.kafka.common.DirectoryId",
    "source_method": "reserved",
    "target_class": "org.apache.kafka.common.Uuid"
  },
  {
    "source_class": "org.apache.kafka.common.DirectoryId",
    "source_method": "isOnline",
    "target_class": "java.util.List<org.apache.kafka.common.Uuid>):boolean \t org.apache.kafka.common.Uuid"
  },
  {
    "source_class": "org.apache.kafka.queue.KafkaEventQueue.EventHandler",
    "source_method": "remove",
    "target_class": "org.apache.kafka.queue.KafkaEventQueue.EventContext"
  },
  {
    "source_class": "org.apache.kafka.security.EncryptingPasswordEncoder",
    "source_method": "secretKeySpec",
    "target_class": "java.lang.String, int, byte[], int):javax.crypto.spec.SecretKeySpec \t org.apache.kafka.common.config.types.Password"
  },
  {
    "source_class": "org.apache.kafka.server.common.serialization.BytesApiMessageSerde",
    "source_method": "serialize",
    "target_class": "org.apache.kafka.server.common.serialization.AbstractApiMessageSerde"
  },
  {
    "source_class": "org.apache.kafka.server.common.serialization.BytesApiMessageSerde",
    "source_method": "deserialize",
    "target_class": "org.apache.kafka.server.common.serialization.AbstractApiMessageSerde"
  },
  {
    "source_class": "org.apache.kafka.server.common.Features",
    "source_method": "fromFeatureLevel",
    "target_class": "boolean):org.apache.kafka.server.common.FeatureVersion \t org.apache.kafka.server.common.FeatureVersion"
  },
  {
    "source_class": "org.apache.kafka.server.common.Features",
    "source_method": "validateVersion",
    "target_class": "java.util.Map<java.lang.String,java.lang.Short>):void \t org.apache.kafka.server.common.MetadataVersion"
  },
  {
    "source_class": "org.apache.kafka.server.common.Features",
    "source_method": "defaultValue",
    "target_class": "org.apache.kafka.server.common.MetadataVersion"
  },
  {
    "source_class": "org.apache.kafka.server.network.EndpointReadyFutures.Builder",
    "source_method": "build",
    "target_class": "extends java.util.concurrent.CompletionStage<?>>, org.apache.kafka.server.authorizer.AuthorizerServerInfo):org.apache.kafka.server.network.EndpointReadyFutures \t org.apache.kafka.common.Endpoint"
  },
  {
    "source_class": "org.apache.kafka.server.util.timer.TimerTaskEntry",
    "source_method": "cancelled",
    "target_class": "org.apache.kafka.server.util.timer.TimerTask"
  },
  {
    "source_class": "org.apache.kafka.server.util.timer.TimerTaskEntry",
    "source_method": "remove",
    "target_class": "org.apache.kafka.server.util.timer.TimerTaskList"
  },
  {
    "source_class": "org.apache.kafka.server.util.timer.TimerTaskList",
    "source_method": "add",
    "target_class": "org.apache.kafka.server.util.timer.TimerTaskEntry"
  },
  {
    "source_class": "org.apache.kafka.server.util.timer.SystemTimer",
    "source_method": "addTimerTaskEntry",
    "target_class": "org.apache.kafka.server.util.timer.TimingWheel"
  },
  {
    "source_class": "org.apache.kafka.server.util.timer.TimerTask",
    "source_method": "setTimerTaskEntry",
    "target_class": "org.apache.kafka.server.util.timer.TimerTaskEntry"
  },
  {
    "source_class": "org.apache.kafka.server.util.Deadline",
    "source_method": "fromDelay",
    "target_class": "long, java.util.concurrent.TimeUnit):org.apache.kafka.server.util.Deadline \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.server.util.FutureUtils",
    "source_method": "waitWithLogging",
    "target_class": "java.lang.String, java.lang.String, java.util.concurrent.CompletableFuture<T>, org.apache.kafka.server.util.Deadline, org.apache.kafka.common.utils.Time):T \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.server.util.Json",
    "source_method": "tryParseBytes",
    "target_class": "org.apache.kafka.server.util.json.JsonValue"
  },
  {
    "source_class": "org.apache.kafka.server.util.Json",
    "source_method": "tryParseFull",
    "target_class": "org.apache.kafka.server.util.json.JsonValue"
  },
  {
    "source_class": "org.apache.kafka.server.util.CommandLineUtils",
    "source_method": "printUsageAndExit",
    "target_class": "java.lang.String):void \t org.apache.kafka.common.utils.Exit"
  },
  {
    "source_class": "org.apache.kafka.server.util.CommandLineUtils",
    "source_method": "printVersionAndExit",
    "target_class": "org.apache.kafka.common.utils.AppInfoParser"
  },
  {
    "source_class": "org.apache.kafka.server.util.InterBrokerSendThread",
    "source_method": "hasUnsentRequests",
    "target_class": "org.apache.kafka.server.util.InterBrokerSendThread.UnsentRequests"
  },
  {
    "source_class": "org.apache.kafka.server.util.InterBrokerSendThread",
    "source_method": "drainGeneratedRequests",
    "target_class": "org.apache.kafka.server.util.InterBrokerSendThread.UnsentRequests"
  },
  {
    "source_class": "org.apache.kafka.server.util.InterBrokerSendThread",
    "source_method": "sendRequests",
    "target_class": "long):long \t org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.server.util.InterBrokerSendThread",
    "source_method": "completeWithDisconnect",
    "target_class": "long, org.apache.kafka.common.errors.AuthenticationException):void \t org.apache.kafka.clients.ClientRequest"
  },
  {
    "source_class": "org.apache.kafka.server.util.InterBrokerSendThread.UnsentRequests",
    "source_method": "removeAllTimedOut",
    "target_class": "org.apache.kafka.clients.ClientRequest"
  },
  {
    "source_class": "org.apache.kafka.server.record.BrokerCompressionType",
    "source_method": "targetCompression",
    "target_class": "org.apache.kafka.common.record.CompressionType):org.apache.kafka.common.compress.Compression \t org.apache.kafka.common.compress.Compression"
  },
  {
    "source_class": "org.apache.kafka.server.metrics.KafkaMetricsGroup",
    "source_method": "toMBeanName",
    "target_class": "org.apache.kafka.common.utils.Sanitizer"
  },
  {
    "source_class": "org.apache.kafka.server.config.ServerTopicConfigSynonyms",
    "source_method": "sameName",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.server.config.ServerTopicConfigSynonyms",
    "source_method": "sameNameWithLogPrefix",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.server.config.ServerTopicConfigSynonyms",
    "source_method": "sameNameWithLogCleanerPrefix",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.server.config.ServerTopicConfigSynonyms",
    "source_method": "singleWithLogPrefix",
    "target_class": "java.lang.String):java.util.Map.Entry<java.lang.String,java.util.List<org.apache.kafka.server.config.ConfigSynonym>> \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.server.config.ServerTopicConfigSynonyms",
    "source_method": "singleWithLogCleanerPrefix",
    "target_class": "java.lang.String):java.util.Map.Entry<java.lang.String,java.util.List<org.apache.kafka.server.config.ConfigSynonym>> \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.server.config.ServerTopicConfigSynonyms",
    "source_method": "listWithLogPrefix",
    "target_class": "org.apache.kafka.server.config.ConfigSynonym[]):java.util.Map.Entry<java.lang.String,java.util.List<org.apache.kafka.server.config.ConfigSynonym>> \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.server.config.ServerTopicConfigSynonyms",
    "source_method": "single",
    "target_class": "java.lang.String):java.util.Map.Entry<java.lang.String,java.util.List<org.apache.kafka.server.config.ConfigSynonym>> \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.server.config.QuotaConfigs",
    "source_method": "buildUserClientQuotaConfigDef",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.server.config.QuotaConfigs",
    "source_method": "brokerQuotaConfigs",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.server.config.QuotaConfigs",
    "source_method": "scramMechanismsPlusUserAndClientQuotaConfigs",
    "target_class": "org.apache.kafka.common.security.scram.internals.ScramMechanism"
  },
  {
    "source_class": "org.apache.kafka.server.config.QuotaConfigs",
    "source_method": "ipConfigs",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.server.group.share.WriteShareGroupStateResult",
    "source_method": "from",
    "target_class": "org.apache.kafka.server.group.share.WriteShareGroupStateResult.Builder"
  },
  {
    "source_class": "org.apache.kafka.server.group.share.InitializeShareGroupStateParameters",
    "source_method": "from",
    "target_class": "org.apache.kafka.server.group.share.InitializeShareGroupStateParameters.Builder"
  },
  {
    "source_class": "org.apache.kafka.server.group.share.DeleteShareGroupStateResult",
    "source_method": "from",
    "target_class": "org.apache.kafka.server.group.share.DeleteShareGroupStateResult.Builder"
  },
  {
    "source_class": "org.apache.kafka.server.group.share.ReadShareGroupStateSummaryResult",
    "source_method": "from",
    "target_class": "org.apache.kafka.server.group.share.ReadShareGroupStateSummaryResult.Builder"
  },
  {
    "source_class": "org.apache.kafka.server.group.share.InitializeShareGroupStateResult",
    "source_method": "from",
    "target_class": "org.apache.kafka.server.group.share.InitializeShareGroupStateResult.Builder"
  },
  {
    "source_class": "org.apache.kafka.server.group.share.ReadShareGroupStateParameters",
    "source_method": "from",
    "target_class": "org.apache.kafka.server.group.share.ReadShareGroupStateParameters.Builder"
  },
  {
    "source_class": "org.apache.kafka.server.group.share.WriteShareGroupStateParameters",
    "source_method": "from",
    "target_class": "org.apache.kafka.server.group.share.WriteShareGroupStateParameters.Builder"
  },
  {
    "source_class": "org.apache.kafka.server.group.share.DeleteShareGroupStateParameters",
    "source_method": "from",
    "target_class": "org.apache.kafka.server.group.share.DeleteShareGroupStateParameters.Builder"
  },
  {
    "source_class": "org.apache.kafka.server.group.share.ReadShareGroupStateResult",
    "source_method": "from",
    "target_class": "org.apache.kafka.server.group.share.ReadShareGroupStateResult.Builder"
  },
  {
    "source_class": "org.apache.kafka.server.group.share.ReadShareGroupStateSummaryParameters",
    "source_method": "from",
    "target_class": "org.apache.kafka.server.group.share.ReadShareGroupStateSummaryParameters.Builder"
  },
  {
    "source_class": "org.apache.kafka.metadata.AssignmentsHelper",
    "source_method": "buildRequestData",
    "target_class": "long, java.util.Map<org.apache.kafka.server.common.TopicIdPartition,org.apache.kafka.common.Uuid>):org.apache.kafka.metadata.AssignReplicasToDirsRequestData \t org.apache.kafka.server.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.metadata.AssignmentsHelper",
    "source_method": "buildResponseData",
    "target_class": "int, java.util.Map<org.apache.kafka.common.Uuid,java.util.Map<org.apache.kafka.server.common.TopicIdPartition,org.apache.kafka.common.protocol.Errors>>):org.apache.kafka.metadata.AssignReplicasToDirsResponseData \t org.apache.kafka.server.common.TopicIdPartition"
  },
  {
    "source_class": "kafka.examples.Producer",
    "source_method": "asyncSend",
    "target_class": "int, java.lang.String):void \t org.apache.kafka.clients.producer.KafkaProducer"
  },
  {
    "source_class": "kafka.examples.Utils",
    "source_method": "maybePrintRecord",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerRecord<java.lang.Integer,java.lang.String>):void \t org.apache.kafka.clients.consumer.ConsumerRecord"
  },
  {
    "source_class": "kafka.examples.Utils",
    "source_method": "maybePrintRecord",
    "target_class": "int, java.lang.String, org.apache.kafka.clients.producer.RecordMetadata):void \t org.apache.kafka.clients.producer.RecordMetadata"
  },
  {
    "source_class": "kafka.examples.ExactlyOnceMessageProcessor",
    "source_method": "getOffsetsToCommit",
    "target_class": "org.apache.kafka.clients.consumer.KafkaConsumer"
  },
  {
    "source_class": "kafka.examples.ExactlyOnceMessageProcessor",
    "source_method": "getRemainingRecords",
    "target_class": "org.apache.kafka.clients.consumer.KafkaConsumer"
  },
  {
    "source_class": "kafka.examples.ExactlyOnceMessageProcessor",
    "source_method": "maybeRetry",
    "target_class": "org.apache.kafka.clients.consumer.KafkaConsumer<java.lang.Integer,java.lang.String>):int \t org.apache.kafka.clients.consumer.KafkaConsumer"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.OffsetAndMetadata",
    "source_method": "fromRecord",
    "target_class": "org.apache.kafka.coordinator.group.OffsetCommitValue):org.apache.kafka.coordinator.group.OffsetAndMetadata \t org.apache.kafka.coordinator.group.Utils"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.OffsetAndMetadata",
    "source_method": "fromRequest",
    "target_class": "long, java.util.OptionalLong):org.apache.kafka.coordinator.group.OffsetAndMetadata \t org.apache.kafka.coordinator.group.Utils"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.OffsetAndMetadata",
    "source_method": "fromRequest",
    "target_class": "long):org.apache.kafka.coordinator.group.OffsetAndMetadata \t org.apache.kafka.coordinator.group.Utils"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.Utils",
    "source_method": "toConsumerProtocolAssignment",
    "target_class": "org.apache.kafka.image.TopicsImage):org.apache.kafka.coordinator.group.ConsumerProtocolAssignment \t org.apache.kafka.image.TopicImage"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.Utils",
    "source_method": "toTopicPartitions",
    "target_class": "org.apache.kafka.image.TopicsImage):java.util.List<ConsumerGroupHeartbeatRequestData.TopicPartitions> \t org.apache.kafka.image.TopicImage"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.TargetAssignmentBuilder",
    "source_method": "build",
    "target_class": "org.apache.kafka.coordinator.group.consumer.Assignment"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.TargetAssignmentBuilder",
    "source_method": "newMemberAssignment",
    "target_class": "java.lang.String):org.apache.kafka.coordinator.group.consumer.Assignment \t org.apache.kafka.coordinator.group.api.assignor.GroupAssignment"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.TargetAssignmentBuilder",
    "source_method": "createMemberSubscriptionAndAssignment",
    "target_class": "org.apache.kafka.coordinator.group.consumer.Assignment, org.apache.kafka.image.TopicsImage):org.apache.kafka.coordinator.group.consumer.MemberSubscriptionAndAssignmentImpl \t org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "state",
    "target_class": "org.apache.kafka.timeline.TimelineObject"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "state",
    "target_class": "org.apache.kafka.timeline.TimelineObject"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "groupEpoch",
    "target_class": "org.apache.kafka.timeline.TimelineInteger"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "assignmentEpoch",
    "target_class": "org.apache.kafka.timeline.TimelineInteger"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "setNumClassicProtocolMembers",
    "target_class": "org.apache.kafka.timeline.TimelineInteger"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "staticMemberId",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "getOrMaybeCreateMember",
    "target_class": "boolean):org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "updateStaticMember",
    "target_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "removeStaticMember",
    "target_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "hasMember",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "numMembers",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "numClassicProtocolMembers",
    "target_class": "org.apache.kafka.timeline.TimelineInteger"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "subscriptionType",
    "target_class": "org.apache.kafka.timeline.TimelineObject"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "updateTargetAssignment",
    "target_class": "org.apache.kafka.coordinator.group.consumer.Assignment):void \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "updateInvertedTargetAssignment",
    "target_class": "org.apache.kafka.coordinator.group.consumer.Assignment, org.apache.kafka.coordinator.group.consumer.Assignment):void \t org.apache.kafka.coordinator.group.consumer.Assignment"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "removeTargetAssignment",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "currentPartitionEpoch",
    "target_class": "int):int \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "preferredServerAssignor",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "setSubscriptionMetadata",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "computeSubscriptionMetadata",
    "target_class": "org.apache.kafka.image.TopicsImage, org.apache.kafka.image.ClusterImage):java.util.Map<java.lang.String,org.apache.kafka.coordinator.group.consumer.TopicMetadata> \t org.apache.kafka.image.TopicImage"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "maybeUpdateGroupState",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "maybeUpdateServerAssignors",
    "target_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember, org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember):void \t org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "maybeUpdateNumClassicProtocolMembers",
    "target_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember):void \t org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "maybeUpdateSubscribedTopicNamesAndGroupSubscriptionType",
    "target_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember):void \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "maybeUpdateSubscribedTopicNames",
    "target_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember, org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember):void \t org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "maybeUpdatePartitionEpoch",
    "target_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember):void \t org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "maybeRemovePartitionEpoch",
    "target_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "removePartitionEpochs",
    "target_class": "int):void \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "addPartitionEpochs",
    "target_class": "int):void \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "fromClassicGroup",
    "target_class": "org.apache.kafka.coordinator.group.metrics.GroupCoordinatorMetricsShard, org.apache.kafka.coordinator.group.classic.ClassicGroup, org.apache.kafka.image.TopicsImage):org.apache.kafka.coordinator.group.consumer.ConsumerGroup \t org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember.Builder"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup",
    "source_method": "waitingOnUnreleasedPartition",
    "target_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember",
    "source_method": "topicPartitionsFromMap",
    "target_class": "org.apache.kafka.image.TopicsImage):java.util.List<ConsumerGroupDescribeResponseData.TopicPartitions> \t org.apache.kafka.image.TopicImage"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.consumer.CurrentAssignmentBuilder",
    "source_method": "computeNextAssignment",
    "target_class": "java.util.Map<org.apache.kafka.common.Uuid,java.util.Set<java.lang.Integer>>):org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember \t org.apache.kafka.coordinator.group.consumer.Assignment"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.classic.ClassicGroup",
    "source_method": "add",
    "target_class": "java.util.concurrent.CompletableFuture<org.apache.kafka.coordinator.group.classic.JoinGroupResponseData>):void \t org.apache.kafka.coordinator.group.classic.ClassicGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.classic.ClassicGroup",
    "source_method": "remove",
    "target_class": "org.apache.kafka.coordinator.group.classic.ClassicGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.classic.ClassicGroup",
    "source_method": "notYetRejoinedMembers",
    "target_class": "org.apache.kafka.coordinator.group.classic.ClassicGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.classic.ClassicGroup",
    "source_method": "transitionTo",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.classic.ClassicGroup",
    "source_method": "selectProtocol",
    "target_class": "org.apache.kafka.coordinator.group.classic.ClassicGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.classic.ClassicGroup",
    "source_method": "supportsProtocols",
    "target_class": "org.apache.kafka.coordinator.group.classic.ClassicGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.classic.ClassicGroup",
    "source_method": "updateMember",
    "target_class": "org.apache.kafka.coordinator.group.classic.JoinGroupRequestProtocolCollection, int, int, java.util.concurrent.CompletableFuture<org.apache.kafka.coordinator.group.classic.JoinGroupResponseData>):void \t org.apache.kafka.coordinator.group.classic.ClassicGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.classic.ClassicGroup",
    "source_method": "fromConsumerGroup",
    "target_class": "java.lang.String, org.apache.kafka.common.utils.LogContext, org.apache.kafka.common.utils.Time, org.apache.kafka.coordinator.group.metrics.GroupCoordinatorMetricsShard, org.apache.kafka.image.MetadataImage):org.apache.kafka.coordinator.group.classic.ClassicGroup \t org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.classic.ClassicGroup",
    "source_method": "createClassicGroupRecords",
    "target_class": "java.util.List<org.apache.kafka.coordinator.group.CoordinatorRecord>):void \t org.apache.kafka.coordinator.group.classic.ClassicGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.classic.ClassicGroup",
    "source_method": "assertValidTransition",
    "target_class": "org.apache.kafka.coordinator.group.classic.ClassicGroupState"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.assignor.UniformHomogeneousAssignmentBuilder",
    "source_method": "build",
    "target_class": "org.apache.kafka.coordinator.group.api.assignor.SubscribedTopicDescriber"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.assignor.UniformHomogeneousAssignmentBuilder",
    "source_method": "assignRemainingPartitions",
    "target_class": "org.apache.kafka.server.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.assignor.RangeAssignor",
    "source_method": "membersPerTopic",
    "target_class": "org.apache.kafka.coordinator.group.api.assignor.SubscribedTopicDescriber):java.util.Map<org.apache.kafka.common.Uuid,java.util.Collection<java.lang.String>> \t org.apache.kafka.coordinator.group.api.assignor.SubscribedTopicDescriber"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.assignor.UniformHeterogeneousAssignmentBuilder",
    "source_method": "sortTopicIdPartitions",
    "target_class": "org.apache.kafka.server.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.assignor.UniformHeterogeneousAssignmentBuilder",
    "source_method": "unassignedPartitionsAssignment",
    "target_class": "org.apache.kafka.coordinator.group.assignor.UniformHeterogeneousAssignmentBuilder.AssignmentManager"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.assignor.UniformHeterogeneousAssignmentBuilder",
    "source_method": "reassignPartition",
    "target_class": "org.apache.kafka.server.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.assignor.UniformHeterogeneousAssignmentBuilder",
    "source_method": "reassignPartition",
    "target_class": "java.lang.String):void \t org.apache.kafka.coordinator.group.assignor.UniformHeterogeneousAssignmentBuilder.PartitionMovements"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.assignor.UniformHeterogeneousAssignmentBuilder",
    "source_method": "processPartitionMovement",
    "target_class": "java.lang.String):void \t org.apache.kafka.coordinator.group.assignor.UniformHeterogeneousAssignmentBuilder.AssignmentManager"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.assignor.UniformHeterogeneousAssignmentBuilder.PartitionMovements",
    "source_method": "removeMovementRecordOfPartition",
    "target_class": "org.apache.kafka.server.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.assignor.UniformHeterogeneousAssignmentBuilder.PartitionMovements",
    "source_method": "addPartitionMovementRecord",
    "target_class": "org.apache.kafka.coordinator.group.assignor.UniformHeterogeneousAssignmentBuilder.MemberPair):void \t org.apache.kafka.server.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.assignor.UniformHeterogeneousAssignmentBuilder.PartitionMovements",
    "source_method": "computeActualPartitionToBeMoved",
    "target_class": "java.lang.String, java.lang.String):org.apache.kafka.server.common.TopicIdPartition \t org.apache.kafka.server.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.assignor.UniformHeterogeneousAssignmentBuilder.AssignmentManager",
    "source_method": "sortMembersByAssignmentSize",
    "target_class": "org.apache.kafka.coordinator.group.assignor.UniformHeterogeneousAssignmentBuilder.AssignmentManager.MemberAssignmentData"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.runtime.CoordinatorRuntime.CoordinatorContext",
    "source_method": "freeCurrentBatch",
    "target_class": "org.apache.kafka.common.utils.BufferSupplier"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.runtime.CoordinatorRuntime",
    "source_method": "enqueueLast",
    "target_class": "org.apache.kafka.coordinator.group.runtime.CoordinatorEventProcessor"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.runtime.CoordinatorRuntime",
    "source_method": "enqueueFirst",
    "target_class": "org.apache.kafka.coordinator.group.runtime.CoordinatorEventProcessor"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.runtime.CoordinatorRuntime",
    "source_method": "withActiveContextOrThrow",
    "target_class": "java.util.function.Consumer<org.apache.kafka.coordinator.group.runtime.CoordinatorRuntime<S,U>.CoordinatorContext>):void \t org.apache.kafka.coordinator.group.runtime.CoordinatorRuntime.CoordinatorContext"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.OffsetMetadataManager.Offsets",
    "source_method": "get",
    "target_class": "java.lang.String, int):org.apache.kafka.coordinator.group.OffsetAndMetadata \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.OffsetMetadataManager.Offsets",
    "source_method": "remove",
    "target_class": "java.lang.String, int):org.apache.kafka.coordinator.group.OffsetAndMetadata \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.OffsetMetadataManager",
    "source_method": "expireTimestampMs",
    "target_class": "long):java.util.OptionalLong \t org.apache.kafka.common.requests.OffsetCommitRequest"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.OffsetMetadataManager",
    "source_method": "deleteAllOffsets",
    "target_class": "java.util.List<org.apache.kafka.coordinator.group.CoordinatorRecord>):int \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.OffsetMetadataManager",
    "source_method": "hasPendingTransactionalOffsets",
    "target_class": "java.lang.String, int):boolean \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.OffsetMetadataManager",
    "source_method": "hasCommittedOffset",
    "target_class": "java.lang.String, int):boolean \t org.apache.kafka.coordinator.group.OffsetMetadataManager.Offsets"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.OffsetMetadataManager",
    "source_method": "onPartitionsDeleted",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.OffsetMetadataManager",
    "source_method": "offset",
    "target_class": "java.lang.String, int):org.apache.kafka.coordinator.group.OffsetAndMetadata \t org.apache.kafka.coordinator.group.OffsetMetadataManager.Offsets"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.OffsetMetadataManager",
    "source_method": "pendingTransactionalOffset",
    "target_class": "java.lang.String, java.lang.String, int):org.apache.kafka.coordinator.group.OffsetAndMetadata \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.metrics.GroupCoordinatorRuntimeMetrics",
    "source_method": "kafkaMetricName",
    "target_class": "java.lang.String, java.lang.String[]):org.apache.kafka.common.MetricName \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.metrics.GroupCoordinatorMetricsShard",
    "source_method": "onClassicGroupStateTransition",
    "target_class": "org.apache.kafka.coordinator.group.classic.ClassicGroupState):void \t org.apache.kafka.coordinator.group.classic.ClassicGroupState"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.metrics.GroupCoordinatorMetricsShard",
    "source_method": "onConsumerGroupStateTransition",
    "target_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroup.ConsumerGroupState):void \t org.apache.kafka.coordinator.group.consumer.ConsumerGroup.ConsumerGroupState"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.CoordinatorRecordHelpers",
    "source_method": "newMemberSubscriptionRecord",
    "target_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember):org.apache.kafka.coordinator.group.CoordinatorRecord \t org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.CoordinatorRecordHelpers",
    "source_method": "newGroupSubscriptionMetadataRecord",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.coordinator.group.consumer.TopicMetadata>):org.apache.kafka.coordinator.group.CoordinatorRecord \t org.apache.kafka.coordinator.group.consumer.TopicMetadata"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.CoordinatorRecordHelpers",
    "source_method": "newCurrentAssignmentRecord",
    "target_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember):org.apache.kafka.coordinator.group.CoordinatorRecord \t org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.CoordinatorRecordHelpers",
    "source_method": "newGroupMetadataRecord",
    "target_class": "java.util.Map<java.lang.String,byte[]>, org.apache.kafka.server.common.MetadataVersion):org.apache.kafka.coordinator.group.CoordinatorRecord \t org.apache.kafka.coordinator.group.classic.ClassicGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.CoordinatorRecordHelpers",
    "source_method": "newEmptyGroupMetadataRecord",
    "target_class": "org.apache.kafka.server.common.MetadataVersion):org.apache.kafka.coordinator.group.CoordinatorRecord \t org.apache.kafka.server.common.MetadataVersion"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.CoordinatorRecordHelpers",
    "source_method": "newOffsetCommitRecord",
    "target_class": "java.lang.String, int, org.apache.kafka.coordinator.group.OffsetAndMetadata, org.apache.kafka.server.common.MetadataVersion):org.apache.kafka.coordinator.group.CoordinatorRecord \t org.apache.kafka.server.common.MetadataVersion"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "group",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "group",
    "target_class": "long):org.apache.kafka.coordinator.group.Group \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "getOrMaybeCreateConsumerGroup",
    "target_class": "boolean, java.util.List<org.apache.kafka.coordinator.group.CoordinatorRecord>):org.apache.kafka.coordinator.group.consumer.ConsumerGroup \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "consumerGroup",
    "target_class": "long):org.apache.kafka.coordinator.group.consumer.ConsumerGroup \t org.apache.kafka.coordinator.group.Group"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "getOrMaybeCreatePersistedConsumerGroup",
    "target_class": "boolean):org.apache.kafka.coordinator.group.consumer.ConsumerGroup \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "getOrMaybeCreateClassicGroup",
    "target_class": "boolean):org.apache.kafka.coordinator.group.classic.ClassicGroup \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "classicGroup",
    "target_class": "long):org.apache.kafka.coordinator.group.classic.ClassicGroup \t org.apache.kafka.coordinator.group.Group"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "throwIfConsumerGroupIsFull",
    "target_class": "java.lang.String):void \t org.apache.kafka.coordinator.group.consumer.ConsumerGroup"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "throwIfMemberEpochIsInvalid",
    "target_class": "int, java.util.List<ConsumerGroupHeartbeatRequestData.TopicPartitions>):void \t org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "throwIfClassicProtocolIsNotSupported",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.coordinator.group.JoinGroupRequestProtocolCollection):void \t org.apache.kafka.coordinator.group.consumer.ConsumerGroup"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "throwIfMemberDoesNotUseClassicProtocol",
    "target_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "throwIfRebalanceInProgress",
    "target_class": "org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember):void \t org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "scheduleConsumerGroupSessionTimeout",
    "target_class": "java.lang.String, int):void \t org.apache.kafka.coordinator.group.runtime.CoordinatorTimer"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "cancelConsumerGroupSessionTimeout",
    "target_class": "java.lang.String):void \t org.apache.kafka.coordinator.group.runtime.CoordinatorTimer"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "cancelConsumerGroupRebalanceTimeout",
    "target_class": "java.lang.String):void \t org.apache.kafka.coordinator.group.runtime.CoordinatorTimer"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "scheduleConsumerGroupJoinTimeoutIfAbsent",
    "target_class": "java.lang.String, int):void \t org.apache.kafka.coordinator.group.runtime.CoordinatorTimer"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "cancelConsumerGroupJoinTimeout",
    "target_class": "java.lang.String):void \t org.apache.kafka.coordinator.group.runtime.CoordinatorTimer"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "scheduleConsumerGroupSyncTimeout",
    "target_class": "java.lang.String, int):void \t org.apache.kafka.coordinator.group.runtime.CoordinatorTimer"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "cancelConsumerGroupSyncTimeout",
    "target_class": "java.lang.String):void \t org.apache.kafka.coordinator.group.runtime.CoordinatorTimer"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "groupsSubscribedToTopic",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "unsubscribeGroupFromTopic",
    "target_class": "java.lang.String):void \t org.apache.kafka.timeline.TimelineHashSet"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "onNewMetadataImage",
    "target_class": "org.apache.kafka.image.MetadataDelta):void \t org.apache.kafka.image.MetadataDelta"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "maybeCompleteJoinPhase",
    "target_class": "org.apache.kafka.coordinator.group.classic.ClassicGroup"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "schedulePendingSync",
    "target_class": "org.apache.kafka.coordinator.group.classic.ClassicGroup"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "removePendingMemberAndUpdateClassicGroup",
    "target_class": "java.lang.String):org.apache.kafka.coordinator.group.runtime.CoordinatorResult<java.lang.Void,org.apache.kafka.coordinator.group.CoordinatorRecord> \t org.apache.kafka.coordinator.group.classic.ClassicGroup"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "maybePrepareRebalanceOrCompleteJoin",
    "target_class": "java.lang.String):org.apache.kafka.coordinator.group.runtime.CoordinatorResult<java.lang.Void,org.apache.kafka.coordinator.group.CoordinatorRecord> \t org.apache.kafka.coordinator.group.classic.ClassicGroup"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "maybeCompleteJoinElseSchedule",
    "target_class": "org.apache.kafka.coordinator.group.runtime.CoordinatorTimer"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "resetAndPropagateAssignmentWithError",
    "target_class": "org.apache.kafka.common.protocol.Errors):void \t org.apache.kafka.coordinator.group.classic.ClassicGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "setAndPropagateAssignment",
    "target_class": "java.util.Map<java.lang.String,byte[]>):void \t org.apache.kafka.coordinator.group.classic.ClassicGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "rescheduleClassicGroupMemberHeartbeat",
    "target_class": "org.apache.kafka.coordinator.group.classic.ClassicGroupMember):void \t org.apache.kafka.coordinator.group.classic.ClassicGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "rescheduleClassicGroupMemberHeartbeat",
    "target_class": "org.apache.kafka.coordinator.group.classic.ClassicGroupMember, long):void \t org.apache.kafka.coordinator.group.classic.ClassicGroupMember"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "removeSyncExpiration",
    "target_class": "org.apache.kafka.coordinator.group.classic.ClassicGroup"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "acceptJoiningMember",
    "target_class": "java.lang.String):boolean \t org.apache.kafka.coordinator.group.classic.ClassicGroup"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "removePendingSyncMember",
    "target_class": "java.lang.String):void \t org.apache.kafka.coordinator.group.classic.ClassicGroup"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "validateClassicGroupHeartbeat",
    "target_class": "java.lang.String, java.lang.String, int):void \t org.apache.kafka.coordinator.group.classic.ClassicGroup"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "validateConsumerGroupMember",
    "target_class": "java.lang.String, java.lang.String):org.apache.kafka.coordinator.group.consumer.ConsumerGroupMember \t org.apache.kafka.coordinator.group.consumer.ConsumerGroup"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "validateDeleteGroup",
    "target_class": "org.apache.kafka.coordinator.group.Group"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "maybeDeleteGroup",
    "target_class": "java.util.List<org.apache.kafka.coordinator.group.CoordinatorRecord>):void \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "maybeDeleteEmptyConsumerGroup",
    "target_class": "java.util.List<org.apache.kafka.coordinator.group.CoordinatorRecord>):void \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupMetadataManager",
    "source_method": "groupIds",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupCoordinatorShard",
    "source_method": "describeGroups",
    "target_class": "java.util.List<java.lang.String>, long):java.util.List<DescribeGroupsResponseData.DescribedGroup> \t org.apache.kafka.coordinator.group.GroupMetadataManager"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupCoordinatorShard",
    "source_method": "deleteOffsets",
    "target_class": "org.apache.kafka.coordinator.group.OffsetDeleteRequestData):org.apache.kafka.coordinator.group.runtime.CoordinatorResult<org.apache.kafka.coordinator.group.OffsetDeleteResponseData,org.apache.kafka.coordinator.group.CoordinatorRecord> \t org.apache.kafka.coordinator.group.OffsetMetadataManager"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupCoordinatorShard",
    "source_method": "scheduleGroupMetadataExpiration",
    "target_class": "org.apache.kafka.coordinator.group.runtime.CoordinatorTimer"
  },
  {
    "source_class": "org.apache.kafka.coordinator.group.GroupCoordinatorShard",
    "source_method": "messageOrNull",
    "target_class": "org.apache.kafka.server.common.ApiMessageAndVersion"
  },
  {
    "source_class": "kafka.server.share.SharePartitionManager",
    "source_method": "cachedTopicIdPartitionsInShareSession",
    "target_class": "org.apache.kafka.common.Uuid):java.util.List<org.apache.kafka.common.TopicIdPartition> \t org.apache.kafka.server.share.ShareSession"
  },
  {
    "source_class": "kafka.server.share.SharePartition",
    "source_method": "checkForFullMatch",
    "target_class": "long, long):boolean \t kafka.server.share.SharePartition.InFlightBatch"
  },
  {
    "source_class": "kafka.server.share.SharePartition",
    "source_method": "fetchRecordStateMapForAcknowledgementBatch",
    "target_class": "org.apache.kafka.server.share.ShareAcknowledgementBatch"
  },
  {
    "source_class": "kafka.server.share.SharePartition",
    "source_method": "isRecordStateAcknowledged",
    "target_class": "kafka.server.share.SharePartition.RecordState"
  },
  {
    "source_class": "kafka.server.share.SharePartition",
    "source_method": "findLastOffsetAcknowledged",
    "target_class": "kafka.server.share.SharePartition.InFlightBatch"
  },
  {
    "source_class": "kafka.server.share.SharePartition",
    "source_method": "scheduleAcquisitionLockTimeout",
    "target_class": "long, long, long):kafka.server.share.SharePartition.AcquisitionLockTimerTask \t org.apache.kafka.server.util.timer.Timer"
  },
  {
    "source_class": "kafka.server.share.SharePartition.InFlightBatch",
    "source_method": "batchDeliveryCount",
    "target_class": "kafka.server.share.SharePartition.InFlightState"
  },
  {
    "source_class": "kafka.server.share.SharePartition.InFlightBatch",
    "source_method": "batchAcquisitionLockTimeoutTask",
    "target_class": "kafka.server.share.SharePartition.InFlightState"
  },
  {
    "source_class": "kafka.server.share.SharePartition.InFlightBatch",
    "source_method": "tryUpdateBatchState",
    "target_class": "boolean, int, java.lang.String):kafka.server.share.SharePartition.InFlightState \t kafka.server.share.SharePartition.InFlightState"
  },
  {
    "source_class": "kafka.server.share.SharePartition.InFlightBatch",
    "source_method": "startBatchStateTransition",
    "target_class": "boolean, int, java.lang.String):kafka.server.share.SharePartition.InFlightState \t kafka.server.share.SharePartition.InFlightState"
  },
  {
    "source_class": "kafka.server.TierStateMachine",
    "source_method": "readLeaderEpochCheckpoint",
    "target_class": "org.apache.kafka.server.log.remote.storage.RemoteLogSegmentMetadata):java.util.List<org.apache.kafka.storage.internals.log.EpochEntry> \t kafka.log.remote.RemoteLogManager"
  },
  {
    "source_class": "kafka.server.NetworkUtils",
    "source_method": "buildNetworkClient",
    "target_class": "kafka.server.KafkaConfig, org.apache.kafka.common.metrics.Metrics, org.apache.kafka.common.utils.Time, org.apache.kafka.common.utils.LogContext):org.apache.kafka.clients.NetworkClient \t org.apache.kafka.common.network.ChannelBuilders"
  },
  {
    "source_class": "kafka.log.remote.RemoteLogManager",
    "source_method": "removeMetrics",
    "target_class": "org.apache.kafka.server.metrics.KafkaMetricsGroup"
  },
  {
    "source_class": "kafka.log.remote.RemoteLogManager",
    "source_method": "isRemoteLogFetchQuotaExceeded",
    "target_class": "kafka.log.remote.quota.RLMQuotaManager"
  },
  {
    "source_class": "kafka.log.remote.RemoteLogManager",
    "source_method": "copyQuotaManagerConfig",
    "target_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig"
  },
  {
    "source_class": "kafka.log.remote.RemoteLogManager",
    "source_method": "fetchQuotaManagerConfig",
    "target_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig"
  },
  {
    "source_class": "kafka.log.remote.RemoteLogManager",
    "source_method": "createRemoteStorageManager",
    "target_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig"
  },
  {
    "source_class": "kafka.log.remote.RemoteLogManager",
    "source_method": "configureRSM",
    "target_class": "org.apache.kafka.server.log.remote.storage.RemoteLogManagerConfig"
  },
  {
    "source_class": "kafka.log.remote.RemoteLogManager",
    "source_method": "deleteRemoteLogPartition",
    "target_class": "org.apache.kafka.storage.internals.log.RemoteIndexCache"
  },
  {
    "source_class": "kafka.log.remote.RemoteLogManager",
    "source_method": "publishEvents",
    "target_class": "org.apache.kafka.server.log.remote.storage.RemoteLogMetadataManager"
  },
  {
    "source_class": "kafka.log.remote.RemoteLogManager",
    "source_method": "fetchRemoteLogSegmentMetadata",
    "target_class": "int, long):java.util.Optional<org.apache.kafka.server.log.remote.storage.RemoteLogSegmentMetadata> \t org.apache.kafka.server.log.remote.storage.RemoteLogMetadataManager"
  },
  {
    "source_class": "kafka.log.remote.RemoteLogManager",
    "source_method": "lookupTimestamp",
    "target_class": "long, long):java.util.Optional<org.apache.kafka.common.record.FileRecords.TimestampAndOffset> \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "kafka.log.remote.RemoteLogManager",
    "source_method": "isRemoteSegmentWithinLeaderEpochs",
    "target_class": "long, java.util.NavigableMap<java.lang.Integer,java.lang.Long>):boolean \t org.apache.kafka.server.log.remote.storage.RemoteLogSegmentMetadata"
  },
  {
    "source_class": "kafka.log.remote.RemoteLogManager",
    "source_method": "lookupPositionForOffset",
    "target_class": "long):int \t org.apache.kafka.storage.internals.log.RemoteIndexCache"
  },
  {
    "source_class": "kafka.log.remote.RemoteLogManager",
    "source_method": "collectAbortedTransactionInLocalSegments",
    "target_class": "long, java.util.function.Consumer<java.util.List<org.apache.kafka.storage.internals.log.AbortedTxn>>, java.util.Iterator<org.apache.kafka.storage.internals.log.LogSegment>):void \t org.apache.kafka.storage.internals.log.TransactionIndex"
  },
  {
    "source_class": "kafka.log.remote.RemoteLogManager",
    "source_method": "findFirstBatch",
    "target_class": "long):org.apache.kafka.common.record.RecordBatch \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "kafka.log.remote.RemoteLogManager",
    "source_method": "epochEntriesAsByteBuffer",
    "target_class": "org.apache.kafka.server.common.CheckpointFile.CheckpointWriteBuffer"
  },
  {
    "source_class": "kafka.log.remote.quota.RLMQuotaManager",
    "source_method": "record",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "kafka.log.remote.quota.RLMQuotaManager",
    "source_method": "getQuotaMetricConfig",
    "target_class": "kafka.log.remote.quota.RLMQuotaManagerConfig"
  },
  {
    "source_class": "org.apache.kafka.common.internals.KafkaFutureImpl",
    "source_method": "toKafkaCompletableFuture",
    "target_class": "org.apache.kafka.common.internals.KafkaCompletableFuture"
  },
  {
    "source_class": "org.apache.kafka.common.requests.AbstractResponse",
    "source_method": "serializeWithHeader",
    "target_class": "short):java.nio.ByteBuffer \t org.apache.kafka.common.requests.ResponseHeader"
  },
  {
    "source_class": "org.apache.kafka.common.requests.AbstractResponse",
    "source_method": "parseResponse",
    "target_class": "org.apache.kafka.common.requests.RequestHeader):org.apache.kafka.common.requests.AbstractResponse \t org.apache.kafka.common.requests.RequestHeader"
  },
  {
    "source_class": "org.apache.kafka.common.requests.RequestHeader",
    "source_method": "parse",
    "target_class": "org.apache.kafka.common.protocol.ApiKeys"
  },
  {
    "source_class": "org.apache.kafka.common.requests.RequestUtils",
    "source_method": "getLeaderEpoch",
    "target_class": "org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.common.requests.RequestUtils",
    "source_method": "flag",
    "target_class": "java.util.function.Predicate<org.apache.kafka.common.record.RecordBatch>):boolean \t org.apache.kafka.common.requests.ProduceRequest"
  },
  {
    "source_class": "org.apache.kafka.common.requests.RequestUtils",
    "source_method": "serialize",
    "target_class": "short, org.apache.kafka.common.protocol.Message, short):java.nio.ByteBuffer \t org.apache.kafka.common.protocol.ByteBufferAccessor"
  },
  {
    "source_class": "org.apache.kafka.common.requests.AbstractRequest",
    "source_method": "serializeWithHeader",
    "target_class": "org.apache.kafka.common.requests.RequestHeader"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DescribeGroupsResponse",
    "source_method": "groupMetadata",
    "target_class": "org.apache.kafka.common.protocol.Errors, java.lang.String, java.lang.String, java.lang.String, java.util.List<org.apache.kafka.common.requests.DescribedGroupMember>, java.util.Set<java.lang.Byte>):org.apache.kafka.common.requests.DescribedGroup \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DescribeGroupsResponse",
    "source_method": "groupMetadata",
    "target_class": "org.apache.kafka.common.protocol.Errors, java.lang.String, java.lang.String, java.lang.String, java.util.List<org.apache.kafka.common.requests.DescribedGroupMember>, int):org.apache.kafka.common.requests.DescribedGroup \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ProduceResponse",
    "source_method": "toData",
    "target_class": "int, java.util.List<org.apache.kafka.common.Node>):org.apache.kafka.common.requests.ProduceResponseData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.RequestContext",
    "source_method": "parseRequest",
    "target_class": "org.apache.kafka.common.requests.RequestHeader"
  },
  {
    "source_class": "org.apache.kafka.common.requests.RequestContext",
    "source_method": "buildResponseSend",
    "target_class": "org.apache.kafka.common.requests.AbstractResponse"
  },
  {
    "source_class": "org.apache.kafka.common.requests.RequestContext",
    "source_method": "buildResponseEnvelopePayload",
    "target_class": "org.apache.kafka.common.requests.AbstractResponse"
  },
  {
    "source_class": "org.apache.kafka.common.requests.RequestContext",
    "source_method": "isUnsupportedApiVersionsRequest",
    "target_class": "org.apache.kafka.common.requests.RequestHeader"
  },
  {
    "source_class": "org.apache.kafka.common.requests.RequestContext",
    "source_method": "apiVersion",
    "target_class": "org.apache.kafka.common.requests.RequestHeader"
  },
  {
    "source_class": "org.apache.kafka.common.requests.BeginQuorumEpochRequest",
    "source_method": "singletonRequest",
    "target_class": "java.lang.String, int, int):org.apache.kafka.common.requests.BeginQuorumEpochRequestData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.FetchSnapshotResponse",
    "source_method": "withTopLevelError",
    "target_class": "org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ShareAcknowledgeResponse",
    "source_method": "matchingTopic",
    "target_class": "org.apache.kafka.common.TopicIdPartition):boolean \t org.apache.kafka.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ShareAcknowledgeResponse",
    "source_method": "partitionResponse",
    "target_class": "org.apache.kafka.common.protocol.Errors):ShareAcknowledgeResponseData.PartitionData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ShareAcknowledgeResponse",
    "source_method": "partitionResponse",
    "target_class": "org.apache.kafka.common.protocol.Errors):ShareAcknowledgeResponseData.PartitionData \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ShareAcknowledgeResponse",
    "source_method": "toMessage",
    "target_class": "int, java.util.Iterator<java.util.Map.Entry<org.apache.kafka.common.TopicIdPartition,ShareAcknowledgeResponseData.PartitionData>>, java.util.List<org.apache.kafka.common.Node>):org.apache.kafka.common.requests.ShareAcknowledgeResponseData \t org.apache.kafka.common.Node"
  },
  {
    "source_class": "org.apache.kafka.common.requests.FetchResponse",
    "source_method": "partitionResponse",
    "target_class": "org.apache.kafka.common.protocol.Errors):FetchResponseData.PartitionData \t org.apache.kafka.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.FetchResponse",
    "source_method": "partitionResponse",
    "target_class": "org.apache.kafka.common.protocol.Errors):FetchResponseData.PartitionData \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.FetchResponse",
    "source_method": "matchingTopic",
    "target_class": "org.apache.kafka.common.TopicIdPartition):boolean \t org.apache.kafka.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.FetchResponse",
    "source_method": "toMessage",
    "target_class": "int, int, java.util.Iterator<java.util.Map.Entry<org.apache.kafka.common.TopicIdPartition,FetchResponseData.PartitionData>>, java.util.List<org.apache.kafka.common.Node>):org.apache.kafka.common.requests.FetchResponseData \t org.apache.kafka.common.Node"
  },
  {
    "source_class": "org.apache.kafka.common.requests.CreateDelegationTokenResponse",
    "source_method": "prepareResponse",
    "target_class": "int, org.apache.kafka.common.protocol.Errors, org.apache.kafka.common.security.auth.KafkaPrincipal, org.apache.kafka.common.security.auth.KafkaPrincipal, long, long, long, java.lang.String, java.nio.ByteBuffer):org.apache.kafka.common.requests.CreateDelegationTokenResponse \t org.apache.kafka.common.security.auth.KafkaPrincipal"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ShareGroupDescribeRequest",
    "source_method": "getErrorDescribedGroupList",
    "target_class": "org.apache.kafka.common.protocol.Errors):java.util.List<ShareGroupDescribeResponseData.DescribedGroup> \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.UpdateFeaturesResponse",
    "source_method": "createWithErrors",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.common.requests.ApiError>, int):org.apache.kafka.common.requests.UpdateFeaturesResponse \t org.apache.kafka.common.requests.ApiError"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ListOffsetsRequest.Builder",
    "source_method": "forConsumer",
    "target_class": "org.apache.kafka.common.IsolationLevel, boolean):org.apache.kafka.common.requests.ListOffsetsRequest.Builder \t org.apache.kafka.common.protocol.ApiKeys"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ListOffsetsRequest",
    "source_method": "toListOffsetsTopics",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ShareAcknowledgeRequest.Builder",
    "source_method": "forConsumer",
    "target_class": "org.apache.kafka.common.requests.ShareFetchMetadata, java.util.Map<org.apache.kafka.common.TopicIdPartition,java.util.List<ShareAcknowledgeRequestData.AcknowledgementBatch>>):org.apache.kafka.common.requests.ShareAcknowledgeRequest.Builder \t org.apache.kafka.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.AddPartitionsToTxnRequest.Builder",
    "source_method": "forBroker",
    "target_class": "org.apache.kafka.common.protocol.ApiKeys"
  },
  {
    "source_class": "org.apache.kafka.common.requests.AddPartitionsToTxnRequest.Builder",
    "source_method": "buildTxnTopicCollection",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ListOffsetsResponse",
    "source_method": "singletonListOffsetsTopicResponse",
    "target_class": "org.apache.kafka.common.protocol.Errors, long, long, int):org.apache.kafka.common.requests.ListOffsetsTopicResponse \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DescribeQuorumResponse",
    "source_method": "singletonErrorResponse",
    "target_class": "org.apache.kafka.common.protocol.Errors):org.apache.kafka.common.requests.DescribeQuorumResponseData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DescribeQuorumResponse",
    "source_method": "singletonResponse",
    "target_class": "DescribeQuorumResponseData.PartitionData, DescribeQuorumResponseData.NodeCollection):org.apache.kafka.common.requests.DescribeQuorumResponseData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.LeaveGroupResponse",
    "source_method": "getError",
    "target_class": "java.util.List<org.apache.kafka.common.requests.MemberResponse>):org.apache.kafka.common.protocol.Errors \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.JoinGroupRequest",
    "source_method": "validateGroupInstanceId",
    "target_class": "org.apache.kafka.common.internals.Topic"
  },
  {
    "source_class": "org.apache.kafka.common.requests.MetadataResponse",
    "source_method": "toPartitionInfo",
    "target_class": "java.util.Map<java.lang.Integer,org.apache.kafka.common.Node>):org.apache.kafka.common.PartitionInfo \t org.apache.kafka.common.requests.MetadataResponse.PartitionMetadata"
  },
  {
    "source_class": "org.apache.kafka.common.requests.MetadataResponse",
    "source_method": "brokers",
    "target_class": "org.apache.kafka.common.requests.MetadataResponse.Holder"
  },
  {
    "source_class": "org.apache.kafka.common.requests.MetadataResponse",
    "source_method": "brokersById",
    "target_class": "org.apache.kafka.common.requests.MetadataResponse.Holder"
  },
  {
    "source_class": "org.apache.kafka.common.requests.MetadataResponse",
    "source_method": "topicMetadata",
    "target_class": "org.apache.kafka.common.requests.MetadataResponse.Holder"
  },
  {
    "source_class": "org.apache.kafka.common.requests.MetadataResponse",
    "source_method": "controller",
    "target_class": "org.apache.kafka.common.requests.MetadataResponse.Holder"
  },
  {
    "source_class": "org.apache.kafka.common.requests.MetadataResponse",
    "source_method": "prepareResponse",
    "target_class": "int, java.util.Collection<org.apache.kafka.common.Node>, java.lang.String, int, java.util.List<org.apache.kafka.common.requests.MetadataResponseTopic>, int):org.apache.kafka.common.requests.MetadataResponse \t org.apache.kafka.common.Node"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DeleteAclsResponse",
    "source_method": "filterResult",
    "target_class": "org.apache.kafka.common.requests.ApiError"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DeleteAclsResponse",
    "source_method": "matchingAcl",
    "target_class": "org.apache.kafka.server.authorizer.AclDeleteResult.AclBindingDeleteResult"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DeleteAclsResponse",
    "source_method": "matchingAcl",
    "target_class": "org.apache.kafka.common.requests.ApiError):org.apache.kafka.common.requests.DeleteAclsMatchingAcl \t org.apache.kafka.common.acl.AclOperation"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DeleteAclsResponse",
    "source_method": "aclBinding",
    "target_class": "org.apache.kafka.common.acl.AclOperation"
  },
  {
    "source_class": "org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.Builder",
    "source_method": "forConsumer",
    "target_class": "org.apache.kafka.common.protocol.ApiKeys"
  },
  {
    "source_class": "org.apache.kafka.common.requests.CreateAclsRequest",
    "source_method": "aclBinding",
    "target_class": "org.apache.kafka.common.acl.AclOperation"
  },
  {
    "source_class": "org.apache.kafka.common.requests.CreateAclsRequest",
    "source_method": "aclCreation",
    "target_class": "org.apache.kafka.common.acl.AccessControlEntry"
  },
  {
    "source_class": "org.apache.kafka.common.requests.CreateAclsRequest",
    "source_method": "aclResult",
    "target_class": "org.apache.kafka.common.requests.ApiError"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DeleteGroupsRequest",
    "source_method": "getErrorResultCollection",
    "target_class": "org.apache.kafka.common.protocol.Errors):DeleteGroupsResponseData.DeletableGroupResultCollection \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.IncrementalAlterConfigsResponse",
    "source_method": "fromResponseData",
    "target_class": "org.apache.kafka.common.config.ConfigResource.Type"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DescribeAclsResponse",
    "source_method": "aclsResources",
    "target_class": "org.apache.kafka.common.acl.AclOperation"
  },
  {
    "source_class": "org.apache.kafka.common.requests.FetchRequest.Builder",
    "source_method": "forConsumer",
    "target_class": "int, int, java.util.Map<org.apache.kafka.common.TopicPartition,org.apache.kafka.common.requests.FetchRequest.PartitionData>):org.apache.kafka.common.requests.FetchRequest.Builder \t org.apache.kafka.common.protocol.ApiKeys"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DescribeQuorumRequest",
    "source_method": "singletonRequest",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DescribeQuorumRequest",
    "source_method": "getPartitionLevelErrorResponse",
    "target_class": "org.apache.kafka.common.protocol.Errors):org.apache.kafka.common.requests.DescribeQuorumResponseData \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DescribeQuorumRequest",
    "source_method": "getTopLevelErrorResponse",
    "target_class": "org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.FindCoordinatorResponse",
    "source_method": "prepareOldResponse",
    "target_class": "org.apache.kafka.common.Node):org.apache.kafka.common.requests.FindCoordinatorResponse \t org.apache.kafka.common.Node"
  },
  {
    "source_class": "org.apache.kafka.common.requests.FindCoordinatorResponse",
    "source_method": "prepareCoordinatorResponse",
    "target_class": "java.lang.String, org.apache.kafka.common.Node):FindCoordinatorResponseData.Coordinator \t org.apache.kafka.common.Node"
  },
  {
    "source_class": "org.apache.kafka.common.requests.FindCoordinatorResponse",
    "source_method": "prepareErrorResponse",
    "target_class": "java.util.List<java.lang.String>):org.apache.kafka.common.requests.FindCoordinatorResponse \t org.apache.kafka.common.Node"
  },
  {
    "source_class": "org.apache.kafka.common.requests.OffsetFetchResponse",
    "source_method": "topLevelError",
    "target_class": "org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DescribeGroupsRequest",
    "source_method": "getErrorDescribedGroupList",
    "target_class": "org.apache.kafka.common.protocol.Errors):java.util.List<DescribeGroupsResponseData.DescribedGroup> \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ShareFetchResponse",
    "source_method": "toMessage",
    "target_class": "int, java.util.Iterator<java.util.Map.Entry<org.apache.kafka.common.TopicIdPartition,ShareFetchResponseData.PartitionData>>, java.util.List<org.apache.kafka.common.Node>):org.apache.kafka.common.requests.ShareFetchResponseData \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ShareFetchResponse",
    "source_method": "partitionResponse",
    "target_class": "org.apache.kafka.common.protocol.Errors):ShareFetchResponseData.PartitionData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ShareFetchResponse",
    "source_method": "partitionResponse",
    "target_class": "org.apache.kafka.common.protocol.Errors):ShareFetchResponseData.PartitionData \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.UpdateMetadataRequest",
    "source_method": "listenerNameFromSecurityProtocol",
    "target_class": "org.apache.kafka.common.security.auth.SecurityProtocol"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DescribeClientQuotasResponse",
    "source_method": "fromQuotaEntities",
    "target_class": "int):org.apache.kafka.common.requests.DescribeClientQuotasResponse \t org.apache.kafka.common.quota.ClientQuotaEntity"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ProduceRequest",
    "source_method": "forMagic",
    "target_class": "org.apache.kafka.common.requests.ProduceRequestData):org.apache.kafka.common.requests.ProduceRequest.Builder \t org.apache.kafka.common.protocol.ApiKeys"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ProduceRequest",
    "source_method": "validateRecords",
    "target_class": "org.apache.kafka.common.record.BaseRecords):void \t org.apache.kafka.common.record.Records"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ProduceRequest",
    "source_method": "requiredMagicForVersion",
    "target_class": "org.apache.kafka.common.protocol.ApiKeys"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ConsumerGroupDescribeRequest",
    "source_method": "getErrorDescribedGroupList",
    "target_class": "org.apache.kafka.common.protocol.Errors):java.util.List<ConsumerGroupDescribeResponseData.DescribedGroup> \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.EndQuorumEpochRequest",
    "source_method": "singletonRequest",
    "target_class": "java.lang.String, int, int, java.util.List<java.lang.Integer>):org.apache.kafka.common.requests.EndQuorumEpochRequestData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.WriteShareGroupStateResponse",
    "source_method": "toErrorResponseData",
    "target_class": "int, org.apache.kafka.common.protocol.Errors, java.lang.String):org.apache.kafka.common.requests.WriteShareGroupStateResponseData \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.WriteShareGroupStateResponse",
    "source_method": "toErrorResponsePartitionResult",
    "target_class": "org.apache.kafka.common.protocol.Errors, java.lang.String):WriteShareGroupStateResponseData.PartitionResult \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DeleteAclsRequest",
    "source_method": "deleteAclsFilter",
    "target_class": "org.apache.kafka.common.acl.AclOperation"
  },
  {
    "source_class": "org.apache.kafka.common.requests.DeleteAclsRequest",
    "source_method": "aclBindingFilter",
    "target_class": "org.apache.kafka.common.acl.AclOperation"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ShareFetchRequest.Builder",
    "source_method": "forConsumer",
    "target_class": "org.apache.kafka.common.requests.ShareFetchMetadata, int, int, int, int, java.util.List<org.apache.kafka.common.TopicIdPartition>, java.util.List<org.apache.kafka.common.TopicIdPartition>, java.util.Map<org.apache.kafka.common.TopicIdPartition,java.util.List<ShareFetchRequestData.AcknowledgementBatch>>):org.apache.kafka.common.requests.ShareFetchRequest.Builder \t org.apache.kafka.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.VoteRequest",
    "source_method": "singletonRequest",
    "target_class": "java.lang.String, int, int, int, long):org.apache.kafka.common.requests.VoteRequestData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.AddPartitionsToTxnResponse",
    "source_method": "topicCollectionForErrors",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.AddPartitionsToTxnResponse",
    "source_method": "errorsForTransaction",
    "target_class": "org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ElectLeadersResponse",
    "source_method": "electLeadersResult",
    "target_class": "org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.TxnOffsetCommitRequest",
    "source_method": "getTopics",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.TxnOffsetCommitRequest",
    "source_method": "getErrorResponseTopics",
    "target_class": "org.apache.kafka.common.protocol.Errors):java.util.List<org.apache.kafka.common.requests.TxnOffsetCommitResponseTopic> \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.AlterClientQuotasResponse",
    "source_method": "toEntityData",
    "target_class": "org.apache.kafka.common.quota.ClientQuotaEntity"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ApiVersionsResponse",
    "source_method": "filterApis",
    "target_class": "ApiMessageType.ListenerType, boolean, boolean):org.apache.kafka.common.requests.ApiVersionCollection \t org.apache.kafka.common.protocol.ApiKeys"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ApiVersionsResponse",
    "source_method": "collectApis",
    "target_class": "boolean):org.apache.kafka.common.requests.ApiVersionCollection \t org.apache.kafka.common.protocol.ApiKeys"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ApiVersionsResponse",
    "source_method": "intersectForwardableApis",
    "target_class": "org.apache.kafka.common.record.RecordVersion, java.util.Map<org.apache.kafka.common.protocol.ApiKeys,org.apache.kafka.common.requests.ApiVersion>, boolean, boolean):org.apache.kafka.common.requests.ApiVersionCollection \t org.apache.kafka.common.protocol.ApiKeys"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ApiVersionsResponse",
    "source_method": "createSupportedFeatureKeys",
    "target_class": "org.apache.kafka.common.feature.BaseVersionRange"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ApiError",
    "source_method": "fromThrowable",
    "target_class": "org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.FetchSnapshotRequest",
    "source_method": "singleton",
    "target_class": "int, org.apache.kafka.common.TopicPartition, java.util.function.UnaryOperator<FetchSnapshotRequestData.PartitionSnapshot>):org.apache.kafka.common.requests.FetchSnapshotRequestData \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ControlledShutdownResponse",
    "source_method": "prepareResponse",
    "target_class": "java.util.Set<org.apache.kafka.common.TopicPartition>):org.apache.kafka.common.requests.ControlledShutdownResponse \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ReadShareGroupStateResponse",
    "source_method": "toErrorResponseData",
    "target_class": "int, org.apache.kafka.common.protocol.Errors, java.lang.String):org.apache.kafka.common.requests.ReadShareGroupStateResponseData \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.requests.ReadShareGroupStateResponse",
    "source_method": "toErrorResponsePartitionResult",
    "target_class": "org.apache.kafka.common.protocol.Errors, java.lang.String):ReadShareGroupStateResponseData.PartitionResult \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.compress.ZstdCompression",
    "source_method": "wrapForZstdInput",
    "target_class": "org.apache.kafka.common.utils.BufferSupplier):org.apache.kafka.common.compress.ZstdInputStreamNoFinalizer \t org.apache.kafka.common.utils.BufferSupplier"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.ClientTelemetryUtils",
    "source_method": "maybeFetchErrorIntervalMs",
    "target_class": "int):java.util.Optional<java.lang.Integer> \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.ClientTelemetryUtils",
    "source_method": "getSelectorFromRequestedMetrics",
    "target_class": "super org.apache.kafka.common.telemetry.internals.MetricKeyable> \t org.apache.kafka.common.telemetry.internals.MetricKey"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.ClientTelemetryUtils",
    "source_method": "getCompressionTypesFromAcceptedList",
    "target_class": "org.apache.kafka.common.record.CompressionType"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.ClientTelemetryUtils",
    "source_method": "validateClientInstanceId",
    "target_class": "org.apache.kafka.common.Uuid"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.ClientTelemetryUtils",
    "source_method": "validateIntervalMs",
    "target_class": "org.apache.kafka.common.telemetry.internals.ClientTelemetryReporter"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.ClientTelemetryUtils",
    "source_method": "validateRequiredResourceLabels",
    "target_class": "org.apache.kafka.common.metrics.MetricsContext"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.ClientTelemetryUtils",
    "source_method": "preferredCompressionType",
    "target_class": "org.apache.kafka.common.record.CompressionType"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.ClientTelemetryUtils",
    "source_method": "compress",
    "target_class": "org.apache.kafka.common.record.CompressionType):byte[] \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.ClientTelemetryUtils",
    "source_method": "decompress",
    "target_class": "org.apache.kafka.common.record.CompressionType):java.nio.ByteBuffer \t org.apache.kafka.common.compress.Compression.Builder"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.ClientTelemetryUtils",
    "source_method": "fetchClientInstanceId",
    "target_class": "java.time.Duration):org.apache.kafka.common.Uuid \t org.apache.kafka.common.telemetry.internals.ClientTelemetrySender"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.KafkaMetricsCollector",
    "source_method": "metricsReset",
    "target_class": "org.apache.kafka.common.telemetry.internals.KafkaMetricsCollector.StateLedger"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.KafkaMetricsCollector",
    "source_method": "getTrackedMetrics",
    "target_class": "org.apache.kafka.common.telemetry.internals.KafkaMetricsCollector.StateLedger"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.KafkaMetricsCollector",
    "source_method": "collectSum",
    "target_class": "double, org.apache.kafka.common.telemetry.internals.MetricsEmitter, java.time.Instant):void \t org.apache.kafka.common.telemetry.internals.MetricsEmitter"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.KafkaMetricsCollector",
    "source_method": "collectGauge",
    "target_class": "java.lang.Number, org.apache.kafka.common.telemetry.internals.MetricsEmitter, java.time.Instant):void \t org.apache.kafka.common.telemetry.internals.MetricsEmitter"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.KafkaMetricsCollector.StateLedger",
    "source_method": "metricsStateReset",
    "target_class": "org.apache.kafka.common.telemetry.internals.LastValueTracker"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.ClientTelemetryProvider",
    "source_method": "validate",
    "target_class": "org.apache.kafka.common.metrics.MetricsContext"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.SinglePointMetric",
    "source_method": "sum",
    "target_class": "org.apache.kafka.common.telemetry.internals.AggregationTemporality, boolean, NumberDataPoint.Builder, java.util.Set<java.lang.String>):org.apache.kafka.common.telemetry.internals.SinglePointMetric \t org.apache.kafka.common.telemetry.internals.MetricKey"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.SinglePointMetric",
    "source_method": "gauge",
    "target_class": "NumberDataPoint.Builder, java.util.Set<java.lang.String>):org.apache.kafka.common.telemetry.internals.SinglePointMetric \t org.apache.kafka.common.telemetry.internals.MetricKey"
  },
  {
    "source_class": "org.apache.kafka.common.telemetry.internals.ClientTelemetryReporter",
    "source_method": "initCollectors",
    "target_class": "org.apache.kafka.common.telemetry.internals.ClientTelemetryProvider"
  },
  {
    "source_class": "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils",
    "source_method": "credentialToString",
    "target_class": "org.apache.kafka.common.security.scram.ScramCredential"
  },
  {
    "source_class": "org.apache.kafka.common.security.scram.internals.ScramCredentialUtils",
    "source_method": "createCache",
    "target_class": "java.util.Collection<java.lang.String>):void \t org.apache.kafka.common.security.scram.internals.ScramMechanism"
  },
  {
    "source_class": "org.apache.kafka.common.security.scram.internals.ScramSaslClient",
    "source_method": "handleServerFirstMessage",
    "target_class": "org.apache.kafka.common.security.scram.internals.ScramMessages.ClientFinalMessage"
  },
  {
    "source_class": "org.apache.kafka.common.security.scram.internals.ScramSaslClient",
    "source_method": "handleServerFinalMessage",
    "target_class": "org.apache.kafka.common.security.scram.internals.ScramFormatter"
  },
  {
    "source_class": "org.apache.kafka.common.security.scram.internals.ScramFormatter",
    "source_method": "authMessage",
    "target_class": "org.apache.kafka.common.security.scram.internals.ScramMessages.ServerFirstMessage, org.apache.kafka.common.security.scram.internals.ScramMessages.ClientFinalMessage):byte[] \t org.apache.kafka.common.security.scram.internals.ScramMessages.ClientFinalMessage"
  },
  {
    "source_class": "org.apache.kafka.common.security.scram.internals.ScramSaslServer",
    "source_method": "verifyClientProof",
    "target_class": "org.apache.kafka.common.security.scram.internals.ScramMessages.ClientFinalMessage"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator",
    "source_method": "flushNetOutBufferAndUpdateInterestOps",
    "target_class": "org.apache.kafka.common.network.TransportLayer"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator",
    "source_method": "flushNetOutBuffer",
    "target_class": "org.apache.kafka.common.network.Send"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.SaslClientAuthenticator",
    "source_method": "handleSaslHandshakeResponse",
    "target_class": "org.apache.kafka.common.requests.SaslHandshakeResponse"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.LoginManager",
    "source_method": "acquireLoginManager",
    "target_class": "java.lang.String, java.lang.Class<? extends org.apache.kafka.common.security.auth.Login>, java.util.Map<java.lang.String,?>):org.apache.kafka.common.security.authenticator.LoginManager \t org.apache.kafka.common.utils.SecurityUtils"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.LoginManager",
    "source_method": "cacheKey",
    "target_class": "org.apache.kafka.common.security.authenticator.LoginManager.LoginMetadata"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.LoginManager",
    "source_method": "closeAll",
    "target_class": "org.apache.kafka.common.security.auth.Login"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.LoginManager",
    "source_method": "configuredClassOrDefault",
    "target_class": "org.apache.kafka.common.security.JaasContext, java.lang.String, java.lang.String, java.lang.Class<? extends T>):java.lang.Class<? extends T> \t org.apache.kafka.common.security.JaasContext"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.CredentialCache",
    "source_method": "cache",
    "target_class": "java.lang.Class<C>):org.apache.kafka.common.security.authenticator.CredentialCache.Cache<C> \t org.apache.kafka.common.security.authenticator.CredentialCache.Cache"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator",
    "source_method": "flushNetOutBufferAndUpdateInterestOps",
    "target_class": "org.apache.kafka.common.network.TransportLayer"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator",
    "source_method": "flushNetOutBuffer",
    "target_class": "org.apache.kafka.common.network.Send"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator",
    "source_method": "serverAddress",
    "target_class": "org.apache.kafka.common.network.TransportLayer"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator",
    "source_method": "clientAddress",
    "target_class": "org.apache.kafka.common.network.TransportLayer"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator",
    "source_method": "clientPort",
    "target_class": "org.apache.kafka.common.network.TransportLayer"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator",
    "source_method": "buildResponseOnAuthenticateFailure",
    "target_class": "org.apache.kafka.common.requests.AbstractResponse):void \t org.apache.kafka.common.requests.RequestContext"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator",
    "source_method": "sendKafkaResponse",
    "target_class": "org.apache.kafka.common.requests.AbstractResponse):void \t org.apache.kafka.common.requests.RequestContext"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.SaslServerAuthenticator.ReauthInfo",
    "source_method": "ensurePrincipalUnchanged",
    "target_class": "org.apache.kafka.common.security.auth.KafkaPrincipal"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.DefaultKafkaPrincipalBuilder",
    "source_method": "applyKerberosShortNamer",
    "target_class": "org.apache.kafka.common.security.kerberos.KerberosShortNamer"
  },
  {
    "source_class": "org.apache.kafka.common.security.authenticator.DefaultKafkaPrincipalBuilder",
    "source_method": "applySslPrincipalMapper",
    "target_class": "org.apache.kafka.common.security.ssl.SslPrincipalMapper"
  },
  {
    "source_class": "org.apache.kafka.common.security.ssl.SslFactory",
    "source_method": "createSslEngine",
    "target_class": "int):javax.net.ssl.SSLEngine \t org.apache.kafka.common.security.auth.SslEngineFactory"
  },
  {
    "source_class": "org.apache.kafka.common.security.ssl.DefaultSslEngineFactory",
    "source_method": "createSslClientAuth",
    "target_class": "org.apache.kafka.common.config.SslClientAuth"
  },
  {
    "source_class": "org.apache.kafka.common.security.ssl.DefaultSslEngineFactory",
    "source_method": "getTrustManagers",
    "target_class": "java.lang.String):javax.net.ssl.TrustManager[] \t org.apache.kafka.common.security.ssl.DefaultSslEngineFactory.SecurityStore"
  },
  {
    "source_class": "org.apache.kafka.common.security.ssl.DefaultSslEngineFactory.FileBasedStore",
    "source_method": "load",
    "target_class": "org.apache.kafka.common.config.types.Password"
  },
  {
    "source_class": "org.apache.kafka.common.security.ssl.DefaultSslEngineFactory.PemStore",
    "source_method": "certs",
    "target_class": "org.apache.kafka.common.security.ssl.DefaultSslEngineFactory.PemParser"
  },
  {
    "source_class": "org.apache.kafka.common.security.ssl.DefaultSslEngineFactory.PemStore",
    "source_method": "privateKey",
    "target_class": "char[]):java.security.PrivateKey \t org.apache.kafka.common.security.ssl.DefaultSslEngineFactory.PemParser"
  },
  {
    "source_class": "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache",
    "source_method": "credential",
    "target_class": "java.lang.String):org.apache.kafka.common.security.scram.ScramCredential \t org.apache.kafka.common.security.authenticator.CredentialCache"
  },
  {
    "source_class": "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache",
    "source_method": "owner",
    "target_class": "org.apache.kafka.common.security.token.delegation.TokenInformation"
  },
  {
    "source_class": "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache",
    "source_method": "updateCache",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.common.security.scram.ScramCredential>):void \t org.apache.kafka.common.security.token.delegation.DelegationToken"
  },
  {
    "source_class": "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache",
    "source_method": "removeToken",
    "target_class": "org.apache.kafka.common.security.token.delegation.TokenInformation"
  },
  {
    "source_class": "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache",
    "source_method": "credentialCache",
    "target_class": "org.apache.kafka.common.security.authenticator.CredentialCache"
  },
  {
    "source_class": "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache",
    "source_method": "updateCredentials",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.common.security.scram.ScramCredential>):void \t org.apache.kafka.common.security.authenticator.CredentialCache"
  },
  {
    "source_class": "org.apache.kafka.common.security.token.delegation.TokenInformation",
    "source_method": "ownerAsString",
    "target_class": "org.apache.kafka.common.security.auth.KafkaPrincipal"
  },
  {
    "source_class": "org.apache.kafka.common.security.token.delegation.TokenInformation",
    "source_method": "tokenRequesterAsString",
    "target_class": "org.apache.kafka.common.security.auth.KafkaPrincipal"
  },
  {
    "source_class": "org.apache.kafka.common.security.token.delegation.TokenInformation",
    "source_method": "renewersAsString",
    "target_class": "org.apache.kafka.common.security.auth.KafkaPrincipal"
  },
  {
    "source_class": "org.apache.kafka.common.security.token.delegation.TokenInformation",
    "source_method": "ownerOrRenewer",
    "target_class": "org.apache.kafka.common.security.auth.KafkaPrincipal"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.secured.JaasOptionsUtils",
    "source_method": "getSslClientConfig",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.secured.AccessTokenValidatorFactory",
    "source_method": "create",
    "target_class": "java.lang.String):org.apache.kafka.common.security.oauthbearer.internals.secured.AccessTokenValidator \t org.apache.kafka.common.security.oauthbearer.internals.secured.ConfigurationUtils"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.secured.AccessTokenValidatorFactory",
    "source_method": "create",
    "target_class": "java.lang.String, org.apache.kafka.common.security.oauthbearer.internals.secured.VerificationKeyResolver):org.apache.kafka.common.security.oauthbearer.internals.secured.AccessTokenValidator \t org.apache.kafka.common.security.oauthbearer.internals.secured.ConfigurationUtils"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.secured.AccessTokenRetrieverFactory",
    "source_method": "create",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.Object>):org.apache.kafka.common.security.oauthbearer.internals.secured.AccessTokenRetriever \t org.apache.kafka.common.security.oauthbearer.internals.secured.ConfigurationUtils"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.secured.VerificationKeyResolverFactory",
    "source_method": "create",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.Object>):org.apache.kafka.common.security.oauthbearer.internals.secured.CloseableVerificationKeyResolver \t org.apache.kafka.common.security.oauthbearer.internals.secured.JaasOptionsUtils"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.secured.HttpAccessTokenRetriever",
    "source_method": "formatAuthorizationHeader",
    "target_class": "java.lang.String):java.lang.String \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredJws",
    "source_method": "toMap",
    "target_class": "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler",
    "source_method": "handleExtensionsCallback",
    "target_class": "org.apache.kafka.common.security.auth.SaslExtensionsCallback"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerUnsecuredLoginCallbackHandler",
    "source_method": "expClaimText",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils",
    "source_method": "validateClaimForExistenceAndType",
    "target_class": "boolean, java.lang.String, java.lang.Class<?>[]):org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult \t org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils",
    "source_method": "validateExpirationTime",
    "target_class": "long, int):org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult \t org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils",
    "source_method": "validateTimeConsistency",
    "target_class": "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils",
    "source_method": "validateScope",
    "target_class": "java.util.List<java.lang.String>):org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult \t org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationUtils",
    "source_method": "doesNotExistResult",
    "target_class": "java.lang.String):org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult \t org.apache.kafka.common.security.oauthbearer.internals.unsecured.OAuthBearerValidationResult"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerSaslClientCallbackHandler",
    "source_method": "handleCallback",
    "target_class": "javax.security.auth.Subject):void \t org.apache.kafka.common.security.auth.SaslExtensionsCallback"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse",
    "source_method": "validateExtensions",
    "target_class": "org.apache.kafka.common.security.auth.SaslExtensions"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.OAuthBearerClientInitialResponse",
    "source_method": "extensionsMessage",
    "target_class": "org.apache.kafka.common.security.auth.SaslExtensions"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin.LoginContextFactory",
    "source_method": "createLoginContext",
    "target_class": "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin",
    "source_method": "currentMs",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshingLogin",
    "source_method": "isLogoutRequiredBeforeLoggingBackIn",
    "target_class": "org.apache.kafka.common.security.oauthbearer.internals.expiring.ExpiringCredentialRefreshConfig"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.OAuthBearerExtensionsValidatorCallback",
    "source_method": "ignoredExtensions",
    "target_class": "org.apache.kafka.common.security.auth.SaslExtensions"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.OAuthBearerExtensionsValidatorCallback",
    "source_method": "valid",
    "target_class": "org.apache.kafka.common.security.auth.SaslExtensions"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.OAuthBearerValidatorCallbackHandler",
    "source_method": "handleExtensionsValidatorCallback",
    "target_class": "org.apache.kafka.common.security.oauthbearer.OAuthBearerExtensionsValidatorCallback"
  },
  {
    "source_class": "org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginCallbackHandler",
    "source_method": "handleExtensionsCallback",
    "target_class": "org.apache.kafka.common.security.auth.SaslExtensionsCallback"
  },
  {
    "source_class": "org.apache.kafka.common.security.kerberos.KerberosLogin",
    "source_method": "getServiceName",
    "target_class": "java.lang.String, javax.security.auth.login.Configuration):java.lang.String \t org.apache.kafka.common.security.JaasContext"
  },
  {
    "source_class": "org.apache.kafka.common.security.kerberos.KerberosLogin",
    "source_method": "currentElapsedTime",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.common.security.kerberos.KerberosLogin",
    "source_method": "currentWallTime",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.common.security.kerberos.KerberosShortNamer",
    "source_method": "shortName",
    "target_class": "org.apache.kafka.common.security.kerberos.KerberosName"
  },
  {
    "source_class": "org.apache.kafka.common.security.JaasContext",
    "source_method": "defaultContext",
    "target_class": "java.lang.String, java.lang.String):org.apache.kafka.common.security.JaasContext \t org.apache.kafka.common.security.JaasUtils"
  },
  {
    "source_class": "org.apache.kafka.common.network.SslChannelBuilder",
    "source_method": "buildTransportLayer",
    "target_class": "java.lang.String, java.nio.channels.SelectionKey, org.apache.kafka.common.network.ChannelMetadataRegistry):org.apache.kafka.common.network.SslTransportLayer \t org.apache.kafka.common.security.ssl.SslFactory"
  },
  {
    "source_class": "org.apache.kafka.common.network.ChannelBuilders",
    "source_method": "clientChannelBuilder",
    "target_class": "org.apache.kafka.common.security.JaasContext.Type, org.apache.kafka.common.config.AbstractConfig, org.apache.kafka.common.network.ListenerName, java.lang.String, org.apache.kafka.common.utils.Time, boolean, org.apache.kafka.common.utils.LogContext):org.apache.kafka.common.network.ChannelBuilder \t org.apache.kafka.common.security.auth.SecurityProtocol"
  },
  {
    "source_class": "org.apache.kafka.common.network.ChannelBuilders",
    "source_method": "channelBuilderConfigs",
    "target_class": "org.apache.kafka.common.network.ListenerName):java.util.Map<java.lang.String,java.lang.Object> \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.common.network.ChannelBuilders",
    "source_method": "createPrincipalBuilder",
    "target_class": "org.apache.kafka.common.security.kerberos.KerberosShortNamer, org.apache.kafka.common.security.ssl.SslPrincipalMapper):org.apache.kafka.common.security.auth.KafkaPrincipalBuilder \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.common.network.ListenerName",
    "source_method": "forSecurityProtocol",
    "target_class": "org.apache.kafka.common.security.auth.SecurityProtocol"
  },
  {
    "source_class": "org.apache.kafka.common.network.ListenerName",
    "source_method": "normalised",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector",
    "source_method": "registerChannel",
    "target_class": "java.nio.channels.SocketChannel, int):java.nio.channels.SelectionKey \t org.apache.kafka.common.network.Selector.IdleExpiryManager"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector",
    "source_method": "buildAndAttachKafkaChannel",
    "target_class": "java.lang.String, java.nio.channels.SelectionKey):org.apache.kafka.common.network.KafkaChannel \t org.apache.kafka.common.network.ChannelBuilder"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector",
    "source_method": "attemptWrite",
    "target_class": "org.apache.kafka.common.network.KafkaChannel, long):void \t org.apache.kafka.common.network.KafkaChannel"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector",
    "source_method": "write",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector",
    "source_method": "determineHandlingOrder",
    "target_class": "org.apache.kafka.common.memory.MemoryPool"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector",
    "source_method": "attemptRead",
    "target_class": "org.apache.kafka.common.network.KafkaChannel"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector",
    "source_method": "maybeRecordTimePerConnection",
    "target_class": "long):void \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector",
    "source_method": "mute",
    "target_class": "org.apache.kafka.common.network.KafkaChannel"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector",
    "source_method": "unmute",
    "target_class": "org.apache.kafka.common.network.KafkaChannel"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector",
    "source_method": "completeDelayedChannelClose",
    "target_class": "org.apache.kafka.common.network.Selector.DelayedAuthenticationFailureClose"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector",
    "source_method": "maybeDelayCloseOnAuthenticationFailure",
    "target_class": "org.apache.kafka.common.network.Selector.DelayedAuthenticationFailureClose"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector",
    "source_method": "lowestPriorityChannel",
    "target_class": "org.apache.kafka.common.network.Selector.IdleExpiryManager"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector",
    "source_method": "hasCompletedReceive",
    "target_class": "org.apache.kafka.common.network.KafkaChannel"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector",
    "source_method": "addToCompletedReceives",
    "target_class": "org.apache.kafka.common.network.NetworkReceive, long):void \t org.apache.kafka.common.network.NetworkReceive"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector.SelectorMetrics",
    "source_method": "createMeter",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.String>, org.apache.kafka.common.metrics.stats.SampledStat, java.lang.String, java.lang.String):org.apache.kafka.common.metrics.stats.Meter \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector.SelectorMetrics",
    "source_method": "createIOThreadRatioMeterLegacy",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.String>, java.lang.String, java.lang.String):org.apache.kafka.common.metrics.stats.Meter \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector.SelectorMetrics",
    "source_method": "createIOThreadRatioMeter",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.String>, java.lang.String, java.lang.String):org.apache.kafka.common.metrics.stats.Meter \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector.SelectorMetrics",
    "source_method": "maybeRegisterConnectionMetrics",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector.SelectorMetrics",
    "source_method": "recordBytesSent",
    "target_class": "long, long):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector.SelectorMetrics",
    "source_method": "recordCompletedSend",
    "target_class": "long, long):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector.SelectorMetrics",
    "source_method": "recordBytesReceived",
    "target_class": "long, long):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.common.network.Selector.SelectorMetrics",
    "source_method": "recordCompletedReceive",
    "target_class": "long, long):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.common.network.SaslChannelBuilder",
    "source_method": "buildTransportLayer",
    "target_class": "java.nio.channels.SelectionKey, java.nio.channels.SocketChannel, org.apache.kafka.common.network.ChannelMetadataRegistry):org.apache.kafka.common.network.TransportLayer \t org.apache.kafka.common.security.ssl.SslFactory"
  },
  {
    "source_class": "org.apache.kafka.common.network.SaslChannelBuilder",
    "source_method": "createServerCallbackHandlers",
    "target_class": "org.apache.kafka.common.security.authenticator.CredentialCache"
  },
  {
    "source_class": "org.apache.kafka.common.network.SaslChannelBuilder",
    "source_method": "createConnectionsMaxReauthMsMap",
    "target_class": "org.apache.kafka.common.network.ListenerName"
  },
  {
    "source_class": "org.apache.kafka.common.network.KafkaChannel",
    "source_method": "mute",
    "target_class": "org.apache.kafka.common.network.TransportLayer"
  },
  {
    "source_class": "org.apache.kafka.common.network.KafkaChannel",
    "source_method": "maybeUnmute",
    "target_class": "org.apache.kafka.common.network.TransportLayer"
  },
  {
    "source_class": "org.apache.kafka.common.network.KafkaChannel",
    "source_method": "delayCloseOnAuthenticationFailure",
    "target_class": "org.apache.kafka.common.network.TransportLayer"
  },
  {
    "source_class": "org.apache.kafka.common.network.KafkaChannel",
    "source_method": "completeCloseOnAuthenticationFailure",
    "target_class": "org.apache.kafka.common.network.Authenticator"
  },
  {
    "source_class": "org.apache.kafka.common.network.KafkaChannel",
    "source_method": "isInMutableState",
    "target_class": "org.apache.kafka.common.network.TransportLayer"
  },
  {
    "source_class": "org.apache.kafka.common.network.KafkaChannel",
    "source_method": "ready",
    "target_class": "org.apache.kafka.common.network.TransportLayer"
  },
  {
    "source_class": "org.apache.kafka.common.network.KafkaChannel",
    "source_method": "socketAddress",
    "target_class": "org.apache.kafka.common.network.TransportLayer"
  },
  {
    "source_class": "org.apache.kafka.common.network.KafkaChannel",
    "source_method": "socketPort",
    "target_class": "org.apache.kafka.common.network.TransportLayer"
  },
  {
    "source_class": "org.apache.kafka.common.network.KafkaChannel",
    "source_method": "socketDescription",
    "target_class": "org.apache.kafka.common.network.TransportLayer"
  },
  {
    "source_class": "org.apache.kafka.common.network.KafkaChannel",
    "source_method": "setSend",
    "target_class": "org.apache.kafka.common.network.TransportLayer"
  },
  {
    "source_class": "org.apache.kafka.common.network.KafkaChannel",
    "source_method": "maybeCompleteSend",
    "target_class": "org.apache.kafka.common.network.TransportLayer"
  },
  {
    "source_class": "org.apache.kafka.common.network.KafkaChannel",
    "source_method": "maybeCompleteReceive",
    "target_class": "org.apache.kafka.common.network.NetworkReceive"
  },
  {
    "source_class": "org.apache.kafka.common.network.KafkaChannel",
    "source_method": "write",
    "target_class": "org.apache.kafka.common.network.NetworkSend"
  },
  {
    "source_class": "org.apache.kafka.common.network.KafkaChannel",
    "source_method": "serverAuthenticationSessionExpired",
    "target_class": "org.apache.kafka.common.network.Authenticator"
  },
  {
    "source_class": "org.apache.kafka.common.PartitionInfo",
    "source_method": "formatNodeIds",
    "target_class": "org.apache.kafka.common.Node"
  },
  {
    "source_class": "org.apache.kafka.common.memory.SimpleMemoryPool",
    "source_method": "maybeRecordEndOfDrySpell",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.common.acl.AclBinding",
    "source_method": "isUnknown",
    "target_class": "org.apache.kafka.common.acl.AccessControlEntry"
  },
  {
    "source_class": "org.apache.kafka.common.acl.AclBinding",
    "source_method": "toFilter",
    "target_class": "org.apache.kafka.common.acl.AccessControlEntry"
  },
  {
    "source_class": "org.apache.kafka.common.acl.AccessControlEntryFilter",
    "source_method": "matches",
    "target_class": "org.apache.kafka.common.acl.AccessControlEntry"
  },
  {
    "source_class": "org.apache.kafka.common.acl.AclBindingFilter",
    "source_method": "isUnknown",
    "target_class": "org.apache.kafka.common.acl.AccessControlEntryFilter"
  },
  {
    "source_class": "org.apache.kafka.common.acl.AclBindingFilter",
    "source_method": "matchesAtMostOne",
    "target_class": "org.apache.kafka.common.resource.ResourcePatternFilter"
  },
  {
    "source_class": "org.apache.kafka.common.acl.AclBindingFilter",
    "source_method": "findIndefiniteField",
    "target_class": "org.apache.kafka.common.resource.ResourcePatternFilter"
  },
  {
    "source_class": "org.apache.kafka.common.acl.AclBindingFilter",
    "source_method": "matches",
    "target_class": "org.apache.kafka.common.acl.AclBinding"
  },
  {
    "source_class": "org.apache.kafka.common.record.LegacyRecord",
    "source_method": "create",
    "target_class": "long, byte[], byte[], org.apache.kafka.common.record.CompressionType, org.apache.kafka.common.record.TimestampType):org.apache.kafka.common.record.LegacyRecord \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.common.record.LegacyRecord",
    "source_method": "create",
    "target_class": "long, byte[], byte[]):org.apache.kafka.common.record.LegacyRecord \t org.apache.kafka.common.record.TimestampType"
  },
  {
    "source_class": "org.apache.kafka.common.record.LegacyRecord",
    "source_method": "write",
    "target_class": "byte, long, byte[], byte[], org.apache.kafka.common.record.CompressionType, org.apache.kafka.common.record.TimestampType):long \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.common.record.LegacyRecord",
    "source_method": "write",
    "target_class": "byte, long, byte, long, byte[], byte[]):void \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.common.record.LegacyRecord",
    "source_method": "write",
    "target_class": "byte, long, byte, long, java.nio.ByteBuffer, java.nio.ByteBuffer):void \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.common.record.LegacyRecord",
    "source_method": "computeAttributes",
    "target_class": "org.apache.kafka.common.record.CompressionType, org.apache.kafka.common.record.TimestampType):byte \t org.apache.kafka.common.record.TimestampType"
  },
  {
    "source_class": "org.apache.kafka.common.record.LegacyRecord",
    "source_method": "computeChecksum",
    "target_class": "byte, long, byte[], byte[]):long \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.common.record.LegacyRecord",
    "source_method": "crc32",
    "target_class": "int, int):long \t org.apache.kafka.common.utils.Checksums"
  },
  {
    "source_class": "org.apache.kafka.common.record.LegacyRecord",
    "source_method": "computeChecksum",
    "target_class": "byte, long, java.nio.ByteBuffer, java.nio.ByteBuffer):long \t org.apache.kafka.common.utils.Checksums"
  },
  {
    "source_class": "org.apache.kafka.common.record.LegacyRecord",
    "source_method": "timestampType",
    "target_class": "org.apache.kafka.common.record.TimestampType, byte):org.apache.kafka.common.record.TimestampType \t org.apache.kafka.common.record.TimestampType"
  },
  {
    "source_class": "org.apache.kafka.common.record.FileLogInputStream.FileChannelRecordBatch",
    "source_method": "loadBatchWithSize",
    "target_class": "java.lang.String):org.apache.kafka.common.record.RecordBatch \t org.apache.kafka.common.record.FileRecords"
  },
  {
    "source_class": "org.apache.kafka.common.record.MultiRecordsSend",
    "source_method": "updateRecordConversionStats",
    "target_class": "org.apache.kafka.common.record.LazyDownConversionRecordsSend"
  },
  {
    "source_class": "org.apache.kafka.common.record.LazyDownConversionRecordsSend",
    "source_method": "topicPartition",
    "target_class": "org.apache.kafka.common.record.RecordsSend"
  },
  {
    "source_class": "org.apache.kafka.common.record.FileRecords",
    "source_method": "append",
    "target_class": "org.apache.kafka.common.record.MemoryRecords"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecordBatch",
    "source_method": "computeAttributes",
    "target_class": "org.apache.kafka.common.record.TimestampType, boolean, boolean, boolean):byte \t org.apache.kafka.common.record.TimestampType"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecordBatch",
    "source_method": "writeHeader",
    "target_class": "long, int, int, byte, org.apache.kafka.common.record.CompressionType, org.apache.kafka.common.record.TimestampType, long, long, long, short, int, boolean, boolean, boolean, int, int):void \t org.apache.kafka.common.utils.Crc32C"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecordBatch",
    "source_method": "sizeInBytes",
    "target_class": "java.lang.Iterable<org.apache.kafka.common.record.Record>):int \t org.apache.kafka.common.record.Record"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecordBatch",
    "source_method": "sizeInBytes",
    "target_class": "org.apache.kafka.common.record.DefaultRecord"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecordBatch",
    "source_method": "estimateBatchSizeUpperBound",
    "target_class": "java.nio.ByteBuffer, org.apache.kafka.common.header.Header[]):int \t org.apache.kafka.common.record.DefaultRecord"
  },
  {
    "source_class": "org.apache.kafka.common.record.ControlRecordUtils",
    "source_method": "deserializeLeaderChangeMessage",
    "target_class": "org.apache.kafka.common.record.Record"
  },
  {
    "source_class": "org.apache.kafka.common.record.ControlRecordUtils",
    "source_method": "deserializeSnapshotHeaderRecord",
    "target_class": "org.apache.kafka.common.record.Record"
  },
  {
    "source_class": "org.apache.kafka.common.record.ControlRecordUtils",
    "source_method": "deserializeSnapshotFooterRecord",
    "target_class": "org.apache.kafka.common.record.Record"
  },
  {
    "source_class": "org.apache.kafka.common.record.ControlRecordUtils",
    "source_method": "deserializeKRaftVersionRecord",
    "target_class": "org.apache.kafka.common.record.Record"
  },
  {
    "source_class": "org.apache.kafka.common.record.ControlRecordUtils",
    "source_method": "deserializeVotersRecord",
    "target_class": "org.apache.kafka.common.record.Record"
  },
  {
    "source_class": "org.apache.kafka.common.record.ControlRecordUtils",
    "source_method": "validateControlRecordType",
    "target_class": "org.apache.kafka.common.record.ControlRecordType):void \t org.apache.kafka.common.record.ControlRecordType"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "filterTo",
    "target_class": "java.lang.Iterable<org.apache.kafka.common.record.MutableRecordBatch>, org.apache.kafka.common.record.MemoryRecords.RecordFilter, java.nio.ByteBuffer, int, org.apache.kafka.common.utils.BufferSupplier):org.apache.kafka.common.record.MemoryRecords.FilterResult \t org.apache.kafka.common.record.MemoryRecords.FilterResult"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "filterBatch",
    "target_class": "org.apache.kafka.common.utils.BufferSupplier, org.apache.kafka.common.record.MemoryRecords.FilterResult, org.apache.kafka.common.record.MemoryRecords.RecordFilter, byte, boolean, java.util.List<org.apache.kafka.common.record.Record>):org.apache.kafka.common.record.MemoryRecords.BatchFilterResult \t org.apache.kafka.common.record.MemoryRecords.RecordFilter"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "buildRetainedRecordsInto",
    "target_class": "java.util.List<org.apache.kafka.common.record.Record>, org.apache.kafka.common.utils.ByteBufferOutputStream, long):org.apache.kafka.common.record.MemoryRecordsBuilder \t org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "builder",
    "target_class": "org.apache.kafka.common.compress.Compression, org.apache.kafka.common.record.TimestampType, long, int):org.apache.kafka.common.record.MemoryRecordsBuilder \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "idempotentBuilder",
    "target_class": "org.apache.kafka.common.compress.Compression, long, long, short, int):org.apache.kafka.common.record.MemoryRecordsBuilder \t org.apache.kafka.common.record.TimestampType"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "builder",
    "target_class": "byte, org.apache.kafka.common.compress.Compression, org.apache.kafka.common.record.TimestampType, long, long):org.apache.kafka.common.record.MemoryRecordsBuilder \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "builder",
    "target_class": "byte, org.apache.kafka.common.compress.Compression, org.apache.kafka.common.record.TimestampType, long):org.apache.kafka.common.record.MemoryRecordsBuilder \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "builder",
    "target_class": "byte, org.apache.kafka.common.compress.Compression, org.apache.kafka.common.record.TimestampType, long, long, int):org.apache.kafka.common.record.MemoryRecordsBuilder \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "builder",
    "target_class": "org.apache.kafka.common.compress.Compression, long, long, short, int, boolean):org.apache.kafka.common.record.MemoryRecordsBuilder \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withRecords",
    "target_class": "org.apache.kafka.common.record.SimpleRecord[]):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withRecords",
    "target_class": "int, org.apache.kafka.common.record.SimpleRecord[]):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.TimestampType"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withRecords",
    "target_class": "org.apache.kafka.common.compress.Compression, org.apache.kafka.common.record.SimpleRecord[]):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.TimestampType"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withRecords",
    "target_class": "org.apache.kafka.common.compress.Compression, org.apache.kafka.common.record.SimpleRecord[]):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.TimestampType"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withRecords",
    "target_class": "long, org.apache.kafka.common.compress.Compression, org.apache.kafka.common.record.SimpleRecord[]):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.TimestampType"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withRecords",
    "target_class": "org.apache.kafka.common.compress.Compression, java.lang.Integer, org.apache.kafka.common.record.SimpleRecord[]):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.TimestampType"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withIdempotentRecords",
    "target_class": "long, short, int, org.apache.kafka.common.record.SimpleRecord[]):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withIdempotentRecords",
    "target_class": "long, org.apache.kafka.common.compress.Compression, long, short, int, int, org.apache.kafka.common.record.SimpleRecord[]):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.TimestampType"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withIdempotentRecords",
    "target_class": "org.apache.kafka.common.compress.Compression, long, short, int, int, org.apache.kafka.common.record.SimpleRecord[]):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.TimestampType"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withTransactionalRecords",
    "target_class": "long, short, int, org.apache.kafka.common.record.SimpleRecord[]):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withTransactionalRecords",
    "target_class": "long, org.apache.kafka.common.compress.Compression, long, short, int, int, org.apache.kafka.common.record.SimpleRecord[]):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.TimestampType"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withRecords",
    "target_class": "long, org.apache.kafka.common.compress.Compression, org.apache.kafka.common.record.TimestampType, org.apache.kafka.common.record.SimpleRecord[]):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withRecords",
    "target_class": "long, org.apache.kafka.common.compress.Compression, org.apache.kafka.common.record.TimestampType, long, short, int, int, boolean, org.apache.kafka.common.record.SimpleRecord[]):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.compress.Compression"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withEndTransactionMarker",
    "target_class": "short, org.apache.kafka.common.record.EndTransactionMarker):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withEndTransactionMarker",
    "target_class": "long, short, org.apache.kafka.common.record.EndTransactionMarker):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "writeEndTransactionalMarker",
    "target_class": "long, long, int, long, short, org.apache.kafka.common.record.EndTransactionMarker):void \t org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withLeaderChangeMessage",
    "target_class": "long, int, java.nio.ByteBuffer, org.apache.kafka.common.record.LeaderChangeMessage):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withSnapshotHeaderRecord",
    "target_class": "long, int, java.nio.ByteBuffer, org.apache.kafka.common.record.SnapshotHeaderRecord):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withSnapshotFooterRecord",
    "target_class": "long, int, java.nio.ByteBuffer, org.apache.kafka.common.record.SnapshotFooterRecord):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withKRaftVersionRecord",
    "target_class": "long, int, java.nio.ByteBuffer, org.apache.kafka.common.record.KRaftVersionRecord):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "withVotersRecord",
    "target_class": "long, int, java.nio.ByteBuffer, org.apache.kafka.common.record.VotersRecord):org.apache.kafka.common.record.MemoryRecords \t org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecords",
    "source_method": "createKraftControlRecordBuilder",
    "target_class": "long, int, java.nio.ByteBuffer):org.apache.kafka.common.record.MemoryRecordsBuilder \t org.apache.kafka.common.record.TimestampType"
  },
  {
    "source_class": "org.apache.kafka.common.record.RecordsUtil",
    "source_method": "downConvert",
    "target_class": "extends org.apache.kafka.common.record.RecordBatch>, byte, long, org.apache.kafka.common.utils.Time):org.apache.kafka.common.record.ConvertedRecords<org.apache.kafka.common.record.MemoryRecords> \t org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.common.record.RecordsUtil",
    "source_method": "convertRecordBatch",
    "target_class": "java.nio.ByteBuffer, org.apache.kafka.common.record.RecordsUtil.RecordBatchAndRecords):org.apache.kafka.common.record.MemoryRecordsBuilder \t org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.common.record.ControlRecordType",
    "source_method": "recordKey",
    "target_class": "org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.common.record.CompressionRatioEstimator",
    "source_method": "initialCompressionRatio",
    "target_class": "org.apache.kafka.common.record.CompressionType"
  },
  {
    "source_class": "org.apache.kafka.common.record.EndTransactionMarker",
    "source_method": "buildRecordValue",
    "target_class": "org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.common.record.EndTransactionMarker",
    "source_method": "ensureTransactionMarkerControlType",
    "target_class": "org.apache.kafka.common.record.ControlRecordType"
  },
  {
    "source_class": "org.apache.kafka.common.record.EndTransactionMarker",
    "source_method": "deserialize",
    "target_class": "org.apache.kafka.common.record.Record"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecordsBuilder",
    "source_method": "info",
    "target_class": "org.apache.kafka.common.compress.Compression"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecordsBuilder",
    "source_method": "writeDefaultBatchHeader",
    "target_class": "org.apache.kafka.common.compress.Compression"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecordsBuilder",
    "source_method": "writeLegacyCompressedWrapperHeader",
    "target_class": "org.apache.kafka.common.utils.ByteBufferOutputStream"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecordsBuilder",
    "source_method": "appendWithOffset",
    "target_class": "org.apache.kafka.common.record.SimpleRecord):void \t org.apache.kafka.common.record.SimpleRecord"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecordsBuilder",
    "source_method": "appendControlRecordWithOffset",
    "target_class": "org.apache.kafka.common.record.SimpleRecord):void \t org.apache.kafka.common.record.SimpleRecord"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecordsBuilder",
    "source_method": "appendControlRecord",
    "target_class": "org.apache.kafka.common.record.ControlRecordType, java.nio.ByteBuffer):void \t org.apache.kafka.common.protocol.types.Struct"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecordsBuilder",
    "source_method": "appendUncheckedWithOffset",
    "target_class": "org.apache.kafka.common.record.LegacyRecord):void \t org.apache.kafka.common.record.LegacyRecord"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecordsBuilder",
    "source_method": "appendUncheckedWithOffset",
    "target_class": "org.apache.kafka.common.record.SimpleRecord):void \t org.apache.kafka.common.record.SimpleRecord"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecordsBuilder",
    "source_method": "append",
    "target_class": "org.apache.kafka.common.record.Record"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecordsBuilder",
    "source_method": "appendWithOffset",
    "target_class": "org.apache.kafka.common.record.Record):void \t org.apache.kafka.common.record.Record"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecordsBuilder",
    "source_method": "appendWithOffset",
    "target_class": "org.apache.kafka.common.record.LegacyRecord):void \t org.apache.kafka.common.record.LegacyRecord"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecordsBuilder",
    "source_method": "toInnerOffset",
    "target_class": "org.apache.kafka.common.compress.Compression"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecordsBuilder",
    "source_method": "estimatedBytesWritten",
    "target_class": "org.apache.kafka.common.compress.Compression"
  },
  {
    "source_class": "org.apache.kafka.common.record.MemoryRecordsBuilder",
    "source_method": "estimatedSizeInBytes",
    "target_class": "org.apache.kafka.common.record.MemoryRecords"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecord",
    "source_method": "writeTo",
    "target_class": "int, long, java.nio.ByteBuffer, java.nio.ByteBuffer, org.apache.kafka.common.header.Header[]):int \t org.apache.kafka.common.utils.ByteUtils"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecord",
    "source_method": "readFrom",
    "target_class": "long, long, int, java.lang.Long):org.apache.kafka.common.record.DefaultRecord \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecord",
    "source_method": "readFrom",
    "target_class": "long, long, int, java.lang.Long):org.apache.kafka.common.record.DefaultRecord \t org.apache.kafka.common.utils.ByteUtils"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecord",
    "source_method": "readFrom",
    "target_class": "int, long, long, int, java.lang.Long):org.apache.kafka.common.record.DefaultRecord \t org.apache.kafka.common.utils.ByteUtils"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecord",
    "source_method": "readPartiallyFrom",
    "target_class": "long, long, int, java.lang.Long):org.apache.kafka.common.record.PartialDefaultRecord \t org.apache.kafka.common.utils.ByteUtils"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecord",
    "source_method": "readPartiallyFrom",
    "target_class": "int, long, long, int, java.lang.Long):org.apache.kafka.common.record.PartialDefaultRecord \t org.apache.kafka.common.utils.ByteUtils"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecord",
    "source_method": "readHeaders",
    "target_class": "int):org.apache.kafka.common.header.Header[] \t org.apache.kafka.common.utils.ByteUtils"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecord",
    "source_method": "sizeInBytes",
    "target_class": "long, java.nio.ByteBuffer, java.nio.ByteBuffer, org.apache.kafka.common.header.Header[]):int \t org.apache.kafka.common.utils.ByteUtils"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecord",
    "source_method": "sizeInBytes",
    "target_class": "long, int, int, org.apache.kafka.common.header.Header[]):int \t org.apache.kafka.common.utils.ByteUtils"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecord",
    "source_method": "sizeOfBodyInBytes",
    "target_class": "long, int, int, org.apache.kafka.common.header.Header[]):int \t org.apache.kafka.common.utils.ByteUtils"
  },
  {
    "source_class": "org.apache.kafka.common.record.DefaultRecord",
    "source_method": "sizeOf",
    "target_class": "int, org.apache.kafka.common.header.Header[]):int \t org.apache.kafka.common.utils.ByteUtils"
  },
  {
    "source_class": "org.apache.kafka.common.record.AbstractRecords",
    "source_method": "estimateSizeInBytes",
    "target_class": "long, org.apache.kafka.common.record.CompressionType, java.lang.Iterable<org.apache.kafka.common.record.Record>):int \t org.apache.kafka.common.record.Record"
  },
  {
    "source_class": "org.apache.kafka.common.record.AbstractRecords",
    "source_method": "estimateSizeInBytes",
    "target_class": "org.apache.kafka.common.record.CompressionType, java.lang.Iterable<org.apache.kafka.common.record.SimpleRecord>):int \t org.apache.kafka.common.record.SimpleRecord"
  },
  {
    "source_class": "org.apache.kafka.common.record.AbstractRecords",
    "source_method": "estimateCompressedSizeInBytes",
    "target_class": "org.apache.kafka.common.record.CompressionType):int \t org.apache.kafka.common.record.CompressionType"
  },
  {
    "source_class": "org.apache.kafka.common.record.AbstractRecords",
    "source_method": "estimateSizeInBytesUpperBound",
    "target_class": "org.apache.kafka.common.record.CompressionType, byte[], byte[], org.apache.kafka.common.header.Header[]):int \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.common.record.AbstractRecords",
    "source_method": "estimateSizeInBytesUpperBound",
    "target_class": "org.apache.kafka.common.record.CompressionType, java.nio.ByteBuffer, java.nio.ByteBuffer, org.apache.kafka.common.header.Header[]):int \t org.apache.kafka.common.record.LegacyRecord"
  },
  {
    "source_class": "org.apache.kafka.common.record.AbstractRecords",
    "source_method": "recordBatchHeaderSizeInBytes",
    "target_class": "org.apache.kafka.common.record.CompressionType):int \t org.apache.kafka.common.record.LegacyRecord"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.stats.Histogram",
    "source_method": "value",
    "target_class": "org.apache.kafka.common.metrics.stats.Histogram.BinScheme"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.stats.TokenBucket",
    "source_method": "burst",
    "target_class": "org.apache.kafka.common.metrics.MetricConfig"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.stats.SampledStat",
    "source_method": "purgeObsoleteSamples",
    "target_class": "long):void \t org.apache.kafka.common.metrics.MetricConfig"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.stats.SampledStat.Sample",
    "source_method": "isComplete",
    "target_class": "org.apache.kafka.common.metrics.MetricConfig):boolean \t org.apache.kafka.common.metrics.MetricConfig"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.stats.Rate",
    "source_method": "windowSize",
    "target_class": "long):long \t org.apache.kafka.common.metrics.MetricConfig"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.Metrics",
    "source_method": "metricName",
    "target_class": "java.lang.String, java.lang.String, java.util.Map<java.lang.String,java.lang.String>):org.apache.kafka.common.MetricName \t org.apache.kafka.common.metrics.MetricConfig"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.Metrics",
    "source_method": "toHtmlTable",
    "target_class": "java.lang.Iterable<org.apache.kafka.common.MetricNameTemplate>):java.lang.String \t org.apache.kafka.common.MetricNameTemplate"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.JmxReporter",
    "source_method": "removeAttribute",
    "target_class": "java.lang.String):org.apache.kafka.common.metrics.JmxReporter.KafkaMbean \t org.apache.kafka.common.metrics.KafkaMetric"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.JmxReporter",
    "source_method": "addAttribute",
    "target_class": "org.apache.kafka.common.metrics.KafkaMetric"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.JmxReporter",
    "source_method": "getMBeanName",
    "target_class": "org.apache.kafka.common.MetricName):java.lang.String \t org.apache.kafka.common.utils.Sanitizer"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.JmxReporter",
    "source_method": "unregister",
    "target_class": "org.apache.kafka.common.metrics.JmxReporter.KafkaMbean"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.JmxReporter",
    "source_method": "compilePredicate",
    "target_class": "org.apache.kafka.common.utils.ConfigUtils"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.Sensor",
    "source_method": "shouldRecord",
    "target_class": "org.apache.kafka.common.metrics.MetricConfig"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.Sensor",
    "source_method": "record",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.Sensor",
    "source_method": "record",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.Sensor",
    "source_method": "checkQuotas",
    "target_class": "org.apache.kafka.common.metrics.MetricConfig"
  },
  {
    "source_class": "org.apache.kafka.common.metrics.Sensor",
    "source_method": "hasExpired",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.common.resource.ResourcePatternFilter",
    "source_method": "matches",
    "target_class": "org.apache.kafka.common.resource.ResourcePattern"
  },
  {
    "source_class": "org.apache.kafka.common.utils.Exit",
    "source_method": "exit",
    "target_class": "java.lang.String):void \t org.apache.kafka.common.utils.Exit.Procedure"
  },
  {
    "source_class": "org.apache.kafka.common.utils.Exit",
    "source_method": "halt",
    "target_class": "java.lang.String):void \t org.apache.kafka.common.utils.Exit.Procedure"
  },
  {
    "source_class": "org.apache.kafka.common.utils.SecurityUtils",
    "source_method": "addConfiguredSecurityProviders",
    "target_class": "org.apache.kafka.common.security.auth.SecurityProviderCreator"
  },
  {
    "source_class": "org.apache.kafka.common.utils.SecurityUtils",
    "source_method": "authorizeByResourceTypeCheckArgs",
    "target_class": "org.apache.kafka.common.resource.ResourceType):void \t org.apache.kafka.common.acl.AclOperation"
  },
  {
    "source_class": "org.apache.kafka.common.utils.Utils",
    "source_method": "swallow",
    "target_class": "org.apache.kafka.common.utils.Level, java.lang.String, org.apache.kafka.common.utils.Utils.SwallowAction, java.util.concurrent.atomic.AtomicReference<java.lang.Throwable>):void \t org.apache.kafka.common.utils.Utils.SwallowAction"
  },
  {
    "source_class": "org.apache.kafka.common.utils.Utils",
    "source_method": "mergeConfigs",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.common.utils.ConfigUtils",
    "source_method": "configMapToRedactedString",
    "target_class": "org.apache.kafka.common.config.ConfigDef):java.lang.String \t org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.common.utils.ImplicitLinkedHashCollection",
    "source_method": "findIndexOfEqualElement",
    "target_class": "org.apache.kafka.common.utils.ImplicitLinkedHashCollection.Element"
  },
  {
    "source_class": "org.apache.kafka.common.utils.ImplicitLinkedHashCollection",
    "source_method": "addInternal",
    "target_class": "org.apache.kafka.common.utils.ImplicitLinkedHashCollection.Element[]):int \t org.apache.kafka.common.utils.ImplicitLinkedHashCollection.Element"
  },
  {
    "source_class": "org.apache.kafka.common.utils.AppInfoParser",
    "source_method": "registerAppInfo",
    "target_class": "java.lang.String, org.apache.kafka.common.metrics.Metrics, long):void \t org.apache.kafka.common.utils.Sanitizer"
  },
  {
    "source_class": "org.apache.kafka.common.utils.AppInfoParser",
    "source_method": "unregisterAppInfo",
    "target_class": "java.lang.String, org.apache.kafka.common.metrics.Metrics):void \t org.apache.kafka.common.utils.Sanitizer"
  },
  {
    "source_class": "org.apache.kafka.common.utils.AppInfoParser",
    "source_method": "registerMetrics",
    "target_class": "org.apache.kafka.common.utils.AppInfoParser.AppInfo):void \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.common.utils.AppInfoParser",
    "source_method": "unregisterMetrics",
    "target_class": "org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.common.utils.CollectionUtils",
    "source_method": "groupPartitionDataByTopic",
    "target_class": "extends T>):java.util.Map<java.lang.String,java.util.Map<java.lang.Integer,T>> \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.utils.CollectionUtils",
    "source_method": "groupPartitionsByTopic",
    "target_class": "java.util.function.Function<java.lang.String,T>, java.util.function.BiConsumer<T,java.lang.Integer>):java.util.Map<java.lang.String,T> \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.common.utils.Timer",
    "source_method": "update",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.common.Cluster",
    "source_method": "withPartitions",
    "target_class": "org.apache.kafka.common.ClusterResource"
  },
  {
    "source_class": "org.apache.kafka.common.Cluster",
    "source_method": "nodeIfOnline",
    "target_class": "int):java.util.Optional<org.apache.kafka.common.Node> \t org.apache.kafka.common.PartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.common.Cluster",
    "source_method": "leaderFor",
    "target_class": "org.apache.kafka.common.PartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.common.config.ConfigDef",
    "source_method": "parseType",
    "target_class": "java.lang.Object, org.apache.kafka.common.config.ConfigDef.Type):java.lang.Object \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.common.config.ConfigDef",
    "source_method": "convertToStringMapWithPasswordValues",
    "target_class": "org.apache.kafka.common.config.types.Password"
  },
  {
    "source_class": "org.apache.kafka.common.config.ConfigDef",
    "source_method": "compare",
    "target_class": "org.apache.kafka.common.config.ConfigDef.ConfigKey, java.util.Map<java.lang.String,java.lang.Integer>):int \t org.apache.kafka.common.config.ConfigDef.ConfigKey"
  },
  {
    "source_class": "org.apache.kafka.common.config.AbstractConfig",
    "source_method": "typeOf",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.common.config.AbstractConfig",
    "source_method": "documentationOf",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.common.config.AbstractConfig",
    "source_method": "valuesWithPrefixOverride",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.common.config.AbstractConfig",
    "source_method": "nonInternalValues",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.common.config.AbstractConfig",
    "source_method": "maybeClose",
    "target_class": "java.lang.String):void \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.common.config.AbstractConfig",
    "source_method": "resolveConfigVariables",
    "target_class": "java.util.Map<java.lang.String,java.lang.Object>):java.util.Map<java.lang.String,?> \t org.apache.kafka.common.config.ConfigTransformer"
  },
  {
    "source_class": "org.apache.kafka.common.KafkaFuture",
    "source_method": "allOf",
    "target_class": "org.apache.kafka.common.internals.KafkaFutureImpl"
  },
  {
    "source_class": "org.apache.kafka.common.protocol.types.Schema",
    "source_method": "handleNode",
    "target_class": "org.apache.kafka.common.protocol.types.Schema.Visitor):void \t org.apache.kafka.common.protocol.types.Schema.Visitor"
  },
  {
    "source_class": "org.apache.kafka.common.protocol.types.Struct",
    "source_method": "hasField",
    "target_class": "org.apache.kafka.common.protocol.types.Schema"
  },
  {
    "source_class": "org.apache.kafka.common.protocol.types.Struct",
    "source_method": "hasField",
    "target_class": "org.apache.kafka.common.protocol.types.Schema"
  },
  {
    "source_class": "org.apache.kafka.common.protocol.types.Struct",
    "source_method": "hasField",
    "target_class": "org.apache.kafka.common.protocol.types.Schema"
  },
  {
    "source_class": "org.apache.kafka.common.protocol.types.Struct",
    "source_method": "set",
    "target_class": "java.lang.Object):org.apache.kafka.common.protocol.types.Struct \t org.apache.kafka.common.protocol.types.Schema"
  },
  {
    "source_class": "org.apache.kafka.common.protocol.types.Struct",
    "source_method": "setIfExists",
    "target_class": "java.lang.Object):org.apache.kafka.common.protocol.types.Struct \t org.apache.kafka.common.protocol.types.Schema"
  },
  {
    "source_class": "org.apache.kafka.common.protocol.types.Struct",
    "source_method": "writeTo",
    "target_class": "org.apache.kafka.common.protocol.types.Schema"
  },
  {
    "source_class": "org.apache.kafka.common.protocol.types.Struct",
    "source_method": "validateField",
    "target_class": "org.apache.kafka.common.protocol.types.BoundField"
  },
  {
    "source_class": "org.apache.kafka.common.protocol.types.RawTaggedFieldWriter",
    "source_method": "writeRawTags",
    "target_class": "int):void \t org.apache.kafka.common.protocol.Writable"
  },
  {
    "source_class": "org.apache.kafka.common.protocol.SendBuilder",
    "source_method": "addSend",
    "target_class": "org.apache.kafka.common.network.Send"
  },
  {
    "source_class": "org.apache.kafka.common.protocol.ApiKeys",
    "source_method": "retainsBufferReference",
    "target_class": "org.apache.kafka.common.protocol.types.Schema"
  },
  {
    "source_class": "org.apache.kafka.common.protocol.Protocol",
    "source_method": "populateSchemaFields",
    "target_class": "java.util.Set<org.apache.kafka.common.protocol.types.BoundField>):void \t org.apache.kafka.common.protocol.types.Schema"
  },
  {
    "source_class": "org.apache.kafka.common.protocol.MessageUtil",
    "source_method": "toByteBuffer",
    "target_class": "short):java.nio.ByteBuffer \t org.apache.kafka.common.protocol.ByteBufferAccessor"
  },
  {
    "source_class": "org.apache.kafka.common.protocol.MessageUtil",
    "source_method": "toVersionPrefixedByteBuffer",
    "target_class": "org.apache.kafka.common.protocol.Message):java.nio.ByteBuffer \t org.apache.kafka.common.protocol.ByteBufferAccessor"
  },
  {
    "source_class": "org.apache.kafka.common.protocol.MessageUtil",
    "source_method": "toVersionPrefixedBytes",
    "target_class": "org.apache.kafka.common.protocol.Message):byte[] \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.clients.ClientUtils",
    "source_method": "parseAndValidateAddresses",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.ClientUtils",
    "source_method": "parseAndValidateAddresses",
    "target_class": "java.lang.String):java.util.List<java.net.InetSocketAddress> \t org.apache.kafka.clients.ClientDnsLookup"
  },
  {
    "source_class": "org.apache.kafka.clients.ClientUtils",
    "source_method": "parseAndValidateAddresses",
    "target_class": "org.apache.kafka.clients.ClientDnsLookup):java.util.List<java.net.InetSocketAddress> \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.clients.ClientUtils",
    "source_method": "createChannelBuilder",
    "target_class": "org.apache.kafka.common.utils.Time, org.apache.kafka.common.utils.LogContext):org.apache.kafka.common.network.ChannelBuilder \t org.apache.kafka.common.network.ChannelBuilders"
  },
  {
    "source_class": "org.apache.kafka.clients.ClientUtils",
    "source_method": "createNetworkClient",
    "target_class": "org.apache.kafka.common.metrics.Metrics, java.lang.String, org.apache.kafka.common.utils.LogContext, org.apache.kafka.clients.ApiVersions, org.apache.kafka.common.utils.Time, int, org.apache.kafka.clients.Metadata, org.apache.kafka.common.metrics.Sensor, org.apache.kafka.common.telemetry.internals.ClientTelemetrySender):org.apache.kafka.clients.NetworkClient \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.ClientUtils",
    "source_method": "createNetworkClient",
    "target_class": "java.lang.String, org.apache.kafka.common.metrics.Metrics, java.lang.String, org.apache.kafka.common.utils.LogContext, org.apache.kafka.clients.ApiVersions, org.apache.kafka.common.utils.Time, int, int, org.apache.kafka.clients.Metadata, org.apache.kafka.clients.MetadataUpdater, org.apache.kafka.clients.HostResolver, org.apache.kafka.common.metrics.Sensor, org.apache.kafka.common.telemetry.internals.ClientTelemetrySender):org.apache.kafka.clients.NetworkClient \t org.apache.kafka.clients.MetadataRecoveryStrategy"
  },
  {
    "source_class": "org.apache.kafka.clients.ClientUtils",
    "source_method": "configuredInterceptors",
    "target_class": "java.lang.String, java.lang.Class<T>):java.util.List \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.ClientUtils",
    "source_method": "configureClusterResourceListeners",
    "target_class": "org.apache.kafka.common.internals.ClusterResourceListeners"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.ListTopicsResult",
    "source_method": "listings",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.ListTopicsResult",
    "source_method": "names",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.DescribeTransactionsResult",
    "source_method": "description",
    "target_class": "org.apache.kafka.clients.admin.internals.CoordinatorKey"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.RemoveMembersFromConsumerGroupResult",
    "source_method": "maybeCompleteExceptionally",
    "target_class": "org.apache.kafka.clients.admin.MemberIdentity, org.apache.kafka.common.internals.KafkaFutureImpl<java.lang.Void>):boolean \t org.apache.kafka.common.internals.KafkaFutureImpl"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.CoordinatorKey",
    "source_method": "byGroupId",
    "target_class": "org.apache.kafka.common.requests.FindCoordinatorRequest.CoordinatorType"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.CoordinatorKey",
    "source_method": "byTransactionalId",
    "target_class": "org.apache.kafka.common.requests.FindCoordinatorRequest.CoordinatorType"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.AbortTransactionHandler",
    "source_method": "newFuture",
    "target_class": "org.apache.kafka.clients.admin.internals.AdminApiFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.AbortTransactionHandler",
    "source_method": "validateTopicPartitions",
    "target_class": "org.apache.kafka.clients.admin.AbortTransactionSpec"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.AdminBootstrapAddresses",
    "source_method": "fromConfig",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.AllBrokersStrategy.AllBrokersFuture",
    "source_method": "completeExceptionally",
    "target_class": "java.lang.Throwable):void \t org.apache.kafka.common.internals.KafkaFutureImpl"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.PartitionLeaderStrategy",
    "source_method": "failAllPartitionsForTopic",
    "target_class": "java.util.Set<org.apache.kafka.common.TopicPartition>, java.util.Map<org.apache.kafka.common.TopicPartition,java.lang.Throwable>, java.util.function.Function<org.apache.kafka.common.TopicPartition,java.lang.Throwable>):void \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.ListTransactionsHandler",
    "source_method": "requireSingleton",
    "target_class": "int):org.apache.kafka.clients.admin.internals.AllBrokersStrategy.BrokerKey \t org.apache.kafka.clients.admin.internals.AllBrokersStrategy.BrokerKey"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.CoordinatorStrategy",
    "source_method": "requireSingletonAndType",
    "target_class": "org.apache.kafka.clients.admin.internals.CoordinatorKey"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.CoordinatorStrategy",
    "source_method": "ensureSameType",
    "target_class": "org.apache.kafka.clients.admin.internals.CoordinatorKey"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.RemoveMembersFromConsumerGroupHandler",
    "source_method": "newFuture",
    "target_class": "org.apache.kafka.clients.admin.internals.AdminApiFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.ListOffsetsHandler",
    "source_method": "newFuture",
    "target_class": "org.apache.kafka.clients.admin.internals.AdminApiFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.DeleteConsumerGroupOffsetsHandler",
    "source_method": "newFuture",
    "target_class": "org.apache.kafka.clients.admin.internals.CoordinatorKey"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.AlterConsumerGroupOffsetsHandler",
    "source_method": "newFuture",
    "target_class": "org.apache.kafka.clients.admin.internals.CoordinatorKey"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.ListConsumerGroupOffsetsHandler",
    "source_method": "newFuture",
    "target_class": "org.apache.kafka.clients.admin.internals.AdminApiFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.ListConsumerGroupOffsetsHandler",
    "source_method": "buildBatchedRequest",
    "target_class": "org.apache.kafka.clients.admin.ListConsumerGroupOffsetsSpec"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.AdminMetadataManager",
    "source_method": "controller",
    "target_class": "org.apache.kafka.common.Cluster"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.AdminMetadataManager",
    "source_method": "nodeById",
    "target_class": "org.apache.kafka.common.Cluster"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.DeleteRecordsHandler",
    "source_method": "newFuture",
    "target_class": "org.apache.kafka.clients.admin.internals.AdminApiFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.internals.DescribeProducersHandler",
    "source_method": "newFuture",
    "target_class": "org.apache.kafka.clients.admin.internals.AdminApiFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult",
    "source_method": "partitionResult",
    "target_class": "org.apache.kafka.common.internals.KafkaFutureImpl"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.DeleteConsumerGroupOffsetsResult",
    "source_method": "maybeCompleteExceptionally",
    "target_class": "org.apache.kafka.common.TopicPartition, org.apache.kafka.common.internals.KafkaFutureImpl<java.lang.Void>):boolean \t org.apache.kafka.common.internals.KafkaFutureImpl"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.DescribeLogDirsResult",
    "source_method": "convertMapValues",
    "target_class": "org.apache.kafka.clients.admin.LogDirDescription"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.Admin",
    "source_method": "create",
    "target_class": "org.apache.kafka.clients.admin.KafkaAdminClient"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.Admin",
    "source_method": "create",
    "target_class": "org.apache.kafka.clients.admin.KafkaAdminClient"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.Admin",
    "source_method": "listConsumerGroupOffsets",
    "target_class": "org.apache.kafka.clients.admin.ListConsumerGroupOffsetsOptions):org.apache.kafka.clients.admin.ListConsumerGroupOffsetsResult \t org.apache.kafka.clients.admin.ListConsumerGroupOffsetsOptions"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.ListTransactionsResult",
    "source_method": "byBrokerId",
    "target_class": "org.apache.kafka.common.internals.KafkaFutureImpl"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.ListTransactionsResult",
    "source_method": "allByBrokerId",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.DescribeConsumerGroupsResult",
    "source_method": "all",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.AdminClientConfig",
    "source_method": "configNames",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "completeAllExceptionally",
    "target_class": "java.lang.Throwable):void \t org.apache.kafka.common.internals.KafkaFutureImpl"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "generateClientId",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "createInternal",
    "target_class": "org.apache.kafka.clients.admin.KafkaAdminClient.TimeoutProcessorFactory, org.apache.kafka.clients.HostResolver):org.apache.kafka.clients.admin.KafkaAdminClient \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "createInternal",
    "target_class": "org.apache.kafka.clients.admin.internals.AdminMetadataManager, org.apache.kafka.clients.KafkaClient, org.apache.kafka.common.utils.Time):org.apache.kafka.clients.admin.KafkaAdminClient \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient.TimeoutProcessor",
    "source_method": "handleTimeouts",
    "target_class": "java.lang.String):int \t org.apache.kafka.clients.admin.KafkaAdminClient.Call"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "parseDescribeClusterResponse",
    "target_class": "org.apache.kafka.common.requests.ApiError"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "topicIdIsUnrepresentable",
    "target_class": "org.apache.kafka.common.Uuid"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "numPendingCalls",
    "target_class": "org.apache.kafka.clients.admin.KafkaAdminClient.AdminClientRunnable"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "completeUnrealizedFutures",
    "target_class": "java.util.function.Function<K,java.lang.String>):void \t org.apache.kafka.common.internals.KafkaFutureImpl"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "maybeCompleteQuotaExceededException",
    "target_class": "java.lang.Throwable, java.util.Map<K,org.apache.kafka.common.internals.KafkaFutureImpl<V>>, java.util.Map<K,org.apache.kafka.common.errors.ThrottlingQuotaExceededException>, int):void \t org.apache.kafka.common.internals.KafkaFutureImpl"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "handleDeleteTopicsUsingNames",
    "target_class": "org.apache.kafka.clients.admin.DeleteTopicsOptions):java.util.Map<java.lang.String,org.apache.kafka.common.KafkaFuture<java.lang.Void>> \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "handleDeleteTopicsUsingIds",
    "target_class": "org.apache.kafka.clients.admin.DeleteTopicsOptions):java.util.Map<org.apache.kafka.common.Uuid,org.apache.kafka.common.KafkaFuture<java.lang.Void>> \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "handleDescribeTopicsByNamesWithDescribeTopicPartitionsApi",
    "target_class": "org.apache.kafka.clients.admin.DescribeTopicsOptions):java.util.Map<java.lang.String,org.apache.kafka.common.KafkaFuture<org.apache.kafka.clients.admin.TopicDescription>> \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "getTopicDescriptionFromCluster",
    "target_class": "java.lang.String, org.apache.kafka.common.Uuid, java.lang.Integer):org.apache.kafka.clients.admin.TopicDescription \t org.apache.kafka.common.Cluster"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "alterConfigs",
    "target_class": "org.apache.kafka.clients.admin.AlterConfigsOptions, java.util.Collection<org.apache.kafka.common.config.ConfigResource>, org.apache.kafka.clients.admin.KafkaAdminClient.NodeProvider):java.util.Map<org.apache.kafka.common.config.ConfigResource,org.apache.kafka.common.internals.KafkaFutureImpl<java.lang.Void>> \t org.apache.kafka.common.internals.KafkaFutureImpl"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "incrementalAlterConfigs",
    "target_class": "org.apache.kafka.clients.admin.AlterConfigsOptions, java.util.Collection<org.apache.kafka.common.config.ConfigResource>, org.apache.kafka.clients.admin.KafkaAdminClient.NodeProvider):java.util.Map<org.apache.kafka.common.config.ConfigResource,org.apache.kafka.common.internals.KafkaFutureImpl<java.lang.Void>> \t org.apache.kafka.common.internals.KafkaFutureImpl"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "logDirDescriptions",
    "target_class": "org.apache.kafka.common.requests.DescribeLogDirsResponse"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "handleNotControllerError",
    "target_class": "org.apache.kafka.clients.admin.internals.AdminMetadataManager"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "nodeFor",
    "target_class": "org.apache.kafka.common.config.ConfigResource"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "getScramCredentialUpsertion",
    "target_class": "org.apache.kafka.clients.admin.ScramCredentialInfo"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "getScramCredentialDeletion",
    "target_class": "org.apache.kafka.clients.admin.ScramMechanism"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "getSaltedPassword",
    "target_class": "byte[], byte[], int):byte[] \t org.apache.kafka.common.security.scram.internals.ScramFormatter"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "invokeDriver",
    "target_class": "org.apache.kafka.clients.admin.internals.AdminApiFuture<K,V>, java.lang.Integer):void \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "maybeSendRequests",
    "target_class": "long):void \t org.apache.kafka.clients.admin.KafkaAdminClient.AdminClientRunnable"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "newCall",
    "target_class": "org.apache.kafka.clients.admin.internals.AdminApiDriver.RequestSpec<K>):org.apache.kafka.clients.admin.KafkaAdminClient.Call \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "getOffsetFromSpec",
    "target_class": "org.apache.kafka.clients.admin.OffsetSpec.TimestampSpec"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.KafkaAdminClient",
    "source_method": "getSubLevelError",
    "target_class": "K, java.lang.String):java.lang.Throwable \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.FenceProducersResult",
    "source_method": "findAndApply",
    "target_class": "org.apache.kafka.common.KafkaFuture.BaseFunction<org.apache.kafka.common.utils.ProducerIdAndEpoch,T>):org.apache.kafka.common.KafkaFuture<T> \t org.apache.kafka.clients.admin.internals.CoordinatorKey"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.ListClientMetricsResourcesResult",
    "source_method": "all",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.DescribeTopicsResult",
    "source_method": "all",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.AlterConsumerGroupOffsetsResult",
    "source_method": "partitionResult",
    "target_class": "org.apache.kafka.common.internals.KafkaFutureImpl"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.AlterConsumerGroupOffsetsResult",
    "source_method": "all",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.ListConsumerGroupOffsetsResult",
    "source_method": "all",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.DeleteAclsResult",
    "source_method": "getAclBindings",
    "target_class": "org.apache.kafka.clients.admin.DeleteAclsResult.FilterResults"
  },
  {
    "source_class": "org.apache.kafka.clients.admin.UserScramCredentialUpsertion",
    "source_method": "generateRandomSalt",
    "target_class": "org.apache.kafka.common.security.scram.internals.ScramFormatter"
  },
  {
    "source_class": "org.apache.kafka.clients.Metadata",
    "source_method": "fetch",
    "target_class": "org.apache.kafka.clients.MetadataSnapshot"
  },
  {
    "source_class": "org.apache.kafka.clients.NodeApiVersions",
    "source_method": "create",
    "target_class": "org.apache.kafka.common.requests.ApiVersionsResponse"
  },
  {
    "source_class": "org.apache.kafka.clients.NodeApiVersions",
    "source_method": "latestUsableVersion",
    "target_class": "org.apache.kafka.common.protocol.ApiKeys"
  },
  {
    "source_class": "org.apache.kafka.clients.ApiVersions",
    "source_method": "computeMaxUsableProduceMagic",
    "target_class": "org.apache.kafka.clients.NodeApiVersions"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.ConsumerConfig",
    "source_method": "configNames",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager",
    "source_method": "findMinTime",
    "target_class": "extends org.apache.kafka.clients.consumer.internals.RequestState>, long):long \t org.apache.kafka.clients.consumer.internals.RequestState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager",
    "source_method": "requestAutoCommit",
    "target_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager.PendingRequests"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager",
    "source_method": "isStaleEpochErrorAndValidEpochAvailable",
    "target_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager.MemberInfo"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager",
    "source_method": "updateAutoCommitTimer",
    "target_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager.AutoCommitState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager",
    "source_method": "unsentOffsetCommitRequests",
    "target_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager.PendingRequests"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager",
    "source_method": "unsentOffsetFetchRequests",
    "target_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager.PendingRequests"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager",
    "source_method": "handleCoordinatorDisconnect",
    "target_class": "long):void \t org.apache.kafka.clients.consumer.internals.CoordinatorRequestManager"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager",
    "source_method": "resetAutoCommitTimer",
    "target_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager.AutoCommitState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager",
    "source_method": "drainPendingOffsetCommitRequests",
    "target_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager.PendingRequests"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager.AutoCommitState",
    "source_method": "remainingMs",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.CommitEvent",
    "source_method": "validate",
    "target_class": "org.apache.kafka.clients.consumer.OffsetAndMetadata"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.CompletableEvent",
    "source_method": "calculateDeadlineMs",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.CompletableEvent",
    "source_method": "calculateDeadlineMs",
    "target_class": "java.time.Duration):long \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.CompletableEvent",
    "source_method": "calculateDeadlineMs",
    "target_class": "long):long \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.ApplicationEventHandler",
    "source_method": "wakeupNetworkThread",
    "target_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkThread"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.ApplicationEventProcessor",
    "source_method": "process",
    "target_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.ApplicationEventProcessor",
    "source_method": "process",
    "target_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.ApplicationEventProcessor",
    "source_method": "process",
    "target_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.ApplicationEventProcessor",
    "source_method": "process",
    "target_class": "org.apache.kafka.clients.consumer.internals.CommitRequestManager"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.ApplicationEventProcessor",
    "source_method": "process",
    "target_class": "org.apache.kafka.clients.consumer.internals.events.AssignmentChangeEvent"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.ApplicationEventProcessor",
    "source_method": "process",
    "target_class": "org.apache.kafka.clients.consumer.internals.events.ListOffsetsEvent"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.ApplicationEventProcessor",
    "source_method": "process",
    "target_class": "org.apache.kafka.clients.consumer.internals.MembershipManager"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.ApplicationEventProcessor",
    "source_method": "process",
    "target_class": "org.apache.kafka.clients.consumer.internals.RequestManagers"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.ApplicationEventProcessor",
    "source_method": "process",
    "target_class": "org.apache.kafka.clients.consumer.internals.RequestManagers"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.ApplicationEventProcessor",
    "source_method": "process",
    "target_class": "org.apache.kafka.clients.consumer.internals.events.TopicMetadataEvent"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.events.ApplicationEventProcessor",
    "source_method": "process",
    "target_class": "org.apache.kafka.clients.consumer.internals.RequestManagers"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.FetchBuffer",
    "source_method": "awaitNotEmpty",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.FetchBuffer",
    "source_method": "bufferedPartitions",
    "target_class": "org.apache.kafka.clients.consumer.internals.CompletedFetch"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.FetchMetricsManager",
    "source_method": "recordLatency",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.FetchMetricsManager",
    "source_method": "recordBytesFetched",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.FetchMetricsManager",
    "source_method": "recordRecordsFetched",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.FetchMetricsManager",
    "source_method": "recordBytesFetched",
    "target_class": "int):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.FetchMetricsManager",
    "source_method": "recordRecordsFetched",
    "target_class": "int):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.FetchMetricsManager",
    "source_method": "recordPartitionLag",
    "target_class": "long):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.FetchMetricsManager",
    "source_method": "recordPartitionLead",
    "target_class": "long):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.FetchMetricsManager",
    "source_method": "maybeUpdateAssignment",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.FetchMetricsManager",
    "source_method": "topicPartitionTags",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.HeartbeatRequestManager",
    "source_method": "makeHeartbeatRequest",
    "target_class": "boolean):org.apache.kafka.clients.consumer.internals.NetworkClientDelegate.UnsentRequest \t org.apache.kafka.clients.consumer.internals.metrics.HeartbeatMetricsManager"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.HeartbeatRequestManager",
    "source_method": "handleFatalFailure",
    "target_class": "org.apache.kafka.clients.consumer.internals.MembershipManager"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.WakeupTrigger",
    "source_method": "wakeup",
    "target_class": "org.apache.kafka.clients.consumer.internals.WakeupTrigger.ActiveFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.Fetch",
    "source_method": "forPartition",
    "target_class": "java.util.List<org.apache.kafka.clients.consumer.ConsumerRecord<K,V>>, boolean):org.apache.kafka.clients.consumer.internals.Fetch<K,V> \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetsRequestManager",
    "source_method": "resetPositionsIfNeeded",
    "target_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetsRequestManager",
    "source_method": "validatePositionsIfNeeded",
    "target_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.Heartbeat",
    "source_method": "update",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.Heartbeat",
    "source_method": "timeToNextHeartbeat",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.Heartbeat",
    "source_method": "sessionTimeoutExpired",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.Heartbeat",
    "source_method": "resetTimeouts",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.Heartbeat",
    "source_method": "resetSessionTimeout",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.Heartbeat",
    "source_method": "pollTimeoutExpired",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.Heartbeat",
    "source_method": "lastPollTime",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.CompletedFetch",
    "source_method": "recordAggregatedMetrics",
    "target_class": "int):void \t org.apache.kafka.clients.consumer.internals.FetchMetricsAggregator"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.CompletedFetch",
    "source_method": "maybeEnsureValid",
    "target_class": "org.apache.kafka.common.record.RecordBatch):void \t org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.CompletedFetch",
    "source_method": "maybeEnsureValid",
    "target_class": "org.apache.kafka.common.record.Record):void \t org.apache.kafka.common.record.Record"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.CompletedFetch",
    "source_method": "isBatchAborted",
    "target_class": "org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.CompletedFetch",
    "source_method": "containsAbortMarker",
    "target_class": "org.apache.kafka.common.record.RecordBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.Fetcher",
    "source_method": "clearBufferedDataForUnassignedPartitions",
    "target_class": "org.apache.kafka.clients.consumer.internals.FetchBuffer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.RequestManagers",
    "source_method": "supplier",
    "target_class": "org.apache.kafka.common.utils.LogContext, org.apache.kafka.clients.consumer.internals.events.BackgroundEventHandler, org.apache.kafka.clients.consumer.internals.ConsumerMetadata, org.apache.kafka.clients.consumer.internals.SubscriptionState, org.apache.kafka.clients.consumer.internals.FetchBuffer, org.apache.kafka.clients.consumer.ConsumerConfig, org.apache.kafka.clients.GroupRebalanceConfig, org.apache.kafka.clients.ApiVersions, org.apache.kafka.clients.consumer.internals.FetchMetricsManager, java.util.function.Supplier<org.apache.kafka.clients.consumer.internals.NetworkClientDelegate>, java.util.Optional<org.apache.kafka.common.telemetry.internals.ClientTelemetryReporter>, org.apache.kafka.common.metrics.Metrics, org.apache.kafka.clients.consumer.internals.OffsetCommitCallbackInvoker, org.apache.kafka.clients.consumer.internals.MemberStateListener):java.util.function.Supplier<org.apache.kafka.clients.consumer.internals.RequestManagers> \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcher",
    "source_method": "resetPositionsIfNeeded",
    "target_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcher",
    "source_method": "validatePositionsIfNeeded",
    "target_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcher",
    "source_method": "offsetsForTimes",
    "target_class": "org.apache.kafka.common.utils.Timer):java.util.Map<org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetAndTimestamp> \t org.apache.kafka.clients.consumer.internals.ConsumerMetadata"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcher",
    "source_method": "fetchOffsetsByTimes",
    "target_class": "org.apache.kafka.common.utils.Timer, boolean):org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils.ListOffsetResult \t org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcher",
    "source_method": "beginningOrEndOffset",
    "target_class": "long, org.apache.kafka.common.utils.Timer):java.util.Map<org.apache.kafka.common.TopicPartition,java.lang.Long> \t org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcher",
    "source_method": "handleListOffsetResponse",
    "target_class": "org.apache.kafka.clients.consumer.internals.RequestFuture<org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils.ListOffsetResult>):void \t org.apache.kafka.clients.consumer.internals.RequestFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerProtocol",
    "source_method": "serializeSubscription",
    "target_class": "short):java.nio.ByteBuffer \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerProtocol",
    "source_method": "serializeAssignment",
    "target_class": "short):java.nio.ByteBuffer \t org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Assignment"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerProtocol",
    "source_method": "serializeAssignment",
    "target_class": "short):java.nio.ByteBuffer \t org.apache.kafka.common.protocol.MessageUtil"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate",
    "source_method": "inflightRequestCount",
    "target_class": "org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate",
    "source_method": "maybePropagateMetadataError",
    "target_class": "org.apache.kafka.clients.Metadata"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate",
    "source_method": "hasAnyPendingRequests",
    "target_class": "org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate",
    "source_method": "trySend",
    "target_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate.UnsentRequest"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate",
    "source_method": "checkDisconnects",
    "target_class": "org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate",
    "source_method": "makeClientRequest",
    "target_class": "org.apache.kafka.common.Node, long):org.apache.kafka.clients.ClientRequest \t org.apache.kafka.common.Node"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate",
    "source_method": "leastLoadedNode",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate",
    "source_method": "nodeUnavailable",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate",
    "source_method": "add",
    "target_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate.UnsentRequest"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate.UnsentRequest",
    "source_method": "setTimer",
    "target_class": "long):void \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate.UnsentRequest",
    "source_method": "future",
    "target_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate.FutureCompletionHandler"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate.UnsentRequest",
    "source_method": "whenComplete",
    "target_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate.FutureCompletionHandler"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate",
    "source_method": "supplier",
    "target_class": "org.apache.kafka.common.utils.LogContext, org.apache.kafka.clients.consumer.internals.ConsumerMetadata, org.apache.kafka.clients.consumer.ConsumerConfig, org.apache.kafka.clients.ApiVersions, org.apache.kafka.common.metrics.Metrics, org.apache.kafka.clients.consumer.internals.FetchMetricsManager, org.apache.kafka.common.telemetry.internals.ClientTelemetrySender, org.apache.kafka.clients.consumer.internals.events.BackgroundEventHandler):java.util.function.Supplier<org.apache.kafka.clients.consumer.internals.NetworkClientDelegate> \t org.apache.kafka.clients.ClientUtils"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractCoordinator",
    "source_method": "sendSyncGroupRequest",
    "target_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractCoordinator",
    "source_method": "hasGenerationReset",
    "target_class": "org.apache.kafka.clients.consumer.internals.AbstractCoordinator.Generation"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractCoordinator",
    "source_method": "createMeter",
    "target_class": "java.lang.String, java.lang.String, java.lang.String):org.apache.kafka.common.metrics.stats.Meter \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractCoordinator",
    "source_method": "hasMatchingGenerationId",
    "target_class": "org.apache.kafka.clients.consumer.internals.AbstractCoordinator.Generation"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractCoordinator",
    "source_method": "hasUnknownGeneration",
    "target_class": "org.apache.kafka.clients.consumer.internals.AbstractCoordinator.Generation"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.MembershipManagerImpl",
    "source_method": "isCompletingRebalance",
    "target_class": "org.apache.kafka.clients.consumer.internals.MemberState):boolean \t org.apache.kafka.clients.consumer.internals.MemberState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.MembershipManagerImpl",
    "source_method": "isStartingRebalance",
    "target_class": "org.apache.kafka.clients.consumer.internals.MemberState):boolean \t org.apache.kafka.clients.consumer.internals.MemberState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.MembershipManagerImpl",
    "source_method": "clearAssignment",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.MembershipManagerImpl",
    "source_method": "updateSubscriptionAwaitingCallback",
    "target_class": "java.util.SortedSet<org.apache.kafka.common.TopicPartition>):void \t org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.MembershipManagerImpl",
    "source_method": "notifyEpochChange",
    "target_class": "java.util.Optional<java.lang.String>):void \t org.apache.kafka.clients.consumer.internals.MemberStateListener"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.MembershipManagerImpl",
    "source_method": "targetAssignmentReconciled",
    "target_class": "org.apache.kafka.clients.consumer.internals.MembershipManager.LocalAssignment"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.MembershipManagerImpl",
    "source_method": "getDeadlineMsForTimeout",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.MembershipManagerImpl",
    "source_method": "toTopicPartitionSet",
    "target_class": "org.apache.kafka.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.MembershipManagerImpl",
    "source_method": "invokeOnPartitionsRevokedCallback",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.MembershipManagerImpl",
    "source_method": "invokeOnPartitionsAssignedCallback",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.MembershipManagerImpl",
    "source_method": "invokeOnPartitionsLostCallback",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.MembershipManagerImpl",
    "source_method": "clearPendingAssignmentsAndLocalNamesCache",
    "target_class": "org.apache.kafka.clients.consumer.internals.MembershipManager.LocalAssignment"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.MembershipManagerImpl",
    "source_method": "topicPartitionsAwaitingReconciliation",
    "target_class": "org.apache.kafka.clients.consumer.internals.MembershipManager.LocalAssignment"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.RequestState",
    "source_method": "onSuccessfulAttempt",
    "target_class": "org.apache.kafka.common.utils.ExponentialBackoff"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.RequestState",
    "source_method": "onFailedAttempt",
    "target_class": "org.apache.kafka.common.utils.ExponentialBackoff"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "send",
    "target_class": "org.apache.kafka.common.requests.AbstractRequest.Builder<?>, int):org.apache.kafka.clients.consumer.internals.RequestFuture<org.apache.kafka.clients.ClientResponse> \t org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "leastLoadedNode",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "hasReadyNodes",
    "target_class": "org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "awaitMetadataUpdate",
    "target_class": "org.apache.kafka.clients.Metadata"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "ensureFreshMetadata",
    "target_class": "org.apache.kafka.clients.Metadata"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "poll",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "poll",
    "target_class": "org.apache.kafka.common.utils.Timer, boolean):boolean \t org.apache.kafka.clients.consumer.internals.RequestFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "pollNoWakeup",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "transmitSends",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "awaitPendingRequests",
    "target_class": "org.apache.kafka.common.utils.Timer):boolean \t org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "pendingRequestCount",
    "target_class": "org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "hasPendingRequests",
    "target_class": "org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "pendingRequestCount",
    "target_class": "org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "hasPendingRequests",
    "target_class": "org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "firePendingCompletedRequests",
    "target_class": "org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "checkDisconnects",
    "target_class": "org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "handlePendingDisconnects",
    "target_class": "org.apache.kafka.common.Node"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "disconnectAsync",
    "target_class": "org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "failExpiredRequests",
    "target_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.UnsentRequests"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "failUnsentRequests",
    "target_class": "java.lang.RuntimeException):void \t org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.UnsentRequests"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient",
    "source_method": "trySend",
    "target_class": "org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.UnsentRequests",
    "source_method": "removeExpiredRequests",
    "target_class": "org.apache.kafka.clients.ClientRequest"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.FetchMetricsAggregator",
    "source_method": "record",
    "target_class": "int, int):void \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.FetchMetricsAggregator",
    "source_method": "maybeRecordMetrics",
    "target_class": "org.apache.kafka.clients.consumer.internals.FetchMetricsManager"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState",
    "source_method": "assignedState",
    "target_class": "org.apache.kafka.common.internals.PartitionStates"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState",
    "source_method": "assignedStateOrNull",
    "target_class": "org.apache.kafka.common.internals.PartitionStates"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState",
    "source_method": "collectPartitions",
    "target_class": "org.apache.kafka.common.internals.PartitionStates"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState.TopicPartitionState",
    "source_method": "validatePosition",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState.FetchPosition"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetCommitCallbackInvoker",
    "source_method": "enqueueInterceptorInvocation",
    "target_class": "org.apache.kafka.clients.consumer.internals.ConsumerInterceptors"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AsyncKafkaConsumer.BackgroundEventProcessor",
    "source_method": "process",
    "target_class": "org.apache.kafka.clients.consumer.internals.events.ErrorEvent"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AsyncKafkaConsumer",
    "source_method": "updateGroupMetadata",
    "target_class": "java.util.Optional<java.lang.String>):void \t org.apache.kafka.clients.consumer.ConsumerGroupMetadata"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AsyncKafkaConsumer",
    "source_method": "beginningOrEndOffset",
    "target_class": "long, java.time.Duration):java.util.Map<org.apache.kafka.common.TopicPartition,java.lang.Long> \t org.apache.kafka.clients.consumer.internals.events.ApplicationEventHandler"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AsyncKafkaConsumer",
    "source_method": "awaitPendingAsyncCommitsAndExecuteCommitCallbacks",
    "target_class": "boolean):void \t org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AsyncKafkaConsumer",
    "source_method": "updatePatternSubscription",
    "target_class": "org.apache.kafka.common.Cluster"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AsyncKafkaConsumer",
    "source_method": "resetGroupMetadata",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerGroupMetadata"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AsyncKafkaConsumer",
    "source_method": "updateFetchPositions",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AsyncKafkaConsumer",
    "source_method": "canReusePendingOffsetFetchEvent",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AsyncKafkaConsumer",
    "source_method": "updateLastSeenEpochIfNewer",
    "target_class": "org.apache.kafka.clients.consumer.OffsetAndMetadata):void \t org.apache.kafka.clients.consumer.OffsetAndMetadata"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AsyncKafkaConsumer",
    "source_method": "processBackgroundEvents",
    "target_class": "org.apache.kafka.common.utils.Timer):T \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AsyncKafkaConsumer",
    "source_method": "invokeRebalanceCallbacks",
    "target_class": "org.apache.kafka.clients.consumer.internals.ConsumerRebalanceListenerMethodName, java.util.SortedSet<org.apache.kafka.common.TopicPartition>, java.util.concurrent.CompletableFuture<java.lang.Void>):org.apache.kafka.clients.consumer.internals.events.ConsumerRebalanceListenerCallbackCompletedEvent \t org.apache.kafka.clients.consumer.internals.ConsumerUtils"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AsyncKafkaConsumer",
    "source_method": "maybeUpdateSubscriptionMetadata",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.FetchUtils",
    "source_method": "requestMetadataUpdate",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState, org.apache.kafka.common.TopicPartition):void \t org.apache.kafka.clients.Metadata"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractPartitionAssignor",
    "source_method": "partitionInfosWithoutRacks",
    "target_class": "org.apache.kafka.common.Node"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.TopicMetadataRequestManager",
    "source_method": "requestAllTopicsMetadata",
    "target_class": "org.apache.kafka.clients.consumer.internals.TopicMetadataRequestManager.TopicMetadataRequestState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.TopicMetadataRequestManager",
    "source_method": "requestTopicMetadata",
    "target_class": "long):java.util.concurrent.CompletableFuture<java.util.Map<java.lang.String,java.util.List<org.apache.kafka.common.PartitionInfo>>> \t org.apache.kafka.clients.consumer.internals.TopicMetadataRequestManager.TopicMetadataRequestState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.TopicMetadataRequestManager.TopicMetadataRequestState",
    "source_method": "createUnsentRequest",
    "target_class": "org.apache.kafka.clients.consumer.internals.NetworkClientDelegate.UnsentRequest"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.LegacyKafkaConsumer",
    "source_method": "assignment",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.LegacyKafkaConsumer",
    "source_method": "subscription",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.LegacyKafkaConsumer",
    "source_method": "sendFetches",
    "target_class": "org.apache.kafka.clients.consumer.internals.Fetcher"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.LegacyKafkaConsumer",
    "source_method": "updateAssignmentMetadataIfNeeded",
    "target_class": "boolean):boolean \t org.apache.kafka.clients.consumer.internals.ConsumerCoordinator"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.LegacyKafkaConsumer",
    "source_method": "createTimerForRequest",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.LegacyKafkaConsumer",
    "source_method": "updateFetchPositions",
    "target_class": "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.LegacyKafkaConsumer",
    "source_method": "updateLastSeenEpochIfNewer",
    "target_class": "org.apache.kafka.clients.consumer.OffsetAndMetadata):void \t org.apache.kafka.clients.consumer.OffsetAndMetadata"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.TopicMetadataFetcher",
    "source_method": "sendMetadataRequest",
    "target_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractFetch",
    "source_method": "hasCompletedFetches",
    "target_class": "org.apache.kafka.clients.consumer.internals.FetchBuffer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractFetch",
    "source_method": "hasAvailableFetches",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractFetch",
    "source_method": "handleFetchFailure",
    "target_class": "org.apache.kafka.clients.FetchSessionHandler.FetchRequestData, java.lang.Throwable):void \t org.apache.kafka.clients.FetchSessionHandler"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractFetch",
    "source_method": "fetchablePartitions",
    "target_class": "org.apache.kafka.clients.consumer.internals.FetchBuffer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.SensorBuilder",
    "source_method": "withAvg",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.SensorBuilder",
    "source_method": "withMin",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.SensorBuilder",
    "source_method": "withMax",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.SensorBuilder",
    "source_method": "withValue",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.SensorBuilder",
    "source_method": "withMeter",
    "target_class": "org.apache.kafka.common.MetricNameTemplate):org.apache.kafka.clients.consumer.internals.SensorBuilder \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.SensorBuilder",
    "source_method": "withMeter",
    "target_class": "org.apache.kafka.common.MetricNameTemplate, org.apache.kafka.common.MetricNameTemplate):org.apache.kafka.clients.consumer.internals.SensorBuilder \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator",
    "source_method": "updatePatternSubscription",
    "target_class": "org.apache.kafka.common.Cluster"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator",
    "source_method": "maybeUpdateJoinedSubscription",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator",
    "source_method": "maybeUpdateSubscriptionMetadata",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator",
    "source_method": "updateGroupSubscription",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator",
    "source_method": "doCommitOffsetsAsync",
    "target_class": "org.apache.kafka.clients.consumer.OffsetCommitCallback):org.apache.kafka.clients.consumer.internals.RequestFuture<java.lang.Void> \t org.apache.kafka.clients.consumer.internals.RequestFuture"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator",
    "source_method": "commitOffsetsSync",
    "target_class": "org.apache.kafka.common.utils.Timer):boolean \t org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator",
    "source_method": "maybeAutoCommitOffsetsAsync",
    "target_class": "org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.OffsetCommitCompletion",
    "source_method": "invoke",
    "target_class": "org.apache.kafka.clients.consumer.OffsetCommitCallback"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.TimedRequestState",
    "source_method": "deadlineTimer",
    "target_class": "long):org.apache.kafka.common.utils.Timer \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils",
    "source_method": "getPartitionsToValidate",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils",
    "source_method": "validatePositionsOnMetadataChange",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils",
    "source_method": "getOffsetResetTimestamp",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils",
    "source_method": "offsetResetStrategyTimestamp",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils",
    "source_method": "timestampToOffsetResetStrategy",
    "target_class": "org.apache.kafka.common.requests.ListOffsetsRequest"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils",
    "source_method": "onFailedResponseForValidatingPositions",
    "target_class": "java.lang.RuntimeException):void \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils",
    "source_method": "resetPositionIfNeeded",
    "target_class": "org.apache.kafka.clients.consumer.OffsetResetStrategy, org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils.ListOffsetData):void \t org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils",
    "source_method": "regroupFetchPositionsByLeader",
    "target_class": "org.apache.kafka.clients.Metadata.LeaderAndEpoch"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetFetcherUtils",
    "source_method": "hasUsableOffsetForLeaderEpochVersion",
    "target_class": "org.apache.kafka.clients.NodeApiVersions"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochUtils",
    "source_method": "prepareRequest",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochUtils",
    "source_method": "handleResponse",
    "target_class": "org.apache.kafka.common.requests.OffsetsForLeaderEpochResponse):org.apache.kafka.clients.consumer.internals.OffsetsForLeaderEpochUtils.OffsetForEpochResult \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerUtils",
    "source_method": "createConsumerNetworkClient",
    "target_class": "org.apache.kafka.common.metrics.Metrics, org.apache.kafka.common.utils.LogContext, org.apache.kafka.clients.ApiVersions, org.apache.kafka.common.utils.Time, org.apache.kafka.clients.Metadata, org.apache.kafka.common.metrics.Sensor, long, org.apache.kafka.common.telemetry.internals.ClientTelemetrySender):org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient \t org.apache.kafka.clients.ClientUtils"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerUtils",
    "source_method": "createLogContext",
    "target_class": "org.apache.kafka.clients.GroupRebalanceConfig):org.apache.kafka.common.utils.LogContext \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerUtils",
    "source_method": "configuredIsolationLevel",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerUtils",
    "source_method": "createSubscriptionState",
    "target_class": "org.apache.kafka.common.utils.LogContext):org.apache.kafka.clients.consumer.internals.SubscriptionState \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerUtils",
    "source_method": "createMetrics",
    "target_class": "org.apache.kafka.common.utils.Time):org.apache.kafka.common.metrics.Metrics \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerUtils",
    "source_method": "createMetrics",
    "target_class": "org.apache.kafka.common.utils.Time, java.util.List<org.apache.kafka.common.metrics.MetricsReporter>):org.apache.kafka.common.metrics.Metrics \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerUtils",
    "source_method": "configuredConsumerInterceptors",
    "target_class": "org.apache.kafka.clients.ClientUtils"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerUtils",
    "source_method": "refreshCommittedOffsets",
    "target_class": "org.apache.kafka.clients.consumer.internals.ConsumerMetadata, org.apache.kafka.clients.consumer.internals.SubscriptionState):void \t org.apache.kafka.clients.Metadata"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerUtils",
    "source_method": "getResult",
    "target_class": "org.apache.kafka.common.utils.Timer):T \t org.apache.kafka.common.utils.Timer"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkThread",
    "source_method": "runOnce",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.ConsumerNetworkThread",
    "source_method": "reapExpiredApplicationEvents",
    "target_class": "org.apache.kafka.clients.consumer.internals.events.CompletableEventReaper"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.metrics.HeartbeatMetricsManager",
    "source_method": "recordRequestLatency",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.metrics.RebalanceCallbackMetricsManager",
    "source_method": "recordPartitionsRevokedLatency",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.metrics.RebalanceCallbackMetricsManager",
    "source_method": "recordPartitionsAssignedLatency",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.metrics.RebalanceCallbackMetricsManager",
    "source_method": "recordPartitionsLostLatency",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.metrics.RebalanceMetricsManager",
    "source_method": "createMetric",
    "target_class": "java.lang.String, java.lang.String):org.apache.kafka.common.MetricName \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.metrics.RebalanceMetricsManager",
    "source_method": "recordRebalanceEnded",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.metrics.RebalanceMetricsManager",
    "source_method": "maybeRecordRebalanceFailed",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.metrics.KafkaConsumerMetrics",
    "source_method": "recordPollStart",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.metrics.KafkaConsumerMetrics",
    "source_method": "recordPollEnd",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.metrics.KafkaConsumerMetrics",
    "source_method": "recordCommitSync",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.metrics.KafkaConsumerMetrics",
    "source_method": "recordCommitted",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor.PartitionMovements",
    "source_method": "removeMovementRecordOfPartition",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor.PartitionMovements",
    "source_method": "addPartitionMovementRecord",
    "target_class": "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor.ConsumerPair):void \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor.PartitionMovements",
    "source_method": "getTheActualPartitionToBeMoved",
    "target_class": "java.lang.String, java.lang.String):org.apache.kafka.common.TopicPartition \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor.AbstractAssignmentBuilder",
    "source_method": "getAllTopicPartitions",
    "target_class": "org.apache.kafka.common.PartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor.GeneralAssignmentBuilder",
    "source_method": "assignOwnedPartitions",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor.GeneralAssignmentBuilder",
    "source_method": "getUnassignedPartitions",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor.GeneralAssignmentBuilder",
    "source_method": "maybeAssignPartition",
    "target_class": "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor.RackInfo):boolean \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor.GeneralAssignmentBuilder",
    "source_method": "maybeAssign",
    "target_class": "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor.RackInfo, boolean):void \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.internals.AbstractStickyAssignor.GeneralAssignmentBuilder",
    "source_method": "reassignPartition",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.KafkaConsumer",
    "source_method": "clientId",
    "target_class": "org.apache.kafka.clients.consumer.internals.ConsumerDelegate"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.KafkaConsumer",
    "source_method": "metricsRegistry",
    "target_class": "org.apache.kafka.clients.consumer.internals.ConsumerDelegate"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.KafkaConsumer",
    "source_method": "kafkaConsumerMetrics",
    "target_class": "org.apache.kafka.clients.consumer.internals.ConsumerDelegate"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.KafkaConsumer",
    "source_method": "updateAssignmentMetadataIfNeeded",
    "target_class": "org.apache.kafka.clients.consumer.internals.ConsumerDelegate"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.RangeAssignor",
    "source_method": "assignRanges",
    "target_class": "java.util.function.BiFunction<java.lang.String,org.apache.kafka.common.TopicPartition,java.lang.Boolean>, java.util.Map<java.lang.String,java.util.List<org.apache.kafka.common.TopicPartition>>):void \t org.apache.kafka.clients.consumer.RangeAssignor.TopicAssignmentState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.RangeAssignor",
    "source_method": "assignCoPartitionedWithRackMatching",
    "target_class": "int, java.util.Collection<org.apache.kafka.clients.consumer.RangeAssignor.TopicAssignmentState>, java.util.Map<java.lang.String,java.util.List<org.apache.kafka.common.TopicPartition>>):void \t org.apache.kafka.clients.consumer.RangeAssignor.TopicAssignmentState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.RangeAssignor",
    "source_method": "assign",
    "target_class": "java.util.List<org.apache.kafka.common.TopicPartition>, org.apache.kafka.clients.consumer.RangeAssignor.TopicAssignmentState, java.util.Map<java.lang.String,java.util.List<org.apache.kafka.common.TopicPartition>>):void \t org.apache.kafka.clients.consumer.RangeAssignor.TopicAssignmentState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.RangeAssignor",
    "source_method": "consumerRacks",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.MockConsumer",
    "source_method": "updateFetchPosition",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.MockConsumer",
    "source_method": "resetOffsetPosition",
    "target_class": "org.apache.kafka.clients.consumer.internals.SubscriptionState"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.StickyAssignor",
    "source_method": "serializeTopicPartitionAssignment",
    "target_class": "org.apache.kafka.common.utils.CollectionUtils"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.StickyAssignor",
    "source_method": "deserializeTopicPartitionAssignment",
    "target_class": "org.apache.kafka.common.protocol.types.Schema"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.KafkaShareConsumer",
    "source_method": "clientId",
    "target_class": "org.apache.kafka.clients.consumer.internals.ShareConsumerDelegate"
  },
  {
    "source_class": "org.apache.kafka.clients.consumer.KafkaShareConsumer",
    "source_method": "metricsRegistry",
    "target_class": "org.apache.kafka.clients.consumer.internals.ShareConsumerDelegate"
  },
  {
    "source_class": "org.apache.kafka.clients.NetworkClientUtils",
    "source_method": "isReady",
    "target_class": "org.apache.kafka.common.Node, long):boolean \t org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.NetworkClientUtils",
    "source_method": "awaitReady",
    "target_class": "org.apache.kafka.common.Node, org.apache.kafka.common.utils.Time, long):boolean \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.NetworkClientUtils",
    "source_method": "sendAndReceive",
    "target_class": "org.apache.kafka.clients.ClientRequest, org.apache.kafka.common.utils.Time):org.apache.kafka.clients.ClientResponse \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.NetworkClientUtils",
    "source_method": "isUnavailable",
    "target_class": "org.apache.kafka.common.Node, org.apache.kafka.common.utils.Time):boolean \t org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.NetworkClientUtils",
    "source_method": "maybeThrowAuthFailure",
    "target_class": "org.apache.kafka.common.Node):void \t org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.NetworkClientUtils",
    "source_method": "tryConnect",
    "target_class": "org.apache.kafka.common.Node, org.apache.kafka.common.utils.Time):void \t org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "registerMetrics",
    "target_class": "java.lang.String):void \t org.apache.kafka.clients.producer.internals.BufferPool"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "appendNewBatch",
    "target_class": "int, java.util.Deque<org.apache.kafka.clients.producer.internals.ProducerBatch>, long, byte[], byte[], org.apache.kafka.common.header.Header[], org.apache.kafka.clients.producer.internals.RecordAccumulator.AppendCallbacks, java.nio.ByteBuffer, long):org.apache.kafka.clients.producer.internals.RecordAccumulator.RecordAppendResult \t org.apache.kafka.clients.producer.internals.ProducerBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "allBatchesFull",
    "target_class": "org.apache.kafka.clients.producer.internals.ProducerBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "tryAppend",
    "target_class": "byte[], byte[], org.apache.kafka.common.header.Header[], org.apache.kafka.clients.producer.Callback, java.util.Deque<org.apache.kafka.clients.producer.internals.ProducerBatch>, long):org.apache.kafka.clients.producer.internals.RecordAccumulator.RecordAppendResult \t org.apache.kafka.clients.producer.internals.ProducerBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "expiredBatches",
    "target_class": "org.apache.kafka.clients.producer.internals.ProducerBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "reenqueue",
    "target_class": "long):void \t org.apache.kafka.clients.producer.internals.ProducerBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "splitAndReenqueue",
    "target_class": "org.apache.kafka.clients.producer.internals.ProducerBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "batchReady",
    "target_class": "org.apache.kafka.common.TopicPartition, org.apache.kafka.common.Node, long, boolean, int, boolean, long, java.util.Set<org.apache.kafka.common.Node>):long \t org.apache.kafka.common.utils.ExponentialBackoff"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "partitionReady",
    "target_class": "long, java.lang.String, org.apache.kafka.clients.producer.internals.RecordAccumulator.TopicInfo, long, java.util.Set<org.apache.kafka.common.Node>, java.util.Set<java.lang.String>):long \t org.apache.kafka.clients.producer.internals.ProducerBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "shouldStopDrainBatchesForPartition",
    "target_class": "org.apache.kafka.common.TopicPartition):boolean \t org.apache.kafka.clients.producer.internals.ProducerBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "getDeque",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "getOrCreateDeque",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "deallocate",
    "target_class": "org.apache.kafka.clients.producer.internals.ProducerBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "bufferPoolAvailableMemory",
    "target_class": "org.apache.kafka.clients.producer.internals.BufferPool"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "awaitFlushCompletion",
    "target_class": "org.apache.kafka.clients.producer.internals.IncompleteBatches"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "hasIncomplete",
    "target_class": "org.apache.kafka.clients.producer.internals.IncompleteBatches"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "abortUndrainedBatches",
    "target_class": "org.apache.kafka.clients.producer.internals.IncompleteBatches"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator",
    "source_method": "close",
    "target_class": "org.apache.kafka.clients.producer.internals.BufferPool"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.BuiltInPartitioner",
    "source_method": "partitionForKey",
    "target_class": "int):int \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.FutureRecordMetadata",
    "source_method": "valueOrError",
    "target_class": "org.apache.kafka.clients.producer.internals.ProduceRequestResult"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.FutureRecordMetadata",
    "source_method": "timestamp",
    "target_class": "org.apache.kafka.clients.producer.internals.ProduceRequestResult"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.TransactionManager",
    "source_method": "hasProducerId",
    "target_class": "org.apache.kafka.common.utils.ProducerIdAndEpoch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.TransactionManager",
    "source_method": "resetSequenceForPartition",
    "target_class": "org.apache.kafka.clients.producer.internals.TxnPartitionMap"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.TransactionManager",
    "source_method": "resetSequenceNumbers",
    "target_class": "org.apache.kafka.clients.producer.internals.TxnPartitionMap"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.TransactionManager",
    "source_method": "updateLastAckedOffset",
    "target_class": "org.apache.kafka.clients.producer.internals.ProducerBatch):void \t org.apache.kafka.common.requests.ProduceResponse.PartitionResponse"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.TransactionManager",
    "source_method": "lookupCoordinator",
    "target_class": "org.apache.kafka.clients.producer.internals.TransactionManager.TxnRequestHandler"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.TransactionManager",
    "source_method": "maybeTerminateRequestWithError",
    "target_class": "org.apache.kafka.clients.producer.internals.TransactionManager.TxnRequestHandler"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.TransactionManager",
    "source_method": "addPartitionsToTransactionHandler",
    "target_class": "org.apache.kafka.common.requests.AddPartitionsToTxnRequest.Builder"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.TransactionManager",
    "source_method": "txnOffsetCommitHandler",
    "target_class": "java.util.Map<org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetAndMetadata>, org.apache.kafka.clients.consumer.ConsumerGroupMetadata):org.apache.kafka.clients.producer.internals.TransactionManager.TxnOffsetCommitHandler \t org.apache.kafka.clients.consumer.ConsumerGroupMetadata"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.TransactionManager",
    "source_method": "handleCachedTransactionRequestResult",
    "target_class": "org.apache.kafka.clients.producer.internals.TransactionManager.State, java.lang.String):org.apache.kafka.clients.producer.internals.TransactionalRequestResult \t org.apache.kafka.clients.producer.internals.TransactionalRequestResult"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.TxnPartitionMap",
    "source_method": "lastAckedOffset",
    "target_class": "org.apache.kafka.clients.producer.internals.TxnPartitionEntry"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.TxnPartitionMap",
    "source_method": "lastAckedSequence",
    "target_class": "org.apache.kafka.clients.producer.internals.TxnPartitionEntry"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.TxnPartitionMap",
    "source_method": "maybeUpdateLastAckedSequence",
    "target_class": "int):int \t org.apache.kafka.clients.producer.internals.TxnPartitionEntry"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.TxnPartitionEntry",
    "source_method": "startSequencesAtBeginning",
    "target_class": "org.apache.kafka.clients.producer.internals.ProducerBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.TxnPartitionEntry",
    "source_method": "adjustSequencesDueToFailedBatch",
    "target_class": "int):void \t org.apache.kafka.clients.producer.internals.ProducerBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.ProducerInterceptors",
    "source_method": "extractTopicPartition",
    "target_class": "org.apache.kafka.clients.producer.ProducerRecord"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.BufferPool",
    "source_method": "recordWaitTime",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.DefaultPartitioner",
    "source_method": "partition",
    "target_class": "java.lang.Object, byte[], java.lang.Object, byte[], org.apache.kafka.common.Cluster, int):int \t org.apache.kafka.clients.producer.internals.StickyPartitionCache"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.DefaultPartitioner",
    "source_method": "onNewBatch",
    "target_class": "org.apache.kafka.common.Cluster, int):void \t org.apache.kafka.clients.producer.internals.StickyPartitionCache"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.ProducerBatch",
    "source_method": "tryAppend",
    "target_class": "byte[], byte[], org.apache.kafka.common.header.Header[], org.apache.kafka.clients.producer.Callback, long):org.apache.kafka.clients.producer.internals.FutureRecordMetadata \t org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.ProducerBatch",
    "source_method": "tryAppendForSplit",
    "target_class": "java.nio.ByteBuffer, java.nio.ByteBuffer, org.apache.kafka.common.header.Header[], org.apache.kafka.clients.producer.internals.ProducerBatch.Thunk):boolean \t org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.ProducerBatch",
    "source_method": "createBatchOffAccumulatorForRecord",
    "target_class": "int):org.apache.kafka.clients.producer.internals.ProducerBatch \t org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.ProducerBatch",
    "source_method": "isCompressed",
    "target_class": "org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.ProducerBatch",
    "source_method": "records",
    "target_class": "org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.ProducerBatch",
    "source_method": "close",
    "target_class": "org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.ProducerBatch",
    "source_method": "abortRecordAppends",
    "target_class": "org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.ProducerBatch",
    "source_method": "isWritable",
    "target_class": "org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.ProducerBatch",
    "source_method": "lastSequence",
    "target_class": "org.apache.kafka.common.record.MemoryRecordsBuilder"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender",
    "source_method": "maybeRemoveFromInflightBatches",
    "target_class": "org.apache.kafka.clients.producer.internals.ProducerBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender",
    "source_method": "maybeRemoveAndDeallocateBatch",
    "target_class": "org.apache.kafka.clients.producer.internals.RecordAccumulator"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender",
    "source_method": "getExpiredInflightBatches",
    "target_class": "org.apache.kafka.clients.producer.internals.ProducerBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender",
    "source_method": "hasPendingTransactionalRequests",
    "target_class": "org.apache.kafka.clients.producer.internals.TransactionManager"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender",
    "source_method": "shouldHandleAuthorizationError",
    "target_class": "org.apache.kafka.clients.producer.internals.TransactionManager"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender",
    "source_method": "maybeFindCoordinatorAndRetry",
    "target_class": "org.apache.kafka.clients.producer.internals.TransactionManager.TxnRequestHandler"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender",
    "source_method": "awaitNodeReady",
    "target_class": "org.apache.kafka.common.requests.FindCoordinatorRequest.CoordinatorType):boolean \t org.apache.kafka.clients.producer.internals.TransactionManager"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender",
    "source_method": "formatErrMsg",
    "target_class": "org.apache.kafka.common.requests.ProduceResponse.PartitionResponse"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender",
    "source_method": "reenqueueBatch",
    "target_class": "long):void \t org.apache.kafka.clients.producer.internals.RecordAccumulator"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender",
    "source_method": "completeBatch",
    "target_class": "org.apache.kafka.common.requests.ProduceResponse.PartitionResponse):void \t org.apache.kafka.clients.producer.internals.ProducerBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender",
    "source_method": "failBatch",
    "target_class": "org.apache.kafka.common.requests.ProduceResponse.PartitionResponse, boolean):void \t org.apache.kafka.common.requests.ProduceResponse.PartitionResponse"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender",
    "source_method": "canRetry",
    "target_class": "org.apache.kafka.common.requests.ProduceResponse.PartitionResponse, long):boolean \t org.apache.kafka.clients.producer.internals.ProducerBatch"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender",
    "source_method": "wakeup",
    "target_class": "org.apache.kafka.clients.KafkaClient"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender",
    "source_method": "throttleTimeSensor",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender.SenderMetrics",
    "source_method": "maybeRegisterTopicMetrics",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender.SenderMetrics",
    "source_method": "recordRetries",
    "target_class": "int):void \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender.SenderMetrics",
    "source_method": "recordErrors",
    "target_class": "int):void \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender.SenderMetrics",
    "source_method": "recordLatency",
    "target_class": "long):void \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.Sender.SenderMetrics",
    "source_method": "recordBatchSplit",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.KafkaProducerMetrics",
    "source_method": "recordFlush",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.KafkaProducerMetrics",
    "source_method": "recordInit",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.KafkaProducerMetrics",
    "source_method": "recordBeginTxn",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.KafkaProducerMetrics",
    "source_method": "recordSendOffsets",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.KafkaProducerMetrics",
    "source_method": "recordCommitTxn",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.KafkaProducerMetrics",
    "source_method": "recordAbortTxn",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.KafkaProducerMetrics",
    "source_method": "recordMetadataWait",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.KafkaProducerMetrics",
    "source_method": "newLatencySensor",
    "target_class": "java.lang.String):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.internals.StickyPartitionCache",
    "source_method": "nextPartition",
    "target_class": "org.apache.kafka.common.Cluster, int):int \t org.apache.kafka.common.Cluster"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.MockProducer.Completion",
    "source_method": "complete",
    "target_class": "org.apache.kafka.clients.producer.internals.ProduceRequestResult"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.KafkaProducer",
    "source_method": "newSender",
    "target_class": "org.apache.kafka.clients.KafkaClient, org.apache.kafka.clients.producer.internals.ProducerMetadata):org.apache.kafka.clients.producer.internals.Sender \t org.apache.kafka.clients.producer.ProducerConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.KafkaProducer",
    "source_method": "configureCompression",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.KafkaProducer",
    "source_method": "lingerMs",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.KafkaProducer",
    "source_method": "configureDeliveryTimeout",
    "target_class": "org.apache.kafka.clients.producer.Logger):int \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.KafkaProducer",
    "source_method": "throwIfProducerClosed",
    "target_class": "org.apache.kafka.clients.producer.internals.Sender"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.KafkaProducer",
    "source_method": "onNewBatch",
    "target_class": "org.apache.kafka.common.Cluster, int):void \t org.apache.kafka.clients.producer.Partitioner"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.KafkaProducer",
    "source_method": "throwIfInvalidGroupMetadata",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerGroupMetadata"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.RecordMetadata",
    "source_method": "topic",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.RecordMetadata",
    "source_method": "partition",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.producer.ProducerConfig",
    "source_method": "configNames",
    "target_class": "org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.clients.NetworkClient",
    "source_method": "canConnect",
    "target_class": "long):boolean \t org.apache.kafka.common.Node"
  },
  {
    "source_class": "org.apache.kafka.clients.NetworkClient",
    "source_method": "throttleDelayMs",
    "target_class": "long):long \t org.apache.kafka.common.Node"
  },
  {
    "source_class": "org.apache.kafka.clients.NetworkClient",
    "source_method": "canSendRequest",
    "target_class": "long):boolean \t org.apache.kafka.clients.ClusterConnectionStates"
  },
  {
    "source_class": "org.apache.kafka.clients.NetworkClient",
    "source_method": "parseResponse",
    "target_class": "org.apache.kafka.common.requests.RequestHeader):org.apache.kafka.common.requests.AbstractResponse \t org.apache.kafka.common.requests.RequestHeader"
  },
  {
    "source_class": "org.apache.kafka.clients.NetworkClient",
    "source_method": "handleCompletedSends",
    "target_class": "long):void \t org.apache.kafka.common.network.Selectable"
  },
  {
    "source_class": "org.apache.kafka.clients.NetworkClient",
    "source_method": "isAnyNodeConnecting",
    "target_class": "org.apache.kafka.clients.MetadataUpdater"
  },
  {
    "source_class": "org.apache.kafka.clients.NetworkClient.TelemetrySender",
    "source_method": "handleFailedRequest",
    "target_class": "org.apache.kafka.common.KafkaException):void \t org.apache.kafka.common.telemetry.internals.ClientTelemetrySender"
  },
  {
    "source_class": "org.apache.kafka.clients.NetworkClient",
    "source_method": "telemetryConnectedNode",
    "target_class": "org.apache.kafka.clients.NetworkClient.TelemetrySender"
  },
  {
    "source_class": "org.apache.kafka.clients.FetchSessionHandler.Builder",
    "source_method": "add",
    "target_class": "org.apache.kafka.common.requests.FetchRequest.PartitionData):void \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "canConnect",
    "target_class": "long):boolean \t org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "isBlackedOut",
    "target_class": "long):boolean \t org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "connectionDelay",
    "target_class": "long):long \t org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "isConnecting",
    "target_class": "org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "isPreparingConnection",
    "target_class": "org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "disconnected",
    "target_class": "long):void \t org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "throttle",
    "target_class": "long):void \t org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "throttleDelayMs",
    "target_class": "long):long \t org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "ready",
    "target_class": "org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "authenticationFailed",
    "target_class": "long, org.apache.kafka.common.errors.AuthenticationException):void \t org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "isReady",
    "target_class": "long):boolean \t org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "isConnected",
    "target_class": "org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "isDisconnected",
    "target_class": "org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "authenticationException",
    "target_class": "org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "resetReconnectBackoff",
    "target_class": "org.apache.kafka.common.utils.ExponentialBackoff"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "resetConnectionSetupTimeout",
    "target_class": "org.apache.kafka.common.utils.ExponentialBackoff"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "updateReconnectBackoff",
    "target_class": "org.apache.kafka.common.utils.ExponentialBackoff"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "updateConnectionSetupTimeout",
    "target_class": "org.apache.kafka.common.utils.ExponentialBackoff"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "lastConnectAttemptMs",
    "target_class": "org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.ClusterConnectionStates",
    "source_method": "connectionSetupTimeoutMs",
    "target_class": "org.apache.kafka.clients.ClusterConnectionStates.NodeConnectionState"
  },
  {
    "source_class": "org.apache.kafka.clients.InFlightRequests",
    "source_method": "incrementThrottleTime",
    "target_class": "long):void \t org.apache.kafka.clients.NetworkClient.InFlightRequest"
  },
  {
    "source_class": "org.apache.kafka.clients.CommonClientConfigs",
    "source_method": "postProcessReconnectBackoffConfigs",
    "target_class": "java.util.Map<java.lang.String,java.lang.Object>):java.util.Map<java.lang.String,java.lang.Object> \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.CommonClientConfigs",
    "source_method": "warnDisablingExponentialBackoff",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.CommonClientConfigs",
    "source_method": "postValidateSaslMechanismConfig",
    "target_class": "org.apache.kafka.common.security.auth.SecurityProtocol"
  },
  {
    "source_class": "org.apache.kafka.clients.CommonClientConfigs",
    "source_method": "metricsReporters",
    "target_class": "org.apache.kafka.common.config.AbstractConfig):java.util.List<org.apache.kafka.common.metrics.MetricsReporter> \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.clients.CommonClientConfigs",
    "source_method": "telemetryReporter",
    "target_class": "org.apache.kafka.common.config.AbstractConfig):java.util.Optional<org.apache.kafka.common.telemetry.internals.ClientTelemetryReporter> \t org.apache.kafka.common.telemetry.internals.ClientTelemetryReporter"
  },
  {
    "source_class": "org.apache.kafka.server.authorizer.Authorizer",
    "source_method": "authorizeByResourceType",
    "target_class": "org.apache.kafka.common.acl.AclOperation, org.apache.kafka.common.resource.ResourceType):org.apache.kafka.server.authorizer.AuthorizationResult \t org.apache.kafka.common.security.auth.KafkaPrincipal"
  },
  {
    "source_class": "org.apache.kafka.security.CredentialProvider",
    "source_method": "updateCredentials",
    "target_class": "java.util.Properties):void \t org.apache.kafka.common.security.authenticator.CredentialCache"
  },
  {
    "source_class": "org.apache.kafka.security.CredentialProvider",
    "source_method": "updateCredential",
    "target_class": "java.lang.String, org.apache.kafka.common.security.scram.ScramCredential):void \t org.apache.kafka.clients.admin.ScramMechanism"
  },
  {
    "source_class": "org.apache.kafka.security.CredentialProvider",
    "source_method": "removeCredentials",
    "target_class": "java.lang.String):void \t org.apache.kafka.clients.admin.ScramMechanism"
  },
  {
    "source_class": "org.apache.kafka.security.authorizer.AclEntry",
    "source_method": "fromBytes",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.security.authorizer.AclEntry",
    "source_method": "authorizationError",
    "target_class": "org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.security.authorizer.AuthorizerUtils",
    "source_method": "createAuthorizer",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.server.ClientMetricsManager",
    "source_method": "isTelemetryReceiverConfigured",
    "target_class": "org.apache.kafka.server.metrics.ClientMetricsReceiverPlugin"
  },
  {
    "source_class": "org.apache.kafka.server.ClientMetricsManager",
    "source_method": "generateNewClientId",
    "target_class": "org.apache.kafka.common.cache.Cache"
  },
  {
    "source_class": "org.apache.kafka.server.ClientMetricsManager",
    "source_method": "clientInstance",
    "target_class": "org.apache.kafka.common.requests.RequestContext):org.apache.kafka.server.metrics.ClientMetricsInstance \t org.apache.kafka.server.metrics.ClientMetricsInstance"
  },
  {
    "source_class": "org.apache.kafka.server.ClientMetricsManager",
    "source_method": "createClientInstanceAndUpdateCache",
    "target_class": "org.apache.kafka.server.metrics.ClientMetricsInstanceMetadata):org.apache.kafka.server.metrics.ClientMetricsInstance \t org.apache.kafka.server.ClientMetricsManager.ClientMetricsStats"
  },
  {
    "source_class": "org.apache.kafka.server.ClientMetricsManager",
    "source_method": "createClientInstance",
    "target_class": "org.apache.kafka.server.metrics.ClientMetricsInstanceMetadata):org.apache.kafka.server.metrics.ClientMetricsInstance \t org.apache.kafka.server.metrics.ClientMetricsInstanceMetadata"
  },
  {
    "source_class": "org.apache.kafka.server.ClientMetricsManager",
    "source_method": "isSupportedCompressionType",
    "target_class": "org.apache.kafka.common.record.CompressionType"
  },
  {
    "source_class": "org.apache.kafka.server.ClientMetricsManager",
    "source_method": "clientInstance",
    "target_class": "org.apache.kafka.common.cache.Cache"
  },
  {
    "source_class": "org.apache.kafka.server.share.CachedSharePartition",
    "source_method": "updateRequestParams",
    "target_class": "org.apache.kafka.common.requests.ShareFetchRequest.SharePartitionData"
  },
  {
    "source_class": "org.apache.kafka.server.AssignmentsManager",
    "source_method": "close",
    "target_class": "org.apache.kafka.queue.KafkaEventQueue"
  },
  {
    "source_class": "org.apache.kafka.server.AssignmentsManager.AssignmentEvent",
    "source_method": "merge",
    "target_class": "org.apache.kafka.server.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.server.AssignmentsManager",
    "source_method": "responseIsError",
    "target_class": "org.apache.kafka.common.requests.AssignReplicasToDirsResponse"
  },
  {
    "source_class": "org.apache.kafka.server.AssignmentsManager",
    "source_method": "filterFailures",
    "target_class": "java.util.Map<org.apache.kafka.server.common.TopicIdPartition,org.apache.kafka.server.AssignmentsManager.AssignmentEvent>):java.util.Set<org.apache.kafka.server.AssignmentsManager.AssignmentEvent> \t org.apache.kafka.common.protocol.Errors"
  },
  {
    "source_class": "org.apache.kafka.server.AssignmentsManager",
    "source_method": "buildRequestData",
    "target_class": "long, java.util.Map<org.apache.kafka.server.common.TopicIdPartition,org.apache.kafka.common.Uuid>):org.apache.kafka.server.AssignReplicasToDirsRequestData \t org.apache.kafka.server.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.streams.internals.ApiUtils",
    "source_method": "checkSupplier",
    "target_class": "org.apache.kafka.streams.kstream.ValueTransformerSupplier"
  },
  {
    "source_class": "org.apache.kafka.streams.internals.metrics.ClientMetrics",
    "source_method": "addVersionMetric",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.internals.metrics.ClientMetrics",
    "source_method": "addCommitIdMetric",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.internals.metrics.ClientMetrics",
    "source_method": "addApplicationIdMetric",
    "target_class": "java.lang.String):void \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.internals.metrics.ClientMetrics",
    "source_method": "addTopologyDescriptionMetric",
    "target_class": "org.apache.kafka.common.metrics.Gauge<java.lang.String>):void \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.internals.metrics.ClientMetrics",
    "source_method": "addStateMetric",
    "target_class": "org.apache.kafka.common.metrics.Gauge<org.apache.kafka.streams.KafkaStreams.State>):void \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.internals.metrics.ClientMetrics",
    "source_method": "addNumAliveStreamThreadMetric",
    "target_class": "org.apache.kafka.common.metrics.Gauge<java.lang.Integer>):void \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.internals.metrics.ClientMetrics",
    "source_method": "failedStreamThreadSensor",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.internals.StreamsConfigUtils",
    "source_method": "processingMode",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.internals.StreamsConfigUtils",
    "source_method": "processingModeString",
    "target_class": "org.apache.kafka.streams.internals.StreamsConfigUtils.ProcessingMode"
  },
  {
    "source_class": "org.apache.kafka.streams.internals.StreamsConfigUtils",
    "source_method": "eosEnabled",
    "target_class": "org.apache.kafka.streams.internals.StreamsConfigUtils.ProcessingMode"
  },
  {
    "source_class": "org.apache.kafka.streams.internals.StreamsConfigUtils",
    "source_method": "getTotalCacheSize",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.query.internals.InternalQueryResultUtil",
    "source_method": "copyAndSubstituteDeserializedResult",
    "target_class": "R):org.apache.kafka.streams.query.QueryResult<R> \t org.apache.kafka.streams.query.QueryResult"
  },
  {
    "source_class": "org.apache.kafka.streams.query.PositionBound",
    "source_method": "unbounded",
    "target_class": "org.apache.kafka.streams.query.Position"
  },
  {
    "source_class": "org.apache.kafka.streams.query.PositionBound",
    "source_method": "isUnbounded",
    "target_class": "org.apache.kafka.streams.query.Position"
  },
  {
    "source_class": "org.apache.kafka.streams.query.QueryResult",
    "source_method": "notUpToBound",
    "target_class": "org.apache.kafka.streams.query.PositionBound, java.lang.Integer):org.apache.kafka.streams.query.QueryResult<R> \t org.apache.kafka.streams.query.FailureReason"
  },
  {
    "source_class": "org.apache.kafka.streams.query.TimestampedRangeQuery",
    "source_method": "withRange",
    "target_class": "K):org.apache.kafka.streams.query.TimestampedRangeQuery<K,V> \t org.apache.kafka.streams.query.ResultOrder"
  },
  {
    "source_class": "org.apache.kafka.streams.query.TimestampedRangeQuery",
    "source_method": "withUpperBound",
    "target_class": "org.apache.kafka.streams.query.ResultOrder"
  },
  {
    "source_class": "org.apache.kafka.streams.query.TimestampedRangeQuery",
    "source_method": "withLowerBound",
    "target_class": "org.apache.kafka.streams.query.ResultOrder"
  },
  {
    "source_class": "org.apache.kafka.streams.query.MultiVersionedKeyQuery",
    "source_method": "withKey",
    "target_class": "org.apache.kafka.streams.query.ResultOrder"
  },
  {
    "source_class": "org.apache.kafka.streams.query.RangeQuery",
    "source_method": "withRange",
    "target_class": "K):org.apache.kafka.streams.query.RangeQuery<K,V> \t org.apache.kafka.streams.query.ResultOrder"
  },
  {
    "source_class": "org.apache.kafka.streams.query.RangeQuery",
    "source_method": "withUpperBound",
    "target_class": "org.apache.kafka.streams.query.ResultOrder"
  },
  {
    "source_class": "org.apache.kafka.streams.query.RangeQuery",
    "source_method": "withLowerBound",
    "target_class": "org.apache.kafka.streams.query.ResultOrder"
  },
  {
    "source_class": "org.apache.kafka.streams.query.RangeQuery",
    "source_method": "withNoBounds",
    "target_class": "org.apache.kafka.streams.query.ResultOrder"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.SessionKeySchema",
    "source_method": "keyByteLength",
    "target_class": "org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.SessionKeySchema",
    "source_method": "from",
    "target_class": "org.apache.kafka.common.serialization.Deserializer<K>, java.lang.String):org.apache.kafka.streams.kstream.Windowed<K> \t org.apache.kafka.common.serialization.Deserializer"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.SessionKeySchema",
    "source_method": "toBinary",
    "target_class": "org.apache.kafka.common.serialization.Serializer<K>, java.lang.String):byte[] \t org.apache.kafka.streams.kstream.Window"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.SessionKeySchema",
    "source_method": "toBinary",
    "target_class": "org.apache.kafka.streams.kstream.Window"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.SessionKeySchema",
    "source_method": "writeBinary",
    "target_class": "org.apache.kafka.streams.kstream.Windowed<org.apache.kafka.common.utils.Bytes>):void \t org.apache.kafka.streams.kstream.Window"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.SessionKeySchema",
    "source_method": "writeBinary",
    "target_class": "org.apache.kafka.common.utils.Bytes, long, long):void \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.QueryableStoreProvider",
    "source_method": "getStore",
    "target_class": "org.apache.kafka.streams.state.internals.GlobalStateStoreProvider"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.CachingWindowStore",
    "source_method": "initInternal",
    "target_class": "java.lang.String):void \t org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.CachingWindowStore",
    "source_method": "putAndMaybeForward",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalProcessorContext<?,?>):void \t org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.SegmentIterator",
    "source_method": "hasNextConditionHasNext",
    "target_class": "org.apache.kafka.streams.state.internals.HasNextCondition"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.ChangeLoggingWindowBytesStore",
    "source_method": "log",
    "target_class": "byte[]):void \t org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.TimeOrderedKeyValueBufferChangelogDeserializationHelper",
    "source_method": "deserializeV0",
    "target_class": "org.apache.kafka.common.utils.Bytes, byte[]):org.apache.kafka.streams.state.internals.TimeOrderedKeyValueBufferChangelogDeserializationHelper.DeserializationResult \t org.apache.kafka.streams.kstream.internals.FullChangeSerde"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.TimeOrderedKeyValueBufferChangelogDeserializationHelper",
    "source_method": "deserializeV1",
    "target_class": "org.apache.kafka.common.utils.Bytes, byte[]):org.apache.kafka.streams.state.internals.TimeOrderedKeyValueBufferChangelogDeserializationHelper.DeserializationResult \t org.apache.kafka.streams.kstream.internals.FullChangeSerde"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.TimeOrderedKeyValueBufferChangelogDeserializationHelper",
    "source_method": "deserializeV2",
    "target_class": "org.apache.kafka.common.utils.Bytes):org.apache.kafka.streams.state.internals.TimeOrderedKeyValueBufferChangelogDeserializationHelper.DeserializationResult \t org.apache.kafka.streams.kstream.internals.FullChangeSerde"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.TimeOrderedKeyValueBufferChangelogDeserializationHelper",
    "source_method": "deserializeV3",
    "target_class": "org.apache.kafka.common.utils.Bytes):org.apache.kafka.streams.state.internals.TimeOrderedKeyValueBufferChangelogDeserializationHelper.DeserializationResult \t org.apache.kafka.clients.consumer.ConsumerRecord"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.MeteredSessionStore",
    "source_method": "registerMetrics",
    "target_class": "org.apache.kafka.streams.processor.TaskId"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.MeteredSessionStore",
    "source_method": "maybeRecordE2ELatency",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.VersionedKeyValueToBytesStoreAdapter",
    "source_method": "serializeAsBytes",
    "target_class": "org.apache.kafka.streams.state.ValueAndTimestamp"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.MeteredKeyValueStore",
    "source_method": "maybeRecordE2ELatency",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.AbstractRocksDBTimeOrderedSegmentedBytesStore",
    "source_method": "fetch",
    "target_class": "long, long, boolean):org.apache.kafka.streams.state.KeyValueIterator<org.apache.kafka.common.utils.Bytes,byte[]> \t org.apache.kafka.streams.state.internals.SegmentedBytesStore.KeySchema"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.OrderedBytes",
    "source_method": "upperRange",
    "target_class": "byte[]):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.OrderedBytes",
    "source_method": "lowerRange",
    "target_class": "byte[]):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.CachingKeyValueStore",
    "source_method": "runKeyQuery",
    "target_class": "org.apache.kafka.streams.query.Position, org.apache.kafka.streams.query.PositionBound, org.apache.kafka.streams.query.QueryConfig):org.apache.kafka.streams.query.QueryResult<R> \t org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.CachingKeyValueStore",
    "source_method": "initInternal",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.CachingKeyValueStore",
    "source_method": "putAndMaybeForward",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalProcessorContext<?,?>):void \t org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.CachingKeyValueStore",
    "source_method": "putInternal",
    "target_class": "byte[]):void \t org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PositionSerde",
    "source_method": "deserialize",
    "target_class": "org.apache.kafka.streams.query.Position"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PositionSerde",
    "source_method": "serialize",
    "target_class": "org.apache.kafka.streams.query.Position"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.CachingSessionStore",
    "source_method": "initInternal",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.CachingSessionStore",
    "source_method": "putAndMaybeForward",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalProcessorContext<?,?>):void \t org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedWindowKeySchemas.TimeFirstWindowKeySchema",
    "source_method": "toStoreKeyBinary",
    "target_class": "int):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.streams.kstream.Window"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedWindowKeySchemas.TimeFirstWindowKeySchema",
    "source_method": "toStoreKeyBinary",
    "target_class": "int, org.apache.kafka.streams.state.StateSerdes<K,?>):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.streams.state.StateSerdes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedWindowKeySchemas.TimeFirstWindowKeySchema",
    "source_method": "toStoreKeyBinary",
    "target_class": "long, int, org.apache.kafka.streams.state.StateSerdes<K,?>):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.streams.state.StateSerdes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedWindowKeySchemas.TimeFirstWindowKeySchema",
    "source_method": "toStoreKeyBinary",
    "target_class": "long, int):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedWindowKeySchemas.KeyFirstWindowKeySchema",
    "source_method": "toStoreKeyBinary",
    "target_class": "long, int, org.apache.kafka.streams.state.StateSerdes<K,?>):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.streams.state.StateSerdes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedWindowKeySchemas.KeyFirstWindowKeySchema",
    "source_method": "toStoreKeyBinary",
    "target_class": "int):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.streams.kstream.Window"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedWindowKeySchemas.KeyFirstWindowKeySchema",
    "source_method": "toStoreKeyBinary",
    "target_class": "int, org.apache.kafka.streams.state.StateSerdes<K,?>):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.streams.state.StateSerdes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedWindowKeySchemas.KeyFirstWindowKeySchema",
    "source_method": "toStoreKeyBinary",
    "target_class": "long, int):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedWindowKeySchemas.KeyFirstWindowKeySchema",
    "source_method": "wrapPrefix",
    "target_class": "boolean):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedWindowKeySchemas.KeyFirstWindowKeySchema",
    "source_method": "fromNonPrefixWindowKey",
    "target_class": "org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.SessionStoreBuilder",
    "source_method": "maybeWrapCaching",
    "target_class": "org.apache.kafka.streams.state.SessionBytesStoreSupplier"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.SessionStoreBuilder",
    "source_method": "retentionPeriod",
    "target_class": "org.apache.kafka.streams.state.SessionBytesStoreSupplier"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StreamThreadStateStoreProvider",
    "source_method": "stores",
    "target_class": "org.apache.kafka.streams.StoreQueryParameters"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.SegmentedCacheFunction",
    "source_method": "cacheKey",
    "target_class": "long):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.SegmentedCacheFunction",
    "source_method": "bytesFromCacheKey",
    "target_class": "org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.SegmentedCacheFunction",
    "source_method": "segmentId",
    "target_class": "org.apache.kafka.streams.state.internals.SegmentedBytesStore.KeySchema"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.SegmentedCacheFunction",
    "source_method": "compareSegmentedKeys",
    "target_class": "org.apache.kafka.common.utils.Bytes):int \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.InMemoryWindowStore",
    "source_method": "wrapForDups",
    "target_class": "int):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.InMemoryWindowStore",
    "source_method": "getKey",
    "target_class": "org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.InMemoryWindowStore.InMemoryWindowStoreIteratorWrapper",
    "source_method": "isKeyWithinRange",
    "target_class": "org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.InMemoryWindowStore.InMemoryWindowStoreIteratorWrapper",
    "source_method": "close",
    "target_class": "org.apache.kafka.streams.state.internals.InMemoryWindowStore.ClosingCallback"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.WindowKeySchema",
    "source_method": "toBinary",
    "target_class": "org.apache.kafka.common.serialization.Serializer<K>, java.lang.String):byte[] \t org.apache.kafka.streams.kstream.Window"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.WindowKeySchema",
    "source_method": "from",
    "target_class": "long, org.apache.kafka.common.serialization.Deserializer<K>, java.lang.String):org.apache.kafka.streams.kstream.Windowed<K> \t org.apache.kafka.common.serialization.Deserializer"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.WindowKeySchema",
    "source_method": "toStoreKeyBinary",
    "target_class": "long, int):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.WindowKeySchema",
    "source_method": "toStoreKeyBinary",
    "target_class": "long, int, org.apache.kafka.streams.state.StateSerdes<K,?>):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.streams.state.StateSerdes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.WindowKeySchema",
    "source_method": "toStoreKeyBinary",
    "target_class": "int):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.streams.kstream.Window"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.WindowKeySchema",
    "source_method": "toStoreKeyBinary",
    "target_class": "int, org.apache.kafka.streams.state.StateSerdes<K,?>):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.streams.state.StateSerdes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.WindowKeySchema",
    "source_method": "toStoreKeyBinary",
    "target_class": "long, int):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.WindowKeySchema",
    "source_method": "extractStoreKey",
    "target_class": "org.apache.kafka.streams.state.StateSerdes<K,?>):K \t org.apache.kafka.streams.state.StateSerdes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.WindowKeySchema",
    "source_method": "fromStoreKey",
    "target_class": "org.apache.kafka.common.serialization.Deserializer<K>, java.lang.String):org.apache.kafka.streams.kstream.Windowed<K> \t org.apache.kafka.common.serialization.Deserializer"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.MeteredWindowStore",
    "source_method": "registerMetrics",
    "target_class": "org.apache.kafka.streams.processor.TaskId"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.MeteredWindowStore",
    "source_method": "maybeRecordE2ELatency",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.RocksDbIndexedTimeOrderedWindowBytesStoreSupplier",
    "source_method": "create",
    "target_class": "java.time.Duration, java.time.Duration, boolean, boolean):org.apache.kafka.streams.state.internals.RocksDbIndexedTimeOrderedWindowBytesStoreSupplier \t org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.RocksDBTimeOrderedKeyValueBuffer",
    "source_method": "computeRecordSize",
    "target_class": "org.apache.kafka.streams.state.internals.BufferValue):long \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.RocksDBTimeOrderedKeyValueBuffer",
    "source_method": "logValue",
    "target_class": "org.apache.kafka.streams.state.internals.BufferKey, org.apache.kafka.streams.state.internals.BufferValue):void \t org.apache.kafka.streams.state.internals.BufferValue"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedSessionKeySchemas.TimeFirstSessionKeySchema",
    "source_method": "toBinary",
    "target_class": "org.apache.kafka.common.serialization.Serializer<K>, java.lang.String):byte[] \t org.apache.kafka.streams.kstream.Window"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedSessionKeySchemas.TimeFirstSessionKeySchema",
    "source_method": "toBinary",
    "target_class": "org.apache.kafka.streams.kstream.Window"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedSessionKeySchemas.TimeFirstSessionKeySchema",
    "source_method": "writeBinary",
    "target_class": "org.apache.kafka.common.utils.Bytes, long, long):void \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedSessionKeySchemas.KeyFirstSessionKeySchema",
    "source_method": "toBinary",
    "target_class": "org.apache.kafka.streams.kstream.Window"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedSessionKeySchemas.KeyFirstSessionKeySchema",
    "source_method": "toBinary",
    "target_class": "org.apache.kafka.common.serialization.Serializer<K>, java.lang.String):byte[] \t org.apache.kafka.streams.kstream.Window"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedSessionKeySchemas.KeyFirstSessionKeySchema",
    "source_method": "toBinary",
    "target_class": "long, long):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.PrefixedSessionKeySchemas.KeyFirstSessionKeySchema",
    "source_method": "wrapPrefix",
    "target_class": "boolean):org.apache.kafka.common.utils.Bytes \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.TimestampedWindowStoreBuilder",
    "source_method": "maybeWrapCaching",
    "target_class": "org.apache.kafka.streams.state.WindowBytesStoreSupplier"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.TimestampedWindowStoreBuilder",
    "source_method": "maybeWrapLogging",
    "target_class": "org.apache.kafka.streams.state.WindowBytesStoreSupplier"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.TimestampedWindowStoreBuilder",
    "source_method": "retentionPeriod",
    "target_class": "org.apache.kafka.streams.state.WindowBytesStoreSupplier"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "handleBasicQueries",
    "target_class": "org.apache.kafka.streams.query.PositionBound, org.apache.kafka.streams.query.QueryConfig, org.apache.kafka.streams.processor.StateStore, org.apache.kafka.streams.query.Position, org.apache.kafka.streams.processor.StateStoreContext):org.apache.kafka.streams.query.QueryResult<R> \t org.apache.kafka.streams.query.Position"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "updatePosition",
    "target_class": "org.apache.kafka.streams.processor.StateStoreContext):void \t org.apache.kafka.streams.query.Position"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "isPermitted",
    "target_class": "org.apache.kafka.streams.query.PositionBound, int):boolean \t org.apache.kafka.streams.query.PositionBound"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "runRangeQuery",
    "target_class": "org.apache.kafka.streams.query.PositionBound, org.apache.kafka.streams.query.QueryConfig, org.apache.kafka.streams.processor.StateStore):org.apache.kafka.streams.query.QueryResult<R> \t org.apache.kafka.streams.query.RangeQuery"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "runKeyQuery",
    "target_class": "org.apache.kafka.streams.query.PositionBound, org.apache.kafka.streams.query.QueryConfig, org.apache.kafka.streams.processor.StateStore):org.apache.kafka.streams.query.QueryResult<R> \t org.apache.kafka.streams.query.KeyQuery"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "runWindowKeyQuery",
    "target_class": "org.apache.kafka.streams.query.PositionBound, org.apache.kafka.streams.query.QueryConfig, org.apache.kafka.streams.processor.StateStore):org.apache.kafka.streams.query.QueryResult<R> \t org.apache.kafka.streams.query.FailureReason"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "runWindowRangeQuery",
    "target_class": "org.apache.kafka.streams.query.PositionBound, org.apache.kafka.streams.query.QueryConfig, org.apache.kafka.streams.processor.StateStore):org.apache.kafka.streams.query.QueryResult<R> \t org.apache.kafka.streams.query.WindowRangeQuery"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "runMultiVersionedKeyQuery",
    "target_class": "org.apache.kafka.streams.query.PositionBound, org.apache.kafka.streams.query.QueryConfig, org.apache.kafka.streams.processor.StateStore):org.apache.kafka.streams.query.QueryResult<R> \t org.apache.kafka.streams.query.MultiVersionedKeyQuery"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "getDeserializeValue",
    "target_class": "org.apache.kafka.streams.processor.StateStore):java.util.function.Function<byte[],V> \t org.apache.kafka.streams.state.StateSerdes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "isAdapter",
    "target_class": "org.apache.kafka.streams.state.internals.WrappedStateStore"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "getDeserializeValue",
    "target_class": "org.apache.kafka.streams.state.StateSerdes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "deserializeVersionedRecord",
    "target_class": "org.apache.kafka.streams.state.VersionedRecord<byte[]>):org.apache.kafka.streams.state.VersionedRecord<V> \t org.apache.kafka.common.serialization.Deserializer"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "checkpointPosition",
    "target_class": "org.apache.kafka.streams.query.Position):void \t org.apache.kafka.streams.state.internals.OffsetCheckpoint"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "readPositionFromCheckpoint",
    "target_class": "org.apache.kafka.streams.state.internals.OffsetCheckpoint"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "positionToTopicPartitionMap",
    "target_class": "org.apache.kafka.streams.query.Position"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.StoreQueryUtils",
    "source_method": "topicPartitionMapToPosition",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.OffsetCheckpoint",
    "source_method": "writeEntry",
    "target_class": "org.apache.kafka.common.TopicPartition, long):void \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.TimeOrderedCachingWindowStore",
    "source_method": "initInternal",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.TimeOrderedCachingWindowStore",
    "source_method": "putAndMaybeForward",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalProcessorContext<?,?>):void \t org.apache.kafka.streams.state.internals.SegmentedCacheFunction"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.TimeOrderedCachingWindowStore",
    "source_method": "putAndMaybeForward",
    "target_class": "org.apache.kafka.streams.state.internals.ThreadCache.DirtyEntry, org.apache.kafka.common.utils.Bytes, long):void \t org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.TimeOrderedCachingWindowStore",
    "source_method": "indexKeyToBaseKey",
    "target_class": "org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.TimeOrderedCachingWindowStore",
    "source_method": "fetchInternal",
    "target_class": "org.apache.kafka.common.utils.Bytes, long, long, boolean):org.apache.kafka.streams.state.WindowStoreIterator<byte[]> \t org.apache.kafka.streams.state.internals.SegmentedBytesStore.KeySchema"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.TimeOrderedCachingWindowStore",
    "source_method": "fetchKeyRange",
    "target_class": "org.apache.kafka.common.utils.Bytes, org.apache.kafka.common.utils.Bytes, long, long, boolean):org.apache.kafka.streams.state.KeyValueIterator<org.apache.kafka.streams.kstream.Windowed<org.apache.kafka.common.utils.Bytes>,byte[]> \t org.apache.kafka.streams.state.internals.SegmentedBytesStore.KeySchema"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.TimeOrderedCachingWindowStore",
    "source_method": "fetchAllInternal",
    "target_class": "long, long, boolean):org.apache.kafka.streams.state.KeyValueIterator<org.apache.kafka.streams.kstream.Windowed<org.apache.kafka.common.utils.Bytes>,byte[]> \t org.apache.kafka.streams.state.internals.PrefixedWindowKeySchemas.TimeFirstWindowKeySchema"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.ChangeLoggingKeyValueBytesStore",
    "source_method": "log",
    "target_class": "byte[], long):void \t org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.LRUCacheEntry",
    "source_method": "context",
    "target_class": "org.apache.kafka.streams.state.internals.ContextualRecord"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.LogicalKeyValueSegment.PrefixKeyFormatter",
    "source_method": "addPrefix",
    "target_class": "org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.LogicalKeyValueSegment.PrefixKeyFormatter",
    "source_method": "startsWithPrefix",
    "target_class": "org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.LogicalKeyValueSegment.StrippedPrefixKeyValueIteratorAdapter",
    "source_method": "pruneNonPrefixedElements",
    "target_class": "org.apache.kafka.streams.state.KeyValueIterator"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.ThreadCache",
    "source_method": "delete",
    "target_class": "org.apache.kafka.common.utils.Bytes):org.apache.kafka.streams.state.internals.LRUCacheEntry \t org.apache.kafka.streams.state.internals.NamedCache"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.ThreadCache.MemoryLRUCacheBytesIterator",
    "source_method": "internalNext",
    "target_class": "org.apache.kafka.streams.state.internals.NamedCache"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.BufferValue",
    "source_method": "deserialize",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.BufferValue",
    "source_method": "residentMemorySizeEstimate",
    "target_class": "org.apache.kafka.streams.processor.internals.ProcessorRecordContext"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.NamedCache",
    "source_method": "getInternal",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.NamedCache",
    "source_method": "computeSubSet",
    "target_class": "org.apache.kafka.common.utils.Bytes, boolean):java.util.Set<org.apache.kafka.common.utils.Bytes> \t org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.NamedCache.LRUNode",
    "source_method": "size",
    "target_class": "org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "putSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "putIfAbsentSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "putAllSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "getSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "fetchSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "allSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "rangeSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "prefixScanSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "flushSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "deleteSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "removeSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "restoreSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "suppressionBufferCountSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "suppressionBufferSizeSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "e2ELatencySensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "iteratorDurationSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "addNumOpenIteratorsGauge",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl, org.apache.kafka.common.metrics.Gauge<java.lang.Long>):void \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "addOldestOpenIteratorGauge",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl, org.apache.kafka.common.metrics.Gauge<java.lang.Long>):void \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "sizeOrCountSensor",
    "target_class": "java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, org.apache.kafka.common.metrics.Sensor.RecordingLevel, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.StateStoreMetrics",
    "source_method": "throughputAndLatencySensor",
    "target_class": "java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, org.apache.kafka.common.metrics.Sensor.RecordingLevel, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetricsRecordingTrigger",
    "source_method": "metricsRecorderName",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetricsRecorder"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.NamedCacheMetrics",
    "source_method": "hitRatioSensor",
    "target_class": "java.lang.String, java.lang.String, java.lang.String):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetricsRecorder",
    "source_method": "init",
    "target_class": "org.apache.kafka.streams.processor.TaskId):void \t org.apache.kafka.streams.processor.TaskId"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "bytesWrittenToDatabaseSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "bytesReadFromDatabaseSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "memtableBytesFlushedSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "memtableHitRatioSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "memtableAvgFlushTimeSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "memtableMinFlushTimeSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "memtableMaxFlushTimeSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "writeStallDurationSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "blockCacheDataHitRatioSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "blockCacheIndexHitRatioSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "blockCacheFilterHitRatioSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "bytesReadDuringCompactionSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "bytesWrittenDuringCompactionSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "compactionTimeAvgSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "compactionTimeMinSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "compactionTimeMaxSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "numberOfOpenFilesSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "numberOfFileErrorsSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "addMutableMetric",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext, org.apache.kafka.common.metrics.Gauge<java.math.BigInteger>, java.lang.String, java.lang.String):void \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics",
    "source_method": "createSensor",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetrics.RocksDBMetricContext, java.lang.String):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.RocksDBTimeOrderedSessionSegmentedBytesStore",
    "source_method": "fetchSessions",
    "target_class": "long):org.apache.kafka.streams.state.KeyValueIterator<org.apache.kafka.common.utils.Bytes,byte[]> \t org.apache.kafka.streams.kstream.Windowed"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.VersionedKeyValueStoreBuilder",
    "source_method": "historyRetention",
    "target_class": "org.apache.kafka.streams.state.VersionedBytesStoreSupplier"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.RocksDBVersionedStore",
    "source_method": "maybePutToLatestValueStore",
    "target_class": "long, org.apache.kafka.common.utils.Bytes, byte[], long):org.apache.kafka.streams.state.internals.RocksDBVersionedStore.PutStatus \t org.apache.kafka.streams.state.internals.RocksDBVersionedStore.VersionedStoreClient"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.RocksDBVersionedStore",
    "source_method": "maybePutToSegments",
    "target_class": "long, org.apache.kafka.common.utils.Bytes, byte[], long, long):org.apache.kafka.streams.state.internals.RocksDBVersionedStore.PutStatus \t org.apache.kafka.streams.state.internals.RocksDBVersionedStore.VersionedStoreClient"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.RocksDBVersionedStore",
    "source_method": "putToSegment",
    "target_class": "long, T, byte[], org.apache.kafka.common.utils.Bytes, byte[], long):long \t org.apache.kafka.streams.state.internals.RocksDBVersionedStore.VersionedStoreClient"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.RocksDBVersionedStore",
    "source_method": "finishPut",
    "target_class": "long, org.apache.kafka.common.utils.Bytes, byte[], long, long):long \t org.apache.kafka.streams.state.internals.RocksDBVersionedStore.VersionedStoreClient"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.WindowStoreBuilder",
    "source_method": "maybeWrapCaching",
    "target_class": "org.apache.kafka.streams.state.WindowBytesStoreSupplier"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.WindowStoreBuilder",
    "source_method": "maybeWrapLogging",
    "target_class": "org.apache.kafka.streams.state.WindowBytesStoreSupplier"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.WindowStoreBuilder",
    "source_method": "retentionPeriod",
    "target_class": "org.apache.kafka.streams.state.WindowBytesStoreSupplier"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.RocksDBStore",
    "source_method": "addValueProvidersToMetricsRecorder",
    "target_class": "org.apache.kafka.streams.state.internals.metrics.RocksDBMetricsRecorder"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.RocksDBStore",
    "source_method": "doPrefixScan",
    "target_class": "PS, java.util.Set<org.apache.kafka.streams.state.KeyValueIterator<org.apache.kafka.common.utils.Bytes,byte[]>>):org.apache.kafka.streams.state.KeyValueIterator<org.apache.kafka.common.utils.Bytes,byte[]> \t org.apache.kafka.streams.state.internals.RocksDBStore.ColumnFamilyAccessor"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.RocksDBStore",
    "source_method": "all",
    "target_class": "java.util.Set<org.apache.kafka.streams.state.KeyValueIterator<org.apache.kafka.common.utils.Bytes,byte[]>>):org.apache.kafka.streams.state.KeyValueIterator<org.apache.kafka.common.utils.Bytes,byte[]> \t org.apache.kafka.streams.state.internals.RocksDBStore.ColumnFamilyAccessor"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.RocksDBStore",
    "source_method": "restoreBatch",
    "target_class": "org.apache.kafka.streams.state.internals.RocksDBStore.ColumnFamilyAccessor"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.RocksDBStore",
    "source_method": "incrementWithoutOverflow",
    "target_class": "org.apache.kafka.common.utils.Bytes"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.AbstractMergedSortedCacheStoreIterator",
    "source_method": "isDeletedCacheEntry",
    "target_class": "org.apache.kafka.streams.KeyValue"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.ContextualRecord",
    "source_method": "residentMemorySizeEstimate",
    "target_class": "org.apache.kafka.streams.processor.internals.ProcessorRecordContext"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.ContextualRecord",
    "source_method": "deserialize",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.ListValueStore",
    "source_method": "putInternal",
    "target_class": "byte[], byte[]):void \t org.apache.kafka.common.serialization.Serde"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.InMemoryTimeOrderedKeyValueChangeBuffer",
    "source_method": "init",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.InMemoryTimeOrderedKeyValueChangeBuffer",
    "source_method": "logValue",
    "target_class": "org.apache.kafka.streams.state.internals.BufferKey, org.apache.kafka.streams.state.internals.BufferValue):void \t org.apache.kafka.streams.state.internals.BufferValue"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.InMemoryTimeOrderedKeyValueChangeBuffer",
    "source_method": "restoreBatch",
    "target_class": "org.apache.kafka.streams.state.internals.TimeOrderedKeyValueBufferChangelogDeserializationHelper.DeserializationResult"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.InMemoryTimeOrderedKeyValueChangeBuffer",
    "source_method": "internalPriorValueForBuffered",
    "target_class": "org.apache.kafka.streams.state.internals.BufferValue"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.InMemoryTimeOrderedKeyValueChangeBuffer",
    "source_method": "computeRecordSize",
    "target_class": "org.apache.kafka.streams.state.internals.BufferValue):long \t org.apache.kafka.streams.state.internals.BufferValue"
  },
  {
    "source_class": "org.apache.kafka.streams.state.internals.InMemoryTimeOrderedKeyValueChangeBuffer",
    "source_method": "updateBufferMetrics",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.state.HostInfo",
    "source_method": "buildFromEndpoint",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.streams.state.Stores",
    "source_method": "persistentVersionedKeyValueStore",
    "target_class": "java.time.Duration):org.apache.kafka.streams.state.VersionedBytesStoreSupplier \t org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.state.Stores",
    "source_method": "persistentVersionedKeyValueStore",
    "target_class": "java.time.Duration, java.time.Duration):org.apache.kafka.streams.state.VersionedBytesStoreSupplier \t org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.state.Stores",
    "source_method": "persistentWindowStore",
    "target_class": "java.time.Duration, java.time.Duration, boolean, boolean):org.apache.kafka.streams.state.WindowBytesStoreSupplier \t org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.state.Stores",
    "source_method": "inMemoryWindowStore",
    "target_class": "java.time.Duration, java.time.Duration, boolean):org.apache.kafka.streams.state.WindowBytesStoreSupplier \t org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.state.Stores",
    "source_method": "persistentSessionStore",
    "target_class": "java.time.Duration):org.apache.kafka.streams.state.SessionBytesStoreSupplier \t org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.state.Stores",
    "source_method": "inMemorySessionStore",
    "target_class": "java.time.Duration):org.apache.kafka.streams.state.SessionBytesStoreSupplier \t org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.state.Stores",
    "source_method": "keyValueStoreBuilder",
    "target_class": "org.apache.kafka.common.serialization.Serde<K>, org.apache.kafka.common.serialization.Serde<V>):org.apache.kafka.streams.state.StoreBuilder<org.apache.kafka.streams.state.KeyValueStore<K,V>> \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.state.Stores",
    "source_method": "timestampedKeyValueStoreBuilder",
    "target_class": "org.apache.kafka.common.serialization.Serde<K>, org.apache.kafka.common.serialization.Serde<V>):org.apache.kafka.streams.state.StoreBuilder<org.apache.kafka.streams.state.TimestampedKeyValueStore<K,V>> \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.state.Stores",
    "source_method": "versionedKeyValueStoreBuilder",
    "target_class": "org.apache.kafka.common.serialization.Serde<K>, org.apache.kafka.common.serialization.Serde<V>):org.apache.kafka.streams.state.StoreBuilder<org.apache.kafka.streams.state.VersionedKeyValueStore<K,V>> \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.state.Stores",
    "source_method": "windowStoreBuilder",
    "target_class": "org.apache.kafka.common.serialization.Serde<K>, org.apache.kafka.common.serialization.Serde<V>):org.apache.kafka.streams.state.StoreBuilder<org.apache.kafka.streams.state.WindowStore<K,V>> \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.state.Stores",
    "source_method": "timestampedWindowStoreBuilder",
    "target_class": "org.apache.kafka.common.serialization.Serde<K>, org.apache.kafka.common.serialization.Serde<V>):org.apache.kafka.streams.state.StoreBuilder<org.apache.kafka.streams.state.TimestampedWindowStore<K,V>> \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.state.Stores",
    "source_method": "sessionStoreBuilder",
    "target_class": "org.apache.kafka.common.serialization.Serde<K>, org.apache.kafka.common.serialization.Serde<V>):org.apache.kafka.streams.state.StoreBuilder<org.apache.kafka.streams.state.SessionStore<K,V>> \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.state.StateSerdes",
    "source_method": "withBuiltinTypes",
    "target_class": "java.lang.Class<K>, java.lang.Class<V>):org.apache.kafka.streams.state.StateSerdes<K,V> \t org.apache.kafka.common.serialization.Serdes"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorContextUtils",
    "source_method": "getMetricsImpl",
    "target_class": "org.apache.kafka.streams.processor.ProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorContextUtils",
    "source_method": "getMetricsImpl",
    "target_class": "org.apache.kafka.streams.processor.StateStoreContext"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorContextUtils",
    "source_method": "changelogFor",
    "target_class": "java.lang.String, java.lang.Boolean):java.lang.String \t org.apache.kafka.streams.processor.ProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorContextUtils",
    "source_method": "changelogFor",
    "target_class": "java.lang.String, java.lang.Boolean):java.lang.String \t org.apache.kafka.streams.processor.StateStoreContext"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorContextUtils",
    "source_method": "getPrefix",
    "target_class": "java.lang.String):java.lang.String \t org.apache.kafka.streams.StreamsConfig.InternalConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "addSource",
    "target_class": "java.lang.String, org.apache.kafka.streams.processor.TimestampExtractor, org.apache.kafka.common.serialization.Deserializer<?>, org.apache.kafka.common.serialization.Deserializer<?>, java.lang.String[]):void \t org.apache.kafka.streams.processor.internals.QuickUnion"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "addSource",
    "target_class": "java.lang.String, org.apache.kafka.streams.processor.TimestampExtractor, org.apache.kafka.common.serialization.Deserializer<?>, org.apache.kafka.common.serialization.Deserializer<?>, java.util.regex.Pattern):void \t org.apache.kafka.streams.processor.internals.QuickUnion"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "addSink",
    "target_class": "org.apache.kafka.streams.processor.TopicNameExtractor<K,V>, org.apache.kafka.common.serialization.Serializer<K>, org.apache.kafka.common.serialization.Serializer<V>, org.apache.kafka.streams.processor.StreamPartitioner<? super K,? super V>, java.lang.String[]):void \t org.apache.kafka.streams.processor.internals.QuickUnion"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "addProcessor",
    "target_class": "org.apache.kafka.streams.processor.api.ProcessorSupplier<KIn,VIn,KOut,VOut>, java.lang.String[]):void \t org.apache.kafka.streams.processor.internals.QuickUnion"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "addProcessor",
    "target_class": "org.apache.kafka.streams.processor.api.FixedKeyProcessorSupplier<KIn,VIn,VOut>, java.lang.String[]):void \t org.apache.kafka.streams.processor.internals.QuickUnion"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "addStateStore",
    "target_class": "boolean, java.lang.String[]):void \t org.apache.kafka.streams.processor.internals.StoreFactory"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "addGlobalStore",
    "target_class": "java.lang.String, org.apache.kafka.streams.processor.TimestampExtractor, org.apache.kafka.common.serialization.Deserializer<KIn>, org.apache.kafka.common.serialization.Deserializer<VIn>, java.lang.String, java.lang.String, org.apache.kafka.streams.processor.api.ProcessorSupplier<KIn,VIn,java.lang.Void,java.lang.Void>, boolean):void \t org.apache.kafka.streams.processor.internals.InternalTopologyBuilder.ProcessorNodeFactory"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "validateCopartition",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopicProperties"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "connectProcessorAndStateStore",
    "target_class": "java.lang.String):void \t org.apache.kafka.streams.processor.internals.InternalTopologyBuilder.ProcessorNodeFactory"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "putNodeGroupName",
    "target_class": "int, java.util.Map<java.lang.Integer,java.util.Set<java.lang.String>>, java.util.Map<java.lang.String,java.util.Set<java.lang.String>>):int \t org.apache.kafka.streams.processor.internals.QuickUnion"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "buildSinkNode",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.streams.processor.internals.SinkNode<?,?>>, java.util.Set<java.lang.String>, org.apache.kafka.streams.processor.internals.InternalTopologyBuilder.SinkNodeFactory<?,?>, org.apache.kafka.streams.processor.internals.SinkNode<?,?>):void \t org.apache.kafka.streams.processor.internals.InternalTopologyBuilder.SinkNodeFactory"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "buildSourceNode",
    "target_class": "java.util.Set<java.lang.String>, org.apache.kafka.streams.processor.internals.InternalTopologyBuilder.SourceNodeFactory<?,?>, org.apache.kafka.streams.processor.internals.SourceNode<?,?>):void \t org.apache.kafka.streams.processor.internals.InternalTopologyBuilder.SourceNodeFactory"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "buildProcessorNode",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.streams.processor.StateStore>, org.apache.kafka.streams.processor.internals.InternalTopologyBuilder.ProcessorNodeFactory<?,?,?,?>, org.apache.kafka.streams.processor.internals.ProcessorNode<java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object>):void \t org.apache.kafka.streams.processor.internals.StoreFactory"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "createChangelogTopicConfig",
    "target_class": "java.lang.String):org.apache.kafka.streams.processor.internals.InternalTopicConfig \t org.apache.kafka.streams.processor.internals.StoreFactory"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "decorateTopic",
    "target_class": "org.apache.kafka.streams.TopologyConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "describeGlobalStore",
    "target_class": "java.util.Set<java.lang.String>, int):void \t org.apache.kafka.streams.processor.internals.InternalTopologyBuilder.TopologyDescription"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "updateSize",
    "target_class": "int):void \t org.apache.kafka.streams.processor.internals.InternalTopologyBuilder.AbstractNode"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder",
    "source_method": "describeSubtopology",
    "target_class": "java.lang.Integer, java.util.Set<java.lang.String>):void \t org.apache.kafka.streams.processor.internals.InternalTopologyBuilder.TopologyDescription"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsProducer",
    "source_method": "resetProducer",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsProducer",
    "source_method": "totalBlockedTime",
    "target_class": "org.apache.kafka.clients.producer.Producer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsProducer",
    "source_method": "maybeBeginTransaction",
    "target_class": "org.apache.kafka.clients.producer.Producer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsProducer",
    "source_method": "commitTransaction",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerGroupMetadata):void \t org.apache.kafka.clients.producer.Producer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.RecordCollectorImpl",
    "source_method": "removeAllProducedSensors",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.RecordCollectorImpl",
    "source_method": "producer",
    "target_class": "org.apache.kafka.streams.processor.internals.StreamsProducer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ClientUtils",
    "source_method": "consumerMetrics",
    "target_class": "org.apache.kafka.clients.consumer.Consumer<byte[],byte[]>):java.util.Map<org.apache.kafka.common.MetricName,org.apache.kafka.common.Metric> \t org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ClientUtils",
    "source_method": "adminClientMetrics",
    "target_class": "org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ClientUtils",
    "source_method": "producerMetrics",
    "target_class": "org.apache.kafka.streams.processor.internals.StreamsProducer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ClientUtils",
    "source_method": "fetchCommittedOffsets",
    "target_class": "org.apache.kafka.clients.consumer.Consumer<byte[],byte[]>):java.util.Map<org.apache.kafka.common.TopicPartition,java.lang.Long> \t org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ClientUtils",
    "source_method": "fetchEndOffsetsFuture",
    "target_class": "org.apache.kafka.clients.admin.Admin):org.apache.kafka.common.KafkaFuture<java.util.Map<org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.admin.ListOffsetsResult.ListOffsetsResultInfo>> \t org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ClientUtils",
    "source_method": "fetchEndOffsetsResult",
    "target_class": "org.apache.kafka.clients.admin.Admin):org.apache.kafka.clients.admin.ListOffsetsResult \t org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ClientUtils",
    "source_method": "getEndOffsets",
    "target_class": "java.util.Collection<org.apache.kafka.common.TopicPartition>):java.util.Map<org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.admin.ListOffsetsResult.ListOffsetsResultInfo> \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ClientUtils",
    "source_method": "getEndOffsets",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ClientUtils",
    "source_method": "producerRecordSizeInBytes",
    "target_class": "org.apache.kafka.clients.producer.ProducerRecord"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ClientUtils",
    "source_method": "consumerRecordSizeInBytes",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerRecord"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ClientUtils",
    "source_method": "recordSizeInBytes",
    "target_class": "long, java.lang.String, org.apache.kafka.common.header.Headers):long \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ActiveTaskCreator",
    "source_method": "reInitializeThreadProducer",
    "target_class": "org.apache.kafka.streams.processor.internals.StreamsProducer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ActiveTaskCreator",
    "source_method": "createTasks",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.TaskId,java.util.Set<org.apache.kafka.common.TopicPartition>>):java.util.Collection<org.apache.kafka.streams.processor.internals.Task> \t org.apache.kafka.streams.processor.internals.ProcessorTopology"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ActiveTaskCreator",
    "source_method": "closeThreadProducerIfNeeded",
    "target_class": "org.apache.kafka.streams.processor.internals.StreamsProducer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ActiveTaskCreator",
    "source_method": "closeAndRemoveTaskProducerIfNeeded",
    "target_class": "org.apache.kafka.streams.processor.internals.StreamsProducer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ActiveTaskCreator",
    "source_method": "totalProducerBlockedTime",
    "target_class": "org.apache.kafka.streams.processor.internals.StreamsProducer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TopicPartitionMetadata",
    "source_method": "encode",
    "target_class": "org.apache.kafka.streams.processor.internals.ProcessorMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TopicPartitionMetadata",
    "source_method": "decode",
    "target_class": "org.apache.kafka.streams.processor.internals.ProcessorMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopicManager",
    "source_method": "validatePartitionCount",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopicConfig, org.apache.kafka.clients.admin.TopicDescription):void \t org.apache.kafka.streams.processor.internals.InternalTopicConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopicManager",
    "source_method": "validateCleanupPolicy",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopicConfig, org.apache.kafka.clients.admin.Config):void \t org.apache.kafka.streams.processor.internals.InternalTopicConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopicManager",
    "source_method": "validateCleanupPolicyForUnwindowedUnversionedChangelogs",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopicConfig, org.apache.kafka.clients.admin.Config):void \t org.apache.kafka.streams.processor.internals.InternalTopicConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopicManager",
    "source_method": "validateCleanupPolicyForWindowedChangelogs",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopicConfig, org.apache.kafka.clients.admin.Config):void \t org.apache.kafka.streams.processor.internals.InternalTopicConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopicManager",
    "source_method": "validateCleanupPolicyForVersionedChangelogs",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopicConfig, org.apache.kafka.clients.admin.Config):void \t org.apache.kafka.streams.processor.internals.InternalTopicConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopicManager",
    "source_method": "validateCleanupPolicyForRepartitionTopic",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopicConfig, org.apache.kafka.clients.admin.Config):void \t org.apache.kafka.streams.processor.internals.InternalTopicConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalTopicManager",
    "source_method": "getBrokerSideConfigValue",
    "target_class": "java.lang.String, java.lang.String):java.lang.String \t org.apache.kafka.clients.admin.Config"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.Tasks",
    "source_method": "removePartitionsForActiveTask",
    "target_class": "org.apache.kafka.streams.processor.TaskId"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.InternalProcessorContext",
    "source_method": "getStateStore",
    "target_class": "org.apache.kafka.streams.state.StoreBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamTask",
    "source_method": "flush",
    "target_class": "org.apache.kafka.streams.processor.internals.RecordCollector"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamTask",
    "source_method": "findOffset",
    "target_class": "org.apache.kafka.streams.processor.internals.AbstractPartitionGroup"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamTask",
    "source_method": "clearCommitStatuses",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamTask",
    "source_method": "extractPartitionTimes",
    "target_class": "org.apache.kafka.streams.processor.internals.AbstractPartitionGroup"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamTask",
    "source_method": "removeAllSensors",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamTask",
    "source_method": "updateProcessorContext",
    "target_class": "long, org.apache.kafka.streams.processor.internals.ProcessorRecordContext):void \t org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamTask",
    "source_method": "schedule",
    "target_class": "org.apache.kafka.streams.processor.PunctuationType, org.apache.kafka.streams.processor.Punctuator):org.apache.kafka.streams.processor.Cancellable \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamTask",
    "source_method": "schedule",
    "target_class": "long, org.apache.kafka.streams.processor.PunctuationType, org.apache.kafka.streams.processor.Punctuator):org.apache.kafka.streams.processor.Cancellable \t org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamTask",
    "source_method": "canPunctuateStreamTime",
    "target_class": "org.apache.kafka.streams.processor.internals.AbstractPartitionGroup"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamTask",
    "source_method": "canPunctuateSystemTime",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamTask",
    "source_method": "maybeRecordE2ELatency",
    "target_class": "long, java.lang.String):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsMetadataState",
    "source_method": "rebuildMetadataForNamedTopologies",
    "target_class": "java.util.Map<org.apache.kafka.streams.state.HostInfo,java.util.Set<org.apache.kafka.common.TopicPartition>>):java.util.List<org.apache.kafka.streams.StreamsMetadata> \t org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsMetadataState",
    "source_method": "rebuildMetadataForSingleTopology",
    "target_class": "java.util.Map<org.apache.kafka.streams.state.HostInfo,java.util.Set<org.apache.kafka.common.TopicPartition>>):java.util.List<org.apache.kafka.streams.StreamsMetadata> \t org.apache.kafka.streams.state.HostInfo"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsMetadataState",
    "source_method": "getKeyQueryMetadataForKey",
    "target_class": "K, org.apache.kafka.streams.processor.StreamPartitioner<? super K,?>, org.apache.kafka.streams.processor.internals.StreamsMetadataState.SourceTopicsInfo):org.apache.kafka.streams.KeyQueryMetadata \t org.apache.kafka.streams.processor.StreamPartitioner"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsMetadataState",
    "source_method": "getKeyQueryMetadataForKey",
    "target_class": "K, org.apache.kafka.streams.processor.StreamPartitioner<? super K,?>, org.apache.kafka.streams.processor.internals.StreamsMetadataState.SourceTopicsInfo, java.lang.String):org.apache.kafka.streams.KeyQueryMetadata \t org.apache.kafka.streams.processor.StreamPartitioner"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsMetadataState",
    "source_method": "getSourceTopicsInfo",
    "target_class": "java.lang.String):org.apache.kafka.streams.processor.internals.StreamsMetadataState.SourceTopicsInfo \t org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.RecordQueue",
    "source_method": "poll",
    "target_class": "org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.RecordQueue",
    "source_method": "headRecordOffset",
    "target_class": "org.apache.kafka.streams.processor.internals.StampedRecord"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamThread",
    "source_method": "create",
    "target_class": "org.apache.kafka.streams.StreamsConfig, org.apache.kafka.streams.KafkaClientSupplier, org.apache.kafka.clients.admin.Admin, java.util.UUID, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl, org.apache.kafka.common.utils.Time, org.apache.kafka.streams.processor.internals.StreamsMetadataState, long, org.apache.kafka.streams.processor.internals.StateDirectory, org.apache.kafka.streams.processor.StateRestoreListener, org.apache.kafka.streams.processor.StandbyUpdateListener, int, java.lang.Runnable, java.util.function.BiConsumer<java.lang.Throwable,java.lang.Boolean>):org.apache.kafka.streams.processor.internals.StreamThread \t org.apache.kafka.streams.processor.internals.ClientUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamThread",
    "source_method": "maybeCreateSchedulingTaskManager",
    "target_class": "boolean, org.apache.kafka.streams.processor.internals.TopologyMetadata, org.apache.kafka.common.utils.Time, java.lang.String, org.apache.kafka.streams.processor.internals.Tasks):org.apache.kafka.streams.processor.internals.tasks.DefaultTaskManager \t org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamThread",
    "source_method": "maybeCreateAndStartStateUpdater",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl, org.apache.kafka.streams.StreamsConfig, org.apache.kafka.clients.consumer.Consumer<byte[],byte[]>, org.apache.kafka.streams.processor.internals.ChangelogReader, org.apache.kafka.streams.processor.internals.TopologyMetadata, org.apache.kafka.common.utils.Time, java.lang.String, int):org.apache.kafka.streams.processor.internals.StateUpdater \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamThread",
    "source_method": "maybeGetClientInstanceIds",
    "target_class": "org.apache.kafka.streams.processor.internals.TaskManager"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamThread",
    "source_method": "maybeResetFetchDeadline",
    "target_class": "org.apache.kafka.common.internals.KafkaFutureImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamThread",
    "source_method": "sendShutdownRequest",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.AssignorError"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamThread",
    "source_method": "subscribeConsumer",
    "target_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamThread",
    "source_method": "checkStateUpdater",
    "target_class": "org.apache.kafka.streams.processor.internals.TaskManager"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamThread",
    "source_method": "pollRequests",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamThread",
    "source_method": "resetOffsets",
    "target_class": "java.lang.Exception):void \t org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamThread",
    "source_method": "advanceNowAndComputeLatency",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamThread",
    "source_method": "readyOnlyAllTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.TaskManager"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.tasks.DefaultTaskManager",
    "source_method": "canProgress",
    "target_class": "long):boolean \t org.apache.kafka.streams.processor.internals.StreamTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StateManagerUtil",
    "source_method": "converterForStore",
    "target_class": "org.apache.kafka.streams.state.internals.WrappedStateStore"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StateManagerUtil",
    "source_method": "registerStateStores",
    "target_class": "java.lang.String, org.apache.kafka.streams.processor.internals.ProcessorTopology, org.apache.kafka.streams.processor.internals.ProcessorStateManager, org.apache.kafka.streams.processor.internals.StateDirectory, org.apache.kafka.streams.processor.internals.InternalProcessorContext):void \t org.apache.kafka.streams.processor.internals.ProcessorTopology"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StateManagerUtil",
    "source_method": "closeStateManager",
    "target_class": "java.lang.String, boolean, boolean, org.apache.kafka.streams.processor.internals.ProcessorStateManager, org.apache.kafka.streams.processor.internals.StateDirectory, org.apache.kafka.streams.processor.internals.Task.TaskType):void \t org.apache.kafka.streams.processor.internals.ProcessorStateManager"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StateManagerUtil",
    "source_method": "toTaskDirString",
    "target_class": "org.apache.kafka.streams.processor.TaskId"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.SerdeGetter",
    "source_method": "keySerde",
    "target_class": "org.apache.kafka.streams.processor.ProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.SerdeGetter",
    "source_method": "valueSerde",
    "target_class": "org.apache.kafka.streams.processor.ProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.AbstractPartitionGroup.RecordInfo",
    "source_method": "node",
    "target_class": "org.apache.kafka.streams.processor.internals.RecordQueue"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamThreadTotalBlockedTime",
    "source_method": "metricValue",
    "target_class": "extends org.apache.kafka.common.Metric>, java.lang.String):double \t org.apache.kafka.common.MetricName"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamThreadTotalBlockedTime",
    "source_method": "compute",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorContextImpl",
    "source_method": "addAllFlushListenersToNewCache",
    "target_class": "org.apache.kafka.streams.state.internals.ThreadCache"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorContextImpl",
    "source_method": "forwardInternal",
    "target_class": "org.apache.kafka.streams.processor.api.Record<K,V>):void \t org.apache.kafka.streams.processor.internals.ProcessorNode"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorNode",
    "source_method": "close",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsPartitionAssignor.ClientMetadata",
    "source_method": "addConsumer",
    "target_class": "java.util.List<org.apache.kafka.common.TopicPartition>):void \t org.apache.kafka.streams.processor.internals.assignment.ClientState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsPartitionAssignor",
    "source_method": "populatePartitionsByHostMaps",
    "target_class": "java.util.Map<org.apache.kafka.streams.state.HostInfo,java.util.Set<org.apache.kafka.common.TopicPartition>>, java.util.Map<org.apache.kafka.streams.processor.TaskId,java.util.Set<org.apache.kafka.common.TopicPartition>>, java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.internals.StreamsPartitionAssignor.ClientMetadata>):void \t org.apache.kafka.streams.processor.internals.assignment.ClientState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsPartitionAssignor",
    "source_method": "assignTasksToThreads",
    "target_class": "boolean, java.util.SortedSet<java.lang.String>, org.apache.kafka.streams.processor.internals.assignment.ClientState, java.util.Map<java.lang.String,java.lang.Integer>):java.util.Map<java.lang.String,java.util.List<org.apache.kafka.streams.processor.TaskId>> \t org.apache.kafka.streams.processor.internals.assignment.ClientState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsPartitionAssignor",
    "source_method": "verifyHostInfo",
    "target_class": "org.apache.kafka.streams.state.HostInfo"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsPartitionAssignor",
    "source_method": "getActiveTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo):java.util.Map<org.apache.kafka.streams.processor.TaskId,java.util.Set<org.apache.kafka.common.TopicPartition>> \t org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsPartitionAssignor",
    "source_method": "getTopicPartitionInfo",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StreamsPartitionAssignor",
    "source_method": "validateActiveTaskEncoding",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo, java.lang.String):void \t org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorStateManager",
    "source_method": "maybeRegisterStoreWithChangelogReader",
    "target_class": "org.apache.kafka.streams.processor.internals.ChangelogRegister"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorStateManager",
    "source_method": "storeMetadata",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorStateManager",
    "source_method": "restore",
    "target_class": "java.util.List<org.apache.kafka.clients.consumer.ConsumerRecord<byte[],byte[]>>, java.util.OptionalLong):void \t org.apache.kafka.streams.processor.internals.RecordBatchingStateRestoreCallback"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorStateManager",
    "source_method": "transitionTaskType",
    "target_class": "org.apache.kafka.common.utils.LogContext):void \t org.apache.kafka.common.utils.LogContext"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorStateManager",
    "source_method": "getStorePartition",
    "target_class": "org.apache.kafka.streams.processor.TaskId"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorStateManager",
    "source_method": "findStore",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorStateManager",
    "source_method": "registeredChangelogPartitionFor",
    "target_class": "org.apache.kafka.streams.processor.internals.ProcessorStateManager.StateStoreMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorStateManager",
    "source_method": "deleteCheckPointFileIfEOSEnabled",
    "target_class": "org.apache.kafka.streams.state.internals.OffsetCheckpoint"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.GlobalStateUpdateTask",
    "source_method": "initTopology",
    "target_class": "org.apache.kafka.streams.processor.internals.ProcessorTopology"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.RepartitionTopics",
    "source_method": "topologiesWithMissingInputTopics",
    "target_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.RepartitionTopics",
    "source_method": "ensureCopartitioning",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.streams.processor.internals.InternalTopicConfig>, org.apache.kafka.common.Cluster):void \t org.apache.kafka.streams.processor.internals.assignment.CopartitionedTopicsEnforcer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.RepartitionTopics",
    "source_method": "computeMissingExternalSourceTopics",
    "target_class": "org.apache.kafka.common.Cluster):java.util.Set<java.lang.String> \t org.apache.kafka.common.Cluster"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.RepartitionTopics",
    "source_method": "computePartitionCount",
    "target_class": "java.util.Collection<org.apache.kafka.streams.processor.internals.InternalTopologyBuilder.TopicsInfo>, org.apache.kafka.common.Cluster, java.lang.String):java.lang.Integer \t org.apache.kafka.common.Cluster"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.GlobalStateManagerImpl",
    "source_method": "topicPartitionsForStore",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.GlobalStateManagerImpl",
    "source_method": "reprocessState",
    "target_class": "java.util.Map<org.apache.kafka.common.TopicPartition,java.lang.Long>, org.apache.kafka.streams.processor.internals.InternalTopologyBuilder.ReprocessFactory, java.lang.String):void \t org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.GlobalStateManagerImpl",
    "source_method": "restoreState",
    "target_class": "java.util.List<org.apache.kafka.common.TopicPartition>, java.util.Map<org.apache.kafka.common.TopicPartition,java.lang.Long>, java.lang.String, org.apache.kafka.streams.state.internals.RecordConverter):void \t org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.GlobalStateManagerImpl",
    "source_method": "getGlobalConsumerOffset",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.GlobalStateManagerImpl",
    "source_method": "maybeUpdateDeadlineOrThrow",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.PunctuationQueue",
    "source_method": "schedule",
    "target_class": "org.apache.kafka.streams.processor.internals.PunctuationSchedule"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.PunctuationQueue",
    "source_method": "maybePunctuate",
    "target_class": "org.apache.kafka.streams.processor.PunctuationType, org.apache.kafka.streams.processor.internals.ProcessorNodePunctuator):boolean \t org.apache.kafka.streams.processor.internals.PunctuationSchedule"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.PunctuationQueue",
    "source_method": "canPunctuate",
    "target_class": "org.apache.kafka.streams.processor.internals.PunctuationSchedule"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskExecutor",
    "source_method": "process",
    "target_class": "org.apache.kafka.common.utils.Time):int \t org.apache.kafka.streams.processor.internals.TaskExecutionMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskExecutor",
    "source_method": "updateTaskCommitMetadata",
    "target_class": "org.apache.kafka.streams.processor.internals.TasksRegistry"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.AbstractTask",
    "source_method": "transitionTo",
    "target_class": "org.apache.kafka.streams.processor.internals.ProcessorStateManager"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.DefaultStateUpdater.StateUpdaterThread",
    "source_method": "getUpdatingStandbyTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.DefaultStateUpdater.StateUpdaterThread",
    "source_method": "getNumUpdatingStandbyTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.DefaultStateUpdater.StateUpdaterThread",
    "source_method": "getNumPausedStandbyTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.DefaultStateUpdater.StateUpdaterThread",
    "source_method": "restoreTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.ChangelogReader"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.DefaultStateUpdater.StateUpdaterThread",
    "source_method": "removeCheckpointForCorruptedTask",
    "target_class": "org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.DefaultStateUpdater.StateUpdaterThread",
    "source_method": "handleStreamsExceptionWithTask",
    "target_class": "org.apache.kafka.streams.errors.StreamsException"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.DefaultStateUpdater.StateUpdaterThread",
    "source_method": "clearUpdatingAndPausedTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.ChangelogReader"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.DefaultStateUpdater.StateUpdaterThread",
    "source_method": "prepareUpdatingTaskForRemoval",
    "target_class": "org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.DefaultStateUpdater.StateUpdaterThread",
    "source_method": "preparePausedTaskForRemoval",
    "target_class": "org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.DefaultStateUpdater.StateUpdaterThread",
    "source_method": "isStateless",
    "target_class": "org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.DefaultStateUpdater.StateUpdaterThread",
    "source_method": "transitToUpdateStandbysIfOnlyStandbysLeft",
    "target_class": "org.apache.kafka.streams.processor.internals.ChangelogReader"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.DefaultStateUpdater.StateUpdaterThread",
    "source_method": "recordMetrics",
    "target_class": "long, long):void \t org.apache.kafka.streams.processor.internals.ChangelogReader"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.DefaultStateUpdater",
    "source_method": "verifyStateFor",
    "target_class": "org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.DefaultStateUpdater",
    "source_method": "getStreamOfNonPausedTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.TaskAndAction"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "consumerGroupMetadata",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "consumerCommitSync",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "handleRebalanceStart",
    "target_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "handleRebalanceComplete",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "createNewTasks",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.TaskId,java.util.Set<org.apache.kafka.common.TopicPartition>>):void \t org.apache.kafka.streams.processor.internals.ActiveTaskCreator"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "updateInputPartitionsOfStandbyTaskIfTheyChanged",
    "target_class": "java.util.Set<org.apache.kafka.common.TopicPartition>):void \t org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "handleTasksPendingInitialization",
    "target_class": "org.apache.kafka.streams.processor.internals.TasksRegistry"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "handleReassignedActiveTask",
    "target_class": "java.util.Set<org.apache.kafka.common.TopicPartition>):void \t org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "handleTasksInStateUpdater",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.TaskId,java.util.Set<org.apache.kafka.common.TopicPartition>>, java.util.Map<org.apache.kafka.streams.processor.internals.Task,java.util.Set<org.apache.kafka.common.TopicPartition>>, java.util.Set<org.apache.kafka.streams.processor.internals.Task>, java.util.Set<org.apache.kafka.streams.processor.internals.Task>, java.util.Map<org.apache.kafka.streams.processor.TaskId,java.lang.RuntimeException>):void \t org.apache.kafka.streams.processor.internals.StateUpdater"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "updateInputPartitions",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.TaskId,java.util.Set<org.apache.kafka.common.TopicPartition>>, java.util.Map<org.apache.kafka.streams.processor.TaskId,java.lang.RuntimeException>):void \t org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "addToActiveTasksToRecycle",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.TaskId,java.util.Set<org.apache.kafka.common.TopicPartition>>, java.util.Map<org.apache.kafka.streams.processor.internals.Task,java.util.Set<org.apache.kafka.common.TopicPartition>>, java.util.Map<org.apache.kafka.streams.processor.TaskId,java.lang.RuntimeException>):void \t org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "addToStandbyTasksToRecycle",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.TaskId,java.util.Set<org.apache.kafka.common.TopicPartition>>, java.util.Map<org.apache.kafka.streams.processor.internals.Task,java.util.Set<org.apache.kafka.common.TopicPartition>>, java.util.Map<org.apache.kafka.streams.processor.TaskId,java.lang.RuntimeException>):void \t org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "addToTasksToClose",
    "target_class": "java.util.Set<org.apache.kafka.streams.processor.internals.Task>, java.util.Set<org.apache.kafka.streams.processor.internals.Task>):void \t org.apache.kafka.streams.processor.internals.StateUpdater.RemovedTaskResult"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "checkIfTaskFailed",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.TaskId,java.lang.RuntimeException>):org.apache.kafka.streams.processor.internals.Task \t org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "convertActiveToStandby",
    "target_class": "java.util.Set<org.apache.kafka.common.TopicPartition>):org.apache.kafka.streams.processor.internals.StandbyTask \t org.apache.kafka.streams.processor.internals.StandbyTaskCreator"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "convertStandbyToActive",
    "target_class": "java.util.Set<org.apache.kafka.common.TopicPartition>):org.apache.kafka.streams.processor.internals.StreamTask \t org.apache.kafka.streams.processor.internals.ActiveTaskCreator"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "checkStateUpdater",
    "target_class": "java.util.function.Consumer<java.util.Set<org.apache.kafka.common.TopicPartition>>):boolean \t org.apache.kafka.streams.processor.internals.StateUpdater"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "addTasksToStateUpdater",
    "target_class": "org.apache.kafka.streams.processor.internals.TasksRegistry"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "collectExceptionsAndFailedTasksFromStateUpdater",
    "target_class": "org.apache.kafka.streams.processor.internals.StateUpdater"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "handleRestoredTasksFromStateUpdater",
    "target_class": "java.util.function.Consumer<java.util.Set<org.apache.kafka.common.TopicPartition>>):void \t org.apache.kafka.streams.processor.internals.StateUpdater"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "revokeTasksInStateUpdater",
    "target_class": "org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "removeLostActiveTasksFromStateUpdater",
    "target_class": "org.apache.kafka.streams.processor.internals.StateUpdater"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "signalResume",
    "target_class": "org.apache.kafka.streams.processor.internals.tasks.DefaultTaskManager"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "releaseLockedDirectoriesForTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.StateDirectory"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "closeTaskClean",
    "target_class": "org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "shutdownStateUpdater",
    "target_class": "org.apache.kafka.streams.processor.internals.StateUpdater"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "shutdownSchedulingTaskManager",
    "target_class": "org.apache.kafka.streams.processor.internals.tasks.DefaultTaskManager"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "allTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.StateUpdater"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "allOwnedTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.TasksRegistry"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "readOnlyAllTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.StateUpdater"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "notPausedTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "activeTaskStream",
    "target_class": "org.apache.kafka.streams.processor.internals.StateUpdater"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "activeRunningTaskStream",
    "target_class": "org.apache.kafka.streams.processor.internals.TasksRegistry"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "standbyTaskStream",
    "target_class": "org.apache.kafka.streams.processor.internals.StateUpdater"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "resumePollingForPartitionsWithAvailableSpace",
    "target_class": "org.apache.kafka.streams.processor.internals.TasksRegistry"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "updateLags",
    "target_class": "org.apache.kafka.streams.processor.internals.TasksRegistry"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "maybeThrowTaskExceptionsFromProcessingThreads",
    "target_class": "org.apache.kafka.streams.processor.internals.tasks.DefaultTaskManager"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "commit",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "commitTasksAndMaybeUpdateCommittableOffsets",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.internals.Task,java.util.Map<org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.consumer.OffsetAndMetadata>>):int \t org.apache.kafka.streams.processor.internals.TaskExecutor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "updateTaskEndMetadata",
    "target_class": "java.lang.Long):void \t org.apache.kafka.streams.processor.internals.TasksRegistry"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "createPendingTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.TasksRegistry"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskManager",
    "source_method": "maybeWrapTaskException",
    "target_class": "org.apache.kafka.streams.processor.TaskId):org.apache.kafka.streams.errors.StreamsException \t org.apache.kafka.streams.errors.StreamsException"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.PunctuationSchedule",
    "source_method": "next",
    "target_class": "org.apache.kafka.streams.processor.internals.PunctuationSchedule.RepointableCancellable"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StandbyTask",
    "source_method": "toString",
    "target_class": "org.apache.kafka.streams.processor.internals.ProcessorTopology"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.namedtopology.AddNamedTopologyResult",
    "source_method": "exceptionNow",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.namedtopology.NamedTopology",
    "source_method": "name",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.namedtopology.KafkaStreamsNamedTopologyWrapper",
    "source_method": "getAllTopologies",
    "target_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.namedtopology.KafkaStreamsNamedTopologyWrapper",
    "source_method": "pauseNamedTopology",
    "target_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.namedtopology.KafkaStreamsNamedTopologyWrapper",
    "source_method": "isNamedTopologyPaused",
    "target_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.namedtopology.KafkaStreamsNamedTopologyWrapper",
    "source_method": "resumeNamedTopology",
    "target_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.namedtopology.KafkaStreamsNamedTopologyWrapper",
    "source_method": "getFullTopologyDescription",
    "target_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.namedtopology.KafkaStreamsNamedTopologyWrapper",
    "source_method": "verifyTopologyStateStore",
    "target_class": "java.lang.String):void \t org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorRecordContext",
    "source_method": "serialize",
    "target_class": "org.apache.kafka.common.header.Headers"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ProcessorRecordContext",
    "source_method": "deserialize",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskExecutionMetadata",
    "source_method": "canProcessTask",
    "target_class": "long):boolean \t org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskExecutionMetadata",
    "source_method": "canPunctuateTask",
    "target_class": "org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskExecutionMetadata",
    "source_method": "registerTaskError",
    "target_class": "java.lang.Throwable, long):void \t org.apache.kafka.streams.processor.internals.Task"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TaskAndAction",
    "source_method": "createAddTask",
    "target_class": "org.apache.kafka.streams.processor.internals.TaskAndAction.Action"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader.ChangelogMetadata",
    "source_method": "transitTo",
    "target_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader.ChangelogState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader",
    "source_method": "hasRestoredToEnd",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader",
    "source_method": "restoringChangelogByPartition",
    "target_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader.ChangelogMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader",
    "source_method": "registeredChangelogs",
    "target_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader.ChangelogMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader",
    "source_method": "restoringChangelogs",
    "target_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader.ChangelogMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader",
    "source_method": "activeRestoringChangelogs",
    "target_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader.ChangelogMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader",
    "source_method": "standbyRestoringChangelogs",
    "target_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader.ChangelogMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader",
    "source_method": "updatePartitionsByType",
    "target_class": "java.util.Set<org.apache.kafka.common.TopicPartition>, org.apache.kafka.streams.processor.internals.Task.TaskType):void \t org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader",
    "source_method": "shouldResume",
    "target_class": "org.apache.kafka.common.TopicPartition, org.apache.kafka.streams.processor.internals.Task.TaskType):boolean \t org.apache.kafka.streams.processor.internals.ProcessorStateManager"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader",
    "source_method": "shouldPause",
    "target_class": "org.apache.kafka.common.TopicPartition, org.apache.kafka.streams.processor.internals.Task.TaskType):boolean \t org.apache.kafka.streams.processor.internals.ProcessorStateManager"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader",
    "source_method": "getPositionString",
    "target_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader.ChangelogMetadata):java.lang.String \t org.apache.kafka.streams.processor.internals.ProcessorStateManager"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader",
    "source_method": "maybeUpdateLimitOffsetsForStandbyChangelogs",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader",
    "source_method": "maybeInitTaskTimeoutOrThrow",
    "target_class": "java.lang.Exception):void \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader",
    "source_method": "filterNewPartitionsToRestore",
    "target_class": "java.util.Set<org.apache.kafka.streams.processor.internals.StoreChangelogReader.ChangelogMetadata>):void \t org.apache.kafka.streams.processor.internals.StoreChangelogReader.ChangelogMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StoreChangelogReader",
    "source_method": "removeChangelogsFromRestoreConsumer",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.PartitionGrouper",
    "source_method": "partitionGroups",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.internals.TopologyMetadata.Subtopology,java.util.Set<java.lang.String>>, java.util.Map<org.apache.kafka.streams.processor.TaskId,java.util.Set<org.apache.kafka.common.TopicPartition>>, org.apache.kafka.common.Cluster):java.util.Map<org.apache.kafka.streams.processor.TaskId,java.util.Set<org.apache.kafka.common.TopicPartition>> \t org.apache.kafka.common.Cluster"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.TopicMetrics",
    "source_method": "consumedSensor",
    "target_class": "java.lang.String, java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.TopicMetrics",
    "source_method": "producedSensor",
    "target_class": "java.lang.String, java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.TaskMetrics",
    "source_method": "totalCacheSizeBytesSensor",
    "target_class": "java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.TaskMetrics",
    "source_method": "restoreRemainingRecordsSensor",
    "target_class": "java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.TaskMetrics",
    "source_method": "activeProcessRatioSensor",
    "target_class": "java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.TaskMetrics",
    "source_method": "activeBufferedRecordsSensor",
    "target_class": "java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.TaskMetrics",
    "source_method": "recordLatenessSensor",
    "target_class": "java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.TaskMetrics",
    "source_method": "invocationRateAndCountSensor",
    "target_class": "java.lang.String, java.lang.String, java.lang.String, java.lang.String, org.apache.kafka.common.metrics.Sensor.RecordingLevel, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl, org.apache.kafka.common.metrics.Sensor[]):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.TaskMetrics",
    "source_method": "invocationRateAndTotalSensor",
    "target_class": "java.lang.String, java.lang.String, java.lang.String, java.lang.String, org.apache.kafka.common.metrics.Sensor.RecordingLevel, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl, org.apache.kafka.common.metrics.Sensor[]):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.TaskMetrics",
    "source_method": "avgAndMaxSensor",
    "target_class": "java.lang.String, java.lang.String, java.lang.String, java.lang.String, org.apache.kafka.common.metrics.Sensor.RecordingLevel, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl, org.apache.kafka.common.metrics.Sensor[]):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.TaskMetrics",
    "source_method": "invocationRateAndCountAndAvgAndMaxLatencySensor",
    "target_class": "java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, org.apache.kafka.common.metrics.Sensor.RecordingLevel, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl, org.apache.kafka.common.metrics.Sensor[]):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "addClientLevelImmutableMetric",
    "target_class": "java.lang.String, org.apache.kafka.common.metrics.Sensor.RecordingLevel, T):void \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "addClientLevelMutableMetric",
    "target_class": "java.lang.String, org.apache.kafka.common.metrics.Sensor.RecordingLevel, org.apache.kafka.common.metrics.Gauge<T>):void \t org.apache.kafka.common.metrics.MetricConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "addThreadLevelImmutableMetric",
    "target_class": "java.lang.String, java.lang.String, T):void \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "clientLevelSensor",
    "target_class": "org.apache.kafka.common.metrics.Sensor.RecordingLevel, org.apache.kafka.common.metrics.Sensor[]):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "removeAllClientLevelMetrics",
    "target_class": "org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "removeAllClientLevelSensors",
    "target_class": "org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "removeAllThreadLevelSensors",
    "target_class": "org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "removeAllThreadLevelMetrics",
    "target_class": "org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "removeAllTaskLevelSensors",
    "target_class": "java.lang.String):void \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "removeAllNodeLevelSensors",
    "target_class": "java.lang.String, java.lang.String):void \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "removeAllTopicLevelSensors",
    "target_class": "java.lang.String, java.lang.String, java.lang.String):void \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "removeAllCacheLevelSensors",
    "target_class": "java.lang.String, java.lang.String):void \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "removeAllStoreLevelSensors",
    "target_class": "java.lang.String, java.lang.String):void \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "removeAllStoreLevelMetrics",
    "target_class": "java.lang.String, java.lang.String):void \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "customInvocationRateAndCountSensor",
    "target_class": "java.lang.String, java.lang.String, java.lang.String, java.util.Map<java.lang.String,java.lang.String>, org.apache.kafka.common.metrics.Sensor.RecordingLevel):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "addAvgAndMaxToSensor",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.String>, java.lang.String, java.lang.String, java.lang.String):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "addMinAndMaxToSensor",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.String>, java.lang.String, java.lang.String, java.lang.String):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "addAvgAndMaxLatencyToSensor",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.String>, java.lang.String):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "addAvgAndMinAndMaxToSensor",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.String>, java.lang.String, java.lang.String, java.lang.String, java.lang.String):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "addInvocationRateAndCountToSensor",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.String>, java.lang.String, java.lang.String, java.lang.String):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "addInvocationRateToSensor",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.String>, java.lang.String, java.lang.String):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "addRateOfSumMetricToSensor",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.String>, java.lang.String, java.lang.String):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "addSumMetricToSensor",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.String>, java.lang.String, boolean, java.lang.String):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "addValueMetricToSensor",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.String>, java.lang.String, java.lang.String):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "addAvgAndSumMetricsToSensor",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.String>, java.lang.String, java.lang.String, java.lang.String):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "addTotalCountAndSumMetricsToSensor",
    "target_class": "java.lang.String, java.util.Map<java.lang.String,java.lang.String>, java.lang.String, java.lang.String, java.lang.String, java.lang.String):void \t org.apache.kafka.common.metrics.Sensor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "maybeRecordSensor",
    "target_class": "org.apache.kafka.common.utils.Time, org.apache.kafka.common.metrics.Sensor):void \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "maybeMeasureLatency",
    "target_class": "org.apache.kafka.common.utils.Time, org.apache.kafka.common.metrics.Sensor):void \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "maybeMeasureLatency",
    "target_class": "org.apache.kafka.common.utils.Time, org.apache.kafka.common.metrics.Sensor):T \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl",
    "source_method": "getSensors",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.common.metrics.Sensor.RecordingLevel, org.apache.kafka.common.metrics.Sensor[]):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Metrics"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ProcessorNodeMetrics",
    "source_method": "suppressionEmitSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ProcessorNodeMetrics",
    "source_method": "skippedIdempotentUpdatesSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.common.metrics.Sensor.RecordingLevel"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ProcessorNodeMetrics",
    "source_method": "processAtSourceSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ProcessorNodeMetrics",
    "source_method": "e2ELatencySensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ProcessorNodeMetrics",
    "source_method": "emitFinalLatencySensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ProcessorNodeMetrics",
    "source_method": "emittedRecordsSensor",
    "target_class": "java.lang.String, java.lang.String, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ProcessorNodeMetrics",
    "source_method": "throughputSensor",
    "target_class": "java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, org.apache.kafka.common.metrics.Sensor.RecordingLevel, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl, org.apache.kafka.common.metrics.Sensor[]):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ThreadMetrics",
    "source_method": "processLatencySensor",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ThreadMetrics",
    "source_method": "pollRecordsSensor",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ThreadMetrics",
    "source_method": "processRecordsSensor",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ThreadMetrics",
    "source_method": "processRateSensor",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ThreadMetrics",
    "source_method": "processRatioSensor",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ThreadMetrics",
    "source_method": "punctuateRatioSensor",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ThreadMetrics",
    "source_method": "pollRatioSensor",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ThreadMetrics",
    "source_method": "commitRatioSensor",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ThreadMetrics",
    "source_method": "addThreadStartTimeMetric",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl, long):void \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ThreadMetrics",
    "source_method": "addThreadBlockedTimeMetric",
    "target_class": "org.apache.kafka.streams.processor.internals.StreamThreadTotalBlockedTime, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):void \t org.apache.kafka.streams.processor.internals.StreamThreadTotalBlockedTime"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ThreadMetrics",
    "source_method": "invocationRateAndCountSensor",
    "target_class": "java.lang.String, java.lang.String, java.lang.String, org.apache.kafka.common.metrics.Sensor.RecordingLevel, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.metrics.ThreadMetrics",
    "source_method": "invocationRateAndCountAndAvgAndMaxLatencySensor",
    "target_class": "java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, org.apache.kafka.common.metrics.Sensor.RecordingLevel, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl):org.apache.kafka.common.metrics.Sensor \t org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.LegacyStickyTaskAssignor",
    "source_method": "optimizeStandby",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.RackAwareTaskAssignor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.LegacyStickyTaskAssignor",
    "source_method": "optimizeActive",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.RackAwareTaskAssignor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.LegacyStickyTaskAssignor",
    "source_method": "allocateTaskWithClientCandidates",
    "target_class": "java.util.Set<org.apache.kafka.streams.processor.assignment.ProcessId>, boolean):void \t org.apache.kafka.streams.processor.internals.assignment.ClientState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.LegacyStickyTaskAssignor",
    "source_method": "assignTaskToClient",
    "target_class": "org.apache.kafka.streams.processor.TaskId, org.apache.kafka.streams.processor.internals.assignment.ClientState):void \t org.apache.kafka.streams.processor.internals.assignment.ClientState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.LegacyStickyTaskAssignor",
    "source_method": "hasClientsWithMoreAvailableCapacity",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.LegacyStickyTaskAssignor",
    "source_method": "findLeastLoaded",
    "target_class": "java.util.Set<org.apache.kafka.streams.processor.assignment.ProcessId>, boolean):org.apache.kafka.streams.processor.internals.assignment.ClientState \t org.apache.kafka.streams.processor.internals.assignment.ClientState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.LegacyStickyTaskAssignor.TaskPairs",
    "source_method": "pair",
    "target_class": "org.apache.kafka.streams.processor.TaskId):org.apache.kafka.streams.processor.internals.assignment.LegacyStickyTaskAssignor.TaskPairs.Pair \t org.apache.kafka.streams.processor.TaskId"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientTagAwareStandbyTaskAssignor",
    "source_method": "assignPendingStandbyTasksToLeastLoadedClients",
    "target_class": "int, org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet, java.util.Map<org.apache.kafka.streams.processor.TaskId,java.lang.Integer>):void \t org.apache.kafka.streams.processor.internals.assignment.StandbyTaskAssignmentUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ConsumerProtocolUtils",
    "source_method": "writeTaskIdTo",
    "target_class": "java.io.DataOutputStream, int):void \t org.apache.kafka.streams.processor.TaskId"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ConsumerProtocolUtils",
    "source_method": "writeTaskIdTo",
    "target_class": "java.nio.ByteBuffer, int):void \t org.apache.kafka.streams.processor.TaskId"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "activeTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "activeTaskCount",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "assignActiveTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "assignStandbyTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "assignActiveToConsumer",
    "target_class": "java.lang.String):void \t org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "assignStandbyToConsumer",
    "target_class": "java.lang.String):void \t org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "revokeActiveFromConsumer",
    "target_class": "java.lang.String):void \t org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "prevOwnedActiveTasksByConsumer",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "prevOwnedStandbyByConsumer",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "assignedActiveTasksByConsumer",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "revokingActiveTasksByConsumer",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "assignedStandbyTasksByConsumer",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "assignActive",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "unassignActive",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "standbyTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "hasStandbyTask",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "hasActiveTask",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "standbyTaskCount",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "assignStandby",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "unassignStandby",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "assignedTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "previouslyOwnedStandby",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "hasAssignedTask",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "prevActiveTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "addPreviousActiveTask",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "addPreviousActiveTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "prevStandbyTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "addPreviousStandbyTask",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "addPreviousStandbyTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "previousAssignedTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "initializePrevTasks",
    "target_class": "boolean):void \t org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "maybeFilterUnknownPrevTasksAndPartitions",
    "target_class": "boolean):void \t org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "statefulActiveTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "statelessActiveTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "hasUnfulfilledQuota",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "previousActiveTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "previousStandbyTasks",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "setAssignedTasks",
    "target_class": "org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "currentAssignment",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState",
    "source_method": "assertNotAssigned",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientStateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.TaskMovement",
    "source_method": "assignActiveTaskMovements",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.TaskId,java.util.SortedSet<org.apache.kafka.streams.processor.assignment.ProcessId>>, java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.internals.assignment.ClientState>, java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,java.util.Set<org.apache.kafka.streams.processor.TaskId>>, java.util.concurrent.atomic.AtomicInteger):int \t org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.TaskMovement",
    "source_method": "assignStandbyTaskMovements",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.TaskId,java.util.SortedSet<org.apache.kafka.streams.processor.assignment.ProcessId>>, java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.internals.assignment.ClientState>, java.util.concurrent.atomic.AtomicInteger, java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,java.util.Set<org.apache.kafka.streams.processor.TaskId>>):int \t org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.TaskMovement",
    "source_method": "tryToSwapStandbyAndActiveOnCaughtUpClient",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet, org.apache.kafka.streams.processor.internals.assignment.TaskMovement):boolean \t org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.TaskMovement",
    "source_method": "tryToMoveActiveToCaughtUpClientAndTryToWarmUp",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,java.util.Set<org.apache.kafka.streams.processor.TaskId>>, java.util.concurrent.atomic.AtomicInteger, org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet, org.apache.kafka.streams.processor.internals.assignment.TaskMovement):boolean \t org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.TaskMovement",
    "source_method": "moveActiveAndTryToWarmUp",
    "target_class": "org.apache.kafka.streams.processor.TaskId, org.apache.kafka.streams.processor.internals.assignment.ClientState, org.apache.kafka.streams.processor.internals.assignment.ClientState, java.util.Set<org.apache.kafka.streams.processor.TaskId>):void \t org.apache.kafka.streams.processor.internals.assignment.ClientState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.TaskMovement",
    "source_method": "moveStandbyAndTryToWarmUp",
    "target_class": "org.apache.kafka.streams.processor.TaskId, org.apache.kafka.streams.processor.internals.assignment.ClientState, org.apache.kafka.streams.processor.internals.assignment.ClientState):void \t org.apache.kafka.streams.processor.internals.assignment.ClientState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.TaskMovement",
    "source_method": "swapStandbyAndActive",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState, org.apache.kafka.streams.processor.internals.assignment.ClientState):void \t org.apache.kafka.streams.processor.internals.assignment.ClientState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.TaskMovement",
    "source_method": "mostCaughtUpEligibleClient",
    "target_class": "java.util.function.Function<org.apache.kafka.streams.processor.assignment.ProcessId,java.lang.Boolean>, org.apache.kafka.streams.processor.TaskId, org.apache.kafka.streams.processor.assignment.ProcessId):org.apache.kafka.streams.processor.assignment.ProcessId \t org.apache.kafka.streams.processor.assignment.ProcessId"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.StandbyTaskAssignmentUtils",
    "source_method": "createLeastLoadedPrioritySetConstrainedByAssignedTask",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.StandbyTaskAssignmentUtils",
    "source_method": "pollClientAndMaybeAssignAndUpdateRemainingStandbyTasks",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.internals.assignment.ClientState>, java.util.Map<org.apache.kafka.streams.processor.TaskId,java.lang.Integer>, org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet, org.apache.kafka.streams.processor.TaskId, org.apache.kafka.streams.processor.internals.assignment.Logger):void \t org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor",
    "source_method": "assignActiveStatefulTasks",
    "target_class": "java.util.SortedSet<org.apache.kafka.streams.processor.TaskId>, org.apache.kafka.streams.processor.internals.assignment.RackAwareTaskAssignor, org.apache.kafka.streams.processor.assignment.AssignmentConfigs):void \t org.apache.kafka.streams.processor.internals.assignment.RackAwareTaskAssignor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor",
    "source_method": "assignStandbyReplicaTasks",
    "target_class": "java.util.Set<org.apache.kafka.streams.processor.TaskId>, java.util.Set<org.apache.kafka.streams.processor.TaskId>, org.apache.kafka.streams.processor.internals.assignment.RackAwareTaskAssignor, org.apache.kafka.streams.processor.assignment.AssignmentConfigs):void \t org.apache.kafka.streams.processor.internals.assignment.RackAwareTaskAssignor"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor",
    "source_method": "balanceTasksOverThreads",
    "target_class": "java.util.function.Function<org.apache.kafka.streams.processor.internals.assignment.ClientState,java.util.Set<org.apache.kafka.streams.processor.TaskId>>, java.util.function.BiConsumer<org.apache.kafka.streams.processor.internals.assignment.ClientState,org.apache.kafka.streams.processor.TaskId>, java.util.function.BiConsumer<org.apache.kafka.streams.processor.internals.assignment.ClientState,org.apache.kafka.streams.processor.TaskId>, java.util.function.BiPredicate<org.apache.kafka.streams.processor.internals.assignment.ClientState,org.apache.kafka.streams.processor.internals.assignment.ClientState>):void \t org.apache.kafka.streams.processor.internals.assignment.ClientState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor",
    "source_method": "shouldMoveATask",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ClientState):boolean \t org.apache.kafka.streams.processor.internals.assignment.ClientState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor",
    "source_method": "assignStatelessActiveTasks",
    "target_class": "java.lang.Iterable<org.apache.kafka.streams.processor.TaskId>, org.apache.kafka.streams.processor.internals.assignment.RackAwareTaskAssignor):void \t org.apache.kafka.streams.processor.internals.assignment.ClientState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor",
    "source_method": "tasksToClientByLag",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.internals.assignment.ClientState>):java.util.Map<org.apache.kafka.streams.processor.TaskId,java.util.SortedSet<org.apache.kafka.streams.processor.assignment.ProcessId>> \t org.apache.kafka.streams.processor.internals.assignment.ClientState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.RackUtils",
    "source_method": "annotateTopicPartitionsWithRackInfo",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopicManager, java.util.Set<org.apache.kafka.streams.processor.internals.assignment.DefaultTaskTopicPartition>):void \t org.apache.kafka.streams.processor.internals.assignment.DefaultTaskTopicPartition"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.RackUtils",
    "source_method": "topicsWithMissingMetadata",
    "target_class": "java.util.Set<org.apache.kafka.common.TopicPartition>):java.util.Set<java.lang.String> \t org.apache.kafka.common.Cluster"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.RackUtils",
    "source_method": "knownRacksForPartition",
    "target_class": "java.util.Set<org.apache.kafka.common.TopicPartition>):java.util.Map<org.apache.kafka.common.TopicPartition,java.util.Set<java.lang.String>> \t org.apache.kafka.common.Cluster"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.RackUtils",
    "source_method": "describeTopics",
    "target_class": "java.util.Set<java.lang.String>):java.util.Map<java.lang.String,java.util.List<org.apache.kafka.common.TopicPartitionInfo>> \t org.apache.kafka.streams.processor.internals.InternalTopicManager"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.RackAwareTaskAssignor",
    "source_method": "validateClientRack",
    "target_class": "org.apache.kafka.streams.processor.assignment.AssignmentConfigs, java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,java.lang.String>):boolean \t org.apache.kafka.streams.processor.assignment.AssignmentConfigs"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.RackAwareTaskAssignor",
    "source_method": "tasksCost",
    "target_class": "java.util.SortedMap<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.internals.assignment.ClientState>, int, int, java.util.function.BiPredicate<org.apache.kafka.streams.processor.internals.assignment.ClientState,org.apache.kafka.streams.processor.TaskId>, boolean, boolean):long \t org.apache.kafka.streams.processor.internals.assignment.Graph"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.StandbyTaskAssignorFactory",
    "source_method": "create",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.RackAwareTaskAssignor):org.apache.kafka.streams.processor.internals.assignment.StandbyTaskAssignor \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.CopartitionedTopicsEnforcer",
    "source_method": "maybeSetNumberOfPartitionsForInternalTopic",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopicConfig):void \t org.apache.kafka.streams.processor.internals.InternalTopicConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.CopartitionedTopicsEnforcer",
    "source_method": "validateAndGetNumOfPartitions",
    "target_class": "java.util.Collection<org.apache.kafka.streams.processor.internals.InternalTopicConfig>):int \t org.apache.kafka.streams.processor.internals.InternalTopicConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo",
    "source_method": "writeHostInfo",
    "target_class": "org.apache.kafka.streams.state.HostInfo):void \t org.apache.kafka.streams.state.HostInfo"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo",
    "source_method": "decodeActiveTasks",
    "target_class": "java.io.DataInputStream):void \t org.apache.kafka.streams.processor.internals.assignment.ConsumerProtocolUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.assignment.AssignmentInfo",
    "source_method": "decodeStandbyTasks",
    "target_class": "java.io.DataInputStream):void \t org.apache.kafka.streams.processor.internals.assignment.ConsumerProtocolUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata",
    "source_method": "getTaskConfigFor",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata",
    "source_method": "allFullSourceTopicNames",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata",
    "source_method": "sourceTopicPattern",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata",
    "source_method": "topologyDescriptionString",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata",
    "source_method": "buildSubtopology",
    "target_class": "org.apache.kafka.streams.processor.TaskId"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata",
    "source_method": "stateStoreNameToSourceTopics",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata",
    "source_method": "subtopologyTopicsInfoMapExcluding",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata",
    "source_method": "topologyToSubtopologyTopicsInfoMap",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata",
    "source_method": "lookupBuilderForTask",
    "target_class": "org.apache.kafka.streams.processor.TaskId"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.ChangelogRecordDeserializationHelper",
    "source_method": "applyChecksAndUpdatePosition",
    "target_class": "boolean, org.apache.kafka.streams.query.Position):void \t org.apache.kafka.common.header.Header"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.GlobalStreamThread.StateConsumer",
    "source_method": "initialize",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.GlobalStreamThread.StateConsumer",
    "source_method": "pollAndUpdate",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.GlobalStreamThread",
    "source_method": "consumerMetrics",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.GlobalStreamThread",
    "source_method": "globalConsumerInstanceId",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.RecordDeserializer",
    "source_method": "deserialize",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerRecord<byte[],byte[]>):org.apache.kafka.clients.consumer.ConsumerRecord<java.lang.Object,java.lang.Object> \t org.apache.kafka.streams.processor.internals.SourceNode"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.RecordDeserializer",
    "source_method": "handleDeserializationFailure",
    "target_class": "org.apache.kafka.streams.processor.api.ProcessorContext<?,?>, java.lang.Exception, org.apache.kafka.clients.consumer.ConsumerRecord<byte[],byte[]>, org.apache.kafka.streams.processor.internals.Logger, org.apache.kafka.common.metrics.Sensor):void \t org.apache.kafka.streams.errors.DeserializationExceptionHandler"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.internals.StateRestoreCallbackAdapter",
    "source_method": "adapt",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerRecord"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.TaskId",
    "source_method": "readFrom",
    "target_class": "int):org.apache.kafka.streams.processor.TaskId \t org.apache.kafka.streams.processor.internals.assignment.ConsumerProtocolUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.TaskId",
    "source_method": "readFrom",
    "target_class": "int):org.apache.kafka.streams.processor.TaskId \t org.apache.kafka.streams.processor.internals.assignment.ConsumerProtocolUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.api.InternalFixedKeyRecordFactory",
    "source_method": "create",
    "target_class": "org.apache.kafka.streams.processor.api.Record"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor",
    "source_method": "optimizeActive",
    "target_class": "org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor.AssignmentState):void \t org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils.RackAwareOptimizationParams"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor",
    "source_method": "optimizeStandby",
    "target_class": "org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor.AssignmentState):void \t org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils.RackAwareOptimizationParams"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor",
    "source_method": "assignActive",
    "target_class": "java.util.Collection<org.apache.kafka.streams.processor.assignment.KafkaStreamsState>, org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor.AssignmentState, boolean):void \t org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor.AssignmentState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor",
    "source_method": "assignStandby",
    "target_class": "org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor.AssignmentState):void \t org.apache.kafka.streams.processor.assignment.AssignmentConfigs"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor.AssignmentState",
    "source_method": "finalizeAssignment",
    "target_class": "org.apache.kafka.streams.processor.assignment.ProcessId, org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment.AssignedTask.Type):void \t org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor.TaskPairs"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor.AssignmentState",
    "source_method": "hasRoomForActiveTask",
    "target_class": "int):boolean \t org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment.AssignedTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor.AssignmentState",
    "source_method": "findLeastLoadedClient",
    "target_class": "java.util.Set<org.apache.kafka.streams.processor.assignment.ProcessId>):org.apache.kafka.streams.processor.assignment.ProcessId \t org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor.TaskPairs"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor.TaskPairs",
    "source_method": "pair",
    "target_class": "org.apache.kafka.streams.processor.TaskId):org.apache.kafka.streams.processor.assignment.assignors.StickyTaskAssignor.TaskPair \t org.apache.kafka.streams.processor.TaskId"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "validateTaskAssignment",
    "target_class": "org.apache.kafka.streams.processor.assignment.TaskAssignor.TaskAssignment):org.apache.kafka.streams.processor.assignment.TaskAssignor.AssignmentError \t org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "identityAssignment",
    "target_class": "org.apache.kafka.streams.processor.assignment.ApplicationState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "defaultStandbyTaskAssignment",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment>):void \t org.apache.kafka.streams.processor.assignment.ApplicationState"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "optimizeRackAwareActiveTasks",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment>):void \t org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "optimizeRackAwareStandbyTasks",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment>):void \t org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "computeTotalAssignmentCost",
    "target_class": "java.util.List<org.apache.kafka.streams.processor.TaskId>, java.util.List<org.apache.kafka.streams.processor.assignment.ProcessId>, java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment>, java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.assignment.KafkaStreamsState>, int, int, boolean, boolean):long \t org.apache.kafka.streams.processor.internals.assignment.Graph"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "buildTaskGraph",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.assignment.KafkaStreamsState>, java.util.List<org.apache.kafka.streams.processor.TaskId>, java.util.List<org.apache.kafka.streams.processor.assignment.ProcessId>, java.util.Map<org.apache.kafka.streams.processor.TaskId,java.util.Set<org.apache.kafka.streams.processor.assignment.TaskTopicPartition>>, int, int, boolean, boolean, org.apache.kafka.streams.processor.internals.assignment.RackAwareGraphConstructor<org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment>):org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils.AssignmentGraph \t org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "canPerformRackAwareOptimization",
    "target_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils.RackAwareOptimizationParams, org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment.AssignedTask.Type):boolean \t org.apache.kafka.streams.processor.assignment.AssignmentConfigs"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "hasValidRackInformation",
    "target_class": "org.apache.kafka.streams.processor.assignment.ProcessId"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "tagBasedStandbyTaskAssignment",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment>):java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment> \t org.apache.kafka.streams.processor.assignment.AssignmentConfigs"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "assignStandbyTasksForActiveTask",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment>, java.util.Map<org.apache.kafka.streams.processor.TaskId,java.lang.Integer>, org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet, org.apache.kafka.streams.processor.TaskId):void \t org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "assignStandbyTasksToClientsWithDifferentTags",
    "target_class": "org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet, org.apache.kafka.streams.processor.TaskId, org.apache.kafka.streams.processor.assignment.ProcessId, java.util.Set<java.lang.String>, java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.assignment.KafkaStreamsState>, java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment>, java.util.Map<org.apache.kafka.streams.processor.TaskId,java.lang.Integer>, java.util.Map<java.lang.String,java.util.Set<java.lang.String>>, java.util.Map<org.apache.kafka.streams.KeyValue<java.lang.String,java.lang.String>,java.util.Set<org.apache.kafka.streams.processor.assignment.ProcessId>>, java.util.Map<org.apache.kafka.streams.processor.TaskId,org.apache.kafka.streams.processor.assignment.ProcessId>):void \t org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "getStandbyTaskMovePredicate",
    "target_class": "org.apache.kafka.streams.processor.assignment.AssignmentConfigs"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "standbyTaskPriorityListByLoad",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment>):org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet \t org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "assignPendingStandbyTasksToLeastLoadedClients",
    "target_class": "int, org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet, java.util.Map<org.apache.kafka.streams.processor.TaskId,java.lang.Integer>):void \t org.apache.kafka.streams.processor.internals.assignment.ConstrainedPrioritySet"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "initializeAssignmentsForAllClients",
    "target_class": "java.util.Map<org.apache.kafka.streams.processor.assignment.ProcessId,org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment>):void \t org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils",
    "source_method": "getTasksToOptimize",
    "target_class": "org.apache.kafka.streams.processor.assignment.TaskAssignmentUtils.RackAwareOptimizationParams, org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment.AssignedTask.Type):java.util.SortedSet<org.apache.kafka.streams.processor.TaskId> \t org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment",
    "source_method": "assignTask",
    "target_class": "org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment.AssignedTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment",
    "source_method": "removeTask",
    "target_class": "org.apache.kafka.streams.processor.assignment.KafkaStreamsAssignment.AssignedTask"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.AssignmentConfigs",
    "source_method": "of",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.processor.assignment.AssignmentConfigs",
    "source_method": "validated",
    "target_class": "T):T \t org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.suppress.KTableSuppressProcessorSupplier.KTableSuppressProcessor",
    "source_method": "enforceConstraints",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalProcessorContext"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.suppress.KTableSuppressProcessorSupplier.KTableSuppressProcessor",
    "source_method": "overCapacity",
    "target_class": "org.apache.kafka.streams.state.internals.TimeOrderedKeyValueBuffer"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.NamedInternal",
    "source_method": "orElseGenerateWithPrefix",
    "target_class": "java.lang.String):java.lang.String \t org.apache.kafka.streams.kstream.internals.InternalNameProvider"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.KTableImpl",
    "source_method": "maybeSetOutputVersioned",
    "target_class": "org.apache.kafka.streams.kstream.internals.MaterializedInternal<?,?,org.apache.kafka.streams.state.KeyValueStore<org.apache.kafka.common.utils.Bytes,byte[]>>):void \t org.apache.kafka.streams.kstream.internals.MaterializedInternal"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.AbstractKStreamTimeWindowAggregateProcessor",
    "source_method": "shouldEmitFinal",
    "target_class": "org.apache.kafka.streams.kstream.EmitStrategy"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.StreamStreamJoinUtil",
    "source_method": "skipRecord",
    "target_class": "org.apache.kafka.streams.kstream.internals.Logger, org.apache.kafka.common.metrics.Sensor, org.apache.kafka.streams.processor.api.ProcessorContext<KOut,VOut>):boolean \t org.apache.kafka.streams.processor.api.ProcessingContext"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.KStreamImpl",
    "source_method": "createRepartitionedSource",
    "target_class": "org.apache.kafka.common.serialization.Serde<K1>, org.apache.kafka.common.serialization.Serde<V1>, java.lang.String, org.apache.kafka.streams.processor.StreamPartitioner<K1,V1>, org.apache.kafka.streams.kstream.internals.graph.BaseRepartitionNode.BaseRepartitionNodeBuilder<K1,V1,RN>):java.lang.String \t org.apache.kafka.streams.kstream.internals.graph.BaseRepartitionNode.BaseRepartitionNodeBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.ChangedSerializer",
    "source_method": "isUpgrade",
    "target_class": "org.apache.kafka.streams.internals.UpgradeFromValues"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.graph.GraphGraceSearchUtil",
    "source_method": "findAndVerifyWindowGrace",
    "target_class": "java.lang.String):long \t org.apache.kafka.streams.kstream.internals.graph.GraphNode"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.graph.GraphGraceSearchUtil",
    "source_method": "extractGracePeriod",
    "target_class": "org.apache.kafka.streams.kstream.internals.graph.ProcessorParameters"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.graph.ProcessorParameters",
    "source_method": "addProcessorTo",
    "target_class": "java.lang.String[]):void \t org.apache.kafka.streams.processor.internals.InternalTopologyBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.foreignkeyjoin.SubscriptionWrapperSerde.SubscriptionWrapperSerializer",
    "source_method": "upgradeFromV0",
    "target_class": "org.apache.kafka.streams.internals.UpgradeFromValues"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.AbstractStream",
    "source_method": "toValueTransformerWithKeySupplier",
    "target_class": "org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.WrappingNullableSerde",
    "source_method": "setIfUnset",
    "target_class": "org.apache.kafka.streams.kstream.internals.WrappingNullableDeserializer"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.OuterStreamJoinStoreFactory",
    "source_method": "buildOuterJoinWindowStoreName",
    "target_class": "java.lang.String, org.apache.kafka.streams.kstream.internals.OuterStreamJoinStoreFactory.Type):java.lang.String \t org.apache.kafka.streams.kstream.internals.StreamJoinedInternal"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.KStreamImplJoin",
    "source_method": "join",
    "target_class": "org.apache.kafka.streams.kstream.KStream<K,V2>, org.apache.kafka.streams.kstream.ValueJoinerWithKey<? super K,? super V1,? super V2,? extends VOut>, org.apache.kafka.streams.kstream.JoinWindows, org.apache.kafka.streams.kstream.StreamJoined<K,V1,V2>):org.apache.kafka.streams.kstream.KStream<K,VOut> \t org.apache.kafka.streams.kstream.internals.StreamJoinedInternal"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.KStreamImplJoin",
    "source_method": "assertWindowSettings",
    "target_class": "org.apache.kafka.streams.kstream.JoinWindows):void \t org.apache.kafka.streams.kstream.JoinWindows"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.KStreamImplJoin",
    "source_method": "joinWindowStoreBuilderFromSupplier",
    "target_class": "org.apache.kafka.common.serialization.Serde<K>, org.apache.kafka.common.serialization.Serde<V>):org.apache.kafka.streams.processor.internals.StoreFactory \t org.apache.kafka.streams.state.Stores"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.WrappingNullableUtils",
    "source_method": "prepareSerde",
    "target_class": "org.apache.kafka.streams.processor.internals.SerdeGetter, boolean):org.apache.kafka.common.serialization.Serde<T> \t org.apache.kafka.streams.kstream.internals.WrappingNullableSerde"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.WrappingNullableUtils",
    "source_method": "initNullableSerializer",
    "target_class": "org.apache.kafka.streams.processor.internals.SerdeGetter):void \t org.apache.kafka.streams.kstream.internals.WrappingNullableSerializer"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.WrappingNullableUtils",
    "source_method": "initNullableDeserializer",
    "target_class": "org.apache.kafka.streams.processor.internals.SerdeGetter):void \t org.apache.kafka.streams.kstream.internals.WrappingNullableDeserializer"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.InternalStreamsBuilder",
    "source_method": "stream",
    "target_class": "org.apache.kafka.streams.kstream.internals.ConsumedInternal<K,V>):org.apache.kafka.streams.kstream.KStream<K,V> \t org.apache.kafka.streams.kstream.internals.ConsumedInternal"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.InternalStreamsBuilder",
    "source_method": "stream",
    "target_class": "org.apache.kafka.streams.kstream.internals.ConsumedInternal<K,V>):org.apache.kafka.streams.kstream.KStream<K,V> \t org.apache.kafka.streams.kstream.internals.ConsumedInternal"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.InternalStreamsBuilder",
    "source_method": "table",
    "target_class": "org.apache.kafka.streams.kstream.internals.ConsumedInternal<K,V>, org.apache.kafka.streams.kstream.internals.MaterializedInternal<K,V,org.apache.kafka.streams.state.KeyValueStore<org.apache.kafka.common.utils.Bytes,byte[]>>):org.apache.kafka.streams.kstream.KTable<K,V> \t org.apache.kafka.streams.kstream.internals.MaterializedInternal"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.InternalStreamsBuilder",
    "source_method": "globalTable",
    "target_class": "org.apache.kafka.streams.kstream.internals.ConsumedInternal<K,V>, org.apache.kafka.streams.kstream.internals.MaterializedInternal<K,V,org.apache.kafka.streams.state.KeyValueStore<org.apache.kafka.common.utils.Bytes,byte[]>>):org.apache.kafka.streams.kstream.GlobalKTable<K,V> \t org.apache.kafka.streams.kstream.internals.MaterializedInternal"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.InternalStreamsBuilder",
    "source_method": "createRepartitionNode",
    "target_class": "org.apache.kafka.common.serialization.Serde<K>, org.apache.kafka.common.serialization.Serde<V>):org.apache.kafka.streams.kstream.internals.graph.OptimizableRepartitionNode<K,V> \t org.apache.kafka.streams.kstream.internals.graph.OptimizableRepartitionNode.OptimizableRepartitionNodeBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.InternalStreamsBuilder",
    "source_method": "isVersionedOrVersionedUpstream",
    "target_class": "org.apache.kafka.streams.kstream.internals.graph.GraphNode"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.FullChangeSerde",
    "source_method": "decomposeLegacyFormattedArrayIntoChangeArrays",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.MaterializedInternal",
    "source_method": "parse",
    "target_class": "org.apache.kafka.streams.kstream.Materialized.StoreType"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.internals.MaterializedInternal",
    "source_method": "storeName",
    "target_class": "org.apache.kafka.streams.state.StoreSupplier"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.Printed",
    "source_method": "toFile",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.SlidingWindows",
    "source_method": "ofTimeDifferenceAndGrace",
    "target_class": "java.time.Duration):org.apache.kafka.streams.kstream.SlidingWindows \t org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.SlidingWindows",
    "source_method": "withTimeDifferenceAndGrace",
    "target_class": "java.time.Duration):org.apache.kafka.streams.kstream.SlidingWindows \t org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.TimeWindows",
    "source_method": "ofSizeAndGrace",
    "target_class": "java.time.Duration):org.apache.kafka.streams.kstream.TimeWindows \t org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.TimeWindows",
    "source_method": "of",
    "target_class": "org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.SessionWindows",
    "source_method": "ofInactivityGapAndGrace",
    "target_class": "java.time.Duration):org.apache.kafka.streams.kstream.SessionWindows \t org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.SessionWindows",
    "source_method": "with",
    "target_class": "org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.JoinWindows",
    "source_method": "ofTimeDifferenceAndGrace",
    "target_class": "java.time.Duration):org.apache.kafka.streams.kstream.JoinWindows \t org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.JoinWindows",
    "source_method": "of",
    "target_class": "org.apache.kafka.streams.internals.ApiUtils"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.WindowedSerdes",
    "source_method": "timeWindowedSerdeFrom",
    "target_class": "org.apache.kafka.common.serialization.Serdes"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.WindowedSerdes",
    "source_method": "timeWindowedSerdeFrom",
    "target_class": "long):org.apache.kafka.common.serialization.Serde<org.apache.kafka.streams.kstream.Windowed<T>> \t org.apache.kafka.common.serialization.Serdes"
  },
  {
    "source_class": "org.apache.kafka.streams.kstream.WindowedSerdes",
    "source_method": "sessionWindowedSerdeFrom",
    "target_class": "org.apache.kafka.common.serialization.Serdes"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "setUncaughtExceptionHandler",
    "target_class": "org.apache.kafka.streams.processor.internals.GlobalStreamThread"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "setGlobalStateRestoreListener",
    "target_class": "org.apache.kafka.streams.KafkaStreams.DelegatingStateRestoreListener"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "setStandbyUpdateListener",
    "target_class": "org.apache.kafka.streams.KafkaStreams.DelegatingStandbyUpdateListener"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "metrics",
    "target_class": "extends org.apache.kafka.common.Metric> \t org.apache.kafka.streams.processor.internals.StreamThread"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "getMetrics",
    "target_class": "org.apache.kafka.common.utils.Time, java.lang.String):org.apache.kafka.common.metrics.Metrics \t org.apache.kafka.common.metrics.MetricConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "getNextThreadIndex",
    "target_class": "org.apache.kafka.streams.processor.internals.StreamThread"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "getCacheSizePerThread",
    "target_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "resizeThreadCache",
    "target_class": "org.apache.kafka.streams.processor.internals.GlobalStreamThread"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "maybeCreateRocksDBMetricsRecordingService",
    "target_class": "org.apache.kafka.streams.StreamsConfig):java.util.concurrent.ScheduledExecutorService \t org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "parseHostInfo",
    "target_class": "org.apache.kafka.streams.state.HostInfo"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "cleanUp",
    "target_class": "org.apache.kafka.streams.processor.internals.StateDirectory"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "allMetadata",
    "target_class": "org.apache.kafka.streams.StreamsMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "metadataForAllStreamsClients",
    "target_class": "org.apache.kafka.streams.processor.internals.StreamsMetadataState"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "allMetadataForStore",
    "target_class": "org.apache.kafka.streams.StreamsMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "streamsMetadataForStore",
    "target_class": "org.apache.kafka.streams.processor.internals.StreamsMetadataState"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "queryMetadataForKey",
    "target_class": "K, org.apache.kafka.common.serialization.Serializer<K>):org.apache.kafka.streams.KeyQueryMetadata \t org.apache.kafka.streams.processor.internals.StreamsMetadataState"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "queryMetadataForKey",
    "target_class": "K, org.apache.kafka.streams.processor.StreamPartitioner<? super K,?>):org.apache.kafka.streams.KeyQueryMetadata \t org.apache.kafka.streams.processor.internals.StreamsMetadataState"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "store",
    "target_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "pause",
    "target_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "isPaused",
    "target_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "resume",
    "target_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "getOrThrowException",
    "target_class": "long, java.util.function.Supplier<java.lang.String>):T \t org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "localThreadsMetadata",
    "target_class": "org.apache.kafka.streams.TaskMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "metadataForLocalThreads",
    "target_class": "org.apache.kafka.streams.processor.internals.StreamThread"
  },
  {
    "source_class": "org.apache.kafka.streams.KafkaStreams",
    "source_method": "query",
    "target_class": "org.apache.kafka.streams.processor.internals.TopologyMetadata"
  },
  {
    "source_class": "org.apache.kafka.streams.TopologyTestDriver",
    "source_method": "logIfTaskIdleEnabled",
    "target_class": "org.apache.kafka.common.config.AbstractConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.TopologyTestDriver",
    "source_method": "setupMetrics",
    "target_class": "org.apache.kafka.common.metrics.MetricConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.TopologyTestDriver",
    "source_method": "setupTopology",
    "target_class": "org.apache.kafka.streams.StreamsConfig):void \t org.apache.kafka.streams.processor.internals.InternalTopologyBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.TopologyTestDriver",
    "source_method": "setupGlobalTask",
    "target_class": "org.apache.kafka.streams.StreamsConfig, org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl, org.apache.kafka.streams.state.internals.ThreadCache):void \t org.apache.kafka.clients.consumer.MockConsumer"
  },
  {
    "source_class": "org.apache.kafka.streams.TopologyTestDriver",
    "source_method": "setupTask",
    "target_class": "org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl, org.apache.kafka.streams.state.internals.ThreadCache, org.apache.kafka.streams.TopologyConfig.TaskConfig):void \t org.apache.kafka.streams.StreamsConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.TopologyTestDriver",
    "source_method": "enqueueTaskRecord",
    "target_class": "org.apache.kafka.common.TopicPartition, long, byte[], byte[], org.apache.kafka.common.header.Headers):void \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.streams.TopologyTestDriver",
    "source_method": "commit",
    "target_class": "org.apache.kafka.streams.TopologyTestDriver.TestDriverProducer"
  },
  {
    "source_class": "org.apache.kafka.streams.TopologyTestDriver",
    "source_method": "processGlobalRecord",
    "target_class": "long, byte[], byte[], org.apache.kafka.common.header.Headers):void \t org.apache.kafka.streams.processor.internals.GlobalStateUpdateTask"
  },
  {
    "source_class": "org.apache.kafka.streams.TopologyTestDriver",
    "source_method": "validateSourceTopicNameRegexPattern",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.TopologyTestDriver",
    "source_method": "getInputTopicOrPatternPartition",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.TopologyTestDriver",
    "source_method": "advanceWallClockTime",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.streams.TopologyTestDriver",
    "source_method": "readRecord",
    "target_class": "org.apache.kafka.common.serialization.Deserializer<K>, org.apache.kafka.common.serialization.Deserializer<V>):org.apache.kafka.streams.test.TestRecord<K,V> \t org.apache.kafka.common.serialization.Deserializer"
  },
  {
    "source_class": "org.apache.kafka.streams.TopologyTestDriver",
    "source_method": "pipeRecord",
    "target_class": "org.apache.kafka.streams.test.TestRecord<K,V>, org.apache.kafka.common.serialization.Serializer<K>, org.apache.kafka.common.serialization.Serializer<V>, java.time.Instant):void \t org.apache.kafka.common.serialization.Serializer"
  },
  {
    "source_class": "org.apache.kafka.streams.TopologyTestDriver",
    "source_method": "getAllStateStores",
    "target_class": "org.apache.kafka.streams.processor.internals.InternalTopologyBuilder"
  },
  {
    "source_class": "org.apache.kafka.streams.TopologyTestDriver",
    "source_method": "throwIfBuiltInStore",
    "target_class": "org.apache.kafka.streams.processor.StateStore"
  },
  {
    "source_class": "org.apache.kafka.streams.examples.wordcount.WordCountDemo",
    "source_method": "getStreamsConfig",
    "target_class": "org.apache.kafka.streams.StreamsConfig"
  },
  {
    "source_class": "org.apache.kafka.streams.examples.wordcount.WordCountDemo",
    "source_method": "createWordCountStream",
    "target_class": "org.apache.kafka.streams.StreamsBuilder"
  },
  {
    "source_class": "org.apache.kafka.tools.ConnectPluginPath",
    "source_method": "parseConfig",
    "target_class": "org.apache.kafka.tools.Namespace, java.io.PrintStream, java.io.PrintStream):org.apache.kafka.tools.ConnectPluginPath.Config \t org.apache.kafka.tools.ConnectPluginPath.Command"
  },
  {
    "source_class": "org.apache.kafka.tools.ConnectPluginPath",
    "source_method": "parseLocations",
    "target_class": "org.apache.kafka.tools.Namespace):java.util.Set<java.nio.file.Path> \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.ConnectPluginPath",
    "source_method": "runCommand",
    "target_class": "org.apache.kafka.connect.runtime.isolation.PluginUtils"
  },
  {
    "source_class": "org.apache.kafka.tools.ConnectPluginPath.Row",
    "source_method": "locationString",
    "target_class": "org.apache.kafka.tools.ManifestWorkspace.SourceWorkspace"
  },
  {
    "source_class": "org.apache.kafka.tools.ConnectPluginPath",
    "source_method": "enumerateRows",
    "target_class": "org.apache.kafka.connect.runtime.isolation.PluginScanResult):java.util.Set<org.apache.kafka.tools.ConnectPluginPath.Row> \t org.apache.kafka.connect.runtime.isolation.PluginUtils"
  },
  {
    "source_class": "org.apache.kafka.tools.ConnectPluginPath",
    "source_method": "newRow",
    "target_class": "java.lang.String, java.util.List<java.lang.String>, org.apache.kafka.connect.runtime.isolation.PluginType, java.lang.String, boolean):org.apache.kafka.tools.ConnectPluginPath.Row \t org.apache.kafka.tools.ManifestWorkspace.SourceWorkspace"
  },
  {
    "source_class": "org.apache.kafka.tools.ConnectPluginPath",
    "source_method": "beginCommand",
    "target_class": "org.apache.kafka.tools.ConnectPluginPath.Config"
  },
  {
    "source_class": "org.apache.kafka.tools.ConnectPluginPath",
    "source_method": "handlePlugin",
    "target_class": "org.apache.kafka.tools.ConnectPluginPath.Row):void \t org.apache.kafka.tools.ManifestWorkspace.SourceWorkspace"
  },
  {
    "source_class": "org.apache.kafka.tools.ConnectPluginPath",
    "source_method": "endCommand",
    "target_class": "org.apache.kafka.tools.ManifestWorkspace, java.util.Map<java.nio.file.Path,java.util.Set<org.apache.kafka.tools.ConnectPluginPath.Row>>):void \t org.apache.kafka.tools.ManifestWorkspace"
  },
  {
    "source_class": "org.apache.kafka.tools.ConnectPluginPath",
    "source_method": "failCommand",
    "target_class": "java.lang.Throwable):void \t org.apache.kafka.tools.ConnectPluginPath.Config"
  },
  {
    "source_class": "org.apache.kafka.tools.ConnectPluginPath",
    "source_method": "listTablePrint",
    "target_class": "java.lang.Object[]):void \t org.apache.kafka.tools.ConnectPluginPath.Config"
  },
  {
    "source_class": "org.apache.kafka.tools.ConnectPluginPath",
    "source_method": "discoverPlugins",
    "target_class": "org.apache.kafka.connect.runtime.isolation.ReflectionScanner, org.apache.kafka.connect.runtime.isolation.ServiceLoaderScanner):org.apache.kafka.connect.runtime.isolation.PluginScanResult \t org.apache.kafka.connect.runtime.isolation.PluginScanner"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand",
    "source_method": "mainNoExit",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand",
    "source_method": "execute",
    "target_class": "org.apache.kafka.tools.TopicCommand.TopicCommandOptions"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand",
    "source_method": "printException",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand",
    "source_method": "parseReplicaAssignment",
    "target_class": "org.apache.kafka.tools.ToolsUtils"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand",
    "source_method": "parseTopicConfigsToBeAdded",
    "target_class": "org.apache.kafka.storage.internals.log.LogConfig"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand",
    "source_method": "isReassignmentInProgress",
    "target_class": "org.apache.kafka.clients.admin.PartitionReassignment):boolean \t org.apache.kafka.common.TopicPartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand",
    "source_method": "getReplicationFactor",
    "target_class": "org.apache.kafka.clients.admin.PartitionReassignment):java.lang.Integer \t org.apache.kafka.common.TopicPartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand",
    "source_method": "doGetTopics",
    "target_class": "java.util.Optional<java.lang.String>, java.lang.Boolean):java.util.List<java.lang.String> \t org.apache.kafka.common.internals.Topic"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.CommandTopicPartition",
    "source_method": "ifTopicDoesntExist",
    "target_class": "org.apache.kafka.tools.TopicCommand.TopicCommandOptions"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.TopicDescription",
    "source_method": "printDescription",
    "target_class": "org.apache.kafka.clients.admin.Config"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.PartitionDescription",
    "source_method": "minIsrCount",
    "target_class": "org.apache.kafka.clients.admin.Config"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.PartitionDescription",
    "source_method": "isUnderReplicated",
    "target_class": "org.apache.kafka.common.TopicPartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.PartitionDescription",
    "source_method": "hasLeader",
    "target_class": "org.apache.kafka.common.TopicPartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.PartitionDescription",
    "source_method": "isAtMinIsrPartitions",
    "target_class": "org.apache.kafka.common.TopicPartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.PartitionDescription",
    "source_method": "hasUnavailablePartitions",
    "target_class": "org.apache.kafka.common.TopicPartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.PartitionDescription",
    "source_method": "printDescription",
    "target_class": "org.apache.kafka.common.TopicPartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.DescribeOptions",
    "source_method": "shouldPrintUnderReplicatedPartitions",
    "target_class": "org.apache.kafka.tools.TopicCommand.PartitionDescription"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.DescribeOptions",
    "source_method": "shouldPrintUnavailablePartitions",
    "target_class": "org.apache.kafka.tools.TopicCommand.PartitionDescription"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.DescribeOptions",
    "source_method": "shouldPrintUnderMinIsrPartitions",
    "target_class": "org.apache.kafka.tools.TopicCommand.PartitionDescription"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.DescribeOptions",
    "source_method": "shouldPrintAtMinIsrPartitions",
    "target_class": "org.apache.kafka.tools.TopicCommand.PartitionDescription"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.DescribeOptions",
    "source_method": "maybePrintPartitionDescription",
    "target_class": "org.apache.kafka.tools.TopicCommand.PartitionDescription"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.TopicService",
    "source_method": "createAdminClient",
    "target_class": "java.util.Optional<java.lang.String>):org.apache.kafka.clients.admin.Admin \t org.apache.kafka.clients.admin.AdminClientConfig"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.TopicService",
    "source_method": "createTopic",
    "target_class": "org.apache.kafka.tools.TopicCommand.CommandTopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.TopicService",
    "source_method": "createTopic",
    "target_class": "org.apache.kafka.clients.admin.NewTopic"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.TopicService",
    "source_method": "listTopics",
    "target_class": "org.apache.kafka.tools.TopicCommand.TopicCommandOptions"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.TopicService",
    "source_method": "alterTopic",
    "target_class": "org.apache.kafka.tools.TopicCommand.TopicCommandOptions"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.TopicService",
    "source_method": "topicNewPartitions",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.common.KafkaFuture<org.apache.kafka.clients.admin.TopicDescription>>, java.lang.String):java.util.AbstractMap.SimpleEntry<java.lang.String,org.apache.kafka.clients.admin.NewPartitions> \t org.apache.kafka.tools.TopicCommand.CommandTopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.TopicService",
    "source_method": "printPartitionDescription",
    "target_class": "java.util.Map<org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.admin.PartitionReassignment>, org.apache.kafka.clients.admin.TopicDescription, java.lang.String, org.apache.kafka.clients.admin.Config, java.util.ArrayList<org.apache.kafka.common.TopicPartitionInfo>):void \t org.apache.kafka.clients.admin.TopicDescription"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.TopicService",
    "source_method": "printDescribeConfig",
    "target_class": "org.apache.kafka.tools.TopicCommand.DescribeOptions, java.util.Map<org.apache.kafka.common.TopicPartition,org.apache.kafka.clients.admin.PartitionReassignment>, org.apache.kafka.clients.admin.TopicDescription, java.lang.String, org.apache.kafka.common.Uuid, org.apache.kafka.clients.admin.Config, java.util.ArrayList<org.apache.kafka.common.TopicPartitionInfo>):void \t org.apache.kafka.clients.admin.TopicDescription"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.TopicService",
    "source_method": "deleteTopic",
    "target_class": "org.apache.kafka.tools.TopicCommand.TopicCommandOptions"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.TopicService",
    "source_method": "getTopics",
    "target_class": "boolean):java.util.List<java.lang.String> \t org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.tools.TopicCommand.TopicService",
    "source_method": "getTopicIds",
    "target_class": "boolean):java.util.List<org.apache.kafka.common.Uuid> \t org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.tools.FeatureCommand",
    "source_method": "levelToString",
    "target_class": "short):java.lang.String \t org.apache.kafka.server.common.MetadataVersion"
  },
  {
    "source_class": "org.apache.kafka.tools.FeatureCommand",
    "source_method": "handleDescribe",
    "target_class": "org.apache.kafka.clients.admin.FeatureMetadata"
  },
  {
    "source_class": "org.apache.kafka.tools.FeatureCommand",
    "source_method": "handleUpgrade",
    "target_class": "org.apache.kafka.clients.admin.Admin):void \t org.apache.kafka.clients.admin.FeatureUpdate.UpgradeType"
  },
  {
    "source_class": "org.apache.kafka.tools.FeatureCommand",
    "source_method": "downgradeType",
    "target_class": "org.apache.kafka.clients.admin.FeatureUpdate.UpgradeType"
  },
  {
    "source_class": "org.apache.kafka.tools.FeatureCommand",
    "source_method": "update",
    "target_class": "org.apache.kafka.clients.admin.Admin, java.util.Map<java.lang.String,org.apache.kafka.clients.admin.FeatureUpdate>, java.lang.Boolean):void \t org.apache.kafka.clients.admin.FeatureUpdate"
  },
  {
    "source_class": "org.apache.kafka.tools.VerifiableConsumer",
    "source_method": "onRecordsReceived",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerRecords"
  },
  {
    "source_class": "org.apache.kafka.tools.VerifiableConsumer",
    "source_method": "argParser",
    "target_class": "org.apache.kafka.clients.consumer.GroupProtocol"
  },
  {
    "source_class": "org.apache.kafka.tools.VerifiableConsumer",
    "source_method": "createFromArgs",
    "target_class": "java.lang.String[]):org.apache.kafka.tools.VerifiableConsumer \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.ReplicaVerificationTool",
    "source_method": "initialOffsets",
    "target_class": "java.util.Properties, long):java.util.Map<org.apache.kafka.common.TopicPartition,java.lang.Long> \t org.apache.kafka.clients.consumer.KafkaConsumer"
  },
  {
    "source_class": "org.apache.kafka.tools.ReplicaVerificationTool",
    "source_method": "consumerConfig",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerConfig"
  },
  {
    "source_class": "org.apache.kafka.tools.ReplicaVerificationTool",
    "source_method": "brokerDetails",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.tools.ReplicaVerificationTool",
    "source_method": "listTopicsMetadata",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.tools.ReplicaVerificationTool.ReplicaFetcherBlockingSend",
    "source_method": "sendRequest",
    "target_class": "extends org.apache.kafka.common.requests.AbstractRequest>):org.apache.kafka.clients.ClientResponse \t org.apache.kafka.common.Node"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "handleAction",
    "target_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommandOptions):void \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "compareTopicPartitions",
    "target_class": "org.apache.kafka.common.TopicPartition):int \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "compareTopicPartitionReplicas",
    "target_class": "org.apache.kafka.common.TopicPartitionReplica):int \t org.apache.kafka.common.TopicPartitionReplica"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "partitionReassignmentStatesToString",
    "target_class": "org.apache.kafka.tools.reassign.PartitionReassignmentState"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "findPartitionReassignmentStates",
    "target_class": "java.util.List<java.util.Map.Entry<org.apache.kafka.common.TopicPartition,java.util.List<java.lang.Integer>>>):java.util.Map.Entry<java.util.Map<org.apache.kafka.common.TopicPartition,org.apache.kafka.tools.reassign.PartitionReassignmentState>,java.lang.Boolean> \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "topicDescriptionFutureToState",
    "target_class": "org.apache.kafka.common.KafkaFuture<org.apache.kafka.clients.admin.TopicDescription>, java.util.List<java.lang.Integer>):org.apache.kafka.tools.reassign.PartitionReassignmentState \t org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "findLogDirMoveStates",
    "target_class": "java.util.Map<org.apache.kafka.common.TopicPartitionReplica,java.lang.String>):java.util.Map<org.apache.kafka.common.TopicPartitionReplica,org.apache.kafka.tools.reassign.LogDirMoveState> \t org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "replicaMoveStatesToString",
    "target_class": "org.apache.kafka.common.TopicPartitionReplica"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "clearAllThrottles",
    "target_class": "java.util.List<java.util.Map.Entry<org.apache.kafka.common.TopicPartition,java.util.List<java.lang.Integer>>>):void \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "clearBrokerLevelThrottles",
    "target_class": "java.util.Set<java.lang.Integer>):void \t org.apache.kafka.clients.admin.AlterConfigsResult"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "clearTopicLevelThrottles",
    "target_class": "java.util.Set<java.lang.String>):void \t org.apache.kafka.clients.admin.AlterConfigsResult"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "calculateAssignment",
    "target_class": "java.util.List<org.apache.kafka.admin.BrokerMetadata>):java.util.Map<org.apache.kafka.common.TopicPartition,java.util.List<java.lang.Integer>> \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "describeTopics",
    "target_class": "java.util.Set<java.lang.String>):java.util.Map<java.lang.String,org.apache.kafka.clients.admin.TopicDescription> \t org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "getReplicaAssignmentForTopics",
    "target_class": "java.util.List<java.lang.String>):java.util.Map<org.apache.kafka.common.TopicPartition,java.util.List<java.lang.Integer>> \t org.apache.kafka.common.TopicPartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "getReplicaAssignmentForPartitions",
    "target_class": "java.util.Set<org.apache.kafka.common.TopicPartition>):java.util.Map<org.apache.kafka.common.TopicPartition,java.util.List<java.lang.Integer>> \t org.apache.kafka.common.TopicPartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "getBrokerMetadata",
    "target_class": "java.util.List<java.lang.Integer>, boolean):java.util.List<org.apache.kafka.admin.BrokerMetadata> \t org.apache.kafka.clients.admin.DescribeClusterResult"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "parseGenerateAssignmentArgs",
    "target_class": "java.lang.String):java.util.Map.Entry<java.util.List<java.lang.Integer>,java.util.List<java.lang.String>> \t org.apache.kafka.tools.ToolsUtils"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "executeMoves",
    "target_class": "java.util.Map<org.apache.kafka.common.TopicPartitionReplica,java.lang.String>, java.lang.Long, org.apache.kafka.common.utils.Time):void \t org.apache.kafka.common.TopicPartitionReplica"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "curReassignmentsToString",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "verifyBrokerIds",
    "target_class": "java.util.Set<java.lang.Integer>):void \t org.apache.kafka.clients.admin.DescribeClusterResult"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "alterPartitionReassignments",
    "target_class": "java.util.Map<org.apache.kafka.common.TopicPartition,java.util.List<java.lang.Integer>>):java.util.Map<org.apache.kafka.common.TopicPartition,java.lang.Throwable> \t org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "cancelPartitionReassignments",
    "target_class": "java.util.Set<org.apache.kafka.common.TopicPartition>):java.util.Map<org.apache.kafka.common.TopicPartition,java.lang.Throwable> \t org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "calculateCurrentMoveMap",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "calculateProposedMoveMap",
    "target_class": "java.util.Map<org.apache.kafka.common.TopicPartition,java.util.List<java.lang.Integer>>, java.util.Map<org.apache.kafka.common.TopicPartition,java.util.List<java.lang.Integer>>):java.util.Map<java.lang.String,java.util.Map<java.lang.Integer,org.apache.kafka.tools.reassign.PartitionMove>> \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "calculateLeaderThrottles",
    "target_class": "org.apache.kafka.tools.reassign.PartitionMove"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "calculateFollowerThrottles",
    "target_class": "org.apache.kafka.tools.reassign.PartitionMove"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "calculateReassigningBrokers",
    "target_class": "org.apache.kafka.tools.reassign.PartitionMove"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "modifyTopicThrottles",
    "target_class": "java.util.Map<java.lang.String,java.lang.String>, java.util.Map<java.lang.String,java.lang.String>):void \t org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "modifyInterBrokerThrottle",
    "target_class": "java.util.Set<java.lang.Integer>, long):void \t org.apache.kafka.clients.admin.AlterConfigsResult"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "modifyLogDirThrottle",
    "target_class": "java.util.Set<java.lang.Integer>, long):void \t org.apache.kafka.clients.admin.AlterConfigsResult"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "parseExecuteAssignmentArgs",
    "target_class": "org.apache.kafka.tools.ToolsUtils"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "cancelAssignment",
    "target_class": "java.lang.String, java.lang.Boolean, java.lang.Long, org.apache.kafka.common.utils.Time):java.util.Map.Entry<java.util.Set<org.apache.kafka.common.TopicPartition>,java.util.Set<org.apache.kafka.common.TopicPartitionReplica>> \t org.apache.kafka.clients.admin.PartitionReassignment"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "formatAsReassignmentJson",
    "target_class": "java.util.Map<org.apache.kafka.common.TopicPartitionReplica,java.lang.String>):java.lang.String \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "parseTopicsData",
    "target_class": "org.apache.kafka.server.util.Json"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "parseTopicsData",
    "target_class": "org.apache.kafka.server.util.json.JsonValue):java.util.List<java.lang.String> \t org.apache.kafka.server.util.json.JsonObject"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "parsePartitionReassignmentData",
    "target_class": "org.apache.kafka.server.util.json.JsonValue):java.util.Map.Entry<java.util.List<java.util.Map.Entry<org.apache.kafka.common.TopicPartition,java.util.List<java.lang.Integer>>>,java.util.Map<org.apache.kafka.common.TopicPartitionReplica,java.lang.String>> \t org.apache.kafka.server.util.json.JsonObject"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "validateAndParseArgs",
    "target_class": "org.apache.kafka.server.util.CommandLineUtils"
  },
  {
    "source_class": "org.apache.kafka.tools.reassign.ReassignPartitionsCommand",
    "source_method": "alterReplicaLogDirs",
    "target_class": "java.util.Map<org.apache.kafka.common.TopicPartitionReplica,java.lang.String>):java.util.Set<org.apache.kafka.common.TopicPartitionReplica> \t org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.tools.EndToEndLatency",
    "source_method": "validate",
    "target_class": "byte[], org.apache.kafka.clients.consumer.ConsumerRecords<byte[],byte[]>):void \t org.apache.kafka.clients.consumer.ConsumerRecord"
  },
  {
    "source_class": "org.apache.kafka.tools.EndToEndLatency",
    "source_method": "setupConsumer",
    "target_class": "org.apache.kafka.clients.consumer.KafkaConsumer<byte[],byte[]>):void \t org.apache.kafka.clients.consumer.KafkaConsumer"
  },
  {
    "source_class": "org.apache.kafka.tools.EndToEndLatency",
    "source_method": "loadPropsWithBootstrapServers",
    "target_class": "java.lang.String):java.util.Properties \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.TransactionalMessageCopier",
    "source_method": "createProducer",
    "target_class": "org.apache.kafka.clients.producer.ProducerConfig"
  },
  {
    "source_class": "org.apache.kafka.tools.TransactionalMessageCopier",
    "source_method": "createConsumer",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerConfig"
  },
  {
    "source_class": "org.apache.kafka.tools.TransactionalMessageCopier",
    "source_method": "producerRecordFromConsumerRecord",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerRecord<java.lang.String,java.lang.String>):org.apache.kafka.clients.producer.ProducerRecord<java.lang.String,java.lang.String> \t org.apache.kafka.clients.consumer.ConsumerRecord"
  },
  {
    "source_class": "org.apache.kafka.tools.TransactionalMessageCopier",
    "source_method": "consumerPositions",
    "target_class": "org.apache.kafka.clients.consumer.KafkaConsumer"
  },
  {
    "source_class": "org.apache.kafka.tools.TransactionalMessageCopier",
    "source_method": "resetToLastCommittedPositions",
    "target_class": "org.apache.kafka.clients.consumer.KafkaConsumer"
  },
  {
    "source_class": "org.apache.kafka.tools.TransactionalMessageCopier",
    "source_method": "messagesRemaining",
    "target_class": "org.apache.kafka.common.TopicPartition):long \t org.apache.kafka.clients.consumer.KafkaConsumer"
  },
  {
    "source_class": "org.apache.kafka.tools.ClientMetricsCommand",
    "source_method": "execute",
    "target_class": "org.apache.kafka.tools.ClientMetricsCommand.ClientMetricsService"
  },
  {
    "source_class": "org.apache.kafka.tools.ClientMetricsCommand.ClientMetricsService",
    "source_method": "alterClientMetrics",
    "target_class": "org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.tools.ClientMetricsCommand.ClientMetricsService",
    "source_method": "deleteClientMetrics",
    "target_class": "org.apache.kafka.clients.admin.AlterConfigsOptions"
  },
  {
    "source_class": "org.apache.kafka.tools.ClientMetricsCommand.ClientMetricsService",
    "source_method": "describeClientMetrics",
    "target_class": "org.apache.kafka.clients.admin.ConfigEntry"
  },
  {
    "source_class": "org.apache.kafka.tools.ClientMetricsCommand.ClientMetricsService",
    "source_method": "listClientMetrics",
    "target_class": "org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.tools.ClientMetricsCommand.ClientMetricsService",
    "source_method": "getClientMetricsConfig",
    "target_class": "org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.tools.ClientMetricsCommand",
    "source_method": "printException",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.ConsoleConsumer",
    "source_method": "addShutdownHook",
    "target_class": "org.apache.kafka.tools.consumer.ConsoleConsumerOptions):void \t org.apache.kafka.tools.consumer.ConsoleConsumerOptions"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.ConsoleConsumer",
    "source_method": "process",
    "target_class": "org.apache.kafka.common.MessageFormatter, org.apache.kafka.tools.consumer.ConsoleConsumer.ConsumerWrapper, java.io.PrintStream, boolean):void \t org.apache.kafka.clients.consumer.ConsumerRecord"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.ConsoleConsumer.ConsumerWrapper",
    "source_method": "seek",
    "target_class": "int, long):void \t org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.ConsoleConsumer.ConsumerWrapper",
    "source_method": "resetUnconsumedOffsets",
    "target_class": "org.apache.kafka.clients.consumer.ConsumerRecord"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.ConsoleConsumer.ConsumerWrapper",
    "source_method": "receive",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.ConsoleConsumer.ConsumerWrapper",
    "source_method": "wakeup",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.ConsoleConsumer.ConsumerWrapper",
    "source_method": "cleanup",
    "target_class": "org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand",
    "source_method": "run",
    "target_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand.ConsumerGroupService"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand",
    "source_method": "consumerGroupStatesFromString",
    "target_class": "org.apache.kafka.common.ConsumerGroupState"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand",
    "source_method": "consumerGroupTypesFromString",
    "target_class": "org.apache.kafka.common.GroupType"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand",
    "source_method": "printOffsetsToReset",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand.ConsumerGroupService",
    "source_method": "printGroupInfo",
    "target_class": "boolean, boolean):void \t org.apache.kafka.clients.admin.ConsumerGroupListing"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand.ConsumerGroupService",
    "source_method": "listConsumerGroups",
    "target_class": "org.apache.kafka.clients.admin.ListConsumerGroupsResult"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand.ConsumerGroupService",
    "source_method": "listConsumerGroupsWithFilters",
    "target_class": "java.util.Set<org.apache.kafka.common.ConsumerGroupState>):java.util.List<org.apache.kafka.clients.admin.ConsumerGroupListing> \t org.apache.kafka.clients.admin.ListConsumerGroupsResult"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand.ConsumerGroupService",
    "source_method": "printMembers",
    "target_class": "boolean):void \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand.ConsumerGroupService",
    "source_method": "describePartitions",
    "target_class": "java.util.Optional<org.apache.kafka.common.Node>, java.util.List<org.apache.kafka.common.TopicPartition>, java.util.function.Function<org.apache.kafka.common.TopicPartition,java.util.Optional<java.lang.Long>>, java.util.Optional<java.lang.String>, java.util.Optional<java.lang.String>, java.util.Optional<java.lang.String>):java.util.Collection<org.apache.kafka.tools.consumer.group.PartitionAssignmentState> \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand.ConsumerGroupService",
    "source_method": "deleteOffsets",
    "target_class": "java.util.List<java.lang.String>):java.util.Map.Entry<org.apache.kafka.common.protocol.Errors,java.util.Map<org.apache.kafka.common.TopicPartition,java.lang.Throwable>> \t org.apache.kafka.common.TopicPartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand.ConsumerGroupService",
    "source_method": "collectGroupsOffsets",
    "target_class": "org.apache.kafka.clients.admin.MemberDescription"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand.ConsumerGroupService",
    "source_method": "collectGroupsMembers",
    "target_class": "boolean):java.util.TreeMap<java.lang.String,java.util.Map.Entry<java.util.Optional<org.apache.kafka.common.ConsumerGroupState>,java.util.Optional<java.util.Collection<org.apache.kafka.tools.consumer.group.MemberAssignmentState>>>> \t org.apache.kafka.clients.admin.ConsumerGroupDescription"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand.ConsumerGroupService",
    "source_method": "collectGroupsState",
    "target_class": "org.apache.kafka.clients.admin.ConsumerGroupDescription"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand.ConsumerGroupService",
    "source_method": "getLogTimestampOffsets",
    "target_class": "long):java.util.Map<org.apache.kafka.common.TopicPartition,org.apache.kafka.tools.consumer.group.ConsumerGroupCommand.LogOffsetResult> \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.consumer.group.ConsumerGroupCommand.ConsumerGroupService",
    "source_method": "parseTopicPartitionsToReset",
    "target_class": "org.apache.kafka.common.TopicPartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.tools.DeleteRecordsCommand",
    "source_method": "mainNoExit",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.DeleteRecordsCommand",
    "source_method": "parseJsonData",
    "target_class": "org.apache.kafka.server.util.json.JsonValue):java.util.Map<org.apache.kafka.common.TopicPartition,java.util.List<java.lang.Long>> \t org.apache.kafka.server.util.json.JsonArray"
  },
  {
    "source_class": "org.apache.kafka.tools.DeleteRecordsCommand",
    "source_method": "execute",
    "target_class": "java.lang.String, java.io.PrintStream):void \t org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.DeleteRecordsCommand",
    "source_method": "createAdminClient",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.TransactionsCommand.FindHangingTransactionsCommand",
    "source_method": "filterHangingTransactions",
    "target_class": "java.util.Map<java.lang.Long,java.lang.String>, java.util.Map<java.lang.String,org.apache.kafka.clients.admin.TransactionDescription>):java.util.List<org.apache.kafka.tools.TransactionsCommand.FindHangingTransactionsCommand.OpenTransaction> \t org.apache.kafka.clients.admin.TransactionDescription"
  },
  {
    "source_class": "org.apache.kafka.tools.TransactionsCommand.FindHangingTransactionsCommand",
    "source_method": "printHangingTransactions",
    "target_class": "java.io.PrintStream):void \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.tools.TransactionsCommand.FindHangingTransactionsCommand",
    "source_method": "hasReplica",
    "target_class": "org.apache.kafka.common.TopicPartitionInfo):boolean \t org.apache.kafka.common.TopicPartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.tools.TransactionsCommand.FindHangingTransactionsCommand",
    "source_method": "consumeInBatches",
    "target_class": "int, org.apache.kafka.tools.TransactionsCommand.FindHangingTransactionsCommand.ThrowableConsumer<java.util.List<T>>):void \t org.apache.kafka.tools.TransactionsCommand.FindHangingTransactionsCommand.ThrowableConsumer"
  },
  {
    "source_class": "org.apache.kafka.tools.TransactionsCommand",
    "source_method": "printErrorAndExit",
    "target_class": "org.apache.kafka.common.utils.Exit"
  },
  {
    "source_class": "org.apache.kafka.tools.TransactionsCommand",
    "source_method": "buildAdminClient",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.VerifiableProducer",
    "source_method": "createFromArgs",
    "target_class": "java.lang.String[]):org.apache.kafka.tools.VerifiableProducer \t org.apache.kafka.clients.producer.ProducerConfig"
  },
  {
    "source_class": "org.apache.kafka.tools.VerifiableProducer",
    "source_method": "send",
    "target_class": "java.lang.String):void \t org.apache.kafka.clients.producer.Producer"
  },
  {
    "source_class": "org.apache.kafka.tools.ManifestWorkspace",
    "source_method": "forSource",
    "target_class": "org.apache.kafka.connect.runtime.isolation.PluginSource"
  },
  {
    "source_class": "org.apache.kafka.tools.ManifestWorkspace.SourceWorkspace",
    "source_method": "loadManifest",
    "target_class": "org.apache.kafka.connect.runtime.isolation.PluginType"
  },
  {
    "source_class": "org.apache.kafka.tools.ClientCompatibilityTest",
    "source_method": "testProduce",
    "target_class": "org.apache.kafka.clients.producer.KafkaProducer"
  },
  {
    "source_class": "org.apache.kafka.tools.ClientCompatibilityTest",
    "source_method": "testDescribeConfigsMethod",
    "target_class": "org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.tools.ClientCompatibilityTest",
    "source_method": "createTopicsResultTest",
    "target_class": "java.util.Collection<java.lang.String>):void \t org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.tools.ToolsUtils",
    "source_method": "printMetrics",
    "target_class": "extends org.apache.kafka.common.Metric>):void \t org.apache.kafka.common.Metric"
  },
  {
    "source_class": "org.apache.kafka.tools.ToolsUtils",
    "source_method": "validateBootstrapServer",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.JmxTool",
    "source_method": "connectToBeanServer",
    "target_class": "org.apache.kafka.tools.JmxTool.JmxToolOptions"
  },
  {
    "source_class": "org.apache.kafka.tools.LogDirsCommand",
    "source_method": "mainNoExit",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.LogDirsCommand",
    "source_method": "fromReplicasInfoToPrintableRepresentation",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.LogDirsCommand",
    "source_method": "fromLogDirInfosToPrintableRepresentation",
    "target_class": "java.util.Set<java.lang.String>):java.util.List<java.util.Map<java.lang.String,java.lang.Object>> \t org.apache.kafka.clients.admin.LogDirDescription"
  },
  {
    "source_class": "org.apache.kafka.tools.LogDirsCommand",
    "source_method": "createAdminClient",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.StreamsResetter",
    "source_method": "execute",
    "target_class": "java.util.Properties):int \t org.apache.kafka.tools.StreamsResetter.StreamsResetterOptions"
  },
  {
    "source_class": "org.apache.kafka.tools.StreamsResetter",
    "source_method": "maybeDeleteActiveConsumers",
    "target_class": "org.apache.kafka.clients.admin.Admin, org.apache.kafka.tools.StreamsResetter.StreamsResetterOptions):void \t org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.tools.StreamsResetter",
    "source_method": "maybeResetInputAndSeekToEndIntermediateTopicOffsets",
    "target_class": "org.apache.kafka.tools.StreamsResetter.StreamsResetterOptions):int \t org.apache.kafka.common.PartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.tools.StreamsResetter",
    "source_method": "maybeSeekToEnd",
    "target_class": "org.apache.kafka.clients.consumer.Consumer<byte[],byte[]>, java.util.Set<org.apache.kafka.common.TopicPartition>):void \t org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.tools.StreamsResetter",
    "source_method": "resetOffsetsFromResetPlan",
    "target_class": "java.util.Set<org.apache.kafka.common.TopicPartition>, java.util.Map<org.apache.kafka.common.TopicPartition,java.lang.Long>):void \t org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.tools.StreamsResetter",
    "source_method": "resetToDatetime",
    "target_class": "java.util.Set<org.apache.kafka.common.TopicPartition>, java.lang.Long):void \t org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.tools.StreamsResetter",
    "source_method": "shiftOffsetsBy",
    "target_class": "java.util.Set<org.apache.kafka.common.TopicPartition>, long):void \t org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.tools.StreamsResetter",
    "source_method": "resetOffsetsTo",
    "target_class": "java.util.Set<org.apache.kafka.common.TopicPartition>, java.lang.Long):void \t org.apache.kafka.clients.consumer.Consumer"
  },
  {
    "source_class": "org.apache.kafka.tools.StreamsResetter",
    "source_method": "maybeDeleteInternalTopics",
    "target_class": "org.apache.kafka.tools.StreamsResetter.StreamsResetterOptions):int \t org.apache.kafka.tools.StreamsResetter.StreamsResetterOptions"
  },
  {
    "source_class": "org.apache.kafka.tools.StreamsResetter",
    "source_method": "doDelete",
    "target_class": "org.apache.kafka.clients.admin.Admin):void \t org.apache.kafka.clients.admin.DeleteTopicsResult"
  },
  {
    "source_class": "org.apache.kafka.tools.DelegationTokenCommand",
    "source_method": "createToken",
    "target_class": "org.apache.kafka.tools.DelegationTokenCommand.DelegationTokenCommandOptions):org.apache.kafka.common.security.token.delegation.DelegationToken \t org.apache.kafka.common.security.token.delegation.DelegationToken"
  },
  {
    "source_class": "org.apache.kafka.tools.DelegationTokenCommand",
    "source_method": "printToken",
    "target_class": "org.apache.kafka.common.security.token.delegation.DelegationToken"
  },
  {
    "source_class": "org.apache.kafka.tools.DelegationTokenCommand",
    "source_method": "getPrincipals",
    "target_class": "org.apache.kafka.tools.OptionSpec<java.lang.String>):java.util.List<org.apache.kafka.common.security.auth.KafkaPrincipal> \t org.apache.kafka.common.utils.SecurityUtils"
  },
  {
    "source_class": "org.apache.kafka.tools.DelegationTokenCommand",
    "source_method": "renewToken",
    "target_class": "org.apache.kafka.tools.DelegationTokenCommand.DelegationTokenCommandOptions):java.lang.Long \t org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.tools.DelegationTokenCommand",
    "source_method": "expireToken",
    "target_class": "org.apache.kafka.tools.DelegationTokenCommand.DelegationTokenCommandOptions):void \t org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.tools.DelegationTokenCommand",
    "source_method": "createAdminClient",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.LeaderElectionCommand",
    "source_method": "mainNoExit",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.LeaderElectionCommand",
    "source_method": "run",
    "target_class": "java.lang.String[]):void \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.LeaderElectionCommand",
    "source_method": "electLeaders",
    "target_class": "org.apache.kafka.common.ElectionType, java.util.Optional<java.util.Set<org.apache.kafka.common.TopicPartition>>):void \t org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.tools.LeaderElectionCommand",
    "source_method": "toTopicPartition",
    "target_class": "org.apache.kafka.server.util.json.JsonObject"
  },
  {
    "source_class": "org.apache.kafka.tools.ClusterTool",
    "source_method": "mainNoExit",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.ClusterTool",
    "source_method": "execute",
    "target_class": "org.apache.kafka.server.util.CommandLineUtils"
  },
  {
    "source_class": "org.apache.kafka.tools.ClusterTool",
    "source_method": "clusterIdCommand",
    "target_class": "org.apache.kafka.clients.admin.Admin):void \t org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.tools.ClusterTool",
    "source_method": "unregisterCommand",
    "target_class": "org.apache.kafka.clients.admin.Admin, int):void \t org.apache.kafka.clients.admin.UnregisterBrokerResult"
  },
  {
    "source_class": "org.apache.kafka.tools.MetadataQuorumCommand",
    "source_method": "mainNoExit",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.MetadataQuorumCommand",
    "source_method": "getProperties",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.MetadataQuorumCommand",
    "source_method": "handleDescribeReplication",
    "target_class": "boolean):void \t org.apache.kafka.tools.ToolsUtils"
  },
  {
    "source_class": "org.apache.kafka.tools.MetadataQuorumCommand",
    "source_method": "quorumInfoToRows",
    "target_class": "java.util.stream.Stream<org.apache.kafka.clients.admin.QuorumInfo.ReplicaState>, java.lang.String, boolean):java.util.List<java.util.List<java.lang.String>> \t org.apache.kafka.clients.admin.QuorumInfo.ReplicaState"
  },
  {
    "source_class": "org.apache.kafka.tools.MetadataQuorumCommand",
    "source_method": "handleDescribeStatus",
    "target_class": "org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.tools.ProducerPerformance",
    "source_method": "readProps",
    "target_class": "java.lang.String, java.lang.String, boolean):java.util.Properties \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.tools.GetOffsetShell",
    "source_method": "execute",
    "target_class": "org.apache.kafka.common.TopicPartition"
  },
  {
    "source_class": "org.apache.kafka.tools.GetOffsetShell",
    "source_method": "listPartitionInfos",
    "target_class": "org.apache.kafka.server.util.TopicPartitionFilter, boolean):java.util.List<org.apache.kafka.common.TopicPartition> \t org.apache.kafka.clients.admin.Admin"
  },
  {
    "source_class": "org.apache.kafka.tools.ConsumerPerformance",
    "source_method": "consume",
    "target_class": "org.apache.kafka.tools.ConsumerPerformance.ConsumerPerfOptions, java.util.concurrent.atomic.AtomicLong, java.util.concurrent.atomic.AtomicLong, java.util.concurrent.atomic.AtomicLong, long, long, long, long, long, java.util.concurrent.atomic.AtomicLong):void \t org.apache.kafka.tools.ConsumerPerformance.ConsumerPerfOptions"
  },
  {
    "source_class": "org.apache.kafka.controller.errors.EventHandlerExceptionInfo",
    "source_method": "fromInternal",
    "target_class": "java.util.function.Supplier<java.util.OptionalInt>):org.apache.kafka.controller.errors.EventHandlerExceptionInfo \t org.apache.kafka.controller.errors.ControllerExceptions"
  },
  {
    "source_class": "org.apache.kafka.controller.OffsetControlManager",
    "source_method": "activate",
    "target_class": "org.apache.kafka.controller.metrics.QuorumControllerMetrics"
  },
  {
    "source_class": "org.apache.kafka.controller.OffsetControlManager",
    "source_method": "deactivate",
    "target_class": "org.apache.kafka.controller.metrics.QuorumControllerMetrics"
  },
  {
    "source_class": "org.apache.kafka.controller.OffsetControlManager",
    "source_method": "handleCommitBatch",
    "target_class": "org.apache.kafka.controller.metrics.QuorumControllerMetrics"
  },
  {
    "source_class": "org.apache.kafka.controller.OffsetControlManager",
    "source_method": "handleScheduleAtomicAppend",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.controller.OffsetControlManager",
    "source_method": "maybeAdvanceLastStableOffset",
    "target_class": "org.apache.kafka.timeline.SnapshotRegistry"
  },
  {
    "source_class": "org.apache.kafka.controller.ClientQuotaControlManager",
    "source_method": "alterClientQuotas",
    "target_class": "org.apache.kafka.common.quota.ClientQuotaAlteration"
  },
  {
    "source_class": "org.apache.kafka.controller.ClientQuotaControlManager",
    "source_method": "configKeysForEntityType",
    "target_class": "java.util.Map<java.lang.String,org.apache.kafka.common.config.ConfigDef.ConfigKey>):org.apache.kafka.common.requests.ApiError \t org.apache.kafka.server.config.QuotaConfigs"
  },
  {
    "source_class": "org.apache.kafka.controller.ClientQuotaControlManager",
    "source_method": "validateEntity",
    "target_class": "java.util.Map<java.lang.String,java.lang.String>):org.apache.kafka.common.requests.ApiError \t org.apache.kafka.common.quota.ClientQuotaEntity"
  },
  {
    "source_class": "org.apache.kafka.controller.DelegationTokenControlManager",
    "source_method": "getToken",
    "target_class": "org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache"
  },
  {
    "source_class": "org.apache.kafka.controller.DelegationTokenControlManager",
    "source_method": "allowedToRenew",
    "target_class": "org.apache.kafka.common.security.auth.KafkaPrincipal):boolean \t org.apache.kafka.common.security.auth.KafkaPrincipal"
  },
  {
    "source_class": "org.apache.kafka.controller.PartitionChangeBuilder",
    "source_method": "changeRecordIsNoOp",
    "target_class": "org.apache.kafka.metadata.LeaderRecoveryState"
  },
  {
    "source_class": "org.apache.kafka.controller.PartitionChangeBuilder",
    "source_method": "electPreferredLeader",
    "target_class": "org.apache.kafka.metadata.PartitionRegistration"
  },
  {
    "source_class": "org.apache.kafka.controller.PartitionChangeBuilder",
    "source_method": "electAnyLeader",
    "target_class": "org.apache.kafka.metadata.PartitionRegistration"
  },
  {
    "source_class": "org.apache.kafka.controller.PartitionChangeBuilder",
    "source_method": "completeReassignmentIfNeeded",
    "target_class": "org.apache.kafka.controller.PartitionReassignmentReplicas"
  },
  {
    "source_class": "org.apache.kafka.controller.ConfigurationControlManager",
    "source_method": "getParts",
    "target_class": "java.lang.String, org.apache.kafka.common.config.ConfigResource):java.util.List<java.lang.String> \t org.apache.kafka.common.config.ConfigResource"
  },
  {
    "source_class": "org.apache.kafka.controller.ConfigurationControlManager",
    "source_method": "getConfigs",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ConfigurationControlManager",
    "source_method": "getTopicConfig",
    "target_class": "java.lang.String):java.lang.String \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ConfigurationControlManager",
    "source_method": "describeConfigs",
    "target_class": "java.util.Map<org.apache.kafka.common.config.ConfigResource,java.util.Collection<java.lang.String>>):java.util.Map<org.apache.kafka.common.config.ConfigResource,org.apache.kafka.controller.ResultOrError<java.util.Map<java.lang.String,java.lang.String>>> \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ConfigurationControlManager",
    "source_method": "deleteTopicConfigs",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ConfigurationControlManager",
    "source_method": "clusterConfig",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ConfigurationControlManager",
    "source_method": "currentControllerConfig",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ScramControlManager",
    "source_method": "finishUpsertion",
    "target_class": "org.apache.kafka.controller.ScramCredentialUpsertion):org.apache.kafka.common.requests.ApiError \t org.apache.kafka.common.security.scram.internals.ScramMechanism"
  },
  {
    "source_class": "org.apache.kafka.controller.ScramControlManager",
    "source_method": "validateUpsertion",
    "target_class": "org.apache.kafka.clients.admin.ScramMechanism"
  },
  {
    "source_class": "org.apache.kafka.controller.ScramControlManager",
    "source_method": "validateScramUsernameAndMechanism",
    "target_class": "org.apache.kafka.clients.admin.ScramMechanism):org.apache.kafka.common.requests.ApiError \t org.apache.kafka.clients.admin.ScramMechanism"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokerHeartbeatManager.BrokerHeartbeatStateList",
    "source_method": "first",
    "target_class": "org.apache.kafka.controller.BrokerHeartbeatManager.BrokerHeartbeatState"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokerHeartbeatManager.BrokerHeartbeatStateList",
    "source_method": "add",
    "target_class": "org.apache.kafka.controller.BrokerHeartbeatManager.BrokerHeartbeatState"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokerHeartbeatManager.BrokerHeartbeatStateList",
    "source_method": "remove",
    "target_class": "org.apache.kafka.controller.BrokerHeartbeatManager.BrokerHeartbeatState"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokerHeartbeatManager",
    "source_method": "controlledShutdownOffset",
    "target_class": "org.apache.kafka.controller.BrokerHeartbeatManager.BrokerHeartbeatState"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokerHeartbeatManager",
    "source_method": "untrack",
    "target_class": "org.apache.kafka.controller.BrokerHeartbeatManager.BrokerHeartbeatState"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokerHeartbeatManager",
    "source_method": "hasValidSession",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokerHeartbeatManager",
    "source_method": "register",
    "target_class": "boolean):void \t org.apache.kafka.controller.BrokerHeartbeatManager.BrokerHeartbeatState"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokerHeartbeatManager",
    "source_method": "touch",
    "target_class": "boolean, long):void \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokerHeartbeatManager",
    "source_method": "lowestActiveOffset",
    "target_class": "org.apache.kafka.controller.BrokerHeartbeatManager.BrokerHeartbeatState"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokerHeartbeatManager",
    "source_method": "nextCheckTimeNs",
    "target_class": "org.apache.kafka.controller.BrokerHeartbeatManager.BrokerHeartbeatStateList"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokerHeartbeatManager",
    "source_method": "findOneStaleBroker",
    "target_class": "org.apache.kafka.controller.BrokerHeartbeatManager.BrokerHeartbeatState"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokerHeartbeatManager",
    "source_method": "currentBrokerState",
    "target_class": "org.apache.kafka.controller.BrokerHeartbeatManager.BrokerHeartbeatState"
  },
  {
    "source_class": "org.apache.kafka.controller.ProducerIdControlManager",
    "source_method": "nextProducerBlock",
    "target_class": "org.apache.kafka.timeline.TimelineObject"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumFeatures",
    "source_method": "reasonNotSupported",
    "target_class": "java.lang.String, org.apache.kafka.metadata.VersionRange):java.util.Optional<java.lang.String> \t org.apache.kafka.metadata.VersionRange"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumFeatures",
    "source_method": "defaultFeatureMap",
    "target_class": "org.apache.kafka.server.common.MetadataVersion"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumFeatures",
    "source_method": "reasonAllControllersZkMigrationNotReady",
    "target_class": "java.util.Map<java.lang.Integer,org.apache.kafka.metadata.ControllerRegistration>):java.util.Optional<java.lang.String> \t org.apache.kafka.metadata.ControllerRegistration"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager.Builder",
    "source_method": "build",
    "target_class": "org.apache.kafka.controller.ConfigurationControlManager"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager.TopicControlInfo",
    "source_method": "numPartitions",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "updateReassigningTopicsIfNeeded",
    "target_class": "int, boolean, boolean):void \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "buildPartitionRegistration",
    "target_class": "java.util.List<java.lang.Integer>):org.apache.kafka.metadata.PartitionRegistration \t org.apache.kafka.metadata.PartitionRegistration.Builder"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "validateNewTopicNames",
    "target_class": "org.apache.kafka.controller.CreatableTopicCollection, java.util.Map<java.lang.String,? extends java.util.Set<java.lang.String>>):void \t org.apache.kafka.common.internals.Topic"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "findTopicIds",
    "target_class": "java.util.Collection<java.lang.String>):java.util.Map<java.lang.String,org.apache.kafka.controller.ResultOrError<org.apache.kafka.common.Uuid>> \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "findAllTopicIds",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "findTopicNames",
    "target_class": "java.util.Collection<org.apache.kafka.common.Uuid>):java.util.Map<org.apache.kafka.common.Uuid,org.apache.kafka.controller.ResultOrError<java.lang.String>> \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "getPartition",
    "target_class": "int):org.apache.kafka.metadata.PartitionRegistration \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "getTopic",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "getTopicId",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "isElrEnabled",
    "target_class": "org.apache.kafka.controller.FeatureControlManager"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "handleBrokerUncleanShutdown",
    "target_class": "java.util.List<org.apache.kafka.server.common.ApiMessageAndVersion>):void \t org.apache.kafka.controller.FeatureControlManager"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "electionType",
    "target_class": "org.apache.kafka.common.ElectionType"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "electLeader",
    "target_class": "int, org.apache.kafka.common.ElectionType, java.util.List<org.apache.kafka.server.common.ApiMessageAndVersion>):org.apache.kafka.common.requests.ApiError \t org.apache.kafka.controller.ClusterControlManager"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "unregisterBroker",
    "target_class": "org.apache.kafka.controller.ClusterControlManager"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "arePartitionLeadersImbalanced",
    "target_class": "org.apache.kafka.timeline.TimelineHashSet"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "validateManualPartitionAssignment",
    "target_class": "java.util.OptionalInt):void \t org.apache.kafka.metadata.placement.PartitionAssignment"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "cancelPartitionReassignment",
    "target_class": "org.apache.kafka.server.common.TopicIdPartition, org.apache.kafka.metadata.PartitionRegistration):java.util.Optional<org.apache.kafka.server.common.ApiMessageAndVersion> \t org.apache.kafka.server.common.TopicIdPartition"
  },
  {
    "source_class": "org.apache.kafka.controller.ReplicationControlManager",
    "source_method": "updatePartitionDirectories",
    "target_class": "int, org.apache.kafka.common.Uuid[], org.apache.kafka.common.Uuid[]):void \t org.apache.kafka.timeline.TimelineHashSet"
  },
  {
    "source_class": "org.apache.kafka.controller.ControllerRequestContext",
    "source_method": "requestTimeoutMsToDeadlineNs",
    "target_class": "int):java.util.OptionalLong \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokersToIsrs",
    "source_method": "removeTopicEntryForBroker",
    "target_class": "int):void \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokersToIsrs",
    "source_method": "add",
    "target_class": "org.apache.kafka.common.Uuid, int, boolean):void \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokersToIsrs",
    "source_method": "change",
    "target_class": "org.apache.kafka.common.Uuid, int, boolean, boolean):void \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokersToIsrs",
    "source_method": "remove",
    "target_class": "org.apache.kafka.common.Uuid, int, boolean):void \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokersToIsrs",
    "source_method": "iterator",
    "target_class": "boolean):org.apache.kafka.controller.BrokersToIsrs.PartitionsOnReplicaIterator \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ClusterControlManager",
    "source_method": "activate",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ClusterControlManager",
    "source_method": "fencedBrokerIds",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ClusterControlManager",
    "source_method": "zkRegistrationAllowed",
    "target_class": "org.apache.kafka.controller.FeatureControlManager"
  },
  {
    "source_class": "org.apache.kafka.controller.ClusterControlManager",
    "source_method": "registerBrokerRecordOffset",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ClusterControlManager",
    "source_method": "usableBrokers",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ClusterControlManager",
    "source_method": "isUnfenced",
    "target_class": "org.apache.kafka.metadata.BrokerRegistration"
  },
  {
    "source_class": "org.apache.kafka.controller.ClusterControlManager",
    "source_method": "registration",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ClusterControlManager",
    "source_method": "inControlledShutdown",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.ClusterControlManager",
    "source_method": "isActive",
    "target_class": "org.apache.kafka.metadata.BrokerRegistration"
  },
  {
    "source_class": "org.apache.kafka.controller.ClusterControlManager",
    "source_method": "checkBrokerEpoch",
    "target_class": "long):void \t org.apache.kafka.metadata.BrokerRegistration"
  },
  {
    "source_class": "org.apache.kafka.controller.ClusterControlManager",
    "source_method": "hasOnlineDir",
    "target_class": "org.apache.kafka.common.Uuid):boolean \t org.apache.kafka.metadata.BrokerRegistration"
  },
  {
    "source_class": "org.apache.kafka.controller.ClusterControlManager",
    "source_method": "defaultDir",
    "target_class": "org.apache.kafka.metadata.BrokerRegistration"
  },
  {
    "source_class": "org.apache.kafka.controller.ClusterControlManager",
    "source_method": "brokerSupportedFeatures",
    "target_class": "org.apache.kafka.metadata.BrokerRegistration"
  },
  {
    "source_class": "org.apache.kafka.controller.ClusterControlManager",
    "source_method": "controllerSupportedFeatures",
    "target_class": "org.apache.kafka.controller.FeatureControlManager"
  },
  {
    "source_class": "org.apache.kafka.controller.PartitionReassignmentReplicas",
    "source_method": "isReassignmentInProgress",
    "target_class": "org.apache.kafka.metadata.Replicas"
  },
  {
    "source_class": "org.apache.kafka.controller.FeatureControlManager",
    "source_method": "metadataVersion",
    "target_class": "org.apache.kafka.timeline.TimelineObject"
  },
  {
    "source_class": "org.apache.kafka.controller.FeatureControlManager",
    "source_method": "zkMigrationState",
    "target_class": "org.apache.kafka.timeline.TimelineObject"
  },
  {
    "source_class": "org.apache.kafka.controller.FeatureControlManager",
    "source_method": "finalizedFeatures",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.FeatureControlManager",
    "source_method": "inPreMigrationMode",
    "target_class": "org.apache.kafka.timeline.TimelineObject"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokersToElrs",
    "source_method": "removeTopicEntryForBroker",
    "target_class": "int):void \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokersToElrs",
    "source_method": "add",
    "target_class": "org.apache.kafka.common.Uuid, int):void \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokersToElrs",
    "source_method": "remove",
    "target_class": "org.apache.kafka.common.Uuid, int):void \t org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.BrokersToElrs",
    "source_method": "partitionsWithBrokerInElr",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.metrics.QuorumControllerMetrics",
    "source_method": "getMetricName",
    "target_class": "java.lang.String):org.apache.kafka.controller.metrics.MetricName \t org.apache.kafka.server.metrics.KafkaYammerMetrics"
  },
  {
    "source_class": "org.apache.kafka.controller.metrics.ControllerMetricsChanges",
    "source_method": "handleBrokerChange",
    "target_class": "org.apache.kafka.metadata.BrokerRegistration):void \t org.apache.kafka.metadata.BrokerRegistration"
  },
  {
    "source_class": "org.apache.kafka.controller.metrics.ControllerMetricsChanges",
    "source_method": "handleDeletedTopic",
    "target_class": "org.apache.kafka.image.TopicImage"
  },
  {
    "source_class": "org.apache.kafka.controller.metrics.ControllerMetricsChanges",
    "source_method": "handleTopicChange",
    "target_class": "org.apache.kafka.image.TopicDelta):void \t org.apache.kafka.image.TopicDelta"
  },
  {
    "source_class": "org.apache.kafka.controller.metrics.ControllerMetricsChanges",
    "source_method": "handlePartitionChange",
    "target_class": "org.apache.kafka.metadata.PartitionRegistration):void \t org.apache.kafka.metadata.PartitionRegistration"
  },
  {
    "source_class": "org.apache.kafka.controller.metrics.ControllerMetricsChanges",
    "source_method": "apply",
    "target_class": "org.apache.kafka.controller.metrics.ControllerMetadataMetrics"
  },
  {
    "source_class": "org.apache.kafka.controller.metrics.ControllerMetadataMetrics",
    "source_method": "getMetricName",
    "target_class": "java.lang.String):org.apache.kafka.controller.metrics.MetricName \t org.apache.kafka.server.metrics.KafkaYammerMetrics"
  },
  {
    "source_class": "org.apache.kafka.controller.metrics.ControllerMetadataMetricsPublisher",
    "source_method": "publishDelta",
    "target_class": "org.apache.kafka.image.MetadataDelta"
  },
  {
    "source_class": "org.apache.kafka.controller.metrics.ControllerMetadataMetricsPublisher",
    "source_method": "publishSnapshot",
    "target_class": "org.apache.kafka.image.MetadataImage"
  },
  {
    "source_class": "org.apache.kafka.controller.ActivationRecordsGenerator",
    "source_method": "recordsForEmptyLog",
    "target_class": "long, boolean, org.apache.kafka.metadata.bootstrap.BootstrapMetadata, org.apache.kafka.server.common.MetadataVersion):org.apache.kafka.controller.ControllerResult<java.lang.Void> \t org.apache.kafka.controller.ControllerResult"
  },
  {
    "source_class": "org.apache.kafka.controller.ActivationRecordsGenerator",
    "source_method": "recordsForNonEmptyLog",
    "target_class": "long, boolean, org.apache.kafka.controller.FeatureControlManager, org.apache.kafka.server.common.MetadataVersion):org.apache.kafka.controller.ControllerResult<java.lang.Void> \t org.apache.kafka.controller.FeatureControlManager"
  },
  {
    "source_class": "org.apache.kafka.controller.AclControlManager",
    "source_method": "createAcls",
    "target_class": "org.apache.kafka.metadata.authorizer.StandardAclWithId"
  },
  {
    "source_class": "org.apache.kafka.controller.AclControlManager",
    "source_method": "newAclId",
    "target_class": "org.apache.kafka.timeline.TimelineHashMap"
  },
  {
    "source_class": "org.apache.kafka.controller.AclControlManager",
    "source_method": "validateNewAcl",
    "target_class": "org.apache.kafka.common.acl.AccessControlEntry"
  },
  {
    "source_class": "org.apache.kafka.controller.AclControlManager",
    "source_method": "validateFilter",
    "target_class": "org.apache.kafka.common.acl.AccessControlEntryFilter"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumController",
    "source_method": "latestController",
    "target_class": "org.apache.kafka.raft.RaftClient"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumController",
    "source_method": "updateEventStartMetricsAndGetTime",
    "target_class": "org.apache.kafka.controller.metrics.QuorumControllerMetrics"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumController",
    "source_method": "appendReadEvent",
    "target_class": "java.util.OptionalLong, java.util.function.Supplier<T>):java.util.concurrent.CompletableFuture<T> \t org.apache.kafka.controller.QuorumController.ControllerReadEvent"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumController",
    "source_method": "appendRecords",
    "target_class": "org.apache.kafka.controller.ControllerResult<?>, int, java.util.function.Function<java.util.List<org.apache.kafka.server.common.ApiMessageAndVersion>,java.lang.Long>):long \t org.apache.kafka.controller.ControllerResult"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumController",
    "source_method": "appendWriteEvent",
    "target_class": "java.util.OptionalLong, org.apache.kafka.controller.QuorumController.ControllerWriteOperation<T>, java.util.EnumSet<org.apache.kafka.controller.QuorumController.ControllerOperationFlag>):java.util.concurrent.CompletableFuture<T> \t org.apache.kafka.controller.QuorumController.ControllerWriteEvent"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumController",
    "source_method": "claim",
    "target_class": "long):void \t org.apache.kafka.controller.ClusterControlManager"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumController",
    "source_method": "renounce",
    "target_class": "org.apache.kafka.raft.RaftClient"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumController",
    "source_method": "cancelMaybeFenceReplicas",
    "target_class": "org.apache.kafka.queue.KafkaEventQueue"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumController",
    "source_method": "cancelMaybeBalancePartitionLeaders",
    "target_class": "org.apache.kafka.queue.KafkaEventQueue"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumController",
    "source_method": "cancelNextWriteNoOpRecord",
    "target_class": "org.apache.kafka.queue.KafkaEventQueue"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumController",
    "source_method": "handleFeatureControlChange",
    "target_class": "org.apache.kafka.controller.FeatureControlManager"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumController",
    "source_method": "setNewNextWriteOffset",
    "target_class": "org.apache.kafka.controller.OffsetControlManager"
  },
  {
    "source_class": "org.apache.kafka.controller.QuorumController",
    "source_method": "handleUncleanBrokerShutdown",
    "target_class": "java.util.List<org.apache.kafka.server.common.ApiMessageAndVersion>):void \t org.apache.kafka.controller.ReplicationControlManager"
  },
  {
    "source_class": "org.apache.kafka.metadata.bootstrap.BootstrapMetadata",
    "source_method": "fromVersion",
    "target_class": "java.lang.String):org.apache.kafka.metadata.bootstrap.BootstrapMetadata \t org.apache.kafka.server.common.MetadataVersion"
  },
  {
    "source_class": "org.apache.kafka.metadata.bootstrap.BootstrapMetadata",
    "source_method": "fromRecords",
    "target_class": "java.lang.String):org.apache.kafka.metadata.bootstrap.BootstrapMetadata \t org.apache.kafka.server.common.ApiMessageAndVersion"
  },
  {
    "source_class": "org.apache.kafka.metadata.bootstrap.BootstrapMetadata",
    "source_method": "recordToMetadataVersion",
    "target_class": "org.apache.kafka.server.common.MetadataVersion"
  },
  {
    "source_class": "org.apache.kafka.metadata.bootstrap.BootstrapMetadata",
    "source_method": "copyWithOnlyVersion",
    "target_class": "org.apache.kafka.server.common.ApiMessageAndVersion"
  },
  {
    "source_class": "org.apache.kafka.metadata.bootstrap.BootstrapDirectory",
    "source_method": "readFromBinaryFile",
    "target_class": "org.apache.kafka.metadata.util.BatchFileReader"
  },
  {
    "source_class": "org.apache.kafka.metadata.bootstrap.BootstrapDirectory",
    "source_method": "writeBinaryFile",
    "target_class": "org.apache.kafka.metadata.bootstrap.BootstrapMetadata"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationDriver.PollTimeSupplier",
    "source_method": "nextPollTimeMs",
    "target_class": "org.apache.kafka.common.utils.ExponentialBackoff"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationDriver",
    "source_method": "imageDoesNotContainAllBrokers",
    "target_class": "java.util.Set<java.lang.Integer>):boolean \t org.apache.kafka.image.MetadataImage"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationZkWriter",
    "source_method": "handleTopicsSnapshot",
    "target_class": "org.apache.kafka.metadata.migration.KRaftMigrationOperationConsumer):void \t org.apache.kafka.metadata.migration.MigrationClient"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationZkWriter",
    "source_method": "handleTopicsDelta",
    "target_class": "org.apache.kafka.image.TopicsImage, org.apache.kafka.image.TopicsDelta, org.apache.kafka.metadata.migration.KRaftMigrationOperationConsumer):void \t org.apache.kafka.metadata.migration.MigrationClient"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationZkWriter",
    "source_method": "brokerOrTopicOpType",
    "target_class": "java.lang.String, java.lang.String):java.lang.String \t org.apache.kafka.common.config.ConfigResource"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationZkWriter",
    "source_method": "handleConfigsSnapshot",
    "target_class": "org.apache.kafka.metadata.migration.KRaftMigrationOperationConsumer):void \t org.apache.kafka.metadata.migration.MigrationClient"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationZkWriter",
    "source_method": "getScramCredentialStringsForUser",
    "target_class": "java.lang.String):java.util.Map<java.lang.String,java.lang.String> \t org.apache.kafka.metadata.ScramCredentialData"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationZkWriter",
    "source_method": "handleProducerIdSnapshot",
    "target_class": "org.apache.kafka.metadata.migration.KRaftMigrationOperationConsumer):void \t org.apache.kafka.image.ProducerIdsImage"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationZkWriter",
    "source_method": "handleConfigsDelta",
    "target_class": "org.apache.kafka.image.ConfigurationsDelta, org.apache.kafka.metadata.migration.KRaftMigrationOperationConsumer):void \t org.apache.kafka.metadata.migration.MigrationClient"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationZkWriter",
    "source_method": "handleClientQuotasDelta",
    "target_class": "org.apache.kafka.image.MetadataDelta, org.apache.kafka.metadata.migration.KRaftMigrationOperationConsumer):void \t org.apache.kafka.common.quota.ClientQuotaEntity"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationZkWriter",
    "source_method": "handleProducerIdDelta",
    "target_class": "org.apache.kafka.metadata.migration.KRaftMigrationOperationConsumer):void \t org.apache.kafka.image.ProducerIdsDelta"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationZkWriter",
    "source_method": "resourcePatternFromAcl",
    "target_class": "org.apache.kafka.metadata.authorizer.StandardAcl"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationZkWriter",
    "source_method": "handleAclsSnapshot",
    "target_class": "org.apache.kafka.metadata.migration.KRaftMigrationOperationConsumer):void \t org.apache.kafka.metadata.authorizer.StandardAcl"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationZkWriter",
    "source_method": "handleAclsDelta",
    "target_class": "org.apache.kafka.image.AclsImage, org.apache.kafka.image.AclsDelta, org.apache.kafka.metadata.migration.KRaftMigrationOperationConsumer):void \t org.apache.kafka.metadata.authorizer.StandardAcl"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationZkWriter",
    "source_method": "handleDelegationTokenDelta",
    "target_class": "org.apache.kafka.image.DelegationTokenDelta, org.apache.kafka.metadata.migration.KRaftMigrationOperationConsumer):void \t org.apache.kafka.metadata.migration.MigrationClient"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.KRaftMigrationZkWriter",
    "source_method": "handleDelegationTokenSnapshot",
    "target_class": "org.apache.kafka.metadata.migration.KRaftMigrationOperationConsumer):void \t org.apache.kafka.metadata.migration.MigrationClient"
  },
  {
    "source_class": "org.apache.kafka.metadata.migration.MigrationManifest.Builder",
    "source_method": "build",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.metadata.BrokerRegistration",
    "source_method": "fromRecord",
    "target_class": "org.apache.kafka.common.security.auth.SecurityProtocol"
  },
  {
    "source_class": "org.apache.kafka.metadata.BrokerRegistration",
    "source_method": "node",
    "target_class": "org.apache.kafka.common.Endpoint"
  },
  {
    "source_class": "org.apache.kafka.metadata.DelegationTokenData",
    "source_method": "fromRecord",
    "target_class": "org.apache.kafka.common.utils.SecurityUtils"
  },
  {
    "source_class": "org.apache.kafka.metadata.PartitionRegistration",
    "source_method": "electionWasClean",
    "target_class": "int[]):boolean \t org.apache.kafka.metadata.Replicas"
  },
  {
    "source_class": "org.apache.kafka.metadata.PartitionRegistration",
    "source_method": "migratingDirectories",
    "target_class": "org.apache.kafka.common.Uuid"
  },
  {
    "source_class": "org.apache.kafka.metadata.ListenerInfo",
    "source_method": "create",
    "target_class": "java.util.List<org.apache.kafka.common.Endpoint>):org.apache.kafka.metadata.ListenerInfo \t org.apache.kafka.common.Endpoint"
  },
  {
    "source_class": "org.apache.kafka.metadata.placement.StripedReplicaPlacer.Rack",
    "source_method": "initialize",
    "target_class": "org.apache.kafka.metadata.placement.StripedReplicaPlacer.BrokerList"
  },
  {
    "source_class": "org.apache.kafka.metadata.placement.StripedReplicaPlacer.Rack",
    "source_method": "shuffle",
    "target_class": "org.apache.kafka.metadata.placement.StripedReplicaPlacer.BrokerList"
  },
  {
    "source_class": "org.apache.kafka.metadata.placement.StripedReplicaPlacer.Rack",
    "source_method": "nextUnfenced",
    "target_class": "org.apache.kafka.metadata.placement.StripedReplicaPlacer.BrokerList"
  },
  {
    "source_class": "org.apache.kafka.metadata.placement.StripedReplicaPlacer.Rack",
    "source_method": "next",
    "target_class": "org.apache.kafka.metadata.placement.StripedReplicaPlacer.BrokerList"
  },
  {
    "source_class": "org.apache.kafka.metadata.placement.StripedReplicaPlacer.RackList",
    "source_method": "place",
    "target_class": "org.apache.kafka.metadata.placement.StripedReplicaPlacer.Rack"
  },
  {
    "source_class": "org.apache.kafka.metadata.util.BatchFileWriter",
    "source_method": "append",
    "target_class": "org.apache.kafka.raft.internals.BatchAccumulator"
  },
  {
    "source_class": "org.apache.kafka.metadata.util.BatchFileWriter",
    "source_method": "append",
    "target_class": "org.apache.kafka.raft.internals.BatchAccumulator"
  },
  {
    "source_class": "org.apache.kafka.metadata.util.BatchFileWriter",
    "source_method": "open",
    "target_class": "org.apache.kafka.raft.internals.BatchAccumulator"
  },
  {
    "source_class": "org.apache.kafka.metadata.util.BatchFileReader.Builder",
    "source_method": "build",
    "target_class": "org.apache.kafka.common.record.FileRecords"
  },
  {
    "source_class": "org.apache.kafka.metadata.util.BatchFileReader",
    "source_method": "nextDataBatch",
    "target_class": "org.apache.kafka.common.record.FileLogInputStream.FileChannelRecordBatch"
  },
  {
    "source_class": "org.apache.kafka.metadata.util.SnapshotFileReader",
    "source_method": "beginShutdown",
    "target_class": "org.apache.kafka.queue.KafkaEventQueue"
  },
  {
    "source_class": "org.apache.kafka.metadata.KafkaConfigSchema",
    "source_method": "isSplittable",
    "target_class": "java.lang.String):boolean \t org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.metadata.KafkaConfigSchema",
    "source_method": "isSensitive",
    "target_class": "java.lang.String):boolean \t org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.metadata.KafkaConfigSchema",
    "source_method": "getDefault",
    "target_class": "java.lang.String):java.lang.String \t org.apache.kafka.common.config.ConfigDef"
  },
  {
    "source_class": "org.apache.kafka.metadata.KafkaConfigSchema",
    "source_method": "resolveEffectiveTopicConfig",
    "target_class": "java.util.Map<java.lang.String,?>, java.util.Map<java.lang.String,?>, java.util.Map<java.lang.String,?>, java.util.Map<java.lang.String,?>):org.apache.kafka.clients.admin.ConfigEntry \t org.apache.kafka.common.config.ConfigDef.ConfigKey"
  },
  {
    "source_class": "org.apache.kafka.metadata.ControllerRegistration",
    "source_method": "node",
    "target_class": "org.apache.kafka.common.Endpoint"
  },
  {
    "source_class": "org.apache.kafka.metadata.properties.PropertiesUtils",
    "source_method": "writePropertiesFile",
    "target_class": "java.lang.String, boolean):void \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.metadata.properties.MetaPropertiesEnsemble.Copier",
    "source_method": "generateValidDirectoryId",
    "target_class": "org.apache.kafka.common.Uuid"
  },
  {
    "source_class": "org.apache.kafka.metadata.properties.MetaPropertiesEnsemble.Copier",
    "source_method": "writeLogDirChanges",
    "target_class": "org.apache.kafka.metadata.properties.MetaPropertiesEnsemble"
  },
  {
    "source_class": "org.apache.kafka.metadata.properties.MetaPropertiesEnsemble",
    "source_method": "verify",
    "target_class": "java.util.OptionalInt, java.util.EnumSet<org.apache.kafka.metadata.properties.MetaPropertiesEnsemble.VerificationFlag>):void \t org.apache.kafka.metadata.properties.MetaProperties"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.AclCache",
    "source_method": "acls",
    "target_class": "org.apache.kafka.metadata.authorizer.StandardAcl"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.AclCache",
    "source_method": "addAcl",
    "target_class": "org.apache.kafka.metadata.authorizer.StandardAcl):org.apache.kafka.metadata.authorizer.AclCache \t org.apache.kafka.server.immutable.ImmutableNavigableSet"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.AclCache",
    "source_method": "removeAcl",
    "target_class": "org.apache.kafka.server.immutable.ImmutableNavigableSet"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizerData",
    "source_method": "createLogger",
    "target_class": "org.apache.kafka.common.utils.LogContext"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizerData",
    "source_method": "copyWithNewLoadingComplete",
    "target_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizerData.DefaultRule"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizerData",
    "source_method": "defaultResult",
    "target_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizerData.DefaultRule"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizerData",
    "source_method": "aclCount",
    "target_class": "org.apache.kafka.metadata.authorizer.AclCache"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizerData",
    "source_method": "buildAuditMessage",
    "target_class": "org.apache.kafka.server.authorizer.AuthorizableRequestContext, org.apache.kafka.server.authorizer.Action, org.apache.kafka.metadata.authorizer.StandardAuthorizerData.MatchingRule):java.lang.String \t org.apache.kafka.server.authorizer.Action"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizerData",
    "source_method": "appendResourcePattern",
    "target_class": "java.lang.StringBuilder):void \t org.apache.kafka.common.resource.ResourcePattern"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizerData",
    "source_method": "findAclRule",
    "target_class": "java.lang.String, org.apache.kafka.server.authorizer.Action):org.apache.kafka.metadata.authorizer.StandardAuthorizerData.MatchingRule \t org.apache.kafka.metadata.authorizer.StandardAuthorizerData.MatchingRuleBuilder"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizerData",
    "source_method": "checkSection",
    "target_class": "org.apache.kafka.server.authorizer.Action, org.apache.kafka.metadata.authorizer.StandardAcl, java.util.Set<org.apache.kafka.common.security.auth.KafkaPrincipal>, java.lang.String, org.apache.kafka.metadata.authorizer.StandardAuthorizerData.MatchingRuleBuilder):void \t org.apache.kafka.metadata.authorizer.StandardAcl"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizerData",
    "source_method": "baseKafkaPrincipal",
    "target_class": "org.apache.kafka.common.security.auth.KafkaPrincipal"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizerData",
    "source_method": "matchingPrincipals",
    "target_class": "org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizerData",
    "source_method": "findResult",
    "target_class": "java.util.Set<org.apache.kafka.common.security.auth.KafkaPrincipal>, java.lang.String, org.apache.kafka.metadata.authorizer.StandardAcl):org.apache.kafka.server.authorizer.AuthorizationResult \t org.apache.kafka.metadata.authorizer.StandardAcl"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.StandardAuthorizer",
    "source_method": "getConfiguredSuperUsers",
    "target_class": "org.apache.kafka.common.utils.SecurityUtils"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.StandardAcl",
    "source_method": "fromRecord",
    "target_class": "org.apache.kafka.common.acl.AclOperation"
  },
  {
    "source_class": "org.apache.kafka.metadata.authorizer.StandardAcl",
    "source_method": "fromAclBinding",
    "target_class": "org.apache.kafka.common.acl.AccessControlEntry"
  },
  {
    "source_class": "org.apache.kafka.image.ConfigurationsDelta",
    "source_method": "finishSnapshot",
    "target_class": "org.apache.kafka.image.ConfigurationsImage"
  },
  {
    "source_class": "org.apache.kafka.image.ConfigurationsDelta",
    "source_method": "replay",
    "target_class": "java.lang.String):void \t org.apache.kafka.image.ConfigurationDelta"
  },
  {
    "source_class": "org.apache.kafka.image.ConfigurationsDelta",
    "source_method": "apply",
    "target_class": "org.apache.kafka.image.ConfigurationImage"
  },
  {
    "source_class": "org.apache.kafka.image.ClientQuotaDelta",
    "source_method": "finishSnapshot",
    "target_class": "org.apache.kafka.image.ClientQuotaImage"
  },
  {
    "source_class": "org.apache.kafka.image.ClientQuotaDelta",
    "source_method": "apply",
    "target_class": "org.apache.kafka.image.ClientQuotaImage"
  },
  {
    "source_class": "org.apache.kafka.image.TopicsDelta",
    "source_method": "getOrCreateTopicDelta",
    "target_class": "org.apache.kafka.image.TopicsImage"
  },
  {
    "source_class": "org.apache.kafka.image.TopicsDelta",
    "source_method": "finishSnapshot",
    "target_class": "org.apache.kafka.image.TopicsImage"
  },
  {
    "source_class": "org.apache.kafka.image.TopicsDelta",
    "source_method": "apply",
    "target_class": "org.apache.kafka.image.TopicImage"
  },
  {
    "source_class": "org.apache.kafka.image.TopicsDelta",
    "source_method": "topicWasDeleted",
    "target_class": "org.apache.kafka.image.TopicImage"
  },
  {
    "source_class": "org.apache.kafka.image.TopicsDelta",
    "source_method": "localChanges",
    "target_class": "org.apache.kafka.image.TopicImage"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "getOrCreateFeaturesDelta",
    "target_class": "org.apache.kafka.image.MetadataImage"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "getOrCreateClusterDelta",
    "target_class": "org.apache.kafka.image.MetadataImage"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "getOrCreateTopicsDelta",
    "target_class": "org.apache.kafka.image.MetadataImage"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "getOrCreateConfigsDelta",
    "target_class": "org.apache.kafka.image.MetadataImage"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "getOrCreateClientQuotasDelta",
    "target_class": "org.apache.kafka.image.MetadataImage"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "getOrCreateProducerIdsDelta",
    "target_class": "org.apache.kafka.image.MetadataImage"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "getOrCreateAclsDelta",
    "target_class": "org.apache.kafka.image.MetadataImage"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "getOrCreateScramDelta",
    "target_class": "org.apache.kafka.image.MetadataImage"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "getOrCreateDelegationTokenDelta",
    "target_class": "org.apache.kafka.image.MetadataImage"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "metadataVersionChanged",
    "target_class": "org.apache.kafka.image.FeaturesDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.ClusterDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.ClusterDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.TopicsDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.TopicsDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.TopicsDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.ClusterDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.ClusterDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.TopicsDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.ScramDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.ClusterDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.ClientQuotasDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.ProducerIdsDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.AclsDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.AclsDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.ScramDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.FeaturesDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.image.ClusterDelta"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataDelta",
    "source_method": "apply",
    "target_class": "org.apache.kafka.image.ClientQuotasDelta"
  },
  {
    "source_class": "org.apache.kafka.image.FeaturesDelta",
    "source_method": "finishSnapshot",
    "target_class": "org.apache.kafka.image.FeaturesImage"
  },
  {
    "source_class": "org.apache.kafka.image.FeaturesDelta",
    "source_method": "apply",
    "target_class": "org.apache.kafka.image.FeaturesImage"
  },
  {
    "source_class": "org.apache.kafka.image.publisher.metrics.SnapshotEmitterMetrics",
    "source_method": "latestSnapshotGeneratedAgeMs",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.image.publisher.metrics.SnapshotEmitterMetrics",
    "source_method": "getMetricName",
    "target_class": "java.lang.String):org.apache.kafka.image.publisher.metrics.MetricName \t org.apache.kafka.server.metrics.KafkaYammerMetrics"
  },
  {
    "source_class": "org.apache.kafka.image.FeaturesImage",
    "source_method": "handleFeatureLevelNotSupported",
    "target_class": "org.apache.kafka.image.writer.ImageWriterOptions"
  },
  {
    "source_class": "org.apache.kafka.image.DelegationTokenDelta",
    "source_method": "finishSnapshot",
    "target_class": "org.apache.kafka.image.DelegationTokenImage"
  },
  {
    "source_class": "org.apache.kafka.image.DelegationTokenDelta",
    "source_method": "apply",
    "target_class": "org.apache.kafka.image.DelegationTokenImage"
  },
  {
    "source_class": "org.apache.kafka.image.TopicsImage",
    "source_method": "including",
    "target_class": "org.apache.kafka.image.TopicImage"
  },
  {
    "source_class": "org.apache.kafka.image.TopicsImage",
    "source_method": "getPartition",
    "target_class": "int):org.apache.kafka.metadata.PartitionRegistration \t org.apache.kafka.image.TopicImage"
  },
  {
    "source_class": "org.apache.kafka.image.TopicsImage",
    "source_method": "topicNameToIdView",
    "target_class": "org.apache.kafka.image.TopicImage"
  },
  {
    "source_class": "org.apache.kafka.image.TopicsImage",
    "source_method": "topicIdToNameView",
    "target_class": "org.apache.kafka.image.TopicImage"
  },
  {
    "source_class": "org.apache.kafka.image.ClientQuotaImage",
    "source_method": "entityToData",
    "target_class": "org.apache.kafka.common.quota.ClientQuotaEntity"
  },
  {
    "source_class": "org.apache.kafka.image.loader.MetadataLoader",
    "source_method": "scheduleInitializeNewPublishers",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.image.loader.MetadataLoader",
    "source_method": "loadSnapshot",
    "target_class": "org.apache.kafka.snapshot.SnapshotReader<org.apache.kafka.server.common.ApiMessageAndVersion>):org.apache.kafka.image.loader.SnapshotManifest \t org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.image.loader.MetadataLoader",
    "source_method": "installPublishers",
    "target_class": "extends org.apache.kafka.image.publisher.MetadataPublisher>):java.util.concurrent.CompletableFuture<java.lang.Void> \t org.apache.kafka.image.publisher.MetadataPublisher"
  },
  {
    "source_class": "org.apache.kafka.image.loader.MetadataLoader",
    "source_method": "removeAndClosePublisher",
    "target_class": "org.apache.kafka.image.publisher.MetadataPublisher"
  },
  {
    "source_class": "org.apache.kafka.image.loader.MetadataLoader",
    "source_method": "closePublisher",
    "target_class": "org.apache.kafka.server.fault.FaultHandler"
  },
  {
    "source_class": "org.apache.kafka.image.loader.metrics.MetadataLoaderMetrics",
    "source_method": "getMetricName",
    "target_class": "java.lang.String):org.apache.kafka.image.loader.metrics.MetricName \t org.apache.kafka.server.metrics.KafkaYammerMetrics"
  },
  {
    "source_class": "org.apache.kafka.image.loader.MetadataBatchLoader",
    "source_method": "applyDeltaAndUpdate",
    "target_class": "org.apache.kafka.image.loader.LogDeltaManifest):void \t org.apache.kafka.server.fault.FaultHandler"
  },
  {
    "source_class": "org.apache.kafka.image.ScramImage",
    "source_method": "write",
    "target_class": "org.apache.kafka.image.writer.ImageWriterOptions):void \t org.apache.kafka.image.writer.ImageWriterOptions"
  },
  {
    "source_class": "org.apache.kafka.image.ClientQuotasDelta",
    "source_method": "finishSnapshot",
    "target_class": "org.apache.kafka.image.ClientQuotasImage"
  },
  {
    "source_class": "org.apache.kafka.image.ClientQuotasDelta",
    "source_method": "apply",
    "target_class": "org.apache.kafka.image.ClientQuotasImage"
  },
  {
    "source_class": "org.apache.kafka.image.ClusterImage",
    "source_method": "write",
    "target_class": "org.apache.kafka.image.writer.ImageWriterOptions):void \t org.apache.kafka.image.writer.ImageWriterOptions"
  },
  {
    "source_class": "org.apache.kafka.image.node.MetadataNode",
    "source_method": "print",
    "target_class": "org.apache.kafka.image.node.printer.MetadataNodePrinter"
  },
  {
    "source_class": "org.apache.kafka.image.node.MetadataNode",
    "source_method": "stringify",
    "target_class": "org.apache.kafka.image.node.printer.NodeStringifier"
  },
  {
    "source_class": "org.apache.kafka.image.node.ConfigurationsImageNode",
    "source_method": "resourceFromName",
    "target_class": "org.apache.kafka.common.config.ConfigResource.Type"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataImage",
    "source_method": "isEmpty",
    "target_class": "org.apache.kafka.image.ClientQuotasImage"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataImage",
    "source_method": "highestOffsetAndEpoch",
    "target_class": "org.apache.kafka.image.MetadataProvenance"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataImage",
    "source_method": "offset",
    "target_class": "org.apache.kafka.image.MetadataProvenance"
  },
  {
    "source_class": "org.apache.kafka.image.MetadataImage",
    "source_method": "write",
    "target_class": "org.apache.kafka.image.writer.ImageWriterOptions):void \t org.apache.kafka.image.ClientQuotasImage"
  },
  {
    "source_class": "org.apache.kafka.image.AclsImage",
    "source_method": "write",
    "target_class": "org.apache.kafka.image.writer.ImageWriterOptions):void \t org.apache.kafka.metadata.authorizer.StandardAclWithId"
  },
  {
    "source_class": "org.apache.kafka.image.ClusterDelta",
    "source_method": "broker",
    "target_class": "org.apache.kafka.image.ClusterImage"
  },
  {
    "source_class": "org.apache.kafka.image.ClusterDelta",
    "source_method": "finishSnapshot",
    "target_class": "org.apache.kafka.image.ClusterImage"
  },
  {
    "source_class": "org.apache.kafka.image.ClusterDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.metadata.BrokerRegistration"
  },
  {
    "source_class": "org.apache.kafka.image.ClusterDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.metadata.ControllerRegistration"
  },
  {
    "source_class": "org.apache.kafka.image.ClusterDelta",
    "source_method": "getBrokerOrThrow",
    "target_class": "long, java.lang.String):org.apache.kafka.metadata.BrokerRegistration \t org.apache.kafka.metadata.BrokerRegistration"
  },
  {
    "source_class": "org.apache.kafka.image.ClusterDelta",
    "source_method": "apply",
    "target_class": "org.apache.kafka.image.ClusterImage"
  },
  {
    "source_class": "org.apache.kafka.image.ClientQuotasImage",
    "source_method": "write",
    "target_class": "org.apache.kafka.image.writer.ImageWriterOptions):void \t org.apache.kafka.image.ClientQuotaImage"
  },
  {
    "source_class": "org.apache.kafka.image.ClientQuotasImage",
    "source_method": "matches",
    "target_class": "java.util.Map<java.lang.String,java.lang.String>, java.util.Set<java.lang.String>, boolean):boolean \t org.apache.kafka.common.quota.ClientQuotaEntity"
  },
  {
    "source_class": "org.apache.kafka.image.ClientQuotasImage",
    "source_method": "toDescribeEntry",
    "target_class": "org.apache.kafka.image.ClientQuotaImage):org.apache.kafka.image.EntryData \t org.apache.kafka.common.quota.ClientQuotaEntity"
  },
  {
    "source_class": "org.apache.kafka.image.ConfigurationDelta",
    "source_method": "finishSnapshot",
    "target_class": "org.apache.kafka.image.ConfigurationImage"
  },
  {
    "source_class": "org.apache.kafka.image.ConfigurationDelta",
    "source_method": "deleteAll",
    "target_class": "org.apache.kafka.image.ConfigurationImage"
  },
  {
    "source_class": "org.apache.kafka.image.ConfigurationDelta",
    "source_method": "apply",
    "target_class": "org.apache.kafka.image.ConfigurationImage"
  },
  {
    "source_class": "org.apache.kafka.image.ScramDelta",
    "source_method": "finishSnapshot",
    "target_class": "org.apache.kafka.image.ScramImage"
  },
  {
    "source_class": "org.apache.kafka.image.ScramDelta",
    "source_method": "apply",
    "target_class": "org.apache.kafka.image.ScramImage"
  },
  {
    "source_class": "org.apache.kafka.image.ConfigurationsImage",
    "source_method": "configProperties",
    "target_class": "org.apache.kafka.image.ConfigurationImage"
  },
  {
    "source_class": "org.apache.kafka.image.ConfigurationsImage",
    "source_method": "configMapForResource",
    "target_class": "org.apache.kafka.image.ConfigurationImage"
  },
  {
    "source_class": "org.apache.kafka.image.ConfigurationsImage",
    "source_method": "write",
    "target_class": "org.apache.kafka.image.writer.ImageWriterOptions):void \t org.apache.kafka.image.ConfigurationImage"
  },
  {
    "source_class": "org.apache.kafka.image.TopicDelta",
    "source_method": "newPartitions",
    "target_class": "org.apache.kafka.image.TopicImage"
  },
  {
    "source_class": "org.apache.kafka.image.TopicDelta",
    "source_method": "apply",
    "target_class": "org.apache.kafka.image.TopicImage"
  },
  {
    "source_class": "org.apache.kafka.image.TopicDelta",
    "source_method": "hasPartitionsWithAssignmentChanges",
    "target_class": "org.apache.kafka.metadata.PartitionRegistration"
  },
  {
    "source_class": "org.apache.kafka.image.TopicDelta",
    "source_method": "localChanges",
    "target_class": "org.apache.kafka.metadata.PartitionRegistration"
  },
  {
    "source_class": "org.apache.kafka.image.AclsDelta",
    "source_method": "finishSnapshot",
    "target_class": "org.apache.kafka.image.AclsImage"
  },
  {
    "source_class": "org.apache.kafka.image.AclsDelta",
    "source_method": "replay",
    "target_class": "org.apache.kafka.metadata.authorizer.StandardAclWithId"
  },
  {
    "source_class": "org.apache.kafka.image.AclsDelta",
    "source_method": "apply",
    "target_class": "org.apache.kafka.image.AclsImage"
  },
  {
    "source_class": "org.apache.kafka.trogdor.fault.NetworkPartitionFaultWorker",
    "source_method": "runIptablesCommands",
    "target_class": "java.lang.String):void \t org.apache.kafka.trogdor.common.Platform"
  },
  {
    "source_class": "org.apache.kafka.trogdor.fault.Kibosh.KiboshControlFile",
    "source_method": "read",
    "target_class": "org.apache.kafka.trogdor.common.JsonUtil"
  },
  {
    "source_class": "org.apache.kafka.trogdor.fault.DegradedNetworkFaultWorker",
    "source_method": "devicesForSpec",
    "target_class": "org.apache.kafka.trogdor.fault.DegradedNetworkFaultSpec.NodeDegradeSpec"
  },
  {
    "source_class": "org.apache.kafka.trogdor.fault.DegradedNetworkFaultWorker",
    "source_method": "disableTrafficControl",
    "target_class": "java.lang.String):void \t org.apache.kafka.trogdor.common.Platform"
  },
  {
    "source_class": "org.apache.kafka.trogdor.workload.ProduceBenchWorker.SendRecords",
    "source_method": "recordDuration",
    "target_class": "org.apache.kafka.trogdor.workload.Histogram"
  },
  {
    "source_class": "org.apache.kafka.trogdor.workload.ConfigurableProducerWorker.SendRecords",
    "source_method": "recordDuration",
    "target_class": "org.apache.kafka.trogdor.workload.Histogram"
  },
  {
    "source_class": "org.apache.kafka.trogdor.workload.PartitionsSpec",
    "source_method": "newTopic",
    "target_class": "org.apache.kafka.clients.admin.NewTopic"
  },
  {
    "source_class": "org.apache.kafka.trogdor.workload.ConsumeBenchWorker.Prepare",
    "source_method": "populatePartitionsByTopic",
    "target_class": "java.util.Map<java.lang.String,java.util.List<org.apache.kafka.common.TopicPartition>>):java.util.Map<java.lang.String,java.util.List<org.apache.kafka.common.TopicPartition>> \t org.apache.kafka.common.PartitionInfo"
  },
  {
    "source_class": "org.apache.kafka.trogdor.workload.ConsumeBenchWorker.ThreadSafeConsumer",
    "source_method": "assign",
    "target_class": "org.apache.kafka.clients.consumer.KafkaConsumer"
  },
  {
    "source_class": "org.apache.kafka.trogdor.workload.ConsumeBenchWorker.ThreadSafeConsumer",
    "source_method": "assignedPartitions",
    "target_class": "org.apache.kafka.clients.consumer.KafkaConsumer"
  },
  {
    "source_class": "org.apache.kafka.trogdor.workload.ExternalCommandWorker",
    "source_method": "startProcess",
    "target_class": "org.apache.kafka.trogdor.workload.ExternalCommandSpec"
  },
  {
    "source_class": "org.apache.kafka.trogdor.workload.ExternalCommandWorker",
    "source_method": "readObject",
    "target_class": "org.apache.kafka.trogdor.common.JsonUtil"
  },
  {
    "source_class": "org.apache.kafka.trogdor.workload.TimestampRecordProcessor",
    "source_method": "putHistogram",
    "target_class": "org.apache.kafka.trogdor.workload.Histogram"
  },
  {
    "source_class": "org.apache.kafka.trogdor.workload.ConnectionStressWorker.Stressor",
    "source_method": "fromSpec",
    "target_class": "org.apache.kafka.trogdor.workload.ConnectionStressSpec"
  },
  {
    "source_class": "org.apache.kafka.trogdor.common.Platform.Config",
    "source_method": "parse",
    "target_class": "java.lang.String):org.apache.kafka.trogdor.common.Platform \t org.apache.kafka.common.utils.Utils"
  },
  {
    "source_class": "org.apache.kafka.trogdor.common.Node.Util",
    "source_method": "getIntConfig",
    "target_class": "java.lang.String, int):int \t org.apache.kafka.trogdor.common.Node"
  },
  {
    "source_class": "org.apache.kafka.trogdor.common.WorkerUtils",
    "source_method": "abort",
    "target_class": "java.lang.String, java.lang.Throwable, org.apache.kafka.common.internals.KafkaFutureImpl<java.lang.String>):void \t org.apache.kafka.common.internals.KafkaFutureImpl"
  },
  {
    "source_class": "org.apache.kafka.trogdor.common.WorkerUtils",
    "source_method": "createTopics",
    "target_class": "org.apache.kafka.clients.admin.Admin, java.util.Collection<org.apache.kafka.clients.admin.NewTopic>):java.util.Collection<java.lang.String> \t org.apache.kafka.clients.admin.NewTopic"
  },
  {
    "source_class": "org.apache.kafka.trogdor.common.WorkerUtils",
    "source_method": "verifyTopics",
    "target_class": "org.apache.kafka.clients.admin.Admin, java.util.Collection<java.lang.String>, java.util.Map<java.lang.String,org.apache.kafka.clients.admin.NewTopic>, int, long):void \t org.apache.kafka.clients.admin.TopicDescription"
  },
  {
    "source_class": "org.apache.kafka.trogdor.common.WorkerUtils",
    "source_method": "topicDescriptions",
    "target_class": "org.apache.kafka.clients.admin.Admin, int, long):java.util.Map<java.lang.String,org.apache.kafka.clients.admin.TopicDescription> \t org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.trogdor.common.WorkerUtils",
    "source_method": "getMatchingTopicPartitions",
    "target_class": "java.lang.String, int, int):java.util.Collection<org.apache.kafka.common.TopicPartition> \t org.apache.kafka.common.KafkaFuture"
  },
  {
    "source_class": "org.apache.kafka.trogdor.common.Topology.Util",
    "source_method": "agentNodeNames",
    "target_class": "org.apache.kafka.trogdor.common.Topology"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.CoordinatorRestResource",
    "source_method": "beginShutdown",
    "target_class": "org.apache.kafka.trogdor.rest.CoordinatorShutdownRequest"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.TaskManager.ManagedTask",
    "source_method": "startDelayMs",
    "target_class": "org.apache.kafka.trogdor.task.TaskSpec"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.Coordinator",
    "source_method": "port",
    "target_class": "org.apache.kafka.trogdor.rest.JsonRestServer"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.Coordinator",
    "source_method": "uptime",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.Coordinator",
    "source_method": "createTask",
    "target_class": "org.apache.kafka.trogdor.coordinator.TaskManager"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.Coordinator",
    "source_method": "stopTask",
    "target_class": "org.apache.kafka.trogdor.rest.StopTaskRequest"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.Coordinator",
    "source_method": "destroyTask",
    "target_class": "org.apache.kafka.trogdor.rest.DestroyTaskRequest"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.Coordinator",
    "source_method": "beginShutdown",
    "target_class": "org.apache.kafka.trogdor.rest.JsonRestServer"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.Coordinator",
    "source_method": "waitForShutdown",
    "target_class": "org.apache.kafka.trogdor.rest.JsonRestServer"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.CoordinatorClient",
    "source_method": "status",
    "target_class": "org.apache.kafka.trogdor.rest.JsonRestServer.HttpResponse"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.CoordinatorClient",
    "source_method": "uptime",
    "target_class": "org.apache.kafka.trogdor.rest.JsonRestServer.HttpResponse"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.CoordinatorClient",
    "source_method": "createTask",
    "target_class": "org.apache.kafka.trogdor.rest.JsonRestServer.HttpResponse"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.CoordinatorClient",
    "source_method": "stopTask",
    "target_class": "org.apache.kafka.trogdor.rest.JsonRestServer.HttpResponse"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.CoordinatorClient",
    "source_method": "shutdown",
    "target_class": "org.apache.kafka.trogdor.rest.JsonRestServer.HttpResponse"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.CoordinatorClient",
    "source_method": "prettyPrintTasksResponse",
    "target_class": "java.time.ZoneOffset):java.lang.String \t org.apache.kafka.trogdor.common.StringFormatter"
  },
  {
    "source_class": "org.apache.kafka.trogdor.coordinator.CoordinatorClient",
    "source_method": "prettyPrintTaskInfo",
    "target_class": "java.time.ZoneOffset):java.lang.String \t org.apache.kafka.trogdor.common.StringFormatter"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.Agent",
    "source_method": "port",
    "target_class": "org.apache.kafka.trogdor.rest.JsonRestServer"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.Agent",
    "source_method": "beginShutdown",
    "target_class": "org.apache.kafka.trogdor.agent.WorkerManager"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.Agent",
    "source_method": "waitForShutdown",
    "target_class": "org.apache.kafka.trogdor.rest.JsonRestServer"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.Agent",
    "source_method": "status",
    "target_class": "org.apache.kafka.trogdor.agent.WorkerManager"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.Agent",
    "source_method": "uptime",
    "target_class": "org.apache.kafka.common.utils.Time"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.Agent",
    "source_method": "createWorker",
    "target_class": "org.apache.kafka.trogdor.agent.WorkerManager"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.Agent",
    "source_method": "stopWorker",
    "target_class": "org.apache.kafka.trogdor.agent.WorkerManager"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.Agent",
    "source_method": "destroyWorker",
    "target_class": "org.apache.kafka.trogdor.agent.WorkerManager"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.Agent",
    "source_method": "exec",
    "target_class": "java.io.PrintStream):boolean \t org.apache.kafka.trogdor.common.Platform"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.AgentClient",
    "source_method": "status",
    "target_class": "org.apache.kafka.trogdor.rest.JsonRestServer.HttpResponse"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.AgentClient",
    "source_method": "uptime",
    "target_class": "org.apache.kafka.trogdor.rest.JsonRestServer.HttpResponse"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.AgentClient",
    "source_method": "createWorker",
    "target_class": "org.apache.kafka.trogdor.rest.JsonRestServer.HttpResponse"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.AgentClient",
    "source_method": "stopWorker",
    "target_class": "org.apache.kafka.trogdor.rest.JsonRestServer.HttpResponse"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.AgentClient",
    "source_method": "invokeShutdown",
    "target_class": "org.apache.kafka.trogdor.rest.JsonRestServer.HttpResponse"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.WorkerManager.Worker",
    "source_method": "state",
    "target_class": "org.apache.kafka.trogdor.task.AgentWorkerStatusTracker"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.WorkerManager",
    "source_method": "stopWorker",
    "target_class": "boolean):void \t org.apache.kafka.trogdor.agent.WorkerManager.ShutdownManager"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.WorkerManager",
    "source_method": "workerStates",
    "target_class": "org.apache.kafka.trogdor.agent.WorkerManager.ShutdownManager"
  },
  {
    "source_class": "org.apache.kafka.trogdor.agent.WorkerManager",
    "source_method": "beginShutdown",
    "target_class": "org.apache.kafka.trogdor.agent.WorkerManager.ShutdownManager"
  },
  {
    "source_class": "org.apache.kafka.trogdor.rest.JsonRestServer",
    "source_method": "httpRequest",
    "target_class": "java.lang.String, java.lang.String, java.lang.Object, org.apache.kafka.trogdor.rest.TypeReference<T>):org.apache.kafka.trogdor.rest.JsonRestServer.HttpResponse<T> \t org.apache.kafka.trogdor.common.JsonUtil"
  },
  {
    "source_class": "org.apache.kafka.shell.command.LsCommandHandler",
    "source_method": "printEntries",
    "target_class": "java.lang.String, java.util.OptionalInt, java.util.List<java.lang.String>):void \t org.apache.kafka.shell.command.LsCommandHandler.ColumnSchema"
  },
  {
    "source_class": "org.apache.kafka.shell.command.LsCommandHandler",
    "source_method": "calculateColumnSchema",
    "target_class": "java.util.List<java.lang.String>):org.apache.kafka.shell.command.LsCommandHandler.ColumnSchema \t org.apache.kafka.shell.command.LsCommandHandler.ColumnSchema"
  },
  {
    "source_class": "org.apache.kafka.shell.command.CommandUtils",
    "source_method": "completeCommand",
    "target_class": "java.util.List<org.apache.kafka.shell.command.Candidate>):void \t org.apache.kafka.shell.command.Commands"
  },
  {
    "source_class": "org.apache.kafka.shell.command.CommandUtils",
    "source_method": "completePath",
    "target_class": "java.lang.String, java.util.List<org.apache.kafka.shell.command.Candidate>):void \t org.apache.kafka.image.node.MetadataNode"
  },
  {
    "source_class": "org.apache.kafka.shell.MetadataShell",
    "source_method": "waitUntilCaughtUp",
    "target_class": "org.apache.kafka.image.loader.MetadataLoader"
  }
]