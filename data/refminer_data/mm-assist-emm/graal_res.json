[
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "fb3b5f597e78a4288158088b211948ca5edcd61b",
        "url": "https://github.com/oracle/graal/commit/fb3b5f597e78a4288158088b211948ca5edcd61b",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public maybeMarkUnsafeAccess(graph EncodedGraph) : void extracted from public decode(encodedGraph EncodedGraph, nodeReferences Iterable<EncodedGraph.EncodedNodeReference>) : void in class jdk.graal.compiler.nodes.GraphDecoder & moved to class jdk.graal.compiler.nodes.StructuredGraph",
            "leftSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/GraphDecoder.java",
                    "startLine": 571,
                    "endLine": 600,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "public decode(encodedGraph EncodedGraph, nodeReferences Iterable<EncodedGraph.EncodedNodeReference>) : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/GraphDecoder.java",
                    "startLine": 595,
                    "endLine": 595,
                    "startColumn": 17,
                    "endColumn": 42,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/GraphDecoder.java",
                    "startLine": 594,
                    "endLine": 596,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/GraphDecoder.java",
                    "startLine": 594,
                    "endLine": 596,
                    "startColumn": 49,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/StructuredGraph.java",
                    "startLine": 1135,
                    "endLine": 1139,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public maybeMarkUnsafeAccess(graph EncodedGraph) : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/StructuredGraph.java",
                    "startLine": 1137,
                    "endLine": 1137,
                    "startColumn": 13,
                    "endColumn": 32,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/StructuredGraph.java",
                    "startLine": 1136,
                    "endLine": 1138,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/StructuredGraph.java",
                    "startLine": 1136,
                    "endLine": 1138,
                    "startColumn": 38,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/GraphDecoder.java",
                    "startLine": 571,
                    "endLine": 598,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "public decode(encodedGraph EncodedGraph, nodeReferences Iterable<EncodedGraph.EncodedNodeReference>) : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/GraphDecoder.java",
                    "startLine": 594,
                    "endLine": 594,
                    "startColumn": 13,
                    "endColumn": 54,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "graph.maybeMarkUnsafeAccess(encodedGraph)"
                }
            ],
            "isStatic": false
        },
        "ref_id": 433,
        "extraction_results": {
            "success": true,
            "newCommitHash": "1945e880c1c304df4d3102c6a819b64173d71590",
            "newBranchName": "extract-maybeMarkUnsafeAccess-decode-d0041dd-1"
        },
        "telemetry": {
            "id": "6c253255-fe16-4738-a116-4d62109dc570",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1760,
                "lineStart": 87,
                "lineEnd": 1846,
                "bodyLineStart": 87,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/GraphDecoder.java",
                "sourceCode": "/**\n * Decoder for {@link EncodedGraph encoded graphs} produced by {@link GraphEncoder}. Support for\n * loop explosion during decoding is built into this class, because it requires many interactions\n * with the decoding process. Subclasses can provide canonicalization and simplification of nodes\n * during decoding, as well as method inlining during decoding.\n */\npublic class GraphDecoder {\n\n    /** Decoding state maintained for each encoded graph. */\n    protected class MethodScope {\n        /** The loop that contains the call. Only non-null during method inlining. */\n        public final LoopScope callerLoopScope;\n        /**\n         * Mark for nodes that were present before the decoding of this method started. Note that\n         * nodes that were decoded after the mark can still be part of an outer method, since\n         * floating nodes of outer methods are decoded lazily.\n         */\n        public final Graph.Mark methodStartMark;\n        /** The encode graph that is decoded. */\n        public final EncodedGraph encodedGraph;\n        /** The highest node order id that a fixed node has in the EncodedGraph. */\n        public final int maxFixedNodeOrderId;\n        /**\n         * Number of bytes needed to encode an order id (order ids have a per-encoded-graph fixed\n         * size).\n         */\n        public final int orderIdWidth;\n        /** Access to the encoded graph. */\n        public final TypeReader reader;\n        /** The kind of loop explosion to be performed during decoding. */\n        public final LoopExplosionPlugin.LoopExplosionKind loopExplosion;\n\n        /** All return nodes encountered during decoding. */\n        public final List<ControlSinkNode> returnAndUnwindNodes;\n\n        /** All merges created during loop explosion. */\n        public final EconomicSet<Node> loopExplosionMerges;\n\n        /**\n         * The start of explosion, and the merge point for when irreducible loops are detected. Only\n         * used when {@link MethodScope#loopExplosion} is\n         * {@link jdk.graal.compiler.nodes.graphbuilderconf.LoopExplosionPlugin.LoopExplosionKind#MERGE_EXPLODE}.\n         */\n        public MergeNode loopExplosionHead;\n\n        /**\n         * The decoded inlining log. If this is the root method scope, it\n         * {@link StructuredGraph#setInliningLog replaces} the inlining log of the graph. Otherwise,\n         * the inlining log is {@link InliningLog#inlineByTransfer transferred} to the caller.\n         */\n        public InliningLog inliningLog;\n\n        /**\n         * The decoded optimization log. If this is the root method scope, it\n         * {@link StructuredGraph#setOptimizationLog replaces} the optimization log of the graph.\n         * Otherwise, the optimization log is {@link OptimizationLog#inline inlined} in the caller.\n         */\n        public OptimizationLog optimizationLog;\n\n        /**\n         * The stateful decoder for the {@link #inliningLog}, which is needed to map order IDs back\n         * to decoded graph nodes. The decoder is also responsible for tracking new callsites in the\n         * inlining log. {@code null} if the inlining log is not being decoded.\n         */\n        public InliningLogCodec.InliningLogDecoder inliningLogDecoder;\n\n        @SuppressWarnings(\"unchecked\")\n        protected MethodScope(LoopScope callerLoopScope, StructuredGraph graph, EncodedGraph encodedGraph, LoopExplosionPlugin.LoopExplosionKind loopExplosion) {\n            this.callerLoopScope = callerLoopScope;\n            this.methodStartMark = graph.getMark();\n            this.encodedGraph = encodedGraph;\n            this.loopExplosion = loopExplosion;\n            this.returnAndUnwindNodes = new ArrayList<>(2);\n\n            if (encodedGraph != null) {\n                reader = UnsafeArrayTypeReader.create(encodedGraph.getEncoding(), encodedGraph.getStartOffset(), architecture.supportsUnalignedMemoryAccess());\n                maxFixedNodeOrderId = reader.getUVInt();\n                GraphState.GuardsStage guardsStage = (GraphState.GuardsStage) readObject(this);\n                EnumSet<GraphState.StageFlag> stageFlags = (EnumSet<GraphState.StageFlag>) readObject(this);\n                if (callerLoopScope == null) {\n                    /**\n                     * Only propagate stage flags in non-inlining scenarios. If the caller scope has\n                     * not been guard lowered yet (or is a runtime compilation) while we inline\n                     * something that has been guard lowered already (or is an encoded hosted graph\n                     * like a snippet) do not advance stage flags or guards stage.\n                     */\n                    graph.getGraphState().setGuardsStage(guardsStage);\n                    graph.getGraphState().getStageFlags().addAll(stageFlags);\n                }\n\n                var decoderPair = InliningLogCodec.maybeDecode(graph, readObject(this));\n                if (decoderPair != null) {\n                    inliningLogDecoder = decoderPair.getLeft();\n                    inliningLog = decoderPair.getRight();\n                }\n                optimizationLog = OptimizationLogCodec.maybeDecode(graph, readObject(this));\n\n                int nodeCount = reader.getUVInt();\n                if (encodedGraph.nodeStartOffsets == null) {\n                    int[] nodeStartOffsets = new int[nodeCount];\n                    for (int i = 0; i < nodeCount; i++) {\n                        nodeStartOffsets[i] = encodedGraph.getStartOffset() - reader.getUVInt();\n                    }\n                    encodedGraph.nodeStartOffsets = nodeStartOffsets;\n                }\n\n                if (nodeCount <= GraphEncoder.MAX_INDEX_1_BYTE) {\n                    orderIdWidth = 1;\n                } else if (nodeCount <= GraphEncoder.MAX_INDEX_2_BYTES) {\n                    orderIdWidth = 2;\n                } else {\n                    orderIdWidth = 4;\n                }\n            } else {\n                reader = null;\n                maxFixedNodeOrderId = 0;\n                orderIdWidth = 0;\n            }\n\n            if (loopExplosion.useExplosion()) {\n                loopExplosionMerges = EconomicSet.create(Equivalence.IDENTITY);\n            } else {\n                loopExplosionMerges = null;\n            }\n        }\n\n        public boolean isInlinedMethod() {\n            return false;\n        }\n\n        public NodeSourcePosition getCallerNodeSourcePosition() {\n            return null;\n        }\n\n        public NodeSourcePosition getNodeSourcePosition(NodeSourcePosition position) {\n            return position;\n        }\n\n        /**\n         * Sets the {@link #inliningLog} and {@link #optimizationLog} as the logs of the\n         * {@link #graph} if they are non-null.\n         */\n        public void replaceLogsForDecodedGraph() {\n            if (inliningLog != null) {\n                graph.setInliningLog(inliningLog);\n            }\n            if (optimizationLog != null) {\n                graph.setOptimizationLog(optimizationLog);\n            }\n        }\n    }\n\n    /**\n     * Marker to distinguish the reasons for the creation of a loop scope during partial evaluation.\n     */\n    public enum LoopScopeTrigger {\n        /**\n         * Start loop scope: creation triggered manually at the beginning of partial evaluation.\n         */\n        START,\n\n        /**\n         * Loop scope created for the next iteration of a loop if unrolling is enabled in the loop\n         * explosion mode. See\n         * {@link jdk.graal.compiler.nodes.graphbuilderconf.LoopExplosionPlugin.LoopExplosionKind#unrollLoops()}\n         * for details. Loop unrolling will merge loop end nodes for each iteration of the original\n         * loop.\n         */\n        LOOP_BEGIN_UNROLLING,\n\n        /**\n         * Loop scope created for the next iteration of a loop along a particular loop end node if\n         * {@link jdk.graal.compiler.nodes.graphbuilderconf.LoopExplosionPlugin.LoopExplosionKind#duplicateLoopEnds()}\n         * is enabled and loops are exploded. This means for every loop end we duplicate the next\n         * loop iteration of the original loop.\n         */\n        LOOP_END_DUPLICATION,\n\n        /**\n         * Loop scope created for a loop exit node if\n         * {@link jdk.graal.compiler.nodes.graphbuilderconf.LoopExplosionPlugin.LoopExplosionKind#duplicateLoopExits()}\n         * is enabled, i.e., code after a loop exit is duplicated per loop exit node.\n         *\n         * Special case nested loops: For compilation units with nested loops where inner loops\n         * continue loops at a level n -1 the partial evaluation algorithm will merge outer loops to\n         * avoid loop explosion along loop end nodes (which would be the same as\n         * {@link #LOOP_END_DUPLICATION}.\n         */\n        LOOP_EXIT_DUPLICATION\n    }\n\n    /** Decoding state maintained for each loop in the encoded graph. */\n    protected static class LoopScope {\n        public final MethodScope methodScope;\n        public final LoopScope outer;\n        public final int loopDepth;\n        public final int loopIteration;\n\n        /**\n         * Creation trigger of this particular loop scope, i.e., the reason it was created.\n         */\n        final LoopScopeTrigger trigger;\n        /**\n         * Upcoming, not yet processed, loop iterations created in the context of code duplication\n         * along loop exits. Only used when {@link MethodScope#loopExplosion} has\n         * {@link jdk.graal.compiler.nodes.graphbuilderconf.LoopExplosionPlugin.LoopExplosionKind#duplicateLoopExits()}\n         * enabled.\n         */\n        public Deque<LoopScope> nextIterationFromLoopExitDuplication;\n        /**\n         * Same as {@link #nextIterationFromLoopExitDuplication} except that upcoming iterations\n         * have been created because the duplication of loop ends\n         * {@link jdk.graal.compiler.nodes.graphbuilderconf.LoopExplosionPlugin.LoopExplosionKind#duplicateLoopEnds()}\n         * is enabled.\n         */\n        public Deque<LoopScope> nextIterationFromLoopEndDuplication;\n        /**\n         * Same as {@link #nextIterationFromLoopExitDuplication} except that upcoming iterations\n         * have been created because the unrolling of a loop with constant iteration count\n         * {@link jdk.graal.compiler.nodes.graphbuilderconf.LoopExplosionPlugin.LoopExplosionKind#unrollLoops()}\n         * is enabled.\n         */\n        public Deque<LoopScope> nextIterationsFromUnrolling;\n        /**\n         * Information about already processed loop iterations for state merging during loop\n         * explosion. Only used when {@link MethodScope#loopExplosion} is\n         * {@link jdk.graal.compiler.nodes.graphbuilderconf.LoopExplosionPlugin.LoopExplosionKind#MERGE_EXPLODE}.\n         */\n        public final EconomicMap<LoopExplosionState, LoopExplosionState> iterationStates;\n        public final int loopBeginOrderId;\n        /**\n         * The worklist of fixed nodes to process. Since we already the correct processing order\n         * from the orderId, we just set the orderId bit in the bitset when a node is ready for\n         * processing. The lowest set bit is the next node to process.\n         */\n        public final BitSet nodesToProcess;\n        /** Nodes that have been created, indexed by the orderId. */\n        public final Node[] createdNodes;\n        /**\n         * Nodes that have been created in outer loop scopes and existed before starting to process\n         * this loop, indexed by the orderId. Only used when {@link MethodScope#loopExplosion} is\n         * not\n         * {@link jdk.graal.compiler.nodes.graphbuilderconf.LoopExplosionPlugin.LoopExplosionKind#NONE}.\n         */\n        public final Node[] initialCreatedNodes;\n\n        protected LoopScope(MethodScope methodScope) {\n            this.methodScope = methodScope;\n            this.outer = null;\n            this.nextIterationFromLoopExitDuplication = methodScope.loopExplosion.duplicateLoopExits() || methodScope.loopExplosion.mergeLoops() ? new ArrayDeque<>(2) : null;\n            this.nextIterationFromLoopEndDuplication = methodScope.loopExplosion.duplicateLoopEnds() ? new ArrayDeque<>(2) : null;\n            this.nextIterationsFromUnrolling = methodScope.loopExplosion.unrollLoops() ? new ArrayDeque<>(2) : null;\n            this.loopDepth = 0;\n            this.loopIteration = 0;\n            this.iterationStates = null;\n            this.loopBeginOrderId = -1;\n            int nodeCount = methodScope.encodedGraph.nodeStartOffsets.length;\n            this.nodesToProcess = new BitSet(methodScope.maxFixedNodeOrderId);\n            this.createdNodes = new Node[nodeCount];\n            this.initialCreatedNodes = null;\n            this.trigger = LoopScopeTrigger.START;\n        }\n\n        protected LoopScope(MethodScope methodScope, LoopScope outer, int loopDepth, int loopIteration, int loopBeginOrderId, LoopScopeTrigger trigger, Node[] initialCreatedNodes, Node[] createdNodes,\n                        Deque<LoopScope> nextIterationFromLoopExitDuplication,\n                        Deque<LoopScope> nextIterationFromLoopEndDuplication,\n                        Deque<LoopScope> nextIterationsFromUnrolling, EconomicMap<LoopExplosionState, LoopExplosionState> iterationStates) {\n            this.methodScope = methodScope;\n            this.outer = outer;\n            this.loopDepth = loopDepth;\n            this.loopIteration = loopIteration;\n            this.trigger = trigger;\n            this.nextIterationFromLoopExitDuplication = nextIterationFromLoopExitDuplication;\n            this.nextIterationFromLoopEndDuplication = nextIterationFromLoopEndDuplication;\n            this.nextIterationsFromUnrolling = nextIterationsFromUnrolling;\n            this.iterationStates = iterationStates;\n            this.loopBeginOrderId = loopBeginOrderId;\n            this.nodesToProcess = new BitSet(methodScope.maxFixedNodeOrderId);\n            this.initialCreatedNodes = initialCreatedNodes;\n            this.createdNodes = createdNodes;\n        }\n\n        @Override\n        public String toString() {\n            return loopDepth + \",\" + loopIteration + (loopBeginOrderId == -1 ? \"\" : \"#\" + loopBeginOrderId) + \" triggered by \" + trigger;\n        }\n\n        /**\n         * Determines if iterations generated when decoding this loop have yet to be processed.\n         *\n         * @return {@code true} if there are iterations to be decoded, {@code false} else\n         */\n        public boolean hasIterationsToProcess() {\n            return nextIterationFromLoopEndDuplication != null && !nextIterationFromLoopEndDuplication.isEmpty() ||\n                            nextIterationFromLoopExitDuplication != null && !nextIterationFromLoopExitDuplication.isEmpty() ||\n                            nextIterationsFromUnrolling != null && !nextIterationsFromUnrolling.isEmpty();\n        }\n\n        /**\n         * Return the next iteration yet to be processed that has been created in the context of\n         * decoding this loop scope.\n         *\n         * @param remove determines if the query of the next iteration should remove it from the\n         *            list of iterations to be processed\n         * @return the next {@link LoopScope} to be processed that has been created in the context\n         *         of decoding this loop scope. Note that the order is not necessarily reflecting\n         *         the number of loop iterations.\n         */\n        public LoopScope getNextIterationToProcess(boolean remove) {\n            if (nextIterationFromLoopEndDuplication != null && !nextIterationFromLoopEndDuplication.isEmpty()) {\n                return remove ? nextIterationFromLoopEndDuplication.removeFirst() : nextIterationFromLoopEndDuplication.peekFirst();\n            }\n            if (nextIterationFromLoopExitDuplication != null && !nextIterationFromLoopExitDuplication.isEmpty()) {\n                return remove ? nextIterationFromLoopExitDuplication.removeFirst() : nextIterationFromLoopExitDuplication.peekFirst();\n            }\n            if (nextIterationsFromUnrolling != null && !nextIterationsFromUnrolling.isEmpty()) {\n                return remove ? nextIterationsFromUnrolling.removeFirst() : nextIterationsFromUnrolling.peekFirst();\n            }\n            return null;\n        }\n    }\n\n    protected static class LoopExplosionState {\n        public final FrameState state;\n        public final MergeNode merge;\n        public final int hashCode;\n\n        protected LoopExplosionState(FrameState state, MergeNode merge) {\n            this.state = state;\n            this.merge = merge;\n\n            int h = 0;\n            for (ValueNode value : state.values()) {\n                if (value == null) {\n                    h = h * 31 + 1234;\n                } else {\n                    h = h * 31 + ProxyPlaceholder.unwrap(value).hashCode();\n                }\n            }\n            this.hashCode = h;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (!(obj instanceof LoopExplosionState)) {\n                return false;\n            }\n\n            FrameState otherState = ((LoopExplosionState) obj).state;\n            FrameState thisState = state;\n            assert thisState.outerFrameState() == otherState.outerFrameState() : Assertions.errorMessage(thisState, thisState.outerFrameState(), otherState, otherState.outerFrameState());\n\n            Iterator<ValueNode> thisIter = thisState.values().iterator();\n            Iterator<ValueNode> otherIter = otherState.values().iterator();\n            while (thisIter.hasNext() && otherIter.hasNext()) {\n                ValueNode thisValue = ProxyPlaceholder.unwrap(thisIter.next());\n                ValueNode otherValue = ProxyPlaceholder.unwrap(otherIter.next());\n                if (thisValue != otherValue) {\n                    return false;\n                }\n            }\n            return thisIter.hasNext() == otherIter.hasNext();\n        }\n\n        @Override\n        public int hashCode() {\n            return hashCode;\n        }\n    }\n\n    protected static class InvokableData<T extends Invokable> {\n        public final T invoke;\n        public final ResolvedJavaType contextType;\n        public final int orderId;\n        public final int stateAfterOrderId;\n        public final int nextOrderId;\n        public final int exceptionOrderId;\n        public final int exceptionStateOrderId;\n        public final int exceptionNextOrderId;\n\n        protected InvokableData(T invoke, ResolvedJavaType contextType, int orderId, int stateAfterOrderId, int nextOrderId,\n                        int exceptionOrderId, int exceptionStateOrderId, int exceptionNextOrderId) {\n            this.invoke = invoke;\n            this.contextType = contextType;\n            this.orderId = orderId;\n            this.stateAfterOrderId = stateAfterOrderId;\n            this.nextOrderId = nextOrderId;\n            this.exceptionOrderId = exceptionOrderId;\n            this.exceptionStateOrderId = exceptionStateOrderId;\n            this.exceptionNextOrderId = exceptionNextOrderId;\n        }\n    }\n\n    /**\n     * Additional information encoded for {@link Invoke} nodes to allow method inlining without\n     * decoding the frame state and successors beforehand.\n     */\n    protected static class InvokeData extends InvokableData<Invoke> {\n        static InvokeData createFrom(InvokableData<? extends Invoke> from, int callTargetOrderId, boolean intrinsifiedMethodHandle) {\n            return new InvokeData(from.invoke, from.contextType, from.orderId, callTargetOrderId, intrinsifiedMethodHandle,\n                            from.stateAfterOrderId, from.nextOrderId, from.exceptionOrderId, from.exceptionStateOrderId, from.exceptionNextOrderId);\n        }\n\n        public final int callTargetOrderId;\n        public final boolean intrinsifiedMethodHandle;\n\n        public JavaConstant constantReceiver;\n        public CallTargetNode callTarget;\n        public FixedWithNextNode invokePredecessor;\n\n        public InvokeData(Invoke invoke, ResolvedJavaType contextType, int invokeOrderId, int callTargetOrderId, boolean intrinsifiedMethodHandle,\n                        int stateAfterOrderId, int nextOrderId, int exceptionOrderId, int exceptionStateOrderId, int exceptionNextOrderId) {\n            super(invoke, contextType, invokeOrderId, stateAfterOrderId, nextOrderId, exceptionOrderId, exceptionStateOrderId, exceptionNextOrderId);\n            this.callTargetOrderId = callTargetOrderId;\n            this.intrinsifiedMethodHandle = intrinsifiedMethodHandle;\n        }\n    }\n\n    /**\n     * A node that is created during\n     * {@link jdk.graal.compiler.nodes.graphbuilderconf.LoopExplosionPlugin.LoopExplosionKind#MERGE_EXPLODE\n     * loop explosion} that can later be replaced by a ProxyNode if {@link LoopDetector loop\n     * detection} finds out that the value is defined in the loop, but used outside the loop.\n     */\n    @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)\n    protected static final class ProxyPlaceholder extends FloatingNode implements Canonicalizable {\n        public static final NodeClass<ProxyPlaceholder> TYPE = NodeClass.create(ProxyPlaceholder.class);\n\n        @Input ValueNode value;\n        @Input(InputType.Association) Node proxyPoint;\n\n        public ProxyPlaceholder(ValueNode value, MergeNode proxyPoint) {\n            super(TYPE, value.stamp(NodeView.DEFAULT));\n            this.value = value;\n            this.proxyPoint = proxyPoint;\n        }\n\n        void setValue(ValueNode value) {\n            updateUsages(this.value, value);\n            this.value = value;\n        }\n\n        @Override\n        public Node canonical(CanonicalizerTool tool) {\n            if (tool.allUsagesAvailable()) {\n                /* The node is always unnecessary after graph decoding. */\n                return value;\n            } else {\n                return this;\n            }\n        }\n\n        public static ValueNode unwrap(ValueNode value) {\n            ValueNode result = value;\n            while (result instanceof ProxyPlaceholder) {\n                result = ((ProxyPlaceholder) result).value;\n            }\n            return result;\n        }\n    }\n\n    private static final TimerKey MakeSuccessorStubsTimer = DebugContext.timer(\"PartialEvaluation-MakeSuccessorStubs\").doc(\"Time spent in making successor stubs for the PE.\");\n    private static final TimerKey ReadPropertiesTimer = DebugContext.timer(\"PartialEvaluation-ReadProperties\").doc(\"Time spent in reading node properties in the PE.\");\n\n    protected final Architecture architecture;\n    /** The target graph where decoded nodes are added to. */\n    protected final StructuredGraph graph;\n    protected final OptionValues options;\n    protected final DebugContext debug;\n\n    private final EconomicMap<NodeClass<?>, ArrayDeque<Node>> reusableFloatingNodes;\n\n    public GraphDecoder(Architecture architecture, StructuredGraph graph) {\n        this.architecture = architecture;\n        this.graph = graph;\n        this.options = graph.getOptions();\n        this.debug = graph.getDebug();\n        reusableFloatingNodes = EconomicMap.create(Equivalence.IDENTITY);\n    }\n\n    public final void decode(EncodedGraph encodedGraph) {\n        decode(encodedGraph, null);\n    }\n\n    @SuppressWarnings(\"try\")\n    public final void decode(EncodedGraph encodedGraph, Iterable<EncodedGraph.EncodedNodeReference> nodeReferences) {\n        try (DebugContext.Scope scope = debug.scope(\"GraphDecoder\", graph)) {\n            recordGraphElements(encodedGraph);\n            MethodScope methodScope = new MethodScope(null, graph, encodedGraph, LoopExplosionPlugin.LoopExplosionKind.NONE);\n            LoopScope loopScope = createInitialLoopScope(methodScope, null);\n            decode(loopScope);\n            cleanupGraph(methodScope);\n            assert graph.verify();\n\n            if (nodeReferences != null) {\n                for (var nodeReference : nodeReferences) {\n                    if (nodeReference.orderId < 0) {\n                        throw GraalError.shouldNotReachHere(\"EncodeNodeReference is not in 'encoded' state\"); // ExcludeFromJacocoGeneratedReport\n                    }\n                    nodeReference.node = loopScope.createdNodes[nodeReference.orderId];\n                    if (nodeReference.node == null || !nodeReference.node.isAlive()) {\n                        throw GraalError.shouldNotReachHere(\"Could not decode the EncodedNodeReference\"); // ExcludeFromJacocoGeneratedReport\n                    }\n                    nodeReference.orderId = EncodedGraph.EncodedNodeReference.DECODED;\n                }\n            }\n\n            maybeMarkUnsafeAccess(encodedGraph);\n        } catch (Throwable ex) {\n            debug.handle(ex);\n        }\n    }\n\n    private void maybeMarkUnsafeAccess(EncodedGraph encodedGraph) {\n        if (encodedGraph.hasUnsafeAccess()) {\n            graph.markUnsafeAccess();\n        }\n    }\n\n    protected void recordGraphElements(EncodedGraph encodedGraph) {\n        List<ResolvedJavaMethod> inlinedMethods = encodedGraph.getInlinedMethods();\n        if (inlinedMethods != null) {\n            for (ResolvedJavaMethod other : inlinedMethods) {\n                graph.recordMethod(other);\n            }\n        }\n        Assumptions assumptions = graph.getAssumptions();\n        Assumptions inlinedAssumptions = encodedGraph.getAssumptions();\n        if (assumptions != null) {\n            if (inlinedAssumptions != null) {\n                assumptions.record(inlinedAssumptions);\n            }\n        } else {\n            assert inlinedAssumptions == null : String.format(\"cannot inline graph (%s) which makes assumptions into a graph (%s) that doesn't\", encodedGraph, graph);\n        }\n        if (encodedGraph.hasUnsafeAccess()) {\n            graph.markUnsafeAccess();\n        }\n    }\n\n    protected final LoopScope createInitialLoopScope(MethodScope methodScope, FixedWithNextNode startNode) {\n        LoopScope loopScope = new LoopScope(methodScope);\n        FixedNode firstNode;\n        if (startNode != null) {\n            /*\n             * The start node of a graph can be referenced as the guard for a GuardedNode. We\n             * register the previous block node, so that such guards are correctly anchored when\n             * doing inlining during graph decoding.\n             */\n            registerNode(loopScope, GraphEncoder.START_NODE_ORDER_ID, AbstractBeginNode.prevBegin(startNode), false, false);\n\n            firstNode = makeStubNode(methodScope, loopScope, GraphEncoder.FIRST_NODE_ORDER_ID);\n            startNode.setNext(firstNode);\n            loopScope.nodesToProcess.set(GraphEncoder.FIRST_NODE_ORDER_ID);\n        } else {\n            firstNode = graph.start();\n            registerNode(loopScope, GraphEncoder.START_NODE_ORDER_ID, firstNode, false, false);\n            loopScope.nodesToProcess.set(GraphEncoder.START_NODE_ORDER_ID);\n        }\n        return loopScope;\n    }\n\n    @SuppressWarnings(\"try\")\n    protected final void decode(LoopScope initialLoopScope) {\n        initialLoopScope.methodScope.replaceLogsForDecodedGraph();\n        try (InliningLog.UpdateScope updateScope = InliningLog.openDefaultUpdateScope(graph.getInliningLog())) {\n            LoopScope loopScope = initialLoopScope;\n            /* Process (inlined) methods. */\n            while (loopScope != null) {\n                MethodScope methodScope = loopScope.methodScope;\n\n                /* Process loops of method. */\n                while (loopScope != null) {\n                    /* Process nodes of loop. */\n                    while (!loopScope.nodesToProcess.isEmpty()) {\n                        loopScope = processNextNode(methodScope, loopScope);\n                        methodScope = loopScope.methodScope;\n                        /*\n                         * We can have entered a new loop, and we can have entered a new inlined\n                         * method.\n                         */\n                    }\n\n                    /* Finished with a loop. */\n                    if (loopScope.hasIterationsToProcess()) {\n                        loopScope = loopScope.getNextIterationToProcess(true);\n                    } else {\n                        propagateCreatedNodes(loopScope);\n                        loopScope = loopScope.outer;\n\n                        if (loopScope == null) {\n                            // finished all loops of a method\n                            afterMethodScope(methodScope);\n                        }\n                    }\n                }\n\n                /*\n                 * Finished with an inlined method. Perform end-of-method cleanup tasks.\n                 */\n                if (methodScope.loopExplosion.mergeLoops()) {\n                    LoopDetector loopDetector = new LoopDetector(graph, methodScope);\n                    loopDetector.run();\n                }\n                if (methodScope.isInlinedMethod()) {\n                    finishInlining(methodScope);\n                }\n\n                /* continue with the caller */\n                loopScope = methodScope.callerLoopScope;\n            }\n        }\n    }\n\n    protected void afterMethodScope(@SuppressWarnings(\"unused\") MethodScope methodScope) {\n    }\n\n    protected void finishInlining(@SuppressWarnings(\"unused\") MethodScope inlineScope) {\n    }\n\n    private static void propagateCreatedNodes(LoopScope loopScope) {\n        if (loopScope.outer == null || loopScope.createdNodes != loopScope.outer.createdNodes) {\n            return;\n        }\n\n        /* Register nodes that were created while decoding the loop to the outside scope. */\n        for (int i = 0; i < loopScope.createdNodes.length; i++) {\n            if (loopScope.outer.createdNodes[i] == null) {\n                loopScope.outer.createdNodes[i] = loopScope.createdNodes[i];\n            }\n        }\n    }\n\n    public static final boolean DUMP_DURING_FIXED_NODE_PROCESSING = false;\n\n    protected LoopScope processNextNode(MethodScope methodScope, LoopScope loopScope) {\n        int nodeOrderId = loopScope.nodesToProcess.nextSetBit(0);\n        loopScope.nodesToProcess.clear(nodeOrderId);\n\n        FixedNode node = (FixedNode) lookupNode(loopScope, nodeOrderId);\n\n        if (node.isDeleted()) {\n            return loopScope;\n        }\n        graph.beforeDecodingFields(node);\n        try {\n            if (DUMP_DURING_FIXED_NODE_PROCESSING) {\n                if (node != null) {\n                    try {\n                        debug.dump(DebugContext.DETAILED_LEVEL, graph, \"Before processing node %s\", node);\n                    } catch (Throwable t) {\n                        // swallow here, dumping uninitialized nodes can cause problems\n                    }\n                }\n            }\n            if ((node instanceof MergeNode ||\n                            (node instanceof LoopBeginNode && (methodScope.loopExplosion.unrollLoops() &&\n                                            !methodScope.loopExplosion.mergeLoops()))) &&\n                            ((AbstractMergeNode) node).forwardEndCount() == 1) {\n                /*\n                 * In case node is a loop begin and we are unrolling loops we remove the loop begin\n                 * since the loop will be gone after PE.\n                 */\n                AbstractMergeNode merge = (AbstractMergeNode) node;\n                EndNode singleEnd = merge.forwardEndAt(0);\n\n                /* Nodes that would use this merge as the guard need to use the previous block. */\n                registerNode(loopScope, nodeOrderId, AbstractBeginNode.prevBegin(singleEnd), true, false);\n\n                FixedNode next = makeStubNode(methodScope, loopScope, nodeOrderId + GraphEncoder.BEGIN_NEXT_ORDER_ID_OFFSET);\n                singleEnd.replaceAtPredecessor(next);\n\n                merge.safeDelete();\n                singleEnd.safeDelete();\n                return loopScope;\n            }\n\n            LoopScope successorAddScope = loopScope;\n            boolean updatePredecessors = true;\n            if (node instanceof LoopExitNode) {\n                if (methodScope.loopExplosion.duplicateLoopExits() || (methodScope.loopExplosion.mergeLoops() && loopScope.loopDepth > 1)) {\n                    /*\n                     * We do not want to merge loop exits of inner loops. Instead, we want to keep\n                     * exploding the outer loop separately for every loop exit and then merge the\n                     * outer loop. Therefore, we create a new LoopScope of the outer loop for every\n                     * loop exit of the inner loop.\n                     */\n                    LoopScope outerScope = loopScope.outer;\n                    int nextIterationNumber = outerScope.nextIterationFromLoopExitDuplication.isEmpty() ? outerScope.loopIteration + 1\n                                    : outerScope.nextIterationFromLoopExitDuplication.getLast().loopIteration + 1;\n                    Node[] initialCreatedNodes = outerScope.initialCreatedNodes == null ? null\n                                    : (methodScope.loopExplosion.mergeLoops()\n                                                    ? Arrays.copyOf(outerScope.initialCreatedNodes, outerScope.initialCreatedNodes.length)\n                                                    : outerScope.initialCreatedNodes);\n                    successorAddScope = new LoopScope(methodScope, outerScope.outer, outerScope.loopDepth, nextIterationNumber, outerScope.loopBeginOrderId, LoopScopeTrigger.LOOP_EXIT_DUPLICATION,\n                                    initialCreatedNodes,\n                                    Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),\n                                    outerScope.nextIterationFromLoopExitDuplication,\n                                    outerScope.nextIterationFromLoopEndDuplication,\n                                    outerScope.nextIterationsFromUnrolling,\n                                    outerScope.iterationStates);\n                    checkLoopExplosionIteration(methodScope, successorAddScope);\n\n                    /*\n                     * Nodes that are still unprocessed in the outer scope might be merge nodes that\n                     * are also reachable from the new exploded scope. Clearing them ensures that we\n                     * do not merge, but instead keep exploding.\n                     */\n                    for (int id = outerScope.nodesToProcess.nextSetBit(0); id >= 0; id = outerScope.nodesToProcess.nextSetBit(id + 1)) {\n                        successorAddScope.createdNodes[id] = null;\n                    }\n\n                    outerScope.nextIterationFromLoopExitDuplication.addLast(successorAddScope);\n                } else {\n                    successorAddScope = loopScope.outer;\n                }\n                updatePredecessors = methodScope.loopExplosion.isNoExplosion();\n            }\n\n            methodScope.reader.setByteIndex(methodScope.encodedGraph.nodeStartOffsets[nodeOrderId]);\n            int typeId = methodScope.reader.getUVInt();\n            assert node.getNodeClass() == methodScope.encodedGraph.getNodeClasses()[typeId] : Assertions.errorMessage(node, methodScope.encodedGraph.getNodeClasses()[typeId]);\n            makeFixedNodeInputs(methodScope, loopScope, node);\n            readProperties(methodScope, node);\n\n            if ((node instanceof IfNode || node instanceof SwitchNode) &&\n                            earlyCanonicalization(methodScope, successorAddScope, nodeOrderId, node)) {\n                return loopScope;\n            }\n\n            makeSuccessorStubs(methodScope, successorAddScope, node, updatePredecessors);\n\n            LoopScope resultScope = loopScope;\n            if (node instanceof LoopBeginNode) {\n                if (methodScope.loopExplosion.useExplosion()) {\n                    handleLoopExplosionBegin(methodScope, loopScope, (LoopBeginNode) node);\n                }\n\n            } else if (node instanceof LoopExitNode) {\n                if (methodScope.loopExplosion.useExplosion()) {\n                    handleLoopExplosionProxyNodes(methodScope, loopScope, successorAddScope, (LoopExitNode) node, nodeOrderId);\n                } else {\n                    handleProxyNodes(methodScope, loopScope, (LoopExitNode) node);\n                }\n\n            } else if (node instanceof MergeNode) {\n                handleMergeNode(((MergeNode) node));\n            } else if (node instanceof AbstractEndNode) {\n                LoopScope phiInputScope = loopScope;\n                LoopScope phiNodeScope = loopScope;\n                int mergeOrderId = readOrderId(methodScope);\n\n                boolean requiresMergeOfOuterLoop = methodScope.loopExplosion.unrollLoops() &&\n                                methodScope.loopExplosion.duplicateLoopExits() &&\n                                (!methodScope.loopExplosion.duplicateLoopEnds()) &&\n                                (!methodScope.loopExplosion.mergeLoops()) &&\n                                node instanceof LoopEndNode &&\n                                loopScope.trigger == LoopScopeTrigger.LOOP_EXIT_DUPLICATION;\n\n                if (requiresMergeOfOuterLoop) {\n                    EndNode replacementNode = graph.add(new EndNode());\n                    node.replaceAtPredecessor(replacementNode);\n                    node.safeDelete();\n                    node = replacementNode;\n                    /*\n                     * We are in a loop exit duplicated loop scope and see a loop end node, this can\n                     * only happen if we have a loop end to an outer loop. When duplicating over\n                     * loop exits we have to merge outer loops for nested inner loops.\n                     *\n                     * Therefore, we create a correct outer loop iteration and check if there is\n                     * already one, if not we create it else we re-use it.\n                     */\n                    if (loopScope.nextIterationsFromUnrolling.isEmpty()) {\n                        // create it\n                        int nextIterationNumber = loopScope.nextIterationsFromUnrolling.isEmpty() ? loopScope.loopIteration + 1 : loopScope.nextIterationsFromUnrolling.getLast().loopIteration + 1;\n                        LoopScope outerLoopMergeScope = new LoopScope(methodScope, loopScope.outer, loopScope.loopDepth, nextIterationNumber, loopScope.loopBeginOrderId,\n                                        LoopScopeTrigger.LOOP_BEGIN_UNROLLING,\n                                        methodScope.loopExplosion.mergeLoops() ? Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length) : loopScope.initialCreatedNodes,\n                                        Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),\n                                        loopScope.nextIterationFromLoopExitDuplication,\n                                        loopScope.nextIterationFromLoopEndDuplication,\n                                        loopScope.nextIterationsFromUnrolling,\n                                        loopScope.iterationStates);\n                        checkLoopExplosionIteration(methodScope, outerLoopMergeScope);\n                        loopScope.nextIterationsFromUnrolling.addLast(outerLoopMergeScope);\n                        registerNode(outerLoopMergeScope, loopScope.loopBeginOrderId, null, true, true);\n                        makeStubNode(methodScope, outerLoopMergeScope, loopScope.loopBeginOrderId);\n                        phiNodeScope = outerLoopMergeScope;\n                    } else {\n                        // re-use it\n                        phiNodeScope = loopScope.nextIterationsFromUnrolling.getLast();\n                    }\n\n                } else if (methodScope.loopExplosion.useExplosion() && node instanceof LoopEndNode) {\n                    EndNode replacementNode = graph.add(new EndNode());\n                    node.replaceAtPredecessor(replacementNode);\n                    node.safeDelete();\n                    node = replacementNode;\n                    LoopScopeTrigger trigger = handleLoopExplosionEnd(methodScope, loopScope);\n                    Deque<LoopScope> phiScope = loopScope.nextIterationsFromUnrolling;\n                    if (trigger == LoopScopeTrigger.LOOP_END_DUPLICATION) {\n                        phiScope = loopScope.nextIterationFromLoopEndDuplication;\n                    }\n                    phiNodeScope = phiScope.getLast();\n                }\n                AbstractMergeNode merge = (AbstractMergeNode) lookupNode(phiNodeScope, mergeOrderId);\n                if (merge == null) {\n                    merge = (AbstractMergeNode) makeStubNode(methodScope, phiNodeScope, mergeOrderId);\n                    if (merge instanceof LoopBeginNode) {\n                        /*\n                         * In contrast to the LoopScopeTrigger.START created at the beginning of\n                         * every PE, we see a real loop here and create the first real loop scope\n                         * associated with a loop.\n                         *\n                         * Creation of a loop scope if we reach a loop begin node. We process a loop\n                         * begin node (always before encountering a loop end associated with the\n                         * loop begin) and simply create a normal loop scope. This does not imply an\n                         * advanced unrolling strategy (however it can later if we see duplicate\n                         * over loop end or exits). Therefore, we still use the start marker here,\n                         * we could also use the unrolling marker.\n                         *\n                         * If we unroll loops we will later remove the loop begin node and replace\n                         * it with its forward end (since we do not need to create a loop begin node\n                         * if we unroll the entire loop and it has a constant trip count).\n                         */\n                        assert phiNodeScope == phiInputScope : phiInputScope + \"!=\" + phiInputScope;\n                        assert phiNodeScope == loopScope : phiNodeScope + \"!=\" + loopScope;\n                        resultScope = new LoopScope(methodScope, loopScope, loopScope.loopDepth + 1, 0, mergeOrderId, LoopScopeTrigger.START,\n                                        methodScope.loopExplosion.useExplosion() ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : null,\n                                        methodScope.loopExplosion.useExplosion() ? Arrays.copyOf(loopScope.createdNodes, loopScope.createdNodes.length) : loopScope.createdNodes, //\n                                        methodScope.loopExplosion.duplicateLoopExits() || methodScope.loopExplosion.mergeLoops() ? new ArrayDeque<>(2) : null,\n                                        methodScope.loopExplosion.duplicateLoopEnds() ? new ArrayDeque<>(2) : null,\n                                        methodScope.loopExplosion.unrollLoops() ? new ArrayDeque<>(2) : null, //\n                                        methodScope.loopExplosion.mergeLoops() ? EconomicMap.create(Equivalence.DEFAULT) : null);\n                        phiInputScope = resultScope;\n                        phiNodeScope = resultScope;\n\n                        if (methodScope.loopExplosion.useExplosion()) {\n                            registerNode(loopScope, mergeOrderId, null, true, true);\n                        }\n                        loopScope.nodesToProcess.clear(mergeOrderId);\n                        resultScope.nodesToProcess.set(mergeOrderId);\n                    }\n                }\n                handlePhiFunctions(methodScope, phiInputScope, phiNodeScope, (AbstractEndNode) node, merge);\n            } else if (node instanceof Invoke) {\n                InvokeData invokeData = readInvokeData(methodScope, nodeOrderId, (Invoke) node);\n                resultScope = handleInvoke(methodScope, loopScope, invokeData);\n            } else if (node instanceof MethodHandleWithExceptionNode methodHandle) {\n                InvokableData<MethodHandleWithExceptionNode> invokableData = readInvokableData(methodScope, nodeOrderId, methodHandle);\n                resultScope = handleMethodHandle(methodScope, loopScope, invokableData);\n            } else if (node instanceof ReturnNode || node instanceof UnwindNode) {\n                methodScope.returnAndUnwindNodes.add((ControlSinkNode) node);\n            } else {\n                handleFixedNode(methodScope, loopScope, nodeOrderId, node);\n            }\n            if (DUMP_DURING_FIXED_NODE_PROCESSING) {\n                if (node != null) {\n                    try {\n                        debug.dump(DebugContext.DETAILED_LEVEL, graph, \"After processing node %s\", node);\n                    } catch (Throwable t) {\n                        // swallow here, dumping uninitialized nodes can cause problems\n                    }\n                }\n            }\n            return resultScope;\n        } finally {\n            graph.afterDecodingFields(node);\n        }\n    }\n\n    protected LoopScope handleMethodHandle(MethodScope methodScope, LoopScope loopScope, InvokableData<MethodHandleWithExceptionNode> invokableData) {\n        appendInvokable(methodScope, loopScope, invokableData);\n        return loopScope;\n    }\n\n    protected <T extends Invokable> InvokableData<T> readInvokableData(MethodScope methodScope, int orderId, T node) {\n        ResolvedJavaType contextType = (ResolvedJavaType) readObject(methodScope);\n        int stateAfterOrderId = readOrderId(methodScope);\n        int nextOrderId = readOrderId(methodScope);\n\n        if (node instanceof WithExceptionNode) {\n            int exceptionOrderId = readOrderId(methodScope);\n            int exceptionStateOrderId = readOrderId(methodScope);\n            int exceptionNextOrderId = readOrderId(methodScope);\n            return new InvokableData<>(node, contextType, orderId, stateAfterOrderId, nextOrderId, exceptionOrderId, exceptionStateOrderId, exceptionNextOrderId);\n        } else {\n            return new InvokableData<>(node, contextType, orderId, stateAfterOrderId, nextOrderId, -1, -1, -1);\n        }\n    }\n\n    protected InvokeData readInvokeData(MethodScope methodScope, int invokeOrderId, Invoke invoke) {\n        int callTargetOrderId = readOrderId(methodScope);\n        InvokableData<Invoke> invokableData = readInvokableData(methodScope, invokeOrderId, invoke);\n        return InvokeData.createFrom(invokableData, callTargetOrderId, false);\n    }\n\n    /**\n     * {@link Invoke} nodes do not have the {@link CallTargetNode}, {@link FrameState}, and\n     * successors encoded. Instead, this information is provided separately to allow method inlining\n     * without decoding and adding them to the graph upfront. For non-inlined methods, this method\n     * restores the normal state. Subclasses can override it to perform method inlining.\n     *\n     * The return value is the loop scope where decoding should continue. When method inlining\n     * should be performed, the returned loop scope must be a new loop scope for the inlined method.\n     * Without inlining, the original loop scope must be returned.\n     */\n    protected LoopScope handleInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData) {\n        assert invokeData.invoke.callTarget() == null : \"callTarget edge is ignored during decoding of Invoke\";\n        CallTargetNode callTarget = (CallTargetNode) ensureNodeCreated(methodScope, loopScope, invokeData.callTargetOrderId);\n        appendInvoke(methodScope, loopScope, invokeData, callTarget);\n        return loopScope;\n    }\n\n    protected void appendInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData, CallTargetNode callTarget) {\n        if (invokeData.invoke instanceof InvokeWithExceptionNode) {\n            ((InvokeWithExceptionNode) invokeData.invoke).setCallTarget(callTarget);\n        } else {\n            ((InvokeNode) invokeData.invoke).setCallTarget(callTarget);\n        }\n        appendInvokable(methodScope, loopScope, invokeData);\n    }\n\n    private <T extends Invokable & StateSplit> void appendInvokable(MethodScope methodScope, LoopScope loopScope, InvokableData<T> invokeData) {\n        if (invokeData.invoke.stateAfter() == null) {\n            invokeData.invoke.setStateAfter((FrameState) ensureNodeCreated(methodScope, loopScope, invokeData.stateAfterOrderId));\n        }\n        assert !(invokeData.invoke instanceof Invoke inv && inv.stateDuring() != null) : \"stateDuring is not used in high tier graphs\";\n\n        FixedNode next = makeStubNode(methodScope, loopScope, invokeData.nextOrderId);\n        if (invokeData.invoke instanceof WithExceptionNode withException) {\n            withException.setNext((AbstractBeginNode) next);\n            withException.setExceptionEdge((AbstractBeginNode) makeStubNode(methodScope, loopScope, invokeData.exceptionOrderId));\n        } else {\n            ((FixedWithNextNode) invokeData.invoke).setNext(next);\n        }\n    }\n\n    /**\n     * Hook for subclasses to perform simplifications for a non-loop-header control flow merge.\n     *\n     * @param merge The control flow merge.\n     */\n    protected void handleMergeNode(MergeNode merge) {\n    }\n\n    protected void handleLoopExplosionBegin(MethodScope methodScope, LoopScope loopScope, LoopBeginNode loopBegin) {\n        checkLoopExplosionIteration(methodScope, loopScope);\n\n        List<EndNode> predecessors = loopBegin.forwardEnds().snapshot();\n        FixedNode successor = loopBegin.next();\n        FrameState frameState = loopBegin.stateAfter();\n\n        if (methodScope.loopExplosion.mergeLoops()) {\n            LoopExplosionState queryState = new LoopExplosionState(frameState, null);\n            LoopExplosionState existingState = loopScope.iterationStates.get(queryState);\n            if (existingState != null) {\n                loopBegin.replaceAtUsagesAndDelete(existingState.merge);\n                successor.safeDelete();\n                for (EndNode predecessor : predecessors) {\n                    existingState.merge.addForwardEnd(predecessor);\n                }\n                return;\n            }\n        }\n\n        MergeNode merge = graph.add(new MergeNode());\n        methodScope.loopExplosionMerges.add(merge);\n\n        if (methodScope.loopExplosion.mergeLoops()) {\n            if (loopScope.iterationStates.size() == 0 && loopScope.loopDepth == 1) {\n                if (methodScope.loopExplosionHead != null) {\n                    throw new PermanentBailoutException(\"Graal implementation restriction: Method with %s loop explosion must not have more than one top-level loop\",\n                                    LoopExplosionPlugin.LoopExplosionKind.MERGE_EXPLODE);\n                }\n                methodScope.loopExplosionHead = merge;\n            }\n\n            /*\n             * Proxy generation and merge explosion: When doing merge-explode PE loops are detected\n             * after partial evaluation in a dedicated steps. Therefore, we create merge nodes\n             * instead of loop begins and loop exits and later replace them with the detected loop\n             * begin and loop exit nodes.\n             *\n             * However, in order to create the correct loop proxies, all values alive at a merge\n             * created for a loop begin/loop exit replacement merge, we create so called proxy\n             * placeholder nodes. These nodes are attached to a merge and proxy the corresponding\n             * node. Later, when we replace a merge with a loop exit, we visit all live nodes at\n             * that loop exit and replace the proxy placeholders with real value proxy nodes.\n             *\n             * Since we cannot (this would explode immediately) proxy all nodes for every merge\n             * during explosion, we only create nodes at the loop explosion begins for nodes that\n             * are alive at the framestate of the respective loop begin. This is fine as long as all\n             * values proxied out of a loop are alive at the loop header. However, this is not true\n             * for all values (imagine do-while loops). Thus, we may create, in very specific\n             * patterns, unschedulable graphs since we miss the creation of proxy nodes.\n             *\n             * There is currently no straight forward solution to this problem, thus we shift the\n             * work to the implementor side where such patterns can typically be easily fixed by\n             * creating loop phis and assigning them correctly.\n             */\n            FrameState.ValueFunction valueFunction = new FrameState.ValueFunction() {\n\n                @Override\n                public ValueNode apply(int index, ValueNode frameStateValue) {\n                    if (frameStateValue == null || frameStateValue.isConstant() || !graph.isNew(methodScope.methodStartMark, frameStateValue)) {\n                        return frameStateValue;\n\n                    } else {\n                        ProxyPlaceholder newFrameStateValue = graph.unique(new ProxyPlaceholder(frameStateValue, merge));\n\n                        /*\n                         * We do not have the orderID of the value anymore, so we need to search\n                         * through the complete list of nodes to find a match.\n                         */\n                        for (int i = 0; i < loopScope.createdNodes.length; i++) {\n                            if (loopScope.createdNodes[i] == frameStateValue) {\n                                loopScope.createdNodes[i] = newFrameStateValue;\n                            }\n                        }\n\n                        if (loopScope.initialCreatedNodes != null) {\n                            for (int i = 0; i < loopScope.initialCreatedNodes.length; i++) {\n                                if (loopScope.initialCreatedNodes[i] == frameStateValue) {\n                                    loopScope.initialCreatedNodes[i] = newFrameStateValue;\n                                }\n                            }\n                        }\n                        return newFrameStateValue;\n                    }\n                }\n            };\n            FrameState newFrameState = graph.add(frameState.duplicate(valueFunction));\n\n            frameState.replaceAtUsagesAndDelete(newFrameState);\n            frameState = newFrameState;\n        }\n\n        loopBegin.replaceAtUsagesAndDelete(merge);\n        merge.setStateAfter(frameState);\n        merge.setNext(successor);\n        for (EndNode predecessor : predecessors) {\n            merge.addForwardEnd(predecessor);\n        }\n\n        if (methodScope.loopExplosion.mergeLoops()) {\n            LoopExplosionState explosionState = new LoopExplosionState(frameState, merge);\n            loopScope.iterationStates.put(explosionState, explosionState);\n        }\n    }\n\n    /**\n     * Hook for subclasses.\n     *\n     * @param methodScope The current method.\n     * @param loopScope The current loop.\n     */\n    protected void checkLoopExplosionIteration(MethodScope methodScope, LoopScope loopScope) {\n        throw shouldNotReachHere(\"when subclass uses loop explosion, it needs to implement this method\"); // ExcludeFromJacocoGeneratedReport\n    }\n\n    protected LoopScopeTrigger handleLoopExplosionEnd(MethodScope methodScope, LoopScope loopScope) {\n        /*\n         * This method is only called if we reach a loop end and we use some kind of loop explosion,\n         * i.e., we unroll loops or explode along loop ends.\n         */\n        LoopScopeTrigger trigger = null;\n        Deque<LoopScope> nextIterations = null;\n        if (methodScope.loopExplosion.duplicateLoopEnds()) {\n            /*\n             * Loop explosion along loop ends: We see a loop end, however we do not merge all loop\n             * ends at a common merge node but rather duplicate the rest of the loop for every loop\n             * end.\n             */\n            trigger = LoopScopeTrigger.LOOP_END_DUPLICATION;\n            nextIterations = loopScope.nextIterationFromLoopEndDuplication;\n        } else if (loopScope.nextIterationsFromUnrolling.isEmpty()) {\n            /*\n             * Regular loop unrolling, i.e., we reach a loop end node of a loop that should be\n             * unrolled: We create a new successor scope.\n             */\n            trigger = LoopScopeTrigger.LOOP_BEGIN_UNROLLING;\n            nextIterations = loopScope.nextIterationsFromUnrolling;\n        }\n        if (trigger != null) {\n            int nextIterationNumber = nextIterations.isEmpty() ? loopScope.loopIteration + 1 : nextIterations.getLast().loopIteration + 1;\n            LoopScope nextIterationScope = new LoopScope(methodScope, loopScope.outer, loopScope.loopDepth, nextIterationNumber, loopScope.loopBeginOrderId, trigger,\n                            methodScope.loopExplosion.mergeLoops() ? Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length) : loopScope.initialCreatedNodes,\n                            Arrays.copyOf(loopScope.initialCreatedNodes, loopScope.initialCreatedNodes.length),\n                            loopScope.nextIterationFromLoopExitDuplication,\n                            loopScope.nextIterationFromLoopEndDuplication,\n                            loopScope.nextIterationsFromUnrolling,\n                            loopScope.iterationStates);\n            checkLoopExplosionIteration(methodScope, nextIterationScope);\n            nextIterations.addLast(nextIterationScope);\n            registerNode(nextIterationScope, loopScope.loopBeginOrderId, null, true, true);\n            makeStubNode(methodScope, nextIterationScope, loopScope.loopBeginOrderId);\n        }\n        return trigger;\n    }\n\n    /**\n     * Hook for subclasses.\n     *\n     * @param methodScope The current method.\n     * @param loopScope The current loop.\n     * @param nodeOrderId The orderId of the node.\n     * @param node The node to be simplified.\n     */\n    protected void handleFixedNode(MethodScope methodScope, LoopScope loopScope, int nodeOrderId, FixedNode node) {\n    }\n\n    /**\n     * Hook for subclasses for early canonicalization of IfNodes and IntegerSwitchNodes.\n     *\n     * \"Early\" means that this is called before successor stubs creation. Therefore, all successors\n     * are null a this point, and calling any method using them without prior manual initialization\n     * will fail.\n     *\n     * @param methodScope The current method.\n     * @param loopScope The current loop.\n     * @param nodeOrderId The orderId of the node.\n     * @param node The node to be simplified.\n     * @return true if canonicalization happened, false otherwise.\n     */\n    protected boolean earlyCanonicalization(MethodScope methodScope, LoopScope loopScope, int nodeOrderId, FixedNode node) {\n        return false;\n    }\n\n    protected void handleProxyNodes(MethodScope methodScope, LoopScope loopScope, LoopExitNode loopExit) {\n        assert loopExit.stateAfter() == null;\n        int stateAfterOrderId = readOrderId(methodScope);\n        loopExit.setStateAfter((FrameState) ensureNodeCreated(methodScope, loopScope, stateAfterOrderId));\n\n        int numProxies = methodScope.reader.getUVInt();\n        for (int i = 0; i < numProxies; i++) {\n            int proxyOrderId = readOrderId(methodScope);\n            ProxyNode proxy = (ProxyNode) ensureNodeCreated(methodScope, loopScope, proxyOrderId);\n            /*\n             * The ProxyNode transports a value from the loop to the outer scope. We therefore\n             * register it in the outer scope.\n             */\n            if (loopScope.outer.createdNodes != loopScope.createdNodes) {\n                registerNode(loopScope.outer, proxyOrderId, proxy, false, false);\n            }\n        }\n    }\n\n    protected void handleLoopExplosionProxyNodes(MethodScope methodScope, LoopScope loopScope, LoopScope outerScope, LoopExitNode loopExit, int loopExitOrderId) {\n        assert loopExit.stateAfter() == null;\n        int stateAfterOrderId = readOrderId(methodScope);\n\n        FixedNode loopExitSuccessor = loopExit.next();\n\n        BeginNode begin;\n        if (loopExit.predecessor() instanceof BeginNode) {\n            // Optimization: Reuse an existing BeginNode rather than creating a new one.\n            begin = (BeginNode) loopExit.predecessor();\n            loopExit.replaceAtPredecessor(null);\n        } else {\n            begin = graph.add(new BeginNode());\n            loopExit.replaceAtPredecessor(begin);\n        }\n\n        MergeNode loopExitPlaceholder = null;\n        if (methodScope.loopExplosion.mergeLoops() && loopScope.loopDepth == 1) {\n            /*\n             * This exit might end up as a loop exit of a loop detected after partial evaluation. We\n             * need to be able to create a FrameState and the necessary proxy nodes in this case.\n             */\n            loopExitPlaceholder = graph.add(new MergeNode());\n            methodScope.loopExplosionMerges.add(loopExitPlaceholder);\n\n            EndNode end = graph.add(new EndNode());\n            begin.setNext(end);\n            loopExitPlaceholder.addForwardEnd(end);\n\n            begin = graph.add(new BeginNode());\n            loopExitPlaceholder.setNext(begin);\n        }\n\n        /*\n         * In the original graph, the loop exit is not a merge node. Multiple exploded loop\n         * iterations now take the same loop exit, so we have to introduce a new merge node to\n         * handle the merge.\n         */\n        MergeNode merge = null;\n        Node existingExit = lookupNode(outerScope, loopExitOrderId);\n        if (existingExit == null) {\n            /* First loop iteration that exits. No merge necessary yet. */\n            registerNode(outerScope, loopExitOrderId, begin, false, false);\n            begin.setNext(loopExitSuccessor);\n\n        } else if (existingExit instanceof BeginNode) {\n            /* Second loop iteration that exits. Create the merge. */\n            merge = graph.add(new MergeNode());\n            registerNode(outerScope, loopExitOrderId, merge, true, false);\n            /* Add the first iteration. */\n            EndNode firstEnd = graph.add(new EndNode());\n            ((BeginNode) existingExit).setNext(firstEnd);\n            merge.addForwardEnd(firstEnd);\n            merge.setNext(loopExitSuccessor);\n\n        } else {\n            /* Subsequent loop iteration. Merge already created. */\n            merge = (MergeNode) existingExit;\n        }\n\n        if (merge != null) {\n            EndNode end = graph.add(new EndNode());\n            begin.setNext(end);\n            merge.addForwardEnd(end);\n        }\n\n        /*\n         * Possibly create phi nodes for the original proxy nodes that flow out of the loop. Note\n         * that we definitely do not need a proxy node itself anymore, since the loop was exploded\n         * and is no longer present.\n         */\n        int numProxies = methodScope.reader.getUVInt();\n        boolean phiCreated = false;\n        for (int i = 0; i < numProxies; i++) {\n            int proxyOrderId = readOrderId(methodScope);\n            ProxyNode proxy = (ProxyNode) ensureNodeCreated(methodScope, loopScope, proxyOrderId);\n            ValueNode phiInput = proxy.value();\n\n            if (loopExitPlaceholder != null) {\n                if (!phiInput.isConstant()) {\n                    phiInput = graph.unique(new ProxyPlaceholder(phiInput, loopExitPlaceholder));\n                }\n                registerNode(loopScope, proxyOrderId, phiInput, true, false);\n            }\n\n            ValueNode replacement;\n            ValueNode existing = (ValueNode) outerScope.createdNodes[proxyOrderId];\n            if (existing == null || existing == phiInput) {\n                /*\n                 * We are at the first loop exit, or the proxy carries the same value for all exits.\n                 * We do not need a phi node yet.\n                 */\n                registerNode(outerScope, proxyOrderId, phiInput, true, false);\n                replacement = phiInput;\n\n            } else {\n                // Fortify: Suppress Null Dereference false positive\n                assert merge != null;\n\n                if (!merge.isPhiAtMerge(existing)) {\n                    /* Now we have two different values, so we need to create a phi node. */\n                    PhiNode phi = proxy.createPhi(merge);\n                    /* Add the inputs from all previous exits. */\n                    for (int j = 0; j < merge.phiPredecessorCount() - 1; j++) {\n                        phi.addInput(existing);\n                    }\n                    /* Add the input from this exit. */\n                    phi.addInput(phiInput);\n                    registerNode(outerScope, proxyOrderId, phi, true, false);\n                    replacement = phi;\n                    phiCreated = true;\n\n                } else {\n                    /* Phi node has been created before, so just add the new input. */\n                    PhiNode phi = (PhiNode) existing;\n                    phi.addInput(phiInput);\n                    replacement = phi;\n                }\n            }\n            proxy.replaceAtUsagesAndDelete(replacement);\n        }\n\n        if (loopExitPlaceholder != null) {\n            registerNode(loopScope, stateAfterOrderId, null, true, true);\n            loopExitPlaceholder.setStateAfter((FrameState) ensureNodeCreated(methodScope, loopScope, stateAfterOrderId));\n        }\n\n        if (merge != null && (merge.stateAfter() == null || phiCreated)) {\n            FrameState oldStateAfter = merge.stateAfter();\n            registerNode(outerScope, stateAfterOrderId, null, true, true);\n            merge.setStateAfter((FrameState) ensureNodeCreated(methodScope, outerScope, stateAfterOrderId));\n            if (oldStateAfter != null) {\n                oldStateAfter.safeDelete();\n            }\n        }\n        loopExit.safeDelete();\n        assert loopExitSuccessor.predecessor() == null;\n        if (merge != null) {\n            merge.getNodeClass().getSuccessorEdges().update(merge, null, loopExitSuccessor);\n        } else {\n            begin.getNodeClass().getSuccessorEdges().update(begin, null, loopExitSuccessor);\n        }\n    }\n\n    protected void handlePhiFunctions(MethodScope methodScope, LoopScope phiInputScope, LoopScope phiNodeScope, AbstractEndNode end, AbstractMergeNode merge) {\n\n        if (end instanceof LoopEndNode) {\n            /*\n             * Fix the loop end index and the number of loop ends. When we do canonicalization\n             * during decoding, we can end up with fewer ends than the encoded graph had. And the\n             * order of loop ends can be different.\n             */\n            int numEnds = ((LoopBeginNode) merge).loopEnds().count();\n            ((LoopBeginNode) merge).nextEndIndex = numEnds;\n            ((LoopEndNode) end).endIndex = numEnds - 1;\n\n        } else {\n            if (merge.ends == null) {\n                merge.ends = new NodeInputList<>(merge);\n            }\n            merge.addForwardEnd((EndNode) end);\n        }\n\n        /*\n         * We create most phi functions lazily. Canonicalization and simplification during decoding\n         * can lead to dead branches that are not decoded, so we might not need all phi functions\n         * that the original graph contained. Since we process all predecessors before actually\n         * processing the merge node, we have the final phi function when processing the merge node.\n         * The only exception are loop headers of non-exploded loops: since backward branches are\n         * not processed yet when processing the loop body, we need to create all phi functions\n         * upfront.\n         */\n        boolean lazyPhi = allowLazyPhis() && (!(merge instanceof LoopBeginNode) || methodScope.loopExplosion.useExplosion());\n        int numPhis = methodScope.reader.getUVInt();\n        for (int i = 0; i < numPhis; i++) {\n            int phiInputOrderId = readOrderId(methodScope);\n            int phiNodeOrderId = readOrderId(methodScope);\n\n            ValueNode phiInput = (ValueNode) ensureNodeCreated(methodScope, phiInputScope, phiInputOrderId);\n            ValueNode existing = (ValueNode) lookupNode(phiNodeScope, phiNodeOrderId);\n\n            if (existing != null && merge.phiPredecessorCount() == 1) {\n                /*\n                 * When exploding loops and the code after the loop (FULL_EXPLODE_UNTIL_RETURN),\n                 * then an existing value can already be registered: Parsing of the code before the\n                 * loop registers it when preparing for the later merge. The code after the loop,\n                 * which starts with a clone of the values that were created before the loop, sees\n                 * the stale value when processing the merge the first time. We can safely ignore\n                 * the stale value because it will never be needed to be merged (we are exploding\n                 * until we hit a return).\n                 */\n                assert methodScope.loopExplosion.duplicateLoopExits();\n                assert phiNodeScope.loopIteration > 0 : Assertions.errorMessageContext(\"phiNodeScope.loopIteration\", phiNodeScope.loopIteration);\n                existing = null;\n            }\n\n            if (lazyPhi && (existing == null || existing == phiInput)) {\n                /* Phi function not yet necessary. */\n                registerNode(phiNodeScope, phiNodeOrderId, phiInput, true, false);\n\n            } else if (!merge.isPhiAtMerge(existing)) {\n                /*\n                 * Phi function is necessary. Create it and fill it with existing inputs as well as\n                 * the new input.\n                 */\n                registerNode(phiNodeScope, phiNodeOrderId, null, true, true);\n                PhiNode phi = (PhiNode) ensureNodeCreated(methodScope, phiNodeScope, phiNodeOrderId);\n\n                phi.setMerge(merge);\n                for (int j = 0; j < merge.phiPredecessorCount() - 1; j++) {\n                    phi.addInput(existing);\n                }\n                phi.addInput(phiInput);\n\n            } else {\n                /* Phi node has been created before, so just add the new input. */\n                PhiNode phi = (PhiNode) existing;\n                phi.addInput(phiInput);\n            }\n        }\n    }\n\n    protected boolean allowLazyPhis() {\n        /* We need to exactly reproduce the encoded graph, including unnecessary phi functions. */\n        return false;\n    }\n\n    @SuppressWarnings(\"try\")\n    protected void readProperties(MethodScope methodScope, Node node) {\n        try (DebugCloseable a = ReadPropertiesTimer.start(debug)) {\n            NodeSourcePosition position = (NodeSourcePosition) readObject(methodScope);\n            Fields fields = node.getNodeClass().getData();\n            for (int pos = 0; pos < fields.getCount(); pos++) {\n                if (fields.getType(pos).isPrimitive()) {\n                    long primitive = methodScope.reader.getSV();\n                    fields.setRawPrimitive(node, pos, primitive);\n                } else {\n                    Object value = readObject(methodScope);\n                    fields.putObject(node, pos, value);\n                }\n            }\n            if (graph.trackNodeSourcePosition() && position != null) {\n                NodeSourcePosition newPosition = methodScope.getNodeSourcePosition(position);\n                node.setNodeSourcePosition(newPosition);\n                if (node instanceof DeoptimizingGuard deoptGuard && !newPosition.equals(position)) {\n                    deoptGuard.addCallerToNoDeoptSuccessorPosition(newPosition.getCaller());\n                }\n            }\n        }\n    }\n\n    /**\n     * Process the input edges of a node. Input nodes that have not yet been created must be\n     * non-fixed nodes (because fixed nodes are processed in reverse postorder. Such non-fixed nodes\n     * are created on demand (recursively since they can themselves reference not yet created\n     * nodes).\n     */\n    protected void makeFixedNodeInputs(MethodScope methodScope, LoopScope loopScope, Node node) {\n        Edges edges = node.getNodeClass().getInputEdges();\n        for (int index = 0; index < edges.getDirectCount(); index++) {\n            if (skipDirectEdge(node, edges, index)) {\n                continue;\n            }\n            int orderId = readOrderId(methodScope);\n            Node value = ensureNodeCreated(methodScope, loopScope, orderId);\n            edges.initializeNode(node, index, value);\n            if (value != null && !value.isDeleted()) {\n                edges.update(node, null, value);\n\n            }\n        }\n\n        if (node instanceof AbstractMergeNode) {\n            /* The ends of merge nodes are filled manually when the ends are processed. */\n            assert edges.getCount() - edges.getDirectCount() == 1 : \"MergeNode has one variable size input (the ends)\";\n            assert Edges.getNodeList(node, edges.getOffsets(), edges.getDirectCount()) != null : \"Input list must have been already created\";\n        } else {\n            for (int index = edges.getDirectCount(); index < edges.getCount(); index++) {\n                int size = methodScope.reader.getSVInt();\n                if (size != -1) {\n                    NodeList<Node> nodeList = new NodeInputList<>(node, size);\n                    edges.initializeList(node, index, nodeList);\n                    for (int idx = 0; idx < size; idx++) {\n                        int orderId = readOrderId(methodScope);\n                        Node value = ensureNodeCreated(methodScope, loopScope, orderId);\n                        nodeList.initialize(idx, value);\n                        if (value != null && !value.isDeleted()) {\n                            edges.update(node, null, value);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    protected void makeFloatingNodeInputs(MethodScope methodScope, LoopScope loopScope, Node node) {\n        Edges edges = node.getNodeClass().getInputEdges();\n        if (node instanceof PhiNode) {\n            /*\n             * The inputs of phi functions are filled manually when the end nodes are processed.\n             * However, the values must not be null, so initialize them with an empty list.\n             */\n            assert edges.getDirectCount() == 1 : \"PhiNode has one direct input (the MergeNode)\";\n            assert edges.getCount() - edges.getDirectCount() == 1 : \"PhiNode has one variable size input (the values)\";\n            edges.initializeList(node, edges.getDirectCount(), new NodeInputList<>(node));\n        } else {\n            for (int index = 0; index < edges.getDirectCount(); index++) {\n                int orderId = readOrderId(methodScope);\n                Node value = ensureNodeCreated(methodScope, loopScope, orderId);\n                edges.initializeNode(node, index, value);\n            }\n            for (int index = edges.getDirectCount(); index < edges.getCount(); index++) {\n                int size = methodScope.reader.getSVInt();\n                if (size != -1) {\n                    NodeList<Node> nodeList = new NodeInputList<>(node, size);\n                    edges.initializeList(node, index, nodeList);\n                    for (int idx = 0; idx < size; idx++) {\n                        int orderId = readOrderId(methodScope);\n                        Node value = ensureNodeCreated(methodScope, loopScope, orderId);\n                        nodeList.initialize(idx, value);\n                    }\n                }\n            }\n        }\n    }\n\n    protected Node ensureNodeCreated(MethodScope methodScope, LoopScope loopScope, int nodeOrderId) {\n        if (nodeOrderId == GraphEncoder.NULL_ORDER_ID) {\n            return null;\n        }\n        Node node = lookupNode(loopScope, nodeOrderId);\n        if (node != null) {\n            return node;\n        }\n\n        node = decodeFloatingNode(methodScope, loopScope, nodeOrderId);\n        if (node instanceof ProxyNode || node instanceof PhiNode) {\n            /*\n             * We need these nodes as they were in the original graph, without any canonicalization\n             * or value numbering.\n             */\n            node = graph.addWithoutUnique(node);\n        } else {\n            /* Allow subclasses to canonicalize and intercept nodes. */\n            Node newNode = handleFloatingNodeBeforeAdd(methodScope, loopScope, node);\n            if (newNode != node) {\n                releaseFloatingNode(node);\n            }\n\n            if (!newNode.isAlive()) {\n                newNode = addFloatingNode(methodScope, loopScope, newNode);\n            }\n            node = handleFloatingNodeAfterAdd(methodScope, loopScope, newNode);\n        }\n        registerNode(loopScope, nodeOrderId, node, false, false);\n        return node;\n    }\n\n    protected Node addFloatingNode(@SuppressWarnings(\"unused\") MethodScope methodScope, @SuppressWarnings(\"unused\") LoopScope loopScope, Node node) {\n        /*\n         * We want to exactly reproduce the encoded graph. Even though nodes should be unique in the\n         * encoded graph, this is not always guaranteed.\n         */\n        return graph.addWithoutUnique(node);\n    }\n\n    /**\n     * Decodes a non-fixed node, but does not do any post-processing and does not register it.\n     */\n    protected Node decodeFloatingNode(MethodScope methodScope, LoopScope loopScope, int nodeOrderId) {\n        long readerByteIndex = methodScope.reader.getByteIndex();\n\n        methodScope.reader.setByteIndex(methodScope.encodedGraph.nodeStartOffsets[nodeOrderId]);\n        NodeClass<?> nodeClass = methodScope.encodedGraph.getNodeClasses()[methodScope.reader.getUVInt()];\n        Node node = allocateFloatingNode(nodeClass);\n        if (node instanceof FixedNode) {\n            /*\n             * This is a severe error that will lead to a corrupted graph, so it is better not to\n             * continue decoding at all.\n             */\n            throw shouldNotReachHere(\"Not a floating node: \" + node.getClass().getName()); // ExcludeFromJacocoGeneratedReport\n        }\n\n        /* Read the inputs of the node, possibly creating them recursively. */\n        makeFloatingNodeInputs(methodScope, loopScope, node);\n\n        /* Read the properties of the node. */\n        readProperties(methodScope, node);\n        /* There must not be any successors to read, since it is a non-fixed node. */\n        assert node.getNodeClass().getEdges(Edges.Type.Successors).getCount() == 0 : Assertions.errorMessage(node);\n\n        methodScope.reader.setByteIndex(readerByteIndex);\n        return node;\n    }\n\n    private Node allocateFloatingNode(NodeClass<?> nodeClass) {\n        ArrayDeque<? extends Node> cachedNodes = reusableFloatingNodes.get(nodeClass);\n        if (cachedNodes != null) {\n            Node node = cachedNodes.poll();\n            if (node != null) {\n                return node;\n            }\n        }\n        return nodeClass.allocateInstance();\n    }\n\n    private void releaseFloatingNode(Node node) {\n        ArrayDeque<Node> cachedNodes = reusableFloatingNodes.get(node.getNodeClass());\n        if (cachedNodes == null) {\n            cachedNodes = new ArrayDeque<>(2);\n            reusableFloatingNodes.put(node.getNodeClass(), cachedNodes);\n        }\n        cachedNodes.push(node);\n    }\n\n    /**\n     * Hook for subclasses to process a non-fixed node before it is added to the graph.\n     *\n     * @param methodScope The current method.\n     * @param loopScope The current loop.\n     * @param node The node to be canonicalized.\n     * @return The replacement for the node, or the node itself.\n     */\n    protected Node handleFloatingNodeBeforeAdd(MethodScope methodScope, LoopScope loopScope, Node node) {\n        return node;\n    }\n\n    /**\n     * Hook for subclasses to process a non-fixed node after it is added to the graph.\n     *\n     * If this method replaces a node with another node, it must update its source position if the\n     * original node has the source position set.\n     *\n     * @param methodScope The current method.\n     * @param loopScope The current loop.\n     * @param node The node to be canonicalized.\n     * @return The replacement for the node, or the node itself.\n     */\n    protected Node handleFloatingNodeAfterAdd(MethodScope methodScope, LoopScope loopScope, Node node) {\n        return node;\n    }\n\n    /**\n     * Process successor edges of a node. We create the successor nodes so that we can fill the\n     * successor list, but no properties or edges are loaded yet. That is done when the successor is\n     * on top of the worklist in {@link #processNextNode}.\n     */\n    @SuppressWarnings(\"try\")\n    protected void makeSuccessorStubs(MethodScope methodScope, LoopScope loopScope, Node node, boolean updatePredecessors) {\n        try (DebugCloseable a = MakeSuccessorStubsTimer.start(debug)) {\n            Edges edges = node.getNodeClass().getSuccessorEdges();\n            for (int index = 0; index < edges.getDirectCount(); index++) {\n                if (skipDirectEdge(node, edges, index)) {\n                    continue;\n                }\n                int orderId = readOrderId(methodScope);\n                Node value = makeStubNode(methodScope, loopScope, orderId);\n                edges.initializeNode(node, index, value);\n                if (updatePredecessors && value != null) {\n                    edges.update(node, null, value);\n                }\n            }\n            for (int index = edges.getDirectCount(); index < edges.getCount(); index++) {\n                int size = methodScope.reader.getSVInt();\n                if (size != -1) {\n                    NodeList<Node> nodeList = new NodeSuccessorList<>(node, size);\n                    edges.initializeList(node, index, nodeList);\n                    for (int idx = 0; idx < size; idx++) {\n                        int orderId = readOrderId(methodScope);\n                        Node value = makeStubNode(methodScope, loopScope, orderId);\n                        nodeList.initialize(idx, value);\n                        if (updatePredecessors && value != null) {\n                            edges.update(node, null, value);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    protected NodeClass<?> getNodeClass(MethodScope methodScope, LoopScope loopScope, int nodeOrderId) {\n        if (nodeOrderId == GraphEncoder.NULL_ORDER_ID) {\n            return null;\n        }\n        FixedNode node = (FixedNode) lookupNode(loopScope, nodeOrderId);\n        if (node != null) {\n            return node.getNodeClass();\n        }\n\n        long readerByteIndex = methodScope.reader.getByteIndex();\n        methodScope.reader.setByteIndex(methodScope.encodedGraph.nodeStartOffsets[nodeOrderId]);\n        NodeClass<?> nodeClass = methodScope.encodedGraph.getNodeClasses()[methodScope.reader.getUVInt()];\n        methodScope.reader.setByteIndex(readerByteIndex);\n        return nodeClass;\n    }\n\n    protected FixedNode makeStubNode(MethodScope methodScope, LoopScope loopScope, int nodeOrderId) {\n        if (nodeOrderId == GraphEncoder.NULL_ORDER_ID) {\n            return null;\n        }\n        FixedNode node = (FixedNode) lookupNode(loopScope, nodeOrderId);\n        if (node != null) {\n            return node;\n        }\n\n        long readerByteIndex = methodScope.reader.getByteIndex();\n        methodScope.reader.setByteIndex(methodScope.encodedGraph.nodeStartOffsets[nodeOrderId]);\n        NodeClass<?> nodeClass = methodScope.encodedGraph.getNodeClasses()[methodScope.reader.getUVInt()];\n        Node stubNode = nodeClass.allocateInstance();\n        if (graph.trackNodeSourcePosition()) {\n            stubNode.setNodeSourcePosition(NodeSourcePosition.placeholder(graph.method()));\n        }\n        node = (FixedNode) graph.add(stubNode);\n        /* Properties and edges are not filled yet, the node remains uninitialized. */\n        methodScope.reader.setByteIndex(readerByteIndex);\n\n        registerNode(loopScope, nodeOrderId, node, false, false);\n        loopScope.nodesToProcess.set(nodeOrderId);\n        return node;\n    }\n\n    protected static boolean skipDirectEdge(Node node, Edges edges, int index) {\n        if (node instanceof Invoke || node instanceof MethodHandleWithExceptionNode) {\n            assert node instanceof InvokeNode || node instanceof InvokeWithExceptionNode || node instanceof MethodHandleWithExceptionNode : \"The only supported node classes. Got \" + node.getClass();\n            if (edges.type() == Edges.Type.Successors) {\n                assert edges.getCount() == (node instanceof WithExceptionNode ? 2 : 1) : \"Base Invokable has one successor (next); WithExceptionNode has two successors (next, exceptionEdge)\";\n                return true;\n            } else {\n                assert edges.type() == Edges.Type.Inputs : edges.type();\n                if (edges.getType(index) == CallTargetNode.class) {\n                    return true;\n                } else if (edges.getType(index) == FrameState.class) {\n                    assert edges.get(node, index) == null || edges.get(node, index) == ((StateSplit) node).stateAfter() : \"Only stateAfter can be a FrameState during encoding\";\n                    return true;\n                }\n            }\n        } else if (node instanceof LoopExitNode && edges.type() == Edges.Type.Inputs && edges.getType(index) == FrameState.class) {\n            /* The stateAfter of the loop exit is filled manually. */\n            return true;\n\n        }\n        return false;\n    }\n\n    protected Node lookupNode(LoopScope loopScope, int nodeOrderId) {\n        return loopScope.createdNodes[nodeOrderId];\n    }\n\n    protected void registerNode(LoopScope loopScope, int nodeOrderId, Node node, boolean allowOverwrite, boolean allowNull) {\n        assert node == null || node.isAlive();\n        assert allowNull || node != null;\n        assert allowOverwrite || lookupNode(loopScope, nodeOrderId) == null;\n        loopScope.createdNodes[nodeOrderId] = node;\n        if (loopScope.methodScope.inliningLogDecoder != null) {\n            loopScope.methodScope.inliningLogDecoder.registerNode(loopScope.methodScope.inliningLog, node, nodeOrderId);\n        }\n    }\n\n    protected int readOrderId(MethodScope methodScope) {\n        switch (methodScope.orderIdWidth) {\n            case 1:\n                return methodScope.reader.getU1();\n            case 2:\n                return methodScope.reader.getU2();\n            case 4:\n                return methodScope.reader.getS4();\n        }\n        throw GraalError.shouldNotReachHere(\"Invalid orderIdWidth: \" + methodScope.orderIdWidth); // ExcludeFromJacocoGeneratedReport\n    }\n\n    protected Object readObject(MethodScope methodScope) {\n        return methodScope.encodedGraph.getObject(methodScope.reader.getUVInt());\n    }\n\n    /**\n     * Removes unnecessary nodes from the graph after decoding.\n     *\n     * @param methodScope The current method.\n     */\n    protected void cleanupGraph(MethodScope methodScope) {\n        for (MergeNode merge : graph.getNodes(MergeNode.TYPE)) {\n            for (ProxyPlaceholder placeholder : merge.usages().filter(ProxyPlaceholder.class).snapshot()) {\n                placeholder.replaceAndDelete(placeholder.value);\n            }\n        }\n        assert verifyEdges();\n    }\n\n    protected boolean verifyEdges() {\n        for (Node node : graph.getNodes()) {\n            assert node.isAlive();\n            for (Node i : node.inputs()) {\n                assert i.isAlive();\n                assert i.usages().contains(node);\n            }\n            for (Node s : node.successors()) {\n                assert s.isAlive();\n                assert s.predecessor() == node : Assertions.errorMessage(s.predecessor(), node);\n            }\n\n            for (Node usage : node.usages()) {\n                assert usage.isAlive();\n                assert usage.inputs().contains(node) : node + \" / \" + usage + \" / \" + usage.inputs().count();\n            }\n            if (node.predecessor() != null) {\n                assert node.predecessor().isAlive();\n                assert node.predecessor().successors().contains(node);\n            }\n        }\n        return true;\n    }\n}",
                "methodCount": 68
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 11,
                "candidates": [
                    {
                        "lineStart": 484,
                        "lineEnd": 487,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method createFrom to class SwitchProbabilityData",
                        "description": "move method createFrom to PsiClass:SwitchProbabilityData\nRationale: The createFrom() method generates an InvokeData object from an InvokableData object, emphasizing transformation and creation patterns. The SwitchProbabilityData class already contains similar static factory methods (e.g., create(), profiled(), unknown()). Additionally, SwitchProbabilityData is part of a profile data management context, which is logically coherent with the purpose of the createFrom() method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1792,
                        "lineEnd": 1802,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method readOrderId to class MethodScope",
                        "description": "Move method readOrderId to jdk.graal.compiler.nodes.GraphDecoder.MethodScope\nRationale: The method readOrderId() is specifically dealing with decoding logic related to orderIdWidth from MethodScope. This decoding process includes reading from a TypeReader, which is a component of MethodScope, verifying its place in the logic of decoding graphs or methods within a scope. The method references MethodScope's orderIdWidth and reader properties directly, indicating that it belongs within the MethodScope class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1778,
                        "lineEnd": 1780,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method lookupNode to class LoopScope",
                        "description": "Move method lookupNode to jdk.graal.compiler.nodes.GraphDecoder.LoopScope\nRationale: The method lookupNode() is closely tied to the LoopScope class, as it uses the LoopScope object directly by accessing its createdNodes array to retrieve a Node based on nodeOrderId. This indicates that the method's primary function is to operate on the data encapsulated within the LoopScope class. By relocating the method to LoopScope, we ensure better encapsulation and coherence as the functionality specific to LoopScope remains within its class. Additionally, it helps to follow the principle of placing methods near the data they operate on, improving readability and maintainability of the codebase.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1822,
                        "lineEnd": 1844,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method verifyEdges to class StructuredGraph",
                        "description": "Move method verifyEdges to jdk.graal.compiler.nodes.StructuredGraph\nRationale: The method verifyEdges() extensively interacts with a 'graph' object and its Nodes, verifying the connections and properties of the graph structure. As StructuredGraph is a comprehensive class representing a graph with nodes and edges, it is most suitable for the verifyEdges() method. Placing this method in StructuredGraph ensures encapsulation of graph-related operations and keeps the graph validation logic close to the graph's definition and functionality. Therefore, verifyEdges() should be part of StructuredGraph, aligning with its responsibility of managing the overall graph structure.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1782,
                        "lineEnd": 1790,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method registerNode to class LoopScope",
                        "description": "Move method registerNode to jdk.graal.compiler.nodes.GraphDecoder.LoopScope\nRationale: The method registerNode() deals extensively with handling node information within the provided LoopScope class instance. It directly references several attributes from LoopScope, such as createdNodes and methods in its methodScope. This tight coupling suggests that the method's functionality is deeply integrated with the internal state and behavior of LoopScope.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1000,
                        "lineEnd": 1007,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method appendInvoke to class InvokeData",
                        "description": "Move method appendInvoke to jdk.graal.compiler.nodes.GraphDecoder.InvokeData\nRationale: The appendInvoke method deals directly with setting the call target on either an InvokeNode or InvokeWithExceptionNode contained within the InvokeData object. Since it primarily manipulates the internal state of InvokeData, it makes the most sense to move this method into the InvokeData class. This change would also follow the principle of encapsulation, ensuring that the data and the behavior related to that data are housed within the same class. Moreover, InvokeData already has information about the invoke and call target, making it a logical place for this method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 599,
                        "lineEnd": 603,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method maybeMarkUnsafeAccess to class EncodedGraph",
                        "description": "Move method maybeMarkUnsafeAccess to jdk.graal.compiler.nodes.EncodedGraph\nRationale: The maybeMarkUnsafeAccess method works directly with an EncodedGraph object, invoking its hasUnsafeAccess method. Since it uses the state and behavior of EncodedGraph, it makes logical sense for the method to belong to the EncodedGraph class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1009,
                        "lineEnd": 1022,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method appendInvokable to class MethodScope",
                        "description": "Move method appendInvokable to jdk.graal.compiler.nodes.GraphDecoder.MethodScope\nRationale: The method `appendInvokable` utilizes `MethodScope` extensively as evidenced by the calls to `ensureNodeCreated` and `makeStubNode`, which seem to logically belong within the method scope context. It interacts heavily with the state and behavior relevant to the method decoding processes within a `MethodScope`.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1755,
                        "lineEnd": 1776,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method skipDirectEdge to class GraphUtil",
                        "description": "move method skipDirectEdge to PsiClass:GraphUtil\nRationale: The method `skipDirectEdge` needs to be moved out of its current class because it heavily interacts with the `Node`, `Edges`, and related subclasses/interfaces such as `Invoke`, `MethodHandleWithExceptionNode`, etc. The `GraphUtil` class focuses on various utility operations based on nodes and their interactions within a graph structure, making it the most suitable target. `skipDirectEdge` is essentially a utility function for graph traversal and checking node properties, fitting well into `GraphUtil`'s existing functionality.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1629,
                        "lineEnd": 1638,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method allocateFloatingNode to class TimerKey",
                        "description": "Move method allocateFloatingNode to jdk.graal.compiler.debug.TimerKey\nRationale: The `allocateFloatingNode` method does not seem to fit within the context of the `TimerKey` class. The `TimerKey` class is focused on timing mechanisms and metrics, while the `allocateFloatingNode` method is concerned with node allocation, likely for some caching or resource management system. The method seems to operate on `Node` and makes use of `nodeClass` for allocation, which does not align with the functionalities of `TimerKey`. Therefore, `TimerKey` is not a suitable target class for this method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1600,
                        "lineEnd": 1627,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method decodeFloatingNode to class MethodScope",
                        "description": "Move method decodeFloatingNode to jdk.graal.compiler.nodes.GraphDecoder.MethodScope\nRationale: The decodeFloatingNode method is deeply tied to the MethodScope class in several ways. It utilizes members of MethodScope such as reader, encodedGraph, and nodeStartOffsets to perform decoding operations. It also manipulates the reader's byte index and references node classes, which are all properties of MethodScope. Given that the method is focused on decoding logic that is specific to the MethodScope context, it is appropriate to include it within the MethodScope class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "createInitialLoopScope",
                            "method_signature": "protected final LoopScope createInitialLoopScope(MethodScope methodScope, FixedWithNextNode startNode)",
                            "target_class": "LoopScope",
                            "rationale": "This method specifically deals with creating and initializing a LoopScope object, which makes it more logically consistent to place it within the LoopScope class."
                        },
                        {
                            "method_name": "processNextNode",
                            "method_signature": "protected LoopScope processNextNode(MethodScope methodScope, LoopScope loopScope)",
                            "target_class": "LoopScope",
                            "rationale": "The method `processNextNode` heavily interacts with and modifies LoopScope instances, processing nodes within a loop scope context. Thus, it should be a method within the LoopScope class."
                        },
                        {
                            "method_name": "registerNode",
                            "method_signature": "protected void registerNode(LoopScope loopScope, int nodeOrderId, Node node, boolean allowOverwrite, boolean allowNull)",
                            "target_class": "LoopScope",
                            "rationale": "This method is for registering nodes within a LoopScope, which indicates that it should logically be part of the LoopScope class."
                        },
                        {
                            "method_name": "lookupNode",
                            "method_signature": "protected Node lookupNode(LoopScope loopScope, int nodeOrderId)",
                            "target_class": "LoopScope",
                            "rationale": "This method is designed to look up nodes within a LoopScope, and thus should be a method within LoopScope."
                        },
                        {
                            "method_name": "releaseFloatingNode",
                            "method_signature": "protected void releaseFloatingNode(Node node)",
                            "target_class": "Node",
                            "rationale": "The method deals with releasing a floating node, so it should reside in the Node class where it can better interact with node-specific logic."
                        },
                        {
                            "method_name": "readOrderId",
                            "method_signature": "protected int readOrderId(MethodScope methodScope)",
                            "target_class": "MethodScope",
                            "rationale": "Since the method reads an order ID within the context of a MethodScope, it would make sense to move it to MethodScope to centralize similar logic."
                        },
                        {
                            "method_name": "readInvokableData",
                            "method_signature": "protected <T extends Invokable> InvokableData<T> readInvokableData(MethodScope methodScope, int orderId, T node)",
                            "target_class": "Invokable",
                            "rationale": "The method involves reading data specific to Invokable instances, so it should belong to the Invokable class or related subclasses."
                        },
                        {
                            "method_name": "checkLoopExplosionIteration",
                            "method_signature": "protected void checkLoopExplosionIteration(MethodScope methodScope, LoopScope loopScope)",
                            "target_class": "LoopScope",
                            "rationale": "This method checks loop explosion iteration within a LoopScope and should therefore be a part of the LoopScope class."
                        },
                        {
                            "method_name": "makeStubNode",
                            "method_signature": "protected FixedNode makeStubNode(MethodScope methodScope, LoopScope loopScope, int nodeOrderId)",
                            "target_class": "Node",
                            "rationale": "Creating stub nodes involves operations specific to nodes, so organizationally it is better placed within the Node class."
                        }
                    ],
                    "llm_response_time": 10638
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "calculateDiscount",
                            "method_signature": "public double calculateDiscount()",
                            "target_class": "Order",
                            "rationale": "calculateDiscount() method in the Order class accesses fields of the Customer class. Therefore, it may be more appropriate to place this method in the Customer class as it directly pertains to Customer's properties (loyalty points and membership level)."
                        }
                    ],
                    "llm_response_time": 3384
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "calculateDiscount",
                            "method_signature": "public double calculateDiscount(double amount)",
                            "target_class": "Customer",
                            "rationale": "The method calculateDiscount relies heavily on Customer-specific information including loyalty points and membership level. Moving it to the Customer class will improve cohesion and simplify the Order class."
                        }
                    ],
                    "llm_response_time": 2828
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "replaceLogsForDecodedGraph",
                            "method_signature": "public replaceLogsForDecodedGraph()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createFrom",
                            "method_signature": "static createFrom(InvokableData<? extends Invoke> from, int callTargetOrderId, boolean intrinsifiedMethodHandle)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "decode",
                            "method_signature": "@SuppressWarnings(\"try\")\n    public final decode(EncodedGraph encodedGraph, Iterable<EncodedGraph.EncodedNodeReference> nodeReferences)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "maybeMarkUnsafeAccess",
                            "method_signature": "private maybeMarkUnsafeAccess(EncodedGraph encodedGraph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "recordGraphElements",
                            "method_signature": "protected recordGraphElements(EncodedGraph encodedGraph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createInitialLoopScope",
                            "method_signature": "protected final createInitialLoopScope(MethodScope methodScope, FixedWithNextNode startNode)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "decode",
                            "method_signature": "@SuppressWarnings(\"try\")\n    protected final decode(LoopScope initialLoopScope)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "propagateCreatedNodes",
                            "method_signature": "private static propagateCreatedNodes(LoopScope loopScope)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "processNextNode",
                            "method_signature": "protected processNextNode(MethodScope methodScope, LoopScope loopScope)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleInvoke",
                            "method_signature": "protected handleInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "appendInvoke",
                            "method_signature": "protected appendInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData, CallTargetNode callTarget)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "appendInvokable",
                            "method_signature": "private appendInvokable(MethodScope methodScope, LoopScope loopScope, InvokableData<T> invokeData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleLoopExplosionEnd",
                            "method_signature": "protected handleLoopExplosionEnd(MethodScope methodScope, LoopScope loopScope)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleProxyNodes",
                            "method_signature": "protected handleProxyNodes(MethodScope methodScope, LoopScope loopScope, LoopExitNode loopExit)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleLoopExplosionProxyNodes",
                            "method_signature": "protected handleLoopExplosionProxyNodes(MethodScope methodScope, LoopScope loopScope, LoopScope outerScope, LoopExitNode loopExit, int loopExitOrderId)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handlePhiFunctions",
                            "method_signature": "protected handlePhiFunctions(MethodScope methodScope, LoopScope phiInputScope, LoopScope phiNodeScope, AbstractEndNode end, AbstractMergeNode merge)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "readProperties",
                            "method_signature": "@SuppressWarnings(\"try\")\n    protected readProperties(MethodScope methodScope, Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "makeFixedNodeInputs",
                            "method_signature": "protected makeFixedNodeInputs(MethodScope methodScope, LoopScope loopScope, Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "makeFloatingNodeInputs",
                            "method_signature": "protected makeFloatingNodeInputs(MethodScope methodScope, LoopScope loopScope, Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "ensureNodeCreated",
                            "method_signature": "protected ensureNodeCreated(MethodScope methodScope, LoopScope loopScope, int nodeOrderId)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addFloatingNode",
                            "method_signature": "protected addFloatingNode(@SuppressWarnings(\"unused\") MethodScope methodScope, @SuppressWarnings(\"unused\") LoopScope loopScope, Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "decodeFloatingNode",
                            "method_signature": "protected decodeFloatingNode(MethodScope methodScope, LoopScope loopScope, int nodeOrderId)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "allocateFloatingNode",
                            "method_signature": "private allocateFloatingNode(NodeClass<?> nodeClass)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "releaseFloatingNode",
                            "method_signature": "private releaseFloatingNode(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "makeSuccessorStubs",
                            "method_signature": "@SuppressWarnings(\"try\")\n    protected makeSuccessorStubs(MethodScope methodScope, LoopScope loopScope, Node node, boolean updatePredecessors)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getNodeClass",
                            "method_signature": "protected getNodeClass(MethodScope methodScope, LoopScope loopScope, int nodeOrderId)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "makeStubNode",
                            "method_signature": "protected makeStubNode(MethodScope methodScope, LoopScope loopScope, int nodeOrderId)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "skipDirectEdge",
                            "method_signature": "protected static skipDirectEdge(Node node, Edges edges, int index)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "lookupNode",
                            "method_signature": "protected lookupNode(LoopScope loopScope, int nodeOrderId)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "registerNode",
                            "method_signature": "protected registerNode(LoopScope loopScope, int nodeOrderId, Node node, boolean allowOverwrite, boolean allowNull)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "readOrderId",
                            "method_signature": "protected readOrderId(MethodScope methodScope)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "readObject",
                            "method_signature": "protected readObject(MethodScope methodScope)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "cleanupGraph",
                            "method_signature": "protected cleanupGraph(MethodScope methodScope)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verifyEdges",
                            "method_signature": "protected verifyEdges()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "createFrom",
                            "method_signature": "static createFrom(InvokableData<? extends Invoke> from, int callTargetOrderId, boolean intrinsifiedMethodHandle)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "readOrderId",
                            "method_signature": "protected readOrderId(MethodScope methodScope)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "readObject",
                            "method_signature": "protected readObject(MethodScope methodScope)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "lookupNode",
                            "method_signature": "protected lookupNode(LoopScope loopScope, int nodeOrderId)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verifyEdges",
                            "method_signature": "protected verifyEdges()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "registerNode",
                            "method_signature": "protected registerNode(LoopScope loopScope, int nodeOrderId, Node node, boolean allowOverwrite, boolean allowNull)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "appendInvoke",
                            "method_signature": "protected appendInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData, CallTargetNode callTarget)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "maybeMarkUnsafeAccess",
                            "method_signature": "private maybeMarkUnsafeAccess(EncodedGraph encodedGraph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "appendInvokable",
                            "method_signature": "private appendInvokable(MethodScope methodScope, LoopScope loopScope, InvokableData<T> invokeData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addFloatingNode",
                            "method_signature": "protected addFloatingNode(@SuppressWarnings(\"unused\") MethodScope methodScope, @SuppressWarnings(\"unused\") LoopScope loopScope, Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "skipDirectEdge",
                            "method_signature": "protected static skipDirectEdge(Node node, Edges edges, int index)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "releaseFloatingNode",
                            "method_signature": "private releaseFloatingNode(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleInvoke",
                            "method_signature": "protected handleInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "allocateFloatingNode",
                            "method_signature": "private allocateFloatingNode(NodeClass<?> nodeClass)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "decodeFloatingNode",
                            "method_signature": "protected decodeFloatingNode(MethodScope methodScope, LoopScope loopScope, int nodeOrderId)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "static createFrom(InvokableData<? extends Invoke> from, int callTargetOrderId, boolean intrinsifiedMethodHandle)": {
                        "first": {
                            "method_name": "createFrom",
                            "method_signature": "static createFrom(InvokableData<? extends Invoke> from, int callTargetOrderId, boolean intrinsifiedMethodHandle)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2117077813050487
                    },
                    "protected readOrderId(MethodScope methodScope)": {
                        "first": {
                            "method_name": "readOrderId",
                            "method_signature": "protected readOrderId(MethodScope methodScope)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.30184253760741203
                    },
                    "protected readObject(MethodScope methodScope)": {
                        "first": {
                            "method_name": "readObject",
                            "method_signature": "protected readObject(MethodScope methodScope)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.32936658830274435
                    },
                    "protected lookupNode(LoopScope loopScope, int nodeOrderId)": {
                        "first": {
                            "method_name": "lookupNode",
                            "method_signature": "protected lookupNode(LoopScope loopScope, int nodeOrderId)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3916496614442125
                    },
                    "protected verifyEdges()": {
                        "first": {
                            "method_name": "verifyEdges",
                            "method_signature": "protected verifyEdges()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4053907157305773
                    },
                    "protected registerNode(LoopScope loopScope, int nodeOrderId, Node node, boolean allowOverwrite, boolean allowNull)": {
                        "first": {
                            "method_name": "registerNode",
                            "method_signature": "protected registerNode(LoopScope loopScope, int nodeOrderId, Node node, boolean allowOverwrite, boolean allowNull)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.41395531129224244
                    },
                    "protected appendInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData, CallTargetNode callTarget)": {
                        "first": {
                            "method_name": "appendInvoke",
                            "method_signature": "protected appendInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData, CallTargetNode callTarget)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.451545903504021
                    },
                    "private maybeMarkUnsafeAccess(EncodedGraph encodedGraph)": {
                        "first": {
                            "method_name": "maybeMarkUnsafeAccess",
                            "method_signature": "private maybeMarkUnsafeAccess(EncodedGraph encodedGraph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.46202054886306304
                    },
                    "private appendInvokable(MethodScope methodScope, LoopScope loopScope, InvokableData<T> invokeData)": {
                        "first": {
                            "method_name": "appendInvokable",
                            "method_signature": "private appendInvokable(MethodScope methodScope, LoopScope loopScope, InvokableData<T> invokeData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.48914462588048174
                    },
                    "protected addFloatingNode(@SuppressWarnings(\"unused\") MethodScope methodScope, @SuppressWarnings(\"unused\") LoopScope loopScope, Node node)": {
                        "first": {
                            "method_name": "addFloatingNode",
                            "method_signature": "protected addFloatingNode(@SuppressWarnings(\"unused\") MethodScope methodScope, @SuppressWarnings(\"unused\") LoopScope loopScope, Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.48947757671712666
                    },
                    "protected static skipDirectEdge(Node node, Edges edges, int index)": {
                        "first": {
                            "method_name": "skipDirectEdge",
                            "method_signature": "protected static skipDirectEdge(Node node, Edges edges, int index)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.49719489000240646
                    },
                    "private releaseFloatingNode(Node node)": {
                        "first": {
                            "method_name": "releaseFloatingNode",
                            "method_signature": "private releaseFloatingNode(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5072539390866647
                    },
                    "protected handleInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData)": {
                        "first": {
                            "method_name": "handleInvoke",
                            "method_signature": "protected handleInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5390402535567195
                    },
                    "private allocateFloatingNode(NodeClass<?> nodeClass)": {
                        "first": {
                            "method_name": "allocateFloatingNode",
                            "method_signature": "private allocateFloatingNode(NodeClass<?> nodeClass)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5691656808782218
                    },
                    "protected decodeFloatingNode(MethodScope methodScope, LoopScope loopScope, int nodeOrderId)": {
                        "first": {
                            "method_name": "decodeFloatingNode",
                            "method_signature": "protected decodeFloatingNode(MethodScope methodScope, LoopScope loopScope, int nodeOrderId)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5777745713424959
                    }
                },
                "voyage": {
                    "static createFrom(InvokableData<? extends Invoke> from, int callTargetOrderId, boolean intrinsifiedMethodHandle)": {
                        "first": {
                            "method_name": "createFrom",
                            "method_signature": "static createFrom(InvokableData<? extends Invoke> from, int callTargetOrderId, boolean intrinsifiedMethodHandle)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.23022590157144532
                    },
                    "protected readOrderId(MethodScope methodScope)": {
                        "first": {
                            "method_name": "readOrderId",
                            "method_signature": "protected readOrderId(MethodScope methodScope)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2590297214521559
                    },
                    "private allocateFloatingNode(NodeClass<?> nodeClass)": {
                        "first": {
                            "method_name": "allocateFloatingNode",
                            "method_signature": "private allocateFloatingNode(NodeClass<?> nodeClass)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2785947175508212
                    },
                    "private releaseFloatingNode(Node node)": {
                        "first": {
                            "method_name": "releaseFloatingNode",
                            "method_signature": "private releaseFloatingNode(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3039917786884052
                    },
                    "protected lookupNode(LoopScope loopScope, int nodeOrderId)": {
                        "first": {
                            "method_name": "lookupNode",
                            "method_signature": "protected lookupNode(LoopScope loopScope, int nodeOrderId)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.38053759213516714
                    },
                    "protected verifyEdges()": {
                        "first": {
                            "method_name": "verifyEdges",
                            "method_signature": "protected verifyEdges()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4141492577528024
                    },
                    "private maybeMarkUnsafeAccess(EncodedGraph encodedGraph)": {
                        "first": {
                            "method_name": "maybeMarkUnsafeAccess",
                            "method_signature": "private maybeMarkUnsafeAccess(EncodedGraph encodedGraph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.43967532840345896
                    },
                    "private appendInvokable(MethodScope methodScope, LoopScope loopScope, InvokableData<T> invokeData)": {
                        "first": {
                            "method_name": "appendInvokable",
                            "method_signature": "private appendInvokable(MethodScope methodScope, LoopScope loopScope, InvokableData<T> invokeData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4454499547481693
                    },
                    "protected appendInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData, CallTargetNode callTarget)": {
                        "first": {
                            "method_name": "appendInvoke",
                            "method_signature": "protected appendInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData, CallTargetNode callTarget)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4501071803836788
                    },
                    "@SuppressWarnings(\"try\")\n    protected readProperties(MethodScope methodScope, Node node)": {
                        "first": {
                            "method_name": "readProperties",
                            "method_signature": "@SuppressWarnings(\"try\")\n    protected readProperties(MethodScope methodScope, Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.45210022030737823
                    },
                    "protected readObject(MethodScope methodScope)": {
                        "first": {
                            "method_name": "readObject",
                            "method_signature": "protected readObject(MethodScope methodScope)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.45457453368673606
                    },
                    "@SuppressWarnings(\"try\")\n    protected makeSuccessorStubs(MethodScope methodScope, LoopScope loopScope, Node node, boolean updatePredecessors)": {
                        "first": {
                            "method_name": "makeSuccessorStubs",
                            "method_signature": "@SuppressWarnings(\"try\")\n    protected makeSuccessorStubs(MethodScope methodScope, LoopScope loopScope, Node node, boolean updatePredecessors)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4931151210566177
                    },
                    "protected makeFloatingNodeInputs(MethodScope methodScope, LoopScope loopScope, Node node)": {
                        "first": {
                            "method_name": "makeFloatingNodeInputs",
                            "method_signature": "protected makeFloatingNodeInputs(MethodScope methodScope, LoopScope loopScope, Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4931330924901114
                    },
                    "protected static skipDirectEdge(Node node, Edges edges, int index)": {
                        "first": {
                            "method_name": "skipDirectEdge",
                            "method_signature": "protected static skipDirectEdge(Node node, Edges edges, int index)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4955906772851717
                    },
                    "protected registerNode(LoopScope loopScope, int nodeOrderId, Node node, boolean allowOverwrite, boolean allowNull)": {
                        "first": {
                            "method_name": "registerNode",
                            "method_signature": "protected registerNode(LoopScope loopScope, int nodeOrderId, Node node, boolean allowOverwrite, boolean allowNull)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5027742370698601
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "protected verifyEdges()",
                        "protected registerNode(LoopScope loopScope, int nodeOrderId, Node node, boolean allowOverwrite, boolean allowNull)",
                        "protected lookupNode(LoopScope loopScope, int nodeOrderId)",
                        "protected readOrderId(MethodScope methodScope)",
                        "protected readObject(MethodScope methodScope)",
                        "protected handleInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData)",
                        "protected appendInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData, CallTargetNode callTarget)",
                        "protected decodeFloatingNode(MethodScope methodScope, LoopScope loopScope, int nodeOrderId)",
                        "protected addFloatingNode(@SuppressWarnings(\"unused\") MethodScope methodScope, @SuppressWarnings(\"unused\") LoopScope loopScope, Node node)",
                        "private maybeMarkUnsafeAccess(EncodedGraph encodedGraph)",
                        "private appendInvokable(MethodScope methodScope, LoopScope loopScope, InvokableData<T> invokeData)",
                        "private releaseFloatingNode(Node node)",
                        "private allocateFloatingNode(NodeClass<?> nodeClass)",
                        "protected static skipDirectEdge(Node node, Edges edges, int index)",
                        "static createFrom(InvokableData<? extends Invoke> from, int callTargetOrderId, boolean intrinsifiedMethodHandle)"
                    ],
                    "llm_response_time": 7884
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "protected verifyEdges()",
                        "protected lookupNode(LoopScope loopScope, int nodeOrderId)",
                        "protected readObject(MethodScope methodScope)",
                        "protected readOrderId(MethodScope methodScope)",
                        "static createFrom(InvokableData<? extends Invoke> from, int callTargetOrderId, boolean intrinsifiedMethodHandle)"
                    ],
                    "llm_response_time": 5389
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "protected readOrderId(MethodScope methodScope)",
                        "protected readObject(MethodScope methodScope)",
                        "static createFrom(InvokableData<? extends Invoke> from, int callTargetOrderId, boolean intrinsifiedMethodHandle)"
                    ],
                    "llm_response_time": 4732
                },
                "voyage": {
                    "priority_method_names": [
                        "protected static skipDirectEdge(Node node, Edges edges, int index)",
                        "private allocateFloatingNode(NodeClass<?> nodeClass)",
                        "private releaseFloatingNode(Node node)",
                        "protected lookupNode(LoopScope loopScope, int nodeOrderId)",
                        "private maybeMarkUnsafeAccess(EncodedGraph encodedGraph)",
                        "protected readOrderId(MethodScope methodScope)",
                        "protected readObject(MethodScope methodScope)",
                        "protected registerNode(LoopScope loopScope, int nodeOrderId, Node node, boolean allowOverwrite, boolean allowNull)",
                        "protected verifyEdges()",
                        "protected makeFloatingNodeInputs(MethodScope methodScope, LoopScope loopScope, Node node)",
                        "private appendInvokable(MethodScope methodScope, LoopScope loopScope, InvokableData<T> invokeData)",
                        "protected appendInvoke(MethodScope methodScope, LoopScope loopScope, InvokeData invokeData, CallTargetNode callTarget)",
                        "static createFrom(InvokableData<? extends Invoke> from, int callTargetOrderId, boolean intrinsifiedMethodHandle)"
                    ],
                    "llm_response_time": 5655
                },
                "voyage-5": {
                    "priority_method_names": [
                        "protected readOrderId(MethodScope methodScope)",
                        "protected lookupNode(LoopScope loopScope, int nodeOrderId)",
                        "private allocateFloatingNode(NodeClass<?> nodeClass)",
                        "private releaseFloatingNode(Node node)",
                        "static createFrom(InvokableData<? extends Invoke> from, int callTargetOrderId, boolean intrinsifiedMethodHandle)"
                    ],
                    "llm_response_time": 5072
                },
                "voyage-3": {
                    "priority_method_names": [
                        "protected readOrderId(MethodScope methodScope)",
                        "private allocateFloatingNode(NodeClass<?> nodeClass)",
                        "static createFrom(InvokableData<? extends Invoke> from, int callTargetOrderId, boolean intrinsifiedMethodHandle)"
                    ],
                    "llm_response_time": 4621
                }
            },
            "targetClassMap": {
                "createFrom": {
                    "target_classes": [
                        {
                            "class_name": "GraphComparison",
                            "similarity_score": 0.21144131413423903
                        },
                        {
                            "class_name": "DB",
                            "similarity_score": 0.2773500981126146
                        },
                        {
                            "class_name": "ConstantNode",
                            "similarity_score": 0.26553352553259313
                        },
                        {
                            "class_name": "LogicConstantNode",
                            "similarity_score": 0.23823537325288668
                        },
                        {
                            "class_name": "NamedLocationIdentity",
                            "similarity_score": 0.2407387438844837
                        },
                        {
                            "class_name": "PiNode",
                            "similarity_score": 0.2703296344495263
                        },
                        {
                            "class_name": "DynamicPiNode",
                            "similarity_score": 0.25877795287652094
                        },
                        {
                            "class_name": "BranchProbabilityData",
                            "similarity_score": 0.2658437137275725
                        },
                        {
                            "class_name": "TypeCheckHints",
                            "similarity_score": 0.1323145270899112
                        },
                        {
                            "class_name": "ShortCircuitOrNode",
                            "similarity_score": 0.268602268036039
                        },
                        {
                            "class_name": "InliningLogCodec",
                            "similarity_score": 0.14355879216856482
                        },
                        {
                            "class_name": "SwitchProbabilityData",
                            "similarity_score": 0.3195366918016847
                        },
                        {
                            "class_name": "LogicNegationNode",
                            "similarity_score": 0.2825048744584232
                        },
                        {
                            "class_name": "BeginNode",
                            "similarity_score": 0.22988508617818787
                        },
                        {
                            "class_name": "MergeNode",
                            "similarity_score": 0.24429837824417114
                        },
                        {
                            "class_name": "PrefetchAllocateNode",
                            "similarity_score": 0.1730769230769231
                        },
                        {
                            "class_name": "PauseNode",
                            "similarity_score": 0.16906067027220253
                        },
                        {
                            "class_name": "UnreachableNode",
                            "similarity_score": 0.14072526658231807
                        },
                        {
                            "class_name": "SnippetAnchorNode",
                            "similarity_score": 0.18636039058221673
                        },
                        {
                            "class_name": "OptimizationLogCodec",
                            "similarity_score": 0.22035564873040683
                        },
                        {
                            "class_name": "IfNode",
                            "similarity_score": 0.23000496610490226
                        },
                        {
                            "class_name": "GetObjectAddressNode",
                            "similarity_score": 0.1860842991847172
                        },
                        {
                            "class_name": "LoopDetector",
                            "similarity_score": 0.1301973022889235
                        },
                        {
                            "class_name": "BreakpointNode",
                            "similarity_score": 0.08691126898057103
                        },
                        {
                            "class_name": "ProxyPlaceholder",
                            "similarity_score": 0.21602196757003655
                        },
                        {
                            "class_name": "PiArrayNode",
                            "similarity_score": 0.18924236358783025
                        },
                        {
                            "class_name": "InliningLog",
                            "similarity_score": 0.1537552464134989
                        },
                        {
                            "class_name": "GuardedValueNode",
                            "similarity_score": 0.27277130574057734
                        },
                        {
                            "class_name": "ComputeObjectAddressNode",
                            "similarity_score": 0.17394885264101748
                        },
                        {
                            "class_name": "OptimizationEntryImpl",
                            "similarity_score": 0.19875393017219073
                        },
                        {
                            "class_name": "PlaceholderStamp",
                            "similarity_score": 0.30762521629905626
                        },
                        {
                            "class_name": "LoopFrequencyData",
                            "similarity_score": 0.26960709592132814
                        },
                        {
                            "class_name": "OptimizationNode",
                            "similarity_score": 0.09611396818211317
                        },
                        {
                            "class_name": "ValuePhiNode",
                            "similarity_score": 0.23612502921314066
                        },
                        {
                            "class_name": "DeoptimizeNode",
                            "similarity_score": 0.24057610857875847
                        },
                        {
                            "class_name": "StructuredGraph",
                            "similarity_score": 0.24853909380813777
                        },
                        {
                            "class_name": "GraphEncoder",
                            "similarity_score": 0.17749223037111614
                        },
                        {
                            "class_name": "Callsite",
                            "similarity_score": 0.10992036300837055
                        },
                        {
                            "class_name": "SimplifyingGraphDecoder",
                            "similarity_score": 0.2620828892570095
                        },
                        {
                            "class_name": "GraphState",
                            "similarity_score": 0.13195973445648926
                        },
                        {
                            "class_name": "InvokeNode",
                            "similarity_score": 0.2954066171422978
                        },
                        {
                            "class_name": "FrameState",
                            "similarity_score": 0.24911060843872376
                        },
                        {
                            "class_name": "GuardNode",
                            "similarity_score": 0.22852600222684127
                        },
                        {
                            "class_name": "OptimizationLogImpl",
                            "similarity_score": 0.14848685037611573
                        },
                        {
                            "class_name": "GraphDecoder",
                            "similarity_score": 0.21841601809982286
                        },
                        {
                            "class_name": "LoopBeginNode",
                            "similarity_score": 0.29154185366690444
                        },
                        {
                            "class_name": "IndirectCallTargetNode",
                            "similarity_score": 0.20947232885207748
                        },
                        {
                            "class_name": "GuardPhiNode",
                            "similarity_score": 0.27546275724125807
                        },
                        {
                            "class_name": "GuardProxyNode",
                            "similarity_score": 0.20801257358446093
                        },
                        {
                            "class_name": "InliningLogDecoder",
                            "similarity_score": 0.16324128515450684
                        },
                        {
                            "class_name": "DynamicDeoptimizeNode",
                            "similarity_score": 0.24450664629413973
                        },
                        {
                            "class_name": "Hint",
                            "similarity_score": 0.11686159857648114
                        },
                        {
                            "class_name": "FieldLocationIdentity",
                            "similarity_score": 0.30542465739783053
                        },
                        {
                            "class_name": "FixedGuardNode",
                            "similarity_score": 0.26779427461135347
                        },
                        {
                            "class_name": "EncodedGraph",
                            "similarity_score": 0.2467308760665812
                        },
                        {
                            "class_name": "EncodedNodeReference",
                            "similarity_score": 0.13313988227628884
                        },
                        {
                            "class_name": "EndNode",
                            "similarity_score": 0.17739371879672478
                        },
                        {
                            "class_name": "ReturnNode",
                            "similarity_score": 0.22296455574067103
                        },
                        {
                            "class_name": "EntryMarkerNode",
                            "similarity_score": 0.23937939510846545
                        },
                        {
                            "class_name": "EntryProxyNode",
                            "similarity_score": 0.18568111028459128
                        },
                        {
                            "class_name": "RootScope",
                            "similarity_score": 0.10331485405523487
                        },
                        {
                            "class_name": "InvokableData",
                            "similarity_score": 0.1749800863470773
                        },
                        {
                            "class_name": "LoopEndNode",
                            "similarity_score": 0.16832939849979425
                        },
                        {
                            "class_name": "LoopExitNode",
                            "similarity_score": 0.23318478966361694
                        },
                        {
                            "class_name": "LoopExplosionState",
                            "similarity_score": 0.23884700203524373
                        },
                        {
                            "class_name": "LoopScope",
                            "similarity_score": 0.11030213148105904
                        },
                        {
                            "class_name": "InvokeWithExceptionNode",
                            "similarity_score": 0.2669863288529578
                        },
                        {
                            "class_name": "Builder",
                            "similarity_score": 0.22984733913768188
                        },
                        {
                            "class_name": "SafepointNode",
                            "similarity_score": 0.2048366225996757
                        },
                        {
                            "class_name": "NodeOrder",
                            "similarity_score": 0.22165076680881296
                        },
                        {
                            "class_name": "ScheduleResult",
                            "similarity_score": 0.2819564645836313
                        },
                        {
                            "class_name": "FullInfopointNode",
                            "similarity_score": 0.19418390934515437
                        },
                        {
                            "class_name": "ConditionAnchorNode",
                            "similarity_score": 0.29558388894655596
                        },
                        {
                            "class_name": "MemoryProxyNode",
                            "similarity_score": 0.21404317236952236
                        },
                        {
                            "class_name": "CanonicalizeToNullNode",
                            "similarity_score": 0.23112508176051216
                        },
                        {
                            "class_name": "MethodScope",
                            "similarity_score": 0.13267688388621854
                        },
                        {
                            "class_name": "Default",
                            "similarity_score": 0.22496063533292376
                        },
                        {
                            "class_name": "DirectCallTargetNode",
                            "similarity_score": 0.1739678624058566
                        },
                        {
                            "class_name": "OptimizationEntryDummy",
                            "similarity_score": 0.17722938923964168
                        },
                        {
                            "class_name": "OptimizationLogDummy",
                            "similarity_score": 0.17392331807984004
                        },
                        {
                            "class_name": "OptimizationPhaseNode",
                            "similarity_score": 0.173141967584115
                        },
                        {
                            "class_name": "ParameterNode",
                            "similarity_score": 0.17391507288487007
                        },
                        {
                            "class_name": "Placeholder",
                            "similarity_score": 0.15480470613460084
                        },
                        {
                            "class_name": "PlaceholderInvokable",
                            "similarity_score": 0.27565375132426
                        },
                        {
                            "class_name": "PluginReplacementNode",
                            "similarity_score": 0.23386740249984922
                        },
                        {
                            "class_name": "PluginReplacementWithExceptionNode",
                            "similarity_score": 0.23386740249984922
                        },
                        {
                            "class_name": "PECanonicalizerTool",
                            "similarity_score": 0.28339745488816104
                        },
                        {
                            "class_name": "PartialEscapeLog",
                            "similarity_score": 0.12538920696157715
                        },
                        {
                            "class_name": "UnreachableBeginNode",
                            "similarity_score": 0.09516486024850805
                        },
                        {
                            "class_name": "UnreachableControlSinkNode",
                            "similarity_score": 0.16317848796612636
                        },
                        {
                            "class_name": "UnwindNode",
                            "similarity_score": 0.16594442204000187
                        },
                        {
                            "class_name": "UpdateScope",
                            "similarity_score": 0.1835177279629517
                        },
                        {
                            "class_name": "ValueProxyNode",
                            "similarity_score": 0.2535813726979461
                        },
                        {
                            "class_name": "SpinWaitNode",
                            "similarity_score": 0.16918197377512542
                        },
                        {
                            "class_name": "StartNode",
                            "similarity_score": 0.21850711221876895
                        },
                        {
                            "class_name": "DeadEndNode",
                            "similarity_score": 0.06829999682195942
                        },
                        {
                            "class_name": "Decision",
                            "similarity_score": 0.19805985097023068
                        },
                        {
                            "class_name": "ExceptionPlaceholderNode",
                            "similarity_score": 0.19037490262714743
                        },
                        {
                            "class_name": "SpecialCallTargetCacheKey",
                            "similarity_score": 0.21203680483218526
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SwitchProbabilityData",
                        "FieldLocationIdentity",
                        "PlaceholderStamp"
                    ],
                    "llm_response_time": 2747,
                    "similarity_computation_time": 57,
                    "similarity_metric": "cosine"
                },
                "readOrderId": {
                    "target_classes": [
                        {
                            "class_name": "MethodScope",
                            "similarity_score": 0.18931712020711192
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.08719378417668117
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.08719378417668117
                        },
                        {
                            "class_name": "StructuredGraph",
                            "similarity_score": 0.391392458984212
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "MethodScope",
                        "StructuredGraph",
                        "TimerKey"
                    ],
                    "llm_response_time": 4270,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "readObject": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3740,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "lookupNode": {
                    "target_classes": [
                        {
                            "class_name": "LoopScope",
                            "similarity_score": 0.1645175796245975
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.08181680188713228
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.08181680188713228
                        },
                        {
                            "class_name": "StructuredGraph",
                            "similarity_score": 0.3857288502008785
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "LoopScope",
                        "StructuredGraph",
                        "TimerKey"
                    ],
                    "llm_response_time": 4577,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "verifyEdges": {
                    "target_classes": [
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.09849045847755847
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.09849045847755847
                        },
                        {
                            "class_name": "StructuredGraph",
                            "similarity_score": 0.5233301525736133
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "StructuredGraph",
                        "TimerKey",
                        "TimerKey"
                    ],
                    "llm_response_time": 3766,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "registerNode": {
                    "target_classes": [
                        {
                            "class_name": "LoopScope",
                            "similarity_score": 0.20830926052166412
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.07160576984382794
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.07160576984382794
                        },
                        {
                            "class_name": "StructuredGraph",
                            "similarity_score": 0.4224369441646672
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "LoopScope",
                        "StructuredGraph",
                        "TimerKey"
                    ],
                    "llm_response_time": 3757,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "appendInvoke": {
                    "target_classes": [
                        {
                            "class_name": "MethodScope",
                            "similarity_score": 0.28307298659250074
                        },
                        {
                            "class_name": "LoopScope",
                            "similarity_score": 0.14626261707736188
                        },
                        {
                            "class_name": "InvokeData",
                            "similarity_score": 0.20373864130857494
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.10586970968934838
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.10586970968934838
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "InvokeData",
                        "MethodScope",
                        "LoopScope"
                    ],
                    "llm_response_time": 3871,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                },
                "maybeMarkUnsafeAccess": {
                    "target_classes": [
                        {
                            "class_name": "EncodedGraph",
                            "similarity_score": 0.4001606503634394
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.12406297243467145
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.12406297243467145
                        },
                        {
                            "class_name": "StructuredGraph",
                            "similarity_score": 0.5597746628670203
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "EncodedGraph",
                        "StructuredGraph",
                        "TimerKey"
                    ],
                    "llm_response_time": 3647,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "appendInvokable": {
                    "target_classes": [
                        {
                            "class_name": "MethodScope",
                            "similarity_score": 0.3263049894842662
                        },
                        {
                            "class_name": "LoopScope",
                            "similarity_score": 0.21353500561291974
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.10524566699352861
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.10524566699352861
                        },
                        {
                            "class_name": "StructuredGraph",
                            "similarity_score": 0.5004812239648713
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "MethodScope",
                        "LoopScope",
                        "StructuredGraph"
                    ],
                    "llm_response_time": 3355,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "addFloatingNode": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2161,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "skipDirectEdge": {
                    "target_classes": [
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.4968714206658868
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.47897394560986695
                        },
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.5963895194702861
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.48300595272988794
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.2945337474395688
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.3641992032701598
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.4441021196207434
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.53772376330104
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.400862284393452
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.4210132769892264
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.3522503713819042
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.3086959897127302
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.5431427755301992
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.503575537239244
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.3106185417936357
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.3055599831220931
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.4805219251333785
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.24722397295073154
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.32258400792529573
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.22477661242983915
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.5213104225250147
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.3964462491214061
                        },
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.35605453008949955
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.2994267673387434
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.5537032310884079
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.3719705999783525
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.28415519163323794
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.26547753320306844
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.3726099325215904
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.5531656248739071
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.34152276152480504
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.41229445762405853
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.2825173871634558
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.3463190999507591
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.39815047348796073
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.23575187389599073
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.3985983709713417
                        },
                        {
                            "class_name": "QueryParserUtil",
                            "similarity_score": 0.3341027651173684
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.31763662310415613
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.3824970719625343
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.32784075901393855
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.37566346029865594
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.4227750710872371
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.5097424475921719
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.4364497384090955
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.27051337992900504
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.2784366496110545
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.4313362937940037
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.41341480667427033
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.590827685183676
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.46372833812386466
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.5128598690123816
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.3353134415105184
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.3687581224047675
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.2540508466219365
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.3403883206353555
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.39995748277440313
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.32212031161716265
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.4657731765833369
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.3068097277270814
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.32944754490938255
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.468662861573167
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.33436193924183627
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.3294706980608904
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.3034988530206672
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.619178804321603
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.5893258992500371
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.35405491521662596
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.5538103586760578
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.3214896996506564
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.2842677298698261
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.3962631718729963
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.24750260570185026
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.2792798810917233
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.21596311056865927
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.5072021321490068
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.29582824304337896
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.43173829881079545
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.38059531292561494
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.30891931136357054
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.29607510742069215
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.19002603947197863
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.39006278960985613
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.5629943861882617
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.2109777446496761
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.17728907802904637
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.4538367009258343
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.30146559850876153
                        },
                        {
                            "class_name": "UnsafeCopyNode",
                            "similarity_score": 0.15314274656218146
                        },
                        {
                            "class_name": "UnsafeMemoryUtil",
                            "similarity_score": 0.33828371750228825
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.6062996296546214
                        },
                        {
                            "class_name": "ReversePostOrder",
                            "similarity_score": 0.42332405610697693
                        },
                        {
                            "class_name": "ExitException",
                            "similarity_score": 0.23308398052535564
                        },
                        {
                            "class_name": "DB",
                            "similarity_score": 0.34715692170379175
                        },
                        {
                            "class_name": "StackElement",
                            "similarity_score": 0.3176386235327599
                        },
                        {
                            "class_name": "StampTool",
                            "similarity_score": 0.4580814036804831
                        },
                        {
                            "class_name": "AtomicBoolean",
                            "similarity_score": 0.28654944086840567
                        },
                        {
                            "class_name": "AtomicInteger",
                            "similarity_score": 0.26762642691346855
                        },
                        {
                            "class_name": "AtomicLong",
                            "similarity_score": 0.249551413223379
                        },
                        {
                            "class_name": "AtomicPointer",
                            "similarity_score": 0.2759645847498673
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "GraphUtil",
                        "InliningUtilities",
                        "AccumulativeInlineScope"
                    ],
                    "llm_response_time": 5765,
                    "similarity_computation_time": 48,
                    "similarity_metric": "cosine"
                },
                "releaseFloatingNode": {
                    "target_classes": [
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.09957604472580935
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.09957604472580935
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "TimerKey",
                        "TimerKey"
                    ],
                    "llm_response_time": 1737,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "handleInvoke": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2677,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "allocateFloatingNode": {
                    "target_classes": [
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.11929131964872254
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.11929131964872254
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "TimerKey",
                        "TimerKey"
                    ],
                    "llm_response_time": 1993,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "decodeFloatingNode": {
                    "target_classes": [
                        {
                            "class_name": "MethodScope",
                            "similarity_score": 0.5142152132345988
                        },
                        {
                            "class_name": "LoopScope",
                            "similarity_score": 0.46992873273026853
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.4489860124797199
                        },
                        {
                            "class_name": "TimerKey",
                            "similarity_score": 0.4489860124797199
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "MethodScope",
                        "LoopScope",
                        "TimerKey"
                    ],
                    "llm_response_time": 3548,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "7dfe0687b15825a8d2ee93d295e3a55bdf28250f",
        "url": "https://github.com/oracle/graal/commit/7dfe0687b15825a8d2ee93d295e3a55bdf28250f",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public getSizeInBytes() : int extracted from private parseIntegerConstantValue(info PropertyInfo<Object>) : void in class com.oracle.svm.hosted.c.query.QueryResultParser & moved to class com.oracle.svm.hosted.c.info.SizableInfo",
            "leftSideLocations": [
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/c/query/QueryResultParser.java",
                    "startLine": 187,
                    "endLine": 202,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "private parseIntegerConstantValue(info PropertyInfo<Object>) : void"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/c/query/QueryResultParser.java",
                    "startLine": 189,
                    "endLine": 189,
                    "startColumn": 9,
                    "endColumn": 81,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/c/info/SizableInfo.java",
                    "startLine": 96,
                    "endLine": 98,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public getSizeInBytes() : int"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/c/info/SizableInfo.java",
                    "startLine": 97,
                    "endLine": 97,
                    "startColumn": 9,
                    "endColumn": 44,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/c/query/QueryResultParser.java",
                    "startLine": 208,
                    "endLine": 219,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "private parseIntegerConstantValue(info PropertyInfo<Object>) : void"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/c/query/QueryResultParser.java",
                    "startLine": 213,
                    "endLine": 213,
                    "startColumn": 23,
                    "endColumn": 46,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "parent.getSizeInBytes()"
                }
            ],
            "isStatic": false
        },
        "ref_id": 440,
        "extraction_results": {
            "success": true,
            "newCommitHash": "b00fed42af5f6d33ccdca427621175cd5e2218c2",
            "newBranchName": "extract-getSizeInBytes-parseIntegerConstantValue-324b856"
        },
        "telemetry": {
            "id": "0dcad55e-4e26-4554-a8a0-c47d9663f715",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 189,
                "lineStart": 58,
                "lineEnd": 246,
                "bodyLineStart": 58,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/c/query/QueryResultParser.java",
                "sourceCode": "/**\n * Parses query result described in {@link QueryResultFormat}.\n */\npublic final class QueryResultParser extends NativeInfoTreeVisitor {\n\n    private final Map<String, String> idToResult;\n\n    private QueryResultParser(NativeLibraries nativeLibs) {\n        super(nativeLibs);\n        this.idToResult = new HashMap<>();\n    }\n\n    public static List<String> parse(NativeLibraries nativeLibs, NativeCodeInfo nativeCodeInfo, InputStream source) {\n        QueryResultParser parser = new QueryResultParser(nativeLibs);\n        List<String> lines = FileUtils.readAllLines(source);\n        for (String line : lines) {\n            String[] keyValuePair = line.split(QueryResultFormat.DELIMINATOR);\n            assert keyValuePair.length == 2;\n            parser.idToResult.put(keyValuePair[0], keyValuePair[1]);\n        }\n\n        nativeCodeInfo.accept(parser);\n        return lines;\n    }\n\n    @Override\n    protected void visitConstantInfo(ConstantInfo constantInfo) {\n        switch (constantInfo.getKind()) {\n            case INTEGER:\n                parseIntegerProperty(constantInfo.getSizeInfo());\n                parseSignedness(constantInfo.getSignednessInfo());\n                parseIntegerConstantValue(constantInfo.getValueInfo());\n\n                /*\n                 * From the point of view of the C compiler, plain #define constants have the type\n                 * int and therefore size 4. But sometimes we want to access such values as short or\n                 * byte to avoid casts. Check the actual value of the constant, and if it fits the\n                 * declared type of the constant, then change the actual size to the declared size.\n                 */\n                JavaKind returnKind = AccessorInfo.getReturnType(constantInfo.getAnnotatedElement()).getJavaKind();\n                if (returnKind == JavaKind.Object) {\n                    returnKind = nativeLibs.getTarget().wordJavaKind;\n                }\n                int declaredSize = getSizeInBytes(returnKind);\n                int actualSize = getSizeInBytes(constantInfo);\n                if (declaredSize != actualSize) {\n                    long value = (long) constantInfo.getValueInfo().getProperty();\n                    if (value >= returnKind.getMinValue() && value <= returnKind.getMaxValue()) {\n                        constantInfo.getSizeInfo().setProperty(declaredSize);\n                    }\n                }\n\n                break;\n            case POINTER:\n                parseIntegerProperty(constantInfo.getSizeInfo());\n                parseIntegerConstantValue(constantInfo.getValueInfo());\n                break;\n            case FLOAT:\n                parseIntegerProperty(constantInfo.getSizeInfo());\n                parseFloatValue(constantInfo.getValueInfo());\n                break;\n            case STRING:\n                parseStringValue(constantInfo.getValueInfo());\n                break;\n            case BYTEARRAY:\n                parseByteArrayValue(constantInfo.getValueInfo());\n                break;\n            default:\n                throw shouldNotReachHereUnexpectedInput(constantInfo.getKind()); // ExcludeFromJacocoGeneratedReport\n        }\n    }\n\n    @Override\n    public void visitStructInfo(StructInfo structInfo) {\n        if (!structInfo.isIncomplete()) {\n            parseIntegerProperty(structInfo.getSizeInfo());\n        }\n        processChildren(structInfo);\n    }\n\n    @Override\n    protected void visitRawStructureInfo(RawStructureInfo info) {\n        /* Nothing to do, do not visit children. */\n    }\n\n    @Override\n    public void visitStructFieldInfo(StructFieldInfo fieldInfo) {\n        parseIntegerProperty(fieldInfo.getSizeInfo());\n        parseIntegerProperty(fieldInfo.getOffsetInfo());\n\n        if (fieldInfo.getKind() == ElementKind.INTEGER) {\n            parseSignedness(fieldInfo.getSignednessInfo());\n        }\n    }\n\n    @Override\n    public void visitStructBitfieldInfo(StructBitfieldInfo bitfieldInfo) {\n        parseIntegerProperty(bitfieldInfo.getByteOffsetInfo());\n        parseIntegerProperty(bitfieldInfo.getStartBitInfo());\n        parseIntegerProperty(bitfieldInfo.getEndBitInfo());\n        parseSignedness(bitfieldInfo.getSignednessInfo());\n    }\n\n    @Override\n    public void visitPointerToInfo(PointerToInfo pointerToInfo) {\n        parseIntegerProperty(pointerToInfo.getSizeInfo());\n\n        if (pointerToInfo.getKind() == ElementKind.INTEGER) {\n            parseSignedness(pointerToInfo.getSignednessInfo());\n        }\n    }\n\n    @Override\n    public void visitRawPointerToInfo(RawPointerToInfo pointerToInfo) {\n        /* Nothing to do, do not visit children. */\n    }\n\n    @Override\n    protected void visitEnumConstantInfo(EnumConstantInfo constantInfo) {\n        assert constantInfo.getKind() == ElementKind.INTEGER;\n        parseIntegerProperty(constantInfo.getSizeInfo());\n        parseSignedness(constantInfo.getSignednessInfo());\n        parseIntegerConstantValue(constantInfo.getValueInfo());\n    }\n\n    private void parseSignedness(PropertyInfo<SignednessValue> info) {\n        info.setProperty(SignednessValue.valueOf(stringLiteral(info)));\n    }\n\n    private void parseIntegerConstantValue(PropertyInfo<Object> info) {\n        boolean isUnsigned = ((SizableInfo) info.getParent()).isUnsigned();\n        int size = getSizeInBytes((SizableInfo) info.getParent());\n        String hex = idToResult.get(info.getUniqueID());\n        int hexSize = hex.length() / 2;\n\n        if (hexSize < size) {\n            hex = unsignedExtendToSize(size, hex);\n        }\n\n        if (isUnsigned) {\n            parseHexToLong(info, hex);\n        } else {\n            parseSigned(info, hex);\n        }\n    }\n\n    private int getSizeInBytes(SizableInfo parent) {\n        int size = parent.getSizeInfo().getProperty();\n        return size;\n    }\n\n    private void parseFloatValue(PropertyInfo<Object> info) {\n        String str = idToResult.get(info.getUniqueID());\n        double value = Double.parseDouble(str);\n        info.setProperty(value);\n    }\n\n    private void parseStringValue(PropertyInfo<Object> info) {\n        info.setProperty(stringLiteral(info));\n    }\n\n    private String stringLiteral(ElementInfo info) {\n        String str = idToResult.get(info.getUniqueID());\n        if (str.startsWith(QueryResultFormat.STRING_MARKER) && str.endsWith(QueryResultFormat.STRING_MARKER)) {\n            return str.substring(QueryResultFormat.STRING_MARKER.length(), str.length() - QueryResultFormat.STRING_MARKER.length());\n        } else {\n            addError(\"String constant not deliminated correctly\", info);\n            return \"\";\n        }\n    }\n\n    private void parseByteArrayValue(PropertyInfo<Object> info) {\n        info.setProperty(byteArrayLiteral(info));\n    }\n\n    private byte[] byteArrayLiteral(ElementInfo info) {\n        String str = stringLiteral(info);\n        if (!str.isEmpty()) {\n            return str.getBytes(Charset.forName(\"UTF-8\"));\n        } else {\n            return new byte[0];\n        }\n    }\n\n    private void parseIntegerProperty(PropertyInfo<Integer> info) {\n        int value = Integer.parseInt(idToResult.get(info.getUniqueID()));\n        info.setProperty(value);\n    }\n}",
                "methodCount": 19
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 203,
                        "lineEnd": 206,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getSizeInBytes to class SizableInfo",
                        "description": "Move method getSizeInBytes to com.oracle.svm.hosted.c.info.SizableInfo\nRationale: The method getSizeInBytes() directly interacts with the properties defined in SizableInfo, specifically calling getSizeInfo(). By placing the method inside SizableInfo, it can have better encapsulation and direct access to the relevant properties without needing to pass an instance as a parameter. This change promotes better object-oriented design principles, making SizableInfo responsible for its own size-related calculations.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "parseSignedness",
                            "method_signature": "private void parseSignedness(PropertyInfo<SignednessValue> info)",
                            "target_class": "PropertyInfo",
                            "rationale": "The parseSignedness method deals specifically with setting the signedness property of a PropertyInfo object, making it more appropriate for this class."
                        },
                        {
                            "method_name": "parseIntegerConstantValue",
                            "method_signature": "private void parseIntegerConstantValue(PropertyInfo<Object> info)",
                            "target_class": "PropertyInfo",
                            "rationale": "This method deals with parsing and setting the value of a PropertyInfo object. It should be moved to the PropertyInfo class for better encapsulation."
                        },
                        {
                            "method_name": "parseFloatValue",
                            "method_signature": "private void parseFloatValue(PropertyInfo<Object> info)",
                            "target_class": "PropertyInfo",
                            "rationale": "The parseFloatValue method is related to setting a float value to the PropertyInfo object, thus it should reside in the PropertyInfo class."
                        },
                        {
                            "method_name": "parseStringValue",
                            "method_signature": "private void parseStringValue(PropertyInfo<Object> info)",
                            "target_class": "PropertyInfo",
                            "rationale": "This method is focused on setting the string value of a PropertyInfo object, making PropertyInfo a more suitable class for it."
                        },
                        {
                            "method_name": "stringLiteral",
                            "method_signature": "private String stringLiteral(ElementInfo info)",
                            "target_class": "ElementInfo",
                            "rationale": "The stringLiteral method operates on an ElementInfo object, making it more logical to place it in the ElementInfo class."
                        },
                        {
                            "method_name": "parseByteArrayValue",
                            "method_signature": "private void parseByteArrayValue(PropertyInfo<Object> info)",
                            "target_class": "PropertyInfo",
                            "rationale": "The method is responsible for parsing and setting the byte array value of PropertyInfo objects, thus it belongs to the PropertyInfo class."
                        },
                        {
                            "method_name": "byteArrayLiteral",
                            "method_signature": "private byte[] byteArrayLiteral(ElementInfo info)",
                            "target_class": "ElementInfo",
                            "rationale": "Since the method is focused on converting ElementInfo data into a byte array, it fits better within the ElementInfo class."
                        },
                        {
                            "method_name": "parseIntegerProperty",
                            "method_signature": "private void parseIntegerProperty(PropertyInfo<Integer> info)",
                            "target_class": "PropertyInfo",
                            "rationale": "The method is for setting integer properties on PropertyInfo objects, so it should reside in the PropertyInfo class."
                        },
                        {
                            "method_name": "getSizeInBytes",
                            "method_signature": "private int getSizeInBytes(SizableInfo parent)",
                            "target_class": "SizableInfo",
                            "rationale": "The getSizeInBytes method is specifically used to get the size of SizableInfo objects. Hence, it should be placed in the SizableInfo class."
                        }
                    ],
                    "llm_response_time": 7470
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "parse",
                            "method_signature": "public static List<String> parse(NativeLibraries nativeLibs, NativeCodeInfo nativeCodeInfo, InputStream source)",
                            "target_class": "FileUtils",
                            "rationale": "The `parse` method reads lines from an InputStream using `FileUtils.readAllLines()`, making it centered around file reading and parsing rather than specifically on visiting or processing native information tree structures."
                        }
                    ],
                    "llm_response_time": 2496
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "parseFloatValue",
                            "method_signature": "private void parseFloatValue(PropertyInfo<Object> info)",
                            "target_class": "PropertyInfo",
                            "rationale": "The method `parseFloatValue` works on the PropertyInfo object and is better suited to be within the PropertyInfo class to ensure separation of concerns and make the QueryResultParser class more focused on parsing queries."
                        },
                        {
                            "method_name": "parseStringValue",
                            "method_signature": "private void parseStringValue(PropertyInfo<Object> info)",
                            "target_class": "PropertyInfo",
                            "rationale": "The method `parseStringValue` handles the string property of PropertyInfo. Hence, it should be part of the PropertyInfo class, which will promote encapsulation."
                        },
                        {
                            "method_name": "parseByteArrayValue",
                            "method_signature": "private void parseByteArrayValue(PropertyInfo<Object> info)",
                            "target_class": "PropertyInfo",
                            "rationale": "The method `parseByteArrayValue` deals with byte array parsing from the PropertyInfo object. Having it in the PropertyInfo class will centralize the properties' parsing logic."
                        },
                        {
                            "method_name": "parseIntegerConstantValue",
                            "method_signature": "private void parseIntegerConstantValue(PropertyInfo<Object> info)",
                            "target_class": "PropertyInfo",
                            "rationale": "The `parseIntegerConstantValue` method works directly with properties of the PropertyInfo class. Moving it there aligns with OOP principles of grouping behavior close to the data it operates on."
                        },
                        {
                            "method_name": "parseSignedness",
                            "method_signature": "private void parseSignedness(PropertyInfo<SignednessValue> info)",
                            "target_class": "PropertyInfo",
                            "rationale": "The method `parseSignedness` is specific to the PropertyInfo attributes and should be managed within the PropertyInfo class to maintain coherence and encapsulation."
                        },
                        {
                            "method_name": "parseIntegerProperty",
                            "method_signature": "private void parseIntegerProperty(PropertyInfo<Integer> info)",
                            "target_class": "PropertyInfo",
                            "rationale": "The `parseIntegerProperty` method interacts mainly with the PropertyInfo class and focuses on parsing integer properties. Thus, it should be part of the PropertyInfo class for better cohesion."
                        },
                        {
                            "method_name": "getSizeInBytes",
                            "method_signature": "private int getSizeInBytes(SizableInfo parent)",
                            "target_class": "SizableInfo",
                            "rationale": "The `getSizeInBytes` method essentially deals with size information that is prevalent in SizableInfo. Moving it to SizableInfo will better encapsulate the data related to size."
                        },
                        {
                            "method_name": "parseSigned",
                            "method_signature": "private void parseSigned(PropertyInfo<Object> info, String hex)",
                            "target_class": "PropertyInfo",
                            "rationale": "The `parseSigned` method involves parsing operations specific to PropertyInfo and is closely tied to its attributes. Moving it to the PropertyInfo class improves cohesion."
                        },
                        {
                            "method_name": "unsignedExtendToSize",
                            "method_signature": "private String unsignedExtendToSize(int size, String hex)",
                            "target_class": "Utility",
                            "rationale": "The `unsignedExtendToSize` method is more utility-based and can serve a broader scope. Therefore, it is suitable to move it into a Utility class to promote reuse."
                        },
                        {
                            "method_name": "parseHexToLong",
                            "method_signature": "private void parseHexToLong(PropertyInfo<Object> info, String hex)",
                            "target_class": "Utility",
                            "rationale": "The `parseHexToLong` method performs a conversion that can be broadly useful across different classes and should be placed in a Utility class for shared use."
                        },
                        {
                            "method_name": "stringLiteral",
                            "method_signature": "private String stringLiteral(ElementInfo info)",
                            "target_class": "Utility",
                            "rationale": "The `stringLiteral` method is utility-based and focuses on extracting string literals, a function that can be reused across different classes. Moving it to a Utility class is more appropriate."
                        },
                        {
                            "method_name": "byteArrayLiteral",
                            "method_signature": "private byte[] byteArrayLiteral(ElementInfo info)",
                            "target_class": "Utility",
                            "rationale": "The `byteArrayLiteral` method deals with byte array extraction and processing, a typical utility function suitable for a Utility class. This enhances code reuse and separation of concerns."
                        }
                    ],
                    "llm_response_time": 9729
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "parse",
                            "method_signature": "public static parse(NativeLibraries nativeLibs, NativeCodeInfo nativeCodeInfo, InputStream source)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "parseSignedness",
                            "method_signature": "private parseSignedness(PropertyInfo<SignednessValue> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "parseIntegerConstantValue",
                            "method_signature": "private parseIntegerConstantValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getSizeInBytes",
                            "method_signature": "private getSizeInBytes(SizableInfo parent)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "parseFloatValue",
                            "method_signature": "private parseFloatValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "parseStringValue",
                            "method_signature": "private parseStringValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "stringLiteral",
                            "method_signature": "private stringLiteral(ElementInfo info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "parseByteArrayValue",
                            "method_signature": "private parseByteArrayValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "parseIntegerProperty",
                            "method_signature": "private parseIntegerProperty(PropertyInfo<Integer> info)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "parse",
                            "method_signature": "public static parse(NativeLibraries nativeLibs, NativeCodeInfo nativeCodeInfo, InputStream source)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getSizeInBytes",
                            "method_signature": "private getSizeInBytes(SizableInfo parent)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "parseFloatValue",
                            "method_signature": "private parseFloatValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "parseSignedness",
                            "method_signature": "private parseSignedness(PropertyInfo<SignednessValue> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "parseStringValue",
                            "method_signature": "private parseStringValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "parseByteArrayValue",
                            "method_signature": "private parseByteArrayValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "parseIntegerProperty",
                            "method_signature": "private parseIntegerProperty(PropertyInfo<Integer> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "stringLiteral",
                            "method_signature": "private stringLiteral(ElementInfo info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "parseIntegerConstantValue",
                            "method_signature": "private parseIntegerConstantValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public static parse(NativeLibraries nativeLibs, NativeCodeInfo nativeCodeInfo, InputStream source)": {
                        "first": {
                            "method_name": "parse",
                            "method_signature": "public static parse(NativeLibraries nativeLibs, NativeCodeInfo nativeCodeInfo, InputStream source)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.45642992663285104
                    },
                    "private getSizeInBytes(SizableInfo parent)": {
                        "first": {
                            "method_name": "getSizeInBytes",
                            "method_signature": "private getSizeInBytes(SizableInfo parent)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.49355227696373993
                    },
                    "private parseFloatValue(PropertyInfo<Object> info)": {
                        "first": {
                            "method_name": "parseFloatValue",
                            "method_signature": "private parseFloatValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5712072194706663
                    },
                    "private parseSignedness(PropertyInfo<SignednessValue> info)": {
                        "first": {
                            "method_name": "parseSignedness",
                            "method_signature": "private parseSignedness(PropertyInfo<SignednessValue> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5874672636305188
                    },
                    "private parseStringValue(PropertyInfo<Object> info)": {
                        "first": {
                            "method_name": "parseStringValue",
                            "method_signature": "private parseStringValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5874672636305188
                    },
                    "private parseByteArrayValue(PropertyInfo<Object> info)": {
                        "first": {
                            "method_name": "parseByteArrayValue",
                            "method_signature": "private parseByteArrayValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5874672636305188
                    },
                    "private parseIntegerProperty(PropertyInfo<Integer> info)": {
                        "first": {
                            "method_name": "parseIntegerProperty",
                            "method_signature": "private parseIntegerProperty(PropertyInfo<Integer> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6204490812963562
                    },
                    "private stringLiteral(ElementInfo info)": {
                        "first": {
                            "method_name": "stringLiteral",
                            "method_signature": "private stringLiteral(ElementInfo info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6225403271258195
                    },
                    "private parseIntegerConstantValue(PropertyInfo<Object> info)": {
                        "first": {
                            "method_name": "parseIntegerConstantValue",
                            "method_signature": "private parseIntegerConstantValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6724422852081126
                    }
                },
                "voyage": {
                    "private getSizeInBytes(SizableInfo parent)": {
                        "first": {
                            "method_name": "getSizeInBytes",
                            "method_signature": "private getSizeInBytes(SizableInfo parent)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.30088789328427024
                    },
                    "private parseFloatValue(PropertyInfo<Object> info)": {
                        "first": {
                            "method_name": "parseFloatValue",
                            "method_signature": "private parseFloatValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.42964950066285995
                    },
                    "private stringLiteral(ElementInfo info)": {
                        "first": {
                            "method_name": "stringLiteral",
                            "method_signature": "private stringLiteral(ElementInfo info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.48006913152749076
                    },
                    "private parseSignedness(PropertyInfo<SignednessValue> info)": {
                        "first": {
                            "method_name": "parseSignedness",
                            "method_signature": "private parseSignedness(PropertyInfo<SignednessValue> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4835935652881498
                    },
                    "private parseByteArrayValue(PropertyInfo<Object> info)": {
                        "first": {
                            "method_name": "parseByteArrayValue",
                            "method_signature": "private parseByteArrayValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5110324863502865
                    },
                    "private parseStringValue(PropertyInfo<Object> info)": {
                        "first": {
                            "method_name": "parseStringValue",
                            "method_signature": "private parseStringValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5222371380759763
                    },
                    "private parseIntegerProperty(PropertyInfo<Integer> info)": {
                        "first": {
                            "method_name": "parseIntegerProperty",
                            "method_signature": "private parseIntegerProperty(PropertyInfo<Integer> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5576111680209782
                    },
                    "private parseIntegerConstantValue(PropertyInfo<Object> info)": {
                        "first": {
                            "method_name": "parseIntegerConstantValue",
                            "method_signature": "private parseIntegerConstantValue(PropertyInfo<Object> info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5623028709108451
                    },
                    "public static parse(NativeLibraries nativeLibs, NativeCodeInfo nativeCodeInfo, InputStream source)": {
                        "first": {
                            "method_name": "parse",
                            "method_signature": "public static parse(NativeLibraries nativeLibs, NativeCodeInfo nativeCodeInfo, InputStream source)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6554109564550454
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public static parse(NativeLibraries nativeLibs, NativeCodeInfo nativeCodeInfo, InputStream source)",
                        "private parseIntegerConstantValue(PropertyInfo<Object> info)",
                        "private getSizeInBytes(SizableInfo parent)",
                        "private parseFloatValue(PropertyInfo<Object> info)",
                        "private parseStringValue(PropertyInfo<Object> info)",
                        "private parseByteArrayValue(PropertyInfo<Object> info)",
                        "private parseIntegerProperty(PropertyInfo<Integer> info)",
                        "private stringLiteral(ElementInfo info)",
                        "private parseSignedness(PropertyInfo<SignednessValue> info)"
                    ],
                    "llm_response_time": 6430
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public static parse(NativeLibraries nativeLibs, NativeCodeInfo nativeCodeInfo, InputStream source)",
                        "private getSizeInBytes(SizableInfo parent)",
                        "private parseFloatValue(PropertyInfo<Object> info)",
                        "private parseSignedness(PropertyInfo<SignednessValue> info)",
                        "private parseStringValue(PropertyInfo<Object> info)"
                    ],
                    "llm_response_time": 4309
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public static parse(NativeLibraries nativeLibs, NativeCodeInfo nativeCodeInfo, InputStream source)",
                        "private getSizeInBytes(SizableInfo parent)",
                        "private parseFloatValue(PropertyInfo<Object> info)"
                    ],
                    "llm_response_time": 6309
                },
                "voyage": {
                    "priority_method_names": [
                        "public static parse(NativeLibraries nativeLibs, NativeCodeInfo nativeCodeInfo, InputStream source)",
                        "private getSizeInBytes(SizableInfo parent)",
                        "private parseIntegerConstantValue(PropertyInfo<Object> info)",
                        "private stringLiteral(ElementInfo info)",
                        "private parseFloatValue(PropertyInfo<Object> info)",
                        "private parseStringValue(PropertyInfo<Object> info)",
                        "private parseSignedness(PropertyInfo<SignednessValue> info)",
                        "private parseByteArrayValue(PropertyInfo<Object> info)",
                        "private parseIntegerProperty(PropertyInfo<Integer> info)"
                    ],
                    "llm_response_time": 7564
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private getSizeInBytes(SizableInfo parent)",
                        "private stringLiteral(ElementInfo info)",
                        "private parseByteArrayValue(PropertyInfo<Object> info)",
                        "private parseFloatValue(PropertyInfo<Object> info)",
                        "private parseSignedness(PropertyInfo<SignednessValue> info)"
                    ],
                    "llm_response_time": 3725
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private getSizeInBytes(SizableInfo parent)",
                        "private stringLiteral(ElementInfo info)",
                        "private parseFloatValue(PropertyInfo<Object> info)"
                    ],
                    "llm_response_time": 3626
                }
            },
            "targetClassMap": {
                "parse": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4488,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "getSizeInBytes": {
                    "target_classes": [
                        {
                            "class_name": "SizableInfo",
                            "similarity_score": 0.2758671766342886
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SizableInfo"
                    ],
                    "llm_response_time": 1625,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "parseFloatValue": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4235,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "parseSignedness": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3864,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "parseStringValue": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1539,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "parseByteArrayValue": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1548,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "parseIntegerProperty": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2268,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "stringLiteral": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2557,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "parseIntegerConstantValue": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2900,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "c1fc3905c614510bae727216ee3066ae99d45a3d",
        "url": "https://github.com/oracle/graal/commit/c1fc3905c614510bae727216ee3066ae99d45a3d",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public checkExpiration() : void extracted from public apply(closure BlockIteratorClosure<StateT>, start HIRBlock, initialState StateT, stopAtBlock Predicate<HIRBlock>) : EconomicMap<FixedNode,StateT> in class jdk.graal.compiler.phases.graph.ReentrantBlockIterator & moved to class jdk.graal.compiler.core.common.util.CompilationAlarm",
            "leftSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/phases/graph/ReentrantBlockIterator.java",
                    "startLine": 131,
                    "endLine": 202,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "public apply(closure BlockIteratorClosure<StateT>, start HIRBlock, initialState StateT, stopAtBlock Predicate<HIRBlock>) : EconomicMap<FixedNode,StateT>"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/phases/graph/ReentrantBlockIterator.java",
                    "startLine": 149,
                    "endLine": 149,
                    "startColumn": 17,
                    "endColumn": 117,
                    "codeElementType": "THROW_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/phases/graph/ReentrantBlockIterator.java",
                    "startLine": 147,
                    "endLine": 150,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/phases/graph/ReentrantBlockIterator.java",
                    "startLine": 147,
                    "endLine": 150,
                    "startColumn": 48,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/core/common/util/CompilationAlarm.java",
                    "startLine": 99,
                    "endLine": 106,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public checkExpiration() : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/core/common/util/CompilationAlarm.java",
                    "startLine": 104,
                    "endLine": 104,
                    "startColumn": 13,
                    "endColumn": 94,
                    "codeElementType": "THROW_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/core/common/util/CompilationAlarm.java",
                    "startLine": 103,
                    "endLine": 105,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/core/common/util/CompilationAlarm.java",
                    "startLine": 103,
                    "endLine": 105,
                    "startColumn": 27,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/phases/graph/ReentrantBlockIterator.java",
                    "startLine": 129,
                    "endLine": 196,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "public apply(closure BlockIteratorClosure<StateT>, start HIRBlock, initialState StateT, stopAtBlock Predicate<HIRBlock>) : EconomicMap<FixedNode,StateT>"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/phases/graph/ReentrantBlockIterator.java",
                    "startLine": 144,
                    "endLine": 144,
                    "startColumn": 13,
                    "endColumn": 47,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "compilationAlarm.checkExpiration()"
                }
            ],
            "isStatic": false
        },
        "ref_id": 476,
        "extraction_results": {
            "success": true,
            "newCommitHash": "191a54eba4ada16612d3c115c14e991cf0941fa6",
            "newBranchName": "extract-checkExpiration-apply-c8e9e12"
        },
        "telemetry": {
            "id": "1731318e-954a-4926-9d94-12050795dfe9",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 210,
                "lineStart": 48,
                "lineEnd": 257,
                "bodyLineStart": 48,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/phases/graph/ReentrantBlockIterator.java",
                "sourceCode": "public final class ReentrantBlockIterator {\n\n    public static class LoopInfo<StateT> {\n\n        public final List<StateT> endStates;\n        public final List<StateT> exitStates;\n\n        public LoopInfo(int endCount, int exitCount) {\n            endStates = new ArrayList<>(endCount);\n            exitStates = new ArrayList<>(exitCount);\n        }\n    }\n\n    /**\n     * Abstract base class for reverse post order iteration over the {@link ControlFlowGraph}.\n     */\n    public abstract static class BlockIteratorClosure<StateT> {\n\n        /**\n         * Create the initial state for the reverse post order iteration over the\n         * {@link ControlFlowGraph}.\n         */\n        protected abstract StateT getInitialState();\n\n        /**\n         * Process the current block with the current state during reverse post order iteration.\n         */\n        protected abstract StateT processBlock(HIRBlock block, StateT currentState);\n\n        /**\n         * Merge multiple states when processing {@link HIRBlock} starting with a\n         * {@link AbstractMergeNode}.\n         */\n        protected abstract StateT merge(HIRBlock merge, List<StateT> states);\n\n        /**\n         * Clone a state for a successor invocation of\n         * {@link BlockIteratorClosure#processBlock(HIRBlock, Object)}.\n         */\n        protected abstract StateT cloneState(StateT oldState);\n\n        /**\n         * Hook for subclasses to apply additional operations after\n         * {@link BlockIteratorClosure#cloneState(Object)} for successor blocks.\n         */\n        protected StateT afterSplit(@SuppressWarnings(\"unused\") HIRBlock successor, StateT oldState) {\n            return oldState;\n        }\n\n        protected List<StateT> processLoop(Loop<HIRBlock> loop, StateT initialState) {\n            return ReentrantBlockIterator.processLoop(this, loop, initialState).exitStates;\n        }\n    }\n\n    private ReentrantBlockIterator() {\n        // no instances allowed\n    }\n\n    public static <StateT> LoopInfo<StateT> processLoop(BlockIteratorClosure<StateT> closure, Loop<HIRBlock> loop, StateT initialState) {\n        EconomicMap<FixedNode, StateT> blockEndStates = apply(closure, loop.getHeader(), initialState, block -> !(block.getLoop() == loop || block.isLoopHeader()));\n\n        HIRBlock lh = loop.getHeader();\n        final int predCount = lh.getPredecessorCount();\n        LoopInfo<StateT> info = new LoopInfo<>(predCount - 1, loop.getLoopExits().size());\n        for (int i = 1; i < predCount; i++) {\n            StateT endState = blockEndStates.get(lh.getPredecessorAt(i).getEndNode());\n            // make sure all end states are unique objects\n            info.endStates.add(closure.cloneState(endState));\n        }\n        for (HIRBlock loopExit : loop.getLoopExits()) {\n            assert loopExit.getPredecessorCount() == 1 : Assertions.errorMessage(loop, loopExit);\n            assert blockEndStates.containsKey(loopExit.getBeginNode()) : loopExit.getBeginNode() + \" \" + blockEndStates;\n            StateT exitState = blockEndStates.get(loopExit.getBeginNode());\n            // make sure all exit states are unique objects\n            info.exitStates.add(closure.cloneState(exitState));\n        }\n        return info;\n    }\n\n    public static <StateT> void apply(BlockIteratorClosure<StateT> closure, HIRBlock start) {\n        apply(closure, start, closure.getInitialState(), null);\n    }\n\n    public static <StateT> EconomicMap<FixedNode, StateT> apply(BlockIteratorClosure<StateT> closure, HIRBlock start, StateT initialState, Predicate<HIRBlock> stopAtBlock) {\n        Deque<HIRBlock> blockQueue = new ArrayDeque<>();\n        /*\n         * States are stored on EndNodes before merges, and on BeginNodes after ControlSplitNodes.\n         */\n        EconomicMap<FixedNode, StateT> states = EconomicMap.create(Equivalence.IDENTITY);\n\n        StateT state = initialState;\n        HIRBlock current = start;\n\n        StructuredGraph graph = start.getBeginNode().graph();\n        CompilationAlarm compilationAlarm = CompilationAlarm.current();\n\n        while (true) { // TERMINATION ARGUMENT: processing all blocks reverse post order until end\n                       // of cfg or until a bailout is triggered because of a long compile\n            CompilationAlarm.checkProgress(start.getCfg().graph);\n            if (compilationAlarm.hasExpired()) {\n                double period = CompilationAlarm.Options.CompilationExpirationPeriod.getValue(graph.getOptions());\n                throw new PermanentBailoutException(\"Compilation exceeded %f seconds during CFG traversal\", period);\n            }\n            HIRBlock next = null;\n            if (stopAtBlock != null && stopAtBlock.test(current)) {\n                states.put(current.getBeginNode(), state);\n            } else {\n                state = closure.processBlock(current, state);\n\n                if (current.getSuccessorCount() == 0) {\n                    // nothing to do...\n                } else if (current.getSuccessorCount() == 1) {\n                    HIRBlock successor = current.getSuccessorAt(0);\n                    if (successor.isLoopHeader()) {\n                        if (current.isLoopEnd()) {\n                            // nothing to do... loop ends only lead to loop begins we've already\n                            // visited\n                            states.put(current.getEndNode(), state);\n                        } else {\n                            recurseIntoLoop(closure, blockQueue, states, state, successor);\n                        }\n                    } else if (current.getEndNode() instanceof AbstractEndNode) {\n                        AbstractEndNode end = (AbstractEndNode) current.getEndNode();\n\n                        // add the end node and see if the merge is ready for processing\n                        AbstractMergeNode merge = end.merge();\n                        if (allEndsVisited(states, current, merge)) {\n                            ArrayList<StateT> mergedStates = mergeStates(states, state, current, successor, merge);\n                            state = closure.merge(successor, mergedStates);\n                            next = successor;\n                        } else {\n                            assert !states.containsKey(end);\n                            states.put(end, state);\n                        }\n                    } else {\n                        next = successor;\n                    }\n                } else {\n                    next = processMultipleSuccessors(closure, blockQueue, states, state, current);\n                }\n            }\n\n            // get next queued block\n            if (next != null) {\n                current = next;\n            } else if (blockQueue.isEmpty()) {\n                return states;\n            } else {\n                current = blockQueue.removeFirst();\n                assert current.getPredecessorCount() == 1 : Assertions.errorMessage(current);\n                assert states.containsKey(current.getBeginNode());\n                state = states.removeKey(current.getBeginNode());\n            }\n        }\n    }\n\n    private void checkExpiration(CompilationAlarm compilationAlarm, StructuredGraph graph) {\n        if (compilationAlarm.hasExpired()) {\n            double period = CompilationAlarm.Options.CompilationExpirationPeriod.getValue(graph.getOptions());\n            throw new PermanentBailoutException(\"Compilation exceeded %f seconds during CFG traversal\", period);\n        }\n    }\n\n    private static <StateT> boolean allEndsVisited(EconomicMap<FixedNode, StateT> states, HIRBlock current, AbstractMergeNode merge) {\n        for (AbstractEndNode forwardEnd : merge.forwardEnds()) {\n            if (forwardEnd != current.getEndNode() && !states.containsKey(forwardEnd)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static <StateT> HIRBlock processMultipleSuccessors(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state,\n                    HIRBlock current) {\n        assert current.getSuccessorCount() > 1 : Assertions.errorMessageContext(\"current\", current);\n        for (int i = 1; i < current.getSuccessorCount(); i++) {\n            HIRBlock successor = current.getSuccessorAt(i);\n            blockQueue.addFirst(successor);\n            states.put(successor.getBeginNode(), closure.afterSplit(successor, closure.cloneState(state)));\n        }\n        return current.getSuccessorAt(0);\n    }\n\n    private static <StateT> ArrayList<StateT> mergeStates(EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock current, HIRBlock successor, AbstractMergeNode merge) {\n        ArrayList<StateT> mergedStates = new ArrayList<>(merge.forwardEndCount());\n        for (int i = 0; i < successor.getPredecessorCount(); i++) {\n            HIRBlock predecessor = successor.getPredecessorAt(i);\n            assert predecessor == current || states.containsKey(predecessor.getEndNode());\n            StateT endState = predecessor == current ? state : states.removeKey(predecessor.getEndNode());\n            mergedStates.add(endState);\n        }\n        return mergedStates;\n    }\n\n    private static <StateT> void recurseIntoLoop(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock successor) {\n        // recurse into the loop\n        Loop<HIRBlock> loop = successor.getLoop();\n        LoopBeginNode loopBegin = (LoopBeginNode) loop.getHeader().getBeginNode();\n        assert successor.getBeginNode() == loopBegin : Assertions.errorMessage(successor, successor.getBeginNode(), loopBegin);\n\n        List<StateT> exitStates = closure.processLoop(loop, state);\n\n        int i = 0;\n        assert loop.getLoopExits().size() == exitStates.size() : Assertions.errorMessage(loop, loop.getLoopExits(), exitStates);\n        for (HIRBlock exit : loop.getLoopExits()) {\n            states.put(exit.getBeginNode(), exitStates.get(i++));\n            blockQueue.addFirst(exit);\n        }\n    }\n}",
                "methodCount": 16
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 8,
                "candidates": [
                    {
                        "lineStart": 126,
                        "lineEnd": 128,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method apply to class ReentrantNodeIterator",
                        "description": "move method apply to PsiClass:ReentrantNodeIterator\nRationale: The method 'apply' is closely related to the existing static 'apply' method of the ReentrantNodeIterator class. Both methods perform operations on Nodes and Closures and share a similar naming convention. Since the primary functionality revolves around applying closures to nodes within the iterator pattern and ReentrantNodeIterator already encapsulates such logic, it is logical and consistent to move this method here.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 203,
                        "lineEnd": 208,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method checkExpiration to class CompilationAlarm",
                        "description": "Move method checkExpiration to jdk.graal.compiler.core.common.util.CompilationAlarm\nRationale: The method checkExpiration() relies heavily on CompilationAlarm's state and its options. Specifically, it calls the hasExpired() method on the CompilationAlarm instance and retrieves values from CompilationAlarm.Options, making it integral to the CompilationAlarm functionality. This suggests that the method would be more appropriately placed in the CompilationAlarm class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 210,
                        "lineEnd": 217,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method allEndsVisited to class VirtualUtil",
                        "description": "move method allEndsVisited to PsiClass:VirtualUtil\nRationale: The method `allEndsVisited` relates to traversing and checking conditions on node structures, which aligns with the existing methods in `VirtualUtil` that involve graph traversal and node checking functionalities. This suggests a natural fit for utilities dealing with virtual nodes and graphs. Additionally, the use of `EconomicMap` and `AbstractEndNode` is consistent with the other graph-related methods in `VirtualUtil`.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 241,
                        "lineEnd": 255,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method recurseIntoLoop to class ReentrantNodeIterator",
                        "description": "move method recurseIntoLoop to PsiClass:ReentrantNodeIterator\nRationale: The recurseIntoLoop method directly interacts with classes and methods defined within ReentrantNodeIterator, such as Loop, LoopBeginNode, and HIRBlock. The method's purpose and required functionality, such as managing block states and iterating through the loop blocks, align closely with the responsibilities of ReentrantNodeIterator. Thus, relocating this method here maintains cohesion and ensures that related functionalities are grouped logically.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 219,
                        "lineEnd": 228,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method processMultipleSuccessors to class ReentrantNodeIterator",
                        "description": "move method processMultipleSuccessors to PsiClass:ReentrantNodeIterator\nRationale: The method processMultipleSuccessors aligns closely with the existing methods in ReentrantNodeIterator. It involves processing states and successors within a graph structure, which is consistent with the functionality provided by the other methods in ReentrantNodeIterator. Further, NodeIteratorClosure in ReentrantNodeIterator already deals with splitting and iterating over nodes, making it the most appropriate target class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 105,
                        "lineEnd": 124,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method processLoop to class ReentrantNodeIterator",
                        "description": "move method processLoop to PsiClass:ReentrantNodeIterator\nRationale: The method processLoop(BlockIteratorClosure<StateT>, Loop<HIRBlock>, StateT) closely resembles the existing method processLoop(NodeIteratorClosure<StateT>, LoopBeginNode, StateT) already found in the ReentrantNodeIterator class. Both methods share similar functionalities related to processing loops and handling states within loops. Hence, it makes sense to move this method to the ReentrantNodeIterator class, where related loop processing logic is already encapsulated, promoting better cohesion and reducing redundancy.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 230,
                        "lineEnd": 239,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method mergeStates to class BundleSerializationUtils",
                        "description": "move method mergeStates to PsiClass:BundleSerializationUtils\nRationale: The method `mergeStates` relates to managing state and manipulating collections of state objects, tasks that align well with the purpose of `BundleSerializationUtils`, which already involves managing and serializing data structures. Adding this method to `BundleSerializationUtils` would consolidate utility functions related to state handling and serialization in a single class, providing better cohesion and organization.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 130,
                        "lineEnd": 201,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method apply to class LoopInfo",
                        "description": "move method apply to PsiClass:LoopInfo\nRationale: The method to be moved is heavily involved with CFG traversal and processing loop headers and ends, which aligns well with the responsibilities of the LoopInfo class. By placing the method in LoopInfo, it will have direct access to relevant state and methods, maintaining cohesion because it naturally deals with loop information and states during control flow graph traversals.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "checkExpiration",
                            "method_signature": "private void checkExpiration(CompilationAlarm compilationAlarm, StructuredGraph graph)",
                            "target_class": "CompilationAlarm",
                            "rationale": "The checkExpiration method is primarily concerned with checking the expiration of the compilation process, which falls under the responsibility of the CompilationAlarm class. Moving it there aligns the functionality better."
                        }
                    ],
                    "llm_response_time": 2049
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "checkExpiration",
                            "method_signature": "private void checkExpiration(CompilationAlarm compilationAlarm, StructuredGraph graph)",
                            "target_class": "CompilationAlarm",
                            "rationale": "The method checkExpiration() is closely related to the CompilationAlarm class and deals with its state and expiration. It would be more logical to encapsulate this behavior within the CompilationAlarm class itself."
                        }
                    ],
                    "llm_response_time": 2261
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "checkExpiration",
                            "method_signature": "private void checkExpiration(CompilationAlarm compilationAlarm, StructuredGraph graph)",
                            "target_class": "CompilationAlarm",
                            "rationale": "The checkExpiration method is closely tied to the functionality of CompilationAlarm. It makes more sense for the method to be part of CompilationAlarm to encapsulate the logic related to checking the expiration within the appropriate class."
                        }
                    ],
                    "llm_response_time": 1813
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "processLoop",
                            "method_signature": "public static processLoop(BlockIteratorClosure<StateT> closure, Loop<HIRBlock> loop, StateT initialState)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "apply",
                            "method_signature": "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "apply",
                            "method_signature": "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start, StateT initialState, Predicate<HIRBlock> stopAtBlock)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "checkExpiration",
                            "method_signature": "private checkExpiration(CompilationAlarm compilationAlarm, StructuredGraph graph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "allEndsVisited",
                            "method_signature": "private static allEndsVisited(EconomicMap<FixedNode, StateT> states, HIRBlock current, AbstractMergeNode merge)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "processMultipleSuccessors",
                            "method_signature": "private static processMultipleSuccessors(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state,\n                    HIRBlock current)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "mergeStates",
                            "method_signature": "private static mergeStates(EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock current, HIRBlock successor, AbstractMergeNode merge)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "recurseIntoLoop",
                            "method_signature": "private static recurseIntoLoop(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock successor)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "apply",
                            "method_signature": "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "checkExpiration",
                            "method_signature": "private checkExpiration(CompilationAlarm compilationAlarm, StructuredGraph graph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "allEndsVisited",
                            "method_signature": "private static allEndsVisited(EconomicMap<FixedNode, StateT> states, HIRBlock current, AbstractMergeNode merge)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "recurseIntoLoop",
                            "method_signature": "private static recurseIntoLoop(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock successor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "processMultipleSuccessors",
                            "method_signature": "private static processMultipleSuccessors(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state,\n                    HIRBlock current)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "processLoop",
                            "method_signature": "public static processLoop(BlockIteratorClosure<StateT> closure, Loop<HIRBlock> loop, StateT initialState)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "mergeStates",
                            "method_signature": "private static mergeStates(EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock current, HIRBlock successor, AbstractMergeNode merge)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "apply",
                            "method_signature": "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start, StateT initialState, Predicate<HIRBlock> stopAtBlock)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start)": {
                        "first": {
                            "method_name": "apply",
                            "method_signature": "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.37002983950070595
                    },
                    "private checkExpiration(CompilationAlarm compilationAlarm, StructuredGraph graph)": {
                        "first": {
                            "method_name": "checkExpiration",
                            "method_signature": "private checkExpiration(CompilationAlarm compilationAlarm, StructuredGraph graph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4852324893068426
                    },
                    "private static allEndsVisited(EconomicMap<FixedNode, StateT> states, HIRBlock current, AbstractMergeNode merge)": {
                        "first": {
                            "method_name": "allEndsVisited",
                            "method_signature": "private static allEndsVisited(EconomicMap<FixedNode, StateT> states, HIRBlock current, AbstractMergeNode merge)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5456540215139402
                    },
                    "private static recurseIntoLoop(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock successor)": {
                        "first": {
                            "method_name": "recurseIntoLoop",
                            "method_signature": "private static recurseIntoLoop(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock successor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5870233309628545
                    },
                    "private static processMultipleSuccessors(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state,\n                    HIRBlock current)": {
                        "first": {
                            "method_name": "processMultipleSuccessors",
                            "method_signature": "private static processMultipleSuccessors(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state,\n                    HIRBlock current)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5904585880481258
                    },
                    "public static processLoop(BlockIteratorClosure<StateT> closure, Loop<HIRBlock> loop, StateT initialState)": {
                        "first": {
                            "method_name": "processLoop",
                            "method_signature": "public static processLoop(BlockIteratorClosure<StateT> closure, Loop<HIRBlock> loop, StateT initialState)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6095963206721572
                    },
                    "private static mergeStates(EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock current, HIRBlock successor, AbstractMergeNode merge)": {
                        "first": {
                            "method_name": "mergeStates",
                            "method_signature": "private static mergeStates(EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock current, HIRBlock successor, AbstractMergeNode merge)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6141949004584499
                    },
                    "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start, StateT initialState, Predicate<HIRBlock> stopAtBlock)": {
                        "first": {
                            "method_name": "apply",
                            "method_signature": "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start, StateT initialState, Predicate<HIRBlock> stopAtBlock)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.68898426692284
                    }
                },
                "voyage": {
                    "private checkExpiration(CompilationAlarm compilationAlarm, StructuredGraph graph)": {
                        "first": {
                            "method_name": "checkExpiration",
                            "method_signature": "private checkExpiration(CompilationAlarm compilationAlarm, StructuredGraph graph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.32685073590002856
                    },
                    "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start)": {
                        "first": {
                            "method_name": "apply",
                            "method_signature": "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5634758700934182
                    },
                    "private static allEndsVisited(EconomicMap<FixedNode, StateT> states, HIRBlock current, AbstractMergeNode merge)": {
                        "first": {
                            "method_name": "allEndsVisited",
                            "method_signature": "private static allEndsVisited(EconomicMap<FixedNode, StateT> states, HIRBlock current, AbstractMergeNode merge)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5898506280422079
                    },
                    "private static mergeStates(EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock current, HIRBlock successor, AbstractMergeNode merge)": {
                        "first": {
                            "method_name": "mergeStates",
                            "method_signature": "private static mergeStates(EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock current, HIRBlock successor, AbstractMergeNode merge)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5921972373406703
                    },
                    "private static processMultipleSuccessors(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state,\n                    HIRBlock current)": {
                        "first": {
                            "method_name": "processMultipleSuccessors",
                            "method_signature": "private static processMultipleSuccessors(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state,\n                    HIRBlock current)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6701240146011357
                    },
                    "public static processLoop(BlockIteratorClosure<StateT> closure, Loop<HIRBlock> loop, StateT initialState)": {
                        "first": {
                            "method_name": "processLoop",
                            "method_signature": "public static processLoop(BlockIteratorClosure<StateT> closure, Loop<HIRBlock> loop, StateT initialState)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7051021592715464
                    },
                    "private static recurseIntoLoop(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock successor)": {
                        "first": {
                            "method_name": "recurseIntoLoop",
                            "method_signature": "private static recurseIntoLoop(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock successor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7386578463598408
                    },
                    "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start, StateT initialState, Predicate<HIRBlock> stopAtBlock)": {
                        "first": {
                            "method_name": "apply",
                            "method_signature": "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start, StateT initialState, Predicate<HIRBlock> stopAtBlock)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7541221222738373
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private static recurseIntoLoop(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock successor)",
                        "private static allEndsVisited(EconomicMap<FixedNode, StateT> states, HIRBlock current, AbstractMergeNode merge)",
                        "private static mergeStates(EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock current, HIRBlock successor, AbstractMergeNode merge)",
                        "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start)",
                        "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start, StateT initialState, Predicate<HIRBlock> stopAtBlock)",
                        "public static processLoop(BlockIteratorClosure<StateT> closure, Loop<HIRBlock> loop, StateT initialState)",
                        "private checkExpiration(CompilationAlarm compilationAlarm, StructuredGraph graph)"
                    ],
                    "llm_response_time": 4195
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "private checkExpiration(CompilationAlarm compilationAlarm, StructuredGraph graph)",
                        "private static allEndsVisited(EconomicMap<FixedNode, StateT> states, HIRBlock current, AbstractMergeNode merge)",
                        "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start)"
                    ],
                    "llm_response_time": 5607
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private checkExpiration(CompilationAlarm compilationAlarm, StructuredGraph graph)",
                        "private static allEndsVisited(EconomicMap<FixedNode, StateT> states, HIRBlock current, AbstractMergeNode merge)",
                        "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start)"
                    ],
                    "llm_response_time": 4970
                },
                "voyage": {
                    "priority_method_names": [
                        "private checkExpiration(CompilationAlarm compilationAlarm, StructuredGraph graph)",
                        "private static allEndsVisited(EconomicMap<FixedNode, StateT> states, HIRBlock current, AbstractMergeNode merge)",
                        "private static mergeStates(EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock current, HIRBlock successor, AbstractMergeNode merge)",
                        "private static recurseIntoLoop(BlockIteratorClosure<StateT> closure, Deque<HIRBlock> blockQueue, EconomicMap<FixedNode, StateT> states, StateT state, HIRBlock successor)",
                        "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start)",
                        "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start, StateT initialState, Predicate<HIRBlock> stopAtBlock)",
                        "public static processLoop(BlockIteratorClosure<StateT> closure, Loop<HIRBlock> loop, StateT initialState)"
                    ],
                    "llm_response_time": 3086
                },
                "voyage-5": {
                    "priority_method_names": [],
                    "llm_response_time": 5213
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private checkExpiration(CompilationAlarm compilationAlarm, StructuredGraph graph)",
                        "private static allEndsVisited(EconomicMap<FixedNode, StateT> states, HIRBlock current, AbstractMergeNode merge)",
                        "public static apply(BlockIteratorClosure<StateT> closure, HIRBlock start)"
                    ],
                    "llm_response_time": 3418
                }
            },
            "targetClassMap": {
                "apply": {
                    "target_classes": [
                        {
                            "class_name": "LoopInfo",
                            "similarity_score": 0.40929562993732305
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "LoopInfo"
                    ],
                    "llm_response_time": 2069,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "checkExpiration": {
                    "target_classes": [
                        {
                            "class_name": "CompilationAlarm",
                            "similarity_score": 0.4831601702922562
                        },
                        {
                            "class_name": "StructuredGraph",
                            "similarity_score": 0.4555732131314725
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CompilationAlarm",
                        "StructuredGraph"
                    ],
                    "llm_response_time": 3463,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                },
                "allEndsVisited": {
                    "target_classes": [
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.46947273526858646
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.4277620845647897
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.3966756182260984
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.6032780108492787
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.5588113691923494
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.5467294060851866
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.3540347432880577
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.4470708081130697
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.18767394081458105
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.33988857855092985
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.539109512273716
                        },
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.6084224390570095
                        },
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.34042801429355535
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.4294110554874647
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.5124857272913352
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.2651073974913363
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.6053533734887708
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.6140948814902164
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.4271232498178447
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.32120104209832145
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.21865739655731123
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.6238962951714004
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.48635884646650757
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.4319565371642919
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.3372473977002756
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.33689445682555313
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.49323820141178865
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.29828362186728535
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.6654609461618463
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.46364442470254075
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.35923323790909373
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.44994988054390994
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.40911484834575834
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.48454371185234896
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.506280700991632
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.536904857019718
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.5660657124973861
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.33377308349527574
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.5766228310963157
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.5508908587582
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.588503023989217
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.6210831142454595
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.379150419176934
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.5096772061514204
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.32345057538832317
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.3810085071017753
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.49464916185128177
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.4241603826546118
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.37300192329612547
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.5232668288166067
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.4698897186999826
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.5006381817978524
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.4574225756836928
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.5505230755053986
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.4398632737502412
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.49847092621329075
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.5055465166373733
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.3618419592633488
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.3699305099410977
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.5478718138693338
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.4016853322544532
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.4859822893966368
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.43356607298305033
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.4423258684646914
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.6108696186944306
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.47448024732020844
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.40498356958421783
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.5996096835235826
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.2786391062876764
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.5674878563797853
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.313328142583078
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.5636939763618172
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.32399369891538055
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.5161523849279069
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.568835646580015
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.29996842946335994
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.29079625180270025
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.22829820410148163
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.5875220324893352
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.4725560059336473
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.6372768795154028
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.3936208351034797
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.4544466295731929
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.2017764782442603
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.551370302381346
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.4900189558324237
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.16199455554074874
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.520088841101438
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.4894803464695552
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.2710410824318282
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.41515361472246404
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.4989175626795497
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.4139536397883702
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.45487208779860194
                        },
                        {
                            "class_name": "StackElement",
                            "similarity_score": 0.4410168218875432
                        },
                        {
                            "class_name": "ExitException",
                            "similarity_score": 0.384995251754509
                        },
                        {
                            "class_name": "CEntryPointUtilityNode",
                            "similarity_score": 0.4756310318905898
                        },
                        {
                            "class_name": "AtomicBoolean",
                            "similarity_score": 0.4587432692286246
                        },
                        {
                            "class_name": "AtomicInteger",
                            "similarity_score": 0.3836665218650176
                        },
                        {
                            "class_name": "AtomicLong",
                            "similarity_score": 0.36639577600820755
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "VirtualUtil",
                        "ConstantFoldUtil",
                        "NativeImageResourceFileSystemUtil"
                    ],
                    "llm_response_time": 3075,
                    "similarity_computation_time": 56,
                    "similarity_metric": "cosine"
                },
                "recurseIntoLoop": {
                    "target_classes": [
                        {
                            "class_name": "ReentrantNodeIterator",
                            "similarity_score": 0.5320864170860563
                        },
                        {
                            "class_name": "FixedNodeRelativeFrequencyCache",
                            "similarity_score": 0.3812566447737015
                        },
                        {
                            "class_name": "LoopInfo",
                            "similarity_score": 0.29440538089832324
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReentrantNodeIterator",
                        "FixedNodeRelativeFrequencyCache",
                        "LoopInfo"
                    ],
                    "llm_response_time": 2339,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "processMultipleSuccessors": {
                    "target_classes": [
                        {
                            "class_name": "ReentrantNodeIterator",
                            "similarity_score": 0.49233703958529934
                        },
                        {
                            "class_name": "FixedNodeRelativeFrequencyCache",
                            "similarity_score": 0.31579577216685417
                        },
                        {
                            "class_name": "LoopInfo",
                            "similarity_score": 0.23247668901849133
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReentrantNodeIterator",
                        "FixedNodeRelativeFrequencyCache",
                        "LoopInfo"
                    ],
                    "llm_response_time": 3309,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "processLoop": {
                    "target_classes": [
                        {
                            "class_name": "ReentrantNodeIterator",
                            "similarity_score": 0.5915167609701494
                        },
                        {
                            "class_name": "FixedNodeRelativeFrequencyCache",
                            "similarity_score": 0.3949774332079928
                        },
                        {
                            "class_name": "LoopInfo",
                            "similarity_score": 0.3663512206090133
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReentrantNodeIterator",
                        "LoopInfo",
                        "FixedNodeRelativeFrequencyCache"
                    ],
                    "llm_response_time": 3430,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "mergeStates": {
                    "target_classes": [
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.4434341272918808
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.39873171732537005
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.410520999520094
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.2763500762134157
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.26773959182567275
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.43113811866899343
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.31989786212792315
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.14357749875212406
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.41699422344023895
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.17004233131233637
                        },
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.43570054741170755
                        },
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.4045400801773575
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.36211152191699925
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.2515043453860609
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.31800657044531944
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.28284494537190985
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.45813064506018625
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.3059095108195173
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.2169523714281882
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.32818535768849494
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.33250468382445897
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.12921540192221082
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.2788713271248877
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.35306479367890353
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.24017016749666864
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.21023645489666598
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.23511696994793682
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.2414710638791808
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.35615910473859336
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.34625448093579353
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.21596044680742016
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.31759537822688727
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.20570179844429817
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.3012974308618837
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.4339725676011518
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.4632839834381902
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.31409618802419226
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.4639235894178658
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.34896845547342686
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.34523574075033336
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.3926607366353504
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.3833751214706009
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.3897681258379036
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.35234043724536046
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.3572461988862374
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.32493412382557896
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.4605076065384471
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.309855834700385
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.31665017088430647
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.34406882228563584
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.36511916330533417
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.3581478115522872
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.3481852504854484
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.36273467370806245
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.3425016036039881
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.3565825860541033
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.423355202370433
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.14943889198721133
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.3497514207363215
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.2935654221765046
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.43989672790032336
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.2747568777480001
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.3735576038231977
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.2892611376205054
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.3974249930385726
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.23828272835233358
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.3653283557441084
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.3471076799341804
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.313392045182695
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.20219900811313526
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.28126967882705056
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.20628424925175864
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.34811689157828996
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.45281083903225566
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.36986666972528665
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.40656711639888343
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.25611029824709375
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.21051972850507183
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.30117351663461456
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.4005039158822002
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.09410100629148174
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.3684372490610287
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.29982264260938757
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.3706678036116482
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.2563650593100633
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.24968638542518756
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.1481907092978114
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.36248739705583005
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.2618452371851871
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.18960514247076024
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.29290464595714233
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.4093382867269808
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.2769883730911347
                        },
                        {
                            "class_name": "ExitException",
                            "similarity_score": 0.26932108927745296
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.25276609702075203
                        },
                        {
                            "class_name": "StackElement",
                            "similarity_score": 0.28723404255319146
                        },
                        {
                            "class_name": "InvalidMacroException",
                            "similarity_score": 0.19790977371009408
                        },
                        {
                            "class_name": "CEntryPointUtilityNode",
                            "similarity_score": 0.33272479860248655
                        },
                        {
                            "class_name": "AtomicBoolean",
                            "similarity_score": 0.4125999430749211
                        },
                        {
                            "class_name": "AtomicInteger",
                            "similarity_score": 0.3880008773843994
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BundleSerializationUtils",
                        "StringUtil",
                        "String"
                    ],
                    "llm_response_time": 3446,
                    "similarity_computation_time": 22,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "ca796650fa81760f3bc0498851334b132b826f9a",
        "url": "https://github.com/oracle/graal/commit/ca796650fa81760f3bc0498851334b132b826f9a",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public checkSanityAfterCollection() : void extracted from private postcondition() : void in class com.oracle.svm.core.genscavenge.GCImpl & moved to class com.oracle.svm.core.genscavenge.YoungGeneration",
            "leftSideLocations": [
                {
                    "filePath": "substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GCImpl.java",
                    "startLine": 440,
                    "endLine": 444,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "private postcondition() : void"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GCImpl.java",
                    "startLine": 443,
                    "endLine": 443,
                    "startColumn": 9,
                    "endColumn": 104,
                    "codeElementType": "ASSERT_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/YoungGeneration.java",
                    "startLine": 334,
                    "endLine": 337,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public checkSanityAfterCollection() : void"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/YoungGeneration.java",
                    "startLine": 336,
                    "endLine": 336,
                    "startColumn": 9,
                    "endColumn": 76,
                    "codeElementType": "ASSERT_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GCImpl.java",
                    "startLine": 444,
                    "endLine": 448,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "private checkSanityAfterCollection() : void"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GCImpl.java",
                    "startLine": 446,
                    "endLine": 446,
                    "startColumn": 9,
                    "endColumn": 63,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "heap.getYoungGeneration().checkSanityAfterCollection()"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GCImpl.java",
                    "startLine": 447,
                    "endLine": 447,
                    "startColumn": 9,
                    "endColumn": 61,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "heap.getOldGeneration().checkSanityAfterCollection()"
                }
            ],
            "isStatic": false
        },
        "ref_id": 481,
        "extraction_results": {
            "success": true,
            "newCommitHash": "a885dd5d3d3f6c21706115af9b892ac3efd3d8e1",
            "newBranchName": "extract-checkSanityAfterCollection-postcondition-68e7fa1"
        },
        "telemetry": {
            "id": "0b4d1564-f304-458d-be82-e35efebfc153",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1360,
                "lineStart": 105,
                "lineEnd": 1464,
                "bodyLineStart": 105,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GCImpl.java",
                "sourceCode": "/**\n * Garbage collector (incremental or complete) for {@link HeapImpl}.\n */\npublic final class GCImpl implements GC {\n    private static final long K = 1024;\n    static final long M = K * K;\n\n    private final GreyToBlackObjRefVisitor greyToBlackObjRefVisitor = new GreyToBlackObjRefVisitor();\n    private final GreyToBlackObjectVisitor greyToBlackObjectVisitor = new GreyToBlackObjectVisitor(greyToBlackObjRefVisitor);\n    private final RuntimeCodeCacheWalker runtimeCodeCacheWalker = new RuntimeCodeCacheWalker(greyToBlackObjRefVisitor);\n    private final RuntimeCodeCacheCleaner runtimeCodeCacheCleaner = new RuntimeCodeCacheCleaner();\n\n    private final GCAccounting accounting = new GCAccounting();\n    private final Timers timers = new Timers();\n\n    private final CollectionVMOperation collectOperation = new CollectionVMOperation();\n    private final ChunkReleaser chunkReleaser = new ChunkReleaser();\n\n    private final MarkQueue markQueue = new MarkQueue();\n\n    private final CollectionPolicy policy;\n    private boolean completeCollection = false;\n    private UnsignedWord collectionEpoch = WordFactory.zero();\n    private long lastWholeHeapExaminedTimeMillis = -1;\n\n    @Platforms(Platform.HOSTED_ONLY.class)\n    GCImpl() {\n        this.policy = CollectionPolicy.getInitialPolicy();\n        RuntimeSupport.getRuntimeSupport().addShutdownHook(isFirstIsolate -> printGCSummary());\n    }\n\n    @Override\n    public String getName() {\n        if (SubstrateOptions.UseEpsilonGC.getValue()) {\n            return \"Epsilon GC\";\n        } else {\n            return \"Serial GC\";\n        }\n    }\n\n    @Override\n    public String getDefaultMaxHeapSize() {\n        return String.format(\"%s%% of RAM\", SerialAndEpsilonGCOptions.MaximumHeapSizePercent.getValue());\n    }\n\n    @Override\n    public void collect(GCCause cause) {\n        collect(cause, false);\n    }\n\n    public void maybeCollectOnAllocation(UnsignedWord allocationSize) {\n        boolean outOfMemory = false;\n        if (hasNeverCollectPolicy()) {\n            UnsignedWord edenUsed = HeapImpl.getAccounting().getEdenUsedBytes();\n            outOfMemory = edenUsed.aboveThan(GCImpl.getPolicy().getMaximumHeapSize());\n        } else if (getPolicy().shouldCollectOnAllocation()) {\n            AllocationRequiringGCEvent.emit(getCollectionEpoch(), allocationSize);\n            outOfMemory = collectWithoutAllocating(GenScavengeGCCause.OnAllocation, false);\n        }\n        if (outOfMemory) {\n            throw OutOfMemoryUtil.heapSizeExceeded();\n        }\n    }\n\n    @Override\n    public void collectionHint(boolean fullGC) {\n        if (policy.shouldCollectOnHint(fullGC)) {\n            collect(GCCause.HintedGC, fullGC);\n        }\n    }\n\n    private void collect(GCCause cause, boolean forceFullGC) {\n        if (!hasNeverCollectPolicy()) {\n            boolean outOfMemory = collectWithoutAllocating(cause, forceFullGC);\n            if (outOfMemory) {\n                throw OutOfMemoryUtil.heapSizeExceeded();\n            }\n        }\n    }\n\n    @Uninterruptible(reason = \"Avoid races with other threads that also try to trigger a GC\")\n    @RestrictHeapAccess(access = RestrictHeapAccess.Access.NO_ALLOCATION, reason = \"Must not allocate in the implementation of garbage collection.\")\n    boolean collectWithoutAllocating(GCCause cause, boolean forceFullGC) {\n        VMError.guarantee(!hasNeverCollectPolicy());\n\n        int size = SizeOf.get(CollectionVMOperationData.class);\n        CollectionVMOperationData data = StackValue.get(size);\n        UnmanagedMemoryUtil.fill((Pointer) data, WordFactory.unsigned(size), (byte) 0);\n        data.setCauseId(cause.getId());\n        data.setRequestingEpoch(getCollectionEpoch());\n        data.setCompleteCollectionCount(GCImpl.getAccounting().getCompleteCollectionCount());\n        data.setRequestingNanoTime(System.nanoTime());\n        data.setForceFullGC(forceFullGC);\n        enqueueCollectOperation(data);\n\n        boolean outOfMemory = data.getOutOfMemory();\n        if (outOfMemory && SerialGCOptions.IgnoreMaxHeapSizeWhileInVMOperation.getValue() && VMOperation.isInProgress()) {\n            outOfMemory = false;\n        }\n        return outOfMemory;\n    }\n\n    @Uninterruptible(reason = \"Used as a transition between uninterruptible and interruptible code\", calleeMustBe = false)\n    private void enqueueCollectOperation(CollectionVMOperationData data) {\n        collectOperation.enqueue(data);\n    }\n\n    /** The body of the VMOperation to do the collection. */\n    private void collectOperation(CollectionVMOperationData data) {\n        assert VMOperation.isGCInProgress();\n        assert getCollectionEpoch().equal(data.getRequestingEpoch()) ||\n                        data.getForceFullGC() && GCImpl.getAccounting().getCompleteCollectionCount() == data.getCompleteCollectionCount() : \"unnecessary GC?\";\n\n        timers.mutator.closeAt(data.getRequestingNanoTime());\n        timers.resetAllExceptMutator();\n\n        JfrGCHeapSummaryEvent.emit(JfrGCWhen.BEFORE_GC);\n        GCCause cause = GCCause.fromId(data.getCauseId());\n        printGCBefore(cause);\n\n        ThreadLocalAllocation.disableAndFlushForAllThreads();\n        GenScavengeMemoryPoolMXBeans.singleton().notifyBeforeCollection();\n        HeapImpl.getAccounting().notifyBeforeCollection();\n\n        boolean outOfMemory = collectImpl(cause, data.getRequestingNanoTime(), data.getForceFullGC());\n        data.setOutOfMemory(outOfMemory);\n\n        HeapImpl.getAccounting().notifyAfterCollection();\n        GenScavengeMemoryPoolMXBeans.singleton().notifyAfterCollection();\n\n        printGCAfter(cause);\n        JfrGCHeapSummaryEvent.emit(JfrGCWhen.AFTER_GC);\n\n        collectionEpoch = collectionEpoch.add(1);\n        timers.mutator.open();\n    }\n\n    private boolean collectImpl(GCCause cause, long requestingNanoTime, boolean forceFullGC) {\n        boolean outOfMemory;\n        long startTicks = JfrTicks.elapsedTicks();\n        try {\n            outOfMemory = doCollectImpl(cause, requestingNanoTime, forceFullGC);\n            if (outOfMemory) {\n                // Avoid running out of memory with a full GC that reclaims softly reachable\n                // objects\n                ReferenceObjectProcessing.setSoftReferencesAreWeak(true);\n                try {\n                    outOfMemory = doCollectImpl(cause, requestingNanoTime, true);\n                } finally {\n                    ReferenceObjectProcessing.setSoftReferencesAreWeak(false);\n                }\n            }\n        } finally {\n            JfrGCEvents.emitGarbageCollectionEvent(getCollectionEpoch(), cause, startTicks);\n        }\n        return outOfMemory;\n    }\n\n    private boolean doCollectImpl(GCCause cause, long requestingNanoTime, boolean forceFullGC) {\n        CommittedMemoryProvider.get().beforeGarbageCollection();\n\n        boolean incremental = !forceFullGC && !policy.shouldCollectCompletely(false);\n        boolean outOfMemory = false;\n\n        if (incremental) {\n            long startTicks = JfrGCEvents.startGCPhasePause();\n            try {\n                outOfMemory = doCollectOnce(cause, requestingNanoTime, false, false);\n            } finally {\n                JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), \"Incremental GC\", startTicks);\n            }\n        }\n        if (!incremental || outOfMemory || policy.shouldCollectCompletely(incremental)) {\n            if (incremental) { // uncommit unaligned chunks\n                CommittedMemoryProvider.get().afterGarbageCollection();\n            }\n            long startTicks = JfrGCEvents.startGCPhasePause();\n            try {\n                outOfMemory = doCollectOnce(cause, requestingNanoTime, true, incremental);\n            } finally {\n                JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), \"Full GC\", startTicks);\n            }\n        }\n\n        HeapImpl.getChunkProvider().freeExcessAlignedChunks();\n        CommittedMemoryProvider.get().afterGarbageCollection();\n\n        postcondition();\n        return outOfMemory;\n    }\n\n    private boolean doCollectOnce(GCCause cause, long requestingNanoTime, boolean complete, boolean followsIncremental) {\n        assert !followsIncremental || complete : \"An incremental collection cannot be followed by another incremental collection\";\n        completeCollection = complete;\n\n        accounting.beforeCollection(completeCollection);\n        policy.onCollectionBegin(completeCollection, requestingNanoTime);\n\n        Timer collectionTimer = timers.collection.open();\n        try {\n            if (!followsIncremental) { // we would have verified the heap after the incremental GC\n                verifyBeforeGC();\n            }\n            scavenge(!complete);\n            verifyAfterGC();\n            if (complete) {\n                lastWholeHeapExaminedTimeMillis = System.currentTimeMillis();\n            }\n        } finally {\n            collectionTimer.close();\n        }\n\n        accounting.afterCollection(completeCollection, collectionTimer);\n        policy.onCollectionEnd(completeCollection, cause);\n\n        UnsignedWord usedBytes = getChunkBytes();\n        UnsignedWord freeBytes = policy.getCurrentHeapCapacity().subtract(usedBytes);\n        ReferenceObjectProcessing.afterCollection(freeBytes);\n\n        return usedBytes.aboveThan(policy.getMaximumHeapSize()); // out of memory?\n    }\n\n    private void verifyBeforeGC() {\n        if (SubstrateGCOptions.VerifyHeap.getValue() && SerialGCOptions.VerifyBeforeGC.getValue()) {\n            Timer verifyBeforeTimer = timers.verifyBefore.open();\n            try {\n                boolean success = true;\n                success &= HeapVerifier.singleton().verify(HeapVerifier.Occasion.BEFORE_COLLECTION);\n                success &= StackVerifier.verifyAllThreads();\n\n                if (!success) {\n                    String kind = getGCKind();\n                    Log.log().string(\"Heap verification failed before \").string(kind).string(\" garbage collection.\").newline();\n                    VMError.shouldNotReachHere(\"Heap verification failed\");\n                }\n            } finally {\n                verifyBeforeTimer.close();\n            }\n        }\n    }\n\n    private void verifyAfterGC() {\n        if (SubstrateGCOptions.VerifyHeap.getValue() && SerialGCOptions.VerifyAfterGC.getValue()) {\n            Timer verifyAfterTime = timers.verifyAfter.open();\n            try {\n                boolean success = true;\n                success &= HeapVerifier.singleton().verify(HeapVerifier.Occasion.AFTER_COLLECTION);\n                success &= StackVerifier.verifyAllThreads();\n\n                if (!success) {\n                    String kind = getGCKind();\n                    Log.log().string(\"Heap verification failed after \").string(kind).string(\" garbage collection.\").newline();\n                    VMError.shouldNotReachHere(\"Heap verification failed\");\n                }\n            } finally {\n                verifyAfterTime.close();\n            }\n        }\n    }\n\n    private String getGCKind() {\n        return isCompleteCollection() ? \"complete\" : \"incremental\";\n    }\n\n    /**\n     * This value is only updated during a GC, so it may be outdated if called from outside the GC\n     * VM operation. Also be careful when calling this method during a GC as it might wrongly\n     * include chunks that will be freed at the end of the GC.\n     */\n    public static UnsignedWord getChunkBytes() {\n        UnsignedWord youngBytes = HeapImpl.getHeapImpl().getYoungGeneration().getChunkBytes();\n        UnsignedWord oldBytes = HeapImpl.getHeapImpl().getOldGeneration().getChunkBytes();\n        return youngBytes.add(oldBytes);\n    }\n\n    private void printGCBefore(GCCause cause) {\n        if (!SubstrateGCOptions.VerboseGC.getValue()) {\n            return;\n        }\n\n        if (getCollectionEpoch().equal(0)) {\n            printGCPrefixAndTime().string(\"Using \").string(getName()).newline();\n            Log log = printGCPrefixAndTime().spaces(2).string(\"Memory: \");\n            if (!PhysicalMemory.isInitialized()) {\n                log.string(\"unknown\").newline();\n            } else {\n                log.rational(PhysicalMemory.getCachedSize(), M, 0).string(\"M\").newline();\n            }\n            printGCPrefixAndTime().spaces(2).string(\"Heap policy: \").string(getPolicy().getName()).newline();\n            printGCPrefixAndTime().spaces(2).string(\"Maximum young generation size: \").rational(getPolicy().getMaximumYoungGenerationSize(), M, 0).string(\"M\").newline();\n            printGCPrefixAndTime().spaces(2).string(\"Maximum heap size: \").rational(getPolicy().getMaximumHeapSize(), M, 0).string(\"M\").newline();\n            printGCPrefixAndTime().spaces(2).string(\"Minimum heap size: \").rational(getPolicy().getMinimumHeapSize(), M, 0).string(\"M\").newline();\n            printGCPrefixAndTime().spaces(2).string(\"Aligned chunk size: \").rational(HeapParameters.getAlignedHeapChunkSize(), K, 0).string(\"K\").newline();\n            printGCPrefixAndTime().spaces(2).string(\"Large array threshold: \").rational(HeapParameters.getLargeArrayThreshold(), K, 0).string(\"K\").newline();\n        }\n\n        printGCPrefixAndTime().string(cause.getName()).newline();\n    }\n\n    private void printGCAfter(GCCause cause) {\n        HeapAccounting heapAccounting = HeapImpl.getAccounting();\n        HeapSizes beforeGc = heapAccounting.getHeapSizesBeforeGc();\n\n        if (SubstrateGCOptions.VerboseGC.getValue()) {\n            printHeapSizeChange(\"Eden\", beforeGc.eden, heapAccounting.getEdenUsedBytes());\n            printHeapSizeChange(\"Survivor\", beforeGc.survivor, heapAccounting.getSurvivorUsedBytes());\n            printHeapSizeChange(\"Old\", beforeGc.old, heapAccounting.getOldUsedBytes());\n            printHeapSizeChange(\"Free\", beforeGc.free, heapAccounting.getBytesInUnusedChunks());\n\n            if (SerialGCOptions.PrintGCTimes.getValue()) {\n                timers.logAfterCollection(Log.log());\n            }\n\n            if (SerialGCOptions.TraceHeapChunks.getValue()) {\n                HeapImpl.getHeapImpl().logChunks(Log.log());\n            }\n        }\n\n        if (SubstrateGCOptions.PrintGC.getValue() || SubstrateGCOptions.VerboseGC.getValue()) {\n            String collectionType = completeCollection ? \"Full GC\" : \"Incremental GC\";\n            printGCPrefixAndTime().string(\"Pause \").string(collectionType).string(\" (\").string(cause.getName()).string(\") \")\n                            .rational(beforeGc.totalUsed(), M, 2).string(\"M->\").rational(heapAccounting.getUsedBytes(), M, 2).string(\"M \")\n                            .rational(timers.collection.getMeasuredNanos(), TimeUtils.nanosPerMilli, 3).string(\"ms\").newline();\n        }\n    }\n\n    private void printHeapSizeChange(String text, UnsignedWord before, UnsignedWord after) {\n        printGCPrefixAndTime().string(\"  \").string(text).string(\": \").rational(before, M, 2).string(\"M->\").rational(after, M, 2).string(\"M\").newline();\n    }\n\n    private Log printGCPrefixAndTime() {\n        long uptimeMs = Isolates.getCurrentUptimeMillis();\n        return Log.log().string(\"[\").rational(uptimeMs, TimeUtils.millisPerSecond, 3).string(\"s\").string(\"] GC(\").unsigned(collectionEpoch).string(\") \");\n    }\n\n    private static void postcondition() {\n        HeapImpl heap = HeapImpl.getHeapImpl();\n        YoungGeneration youngGen = heap.getYoungGeneration();\n        assert youngGen.getEden().isEmpty() : \"youngGen.getEden() should be empty after a collection.\";\n    }\n\n    private void checkSanityAfterCollection(YoungGeneration youngGen) {\n        assert youngGen.getEden().isEmpty() : \"youngGen.getEden() should be empty after a collection.\";\n    }\n\n    @Fold\n    static boolean runtimeAssertions() {\n        return RuntimeAssertionsSupport.singleton().desiredAssertionStatus(GCImpl.class);\n    }\n\n    @Fold\n    public static GCImpl getGCImpl() {\n        GCImpl gcImpl = HeapImpl.getGCImpl();\n        assert gcImpl != null;\n        return gcImpl;\n    }\n\n    @Override\n    public void collectCompletely(GCCause cause) {\n        collect(cause, true);\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public boolean isCompleteCollection() {\n        return completeCollection;\n    }\n\n    /** Scavenge, either from dirty roots or from all roots, and process discovered references. */\n    private void scavenge(boolean incremental) {\n        GreyToBlackObjRefVisitor.Counters counters = greyToBlackObjRefVisitor.openCounters();\n        long startTicks;\n        try {\n            if (!incremental) {\n                HeapImpl heap = HeapImpl.getHeapImpl();\n                heap.getOldGeneration().absorb(heap.getYoungGeneration());\n            }\n\n            Timer rootScanTimer = timers.rootScan.open();\n            try {\n                startTicks = JfrGCEvents.startGCPhasePause();\n                try {\n                    cheneyScan(incremental);\n                } finally {\n                    JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), incremental ? \"Incremental Scan\" : \"Scan\", startTicks);\n                }\n            } finally {\n                rootScanTimer.close();\n            }\n\n            if (!incremental) {\n                ReferenceObjectProcessing.updateForwardedRefs();\n\n                Timer tenuredPlanningTimer = timers.tenuredPlanning.open();\n                try {\n                    startTicks = JfrGCEvents.startGCPhasePause();\n                    try {\n                        HeapImpl.getHeapImpl().getOldGeneration().planCompaction();\n                    } finally {\n                        JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), \"Tenured Planning\", startTicks);\n                    }\n                } finally {\n                    tenuredPlanningTimer.close();\n                }\n\n                Timer tenuredFixingTimer = timers.tenuredFixing.open();\n                try {\n                    HeapImpl.getHeapImpl().getOldGeneration().fixupReferencesBeforeCompaction(chunkReleaser, timers);\n                } finally {\n                    tenuredFixingTimer.close();\n                }\n\n                Timer tenuredCompactingTimer = timers.tenuredCompacting.open();\n                try {\n                    HeapImpl.getHeapImpl().getOldGeneration().compact(timers);\n                } finally {\n                    tenuredCompactingTimer.close();\n                }\n            }\n\n            Timer referenceObjectsTimer = timers.referenceObjects.open();\n            try {\n                startTicks = JfrGCEvents.startGCPhasePause();\n                try {\n                    Reference<?> newlyPendingList = ReferenceObjectProcessing.processRememberedReferences();\n                    HeapImpl.getHeapImpl().addToReferencePendingList(newlyPendingList);\n                } finally {\n                    JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), \"Process Remembered References\", startTicks);\n                }\n            } finally {\n                referenceObjectsTimer.close();\n            }\n\n            if (RuntimeCompilation.isEnabled()) {\n                Timer cleanCodeCacheTimer = timers.cleanCodeCache.open();\n                try {\n                    /*\n                     * Cleaning the code cache may invalidate code, which is a rather complex\n                     * operation. To avoid side-effects between the code cache cleaning and the GC\n                     * core, it is crucial that all the GC core work finished before.\n                     */\n                    startTicks = JfrGCEvents.startGCPhasePause();\n                    try {\n                        cleanRuntimeCodeCache();\n                    } finally {\n                        JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), \"Clean Runtime CodeCache\", startTicks);\n                    }\n                } finally {\n                    cleanCodeCacheTimer.close();\n                }\n            }\n\n            Timer releaseSpacesTimer = timers.releaseSpaces.open();\n            try {\n                // assert chunkReleaser.isEmpty(); TODO: chunkReleaser is not empty as we already added unaligned chunks\n                startTicks = JfrGCEvents.startGCPhasePause();\n                try {\n                    releaseSpaces();\n\n                    /*\n                     * Do not uncommit any aligned chunks yet if we just did an incremental GC so if\n                     * we decide to do a full GC next, we can reuse the chunks for copying live old\n                     * objects with fewer chunk allocations. In either case, excess chunks are\n                     * released later.\n                     */\n                    boolean keepAllAlignedChunks = incremental;\n                    chunkReleaser.release(keepAllAlignedChunks);\n                } finally {\n                    JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), \"Release Spaces\", startTicks);\n                }\n            } finally {\n                releaseSpacesTimer.close();\n            }\n\n            startTicks = JfrGCEvents.startGCPhasePause();\n            try {\n                swapSpaces();\n            } finally {\n                JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), \"Swap Spaces\", startTicks);\n            }\n        } finally {\n            counters.close();\n        }\n    }\n\n    /**\n     * Visit all the memory that is reserved for runtime compiled code. References from the runtime\n     * compiled code to the Java heap must be consider as either strong or weak references,\n     * depending on whether the code is currently on the execution stack.\n     */\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private void walkRuntimeCodeCache() {\n        Timer walkRuntimeCodeCacheTimer = timers.walkRuntimeCodeCache.open();\n        try {\n            RuntimeCodeInfoMemory.singleton().walkRuntimeMethodsDuringGC(runtimeCodeCacheWalker);\n        } finally {\n            walkRuntimeCodeCacheTimer.close();\n        }\n    }\n\n    private void cleanRuntimeCodeCache() {\n        Timer cleanRuntimeCodeCacheTimer = timers.cleanRuntimeCodeCache.open();\n        try {\n            RuntimeCodeInfoMemory.singleton().walkRuntimeMethodsDuringGC(runtimeCodeCacheCleaner);\n        } finally {\n            cleanRuntimeCodeCacheTimer.close();\n        }\n    }\n\n    @Uninterruptible(reason = \"We don't want any safepoint checks in the core part of the GC.\")\n    private void cheneyScan(boolean incremental) {\n        if (incremental) {\n            cheneyScanFromDirtyRoots();\n        } else {\n            cheneyScanFromRoots();\n        }\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private void cheneyScanFromRoots() {\n        Timer cheneyScanFromRootsTimer = timers.cheneyScanFromRoots.open();\n        try {\n            long startTicks = JfrGCEvents.startGCPhasePause();\n            try {\n                /* Take a snapshot of the heap so that I can visit all the promoted Objects. */\n                /*\n                 * Debugging tip: I could move the taking of the snapshot and the scanning of grey\n                 * Objects into each of the blackening methods, or even put them around individual\n                 * Object reference visits.\n                 */\n                prepareForPromotion(false);\n            } finally {\n                JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), \"Snapshot Heap\", startTicks);\n            }\n\n            startTicks = JfrGCEvents.startGCPhasePause();\n            try {\n                /*\n                 * Make sure all chunks with pinned objects are in toSpace, and any formerly pinned\n                 * objects are in fromSpace.\n                 */\n                promoteChunksWithPinnedObjects();\n            } finally {\n                JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), \"Promote Pinned Objects\", startTicks);\n            }\n\n            startTicks = JfrGCEvents.startGCPhasePause();\n            try {\n                /*\n                 * Stack references are grey at the beginning of a collection, so I need to blacken\n                 * them.\n                 */\n                blackenStackRoots();\n\n                /* Custom memory regions which contain object references. */\n                walkThreadLocals();\n\n                /*\n                 * Native image Objects are grey at the beginning of a collection, so I need to\n                 * blacken them.\n                 */\n                blackenImageHeapRoots();\n            } finally {\n                JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), \"Scan Roots\", startTicks);\n            }\n\n            startTicks = JfrGCEvents.startGCPhasePause();\n            try {\n                /* Visit all the Objects promoted since the snapshot. */\n                scanGreyObjects(false);\n\n                if (RuntimeCompilation.isEnabled()) {\n                    /*\n                     * Visit the runtime compiled code, now that we know all the reachable objects.\n                     */\n                    walkRuntimeCodeCache();\n\n                    /* Visit all objects that became reachable because of the compiled code. */\n                    scanGreyObjects(false);\n                }\n            } finally {\n                JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), \"Scan From Roots\", startTicks);\n            }\n        } finally {\n            cheneyScanFromRootsTimer.close();\n        }\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private void cheneyScanFromDirtyRoots() {\n        Timer cheneyScanFromDirtyRootsTimer = timers.cheneyScanFromDirtyRoots.open();\n        try {\n            /*\n             * All Objects in the Old Generation are \"promoted automatically\". That does not make those chunks grey,\n             * so I have to use the dirty cards marks to blacken them, but that's what card marks are for.\n             */\n\n            long startTicks = JfrGCEvents.startGCPhasePause();\n            try {\n                /* Take a snapshot of the heap so that I can visit all the promoted Objects. */\n                /*\n                 * Debugging tip: I could move the taking of the snapshot and the scanning of grey\n                 * Objects into each of the blackening methods, or even put them around individual\n                 * Object reference visits.\n                 */\n                prepareForPromotion(true);\n            } finally {\n                JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), \"Snapshot Heap\", startTicks);\n            }\n\n            startTicks = JfrGCEvents.startGCPhasePause();\n            try {\n                /*\n                 * Make sure any released objects are in toSpace (because this is an incremental\n                 * collection). I do this before blackening any roots to make sure the chunks with\n                 * pinned objects are moved entirely, as opposed to promoting the objects\n                 * individually by roots. This makes the objects in those chunks grey.\n                 */\n                promoteChunksWithPinnedObjects();\n            } finally {\n                JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), \"Promote Pinned Objects\", startTicks);\n            }\n\n            startTicks = JfrGCEvents.startGCPhasePause();\n            try {\n                /*\n                 * Blacken Objects that are dirty roots. There are dirty cards in ToSpace. Do this\n                 * early so I don't have to walk the cards of individually promoted objects, which\n                 * will be visited by the grey object scanner.\n                 */\n                blackenDirtyCardRoots();\n\n                /*\n                 * Stack references are grey at the beginning of a collection, so I need to blacken\n                 * them.\n                 */\n                blackenStackRoots();\n\n                /* Custom memory regions which contain object references. */\n                walkThreadLocals();\n\n                /*\n                 * Native image Objects are grey at the beginning of a collection, so I need to\n                 * blacken them.\n                 */\n                blackenDirtyImageHeapRoots();\n            } finally {\n                JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), \"Scan Roots\", startTicks);\n            }\n\n            startTicks = JfrGCEvents.startGCPhasePause();\n            try {\n                /* Visit all the Objects promoted since the snapshot, transitively. */\n                scanGreyObjects(true);\n\n                if (RuntimeCompilation.isEnabled()) {\n                    /*\n                     * Visit the runtime compiled code, now that we know all the reachable objects.\n                     */\n                    walkRuntimeCodeCache();\n\n                    /* Visit all objects that became reachable because of the compiled code. */\n                    scanGreyObjects(true);\n                }\n            } finally {\n                JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), \"Scan From Roots\", startTicks);\n            }\n        } finally {\n            cheneyScanFromDirtyRootsTimer.close();\n        }\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private void promoteChunksWithPinnedObjects() {\n        Timer promotePinnedObjectsTimer = timers.promotePinnedObjects.open();\n        try {\n            // Remove closed pinned objects from the global list. This code needs to use write\n            // barriers as the PinnedObjectImpls are a linked list and we don't know in which\n            // generation each individual PinnedObjectImpl lives. So, the card table will be\n            // modified.\n            PinnedObjectImpl pinnedObjects = removeClosedPinnedObjects(PinnedObjectImpl.getPinnedObjects());\n            PinnedObjectImpl.setPinnedObjects(pinnedObjects);\n\n            // Promote all chunks that contain pinned objects. The card table of the promoted chunks\n            // will be cleaned.\n            PinnedObjectImpl cur = pinnedObjects;\n            while (cur != null) {\n                assert cur.isOpen();\n                promotePinnedObject(cur);\n                cur = cur.getNext();\n            }\n        } finally {\n            promotePinnedObjectsTimer.close();\n        }\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private static PinnedObjectImpl removeClosedPinnedObjects(PinnedObjectImpl list) {\n        PinnedObjectImpl firstOpen = null;\n        PinnedObjectImpl lastOpen = null;\n\n        PinnedObjectImpl cur = list;\n        while (cur != null) {\n            if (cur.isOpen()) {\n                if (firstOpen == null) {\n                    assert lastOpen == null;\n                    firstOpen = cur;\n                    lastOpen = cur;\n                } else {\n                    lastOpen.setNext(cur);\n                    lastOpen = cur;\n                }\n            }\n            cur = cur.getNext();\n        }\n\n        if (lastOpen != null) {\n            lastOpen.setNext(null);\n        }\n        return firstOpen;\n    }\n\n    @NeverInline(\"Starting a stack walk in the caller frame. \" +\n                    \"Note that we could start the stack frame also further down the stack, because GC stack frames must not access any objects that are processed by the GC. \" +\n                    \"But we don't store stack frame information for the first frame we would need to process.\")\n    @Uninterruptible(reason = \"Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.\")\n    private void blackenStackRoots() {\n        Timer blackenStackRootsTimer = timers.blackenStackRoots.open();\n        try {\n            Pointer sp = readCallerStackPointer();\n            CodePointer ip = readReturnAddress();\n\n            walkStackRoots(greyToBlackObjRefVisitor, sp, ip, true);\n        } finally {\n            blackenStackRootsTimer.close();\n        }\n    }\n\n    @AlwaysInline(\"GC performance\")\n    @Uninterruptible(reason = \"Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.\", mayBeInlined = true)\n    static void walkStackRoots(ObjectReferenceVisitor visitor, Pointer sp, CodePointer ip, boolean visitRuntimeCodeInfo) {\n        JavaStackWalk walk = StackValue.get(JavaStackWalk.class);\n        JavaStackWalker.initWalk(walk, sp, ip);\n        walkStack(walk, visitor, visitRuntimeCodeInfo);\n\n        /*\n         * Scan the stacks of all the threads. Other threads will be blocked at a safepoint (or\n         * in native code) so they will each have a JavaFrameAnchor in their VMThread.\n         */\n        for (IsolateThread vmThread = VMThreads.firstThread(); vmThread.isNonNull(); vmThread = VMThreads.nextThread(vmThread)) {\n            if (vmThread == CurrentIsolate.getCurrentThread()) {\n                /*\n                 * The current thread is already scanned by code above, so we do not have to do\n                 * anything for it here. It might have a JavaFrameAnchor from earlier Java-to-C\n                 * transitions, but certainly not at the top of the stack since it is running\n                 * this code, so just this scan would be incomplete.\n                 */\n                continue;\n            }\n            if (JavaStackWalker.initWalk(walk, vmThread)) {\n                walkStack(walk, visitor, visitRuntimeCodeInfo);\n            }\n        }\n    }\n\n    /**\n     * This method inlines {@link JavaStackWalker#continueWalk(JavaStackWalk, CodeInfo)} and\n     * {@link CodeInfoTable#visitObjectReferences}. This avoids looking up the\n     * {@link SimpleCodeInfoQueryResult} twice per frame, and also ensures that there are no virtual\n     * calls to a stack frame visitor.\n     */\n    @AlwaysInline(\"GC performance\")\n    @Uninterruptible(reason = \"Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.\", mayBeInlined = true)\n    private static void walkStack(JavaStackWalk walk, ObjectReferenceVisitor visitor, boolean visitRuntimeCodeInfo) {\n        assert VMOperation.isGCInProgress() : \"This methods accesses a CodeInfo without a tether\";\n\n        while (true) {\n            SimpleCodeInfoQueryResult queryResult = StackValue.get(SimpleCodeInfoQueryResult.class);\n            Pointer sp = walk.getSP();\n            CodePointer ip = walk.getPossiblyStaleIP();\n\n            /* We are during a GC, so tethering of the CodeInfo is not necessary. */\n            CodeInfo codeInfo = CodeInfoAccess.convert(walk.getIPCodeInfo());\n            DeoptimizedFrame deoptFrame = Deoptimizer.checkDeoptimized(sp);\n            if (deoptFrame == null) {\n                if (codeInfo.isNull()) {\n                    throw JavaStackWalker.reportUnknownFrameEncountered(sp, ip, deoptFrame);\n                }\n\n                CodeInfoAccess.lookupCodeInfo(codeInfo, CodeInfoAccess.relativeIP(codeInfo, ip), queryResult);\n                assert Deoptimizer.checkDeoptimized(sp) == null : \"We are at a safepoint, so no deoptimization can have happened\";\n\n                NonmovableArray<Byte> referenceMapEncoding = CodeInfoAccess.getStackReferenceMapEncoding(codeInfo);\n                long referenceMapIndex = queryResult.getReferenceMapIndex();\n                if (referenceMapIndex == ReferenceMapIndex.NO_REFERENCE_MAP) {\n                    throw CodeInfoTable.reportNoReferenceMap(sp, ip, codeInfo);\n                }\n                CodeReferenceMapDecoder.walkOffsetsFromPointer(sp, referenceMapEncoding, referenceMapIndex, visitor, null);\n            } else {\n                /*\n                 * This is a deoptimized frame. The DeoptimizedFrame object is stored in the frame,\n                 * but it is pinned so we do not need to visit references of the frame.\n                 */\n            }\n\n            if (RuntimeCompilation.isEnabled() && !CodeInfoAccess.isAOTImageCode(codeInfo) && visitRuntimeCodeInfo) {\n                /*\n                 * Runtime-compiled code that is currently on the stack must be kept alive. So, we\n                 * mark the tether as strongly reachable. The RuntimeCodeCacheWalker will handle all\n                 * other object references later on.\n                 */\n                RuntimeCodeInfoAccess.walkTether(codeInfo, visitor);\n                assert RuntimeCodeCacheReachabilityAnalyzer.isReachable(\n                        Word.objectToUntrackedPointer(UntetheredCodeInfoAccess.getTetherUnsafe(codeInfo))\n                );\n            }\n\n            if (!JavaStackWalker.continueWalk(walk, queryResult, deoptFrame)) {\n                /* No more caller frame found. */\n                return;\n            }\n        }\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private void walkThreadLocals() {\n        Timer walkThreadLocalsTimer = timers.walkThreadLocals.open();\n        try {\n            for (IsolateThread isolateThread = VMThreads.firstThread(); isolateThread.isNonNull(); isolateThread = VMThreads.nextThread(isolateThread)) {\n                VMThreadLocalSupport.singleton().walk(isolateThread, greyToBlackObjRefVisitor);\n            }\n        } finally {\n            walkThreadLocalsTimer.close();\n        }\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private void blackenDirtyImageHeapRoots() {\n        if (!HeapImpl.usesImageHeapCardMarking()) {\n            blackenImageHeapRoots();\n            return;\n        }\n\n        Timer blackenImageHeapRootsTimer = timers.blackenImageHeapRoots.open();\n        try {\n            for (ImageHeapInfo info = HeapImpl.getFirstImageHeapInfo(); info != null; info = info.next) {\n                blackenDirtyImageHeapChunkRoots(info.getFirstWritableAlignedChunk(), info.getFirstWritableUnalignedChunk(), info.getLastWritableUnalignedChunk());\n            }\n\n            if (AuxiliaryImageHeap.isPresent()) {\n                ImageHeapInfo auxInfo = AuxiliaryImageHeap.singleton().getImageHeapInfo();\n                if (auxInfo != null) {\n                    blackenDirtyImageHeapChunkRoots(auxInfo.getFirstWritableAlignedChunk(), auxInfo.getFirstWritableUnalignedChunk(), auxInfo.getLastWritableUnalignedChunk());\n                }\n            }\n        } finally {\n            blackenImageHeapRootsTimer.close();\n        }\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private void blackenDirtyImageHeapChunkRoots(AlignedHeader firstAligned, UnalignedHeader firstUnaligned, UnalignedHeader lastUnaligned) {\n        /*\n         * We clean and remark cards of the image heap only during complete collections when we also\n         * collect the old generation and can easily remark references into it. It also only makes a\n         * difference after references to the runtime heap were nulled, which is assumed to be rare.\n         */\n        boolean clean = completeCollection;\n\n        AlignedHeader aligned = firstAligned;\n        while (aligned.isNonNull()) {\n            RememberedSet.get().walkDirtyObjects(aligned, greyToBlackObjectVisitor, clean);\n            aligned = HeapChunk.getNext(aligned);\n        }\n\n        UnalignedHeader unaligned = firstUnaligned;\n        while (unaligned.isNonNull()) {\n            RememberedSet.get().walkDirtyObjects(unaligned, greyToBlackObjectVisitor, clean);\n            if (unaligned.equal(lastUnaligned)) {\n                break;\n            }\n            unaligned = HeapChunk.getNext(unaligned);\n        }\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private void blackenImageHeapRoots() {\n        if (HeapImpl.usesImageHeapCardMarking()) {\n            // Avoid scanning the entire image heap even for complete collections: its remembered\n            // set contains references into both the runtime heap's old and young generations.\n            blackenDirtyImageHeapRoots();\n            return;\n        }\n\n        Timer blackenImageHeapRootsTimer = timers.blackenImageHeapRoots.open();\n        try {\n            for (ImageHeapInfo info = HeapImpl.getFirstImageHeapInfo(); info != null; info = info.next) {\n                blackenImageHeapRoots(info);\n            }\n\n            if (AuxiliaryImageHeap.isPresent()) {\n                ImageHeapInfo auxImageHeapInfo = AuxiliaryImageHeap.singleton().getImageHeapInfo();\n                if (auxImageHeapInfo != null) {\n                    blackenImageHeapRoots(auxImageHeapInfo);\n                }\n            }\n        } finally {\n            blackenImageHeapRootsTimer.close();\n        }\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private void blackenImageHeapRoots(ImageHeapInfo imageHeapInfo) {\n        walkImageHeapRoots(imageHeapInfo, greyToBlackObjectVisitor);\n    }\n\n    @AlwaysInline(\"GC Performance\")\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    static void walkImageHeapRoots(ImageHeapInfo imageHeapInfo, ObjectVisitor visitor) {\n        ImageHeapWalker.walkPartitionInline(imageHeapInfo.firstWritableRegularObject, imageHeapInfo.lastWritableRegularObject, visitor, true);\n        ImageHeapWalker.walkPartitionInline(imageHeapInfo.firstWritableHugeObject, imageHeapInfo.lastWritableHugeObject, visitor, false);\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private void blackenDirtyCardRoots() {\n        Timer blackenDirtyCardRootsTimer = timers.blackenDirtyCardRoots.open();\n        try {\n            /*\n             * Walk To-Space looking for dirty cards, and within those for old-to-young pointers.\n             * Promote any referenced young objects.\n             */\n            Space oldGenSpace = HeapImpl.getHeapImpl().getOldGeneration().getSpace();\n            RememberedSet.get().walkDirtyObjects(oldGenSpace, greyToBlackObjectVisitor, true);\n        } finally {\n            blackenDirtyCardRootsTimer.close();\n        }\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private static void prepareForPromotion(boolean isIncremental) {\n        HeapImpl heap = HeapImpl.getHeapImpl();\n        heap.getOldGeneration().prepareForPromotion();\n        if (isIncremental) {\n            heap.getYoungGeneration().prepareForPromotion();\n        }\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private void scanGreyObjects(boolean isIncremental) {\n        Timer scanGreyObjectsTimer = timers.scanGreyObjects.open();\n        try {\n            if (isIncremental) {\n                scanGreyObjectsLoop();\n            } else {\n                while (!markQueue.isEmpty()) {\n                    greyToBlackObjectVisitor.visitObjectInline(markQueue.pop());\n                }\n            }\n        } finally {\n            scanGreyObjectsTimer.close();\n        }\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private static void scanGreyObjectsLoop() {\n        HeapImpl heap = HeapImpl.getHeapImpl();\n        YoungGeneration youngGen = heap.getYoungGeneration();\n        OldGeneration oldGen = heap.getOldGeneration();\n        boolean hasGrey;\n        do {\n            hasGrey = youngGen.scanGreyObjects();\n            hasGrey |= oldGen.scanGreyObjects();\n        } while (hasGrey);\n    }\n\n    @AlwaysInline(\"GC performance\")\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    @SuppressWarnings(\"static-method\")\n    Object promoteObject(Object original, Word header) {\n        HeapImpl heap = HeapImpl.getHeapImpl();\n        boolean isAligned = ObjectHeaderImpl.isAlignedHeader(header);\n        Header<?> originalChunk = getChunk(original, isAligned);\n        Space originalSpace = HeapChunk.getSpace(originalChunk);\n\n        if (completeCollection) {\n            if (ObjectHeaderImpl.isIdentityHashFieldOptional()\n                    && ObjectHeaderImpl.hasIdentityHashFromAddressInline(header)\n                    && isAligned && !((AlignedHeader) originalChunk).getShouldSweepInsteadOfCompact()) {\n                /*\n                 * The object size will increase due to the identity hashcode being persisted as an additional header field.\n                 * Thus, we'll forward the object using OldGeneration#promoteAlignedObject and install the forwarding pointer.\n                 */\n            } else {\n                // Mark objects in the old generation and continue traversal\n                // as referenced objects aren't colored gray by copying!\n                assert originalSpace.isOldSpace();\n                ObjectHeaderImpl.setMarkedBit(original);\n                ObjectHeaderImpl.setRememberedSetBit(original);\n                markQueue.push(original);\n                return original; // Objects in the old generation cannot be promoted further.}\n            }\n        }\n\n        if (!originalSpace.isFromSpace()) {\n            return original;\n        }\n\n        Object result = null;\n        if (!completeCollection && originalSpace.getNextAgeForPromotion() < policy.getTenuringAge()) {\n            if (isAligned) {\n                result = heap.getYoungGeneration().promoteAlignedObject(original, (AlignedHeader) originalChunk, originalSpace);\n            } else {\n                result = heap.getYoungGeneration().promoteUnalignedObject(original, (UnalignedHeader) originalChunk, originalSpace);\n            }\n            if (result == null) {\n                accounting.onSurvivorOverflowed();\n            }\n        }\n        if (result == null) { // complete collection, tenuring age reached, or survivor space full\n            if (isAligned) {\n                result = heap.getOldGeneration().promoteAlignedObject(original, (AlignedHeader) originalChunk, originalSpace);\n            } else {\n                result = heap.getOldGeneration().promoteUnalignedObject(original, (UnalignedHeader) originalChunk, originalSpace);\n            }\n            assert result != null : \"promotion failure in old generation must have been handled\";\n        }\n\n        if (completeCollection) {\n            ObjectHeaderImpl.setMarkedBit(result);\n            markQueue.push(result);\n            assert !ObjectHeaderImpl.hasIdentityHashFromAddressInline(ObjectHeaderImpl.readHeaderFromObject(result));\n            assert !ObjectHeaderImpl.hasMarkedBit(original);\n        }\n\n        return result;\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private static Header<?> getChunk(Object obj, boolean isAligned) {\n        if (isAligned) {\n            return AlignedHeapChunk.getEnclosingChunk(obj);\n        }\n        assert ObjectHeaderImpl.isUnalignedObject(obj);\n        return UnalignedHeapChunk.getEnclosingChunk(obj);\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private void promotePinnedObject(PinnedObjectImpl pinned) {\n        HeapImpl heap = HeapImpl.getHeapImpl();\n        Object referent = pinned.getObject();\n        if (referent != null && !heap.isInImageHeap(referent)) {\n            boolean isAligned = ObjectHeaderImpl.isAlignedObject(referent);\n            Header<?> originalChunk = getChunk(referent, isAligned);\n\n            if (completeCollection) {\n                /*\n                 * As we are using the Mark-and-Compact approach for complete collections,\n                 * we have to make sure that the contained chunk is swept instead of compacted.\n                 */\n                heap.getOldGeneration().markPinnedObject(referent, originalChunk, isAligned);\n                return;\n            }\n\n            Space originalSpace = HeapChunk.getSpace(originalChunk);\n            if (originalSpace.isFromSpace() && !originalSpace.isOldSpace()) {\n                boolean promoted = false;\n                if (originalSpace.getNextAgeForPromotion() < policy.getTenuringAge()) {\n                    promoted = heap.getYoungGeneration().promoteChunk(originalChunk, isAligned, originalSpace);\n                    if (!promoted) {\n                        accounting.onSurvivorOverflowed();\n                    }\n                }\n                if (!promoted) {\n                    heap.getOldGeneration().promoteChunk(originalChunk, isAligned, originalSpace);\n                }\n            }\n        }\n    }\n\n    private static void swapSpaces() {\n        HeapImpl heap = HeapImpl.getHeapImpl();\n        heap.getYoungGeneration().swapSpaces();\n    }\n\n    private void releaseSpaces() {\n        HeapImpl heap = HeapImpl.getHeapImpl();\n\n        heap.getYoungGeneration().releaseSpaces(chunkReleaser);\n        if (completeCollection) {\n            heap.getOldGeneration().releaseSpaces(chunkReleaser);\n        }\n    }\n\n    /**\n     * Inside a VMOperation, we are not allowed to do certain things, e.g., perform synchronization\n     * (because it can deadlock when a lock is held outside the VMOperation). Similar restrictions\n     * apply if we are too early in the attach sequence of a thread.\n     */\n    static void doReferenceHandling() {\n        assert !VMOperation.isInProgress() : \"could result in deadlocks\";\n        assert PlatformThreads.isCurrentAssigned() : \"thread is not fully initialized yet\";\n        /* Most of the time, we won't have a pending reference list. So, we do that check first. */\n        if (HeapImpl.getHeapImpl().hasReferencePendingListUnsafe()) {\n            long startTime = System.nanoTime();\n            ReferenceHandler.processPendingReferencesInRegularThread();\n\n            if (SubstrateGCOptions.VerboseGC.getValue() && SerialGCOptions.PrintGCTimes.getValue()) {\n                long executionTime = System.nanoTime() - startTime;\n                Log.log().string(\"[GC epilogue reference processing and cleaners: \").signed(executionTime).string(\"]\").newline();\n            }\n        }\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public UnsignedWord getCollectionEpoch() {\n        return collectionEpoch;\n    }\n\n    public long getMillisSinceLastWholeHeapExamined() {\n        long startMillis;\n        if (lastWholeHeapExaminedTimeMillis < 0) {\n            // no full GC has yet been run, use time since the first allocation\n            startMillis = Isolates.getCurrentStartTimeMillis();\n        } else {\n            startMillis = lastWholeHeapExaminedTimeMillis;\n        }\n        return System.currentTimeMillis() - startMillis;\n    }\n\n    @Fold\n    public static GCAccounting getAccounting() {\n        return GCImpl.getGCImpl().accounting;\n    }\n\n    @Fold\n    public static CollectionPolicy getPolicy() {\n        return GCImpl.getGCImpl().policy;\n    }\n\n    @Fold\n    public static boolean hasNeverCollectPolicy() {\n        return getPolicy() instanceof NeverCollect;\n    }\n\n    @Fold\n    GreyToBlackObjectVisitor getGreyToBlackObjectVisitor() {\n        return greyToBlackObjectVisitor;\n    }\n\n    @Fold\n    MarkQueue getMarkQueue() {\n        return markQueue;\n    }\n\n    private static class CollectionVMOperation extends NativeVMOperation {\n        private final NoAllocationVerifier noAllocationVerifier = NoAllocationVerifier.factory(\"CollectionVMOperation\", false);\n\n        CollectionVMOperation() {\n            super(VMOperationInfos.get(CollectionVMOperation.class, \"Garbage collection\", SystemEffect.SAFEPOINT));\n        }\n\n        @Override\n        @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        public boolean isGC() {\n            return true;\n        }\n\n        @Override\n        @RestrictHeapAccess(access = RestrictHeapAccess.Access.NO_ALLOCATION, reason = \"Must not allocate while collecting\")\n        protected void operate(NativeVMOperationData data) {\n            NoAllocationVerifier nav = noAllocationVerifier.open();\n            try {\n                collect((CollectionVMOperationData) data);\n            } catch (Throwable t) {\n                throw VMError.shouldNotReachHere(t);\n            } finally {\n                nav.close();\n            }\n        }\n\n        private static void collect(CollectionVMOperationData data) {\n            /*\n             * Exceptions during collections are fatal. The heap is likely in an inconsistent state.\n             * The GC must also be allocation free, i.e., we cannot allocate exception stack traces\n             * while in the GC. This is bad for diagnosing errors in the GC. To improve the\n             * situation a bit, we switch on the flag to make implicit exceptions such as\n             * NullPointerExceptions fatal errors. This ensures that we fail early at the place\n             * where the fatal error reporting can still dump the full stack trace.\n             */\n            ImplicitExceptions.activateImplicitExceptionsAreFatal();\n            try {\n                HeapImpl.getGCImpl().collectOperation(data);\n            } finally {\n                ImplicitExceptions.deactivateImplicitExceptionsAreFatal();\n            }\n        }\n\n        @Override\n        protected boolean hasWork(NativeVMOperationData data) {\n            CollectionVMOperationData d = (CollectionVMOperationData) data;\n            if (d.getForceFullGC()) {\n                /* Skip if another full GC happened in the meanwhile. */\n                return GCImpl.getAccounting().getCompleteCollectionCount() == d.getCompleteCollectionCount();\n            }\n            /* Skip if any other GC happened in the meanwhile. */\n            return GCImpl.getGCImpl().getCollectionEpoch().equal(d.getRequestingEpoch());\n        }\n    }\n\n    @RawStructure\n    private interface CollectionVMOperationData extends NativeVMOperationData {\n        @RawField\n        int getCauseId();\n\n        @RawField\n        void setCauseId(int value);\n\n        @RawField\n        UnsignedWord getRequestingEpoch();\n\n        @RawField\n        void setRequestingEpoch(UnsignedWord value);\n\n        @RawField\n        long getRequestingNanoTime();\n\n        @RawField\n        void setRequestingNanoTime(long value);\n\n        @RawField\n        boolean getForceFullGC();\n\n        @RawField\n        void setForceFullGC(boolean value);\n\n        @RawField\n        long getCompleteCollectionCount();\n\n        @RawField\n        void setCompleteCollectionCount(long value);\n\n        @RawField\n        boolean getOutOfMemory();\n\n        @RawField\n        void setOutOfMemory(boolean value);\n    }\n\n    public static class ChunkReleaser {\n        private AlignedHeader firstAligned;\n        private UnalignedHeader firstUnaligned;\n\n        @Platforms(Platform.HOSTED_ONLY.class)\n        ChunkReleaser() {\n        }\n\n        public boolean isEmpty() {\n            return firstAligned.isNull() && firstUnaligned.isNull();\n        }\n\n        @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        public void add(AlignedHeader chunks) {\n            if (chunks.isNonNull()) {\n                assert HeapChunk.getPrevious(chunks).isNull() : \"prev must be null\";\n                if (firstAligned.isNonNull()) {\n                    AlignedHeader lastNewChunk = getLast(chunks);\n                    HeapChunk.setNext(lastNewChunk, firstAligned);\n                    HeapChunk.setPrevious(firstAligned, lastNewChunk);\n                }\n                firstAligned = chunks;\n            }\n        }\n\n        @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        public void add(UnalignedHeader chunks) {\n            if (chunks.isNonNull()) {\n                assert HeapChunk.getPrevious(chunks).isNull() : \"prev must be null\";\n                if (firstUnaligned.isNonNull()) {\n                    UnalignedHeader lastNewChunk = getLast(chunks);\n                    HeapChunk.setNext(lastNewChunk, firstUnaligned);\n                    HeapChunk.setPrevious(firstUnaligned, lastNewChunk);\n                }\n                firstUnaligned = chunks;\n            }\n        }\n\n        void release(boolean keepAllAlignedChunks) {\n            if (firstAligned.isNonNull()) {\n                HeapImpl.getChunkProvider().consumeAlignedChunks(firstAligned, keepAllAlignedChunks);\n                firstAligned = WordFactory.nullPointer();\n            }\n            if (firstUnaligned.isNonNull()) {\n                HeapChunkProvider.consumeUnalignedChunks(firstUnaligned);\n                firstUnaligned = WordFactory.nullPointer();\n            }\n        }\n\n        @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        private static <T extends Header<T>> T getLast(T chunks) {\n            T prev = chunks;\n            T next = HeapChunk.getNext(prev);\n            while (next.isNonNull()) {\n                prev = next;\n                next = HeapChunk.getNext(prev);\n            }\n            return prev;\n        }\n    }\n\n    private static void printGCSummary() {\n        if (!SerialGCOptions.PrintGCSummary.getValue()) {\n            return;\n        }\n\n        PrintGCSummaryOperation vmOp = new PrintGCSummaryOperation();\n        vmOp.enqueue();\n    }\n\n    private static class PrintGCSummaryOperation extends JavaVMOperation {\n        protected PrintGCSummaryOperation() {\n            super(VMOperationInfos.get(PrintGCSummaryOperation.class, \"Print GC summary\", SystemEffect.SAFEPOINT));\n        }\n\n        @Override\n        protected void operate() {\n            ThreadLocalAllocation.disableAndFlushForAllThreads();\n\n            Log log = Log.log();\n            log.string(\"GC summary\").indent(true);\n            HeapImpl heap = HeapImpl.getHeapImpl();\n            Space edenSpace = heap.getYoungGeneration().getEden();\n            UnsignedWord youngChunkBytes = edenSpace.getChunkBytes();\n            UnsignedWord youngObjectBytes = edenSpace.computeObjectBytes();\n\n            GCAccounting accounting = GCImpl.getAccounting();\n            UnsignedWord allocatedChunkBytes = accounting.getTotalAllocatedChunkBytes().add(youngChunkBytes);\n            UnsignedWord allocatedObjectBytes = accounting.getAllocatedObjectBytes().add(youngObjectBytes);\n\n            log.string(\"Collected chunk bytes: \").rational(accounting.getTotalCollectedChunkBytes(), M, 2).string(\"M\").newline();\n            log.string(\"Collected object bytes: \").rational(accounting.getTotalCollectedObjectBytes(), M, 2).string(\"M\").newline();\n            log.string(\"Allocated chunk bytes: \").rational(allocatedChunkBytes, M, 2).string(\"M\").newline();\n            log.string(\"Allocated object bytes: \").rational(allocatedObjectBytes, M, 2).string(\"M\").newline();\n\n            long incrementalNanos = accounting.getIncrementalCollectionTotalNanos();\n            log.string(\"Incremental GC count: \").signed(accounting.getIncrementalCollectionCount()).newline();\n            log.string(\"Incremental GC time: \").rational(incrementalNanos, TimeUtils.nanosPerSecond, 3).string(\"s\").newline();\n            long completeNanos = accounting.getCompleteCollectionTotalNanos();\n            log.string(\"Complete GC count: \").signed(accounting.getCompleteCollectionCount()).newline();\n            log.string(\"Complete GC time: \").rational(completeNanos, TimeUtils.nanosPerSecond, 3).string(\"s\").newline();\n\n            long gcNanos = incrementalNanos + completeNanos;\n\n            long mutatorNanos = GCImpl.getGCImpl().timers.mutator.getMeasuredNanos();\n            long totalNanos = gcNanos + mutatorNanos;\n            long roundedGCLoad = (0 < totalNanos ? TimeUtils.roundedDivide(100 * gcNanos, totalNanos) : 0);\n            log.string(\"GC time: \").rational(gcNanos, TimeUtils.nanosPerSecond, 3).string(\"s\").newline();\n            log.string(\"Run time: \").rational(totalNanos, TimeUtils.nanosPerSecond, 3).string(\"s\").newline();\n            log.string(\"GC load: \").signed(roundedGCLoad).string(\"%\").indent(false);\n        }\n    }\n}",
                "methodCount": 87
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 15,
                "candidates": [
                    {
                        "lineStart": 445,
                        "lineEnd": 447,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method checkSanityAfterCollection to class ChunkReleaser",
                        "description": "Move method checkSanityAfterCollection to com.oracle.svm.core.genscavenge.GCImpl.ChunkReleaser\nRationale: null",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1359,
                        "lineEnd": 1361,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method isEmpty to class AlignedHeader",
                        "description": "Move method isEmpty to com.oracle.svm.core.genscavenge.AlignedHeapChunk.AlignedHeader\nRationale: The method isEmpty() checks the properties firstAligned and firstUnaligned, which suggest a relationship with headers or alignment. `AlignedHeader` already includes methods for managing aligned structures which makes it a logical place to manage a method related to alignment status. Furthermore, `AlignedHeader` has existing fields and methods that are more closely related to alignment operations, making it a semantically appropriate place for the isEmpty() method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 211,
                        "lineEnd": 239,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method collectOperation to class CollectionVMOperation",
                        "description": "Move method collectOperation to com.oracle.svm.core.genscavenge.GCImpl.CollectionVMOperation\nRationale: The method `collectOperation` is deeply tied to garbage collection operations, which are directly managed by `CollectionVMOperation`. This class already defines methods like `collect`, which call out to `HeapImpl.getGCImpl().collectOperation`. Thus, moving `collectOperation` to `CollectionVMOperation` centralizes the logic for garbage collection operations, ensuring a single-responsibility principle and maintaining coherence in the codebase.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1019,
                        "lineEnd": 1024,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method walkImageHeapRoots to class Space",
                        "description": "move method walkImageHeapRoots to PsiClass:Space\nRationale: The walkImageHeapRoots method is integrally related to heap management and object traversal, which is the core functionality of the Space class. The Space class already contains methods for walking objects and managing heap chunks, making it a natural fit. Moving the method here centralizes heap traversal logic and enhances code cohesion.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 206,
                        "lineEnd": 209,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method enqueueCollectOperation to class CollectionVMOperation",
                        "description": "Move method enqueueCollectOperation to com.oracle.svm.core.genscavenge.GCImpl.CollectionVMOperation\nRationale: The method enqueueCollectOperation aligns with the management of operations specific to the collection process. Since CollectionVMOperation already interacts with CollectionVMOperationData and involves the collectOperation method, moving enqueueCollectOperation here ensures a coherent and focused class responsibility. Additionally, this class handles various operations during garbage collection, making it the most logical place for the method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 379,
                        "lineEnd": 401,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method printGCBefore to class CollectionVMOperation",
                        "description": "Move method printGCBefore to com.oracle.svm.core.genscavenge.GCImpl.CollectionVMOperation\nRationale: The `printGCBefore` method is tightly coupled with the operations and attributes of garbage collection, such as the collection epoch, memory details, and GC policies. The `CollectionVMOperation` class is designed to manage garbage collection operations including attributes and behaviors. This makes it a natural fit for the method since it centralizes the logging and monitoring of these operations within a single place, improving cohesion and maintainability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1196,
                        "lineEnd": 1214,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method doReferenceHandling to class ReferenceObjectProcessing",
                        "description": "move method doReferenceHandling to PsiClass:ReferenceObjectProcessing\nRationale: The method 'doReferenceHandling' directly deals with pending references and their processing, which fits well within the scope of the 'ReferenceObjectProcessing' class. This class is designed to handle reference objects during garbage collection, and contains similar methods for processing and handling references. Moving the method to this class ensures that all reference handling logic is centralized, making it easier to maintain and understand.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 825,
                        "lineEnd": 839,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method blackenStackRoots to class CollectionVMOperation",
                        "description": "Move method blackenStackRoots to com.oracle.svm.core.genscavenge.GCImpl.CollectionVMOperation\nRationale: The `blackenStackRoots` method is closely related to garbage collection operations, as indicated by its use of GC-related methods and classes such as `walkStackRoots` and `greyToBlackObjRefVisitor`. The `CollectionVMOperation` class is designed for managing GC operations, as demonstrated by its responsibilities including handling the actual collection process and being flagged with GC-related tags. Moving the method here makes it part of the GC operation suite and ensures it resides in a class with similar responsibilities, thus enhancing code coherence.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 184,
                        "lineEnd": 204,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method collectWithoutAllocating to class CollectionVMOperation",
                        "description": "Move method collectWithoutAllocating to com.oracle.svm.core.genscavenge.GCImpl.CollectionVMOperation\nRationale: The method collectWithoutAllocating() is responsible for triggering a garbage collection operation and fits logically with other VM operations related to garbage collection in the CollectionVMOperation class. Additionally, the method works closely with the CollectionVMOperationData class and GCImpl, both of which are highly relevant within the CollectionVMOperation class. This ensures cleaner architecture and better encapsulation.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 691,
                        "lineEnd": 773,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method cheneyScanFromDirtyRoots to class CollectionVMOperation",
                        "description": "Move method cheneyScanFromDirtyRoots to com.oracle.svm.core.genscavenge.GCImpl.CollectionVMOperation\nRationale: The method cheneyScanFromDirtyRoots() is intricately involved with garbage collection processes such as heap snapshotting, promoting pinned objects, and scanning roots, directly matching the primary responsibilities of the CollectionVMOperation class. Its operations align closely with the garbage collection process managed by CollectionVMOperation, which already handles similar tasks in its operate method. Additionally, the use of @Uninterruptible annotation is a common practice in both the current method and the CollectionVMOperation class, indicating that the method is designed to be run in an uninterrupted manner during garbage collection.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 775,
                        "lineEnd": 797,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method promoteChunksWithPinnedObjects to class ChunkReleaser",
                        "description": "Move method promoteChunksWithPinnedObjects to com.oracle.svm.core.genscavenge.GCImpl.ChunkReleaser\nRationale: The method `promoteChunksWithPinnedObjects` deals with promoting chunks that contain pinned objects, which is closely aligned with the responsibilities of the `ChunkReleaser` class. The `ChunkReleaser` class already has functionalities related to handling chunks (both aligned and unaligned), and managing the promotion of chunks fits naturally into this class's domain. The method involves detailed operations on chunks that seem more suitable for a class that is specifically targeted at chunk management.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 588,
                        "lineEnd": 601,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method walkRuntimeCodeCache to class CollectionVMOperation",
                        "description": "Move method walkRuntimeCodeCache to com.oracle.svm.core.genscavenge.GCImpl.CollectionVMOperation\nRationale: The method walkRuntimeCodeCache() is closely related to memory management and garbage collection, primarily focusing on the runtime compiled code. CollectionVMOperation is responsible for various operations during garbage collection, and already includes methods dealing with memory on a low level, handling data similarly to how walkRuntimeCodeCache() does. This makes it a more cohesive and relevant location for the method in terms of its functionality and execution context.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1412,
                        "lineEnd": 1419,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method printGCSummary to class PrintGCSummaryOperation",
                        "description": "move method printGCSummary to PsiClass:PrintGCSummaryOperation\nRationale: The method 'printGCSummary()' directly relates to the functionality provided by PrintGCSummaryOperation. Since PrintGCSummaryOperation is specifically designed to handle and operate on GC summary printing operations, it is the most appropriate class for containing this method. Additionally, enqueuing a PrintGCSummaryOperation is an intrinsic part of 'printGCSummary()', further suggesting it belongs logically within PrintGCSummaryOperation.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 403,
                        "lineEnd": 428,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method printGCAfter to class CollectionPolicy",
                        "description": "Move method printGCAfter to com.oracle.svm.core.genscavenge.CollectionPolicy\nRationale: The method `printGCAfter(GCCause cause)` is highly focused on the details of garbage collection processes. It relies on heap accounting, GC causes, verbose GC options, and printing heap size changes, all of which are closely related to policies on when and how garbage collection should be executed. The `CollectionPolicy` interface governs the overall policies and parameters of the garbage collection and seems to be the natural place for methods that are directly involved in reporting and logging GC details. This move would also align with the principle of keeping behavior related to a specific functionality grouped together.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 868,
                        "lineEnd": 925,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method walkStack to class ReferenceObjectProcessing",
                        "description": "move method walkStack to PsiClass:ReferenceObjectProcessing\nRationale: The walkStack method is concerned with walking stack frames and handling CodeInfo and references, which closely aligns with the purpose of the ReferenceObjectProcessing class. This class already contains methods for discovering and processing references during garbage collection (GC), making it a suitable home for this method. Moving walkStack here would centralize related functionalities of reference processing during GC, ensuring better maintainability and cohesion.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getCollectionEpoch",
                            "method_signature": "public UnsignedWord getCollectionEpoch()",
                            "target_class": "GCAccounting",
                            "rationale": "The getCollectionEpoch method pertains to GC accounting and epoch management. Since it involves accounting operations, it would be more appropriate to place it within the GCAccounting class where similar responsibilities are handled."
                        },
                        {
                            "method_name": "getMillisSinceLastWholeHeapExamined",
                            "method_signature": "public long getMillisSinceLastWholeHeapExamined()",
                            "target_class": "HeapImpl",
                            "rationale": "The getMillisSinceLastWholeHeapExamined method calculates the time since the last complete collection of the heap. As this function concerns heap status, it would be more appropriate to place it in the HeapImpl class."
                        },
                        {
                            "method_name": "swapSpaces",
                            "method_signature": "private static void swapSpaces()",
                            "target_class": "HeapImpl",
                            "rationale": "The swapSpaces method deals with managing spaces within the heap. Placing it in the HeapImpl class makes logical sense as it deals with heap-level operations."
                        },
                        {
                            "method_name": "releaseSpaces",
                            "method_signature": "private void releaseSpaces()",
                            "target_class": "HeapImpl",
                            "rationale": "The releaseSpaces method pertains to the release and management of heap spaces. It logically belongs in the HeapImpl class, which is responsible for heap management."
                        },
                        {
                            "method_name": "doReferenceHandling",
                            "method_signature": "static void doReferenceHandling()",
                            "target_class": "ReferenceHandler",
                            "rationale": "The doReferenceHandling method manages pending references and epilogue actions. It would be more appropriate in the ReferenceHandler class, as it deals with managing and processing references."
                        }
                    ],
                    "llm_response_time": 7696
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "getName",
                            "method_signature": "public String getName()",
                            "target_class": "Policy",
                            "rationale": "The method getName() is checking the value of policy-related options and returning a name based on them. It is more appropriate to exist within the context of the Policy class."
                        },
                        {
                            "method_name": "getDefaultMaxHeapSize",
                            "method_signature": "public String getDefaultMaxHeapSize()",
                            "target_class": "Policy",
                            "rationale": "The method getDefaultMaxHeapSize() is dealing with heap size configurations, which are typically managed by a policy-related class."
                        },
                        {
                            "method_name": "getMillisSinceLastWholeHeapExamined",
                            "method_signature": "public long getMillisSinceLastWholeHeapExamined()",
                            "target_class": "HeapImpl",
                            "rationale": "The method getMillisSinceLastWholeHeapExamined() directly depends on heap examination timings and information that HeapImpl is responsible for."
                        },
                        {
                            "method_name": "doReferenceHandling",
                            "method_signature": "public static void doReferenceHandling()",
                            "target_class": "ReferenceHandler",
                            "rationale": "The method doReferenceHandling() deals with pending references and their processing, which is more aligned with the responsibilities of the ReferenceHandler class."
                        },
                        {
                            "method_name": "printGCSummary",
                            "method_signature": "private static void printGCSummary()",
                            "target_class": "Log",
                            "rationale": "The method printGCSummary() is responsible for logging GC related summaries. It is more appropriate for this functionality to reside within the Log class."
                        }
                    ],
                    "llm_response_time": 6978
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "getChunkBytes",
                            "method_signature": "public static UnsignedWord getChunkBytes()",
                            "target_class": "HeapImpl",
                            "rationale": "getChunkBytes() directly operates on HeapImpl's generations, making it more logical to be a part of the HeapImpl class."
                        },
                        {
                            "method_name": "doReferenceHandling",
                            "method_signature": "static void doReferenceHandling()",
                            "target_class": "ReferenceHandler",
                            "rationale": "doReferenceHandling() deals with handling references and involves ReferenceHandler, meaning it would be more appropriate within the ReferenceHandler class."
                        },
                        {
                            "method_name": "printGCSummary",
                            "method_signature": "private static void printGCSummary()",
                            "target_class": "GCLogging",
                            "rationale": "printGCSummary() focuses on logging GC summaries, which makes it fitting for a dedicated logging or reporting class like GCLogging."
                        },
                        {
                            "method_name": "printGCBefore",
                            "method_signature": "private void printGCBefore(GCCause cause)",
                            "target_class": "GCLogging",
                            "rationale": "printGCBefore() is responsible for logging GC-related data before a collection, making it better suited for a GCLogging class."
                        },
                        {
                            "method_name": "printGCAfter",
                            "method_signature": "private void printGCAfter(GCCause cause)",
                            "target_class": "GCLogging",
                            "rationale": "printGCAfter() handles logging activities after a GC collection, which most appropriately belongs to a GCLogging class."
                        },
                        {
                            "method_name": "printHeapSizeChange",
                            "method_signature": "private void printHeapSizeChange(String text, UnsignedWord before, UnsignedWord after)",
                            "target_class": "GCLogging",
                            "rationale": "printHeapSizeChange() is a logging helper method used to print heap size changes, making it a better fit in GCLogging."
                        },
                        {
                            "method_name": "getMillisSinceLastWholeHeapExamined",
                            "method_signature": "public long getMillisSinceLastWholeHeapExamined()",
                            "target_class": "HeapImpl",
                            "rationale": "getMillisSinceLastWholeHeapExamined() calculates the time since the last full heap examination, a core heap operation, making it suitable for HeapImpl."
                        }
                    ],
                    "llm_response_time": 11558
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "collectWithoutAllocating",
                            "method_signature": "@Uninterruptible(reason = \"Avoid races with other threads that also try to trigger a GC\")\n    @RestrictHeapAccess(access = RestrictHeapAccess.Access.NO_ALLOCATION, reason = \"Must not allocate in the implementation of garbage collection.\") collectWithoutAllocating(GCCause cause, boolean forceFullGC)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "enqueueCollectOperation",
                            "method_signature": "@Uninterruptible(reason = \"Used as a transition between uninterruptible and interruptible code\", calleeMustBe = false)\n    private enqueueCollectOperation(CollectionVMOperationData data)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "collectOperation",
                            "method_signature": "private collectOperation(CollectionVMOperationData data)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "doCollectImpl",
                            "method_signature": "private doCollectImpl(GCCause cause, long requestingNanoTime, boolean forceFullGC)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "doCollectOnce",
                            "method_signature": "private doCollectOnce(GCCause cause, long requestingNanoTime, boolean complete, boolean followsIncremental)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verifyBeforeGC",
                            "method_signature": "private verifyBeforeGC()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verifyAfterGC",
                            "method_signature": "private verifyAfterGC()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "printGCBefore",
                            "method_signature": "private printGCBefore(GCCause cause)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "printGCAfter",
                            "method_signature": "private printGCAfter(GCCause cause)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "checkSanityAfterCollection",
                            "method_signature": "private checkSanityAfterCollection(YoungGeneration youngGen)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "scavenge",
                            "method_signature": "private scavenge(boolean incremental)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "walkRuntimeCodeCache",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private walkRuntimeCodeCache()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "cleanRuntimeCodeCache",
                            "method_signature": "private cleanRuntimeCodeCache()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "cheneyScanFromRoots",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private cheneyScanFromRoots()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "cheneyScanFromDirtyRoots",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private cheneyScanFromDirtyRoots()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "promoteChunksWithPinnedObjects",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private promoteChunksWithPinnedObjects()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "blackenStackRoots",
                            "method_signature": "@NeverInline(\"Starting a stack walk in the caller frame. \" +\n                    \"Note that we could start the stack frame also further down the stack, because GC stack frames must not access any objects that are processed by the GC. \" +\n                    \"But we don't store stack frame information for the first frame we would need to process.\")\n    @Uninterruptible(reason = \"Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.\")\n    private blackenStackRoots()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "walkStack",
                            "method_signature": "@AlwaysInline(\"GC performance\")\n    @Uninterruptible(reason = \"Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.\", mayBeInlined = true)\n    private static walkStack(JavaStackWalk walk, ObjectReferenceVisitor visitor, boolean visitRuntimeCodeInfo)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "walkThreadLocals",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private walkThreadLocals()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "blackenDirtyImageHeapRoots",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private blackenDirtyImageHeapRoots()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "blackenImageHeapRoots",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private blackenImageHeapRoots()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "walkImageHeapRoots",
                            "method_signature": "@AlwaysInline(\"GC Performance\")\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    static walkImageHeapRoots(ImageHeapInfo imageHeapInfo, ObjectVisitor visitor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "blackenDirtyCardRoots",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private blackenDirtyCardRoots()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "scanGreyObjects",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private scanGreyObjects(boolean isIncremental)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "promoteObject",
                            "method_signature": "@AlwaysInline(\"GC performance\")\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    @SuppressWarnings(\"static-method\") promoteObject(Object original, Word header)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "promotePinnedObject",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private promotePinnedObject(PinnedObjectImpl pinned)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "doReferenceHandling",
                            "method_signature": "static doReferenceHandling()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isEmpty",
                            "method_signature": "public isEmpty()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "add",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        public add(AlignedHeader chunks)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "add",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        public add(UnalignedHeader chunks)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "release",
                            "method_signature": " release(boolean keepAllAlignedChunks)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "printGCSummary",
                            "method_signature": "private static printGCSummary()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "checkSanityAfterCollection",
                            "method_signature": "private checkSanityAfterCollection(YoungGeneration youngGen)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isEmpty",
                            "method_signature": "public isEmpty()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "collectOperation",
                            "method_signature": "private collectOperation(CollectionVMOperationData data)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "walkImageHeapRoots",
                            "method_signature": "@AlwaysInline(\"GC Performance\")\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    static walkImageHeapRoots(ImageHeapInfo imageHeapInfo, ObjectVisitor visitor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "enqueueCollectOperation",
                            "method_signature": "@Uninterruptible(reason = \"Used as a transition between uninterruptible and interruptible code\", calleeMustBe = false)\n    private enqueueCollectOperation(CollectionVMOperationData data)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "printGCBefore",
                            "method_signature": "private printGCBefore(GCCause cause)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "doReferenceHandling",
                            "method_signature": "static doReferenceHandling()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "blackenStackRoots",
                            "method_signature": "@NeverInline(\"Starting a stack walk in the caller frame. \" +\n                    \"Note that we could start the stack frame also further down the stack, because GC stack frames must not access any objects that are processed by the GC. \" +\n                    \"But we don't store stack frame information for the first frame we would need to process.\")\n    @Uninterruptible(reason = \"Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.\")\n    private blackenStackRoots()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "collectWithoutAllocating",
                            "method_signature": "@Uninterruptible(reason = \"Avoid races with other threads that also try to trigger a GC\")\n    @RestrictHeapAccess(access = RestrictHeapAccess.Access.NO_ALLOCATION, reason = \"Must not allocate in the implementation of garbage collection.\") collectWithoutAllocating(GCCause cause, boolean forceFullGC)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "cheneyScanFromDirtyRoots",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private cheneyScanFromDirtyRoots()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "promoteChunksWithPinnedObjects",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private promoteChunksWithPinnedObjects()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "walkRuntimeCodeCache",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private walkRuntimeCodeCache()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "printGCSummary",
                            "method_signature": "private static printGCSummary()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "printGCAfter",
                            "method_signature": "private printGCAfter(GCCause cause)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "walkStack",
                            "method_signature": "@AlwaysInline(\"GC performance\")\n    @Uninterruptible(reason = \"Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.\", mayBeInlined = true)\n    private static walkStack(JavaStackWalk walk, ObjectReferenceVisitor visitor, boolean visitRuntimeCodeInfo)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "private checkSanityAfterCollection(YoungGeneration youngGen)": {
                        "first": {
                            "method_name": "checkSanityAfterCollection",
                            "method_signature": "private checkSanityAfterCollection(YoungGeneration youngGen)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.35574410382087135
                    },
                    "public isEmpty()": {
                        "first": {
                            "method_name": "isEmpty",
                            "method_signature": "public isEmpty()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4062137370268077
                    },
                    "private collectOperation(CollectionVMOperationData data)": {
                        "first": {
                            "method_name": "collectOperation",
                            "method_signature": "private collectOperation(CollectionVMOperationData data)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.44708090277651497
                    },
                    "@AlwaysInline(\"GC Performance\")\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    static walkImageHeapRoots(ImageHeapInfo imageHeapInfo, ObjectVisitor visitor)": {
                        "first": {
                            "method_name": "walkImageHeapRoots",
                            "method_signature": "@AlwaysInline(\"GC Performance\")\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    static walkImageHeapRoots(ImageHeapInfo imageHeapInfo, ObjectVisitor visitor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4510935948122189
                    },
                    "@Uninterruptible(reason = \"Used as a transition between uninterruptible and interruptible code\", calleeMustBe = false)\n    private enqueueCollectOperation(CollectionVMOperationData data)": {
                        "first": {
                            "method_name": "enqueueCollectOperation",
                            "method_signature": "@Uninterruptible(reason = \"Used as a transition between uninterruptible and interruptible code\", calleeMustBe = false)\n    private enqueueCollectOperation(CollectionVMOperationData data)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.503315593922668
                    },
                    "private printGCBefore(GCCause cause)": {
                        "first": {
                            "method_name": "printGCBefore",
                            "method_signature": "private printGCBefore(GCCause cause)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5115763861035519
                    },
                    "static doReferenceHandling()": {
                        "first": {
                            "method_name": "doReferenceHandling",
                            "method_signature": "static doReferenceHandling()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5254556221383362
                    },
                    "@NeverInline(\"Starting a stack walk in the caller frame. \" +\n                    \"Note that we could start the stack frame also further down the stack, because GC stack frames must not access any objects that are processed by the GC. \" +\n                    \"But we don't store stack frame information for the first frame we would need to process.\")\n    @Uninterruptible(reason = \"Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.\")\n    private blackenStackRoots()": {
                        "first": {
                            "method_name": "blackenStackRoots",
                            "method_signature": "@NeverInline(\"Starting a stack walk in the caller frame. \" +\n                    \"Note that we could start the stack frame also further down the stack, because GC stack frames must not access any objects that are processed by the GC. \" +\n                    \"But we don't store stack frame information for the first frame we would need to process.\")\n    @Uninterruptible(reason = \"Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.\")\n    private blackenStackRoots()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5419002800136072
                    },
                    "@Uninterruptible(reason = \"Avoid races with other threads that also try to trigger a GC\")\n    @RestrictHeapAccess(access = RestrictHeapAccess.Access.NO_ALLOCATION, reason = \"Must not allocate in the implementation of garbage collection.\") collectWithoutAllocating(GCCause cause, boolean forceFullGC)": {
                        "first": {
                            "method_name": "collectWithoutAllocating",
                            "method_signature": "@Uninterruptible(reason = \"Avoid races with other threads that also try to trigger a GC\")\n    @RestrictHeapAccess(access = RestrictHeapAccess.Access.NO_ALLOCATION, reason = \"Must not allocate in the implementation of garbage collection.\") collectWithoutAllocating(GCCause cause, boolean forceFullGC)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5801750422005362
                    },
                    "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private cheneyScanFromDirtyRoots()": {
                        "first": {
                            "method_name": "cheneyScanFromDirtyRoots",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private cheneyScanFromDirtyRoots()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6093241149141739
                    },
                    "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private promoteChunksWithPinnedObjects()": {
                        "first": {
                            "method_name": "promoteChunksWithPinnedObjects",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private promoteChunksWithPinnedObjects()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6404798129940036
                    },
                    "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private walkRuntimeCodeCache()": {
                        "first": {
                            "method_name": "walkRuntimeCodeCache",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private walkRuntimeCodeCache()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6441739163078851
                    },
                    "private static printGCSummary()": {
                        "first": {
                            "method_name": "printGCSummary",
                            "method_signature": "private static printGCSummary()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6488296466072775
                    },
                    "private printGCAfter(GCCause cause)": {
                        "first": {
                            "method_name": "printGCAfter",
                            "method_signature": "private printGCAfter(GCCause cause)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6494080544167484
                    },
                    "@AlwaysInline(\"GC performance\")\n    @Uninterruptible(reason = \"Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.\", mayBeInlined = true)\n    private static walkStack(JavaStackWalk walk, ObjectReferenceVisitor visitor, boolean visitRuntimeCodeInfo)": {
                        "first": {
                            "method_name": "walkStack",
                            "method_signature": "@AlwaysInline(\"GC performance\")\n    @Uninterruptible(reason = \"Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.\", mayBeInlined = true)\n    private static walkStack(JavaStackWalk walk, ObjectReferenceVisitor visitor, boolean visitRuntimeCodeInfo)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6885317253715304
                    }
                },
                "voyage": {
                    "public isEmpty()": {
                        "first": {
                            "method_name": "isEmpty",
                            "method_signature": "public isEmpty()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2965118894136499
                    },
                    "private checkSanityAfterCollection(YoungGeneration youngGen)": {
                        "first": {
                            "method_name": "checkSanityAfterCollection",
                            "method_signature": "private checkSanityAfterCollection(YoungGeneration youngGen)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.35550742772912863
                    },
                    "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        public add(AlignedHeader chunks)": {
                        "first": {
                            "method_name": "add",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        public add(AlignedHeader chunks)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3917832867684799
                    },
                    "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        public add(UnalignedHeader chunks)": {
                        "first": {
                            "method_name": "add",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        public add(UnalignedHeader chunks)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3945980663740555
                    },
                    " release(boolean keepAllAlignedChunks)": {
                        "first": {
                            "method_name": "release",
                            "method_signature": " release(boolean keepAllAlignedChunks)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4651100712834571
                    },
                    "private printGCBefore(GCCause cause)": {
                        "first": {
                            "method_name": "printGCBefore",
                            "method_signature": "private printGCBefore(GCCause cause)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.49029563543128046
                    },
                    "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private promoteChunksWithPinnedObjects()": {
                        "first": {
                            "method_name": "promoteChunksWithPinnedObjects",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private promoteChunksWithPinnedObjects()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.49971227938759727
                    },
                    "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private walkThreadLocals()": {
                        "first": {
                            "method_name": "walkThreadLocals",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private walkThreadLocals()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5185244232870292
                    },
                    "private cleanRuntimeCodeCache()": {
                        "first": {
                            "method_name": "cleanRuntimeCodeCache",
                            "method_signature": "private cleanRuntimeCodeCache()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5455283264668418
                    },
                    "@Uninterruptible(reason = \"Used as a transition between uninterruptible and interruptible code\", calleeMustBe = false)\n    private enqueueCollectOperation(CollectionVMOperationData data)": {
                        "first": {
                            "method_name": "enqueueCollectOperation",
                            "method_signature": "@Uninterruptible(reason = \"Used as a transition between uninterruptible and interruptible code\", calleeMustBe = false)\n    private enqueueCollectOperation(CollectionVMOperationData data)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5485644182035575
                    },
                    "private static printGCSummary()": {
                        "first": {
                            "method_name": "printGCSummary",
                            "method_signature": "private static printGCSummary()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5514328437975694
                    },
                    "private printGCAfter(GCCause cause)": {
                        "first": {
                            "method_name": "printGCAfter",
                            "method_signature": "private printGCAfter(GCCause cause)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5515214358559772
                    },
                    "private verifyAfterGC()": {
                        "first": {
                            "method_name": "verifyAfterGC",
                            "method_signature": "private verifyAfterGC()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5692979474120737
                    },
                    "@AlwaysInline(\"GC performance\")\n    @Uninterruptible(reason = \"Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.\", mayBeInlined = true)\n    private static walkStack(JavaStackWalk walk, ObjectReferenceVisitor visitor, boolean visitRuntimeCodeInfo)": {
                        "first": {
                            "method_name": "walkStack",
                            "method_signature": "@AlwaysInline(\"GC performance\")\n    @Uninterruptible(reason = \"Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.\", mayBeInlined = true)\n    private static walkStack(JavaStackWalk walk, ObjectReferenceVisitor visitor, boolean visitRuntimeCodeInfo)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5882395084920324
                    },
                    "@AlwaysInline(\"GC performance\")\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    @SuppressWarnings(\"static-method\") promoteObject(Object original, Word header)": {
                        "first": {
                            "method_name": "promoteObject",
                            "method_signature": "@AlwaysInline(\"GC performance\")\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    @SuppressWarnings(\"static-method\") promoteObject(Object original, Word header)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5902945393649714
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "@Uninterruptible(reason = \"Avoid races with other threads that also try to trigger a GC\")\n    @RestrictHeapAccess(access = RestrictHeapAccess.Access.NO_ALLOCATION, reason = \"Must not allocate in the implementation of garbage collection.\") collectWithoutAllocating(GCCause cause, boolean forceFullGC)",
                        "@Uninterruptible(reason = \"Used as a transition between uninterruptible and interruptible code\", calleeMustBe = false)\n    private enqueueCollectOperation(CollectionVMOperationData data)",
                        "private collectOperation(CollectionVMOperationData data)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private cheneyScanFromDirtyRoots()",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private promoteChunksWithPinnedObjects()",
                        "@AlwaysInline(\"GC performance\")\n    @Uninterruptible(reason = \"Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.\", mayBeInlined = true)\n    private static walkStack(JavaStackWalk walk, ObjectReferenceVisitor visitor, boolean visitRuntimeCodeInfo)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private walkRuntimeCodeCache()",
                        "@AlwaysInline(\"GC Performance\")\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    static walkImageHeapRoots(ImageHeapInfo imageHeapInfo, ObjectVisitor visitor)",
                        "private printGCBefore(GCCause cause)",
                        "private printGCAfter(GCCause cause)",
                        "private static printGCSummary()",
                        "static doReferenceHandling()",
                        "private checkSanityAfterCollection(YoungGeneration youngGen)",
                        "public isEmpty()"
                    ],
                    "llm_response_time": 7988
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "@Uninterruptible(reason = \"Used as a transition between uninterruptible and interruptible code\", calleeMustBe = false)\n    private enqueueCollectOperation(CollectionVMOperationData data)",
                        "private collectOperation(CollectionVMOperationData data)",
                        "@AlwaysInline(\"GC Performance\")\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    static walkImageHeapRoots(ImageHeapInfo imageHeapInfo, ObjectVisitor visitor)",
                        "private checkSanityAfterCollection(YoungGeneration youngGen)",
                        "public isEmpty()"
                    ],
                    "llm_response_time": 3359
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private collectOperation(CollectionVMOperationData data)",
                        "private checkSanityAfterCollection(YoungGeneration youngGen)",
                        "public isEmpty()"
                    ],
                    "llm_response_time": 3845
                },
                "voyage": {
                    "priority_method_names": [
                        "private verifyAfterGC()",
                        "private printGCBefore(GCCause cause)",
                        "private printGCAfter(GCCause cause)",
                        "private static printGCSummary()",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private promoteChunksWithPinnedObjects()",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private walkThreadLocals()",
                        "private cleanRuntimeCodeCache()",
                        "@Uninterruptible(reason = \"Used as a transition between uninterruptible and interruptible code\", calleeMustBe = false)\n    private enqueueCollectOperation(CollectionVMOperationData data)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        public add(AlignedHeader chunks)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        public add(UnalignedHeader chunks)",
                        "public isEmpty()",
                        "private checkSanityAfterCollection(YoungGeneration youngGen)",
                        "@AlwaysInline(\"GC performance\")\n    @Uninterruptible(reason = \"Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.\", mayBeInlined = true)\n    private static walkStack(JavaStackWalk walk, ObjectReferenceVisitor visitor, boolean visitRuntimeCodeInfo)",
                        "@AlwaysInline(\"GC performance\")\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    @SuppressWarnings(\"static-method\") promoteObject(Object original, Word header)"
                    ],
                    "llm_response_time": 5249
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private checkSanityAfterCollection(YoungGeneration youngGen)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        public add(AlignedHeader chunks)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        public add(UnalignedHeader chunks)",
                        " release(boolean keepAllAlignedChunks)",
                        "public isEmpty()"
                    ],
                    "llm_response_time": 2603
                },
                "voyage-3": {
                    "priority_method_names": [
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        public add(AlignedHeader chunks)",
                        "private checkSanityAfterCollection(YoungGeneration youngGen)",
                        "public isEmpty()"
                    ],
                    "llm_response_time": 3724
                }
            },
            "targetClassMap": {
                "checkSanityAfterCollection": {
                    "target_classes": [
                        {
                            "class_name": "YoungGeneration",
                            "similarity_score": 0.2935484295219752
                        },
                        {
                            "class_name": "GreyToBlackObjRefVisitor",
                            "similarity_score": 0.27089619729513353
                        },
                        {
                            "class_name": "GCAccounting",
                            "similarity_score": 0.28228336575882235
                        },
                        {
                            "class_name": "Timers",
                            "similarity_score": 0.06564386345361468
                        },
                        {
                            "class_name": "CollectionVMOperation",
                            "similarity_score": 0.27590730612220044
                        },
                        {
                            "class_name": "ChunkReleaser",
                            "similarity_score": 0.3272099955018442
                        },
                        {
                            "class_name": "MarkQueue",
                            "similarity_score": 0.23659646083551086
                        },
                        {
                            "class_name": "CollectionPolicy",
                            "similarity_score": 0.1967233194946387
                        }
                    ],
                    "llm_response_time": 3479,
                    "similarity_computation_time": 11,
                    "similarity_metric": "cosine",
                    "target_classes_sorted_by_llm": ["YoungGeneration", "GCAccounting", "ChunkReleaser"],
                    "target_class_priority_explanation": "```json\n[\n    {\n        \"target_class\": \"YoungGeneration\",\n        \"rationale\": \"The method `checkSanityAfterCollection` specifically interacts with the `YoungGeneration` class by checking the state of the `Eden` space after a collection. It directly asserts the condition on `YoungGeneration` instances, making it highly cohesive with the `YoungGeneration` class's responsibilities. Moving this method here provides better encapsulation and adheres to the principle of proximity for methods interacting with class internals.\",\n    },\n    {\n        \"target_class\": \"GCAccounting\",\n        \"rationale\": \"The `GCAccounting` class deals with various pre- and post-collection state information and metrics. While monitoring and accounting, it could make sense to verify the sanity of the `YoungGeneration` if collection sanity validation is considered part of the accounting process. However, since `GCAccounting` is more about metrics and data storage, this move is secondary to the more logical coherence with `YoungGeneration`.\"\n    },\n    {\n        \"target_class\": \"ChunkReleaser\",\n        \"rationale\": \"The method `checkSanityAfterCollection` does not relate to the spaces or functionality managed by `ChunkReleaser`, which is primarily focused on managing and releasing chunks. Moving the method here would break the separation of concerns and reduce the clarity and maintainability of the code.\"\n    }\n]\n```"
                },
                "isEmpty": {
                    "target_classes": [
                        {
                            "class_name": "AlignedHeader",
                            "similarity_score": 0.1421338109037403
                        },
                        {
                            "class_name": "UnalignedHeader",
                            "similarity_score": 0.11952286093343938
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "AlignedHeader",
                        "UnalignedHeader"
                    ],
                    "llm_response_time": 2702,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "collectOperation": {
                    "target_classes": [
                        {
                            "class_name": "CollectionVMOperationData",
                            "similarity_score": 0.08382549209085562
                        },
                        {
                            "class_name": "CollectionVMOperation",
                            "similarity_score": 0.40423702001490924
                        },
                        {
                            "class_name": "ChunkReleaser",
                            "similarity_score": 0.3519816730955842
                        },
                        {
                            "class_name": "CollectionPolicy",
                            "similarity_score": 0.3625542720025175
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CollectionVMOperation",
                        "CollectionPolicy",
                        "ChunkReleaser"
                    ],
                    "llm_response_time": 3006,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "walkImageHeapRoots": {
                    "target_classes": [
                        {
                            "class_name": "JfrGCEvents",
                            "similarity_score": 0.46205434014623054
                        },
                        {
                            "class_name": "JfrGCHeapSummaryEvent",
                            "similarity_score": 0.21496734054567473
                        },
                        {
                            "class_name": "HeapChunkLogging",
                            "similarity_score": 0.3508922252014823
                        },
                        {
                            "class_name": "HeapParameters",
                            "similarity_score": 0.4459615442097818
                        },
                        {
                            "class_name": "ThreadLocalAllocation",
                            "similarity_score": 0.40507649686731045
                        },
                        {
                            "class_name": "HeapChunk",
                            "similarity_score": 0.5032508696662853
                        },
                        {
                            "class_name": "AlignedHeapChunk",
                            "similarity_score": 0.40456679349284175
                        },
                        {
                            "class_name": "UnalignedHeapChunk",
                            "similarity_score": 0.3445543529803188
                        },
                        {
                            "class_name": "ReferenceObjectProcessing",
                            "similarity_score": 0.36953803060215407
                        },
                        {
                            "class_name": "ImageHeapWalker",
                            "similarity_score": 0.5600506661871776
                        },
                        {
                            "class_name": "HeapVerifier",
                            "similarity_score": 0.3190578289772008
                        },
                        {
                            "class_name": "SerialGCOptions",
                            "similarity_score": 0.3076775386269435
                        },
                        {
                            "class_name": "ObjectHeaderImpl",
                            "similarity_score": 0.5605903758291323
                        },
                        {
                            "class_name": "BasicCollectionPolicies",
                            "similarity_score": 0.3037019155032391
                        },
                        {
                            "class_name": "StackVerifier",
                            "similarity_score": 0.32007177500619854
                        },
                        {
                            "class_name": "SerialAndEpsilonGCOptions",
                            "similarity_score": 0.2685352330500135
                        },
                        {
                            "class_name": "TestingBackDoor",
                            "similarity_score": 0.3207189124694415
                        },
                        {
                            "class_name": "HeapChunkProvider",
                            "similarity_score": 0.471560300353392
                        },
                        {
                            "class_name": "Timers",
                            "similarity_score": 0.19292704235657732
                        },
                        {
                            "class_name": "HeapAccounting",
                            "similarity_score": 0.38270420275807127
                        },
                        {
                            "class_name": "PathExhibitor",
                            "similarity_score": 0.3561533541989048
                        },
                        {
                            "class_name": "AdaptiveWeightedAverage",
                            "similarity_score": 0.20972949143565248
                        },
                        {
                            "class_name": "RuntimeCodeCacheFixupWalker",
                            "similarity_score": 0.22487988455975447
                        },
                        {
                            "class_name": "RuntimeCodeCacheReachabilityAnalyzer",
                            "similarity_score": 0.383299241486987
                        },
                        {
                            "class_name": "AdaptiveCollectionPolicy",
                            "similarity_score": 0.34013354730915946
                        },
                        {
                            "class_name": "PinnedObjectImpl",
                            "similarity_score": 0.5345740443188314
                        },
                        {
                            "class_name": "HeapImpl",
                            "similarity_score": 0.401915566427515
                        },
                        {
                            "class_name": "BySpaceAndTime",
                            "similarity_score": 0.2765204519281134
                        },
                        {
                            "class_name": "RuntimeCodeCacheWalker",
                            "similarity_score": 0.1120278984204926
                        },
                        {
                            "class_name": "GenScavengeMemoryPoolMXBeans",
                            "similarity_score": 0.29534533628517845
                        },
                        {
                            "class_name": "MarkQueue",
                            "similarity_score": 0.4627122136743488
                        },
                        {
                            "class_name": "ChunkReleaser",
                            "similarity_score": 0.5054103905872802
                        },
                        {
                            "class_name": "ChunkedImageHeapLayouter",
                            "similarity_score": 0.3450170116838509
                        },
                        {
                            "class_name": "ImageHeapInfo",
                            "similarity_score": 0.4757711809136186
                        },
                        {
                            "class_name": "JfrGCEventSupport",
                            "similarity_score": 0.4944706355233347
                        },
                        {
                            "class_name": "EdenMemoryPoolMXBean",
                            "similarity_score": 0.23488139421661183
                        },
                        {
                            "class_name": "HostedImageHeapChunkWriter",
                            "similarity_score": 0.2674700731087642
                        },
                        {
                            "class_name": "SizeParameters",
                            "similarity_score": 0.40340390866863024
                        },
                        {
                            "class_name": "ChunkedImageHeapAllocator",
                            "similarity_score": 0.31607593787164506
                        },
                        {
                            "class_name": "ChunkedImageHeapPartition",
                            "similarity_score": 0.3430215403991047
                        },
                        {
                            "class_name": "OldGeneration",
                            "similarity_score": 0.4981718224470957
                        },
                        {
                            "class_name": "YoungGeneration",
                            "similarity_score": 0.5196967071029723
                        },
                        {
                            "class_name": "Space",
                            "similarity_score": 0.5700529663454766
                        },
                        {
                            "class_name": "JfrGCEventFeature",
                            "similarity_score": 0.2469572902868155
                        },
                        {
                            "class_name": "GCAccounting",
                            "similarity_score": 0.38485597229224516
                        },
                        {
                            "class_name": "CyclicElement",
                            "similarity_score": 0.20059771011560645
                        },
                        {
                            "class_name": "GenScavengeGCCause",
                            "similarity_score": 0.2125118592516207
                        },
                        {
                            "class_name": "ChunksAccounting",
                            "similarity_score": 0.6022957294233305
                        },
                        {
                            "class_name": "CompleteGarbageCollectorMXBean",
                            "similarity_score": 0.19302749903735322
                        },
                        {
                            "class_name": "AbstractVisitor",
                            "similarity_score": 0.30802055181684873
                        },
                        {
                            "class_name": "AlignedChunk",
                            "similarity_score": 0.271853289083507
                        },
                        {
                            "class_name": "GreyObjectsWalker",
                            "similarity_score": 0.45183993414026064
                        },
                        {
                            "class_name": "GreyToBlackObjectVisitor",
                            "similarity_score": 0.3374990296916845
                        },
                        {
                            "class_name": "GreyToBlackObjRefVisitor",
                            "similarity_score": 0.5822704633034078
                        },
                        {
                            "class_name": "AdaptivePaddedAverage",
                            "similarity_score": 0.23447593081558993
                        },
                        {
                            "class_name": "BootImageHeapElement",
                            "similarity_score": 0.21641148468807855
                        },
                        {
                            "class_name": "IncrementalGarbageCollectorMXBean",
                            "similarity_score": 0.19314360581419038
                        },
                        {
                            "class_name": "FillerObjectDummyPartition",
                            "similarity_score": 0.062295019186722866
                        },
                        {
                            "class_name": "HeaderPaddingSizeProvider",
                            "similarity_score": 0.15875015875023812
                        },
                        {
                            "class_name": "EpsilonGarbageCollectorMXBean",
                            "similarity_score": 0.18155877062495188
                        },
                        {
                            "class_name": "EpsilonMemoryPoolMXBean",
                            "similarity_score": 0.24096579867074966
                        },
                        {
                            "class_name": "HeapElement",
                            "similarity_score": 0.27389551783238836
                        },
                        {
                            "class_name": "HeapImplMemoryMXBean",
                            "similarity_score": 0.24886840673530206
                        },
                        {
                            "class_name": "HeapSizes",
                            "similarity_score": 0.16800537625806178
                        },
                        {
                            "class_name": "FrameVisitor",
                            "similarity_score": 0.31414615634304144
                        },
                        {
                            "class_name": "LeafElement",
                            "similarity_score": 0.19372923726099542
                        },
                        {
                            "class_name": "LibGraalCollectionPolicy",
                            "similarity_score": 0.21587862911669742
                        },
                        {
                            "class_name": "Target_java_lang_Runtime",
                            "similarity_score": 0.26923973076148083
                        },
                        {
                            "class_name": "RuntimeCodeInfoGCSupportImpl",
                            "similarity_score": 0.41966636671137164
                        },
                        {
                            "class_name": "RuntimeImageHeapChunkWriter",
                            "similarity_score": 0.2772521948662049
                        },
                        {
                            "class_name": "UnalignedChunk",
                            "similarity_score": 0.19172686248267184
                        },
                        {
                            "class_name": "SurvivorMemoryPoolMXBean",
                            "similarity_score": 0.22501363524213547
                        },
                        {
                            "class_name": "UseSerialOrEpsilonGC",
                            "similarity_score": 0.1466471150213533
                        },
                        {
                            "class_name": "NeverCollect",
                            "similarity_score": 0.16245910832216473
                        },
                        {
                            "class_name": "WritableHugeMemoryWalkerAccess",
                            "similarity_score": 0.19748051956851723
                        },
                        {
                            "class_name": "WritableRegularMemoryWalkerAccess",
                            "similarity_score": 0.19897095972842185
                        },
                        {
                            "class_name": "Timer",
                            "similarity_score": 0.5005044489374806
                        },
                        {
                            "class_name": "PathEdge",
                            "similarity_score": 0.31188214354787913
                        },
                        {
                            "class_name": "RangeTargetMatcher",
                            "similarity_score": 0.267827834114857
                        },
                        {
                            "class_name": "PinnedObjectSupportImpl",
                            "similarity_score": 0.31876778887743107
                        },
                        {
                            "class_name": "ObjectTargetMatcher",
                            "similarity_score": 0.24650596604914954
                        },
                        {
                            "class_name": "NoopCounters",
                            "similarity_score": 0.5659843436180414
                        },
                        {
                            "class_name": "OldGenerationMemoryPoolMXBean",
                            "similarity_score": 0.22501363524213547
                        },
                        {
                            "class_name": "OnlyCompletely",
                            "similarity_score": 0.18919089532549124
                        },
                        {
                            "class_name": "OnlyIncrementally",
                            "similarity_score": 0.1796053020267749
                        },
                        {
                            "class_name": "RealCounters",
                            "similarity_score": 0.5218347350173809
                        },
                        {
                            "class_name": "ReadOnlyRegularMemoryWalkerAccess",
                            "similarity_score": 0.19897095972842185
                        },
                        {
                            "class_name": "ReadOnlyRelocatableMemoryWalkerAccess",
                            "similarity_score": 0.19748051956851723
                        },
                        {
                            "class_name": "ReciprocalLeastSquareFit",
                            "similarity_score": 0.17145459957044465
                        },
                        {
                            "class_name": "ReadOnlyHugeMemoryWalkerAccess",
                            "similarity_score": 0.19748051956851723
                        },
                        {
                            "class_name": "ProportionateSpacesPolicy",
                            "similarity_score": 0.38226616648421546
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Space",
                        "ChunksAccounting",
                        "GreyToBlackObjRefVisitor"
                    ],
                    "llm_response_time": 3342,
                    "similarity_computation_time": 18,
                    "similarity_metric": "cosine"
                },
                "enqueueCollectOperation": {
                    "target_classes": [
                        {
                            "class_name": "CollectionVMOperationData",
                            "similarity_score": 0.1196495412667539
                        },
                        {
                            "class_name": "CollectionVMOperation",
                            "similarity_score": 0.37116548561378443
                        },
                        {
                            "class_name": "ChunkReleaser",
                            "similarity_score": 0.4912416034969328
                        },
                        {
                            "class_name": "CollectionPolicy",
                            "similarity_score": 0.2117143106879345
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CollectionVMOperation",
                        "CollectionPolicy",
                        "ChunkReleaser"
                    ],
                    "llm_response_time": 3149,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "printGCBefore": {
                    "target_classes": [
                        {
                            "class_name": "CollectionVMOperation",
                            "similarity_score": 0.4024737354552536
                        },
                        {
                            "class_name": "ChunkReleaser",
                            "similarity_score": 0.465627986531675
                        },
                        {
                            "class_name": "CollectionPolicy",
                            "similarity_score": 0.14548966932007915
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CollectionVMOperation",
                        "CollectionPolicy",
                        "ChunkReleaser"
                    ],
                    "llm_response_time": 4183,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "doReferenceHandling": {
                    "target_classes": [
                        {
                            "class_name": "JfrGCEvents",
                            "similarity_score": 0.34948162266441524
                        },
                        {
                            "class_name": "JfrGCHeapSummaryEvent",
                            "similarity_score": 0.22731030232915872
                        },
                        {
                            "class_name": "HeapChunkLogging",
                            "similarity_score": 0.29632865624947563
                        },
                        {
                            "class_name": "HeapParameters",
                            "similarity_score": 0.3709465632132386
                        },
                        {
                            "class_name": "ThreadLocalAllocation",
                            "similarity_score": 0.5248416413515461
                        },
                        {
                            "class_name": "HeapChunk",
                            "similarity_score": 0.5084983817913309
                        },
                        {
                            "class_name": "AlignedHeapChunk",
                            "similarity_score": 0.4674875297945526
                        },
                        {
                            "class_name": "UnalignedHeapChunk",
                            "similarity_score": 0.48298414907226256
                        },
                        {
                            "class_name": "ReferenceObjectProcessing",
                            "similarity_score": 0.5668395666026481
                        },
                        {
                            "class_name": "ImageHeapWalker",
                            "similarity_score": 0.3389139704549816
                        },
                        {
                            "class_name": "HeapVerifier",
                            "similarity_score": 0.4818351890093134
                        },
                        {
                            "class_name": "SerialGCOptions",
                            "similarity_score": 0.2824815767203062
                        },
                        {
                            "class_name": "ObjectHeaderImpl",
                            "similarity_score": 0.4378210193760866
                        },
                        {
                            "class_name": "BasicCollectionPolicies",
                            "similarity_score": 0.41895867288193556
                        },
                        {
                            "class_name": "SerialAndEpsilonGCOptions",
                            "similarity_score": 0.3207102088975829
                        },
                        {
                            "class_name": "TestingBackDoor",
                            "similarity_score": 0.2577417653583969
                        },
                        {
                            "class_name": "StackVerifier",
                            "similarity_score": 0.33791870574008137
                        },
                        {
                            "class_name": "HeapChunkProvider",
                            "similarity_score": 0.5256783074295969
                        },
                        {
                            "class_name": "Timers",
                            "similarity_score": 0.17227046470723398
                        },
                        {
                            "class_name": "HeapAccounting",
                            "similarity_score": 0.40541403260882275
                        },
                        {
                            "class_name": "PathExhibitor",
                            "similarity_score": 0.3765043257064479
                        },
                        {
                            "class_name": "AdaptiveWeightedAverage",
                            "similarity_score": 0.5020533967305911
                        },
                        {
                            "class_name": "RuntimeCodeCacheFixupWalker",
                            "similarity_score": 0.46054941537491406
                        },
                        {
                            "class_name": "RuntimeCodeCacheReachabilityAnalyzer",
                            "similarity_score": 0.32318286529871076
                        },
                        {
                            "class_name": "AdaptiveCollectionPolicy",
                            "similarity_score": 0.5147500908472944
                        },
                        {
                            "class_name": "PinnedObjectImpl",
                            "similarity_score": 0.36823181352159856
                        },
                        {
                            "class_name": "BySpaceAndTime",
                            "similarity_score": 0.4270833333333333
                        },
                        {
                            "class_name": "RuntimeCodeCacheWalker",
                            "similarity_score": 0.4965707663188729
                        },
                        {
                            "class_name": "MarkQueue",
                            "similarity_score": 0.30545060953866515
                        },
                        {
                            "class_name": "GenScavengeMemoryPoolMXBeans",
                            "similarity_score": 0.2962282762277696
                        },
                        {
                            "class_name": "ChunkReleaser",
                            "similarity_score": 0.3494923411213731
                        },
                        {
                            "class_name": "ChunkedImageHeapLayouter",
                            "similarity_score": 0.45247518859744823
                        },
                        {
                            "class_name": "ImageHeapInfo",
                            "similarity_score": 0.305878074058409
                        },
                        {
                            "class_name": "JfrGCEventSupport",
                            "similarity_score": 0.3610764826861255
                        },
                        {
                            "class_name": "EdenMemoryPoolMXBean",
                            "similarity_score": 0.26597931143364983
                        },
                        {
                            "class_name": "HostedImageHeapChunkWriter",
                            "similarity_score": 0.2545448658629778
                        },
                        {
                            "class_name": "SizeParameters",
                            "similarity_score": 0.2197637756112129
                        },
                        {
                            "class_name": "ChunkedImageHeapAllocator",
                            "similarity_score": 0.3905411384696423
                        },
                        {
                            "class_name": "ChunkedImageHeapPartition",
                            "similarity_score": 0.4564452995687827
                        },
                        {
                            "class_name": "OldGeneration",
                            "similarity_score": 0.4580802513704862
                        },
                        {
                            "class_name": "YoungGeneration",
                            "similarity_score": 0.3586323460599546
                        },
                        {
                            "class_name": "Space",
                            "similarity_score": 0.4271133845004796
                        },
                        {
                            "class_name": "JfrGCEventFeature",
                            "similarity_score": 0.2706329386826371
                        },
                        {
                            "class_name": "LeafElement",
                            "similarity_score": 0.332606378779975
                        },
                        {
                            "class_name": "LibGraalCollectionPolicy",
                            "similarity_score": 0.5388338627199272
                        },
                        {
                            "class_name": "ChunksAccounting",
                            "similarity_score": 0.32606641108136836
                        },
                        {
                            "class_name": "NoopCounters",
                            "similarity_score": 0.2410685277835315
                        },
                        {
                            "class_name": "NeverCollect",
                            "similarity_score": 0.26836971959836753
                        },
                        {
                            "class_name": "PathEdge",
                            "similarity_score": 0.255115923876548
                        },
                        {
                            "class_name": "DumpChunkInformation",
                            "similarity_score": 0.21664456120656048
                        },
                        {
                            "class_name": "DumpHeapSettingsAndStatistics",
                            "similarity_score": 0.25221663615265916
                        },
                        {
                            "class_name": "DumpHeapUsage",
                            "similarity_score": 0.2275455136545516
                        },
                        {
                            "class_name": "ProportionateSpacesPolicy",
                            "similarity_score": 0.5073511532797889
                        },
                        {
                            "class_name": "ClassListBuilderVisitor",
                            "similarity_score": 0.29234229107591525
                        },
                        {
                            "class_name": "AbstractVisitor",
                            "similarity_score": 0.22278319716975173
                        },
                        {
                            "class_name": "PinnedObjectSupportImpl",
                            "similarity_score": 0.2805712709727033
                        },
                        {
                            "class_name": "ObjectTargetMatcher",
                            "similarity_score": 0.2311183629104763
                        },
                        {
                            "class_name": "OldGenerationMemoryPoolMXBean",
                            "similarity_score": 0.26172677699674035
                        },
                        {
                            "class_name": "RangeTargetMatcher",
                            "similarity_score": 0.21523650802306962
                        },
                        {
                            "class_name": "OnlyCompletely",
                            "similarity_score": 0.24495479966981368
                        },
                        {
                            "class_name": "AdaptivePaddedAverage",
                            "similarity_score": 0.46098950363730423
                        },
                        {
                            "class_name": "OnlyIncrementally",
                            "similarity_score": 0.1958866984750516
                        },
                        {
                            "class_name": "ReadOnlyHugeMemoryWalkerAccess",
                            "similarity_score": 0.21160368475757949
                        },
                        {
                            "class_name": "ReadOnlyRegularMemoryWalkerAccess",
                            "similarity_score": 0.21320071635561044
                        },
                        {
                            "class_name": "ReadOnlyRelocatableMemoryWalkerAccess",
                            "similarity_score": 0.21160368475757949
                        },
                        {
                            "class_name": "AlignedChunk",
                            "similarity_score": 0.4213379214881678
                        },
                        {
                            "class_name": "RealCounters",
                            "similarity_score": 0.2458352384220393
                        },
                        {
                            "class_name": "ReciprocalLeastSquareFit",
                            "similarity_score": 0.3444683915881794
                        },
                        {
                            "class_name": "EpsilonGarbageCollectorMXBean",
                            "similarity_score": 0.271689730836558
                        },
                        {
                            "class_name": "EpsilonMemoryPoolMXBean",
                            "similarity_score": 0.24436680636784894
                        },
                        {
                            "class_name": "RuntimeCodeInfoGCSupportImpl",
                            "similarity_score": 0.25294474229370423
                        },
                        {
                            "class_name": "RuntimeImageHeapChunkWriter",
                            "similarity_score": 0.286952631187775
                        },
                        {
                            "class_name": "BootImageHeapElement",
                            "similarity_score": 0.29193109706247256
                        },
                        {
                            "class_name": "CompleteGarbageCollectorMXBean",
                            "similarity_score": 0.28022426915890253
                        },
                        {
                            "class_name": "IncrementalGarbageCollectorMXBean",
                            "similarity_score": 0.2803928251255179
                        },
                        {
                            "class_name": "GCAccounting",
                            "similarity_score": 0.41762696659706233
                        },
                        {
                            "class_name": "Target_java_lang_Runtime",
                            "similarity_score": 0.3245567418059366
                        },
                        {
                            "class_name": "GenScavengeGCCause",
                            "similarity_score": 0.18298126367784998
                        },
                        {
                            "class_name": "HeaderPaddingSizeProvider",
                            "similarity_score": 0.24239742246291865
                        },
                        {
                            "class_name": "HeapElement",
                            "similarity_score": 0.2861465445558278
                        },
                        {
                            "class_name": "HeapImplMemoryMXBean",
                            "similarity_score": 0.3333333333333333
                        },
                        {
                            "class_name": "HeapSizes",
                            "similarity_score": 0.18323522807998416
                        },
                        {
                            "class_name": "GreyObjectsWalker",
                            "similarity_score": 0.5012017364113094
                        },
                        {
                            "class_name": "GreyToBlackObjectVisitor",
                            "similarity_score": 0.3091986635794567
                        },
                        {
                            "class_name": "GreyToBlackObjRefVisitor",
                            "similarity_score": 0.3598517386822272
                        },
                        {
                            "class_name": "FillerObjectDummyPartition",
                            "similarity_score": 0.4036298530469181
                        },
                        {
                            "class_name": "FrameVisitor",
                            "similarity_score": 0.24581597659688942
                        },
                        {
                            "class_name": "UnalignedChunk",
                            "similarity_score": 0.2531296355686169
                        },
                        {
                            "class_name": "WritableHugeMemoryWalkerAccess",
                            "similarity_score": 0.21160368475757949
                        },
                        {
                            "class_name": "WritableRegularMemoryWalkerAccess",
                            "similarity_score": 0.21320071635561044
                        },
                        {
                            "class_name": "Timer",
                            "similarity_score": 0.38546483516373187
                        },
                        {
                            "class_name": "UseSerialOrEpsilonGC",
                            "similarity_score": 0.1767766952966369
                        },
                        {
                            "class_name": "CyclicElement",
                            "similarity_score": 0.2931051908802746
                        },
                        {
                            "class_name": "SurvivorMemoryPoolMXBean",
                            "similarity_score": 0.26172677699674035
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReferenceObjectProcessing",
                        "LibGraalCollectionPolicy",
                        "HeapChunkProvider"
                    ],
                    "llm_response_time": 4316,
                    "similarity_computation_time": 19,
                    "similarity_metric": "cosine"
                },
                "blackenStackRoots": {
                    "target_classes": [
                        {
                            "class_name": "CollectionVMOperation",
                            "similarity_score": 0.5428028992389718
                        },
                        {
                            "class_name": "ChunkReleaser",
                            "similarity_score": 0.370672675806411
                        },
                        {
                            "class_name": "CollectionPolicy",
                            "similarity_score": 0.3617020949115366
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CollectionVMOperation",
                        "ChunkReleaser",
                        "CollectionPolicy"
                    ],
                    "llm_response_time": 4016,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "collectWithoutAllocating": {
                    "target_classes": [
                        {
                            "class_name": "CollectionVMOperation",
                            "similarity_score": 0.44683260731588265
                        },
                        {
                            "class_name": "ChunkReleaser",
                            "similarity_score": 0.5321565353901596
                        },
                        {
                            "class_name": "CollectionPolicy",
                            "similarity_score": 0.29391412118413657
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CollectionVMOperation",
                        "CollectionPolicy",
                        "ChunkReleaser"
                    ],
                    "llm_response_time": 4048,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "cheneyScanFromDirtyRoots": {
                    "target_classes": [
                        {
                            "class_name": "CollectionVMOperation",
                            "similarity_score": 0.6472049716935919
                        },
                        {
                            "class_name": "ChunkReleaser",
                            "similarity_score": 0.34416277236362797
                        },
                        {
                            "class_name": "CollectionPolicy",
                            "similarity_score": 0.6424738090432185
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CollectionVMOperation",
                        "CollectionPolicy",
                        "ChunkReleaser"
                    ],
                    "llm_response_time": 3561,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "promoteChunksWithPinnedObjects": {
                    "target_classes": [
                        {
                            "class_name": "CollectionVMOperation",
                            "similarity_score": 0.5341403704404398
                        },
                        {
                            "class_name": "ChunkReleaser",
                            "similarity_score": 0.5229482513313817
                        },
                        {
                            "class_name": "CollectionPolicy",
                            "similarity_score": 0.37587727319031555
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ChunkReleaser",
                        "CollectionPolicy",
                        "CollectionVMOperation"
                    ],
                    "llm_response_time": 3349,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "walkRuntimeCodeCache": {
                    "target_classes": [
                        {
                            "class_name": "CollectionVMOperation",
                            "similarity_score": 0.6293417004449051
                        },
                        {
                            "class_name": "ChunkReleaser",
                            "similarity_score": 0.48009774388460047
                        },
                        {
                            "class_name": "CollectionPolicy",
                            "similarity_score": 0.556417572928747
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CollectionVMOperation",
                        "CollectionPolicy",
                        "ChunkReleaser"
                    ],
                    "llm_response_time": 3806,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "printGCSummary": {
                    "target_classes": [
                        {
                            "class_name": "CollectionVMOperation",
                            "similarity_score": 0.5049695697773386
                        },
                        {
                            "class_name": "ChunkReleaser",
                            "similarity_score": 0.6140664439898527
                        },
                        {
                            "class_name": "PrintGCSummaryOperation",
                            "similarity_score": 0.28931878117892235
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PrintGCSummaryOperation",
                        "CollectionVMOperation",
                        "ChunkReleaser"
                    ],
                    "llm_response_time": 3184,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "printGCAfter": {
                    "target_classes": [
                        {
                            "class_name": "CollectionVMOperation",
                            "similarity_score": 0.48774493131471375
                        },
                        {
                            "class_name": "ChunkReleaser",
                            "similarity_score": 0.6241995083007014
                        },
                        {
                            "class_name": "CollectionPolicy",
                            "similarity_score": 0.19259117112931598
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CollectionPolicy",
                        "CollectionVMOperation",
                        "ChunkReleaser"
                    ],
                    "llm_response_time": 4214,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "walkStack": {
                    "target_classes": [
                        {
                            "class_name": "JfrGCEvents",
                            "similarity_score": 0.42441971876723333
                        },
                        {
                            "class_name": "JfrGCHeapSummaryEvent",
                            "similarity_score": 0.26500957302945816
                        },
                        {
                            "class_name": "HeapChunkLogging",
                            "similarity_score": 0.43047301604613925
                        },
                        {
                            "class_name": "HeapParameters",
                            "similarity_score": 0.4564635097249545
                        },
                        {
                            "class_name": "ThreadLocalAllocation",
                            "similarity_score": 0.6951810497982357
                        },
                        {
                            "class_name": "HeapChunk",
                            "similarity_score": 0.6527746723132475
                        },
                        {
                            "class_name": "AlignedHeapChunk",
                            "similarity_score": 0.6397725657355333
                        },
                        {
                            "class_name": "UnalignedHeapChunk",
                            "similarity_score": 0.6443472343022756
                        },
                        {
                            "class_name": "ReferenceObjectProcessing",
                            "similarity_score": 0.7150764266190252
                        },
                        {
                            "class_name": "ImageHeapWalker",
                            "similarity_score": 0.5110684630067731
                        },
                        {
                            "class_name": "HeapVerifier",
                            "similarity_score": 0.6050503676196821
                        },
                        {
                            "class_name": "SerialGCOptions",
                            "similarity_score": 0.3952988203822608
                        },
                        {
                            "class_name": "ObjectHeaderImpl",
                            "similarity_score": 0.5986114945067915
                        },
                        {
                            "class_name": "BasicCollectionPolicies",
                            "similarity_score": 0.51386138244485
                        },
                        {
                            "class_name": "SerialAndEpsilonGCOptions",
                            "similarity_score": 0.4188972351211543
                        },
                        {
                            "class_name": "TestingBackDoor",
                            "similarity_score": 0.34103312428640037
                        },
                        {
                            "class_name": "StackVerifier",
                            "similarity_score": 0.4651010884766212
                        },
                        {
                            "class_name": "HeapChunkProvider",
                            "similarity_score": 0.6961886678441942
                        },
                        {
                            "class_name": "Timers",
                            "similarity_score": 0.2609292127247129
                        },
                        {
                            "class_name": "HeapAccounting",
                            "similarity_score": 0.5403832973955881
                        },
                        {
                            "class_name": "PathExhibitor",
                            "similarity_score": 0.511049111429637
                        },
                        {
                            "class_name": "AdaptiveWeightedAverage",
                            "similarity_score": 0.5774367114309802
                        },
                        {
                            "class_name": "RuntimeCodeCacheFixupWalker",
                            "similarity_score": 0.6448411678746465
                        },
                        {
                            "class_name": "RuntimeCodeCacheReachabilityAnalyzer",
                            "similarity_score": 0.4608444236254898
                        },
                        {
                            "class_name": "AdaptiveCollectionPolicy",
                            "similarity_score": 0.6574281252931187
                        },
                        {
                            "class_name": "PinnedObjectImpl",
                            "similarity_score": 0.5265563912500331
                        },
                        {
                            "class_name": "HeapImpl",
                            "similarity_score": 0.6507297800671369
                        },
                        {
                            "class_name": "RuntimeCodeCacheWalker",
                            "similarity_score": 0.6721389444702159
                        },
                        {
                            "class_name": "BySpaceAndTime",
                            "similarity_score": 0.5275786942594856
                        },
                        {
                            "class_name": "GenScavengeMemoryPoolMXBeans",
                            "similarity_score": 0.37582820598039257
                        },
                        {
                            "class_name": "CollectionVMOperation",
                            "similarity_score": 0.6506379187753781
                        },
                        {
                            "class_name": "MarkQueue",
                            "similarity_score": 0.488603419120078
                        },
                        {
                            "class_name": "ChunkReleaser",
                            "similarity_score": 0.4885583725941329
                        },
                        {
                            "class_name": "ChunkedImageHeapLayouter",
                            "similarity_score": 0.5669045745719735
                        },
                        {
                            "class_name": "ImageHeapInfo",
                            "similarity_score": 0.4853841847553686
                        },
                        {
                            "class_name": "JfrGCEventSupport",
                            "similarity_score": 0.48197436305984226
                        },
                        {
                            "class_name": "EdenMemoryPoolMXBean",
                            "similarity_score": 0.3279659576704905
                        },
                        {
                            "class_name": "HostedImageHeapChunkWriter",
                            "similarity_score": 0.31081522547283036
                        },
                        {
                            "class_name": "SizeParameters",
                            "similarity_score": 0.32916365871289754
                        },
                        {
                            "class_name": "ChunkedImageHeapAllocator",
                            "similarity_score": 0.4816793438348865
                        },
                        {
                            "class_name": "ChunkedImageHeapPartition",
                            "similarity_score": 0.5812626851400154
                        },
                        {
                            "class_name": "OldGeneration",
                            "similarity_score": 0.6560223611778628
                        },
                        {
                            "class_name": "YoungGeneration",
                            "similarity_score": 0.5256396755233398
                        },
                        {
                            "class_name": "Space",
                            "similarity_score": 0.6109390851569908
                        },
                        {
                            "class_name": "JfrGCEventFeature",
                            "similarity_score": 0.3448275862068966
                        },
                        {
                            "class_name": "GCAccounting",
                            "similarity_score": 0.5911137565106374
                        },
                        {
                            "class_name": "LeafElement",
                            "similarity_score": 0.4125201463251457
                        },
                        {
                            "class_name": "LibGraalCollectionPolicy",
                            "similarity_score": 0.6743661380549263
                        },
                        {
                            "class_name": "FillerObjectDummyPartition",
                            "similarity_score": 0.46794038010525785
                        },
                        {
                            "class_name": "GenScavengeGCCause",
                            "similarity_score": 0.2564606014348602
                        },
                        {
                            "class_name": "ChunksAccounting",
                            "similarity_score": 0.48054673642959844
                        },
                        {
                            "class_name": "AbstractVisitor",
                            "similarity_score": 0.3075147043934641
                        },
                        {
                            "class_name": "GreyObjectsWalker",
                            "similarity_score": 0.660396572106213
                        },
                        {
                            "class_name": "GreyToBlackObjectVisitor",
                            "similarity_score": 0.5080090396157051
                        },
                        {
                            "class_name": "GreyToBlackObjRefVisitor",
                            "similarity_score": 0.502756609502042
                        },
                        {
                            "class_name": "CyclicElement",
                            "similarity_score": 0.36412414197895304
                        },
                        {
                            "class_name": "AdaptivePaddedAverage",
                            "similarity_score": 0.577188320962539
                        },
                        {
                            "class_name": "BootImageHeapElement",
                            "similarity_score": 0.362072006312111
                        },
                        {
                            "class_name": "HeaderPaddingSizeProvider",
                            "similarity_score": 0.274308665115471
                        },
                        {
                            "class_name": "NeverCollect",
                            "similarity_score": 0.3292365256883626
                        },
                        {
                            "class_name": "HeapElement",
                            "similarity_score": 0.3917635686130706
                        },
                        {
                            "class_name": "HeapImplMemoryMXBean",
                            "similarity_score": 0.4180812294131772
                        },
                        {
                            "class_name": "AlignedChunk",
                            "similarity_score": 0.5112844661091438
                        },
                        {
                            "class_name": "HeapSizes",
                            "similarity_score": 0.22578966989153096
                        },
                        {
                            "class_name": "RuntimeCodeInfoGCSupportImpl",
                            "similarity_score": 0.32732591305065833
                        },
                        {
                            "class_name": "RuntimeImageHeapChunkWriter",
                            "similarity_score": 0.3451895783487843
                        },
                        {
                            "class_name": "EpsilonGarbageCollectorMXBean",
                            "similarity_score": 0.3245382191059525
                        },
                        {
                            "class_name": "EpsilonMemoryPoolMXBean",
                            "similarity_score": 0.31723525986203915
                        },
                        {
                            "class_name": "CompleteGarbageCollectorMXBean",
                            "similarity_score": 0.33473287703246585
                        },
                        {
                            "class_name": "NoopCounters",
                            "similarity_score": 0.3564192159750818
                        },
                        {
                            "class_name": "Target_java_lang_Runtime",
                            "similarity_score": 0.37993502855997113
                        },
                        {
                            "class_name": "FrameVisitor",
                            "similarity_score": 0.3936250090323865
                        },
                        {
                            "class_name": "ObjectTargetMatcher",
                            "similarity_score": 0.3418071404006656
                        },
                        {
                            "class_name": "OldGenerationMemoryPoolMXBean",
                            "similarity_score": 0.3228690593869026
                        },
                        {
                            "class_name": "OnlyCompletely",
                            "similarity_score": 0.29462081880405283
                        },
                        {
                            "class_name": "OnlyIncrementally",
                            "similarity_score": 0.24630541871921183
                        },
                        {
                            "class_name": "RangeTargetMatcher",
                            "similarity_score": 0.3362127134309957
                        },
                        {
                            "class_name": "PrintGCSummaryOperation",
                            "similarity_score": 0.3017395316270181
                        },
                        {
                            "class_name": "IncrementalGarbageCollectorMXBean",
                            "similarity_score": 0.3349342201346015
                        },
                        {
                            "class_name": "ReadOnlyHugeMemoryWalkerAccess",
                            "similarity_score": 0.28646628331823293
                        },
                        {
                            "class_name": "ReadOnlyRegularMemoryWalkerAccess",
                            "similarity_score": 0.2886283236756767
                        },
                        {
                            "class_name": "ReadOnlyRelocatableMemoryWalkerAccess",
                            "similarity_score": 0.28646628331823293
                        },
                        {
                            "class_name": "ProportionateSpacesPolicy",
                            "similarity_score": 0.6565247811425077
                        },
                        {
                            "class_name": "RealCounters",
                            "similarity_score": 0.35756762073111803
                        },
                        {
                            "class_name": "UnalignedChunk",
                            "similarity_score": 0.2734457123205325
                        },
                        {
                            "class_name": "ReciprocalLeastSquareFit",
                            "similarity_score": 0.4478828060500464
                        },
                        {
                            "class_name": "PinnedObjectSupportImpl",
                            "similarity_score": 0.4050911772664269
                        },
                        {
                            "class_name": "PathEdge",
                            "similarity_score": 0.34858037479381
                        },
                        {
                            "class_name": "Timer",
                            "similarity_score": 0.5205025983479279
                        },
                        {
                            "class_name": "SurvivorMemoryPoolMXBean",
                            "similarity_score": 0.3228690593869026
                        },
                        {
                            "class_name": "UseSerialOrEpsilonGC",
                            "similarity_score": 0.23227919974668068
                        },
                        {
                            "class_name": "WritableHugeMemoryWalkerAccess",
                            "similarity_score": 0.28646628331823293
                        },
                        {
                            "class_name": "WritableRegularMemoryWalkerAccess",
                            "similarity_score": 0.2886283236756767
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ReferenceObjectProcessing",
                        "HeapChunkProvider",
                        "ThreadLocalAllocation"
                    ],
                    "llm_response_time": 5510,
                    "similarity_computation_time": 23,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "62cf889a84c204b3c995a38beb48d35443a5f0a8",
        "url": "https://github.com/oracle/graal/commit/62cf889a84c204b3c995a38beb48d35443a5f0a8",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method package languageHomes() : Map<String,Path> extracted from package createForEngine(engine PolyglotEngineImpl, resourcesFileSystem FileSystem, delegateFileSystem FileSystem) : ResourcesFileSystem in class com.oracle.truffle.polyglot.FileSystems.ResourcesFileSystem & moved to class com.oracle.truffle.polyglot.PolyglotEngineImpl",
            "leftSideLocations": [
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/FileSystems.java",
                    "startLine": 1231,
                    "endLine": 1242,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "package createForEngine(engine PolyglotEngineImpl, resourcesFileSystem FileSystem, delegateFileSystem FileSystem) : ResourcesFileSystem"
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/FileSystems.java",
                    "startLine": 1232,
                    "endLine": 1232,
                    "startColumn": 13,
                    "endColumn": 55,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/FileSystems.java",
                    "startLine": 1235,
                    "endLine": 1235,
                    "startColumn": 21,
                    "endColumn": 82,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/FileSystems.java",
                    "startLine": 1236,
                    "endLine": 1238,
                    "startColumn": 21,
                    "endColumn": 22,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/FileSystems.java",
                    "startLine": 1234,
                    "endLine": 1239,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/FileSystems.java",
                    "startLine": 1233,
                    "endLine": 1240,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "ENHANCED_FOR_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/FileSystems.java",
                    "startLine": 1236,
                    "endLine": 1238,
                    "startColumn": 47,
                    "endColumn": 22,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/FileSystems.java",
                    "startLine": 1234,
                    "endLine": 1239,
                    "startColumn": 39,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/FileSystems.java",
                    "startLine": 1233,
                    "endLine": 1240,
                    "startColumn": 64,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2340,
                    "endLine": 2352,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "package languageHomes() : Map<String,Path>"
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2341,
                    "endLine": 2341,
                    "startColumn": 9,
                    "endColumn": 59,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2345,
                    "endLine": 2345,
                    "startColumn": 17,
                    "endColumn": 63,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2346,
                    "endLine": 2348,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2343,
                    "endLine": 2349,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2342,
                    "endLine": 2350,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "ENHANCED_FOR_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2346,
                    "endLine": 2348,
                    "startColumn": 43,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2343,
                    "endLine": 2349,
                    "startColumn": 35,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2342,
                    "endLine": 2350,
                    "startColumn": 53,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/FileSystems.java",
                    "startLine": 1231,
                    "endLine": 1233,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "package createForEngine(engine PolyglotEngineImpl, resourcesFileSystem FileSystem, delegateFileSystem FileSystem) : ResourcesFileSystem"
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/FileSystems.java",
                    "startLine": 1232,
                    "endLine": 1232,
                    "startColumn": 127,
                    "endColumn": 149,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "engine.languageHomes()"
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2344,
                    "endLine": 2344,
                    "startColumn": 17,
                    "endColumn": 54,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2347,
                    "endLine": 2347,
                    "startColumn": 21,
                    "endColumn": 77,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2351,
                    "endLine": 2351,
                    "startColumn": 9,
                    "endColumn": 30,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                }
            ],
            "isStatic": false
        },
        "ref_id": 486,
        "extraction_results": {
            "success": true,
            "newCommitHash": "be4c3997b8549decd497525356b8fe98fe000060",
            "newBranchName": "extract-languageHomes-createForEngine-27fe3e8"
        },
        "telemetry": {
            "id": "1882c2f6-2c69-49c5-a02f-d159e0f0aaea",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 312,
                "lineStart": 1224,
                "lineEnd": 1535,
                "bodyLineStart": 1224,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/FileSystems.java",
                "sourceCode": "private static final class ResourcesFileSystem implements PolyglotFileSystem {\n\n        private final FileSystem resourcesFileSystem;\n        private final FileSystem delegateFileSystem;\n        private final InternalResourceRoots resourceRoots;\n        private final Set<Path> languageHomes;\n\n        static ResourcesFileSystem createForEngine(PolyglotEngineImpl engine, FileSystem resourcesFileSystem, FileSystem delegateFileSystem) {\n            Set<Path> languageHomes = new HashSet<>();\n            for (PolyglotLanguage language : engine.languages) {\n                if (language != null) {\n                    final String languageHome = language.cache.getLanguageHome();\n                    if (languageHome != null) {\n                        languageHomes.add(Paths.get(languageHome));\n                    }\n                }\n            }\n            return new ResourcesFileSystem(resourcesFileSystem, delegateFileSystem, engine.internalResourceRoots, languageHomes);\n        }\n\n        private void languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes) {\n            for (PolyglotLanguage language : engine.languages) {\n                if (language != null) {\n                    final String languageHome = language.cache.getLanguageHome();\n                    if (languageHome != null) {\n                        languageHomes.add(Paths.get(languageHome));\n                    }\n                }\n            }\n        }\n\n        static ResourcesFileSystem createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem) {\n            Set<Path> languageHomes = new HashSet<>();\n            for (LanguageCache cache : LanguageCache.languages().values()) {\n                final String languageHome = cache.getLanguageHome();\n                if (languageHome != null) {\n                    languageHomes.add(Paths.get(languageHome));\n                }\n            }\n            return new ResourcesFileSystem(resourcesFileSystem, delegateFileSystem, InternalResourceRoots.getInstance(), languageHomes);\n        }\n\n        private ResourcesFileSystem(FileSystem resourcesFileSystem, FileSystem delegateFileSystem,\n                        InternalResourceRoots resourceRoots, Set<Path> languageHomes) {\n            this.resourcesFileSystem = Objects.requireNonNull(resourcesFileSystem, \"ResourcesFileSystem must be non-null\");\n            this.delegateFileSystem = Objects.requireNonNull(delegateFileSystem, \"DelegateFileSystem must be non-null\");\n            this.resourceRoots = Objects.requireNonNull(resourceRoots, \"ResourceRoots must be non-null\");\n            this.languageHomes = Objects.requireNonNull(languageHomes, \"LanguageHomes must be non-null\");\n            Class<? extends Path> resourcesFileSystemPathType = this.resourcesFileSystem.parsePath(\"\").getClass();\n            Class<? extends Path> customFileSystemPathType = delegateFileSystem.parsePath(\"\").getClass();\n            if (resourcesFileSystemPathType != customFileSystemPathType) {\n                throw new IllegalArgumentException(\"Given FileSystem must have the same Path type as the default FileSystem.\");\n            }\n            if (!resourcesFileSystem.getSeparator().equals(delegateFileSystem.getSeparator())) {\n                throw new IllegalArgumentException(\"Given FileSystem must use the same separator character as the default FileSystem.\");\n            }\n            if (!resourcesFileSystem.getPathSeparator().equals(delegateFileSystem.getPathSeparator())) {\n                throw new IllegalArgumentException(\"Given FileSystem must use the same path separator character as the default FileSystem.\");\n            }\n        }\n\n        @Override\n        public boolean isInternal(AbstractPolyglotImpl polyglot) {\n            return polyglot.isInternalFileSystem(delegateFileSystem);\n        }\n\n        @Override\n        public boolean hasNoAccess() {\n            return (delegateFileSystem instanceof PolyglotFileSystem) && ((PolyglotFileSystem) delegateFileSystem).hasNoAccess();\n        }\n\n        @Override\n        public boolean isHost() {\n            return (delegateFileSystem instanceof PolyglotFileSystem) && ((PolyglotFileSystem) delegateFileSystem).isHost();\n        }\n\n        @Override\n        public Path parsePath(URI uri) {\n            return delegateFileSystem.parsePath(uri);\n        }\n\n        @Override\n        public Path parsePath(String path) {\n            return delegateFileSystem.parsePath(path);\n        }\n\n        @Override\n        public void checkAccess(Path path, Set<? extends AccessMode> modes, LinkOption... linkOptions) throws IOException {\n            Path absolutePath = toNormalizedAbsolutePath(path);\n            if (inResourceRoot(absolutePath)) {\n                resourcesFileSystem.checkAccess(absolutePath, modes, linkOptions);\n            } else {\n                delegateFileSystem.checkAccess(path, modes, linkOptions);\n            }\n        }\n\n        @Override\n        public void createDirectory(Path dir, FileAttribute<?>... attrs) throws IOException {\n            Path absolutePath = toNormalizedAbsolutePath(dir);\n            if (inResourceRoot(absolutePath)) {\n                resourcesFileSystem.createDirectory(absolutePath, attrs);\n            } else {\n                delegateFileSystem.createDirectory(dir, attrs);\n            }\n        }\n\n        @Override\n        public void delete(Path path) throws IOException {\n            Path absolutePath = toNormalizedAbsolutePath(path);\n            if (inResourceRoot(absolutePath)) {\n                resourcesFileSystem.delete(absolutePath);\n            } else {\n                delegateFileSystem.delete(path);\n            }\n        }\n\n        @Override\n        public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n            Path absolutePath = toNormalizedAbsolutePath(path);\n            if (inResourceRoot(absolutePath)) {\n                return resourcesFileSystem.newByteChannel(absolutePath, options, attrs);\n            } else {\n                return delegateFileSystem.newByteChannel(path, options, attrs);\n            }\n        }\n\n        @Override\n        public DirectoryStream<Path> newDirectoryStream(Path dir, DirectoryStream.Filter<? super Path> filter) throws IOException {\n            Path absolutePath = toNormalizedAbsolutePath(dir);\n            if (inResourceRoot(absolutePath)) {\n                return resourcesFileSystem.newDirectoryStream(absolutePath, filter);\n            } else {\n                return delegateFileSystem.newDirectoryStream(dir, filter);\n            }\n        }\n\n        @Override\n        public Path toAbsolutePath(Path path) {\n            return delegateFileSystem.toAbsolutePath(path);\n        }\n\n        @Override\n        public Path toRealPath(Path path, LinkOption... linkOptions) throws IOException {\n            Path absolutePath = toNormalizedAbsolutePath(path);\n            if (inResourceRoot(absolutePath)) {\n                return resourcesFileSystem.toRealPath(path);\n            } else {\n                return delegateFileSystem.toRealPath(path);\n            }\n        }\n\n        @Override\n        public Map<String, Object> readAttributes(Path path, String attributes, LinkOption... options) throws IOException {\n            Path absolutePath = toNormalizedAbsolutePath(path);\n            if (inResourceRoot(absolutePath)) {\n                return resourcesFileSystem.readAttributes(absolutePath, attributes, options);\n            } else {\n                return delegateFileSystem.readAttributes(path, attributes, options);\n            }\n        }\n\n        @Override\n        public void setAttribute(Path path, String attribute, Object value, LinkOption... options) throws IOException {\n            Path absolutePath = toNormalizedAbsolutePath(path);\n            if (inResourceRoot(absolutePath)) {\n                resourcesFileSystem.setAttribute(absolutePath, attribute, value, options);\n            } else {\n                delegateFileSystem.setAttribute(path, attribute, value, options);\n            }\n        }\n\n        @Override\n        public void createLink(Path link, Path existing) throws IOException {\n            Path absoluteLink = toNormalizedAbsolutePath(link);\n            Path absoluteExisting = toNormalizedAbsolutePath(existing);\n            boolean linkInHome = inResourceRoot(absoluteLink);\n            boolean existingInHome = inResourceRoot(absoluteExisting);\n            if (linkInHome && existingInHome) {\n                resourcesFileSystem.createLink(absoluteLink, absoluteExisting);\n            } else if (!linkInHome && !existingInHome) {\n                delegateFileSystem.createLink(link, existing);\n            } else {\n                throw new IOException(\"Cross file system linking is not supported.\");\n            }\n        }\n\n        @Override\n        public void createSymbolicLink(Path link, Path target, FileAttribute<?>... attrs) throws IOException {\n            Path absoluteLink = toNormalizedAbsolutePath(link);\n            Path absoluteTarget = toNormalizedAbsolutePath(target);\n            boolean linkInHome = inResourceRoot(absoluteLink);\n            boolean targetInHome = inResourceRoot(absoluteTarget);\n            if (linkInHome && targetInHome) {\n                resourcesFileSystem.createSymbolicLink(absoluteLink, target);\n            } else if (!linkInHome && !targetInHome) {\n                delegateFileSystem.createSymbolicLink(link, target);\n            } else {\n                throw new IOException(\"Cross file system linking is not supported.\");\n            }\n        }\n\n        @Override\n        public Path readSymbolicLink(Path link) throws IOException {\n            Path absolutePath = toNormalizedAbsolutePath(link);\n            if (inResourceRoot(absolutePath)) {\n                return resourcesFileSystem.readSymbolicLink(absolutePath);\n            } else {\n                return delegateFileSystem.readSymbolicLink(link);\n            }\n        }\n\n        @Override\n        public void setCurrentWorkingDirectory(Path currentWorkingDirectory) {\n            resourcesFileSystem.setCurrentWorkingDirectory(currentWorkingDirectory);\n            delegateFileSystem.setCurrentWorkingDirectory(currentWorkingDirectory);\n        }\n\n        @Override\n        public String getSeparator() {\n            return delegateFileSystem.getSeparator();\n        }\n\n        @Override\n        public String getPathSeparator() {\n            return delegateFileSystem.getPathSeparator();\n        }\n\n        @Override\n        public String getMimeType(Path path) {\n            Path absolutePath = toNormalizedAbsolutePath(path);\n            if (inResourceRoot(absolutePath)) {\n                return resourcesFileSystem.getMimeType(absolutePath);\n            } else {\n                return delegateFileSystem.getMimeType(path);\n            }\n        }\n\n        @Override\n        public Charset getEncoding(Path path) {\n            Path absolutePath = toNormalizedAbsolutePath(path);\n            if (inResourceRoot(absolutePath)) {\n                return resourcesFileSystem.getEncoding(absolutePath);\n            } else {\n                return delegateFileSystem.getEncoding(path);\n            }\n        }\n\n        @Override\n        public Path getTempDirectory() {\n            return delegateFileSystem.getTempDirectory();\n        }\n\n        @Override\n        public boolean isSameFile(Path path1, Path path2, LinkOption... options) throws IOException {\n            Path absolutePath1 = toNormalizedAbsolutePath(path1);\n            Path absolutePath2 = toNormalizedAbsolutePath(path2);\n            boolean path1InHome = inResourceRoot(absolutePath1);\n            boolean path2InHome = inResourceRoot(absolutePath2);\n            if (path1InHome && path2InHome) {\n                return resourcesFileSystem.isSameFile(absolutePath1, absolutePath2, options);\n            } else if (!path1InHome && !path2InHome) {\n                return delegateFileSystem.isSameFile(path1, path2);\n            } else {\n                return false;\n            }\n        }\n\n        private Path toNormalizedAbsolutePath(Path path) {\n            if (path.isAbsolute()) {\n                return path;\n            }\n            Path absolutePath = resourcesFileSystem.toAbsolutePath(path);\n            if (isNormalized(path)) {\n                return absolutePath;\n            } else {\n                return absolutePath.normalize();\n\n            }\n        }\n\n        /**\n         * Checks if the {@code path} is normalized. The path is normalized if it does not contain\n         * \".\" nor \"..\" path elements. In most cases the path coming from the {@link TruffleFile} is\n         * already normalized. The {@link Path#normalize()} calls are expensive even on normalized\n         * paths. It's faster to check if the normalization is needed and normalize only\n         * non-normalized paths.\n         */\n        private static boolean isNormalized(Path path) {\n            for (Path name : path) {\n                String strName = name.toString();\n                if (\".\".equals(strName) || \"..\".equals(strName)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private boolean inResourceRoot(final Path path) {\n            if (!(path.isAbsolute() && isNormalized(path))) {\n                throw new IllegalArgumentException(\"The path must be normalized absolute path.\");\n            }\n            if (resourceRoots.findRoot(path) != null) {\n                return true;\n            }\n            for (Path home : languageHomes) {\n                if (path.startsWith(home)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }",
                "methodCount": 31
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 3,
                "candidates": [
                    {
                        "lineStart": 1254,
                        "lineEnd": 1263,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method createForEmbedder to class PreInitializeContextFileSystem",
                        "description": "move method createForEmbedder to PsiClass:PreInitializeContextFileSystem\nRationale: The method 'createForEmbedder()' creates a new ResourcesFileSystem instance using a delegate filesystem and a resources filesystem, which aligns with the responsibilities and operations of 'PreInitializeContextFileSystem'. This class manages different file systems and would logically be the class responsible for creating a ResourcesFileSystem object using other file systems. Furthermore, 'PreInitializeContextFileSystem' already handles operations such as loading pre-initialized contexts and managing internal and delegate file systems, making it the most appropriate class to house this method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1230,
                        "lineEnd": 1241,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method createForEngine to class FileSystems",
                        "description": "move method createForEngine to PsiClass:FileSystems\nRationale: The createForEngine() method involves creating and managing a ResourcesFileSystem instance, which ties in closely with other methods in the FileSystems class such as createForEmbedder() and newResourcesFileSystem(). Both these methods also deal with creating specific types of FileSystem instances. Therefore, moving the createForEngine() method to FileSystems would enhance the cohesiveness of the codebase and better encapsulate the file system creation logic.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1243,
                        "lineEnd": 1252,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method languageHomes to class PolyglotEngineImpl",
                        "description": "Move method languageHomes to com.oracle.truffle.polyglot.PolyglotEngineImpl\nRationale: The method languageHomes() interacts closely with the PolyglotEngineImpl's languages field. It iterates through its languages and fetches language home directories. This logic inherently belongs to the PolyglotEngineImpl class because it is tightly coupled with the internal structure and data of PolyglotEngineImpl. Keeping it within PolyglotEngineImpl promotes cohesion and maintains the integrity of object-oriented principles by encapsulating the behavior with its related data.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "createForEngine",
                            "method_signature": "static ResourcesFileSystem createForEngine(PolyglotEngineImpl engine, FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                            "target_class": "PolyglotEngineImpl",
                            "rationale": "This method is responsible for creating a ResourcesFileSystem instance specifically for a PolyglotEngineImpl object. It accesses internal properties of the PolyglotEngineImpl instance and should therefore be encapsulated within that class."
                        },
                        {
                            "method_name": "createForEmbedder",
                            "method_signature": "static ResourcesFileSystem createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                            "target_class": "LanguageCache",
                            "rationale": "This method is concerned with creating a ResourcesFileSystem object that involves LanguageCache. It directly iterates over LanguageCache entries, making it more appropriate to be placed inside the LanguageCache class."
                        },
                        {
                            "method_name": "languageHomes",
                            "method_signature": "private void languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes)",
                            "target_class": "PolyglotEngineImpl",
                            "rationale": "This method iterates over the languages present in a PolyglotEngineImpl instance to populate languageHomes. It should be in PolyglotEngineImpl to encapsulate the iteration logic closer to where the data resides."
                        }
                    ],
                    "llm_response_time": 4308
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "languageHomes",
                            "method_signature": "private void languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes)",
                            "target_class": "PolyglotEngineImpl",
                            "rationale": "The `languageHomes` method directly interacts with `PolyglotEngineImpl` by iterating over its `languages` field. This logic seems more cohesive within `PolyglotEngineImpl` which owns the `languages` field."
                        },
                        {
                            "method_name": "createForEngine",
                            "method_signature": "static ResourcesFileSystem createForEngine(PolyglotEngineImpl engine, FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                            "target_class": "PolyglotEngineImpl",
                            "rationale": "The `createForEngine` method is concerned with creating a `ResourcesFileSystem` instance based on data contained within `PolyglotEngineImpl`. It would be more appropriate to relocate this method to `PolyglotEngineImpl`."
                        },
                        {
                            "method_name": "createForEmbedder",
                            "method_signature": "static ResourcesFileSystem createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                            "target_class": "LanguageCache",
                            "rationale": "The `createForEmbedder` method majorly involves the `LanguageCache` and iterates over its elements. It would achieve a better cohesion if placed within `LanguageCache`."
                        }
                    ],
                    "llm_response_time": 4068
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "createForEngine",
                            "method_signature": "static ResourcesFileSystem createForEngine(PolyglotEngineImpl engine, FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                            "target_class": "PolyglotEngineImpl",
                            "rationale": "This method heavily relies on the PolyglotEngineImpl object and accesses its languages. It seems more fitting to be within the PolyglotEngineImpl class itself."
                        },
                        {
                            "method_name": "createForEmbedder",
                            "method_signature": "static ResourcesFileSystem createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                            "target_class": "LanguageCache",
                            "rationale": "This method interacts with the LanguageCache to retrieve language homes and create a new ResourcesFileSystem. It would be more appropriate in LanguageCache class to encapsulate this responsibility."
                        },
                        {
                            "method_name": "languageHomes",
                            "method_signature": "private void languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes)",
                            "target_class": "PolyglotEngineImpl",
                            "rationale": "This method gathers the language homes from the PolyglotEngineImpl instance. It would make more sense to place it within the PolyglotEngineImpl class for better encapsulation and responsibility assignment."
                        }
                    ],
                    "llm_response_time": 3014
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "createForEngine",
                            "method_signature": "static createForEngine(PolyglotEngineImpl engine, FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "languageHomes",
                            "method_signature": "private languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createForEmbedder",
                            "method_signature": "static createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "inResourceRoot",
                            "method_signature": "private inResourceRoot(final Path path)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "createForEmbedder",
                            "method_signature": "static createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createForEngine",
                            "method_signature": "static createForEngine(PolyglotEngineImpl engine, FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "languageHomes",
                            "method_signature": "private languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "inResourceRoot",
                            "method_signature": "private inResourceRoot(final Path path)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "static createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem)": {
                        "first": {
                            "method_name": "createForEmbedder",
                            "method_signature": "static createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6488698430237737
                    },
                    "static createForEngine(PolyglotEngineImpl engine, FileSystem resourcesFileSystem, FileSystem delegateFileSystem)": {
                        "first": {
                            "method_name": "createForEngine",
                            "method_signature": "static createForEngine(PolyglotEngineImpl engine, FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6858939294622062
                    },
                    "private languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes)": {
                        "first": {
                            "method_name": "languageHomes",
                            "method_signature": "private languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6973581314513698
                    },
                    "private inResourceRoot(final Path path)": {
                        "first": {
                            "method_name": "inResourceRoot",
                            "method_signature": "private inResourceRoot(final Path path)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7827664914355196
                    }
                },
                "voyage": {
                    "private languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes)": {
                        "first": {
                            "method_name": "languageHomes",
                            "method_signature": "private languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5278010370681295
                    },
                    "private inResourceRoot(final Path path)": {
                        "first": {
                            "method_name": "inResourceRoot",
                            "method_signature": "private inResourceRoot(final Path path)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5335332889352333
                    },
                    "static createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem)": {
                        "first": {
                            "method_name": "createForEmbedder",
                            "method_signature": "static createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7154387212189783
                    },
                    "static createForEngine(PolyglotEngineImpl engine, FileSystem resourcesFileSystem, FileSystem delegateFileSystem)": {
                        "first": {
                            "method_name": "createForEngine",
                            "method_signature": "static createForEngine(PolyglotEngineImpl engine, FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.751365492881587
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private inResourceRoot(final Path path)",
                        "private languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes)",
                        "static createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                        "static createForEngine(PolyglotEngineImpl engine, FileSystem resourcesFileSystem, FileSystem delegateFileSystem)"
                    ],
                    "llm_response_time": 4784
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "private inResourceRoot(final Path path)",
                        "private languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes)",
                        "static createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                        "static createForEngine(PolyglotEngineImpl engine, FileSystem resourcesFileSystem, FileSystem delegateFileSystem)"
                    ],
                    "llm_response_time": 0
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes)",
                        "static createForEngine(PolyglotEngineImpl engine, FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                        "static createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem)"
                    ],
                    "llm_response_time": 4236
                },
                "voyage": {
                    "priority_method_names": [
                        "private inResourceRoot(final Path path)",
                        "private languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes)",
                        "static createForEngine(PolyglotEngineImpl engine, FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                        "static createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem)"
                    ],
                    "llm_response_time": 3844
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private inResourceRoot(final Path path)",
                        "private languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes)",
                        "static createForEngine(PolyglotEngineImpl engine, FileSystem resourcesFileSystem, FileSystem delegateFileSystem)",
                        "static createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem)"
                    ],
                    "llm_response_time": 0
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private inResourceRoot(final Path path)",
                        "private languageHomes(PolyglotEngineImpl engine, Set<Path> languageHomes)",
                        "static createForEmbedder(FileSystem resourcesFileSystem, FileSystem delegateFileSystem)"
                    ],
                    "llm_response_time": 3845
                }
            },
            "targetClassMap": {
                "createForEmbedder": {
                    "target_classes": [
                        {
                            "class_name": "FileSystems",
                            "similarity_score": 0.6237493485470745
                        },
                        {
                            "class_name": "PreInitializeContextFileSystem",
                            "similarity_score": 0.6252450912717926
                        },
                        {
                            "class_name": "RelativizeDirectoryStream",
                            "similarity_score": 0.48359470356085693
                        },
                        {
                            "class_name": "RelativizeIterator",
                            "similarity_score": 0.45153080797077094
                        },
                        {
                            "class_name": "InternalResourceImageHeapPath",
                            "similarity_score": 0.4811252243246881
                        },
                        {
                            "class_name": "InvalidFileSystem",
                            "similarity_score": 0.37897974938488765
                        },
                        {
                            "class_name": "NIOFileSystem",
                            "similarity_score": 0.5881307373963525
                        },
                        {
                            "class_name": "DeniedIOFileSystem",
                            "similarity_score": 0.3861616855824453
                        },
                        {
                            "class_name": "LanguageHomeImageHeapPath",
                            "similarity_score": 0.4422258422612767
                        },
                        {
                            "class_name": "ImageBuildTimeFactory",
                            "similarity_score": 0.6359727033932191
                        },
                        {
                            "class_name": "ImageExecutionTimeFactory",
                            "similarity_score": 0.3975231959999626
                        },
                        {
                            "class_name": "FileTypeDetectorsSupplier",
                            "similarity_score": 0.6104860774350479
                        },
                        {
                            "class_name": "ForwardingPathIterator",
                            "similarity_score": 0.41889205354092457
                        },
                        {
                            "class_name": "PreInitializePath",
                            "similarity_score": 0.6404669149159686
                        },
                        {
                            "class_name": "PathImageHeapPath",
                            "similarity_score": 0.46980923864981705
                        },
                        {
                            "class_name": "PathOperationsOnlyFileSystem",
                            "similarity_score": 0.44477402880152556
                        },
                        {
                            "class_name": "ReadOnlyFileSystem",
                            "similarity_score": 0.5305482838361476
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PreInitializeContextFileSystem",
                        "ImageBuildTimeFactory",
                        "PreInitializePath"
                    ],
                    "llm_response_time": 3938,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                },
                "createForEngine": {
                    "target_classes": [
                        {
                            "class_name": "FileSystems",
                            "similarity_score": 0.6538474068657274
                        },
                        {
                            "class_name": "PreInitializeContextFileSystem",
                            "similarity_score": 0.6528679720747237
                        },
                        {
                            "class_name": "RelativizeDirectoryStream",
                            "similarity_score": 0.48343860095713
                        },
                        {
                            "class_name": "RelativizeIterator",
                            "similarity_score": 0.4526345642794944
                        },
                        {
                            "class_name": "InternalResourceImageHeapPath",
                            "similarity_score": 0.4841386618546787
                        },
                        {
                            "class_name": "ImageBuildTimeFactory",
                            "similarity_score": 0.6742512476896771
                        },
                        {
                            "class_name": "ImageExecutionTimeFactory",
                            "similarity_score": 0.4032389192727559
                        },
                        {
                            "class_name": "InvalidFileSystem",
                            "similarity_score": 0.4018263586369921
                        },
                        {
                            "class_name": "NIOFileSystem",
                            "similarity_score": 0.6114377460390247
                        },
                        {
                            "class_name": "FileTypeDetectorsSupplier",
                            "similarity_score": 0.6127452863358023
                        },
                        {
                            "class_name": "ForwardingPathIterator",
                            "similarity_score": 0.4199160251916029
                        },
                        {
                            "class_name": "LanguageHomeImageHeapPath",
                            "similarity_score": 0.4514784076932588
                        },
                        {
                            "class_name": "PreInitializePath",
                            "similarity_score": 0.672737848782346
                        },
                        {
                            "class_name": "PathImageHeapPath",
                            "similarity_score": 0.49018043843882814
                        },
                        {
                            "class_name": "PathOperationsOnlyFileSystem",
                            "similarity_score": 0.46921590618906917
                        },
                        {
                            "class_name": "DeniedIOFileSystem",
                            "similarity_score": 0.40965849168452795
                        },
                        {
                            "class_name": "ReadOnlyFileSystem",
                            "similarity_score": 0.5461077117773053
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "FileSystems",
                        "ImageBuildTimeFactory",
                        "PreInitializePath"
                    ],
                    "llm_response_time": 5013,
                    "similarity_computation_time": 6,
                    "similarity_metric": "cosine"
                },
                "languageHomes": {
                    "target_classes": [
                        {
                            "class_name": "PolyglotEngineImpl",
                            "similarity_score": 0.7568123743224723
                        },
                        {
                            "class_name": "InternalResourceRoots",
                            "similarity_score": 0.68776973775383
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PolyglotEngineImpl",
                        "InternalResourceRoots"
                    ],
                    "llm_response_time": 4144,
                    "similarity_computation_time": 8,
                    "similarity_metric": "cosine"
                },
                "inResourceRoot": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2819,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "62cf889a84c204b3c995a38beb48d35443a5f0a8",
        "url": "https://github.com/oracle/graal/commit/62cf889a84c204b3c995a38beb48d35443a5f0a8",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method package languageHomes() : Map<String,Path> extracted from package preinitialize(engine PolyglotEngineImpl, preinitConfig PreinitConfig, sharableLayer PolyglotSharingLayer, languagesToPreinitialize Set<PolyglotLanguage>, emitWarning boolean) : PolyglotContextImpl in class com.oracle.truffle.polyglot.PolyglotContextImpl & moved to class com.oracle.truffle.polyglot.PolyglotEngineImpl",
            "leftSideLocations": [
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotContextImpl.java",
                    "startLine": 3551,
                    "endLine": 3628,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "package preinitialize(engine PolyglotEngineImpl, preinitConfig PreinitConfig, sharableLayer PolyglotSharingLayer, languagesToPreinitialize Set<PolyglotLanguage>, emitWarning boolean) : PolyglotContextImpl"
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotContextImpl.java",
                    "startLine": 3613,
                    "endLine": 3613,
                    "startColumn": 13,
                    "endColumn": 63,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotContextImpl.java",
                    "startLine": 3616,
                    "endLine": 3616,
                    "startColumn": 21,
                    "endColumn": 58,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotContextImpl.java",
                    "startLine": 3617,
                    "endLine": 3617,
                    "startColumn": 21,
                    "endColumn": 67,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotContextImpl.java",
                    "startLine": 3619,
                    "endLine": 3619,
                    "startColumn": 25,
                    "endColumn": 81,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotContextImpl.java",
                    "startLine": 3618,
                    "endLine": 3620,
                    "startColumn": 21,
                    "endColumn": 22,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotContextImpl.java",
                    "startLine": 3615,
                    "endLine": 3621,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotContextImpl.java",
                    "startLine": 3614,
                    "endLine": 3622,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "ENHANCED_FOR_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotContextImpl.java",
                    "startLine": 3618,
                    "endLine": 3620,
                    "startColumn": 47,
                    "endColumn": 22,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotContextImpl.java",
                    "startLine": 3615,
                    "endLine": 3621,
                    "startColumn": 39,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotContextImpl.java",
                    "startLine": 3614,
                    "endLine": 3622,
                    "startColumn": 64,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2340,
                    "endLine": 2352,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "package languageHomes() : Map<String,Path>"
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2341,
                    "endLine": 2341,
                    "startColumn": 9,
                    "endColumn": 59,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2344,
                    "endLine": 2344,
                    "startColumn": 17,
                    "endColumn": 54,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2345,
                    "endLine": 2345,
                    "startColumn": 17,
                    "endColumn": 63,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2347,
                    "endLine": 2347,
                    "startColumn": 21,
                    "endColumn": 77,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2346,
                    "endLine": 2348,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2343,
                    "endLine": 2349,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2342,
                    "endLine": 2350,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "ENHANCED_FOR_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2346,
                    "endLine": 2348,
                    "startColumn": 43,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2343,
                    "endLine": 2349,
                    "startColumn": 35,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2342,
                    "endLine": 2350,
                    "startColumn": 53,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotContextImpl.java",
                    "startLine": 3551,
                    "endLine": 3618,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "package preinitialize(engine PolyglotEngineImpl, preinitConfig PreinitConfig, sharableLayer PolyglotSharingLayer, languagesToPreinitialize Set<PolyglotLanguage>, emitWarning boolean) : PolyglotContextImpl"
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotContextImpl.java",
                    "startLine": 3613,
                    "endLine": 3613,
                    "startColumn": 47,
                    "endColumn": 69,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "engine.languageHomes()"
                },
                {
                    "filePath": "truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotEngineImpl.java",
                    "startLine": 2351,
                    "endLine": 2351,
                    "startColumn": 9,
                    "endColumn": 30,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                }
            ],
            "isStatic": false
        },
        "ref_id": 487,
        "extraction_results": {
            "success": true,
            "newCommitHash": "12668a78c336901d84c3681a5fc4cd9f49014d4e",
            "newBranchName": "extract-languageHomes-preinitialize-27fe3e8"
        },
        "telemetry": {
            "id": "9e0b810a-d8b1-4c6e-b4f8-3f4f30e057bd",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 3739,
                "lineStart": 123,
                "lineEnd": 3861,
                "bodyLineStart": 123,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/truffle/src/com.oracle.truffle.polyglot/src/com/oracle/truffle/polyglot/PolyglotContextImpl.java",
                "sourceCode": "final class PolyglotContextImpl implements com.oracle.truffle.polyglot.PolyglotImpl.VMObject {\n\n    private static final TruffleLogger LOG = TruffleLogger.getLogger(PolyglotEngineImpl.OPTION_GROUP_ENGINE, PolyglotContextImpl.class);\n    private static final InteropLibrary UNCACHED = InteropLibrary.getFactory().getUncached();\n    private static final Object[] DISPOSED_CONTEXT_THREAD_LOCALS = new Object[0];\n    private static final Map<State, State[]> VALID_TRANSITIONS = new EnumMap<>(State.class);\n    private static final TruffleSafepoint.Interrupter DO_NOTHING_INTERRUPTER = new TruffleSafepoint.Interrupter() {\n        @Override\n        public void interrupt(Thread thread) {\n\n        }\n\n        @Override\n        public void resetInterrupted() {\n\n        }\n    };\n\n    static {\n        VALID_TRANSITIONS.put(State.DEFAULT, new State[]{\n                        State.CLOSING,\n                        State.INTERRUPTING,\n                        State.PENDING_EXIT,\n                        State.CANCELLING,\n                        State.EXITING, // only for child contexts and local contexts for isolated\n                                       // contexts\n        });\n        VALID_TRANSITIONS.put(State.CLOSING, new State[]{\n                        State.CLOSING_FINALIZING,\n                        State.CLOSING_INTERRUPTING,\n                        State.CLOSING_CANCELLING,\n                        State.CLOSING_PENDING_EXIT,\n                        State.CLOSING_EXITING,  // only for child contexts and local contexts for\n                                                // isolated contexts\n                        State.DEFAULT\n        });\n        VALID_TRANSITIONS.put(State.CLOSING_FINALIZING, new State[]{\n                        State.CLOSED,\n                        State.CLOSING_INTERRUPTING_FINALIZING,\n                        State.CLOSING_CANCELLING,\n                        State.CLOSING_EXITING,  // only for child contexts and local contexts for\n                                                // isolated contexts\n                        State.DEFAULT\n        });\n        VALID_TRANSITIONS.put(State.INTERRUPTING, new State[]{\n                        State.DEFAULT,\n                        State.CLOSING_INTERRUPTING,\n                        State.CANCELLING,\n                        State.PENDING_EXIT,\n                        State.EXITING,  // only for child contexts and local contexts for isolated\n                                        // contexts\n        });\n        VALID_TRANSITIONS.put(State.PENDING_EXIT, new State[]{\n                        State.EXITING,\n                        State.CANCELLING\n        });\n        VALID_TRANSITIONS.put(State.CANCELLING, new State[]{\n                        State.CLOSING_CANCELLING\n        });\n        VALID_TRANSITIONS.put(State.CLOSING_INTERRUPTING, new State[]{\n                        State.CLOSING_INTERRUPTING_FINALIZING,\n                        State.CLOSING,\n                        State.CLOSING_PENDING_EXIT,\n                        State.CLOSING_CANCELLING,\n                        State.CLOSING_EXITING,  // only for child contexts and local contexts for\n                                                // isolate contexts\n                        State.INTERRUPTING\n        });\n        VALID_TRANSITIONS.put(State.CLOSING_INTERRUPTING_FINALIZING, new State[]{\n                        State.CLOSED_INTERRUPTED,\n                        State.CLOSING_FINALIZING,\n                        State.CLOSING_CANCELLING,\n                        State.CLOSING_EXITING,  // only for child contexts and local contexts for\n                                                // isolated contexts\n                        State.INTERRUPTING\n        });\n        VALID_TRANSITIONS.put(State.CLOSING_CANCELLING, new State[]{\n                        State.CLOSED_CANCELLED,\n                        State.CANCELLING\n        });\n        VALID_TRANSITIONS.put(State.CLOSING_PENDING_EXIT, new State[]{\n                        State.CLOSING_EXITING,\n                        State.CLOSING_CANCELLING,\n                        State.PENDING_EXIT\n        });\n        VALID_TRANSITIONS.put(State.CLOSING_EXITING, new State[]{\n                        State.CLOSED_EXITED,\n                        State.EXITING\n        });\n        VALID_TRANSITIONS.put(State.EXITING, new State[]{\n                        State.CLOSING_EXITING\n        });\n        VALID_TRANSITIONS.put(State.CLOSED,\n                        new State[0]);\n        VALID_TRANSITIONS.put(State.CLOSED_CANCELLED,\n                        new State[0]);\n        VALID_TRANSITIONS.put(State.CLOSED_EXITED,\n                        new State[0]);\n    }\n\n    enum State {\n        /*\n         * Initial state. Context is valid and ready for use.\n         */\n        DEFAULT,\n        /*\n         * Interrupt operation has been started. Threads are being interrupted.\n         */\n        INTERRUPTING,\n        /*\n         * Hard exit was called in the DEFAULT or the INTERRUPTING state and exit notifications (see\n         * TruffleLanguage#exitContext) are about to be executed or are already executing. the\n         * PENDING_EXIT state overrides the INTERRUPTING state.\n         */\n        PENDING_EXIT,\n        /*\n         * Exit operation has been initiated after exit notifications were executed in the\n         * PENDING_EXIT state. Threads are being stopped.\n         */\n        EXITING,\n        /*\n         * Cancel operation has been initiated. Threads are being stopped. The CANCELLING state\n         * overrides the INTERRUPTING and the PENDING_EXIT state.\n         */\n        CANCELLING,\n        /*\n         * Close operation has been initiated in the DEFAULT state, or it has been initiated in the\n         * INTERRUPTING state and the interrupt operation stopped during closing. The thread that\n         * initiated the operation is stored in the closingThread field. The close operation either\n         * finishes successfully and the context goes into one of the closed states, or the close\n         * operation fails and the context goes back to the DEFAULT state.\n         */\n        CLOSING,\n        /*\n         * Hard exit was called in the CLOSING or the CLOSING_INTERRUPTING state and exit\n         * notifications (see TruffleLanguage#exitContext) are about to be executed or are already\n         * executing. the CLOSING_PENDING_EXIT state overrides the CLOSING_INTERRUPTING state.\n         */\n        CLOSING_PENDING_EXIT,\n        /*\n         * The close operation progressed to the \"finalizing\" stage where creation of inner contexts\n         * and caching of thread info is no longer allowed. Also, hard exit is no longer allowed in\n         * this state. The close operation either finishes successfully and the context goes into\n         * one of the closed states, or the close operation fails and the context goes back to the\n         * DEFAULT state.\n         */\n        CLOSING_FINALIZING,\n        /*\n         * Close operation has been initiated in the INTERRUPTING state and the interrupt operation\n         * is still in progress, or it has been initiated in the DEFAULT state and the interrupt\n         * operation started during closing, i.e., the transition to this state can either be from\n         * the CLOSING or the INTERRUPTING state. Even if the transition is from the CLOSING state\n         * the closingThread is still the one that initiated the close operation, not the one that\n         * initiated the interrupt operation. The close operation either finishes successfully and\n         * the context goes into one of the closed states, or the close operation fails and the\n         * context goes back to the INTERRUPTING state.\n         */\n        CLOSING_INTERRUPTING,\n        /*\n         * The close operation while interrupting progressed to the \"finalizing\" stage where\n         * creation of inner contexts is no longer allowed. Also, hard exit is no longer allowed in\n         * this state. The close operation either finishes successfully and the context goes into\n         * one of the closed states, or the close operation fails and the context goes back to the\n         * INTERRUPTING state.\n         */\n        CLOSING_INTERRUPTING_FINALIZING,\n        /*\n         * Close operation has been initiated and at the same time the cancel operation is in\n         * progress. Transition to this state can either be from the CLOSING, the CANCELLING, or the\n         * CLOSING_INTERRUPTING state. Even if the transition is from one of the closing states the\n         * closingThread is still the one that initiated the close operation. The CLOSING_CANCELLING\n         * state overrides the CLOSING and the CLOSING_INTERRUPTING states. Close operation that\n         * started in the CLOSING_CANCELLING state must finish successfully, otherwise it is an\n         * internal error. Close operation that did not start in the CLOSING_CANCELLING state and\n         * the state was overridden by CLOSING_CANCELLING during the operation can fail in which\n         * case the state goes back to CANCELLING.\n         */\n        CLOSING_CANCELLING,\n        /*\n         * Close operation has been initiated and at the same time exit operation is in progress.\n         * Transition to this state can be only from the EXITING state. Close operation that started\n         * in the CLOSING_EXITING state must finish successfully, otherwise it is an internal error.\n         */\n        CLOSING_EXITING,\n        /*\n         * Closing operation in the CLOSING state has finished successfully via the\n         * CLOSING_FINALIZING state.\n         */\n        CLOSED,\n        /*\n         * Closing operation in the CLOSING_INTERRUPTING state has finished successfully via the\n         * CLOSING_INTERRUPTING_FINALIZING state. Essentially the same as the CLOSED state, the only\n         * difference is that in the CLOSED_INTERRUPTED state, the context leave operations on\n         * threads that are still entered notify the thread that is waiting for the interrupting\n         * operation to complete.\n         */\n        CLOSED_INTERRUPTED,\n        /*\n         * Closing operation in the CLOSING_CANCELLING state has finished successfully.\n         */\n        CLOSED_CANCELLED,\n        /*\n         * Closing operation in the CLOSING_EXITING state has finished successfully.\n         */\n        CLOSED_EXITED;\n\n        /*\n         * If false then code can run in this context. If true then code can no longer run - due to\n         * cancelling, exiting or closing.\n         */\n        boolean isInvalidOrClosed() {\n            switch (this) {\n                case CANCELLING:\n                case EXITING:\n                case CLOSING_CANCELLING:\n                case CLOSING_EXITING:\n                case CLOSED:\n                case CLOSED_INTERRUPTED:\n                case CLOSED_CANCELLED:\n                case CLOSED_EXITED:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        /*\n         * If true the context is not usable and may be in an inconsistent state. This is due to\n         * cancelling or exiting.\n         */\n        boolean isCancelled() {\n            switch (this) {\n                case CANCELLING:\n                case EXITING:\n                case CLOSING_CANCELLING:\n                case CLOSING_EXITING:\n                case CLOSED_CANCELLED:\n                case CLOSED_EXITED:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        boolean isInterrupting() {\n            switch (this) {\n                case INTERRUPTING:\n                case CLOSING_INTERRUPTING:\n                case CLOSING_INTERRUPTING_FINALIZING:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        boolean isCancelling() {\n            switch (this) {\n                case CANCELLING:\n                case CLOSING_CANCELLING:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        boolean isExiting() {\n            switch (this) {\n                case EXITING:\n                case CLOSING_EXITING:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        boolean isClosing() {\n            switch (this) {\n                case CLOSING:\n                case CLOSING_FINALIZING:\n                case CLOSING_INTERRUPTING:\n                case CLOSING_INTERRUPTING_FINALIZING:\n                case CLOSING_CANCELLING:\n                case CLOSING_PENDING_EXIT:\n                case CLOSING_EXITING:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        boolean isClosed() {\n            switch (this) {\n                case CLOSED:\n                case CLOSED_INTERRUPTED:\n                case CLOSED_CANCELLED:\n                case CLOSED_EXITED:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private boolean shouldCacheThreadInfo() {\n            switch (this) {\n                case DEFAULT:\n                case PENDING_EXIT:\n                case CLOSING:\n                case CLOSING_PENDING_EXIT:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n    }\n\n    volatile State state = State.DEFAULT;\n    final WeakAssumedValue<PolyglotThreadInfo> singleThreadValue = new WeakAssumedValue<>(\"Single thread\");\n    volatile boolean singleThreaded = true;\n\n    private final Map<Thread, PolyglotThreadInfo> threads = new WeakHashMap<>();\n\n    /*\n     * Do not modify only read. Use setCachedThreadInfo to modify.\n     */\n    private volatile PolyglotThreadInfo cachedThreadInfo = PolyglotThreadInfo.NULL;\n    volatile Object api;\n\n    private ExecutorService cleanupExecutorService;\n    private Future<?> cleanupFuture;\n    boolean skipPendingExit;\n    volatile int exitCode;\n    private volatile String exitMessage;\n    volatile Thread closeExitedTriggerThread;\n    private volatile String invalidMessage;\n    volatile boolean invalidResourceLimit;\n    volatile Thread closingThread;\n    private final ReentrantLock closingLock = new ReentrantLock();\n    private final ReentrantLock interruptingLock = new ReentrantLock();\n    private final ReentrantLock initiateCancelOrExitLock = new ReentrantLock();\n    private List<Future<Void>> cancellationOrExitingFutures;\n\n    volatile boolean disposing;\n    volatile boolean finalizingEmbedderThreads;\n    final PolyglotEngineImpl engine;\n    final PolyglotSharingLayer layer;\n    // contexts by PolyglotLanguage.engineIndex\n    @CompilationFinal(dimensions = 1) final PolyglotLanguageContext[] contexts;\n\n    final TruffleContext creatorTruffleContext;\n    final TruffleContext currentTruffleContext;\n    final PolyglotContextImpl parent;\n    volatile Map<String, Object> polyglotBindings; // for direct legacy access\n    volatile Object polyglotHostBindings; // for accesses from the polyglot api\n    private final PolyglotBindings polyglotBindingsObject = new PolyglotBindings(this);\n    final PolyglotLanguage creator; // creator for internal contexts\n    final ContextWeakReference weakReference;\n    final Set<ProcessHandlers.ProcessDecorator> subProcesses;\n\n    @CompilationFinal PolyglotContextConfig config; // effectively final\n\n    // map from class to language index\n    @CompilationFinal private volatile FinalIntMap languageIndexMap;\n\n    private final List<PolyglotContextImpl> childContexts = new ArrayList<>();\n    List<Source> sourcesToInvalidate;  // Non null only during content pre-initialization\n\n    final AtomicLong volatileStatementCounter = new AtomicLong();\n    long statementCounter;\n    final long statementLimit;\n    private volatile Object contextBoundLoggers;\n\n    /*\n     * Initialized once per context.\n     */\n    @CompilationFinal(dimensions = 1) Object[] contextLocals;\n\n    volatile boolean localsCleared;\n\n    private ObjectSizeCalculator objectSizeCalculator;\n\n    final PolyglotThreadLocalActions threadLocalActions;\n    private Collection<Closeable> closeables;\n\n    private final Set<PauseThreadLocalAction> pauseThreadLocalActions = new LinkedHashSet<>();\n\n    @CompilationFinal private Object hostContextImpl;\n\n    final Node uncachedLocation;\n\n    private final Set<LanguageSystemThread> activeSystemThreads = Collections.newSetFromMap(new HashMap<>());\n\n    /* Constructor for testing. */\n    @SuppressWarnings(\"unused\")\n    private PolyglotContextImpl() {\n        this.engine = null;\n        this.contexts = null;\n        this.creatorTruffleContext = null;\n        this.currentTruffleContext = null;\n        this.layer = null;\n        this.parent = null;\n        this.polyglotHostBindings = null;\n        this.polyglotBindings = null;\n        this.creator = null;\n        this.weakReference = null;\n        this.statementLimit = 0;\n        this.threadLocalActions = null;\n        this.subProcesses = new HashSet<>();\n        this.uncachedLocation = null;\n    }\n\n    /*\n     * Constructor for outer contexts.\n     */\n    PolyglotContextImpl(PolyglotEngineImpl engine, PolyglotContextConfig config) {\n        this.parent = null;\n        this.engine = engine;\n        this.layer = new PolyglotSharingLayer(engine);\n        this.config = config;\n        this.creator = null;\n        this.uncachedLocation = new UncachedLocationNode(layer);\n        this.creatorTruffleContext = EngineAccessor.LANGUAGE.createTruffleContext(this, true);\n        this.currentTruffleContext = EngineAccessor.LANGUAGE.createTruffleContext(this, false);\n        this.weakReference = new ContextWeakReference(this);\n        this.contexts = createContextArray();\n        this.subProcesses = new HashSet<>();\n        this.statementLimit = config.limits != null && config.limits.statementLimit != 0 ? config.limits.statementLimit : Long.MAX_VALUE - 1;\n        this.statementCounter = statementLimit;\n        this.volatileStatementCounter.set(statementLimit);\n        this.threadLocalActions = new PolyglotThreadLocalActions(this);\n\n        PolyglotEngineImpl.ensureInstrumentsCreated(config.getConfiguredInstruments());\n\n        /*\n         * Instruments can add loggers, and so configuration of loggers for this context must be\n         * done after instruments are created.\n         */\n        EngineAccessor.LANGUAGE.configureLoggers(this, config.logLevels, getAllLoggers());\n    }\n\n    /*\n     * Constructor for inner contexts.\n     */\n    @SuppressWarnings(\"hiding\")\n    PolyglotContextImpl(PolyglotLanguageContext creator, PolyglotContextConfig config) {\n        PolyglotContextImpl parent = creator.context;\n        this.parent = parent;\n        this.layer = new PolyglotSharingLayer(parent.engine);\n        this.config = config;\n        this.engine = parent.engine;\n        this.creator = creator.language;\n        this.uncachedLocation = new UncachedLocationNode(layer);\n        this.statementLimit = 0; // inner context limit must not be used anyway\n        this.weakReference = new ContextWeakReference(this);\n        this.creatorTruffleContext = EngineAccessor.LANGUAGE.createTruffleContext(this, true);\n        this.currentTruffleContext = EngineAccessor.LANGUAGE.createTruffleContext(this, false);\n        if (parent.state.isInterrupting()) {\n            this.state = State.INTERRUPTING;\n        } else if (parent.state.isCancelling()) {\n            this.state = State.CANCELLING;\n        } else if (parent.state.isExiting()) {\n            this.state = State.EXITING;\n        }\n        this.invalidMessage = this.parent.invalidMessage;\n        this.exitCode = this.parent.exitCode;\n        this.exitMessage = this.parent.exitMessage;\n        this.contextBoundLoggers = this.parent.contextBoundLoggers;\n        this.threadLocalActions = new PolyglotThreadLocalActions(this);\n        EngineAccessor.LANGUAGE.configureLoggers(this, parent.config.logLevels, getAllLoggers());\n        this.contexts = createContextArray();\n        this.subProcesses = new HashSet<>();\n        // notifyContextCreated() is called after spiContext.impl is set to this.\n        this.engine.noInnerContexts.invalidate();\n    }\n\n    /*\n     * Used only in asserts.\n     */\n    private boolean isTransitionAllowed(State fromState, State toState) {\n        assert Thread.holdsLock(this);\n        State[] successors = VALID_TRANSITIONS.get(fromState);\n        for (State successor : successors) {\n            if (successor == toState) {\n                return isAdditionalTransitionConditionSatisfied(fromState, toState);\n            }\n        }\n        return false;\n    }\n\n    private boolean isAdditionalTransitionConditionSatisfied(State fromState, State toState) {\n        assert Thread.holdsLock(this);\n        if (fromState.isClosing() != toState.isClosing()) {\n            if (closingThread != Thread.currentThread()) {\n                return false;\n            }\n        }\n        if (!fromState.isExiting() && toState.isExiting() && fromState != State.PENDING_EXIT && fromState != State.CLOSING_PENDING_EXIT) {\n            if (parent == null && !skipPendingExit) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean shouldCacheThreadInfo() {\n        assert Thread.holdsLock(this);\n        return state.shouldCacheThreadInfo() && !disposing;\n    }\n\n    /**\n     * Claims a sharing layer for a context. This typically happens at when the first non-host\n     * language is initialized in a context.\n     */\n    void claimSharingLayer(PolyglotLanguage language) {\n        PolyglotSharingLayer s = this.layer;\n        if (!s.isClaimed()) {\n            synchronized (engine.lock) {\n                if (!s.isClaimed()) {\n                    assert !language.isHost() : \"cannot claim context for a host language\";\n                    engine.claimSharingLayer(s, this, language);\n                    assert s.isClaimed();\n                    this.weakReference.layer = s;\n                }\n            }\n        }\n    }\n\n    boolean claimSharingLayer(PolyglotSharingLayer sharableLayer, Set<PolyglotLanguage> languages) {\n        PolyglotSharingLayer s = this.layer;\n        synchronized (engine.lock) {\n            assert !s.isClaimed() : \"sharing layer already claimed\";\n            if (!s.isClaimed()) {\n                if (!s.claimLayerForContext(sharableLayer, this, languages)) {\n                    return false;\n                }\n                assert s.isClaimed();\n                assert this.layer.equals(sharableLayer);\n                this.weakReference.layer = s;\n            }\n        }\n        return true;\n    }\n\n    OptionValues getInstrumentContextOptions(PolyglotInstrument instrument) {\n        return config.getInstrumentOptionValues(instrument);\n    }\n\n    public void resetLimits() {\n        PolyglotLanguageContext languageContext = this.getHostContext();\n        Object prev = hostEnter(languageContext);\n        try {\n            PolyglotLimits.reset(this);\n            EngineAccessor.INSTRUMENT.notifyContextResetLimit(engine, creatorTruffleContext);\n        } catch (Throwable e) {\n            throw PolyglotImpl.guestToHostException(languageContext, e, true);\n        } finally {\n            hostLeave(languageContext, prev);\n        }\n    }\n\n    public void safepoint() {\n        PolyglotLanguageContext languageContext = this.getHostContext();\n        Object prev = hostEnter(languageContext);\n        try {\n            TruffleSafepoint.poll(this.uncachedLocation);\n        } catch (Throwable e) {\n            throw PolyglotImpl.guestToHostException(languageContext, e, true);\n        } finally {\n            hostLeave(languageContext, prev);\n        }\n    }\n\n    private PolyglotLanguageContext[] createContextArray() {\n        Collection<PolyglotLanguage> languages = engine.idToLanguage.values();\n        PolyglotLanguageContext[] newContexts = new PolyglotLanguageContext[engine.languageCount];\n        Iterator<PolyglotLanguage> languageIterator = languages.iterator();\n        for (int i = (PolyglotEngineImpl.HOST_LANGUAGE_INDEX + 1); i < engine.languageCount; i++) {\n            PolyglotLanguage language = languageIterator.next();\n            newContexts[i] = new PolyglotLanguageContext(this, language);\n        }\n        maybeInitializeHostLanguage(newContexts);\n        return newContexts;\n    }\n\n    private void maybeInitializeHostLanguage(PolyglotLanguageContext[] contextsArray) {\n        PolyglotLanguage hostLanguage = engine.hostLanguage;\n        PolyglotLanguageContext hostContext = new PolyglotLanguageContext(this, hostLanguage);\n        contextsArray[PolyglotEngineImpl.HOST_LANGUAGE_INDEX] = hostContext;\n        if (PreInitContextHostLanguage.isInstance(hostLanguage)) {\n            // The host language in the image execution time may differ from host language in the\n            // image build time. We have to postpone the creation and initialization of the host\n            // language context until the patching.\n            assert engine.inEnginePreInitialization : \"PreInitContextHostLanguage can be used only during context pre-initialization\";\n        } else {\n            hostContext.ensureCreated(hostLanguage);\n            hostContext.ensureInitialized(null);\n        }\n    }\n\n    PolyglotLanguageContext getContext(PolyglotLanguage language) {\n        return contexts[language.engineIndex];\n    }\n\n    Object getContextImpl(PolyglotLanguage language) {\n        return contexts[language.engineIndex].getContextImpl();\n    }\n\n    PolyglotLanguageContext getContextInitialized(PolyglotLanguage language, PolyglotLanguage accessingLanguage) {\n        PolyglotLanguageContext context = getContext(language);\n        context.ensureInitialized(accessingLanguage);\n        return context;\n    }\n\n    void notifyContextCreated() {\n        EngineAccessor.INSTRUMENT.notifyContextCreated(engine, creatorTruffleContext);\n    }\n\n    void addChildContext(PolyglotContextImpl child) {\n        assert Thread.holdsLock(this);\n        assert !state.isClosed();\n        if (state.isClosing() && !state.shouldCacheThreadInfo()) {\n            throw PolyglotEngineException.illegalState(\"Adding child context into a closing context.\");\n        }\n        childContexts.add(child);\n    }\n\n    /**\n     * May be used anywhere to lookup the context.\n     *\n     * @throws IllegalStateException when there is no current context available.\n     */\n    static PolyglotContextImpl requireContext() {\n        PolyglotContextImpl context = PolyglotFastThreadLocals.getContext(null);\n        if (context == null) {\n            CompilerDirectives.transferToInterpreterAndInvalidate();\n            throw PolyglotEngineException.illegalState(\"There is no current context available.\");\n        }\n        return context;\n    }\n\n    public synchronized void explicitEnter() {\n        try {\n            Object[] prev = engine.enter(this);\n            PolyglotThreadInfo current = getCurrentThreadInfo();\n            assert current.getThread() == Thread.currentThread();\n            current.explicitContextStack.addLast(prev);\n        } catch (Throwable t) {\n            throw PolyglotImpl.guestToHostException(engine, t);\n        }\n    }\n\n    public synchronized void explicitLeave() {\n        if (state.isClosed()) {\n            /*\n             * closeImpl leaves automatically for all explicit enters on the closingThread, so\n             * nothing else needs to be done if context is already closed.\n             */\n            return;\n        }\n        try {\n            PolyglotThreadInfo current = getCurrentThreadInfo();\n            LinkedList<Object[]> stack = current.explicitContextStack;\n            if (stack.isEmpty() || current.getThread() == null) {\n                throw PolyglotEngineException.illegalState(\"The context is not entered explicity. A context can only be left if it was previously entered.\");\n            }\n            engine.leave(stack.removeLast(), this);\n        } catch (Throwable t) {\n            throw PolyglotImpl.guestToHostException(engine, t);\n        }\n    }\n\n    synchronized Future<Void> pause() {\n        PauseThreadLocalAction pauseAction = new PauseThreadLocalAction(this);\n        Future<Void> future = threadLocalActions.submit(null, PolyglotEngineImpl.ENGINE_ID, pauseAction, new HandshakeConfig(true, true, false, false));\n        pauseThreadLocalActions.add(pauseAction);\n        return new ContextPauseHandle(pauseAction, future);\n    }\n\n    void resume(Future<Void> pauseFuture) {\n        if (pauseFuture instanceof ContextPauseHandle && ((ContextPauseHandle) pauseFuture).pauseThreadLocalAction.context == this) {\n            ContextPauseHandle pauseHandle = (ContextPauseHandle) pauseFuture;\n            pauseHandle.resume();\n        } else {\n            throw new IllegalArgumentException(\"Resume method was not passed a valid pause future!\");\n        }\n    }\n\n    /**\n     * Use to enter context if it's guaranteed to be called rarely and configuration flexibility is\n     * needed. Otherwise use {@link PolyglotEngineImpl#enter(PolyglotContextImpl)}.\n     */\n    @TruffleBoundary\n    Object[] enterThreadChanged(boolean enterReverted, boolean pollSafepoint, boolean mustSucceed, boolean polyglotThreadFirstEnter,\n                    boolean leaveAndEnter) {\n        PolyglotThreadInfo enteredThread = null;\n        Object[] prev = null;\n        Thread current = Thread.currentThread();\n        if (JDKAccessor.isVirtualThread(current) && !(Truffle.getRuntime() instanceof DefaultTruffleRuntime)) {\n            throw PolyglotEngineException.illegalState(\n                            \"Using polyglot contexts on Java virtual threads is currently not supported with an optimizing Truffle runtime. \" +\n                                            \"As a workaround you may add the -Dtruffle.TruffleRuntime=com.oracle.truffle.api.impl.DefaultTruffleRuntime JVM argument to switch to a non-optimizing runtime when using virtual threads. \" +\n                                            \"Please note that performance is severly reduced in this mode. Loom support for optimizing runtimes will be added in a future release.\");\n        }\n        try {\n            boolean deactivateSafepoints = mustSucceed;\n            boolean localPollSafepoint = pollSafepoint && !mustSucceed;\n            try {\n                if (current instanceof SystemThread) {\n                    assert !mustSucceed;\n                    throw PolyglotEngineException.illegalState(\"Context cannot be entered on system threads.\");\n                }\n                if (current instanceof PolyglotThread && !((PolyglotThread) current).isEnterAllowed()) {\n                    assert !mustSucceed;\n                    throw PolyglotEngineException.illegalState(\"Context cannot be entered in polyglot thread's beforeEnter or afterLeave notifications.\");\n                }\n                boolean needsInitialization = false;\n                synchronized (this) {\n                    PolyglotThreadInfo threadInfo = getCurrentThreadInfo();\n\n                    if (enterReverted && threadInfo.getEnteredCount() == 0) {\n                        threadLocalActions.notifyThreadActivation(threadInfo, false);\n                        if ((state.isCancelling() || state.isExiting() || state == State.CLOSED_CANCELLED || state == State.CLOSED_EXITED) && !threadInfo.isActive()) {\n                            notifyThreadClosed(threadInfo);\n                        }\n                        if ((state.isInterrupting() || state == State.CLOSED_INTERRUPTED) && !threadInfo.isActive()) {\n                            Thread.interrupted();\n                            notifyAll();\n                        }\n                    }\n                    if (deactivateSafepoints && threadInfo != PolyglotThreadInfo.NULL) {\n                        threadLocalActions.notifyThreadActivation(threadInfo, false);\n                    }\n\n                    assert threadInfo != null;\n                    if (!leaveAndEnter) {\n                        checkClosedOrDisposing(mustSucceed);\n                        if (threadInfo.isInLeaveAndEnter()) {\n                            throw PolyglotEngineException.illegalState(\"Context cannot be entered inside leaveAndEnter.\");\n                        }\n                    }\n\n                    threadInfo = threads.get(current);\n                    if (threadInfo == null) {\n                        threadInfo = createThreadInfo(current, polyglotThreadFirstEnter);\n                        needsInitialization = true;\n                    }\n                    if (singleThreaded) {\n                        /*\n                         * If this is the only thread, then setting the cached thread info to NULL\n                         * is no performance problem. If there is other thread that is just about to\n                         * enter, we are making sure that it initializes multi-threading if this\n                         * thread doesn't do it.\n                         */\n                        setCachedThreadInfo(PolyglotThreadInfo.NULL);\n                    }\n                    boolean transitionToMultiThreading = isSingleThreaded() && hasActiveOtherThread(true, false);\n\n                    if (transitionToMultiThreading) {\n                        // recheck all thread accesses\n                        checkAllThreadAccesses(Thread.currentThread(), false);\n                    }\n\n                    if (transitionToMultiThreading) {\n                        /*\n                         * We need to do this early (before initializeMultiThreading) as entering or\n                         * local initialization depends on single thread per context.\n                         */\n                        engine.singleThreadPerContext.invalidate();\n                        singleThreaded = false;\n                    }\n\n                    if (needsInitialization) {\n                        threads.put(current, threadInfo);\n                    }\n\n                    if (needsInitialization) {\n                        /*\n                         * Do not enter the thread before initializing thread locals. Creation of\n                         * thread locals might fail.\n                         */\n                        initializeThreadLocals(threadInfo);\n                    }\n\n                    prev = threadInfo.enterInternal();\n                    if (leaveAndEnter) {\n                        threadInfo.setLeaveAndEnterInterrupter(null);\n                        notifyAll();\n                    }\n                    if (needsInitialization) {\n                        this.threadLocalActions.notifyEnterCreatedThread();\n                    }\n                    if (closingThread != Thread.currentThread()) {\n                        try {\n                            threadInfo.notifyEnter(engine, this);\n                        } catch (Throwable t) {\n                            threadInfo.leaveInternal(prev);\n                            throw t;\n                        }\n                    }\n                    enteredThread = threadInfo;\n\n                    // new thread became active so we need to check potential active thread local\n                    // actions and process them.\n                    Set<ThreadLocalAction> activatedActions = null;\n                    if (enteredThread.getEnteredCount() == 1 && !deactivateSafepoints) {\n                        activatedActions = threadLocalActions.notifyThreadActivation(threadInfo, true);\n                    }\n\n                    if (transitionToMultiThreading) {\n                        // we need to verify that all languages give access\n                        // to all threads in multi-threaded mode.\n                        transitionToMultiThreaded(mustSucceed);\n                    }\n\n                    if (needsInitialization) {\n                        initializeNewThread(enteredThread, mustSucceed);\n                    }\n\n                    if (enteredThread.getEnteredCount() == 1 && !pauseThreadLocalActions.isEmpty()) {\n                        for (Iterator<PauseThreadLocalAction> threadLocalActionIterator = pauseThreadLocalActions.iterator(); threadLocalActionIterator.hasNext();) {\n                            PauseThreadLocalAction threadLocalAction = threadLocalActionIterator.next();\n                            if (!threadLocalAction.isPause()) {\n                                threadLocalActionIterator.remove();\n                            } else {\n                                if (activatedActions == null || !activatedActions.contains(threadLocalAction)) {\n                                    threadLocalActions.submit(new Thread[]{Thread.currentThread()}, PolyglotEngineImpl.ENGINE_ID, threadLocalAction, new HandshakeConfig(true, true, false, false));\n                                }\n                            }\n                        }\n                    }\n\n                    // never cache last thread on close or when closingThread\n                    setCachedThreadInfo(threadInfo);\n                }\n\n                if (needsInitialization) {\n                    EngineAccessor.INSTRUMENT.notifyThreadStarted(engine, creatorTruffleContext, current);\n                }\n\n                return prev;\n            } finally {\n                /*\n                 * We need to always poll the safepoint here in case we already submitted a thread\n                 * local action for this thread. Not polling here would make dependencies of that\n                 * event wait forever.\n                 */\n                if (localPollSafepoint) {\n                    TruffleSafepoint.pollHere(this.uncachedLocation);\n                }\n            }\n        } catch (Throwable t) {\n            /*\n             * Just in case the enter fails when already entered, we need to leave the context again\n             * unless we are inside leaveAndEnter which should be followed by leave in a finally\n             * block.\n             */\n            if (enteredThread != null && !leaveAndEnter) {\n                this.leaveThreadChanged(prev, true, polyglotThreadFirstEnter);\n            }\n            throw t;\n        }\n    }\n\n    PolyglotThreadInfo getCachedThread() {\n        PolyglotThreadInfo info;\n        if (CompilerDirectives.inCompiledCode() && CompilerDirectives.isPartialEvaluationConstant(this)) {\n            info = singleThreadValue.getConstant();\n            if (info == null) {\n                // this branch folds away if the thread info can be resolved as a constant\n                info = cachedThreadInfo;\n            }\n        } else {\n            info = cachedThreadInfo;\n        }\n        return info;\n    }\n\n    PolyglotThreadInfo getCurrentThreadInfo() {\n        CompilerAsserts.neverPartOfCompilation();\n        assert Thread.holdsLock(this);\n        PolyglotThreadInfo info = getCachedThread();\n        if (info.getThread() != Thread.currentThread()) {\n            info = threads.get(Thread.currentThread());\n            if (info == null) {\n                // closingThread from a thread we have never seen.\n                info = PolyglotThreadInfo.NULL;\n            }\n        }\n        assert info.getThread() == null || info.getThread() == Thread.currentThread();\n        return info;\n    }\n\n    void setCachedThreadInfo(PolyglotThreadInfo info) {\n        if (!shouldCacheThreadInfo() || threadLocalActions.hasActiveEvents()) {\n            // never set the cached thread when closed closing or invalid\n            cachedThreadInfo = PolyglotThreadInfo.NULL;\n        } else {\n            cachedThreadInfo = info;\n        }\n    }\n\n    synchronized void checkMultiThreadedAccess(PolyglotThread newThread) {\n        boolean singleThread = singleThreaded ? !isActiveNotCancelled() : false;\n        checkAllThreadAccesses(newThread, singleThread);\n    }\n\n    private void checkAllThreadAccesses(Thread enteringThread, boolean singleThread) {\n        assert Thread.holdsLock(this);\n        List<PolyglotLanguage> deniedLanguages = null;\n        for (PolyglotLanguageContext context : contexts) {\n            if (!context.isInitialized()) {\n                continue;\n            }\n            boolean accessAllowed = true;\n            if (!LANGUAGE.isThreadAccessAllowed(context.env, enteringThread, singleThread)) {\n                accessAllowed = false;\n            }\n            if (accessAllowed) {\n                for (PolyglotThreadInfo seenThread : threads.values()) {\n                    if (!LANGUAGE.isThreadAccessAllowed(context.env, seenThread.getThread(), singleThread)) {\n                        accessAllowed = false;\n                        break;\n                    }\n                }\n            }\n            if (!accessAllowed) {\n                if (deniedLanguages == null) {\n                    deniedLanguages = new ArrayList<>();\n                }\n                deniedLanguages.add(context.language);\n            }\n        }\n        if (deniedLanguages != null) {\n            throw throwDeniedThreadAccess(enteringThread, singleThread, deniedLanguages);\n        }\n    }\n\n    @SuppressWarnings(\"CatchMayIgnoreException\")\n    public <T, R> R leaveAndEnter(TruffleSafepoint.Interrupter interrupter, TruffleSafepoint.InterruptibleFunction<T, R> interruptible, T object, boolean mustSucceed) {\n        Objects.requireNonNull(interrupter);\n        Objects.requireNonNull(interruptible);\n\n        if (!mustSucceed) {\n            TruffleSafepoint.pollHere(uncachedLocation);\n        }\n\n        PolyglotThreadInfo currentThreadInfo;\n        synchronized (this) {\n            currentThreadInfo = getCurrentThreadInfo();\n            if (currentThreadInfo.getEnteredCount() != 1) {\n                throw PolyglotEngineException.illegalState(\"Context is entered \" + currentThreadInfo.getEnteredCount() + \" times. It must be entered exactly once for leaveAndEnter.\");\n            }\n            leaveThreadChanged(null, true, false);\n            currentThreadInfo.setLeaveAndEnterInterrupter(interrupter);\n            setCachedThreadInfo(PolyglotThreadInfo.NULL);\n        }\n        try {\n            return interruptible.apply(object);\n        } catch (InterruptedException e) {\n        } finally {\n            if (currentThreadInfo.leaveAndEnterInterrupted) {\n                interrupter.resetInterrupted();\n                currentThreadInfo.leaveAndEnterInterrupted = false;\n            }\n            enterThreadChanged(false, true, mustSucceed, false, true);\n            synchronized (this) {\n                if (state.isCancelled()) {\n                    assert invalidMessage != null;\n                    /*\n                     * Cancellation thread local action needs to be submitted here in case the\n                     * context is cancelling, exiting, cancelled or exited, because we just entered\n                     * the context in a thread which may have been excluded from cancellation while\n                     * the context was not entered.\n                     */\n                    threadLocalActions.submit(new Thread[]{Thread.currentThread()}, PolyglotEngineImpl.ENGINE_ID, new CancellationThreadLocalAction(), true);\n                } else if (state.isInterrupting()) {\n                    threadLocalActions.submit(new Thread[]{Thread.currentThread()}, PolyglotEngineImpl.ENGINE_ID, new InterruptThreadLocalAction(), true);\n                }\n            }\n            if (!mustSucceed) {\n                TruffleSafepoint.pollHere(uncachedLocation);\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Use to leave a context if its guaranteed to be called rarely and configuration flexibility is\n     * needed. Otherwise use {@link PolyglotEngineImpl#leave(Object[], PolyglotContextImpl)}.\n     */\n    @TruffleBoundary\n    void leaveThreadChanged(Object[] prev, boolean entered, boolean finalizeAndDispose) {\n        PolyglotThreadInfo threadInfo;\n        Throwable ex = null;\n        Thread current = Thread.currentThread();\n        if (current instanceof PolyglotThread && !((PolyglotThread) current).isEnterAllowed()) {\n            throw PolyglotEngineException.illegalState(\"Context cannot be left in polyglot thread's beforeEnter or afterLeave notifications.\");\n        }\n        synchronized (this) {\n            threadInfo = threads.get(current);\n            assert threadInfo != null : \"thread must not be disposed\";\n        }\n        if (finalizeAndDispose) {\n            /*\n             * Thread finalization notification is invoked outside of the context lock so that the\n             * guest languages can operate freely without the risk of a deadlock.\n             */\n            ex = notifyThreadFinalizing(threadInfo, null, false);\n        }\n        synchronized (this) {\n            if (finalizeAndDispose) {\n                ex = notifyThreadDisposing(threadInfo, ex);\n            }\n\n            setCachedThreadInfo(PolyglotThreadInfo.NULL);\n\n            if (entered) {\n                try {\n                    if (closingThread != Thread.currentThread()) {\n                        threadInfo.notifyLeave(engine, this);\n                    }\n                } finally {\n                    threadInfo.leaveInternal(prev);\n                }\n            }\n            if (threadInfo.getEnteredCount() == 0) {\n                threadLocalActions.notifyThreadActivation(threadInfo, false);\n            }\n\n            if ((state.isCancelling() || state.isExiting() || state == State.CLOSED_CANCELLED || state == State.CLOSED_EXITED) && !threadInfo.isActive()) {\n                notifyThreadClosed(threadInfo);\n            }\n\n            boolean somePauseThreadLocalActionIsActive = false;\n            if (threadInfo.getEnteredCount() == 0 && !pauseThreadLocalActions.isEmpty()) {\n                for (Iterator<PauseThreadLocalAction> threadLocalActionIterator = pauseThreadLocalActions.iterator(); threadLocalActionIterator.hasNext();) {\n                    PauseThreadLocalAction threadLocalAction = threadLocalActionIterator.next();\n                    if (!threadLocalAction.isPause()) {\n                        threadLocalActionIterator.remove();\n                    } else {\n                        somePauseThreadLocalActionIsActive = true;\n                    }\n                }\n            }\n\n            if (entered && !somePauseThreadLocalActionIsActive) {\n                /*\n                 * Must not cache thread info when this synchronized leave was called as a slow-path\n                 * fallback (entered == false). The slow-path fallback does not perform enteredCount\n                 * decrement and so other threads may see this thread as already left before the\n                 * synchronized block is entered. If we cached the thread info in this case, then a\n                 * subsequent fast-path enter would not perform operations that might be necessary,\n                 * e.g. initialize multithreading.\n                 */\n                setCachedThreadInfo(threadInfo);\n            }\n\n            if ((state.isInterrupting() || state == State.CLOSED_INTERRUPTED) && !threadInfo.isActive()) {\n                Thread.interrupted();\n                notifyAll();\n            }\n\n            if (finalizeAndDispose) {\n                finishThreadDispose(current, threadInfo, ex);\n            }\n        }\n    }\n\n    private void finishThreadDispose(Thread current, PolyglotThreadInfo info, Throwable ex) {\n        assert !info.isActive();\n\n        if (cachedThreadInfo.getThread() == current) {\n            setCachedThreadInfo(PolyglotThreadInfo.NULL);\n        }\n        info.setContextThreadLocals(DISPOSED_CONTEXT_THREAD_LOCALS);\n        threads.remove(current);\n\n        if (ex != null) {\n            throw sneakyThrow(ex);\n        }\n    }\n\n    private Throwable notifyThreadFinalizing(PolyglotThreadInfo threadInfo, Throwable previousEx, boolean mustSucceed) {\n        Throwable ex = previousEx;\n        Thread thread = threadInfo.getThread();\n        if (thread == null) {\n            // thread was already collected\n            return ex;\n        }\n\n        BitSet finalizedContexts = new BitSet(contexts.length);\n        while (true) {\n            for (PolyglotLanguageContext languageContext : contexts) {\n                /*\n                 * New contexts might be initialized while we are finalizing threads. The\n                 * initialization of a new context can happen both on this thread and some other\n                 * thread. The initialization of a new context on other thread also executes\n                 * initializeThread for this thread as long as this thread is in\n                 * PolyglotContextImpl's seen threads. For embedder threads, the thread finalization\n                 * happens after the context is finalized. For polyglot threads it can be before the\n                 * context finalization or during. We must keep the initializeThread,\n                 * finalizeThread, disposeThread order for each thread. For polyglot threads all\n                 * those three are executed on the appropriate thread, except for lazily initialized\n                 * contexts which execute initializeThread for all seen threads from the point of\n                 * context initialization. Therefore:\n                 *\n                 * 1) We cannot initialize this thread for new lazily initialized context when this\n                 * finalization loop is completed => we set threadInfo#finalizationComplete to true\n                 * and never call initializeThread for this thread anymore.\n                 *\n                 * 2) We must not call finalizeThread and disposeThread for a context for which\n                 * initializeThread was not called => we call finalizeThread only for those contexts\n                 * which have their bit in threadInfo#initializedLanguageContexts set.\n                 */\n                if (!finalizedContexts.get(languageContext.language.engineIndex)) {\n                    boolean contextInitialized;\n                    synchronized (this) {\n                        contextInitialized = languageContext.isInitialized() && threadInfo.isLanguageContextInitialized(languageContext.language);\n                    }\n                    if (contextInitialized) {\n                        try {\n                            finalizedContexts.set(languageContext.language.engineIndex);\n                            LANGUAGE.finalizeThread(languageContext.env, thread);\n                        } catch (Throwable t) {\n                            if (ex == null) {\n                                ex = t;\n                            } else {\n                                ex.addSuppressed(t);\n                            }\n                        }\n                    }\n                }\n            }\n            synchronized (this) {\n                if (finalizedContexts.cardinality() == threadInfo.initializedLanguageContextsCount()) {\n                    threadInfo.setFinalizationComplete(engine, mustSucceed);\n                    break;\n                }\n            }\n        }\n\n        return ex;\n    }\n\n    private Throwable notifyThreadDisposing(PolyglotThreadInfo threadInfo, Throwable previousEx) {\n        Throwable ex = previousEx;\n        Thread thread = threadInfo.getThread();\n        if (thread == null) {\n            // thread was already collected\n            return ex;\n        }\n\n        for (PolyglotLanguageContext languageContext : contexts) {\n            if (languageContext.isInitialized() && threadInfo.isLanguageContextInitialized(languageContext.language)) {\n                try {\n                    LANGUAGE.disposeThread(languageContext.env, thread);\n                } catch (Throwable t) {\n                    if (ex == null) {\n                        ex = t;\n                    } else {\n                        ex.addSuppressed(t);\n                    }\n                }\n            }\n        }\n\n        try {\n            EngineAccessor.INSTRUMENT.notifyThreadFinished(engine, creatorTruffleContext, thread);\n        } catch (Throwable t) {\n            if (ex == null) {\n                ex = t;\n            } else {\n                ex.addSuppressed(t);\n            }\n        }\n\n        return ex;\n    }\n\n    /*\n     * When a context is being cancelled or hard-exited, certain exceptions are suppressed and just\n     * logged in certain situations in order not to interfere with the cancelling process, but those\n     * for which this method returns true are always thrown.\n     */\n    static boolean isInternalError(Throwable t) {\n        return !(t instanceof AbstractTruffleException) && !(t instanceof PolyglotEngineImpl.CancelExecution) && !(t instanceof PolyglotContextImpl.ExitException);\n    }\n\n    private void initializeNewThread(PolyglotThreadInfo threadInfo, boolean mustSucceed) {\n        for (PolyglotLanguageContext context : contexts) {\n            if (context.isInitialized()) {\n                try {\n                    threadInfo.initializeLanguageContext(context);\n                } catch (Throwable t) {\n                    if (!mustSucceed || isInternalError(t)) {\n                        throw t;\n                    } else {\n                        /*\n                         * initializeThread may execute thread local actions, and so truffle and\n                         * cancel exceptions are expected. However, they must not fail the cancel\n                         * operation, and so we just log them.\n                         */\n                        assert state.isClosing();\n                        assert state.isInvalidOrClosed();\n                        engine.getEngineLogger().log(Level.FINE,\n                                        \"Exception was thrown while initializing new thread for a polyglot context that is being cancelled or exited. Such exceptions are expected during cancelling or exiting.\",\n                                        t);\n                    }\n                }\n            }\n        }\n    }\n\n    private void transitionToMultiThreaded(boolean mustSucceed) {\n        assert Thread.holdsLock(this);\n\n        for (PolyglotLanguageContext context : contexts) {\n            if (context.isInitialized()) {\n                context.ensureMultiThreadingInitialized(mustSucceed);\n            }\n        }\n        singleThreaded = false;\n        singleThreadValue.invalidate();\n\n        long statementsExecuted = statementLimit - statementCounter;\n        volatileStatementCounter.getAndAdd(-statementsExecuted);\n    }\n\n    private PolyglotThreadInfo createThreadInfo(Thread current, boolean polyglotThreadFirstEnter) {\n        assert Thread.holdsLock(this);\n        PolyglotThreadInfo threadInfo = new PolyglotThreadInfo(this, current, polyglotThreadFirstEnter);\n\n        boolean singleThread = isSingleThreaded();\n        List<PolyglotLanguage> deniedLanguages = null;\n        for (PolyglotLanguageContext context : contexts) {\n            if (context.isInitialized()) {\n                if (!EngineAccessor.LANGUAGE.isThreadAccessAllowed(context.env, current, singleThread)) {\n                    if (deniedLanguages == null) {\n                        deniedLanguages = new ArrayList<>();\n                    }\n                    deniedLanguages.add(context.language);\n                }\n            }\n        }\n\n        if (deniedLanguages != null) {\n            throw throwDeniedThreadAccess(current, singleThread, deniedLanguages);\n        }\n        singleThreadValue.update(threadInfo);\n\n        return threadInfo;\n    }\n\n    static RuntimeException throwDeniedThreadAccess(Thread current, boolean accessSingleThreaded, List<PolyglotLanguage> deniedLanguages) {\n        String message;\n        StringBuilder languagesString = new StringBuilder(\"\");\n        for (PolyglotLanguage language : deniedLanguages) {\n            if (languagesString.length() != 0) {\n                languagesString.append(\", \");\n            }\n            languagesString.append(language.getId());\n        }\n        if (accessSingleThreaded) {\n            message = String.format(\"Single threaded access requested by thread %s but is not allowed for language(s) %s.\", current, languagesString);\n        } else {\n            message = String.format(\"Multi threaded access requested by thread %s but is not allowed for language(s) %s.\", current, languagesString);\n        }\n        throw PolyglotEngineException.illegalState(message);\n    }\n\n    public Object getBindings(String languageId) {\n        PolyglotLanguageContext languageContext = lookupLanguageContext(languageId);\n        assert languageContext != null;\n        Object prev = hostEnter(languageContext);\n        try {\n            if (!languageContext.isInitialized()) {\n                languageContext.ensureInitialized(null);\n            }\n            return languageContext.getHostBindings();\n        } catch (Throwable e) {\n            throw PolyglotImpl.guestToHostException(languageContext, e, true);\n        } finally {\n            hostLeave(languageContext, prev);\n        }\n    }\n\n    public Object getPolyglotBindings() {\n        try {\n            checkClosed();\n            Object bindings = this.polyglotHostBindings;\n            if (bindings == null) {\n                initPolyglotBindings();\n                bindings = this.polyglotHostBindings;\n            }\n            return bindings;\n        } catch (Throwable e) {\n            throw PolyglotImpl.guestToHostException(engine, e);\n        }\n    }\n\n    public Map<String, Object> getPolyglotGuestBindings() {\n        Map<String, Object> bindings = this.polyglotBindings;\n        if (bindings == null) {\n            initPolyglotBindings();\n            bindings = this.polyglotBindings;\n        }\n        return bindings;\n    }\n\n    private void initPolyglotBindings() {\n        synchronized (this) {\n            if (this.polyglotBindings == null) {\n                this.polyglotBindings = new ConcurrentHashMap<>();\n                PolyglotLanguageContext hostContext = getHostContext();\n                PolyglotBindings bindings = new PolyglotBindings(hostContext);\n                this.polyglotHostBindings = getAPIAccess().newValue(new PolyglotBindingsValue(hostContext, bindings), hostContext, bindings);\n            }\n        }\n    }\n\n    public Object getPolyglotBindingsObject() {\n        return polyglotBindingsObject;\n    }\n\n    void checkClosedOrDisposing(boolean mustSucceed) {\n        assert !mustSucceed || (closingThread == Thread.currentThread() && !state.isClosed() && !disposing);\n        checkCancelledNotClosing();\n        if (state.isClosed() || disposing) {\n            throw PolyglotEngineException.closedException(\"The Context is already closed.\");\n        }\n    }\n\n    void checkClosed() {\n        checkCancelledNotClosing();\n        if (state.isClosed()) {\n            throw PolyglotEngineException.closedException(\"The Context is already closed.\");\n        }\n    }\n\n    private void checkCancelledNotClosing() {\n        if (closingThread != Thread.currentThread()) {\n            checkCancelled();\n        }\n    }\n\n    private void checkCancelled() {\n        if (state.isCancelled()) {\n            assert invalidMessage != null;\n            /*\n             * If invalidMessage == null, then invalid flag was set by close.\n             */\n            if (exitMessage == null) {\n                throw createCancelException(null);\n            } else {\n                throw createExitException(null);\n            }\n        }\n    }\n\n    @TruffleBoundary\n    private RuntimeException failValueSharing() {\n        throw new ValueMigrationException(\"A value was tried to be migrated from one context to a different context. \" +\n                        \"Value migration for the current context was disabled and is therefore disallowed.\", this.uncachedLocation);\n    }\n\n    Object migrateValue(Object value, PolyglotContextImpl valueContext) {\n        if (!config.allowValueSharing) {\n            throw failValueSharing();\n        }\n        Object result = engine.host.migrateValue(this, value, valueContext);\n        if (result != null) {\n            // host made sure migration is fine\n            return result;\n        }\n        // guaranteed by migrateValue\n        assert value instanceof TruffleObject;\n        if (value instanceof OtherContextGuestObject) {\n            OtherContextGuestObject otherValue = (OtherContextGuestObject) value;\n            if (otherValue.receiverContext == this && otherValue.delegateContext == valueContext) {\n                // reuse wrapper it is already wrapped\n                return otherValue;\n            } else if (otherValue.receiverContext == valueContext && otherValue.delegateContext == this) {\n                // unpack foreign value it belongs to that context\n                return otherValue.delegate;\n            } else {\n                return new OtherContextGuestObject(this, otherValue.delegate, valueContext);\n            }\n        }\n        assert value instanceof TruffleObject;\n        return new OtherContextGuestObject(this, value, valueContext);\n    }\n\n    Object migrateHostWrapper(PolyglotWrapper wrapper) {\n        Object wrapped = wrapper.getGuestObject();\n        PolyglotContextImpl valueContext = wrapper.getContext();\n        if (valueContext != this) {\n            // migrate wrapped value to the context\n            wrapped = migrateValue(wrapped, valueContext);\n        }\n        return wrapped;\n    }\n\n    PolyglotLanguageContext getHostContext() {\n        return contexts[PolyglotEngineImpl.HOST_LANGUAGE_INDEX];\n    }\n\n    Object getHostContextImpl() {\n        return hostContextImpl;\n    }\n\n    @Override\n    public PolyglotEngineImpl getEngine() {\n        return engine;\n    }\n\n    @Override\n    public APIAccess getAPIAccess() {\n        return engine.apiAccess;\n    }\n\n    @Override\n    public PolyglotImpl getImpl() {\n        return engine.impl;\n    }\n\n    /*\n     * Special version for getLanguageContext for the fast-path.\n     */\n    PolyglotLanguageContext getLanguageContext(Class<? extends TruffleLanguage<?>> languageClass) {\n        if (CompilerDirectives.isPartialEvaluationConstant(this)) {\n            return getLanguageContextImpl(languageClass);\n        } else {\n            return getLanguageContextBoundary(languageClass);\n        }\n    }\n\n    @TruffleBoundary\n    private PolyglotLanguageContext getLanguageContextBoundary(Class<? extends TruffleLanguage<?>> languageClass) {\n        return getLanguageContextImpl(languageClass);\n    }\n\n    @SuppressWarnings(\"rawtypes\")\n    PolyglotLanguageContext findLanguageContext(Class<? extends TruffleLanguage> languageClazz) {\n        PolyglotLanguage directLanguage = engine.getLanguage(languageClazz, false);\n        if (directLanguage != null) {\n            return getContext(directLanguage);\n        }\n\n        // slow language lookup - for compatibility\n        for (PolyglotLanguageContext lang : contexts) {\n            if (lang.isInitialized()) {\n                TruffleLanguage<?> language = EngineAccessor.LANGUAGE.getLanguage(lang.env);\n                if (languageClazz != TruffleLanguage.class && languageClazz.isInstance(language)) {\n                    return lang;\n                }\n            }\n        }\n        Set<String> languageNames = new HashSet<>();\n        for (PolyglotLanguageContext lang : contexts) {\n            if (lang.isInitialized()) {\n                languageNames.add(lang.language.cache.getClassName());\n            }\n        }\n        throw PolyglotEngineException.illegalState(\"Cannot find language \" + languageClazz + \" among \" + languageNames);\n\n    }\n\n    private PolyglotLanguageContext getLanguageContextImpl(Class<? extends TruffleLanguage<?>> languageClass) {\n        FinalIntMap map = this.languageIndexMap;\n        int indexValue = map != null ? map.get(languageClass) : -1;\n        if (indexValue == -1) {\n            CompilerDirectives.transferToInterpreterAndInvalidate();\n            synchronized (this) {\n                if (this.languageIndexMap == null) {\n                    this.languageIndexMap = new FinalIntMap();\n                }\n                indexValue = languageIndexMap.get(languageClass);\n                if (indexValue == -1) {\n                    PolyglotLanguageContext context = findLanguageContext(languageClass);\n                    indexValue = context.language.engineIndex;\n                    this.languageIndexMap.put(languageClass, indexValue);\n                }\n            }\n        }\n        PolyglotLanguageContext context = contexts[indexValue];\n        return context;\n    }\n\n    void initializeInnerContextLanguage(String languageId) {\n        PolyglotLanguage language = engine.idToLanguage.get(languageId);\n        assert language != null : \"language creating the inner context not be found\";\n        Object prev = engine.enterIfNeeded(this, true);\n        try {\n            initializeLanguage(language);\n        } finally {\n            engine.leaveIfNeeded(prev, this);\n        }\n    }\n\n    private boolean initializeLanguage(PolyglotLanguage language) {\n        PolyglotLanguageContext languageContext = getContext(language);\n        assert languageContext != null;\n        languageContext.checkAccess(null);\n        if (!languageContext.isInitialized()) {\n            return languageContext.ensureInitialized(null);\n        }\n        return false;\n    }\n\n    public boolean initializeLanguage(String languageId) {\n        PolyglotLanguageContext languageContext = lookupLanguageContext(languageId);\n        Object prev = hostEnter(languageContext);\n        try {\n            return initializeLanguage(languageContext.language);\n        } catch (Throwable t) {\n            throw PolyglotImpl.guestToHostException(languageContext, t, true);\n        } finally {\n            hostLeave(languageContext, prev);\n        }\n    }\n\n    public Object parse(String languageId, Object source) {\n        PolyglotLanguageContext languageContext = lookupLanguageContext(languageId);\n        assert languageContext != null;\n        Object prev = hostEnter(languageContext);\n        try {\n            Source truffleSource = (Source) getAPIAccess().getSourceReceiver(source);\n            languageContext.checkAccess(null);\n            languageContext.ensureInitialized(null);\n            CallTarget target = languageContext.parseCached(null, truffleSource, null);\n            return languageContext.asValue(new PolyglotParsedEval(languageContext, truffleSource, target));\n        } catch (Throwable e) {\n            throw PolyglotImpl.guestToHostException(languageContext, e, true);\n        } finally {\n            hostLeave(languageContext, prev);\n        }\n    }\n\n    private PolyglotLanguageContext lookupLanguageContext(String languageId) {\n        PolyglotLanguageContext languageContext;\n        try {\n            PolyglotLanguage language = requirePublicLanguage(languageId);\n            languageContext = getContext(language);\n        } catch (Throwable e) {\n            throw PolyglotImpl.guestToHostException(engine, e);\n        }\n        return languageContext;\n    }\n\n    public Object eval(String languageId, Object source) {\n        PolyglotLanguageContext languageContext = lookupLanguageContext(languageId);\n        assert languageContext != null;\n        Object prev = hostEnter(languageContext);\n        try {\n            Source truffleSource = (Source) getAPIAccess().getSourceReceiver(source);\n            languageContext.checkAccess(null);\n            languageContext.ensureInitialized(null);\n            CallTarget target = languageContext.parseCached(null, truffleSource, null);\n            Object result = target.call(PolyglotImpl.EMPTY_ARGS);\n            Object hostValue;\n            try {\n                hostValue = languageContext.asValue(result);\n            } catch (NullPointerException | ClassCastException e) {\n                throw new AssertionError(String.format(\"Language %s returned an invalid return value %s. Must be an interop value.\", languageId, result), e);\n            }\n            if (truffleSource.isInteractive()) {\n                printResult(languageContext, result);\n            }\n            return hostValue;\n        } catch (Throwable e) {\n            throw PolyglotImpl.guestToHostException(languageContext, e, true);\n        } finally {\n            hostLeave(languageContext, prev);\n        }\n    }\n\n    public PolyglotLanguage requirePublicLanguage(String languageId) {\n        PolyglotLanguage language = engine.idToLanguage.get(languageId);\n        if (language == null || language.cache.isInternal()) {\n            engine.requirePublicLanguage(languageId); // will trigger the error\n            assert false;\n            return null;\n        }\n        return language;\n    }\n\n    @TruffleBoundary\n    static void printResult(PolyglotLanguageContext languageContext, Object result) {\n        if (!LANGUAGE.isVisible(languageContext.env, result)) {\n            return;\n        }\n        String stringResult;\n        try {\n            stringResult = UNCACHED.asString(UNCACHED.toDisplayString(languageContext.getLanguageView(result), true));\n        } catch (UnsupportedMessageException e) {\n            throw shouldNotReachHere(e);\n        }\n        try {\n            OutputStream out = languageContext.context.config.out;\n            int lastEndPos = 0;\n            // avoid hitting the java array length limit during conversion to UTF-8 by printing in\n            // chunks\n            while (lastEndPos < stringResult.length()) {\n                int endPos = (int) Math.min(stringResult.length(), ((long) lastEndPos) + (Integer.MAX_VALUE / 4));\n                if (endPos < stringResult.length() && Character.isHighSurrogate(stringResult.charAt(endPos - 1)) && Character.isLowSurrogate(stringResult.charAt(endPos))) {\n                    // don't split in the middle of surrogate pairs\n                    endPos++;\n                }\n                out.write(stringResult.substring(lastEndPos, endPos).getBytes(StandardCharsets.UTF_8));\n                lastEndPos = endPos;\n            }\n            out.write(System.getProperty(\"line.separator\").getBytes(StandardCharsets.UTF_8));\n        } catch (IOException ioex) {\n            // out stream has problems.\n            throw new IllegalStateException(ioex);\n        }\n    }\n\n    /**\n     * Embedder close.\n     */\n    public void close(boolean cancelIfExecuting) {\n        try {\n            clearExplicitContextStack();\n\n            if (cancelIfExecuting) {\n                /*\n                 * Cancel does invalidate. We always need to invalidate before force-closing a\n                 * context that might be active in other threads.\n                 */\n                cancel(false, null);\n            } else {\n                closeAndMaybeWait(false, null);\n                checkCancelledNotClosing();\n            }\n        } catch (Throwable t) {\n            RuntimeException polyglotException = PolyglotImpl.guestToHostException(getHostContext(), t, false);\n            PolyglotExceptionImpl polyglotExceptionImpl = (PolyglotExceptionImpl) getAPIAccess().getPolyglotExceptionReceiver(polyglotException);\n\n            if (!cancelIfExecuting && state.isInvalidOrClosed() && (polyglotExceptionImpl.isCancelled() || polyglotExceptionImpl.isExit())) {\n                try {\n                    /*\n                     * The close operation was interrupted by cancelling or exiting, we are now in\n                     * an invalid state. By executing the close operation again, we make sure that\n                     * the close operation is fully completed when we return.\n                     */\n                    closeAndMaybeWait(false, null);\n                } catch (Throwable closeFinishError) {\n                    /*\n                     * Close operation started when the context is already invalid should complete\n                     * without an error. This exception indicates a bug, most probably in the\n                     * language implementation.\n                     */\n                    RuntimeException closeFinishPolyglotException = PolyglotImpl.guestToHostException(getHostContext(), t, false);\n                    polyglotException.addSuppressed(closeFinishPolyglotException);\n                }\n            }\n            throw polyglotException;\n        }\n    }\n\n    void cancel(boolean resourceLimit, String message) {\n        String cancelMessage = message == null ? \"Context execution was cancelled.\" : message;\n        if (parent == null) {\n            engine.polyglotHostService.notifyContextCancellingOrExiting(this, false, 0, resourceLimit, cancelMessage);\n        }\n        List<Future<Void>> futures = setCancelling(resourceLimit, cancelMessage);\n        closeHereOrCancelInCleanupThread(futures);\n    }\n\n    void initiateCancelOrExit(boolean exit, int code, boolean resourceLimit, String message) {\n        assert parent == null;\n        initiateCancelOrExitLock.lock();\n        try {\n            List<Future<Void>> futures;\n            if (exit) {\n                futures = setExiting(null, code, message, true);\n            } else {\n                futures = setCancelling(resourceLimit, message);\n            }\n            if (!futures.isEmpty()) {\n                /*\n                 * initiateCancelOrExit keeps assigning cancellationOrExitingFutures until one of\n                 * the other setExiting or setCancelling calls takes it and from that point\n                 * cancellationOrExitingFutures == null. If the futures are empty, it means that\n                 * cancelling was not initiated by this method, because it was already initiated\n                 * before, or it is no longer possible.\n                 */\n                cancellationOrExitingFutures = futures;\n            }\n        } finally {\n            initiateCancelOrExitLock.unlock();\n        }\n    }\n\n    void closeAndMaybeWait(boolean force, List<Future<Void>> futures) {\n        if (force) {\n            PolyglotEngineImpl.cancelOrExit(this, futures);\n        } else {\n            boolean closeCompleted = closeImpl(true);\n            if (!closeCompleted) {\n                throw PolyglotEngineException.illegalState(String.format(\"The context is currently executing on another thread. \" +\n                                \"Set cancelIfExecuting to true to stop the execution on this thread.\"));\n            }\n        }\n        finishCleanup();\n        checkSubProcessFinished();\n        checkSystemThreadsFinished();\n        if (parent == null) {\n            engine.polyglotHostService.notifyContextClosed(this, force, invalidResourceLimit, invalidMessage);\n        }\n        if (engine.boundEngine && parent == null) {\n            engine.ensureClosed(force, true);\n        }\n    }\n\n    private void setState(State targetState) {\n        assert Thread.holdsLock(this);\n        assert isTransitionAllowed(state, targetState) : \"Transition from \" + state.name() + \" to \" + targetState.name() + \" not allowed!\";\n        state = targetState;\n        notifyAll();\n    }\n\n    private List<Future<Void>> setInterrupting() {\n        assert Thread.holdsLock(this);\n        State targetState;\n        List<Future<Void>> futures = new ArrayList<>();\n        if (!state.isInterrupting() && !state.isInvalidOrClosed() && state != State.PENDING_EXIT && state != State.CLOSING_PENDING_EXIT) {\n            switch (state) {\n                case CLOSING:\n                    targetState = State.CLOSING_INTERRUPTING;\n                    break;\n                case CLOSING_FINALIZING:\n                    targetState = State.CLOSING_INTERRUPTING_FINALIZING;\n                    break;\n                default:\n                    targetState = State.INTERRUPTING;\n                    break;\n            }\n            setState(targetState);\n            setCachedThreadInfo(PolyglotThreadInfo.NULL);\n            futures.add(threadLocalActions.submit(null, PolyglotEngineImpl.ENGINE_ID, new InterruptThreadLocalAction(), true));\n            maybeSendInterrupt();\n        }\n        return futures;\n    }\n\n    private void unsetInterrupting() {\n        assert Thread.holdsLock(this);\n        if (state.isInterrupting()) {\n            State targetState;\n            switch (state) {\n                case CLOSING_INTERRUPTING:\n                    targetState = State.CLOSING;\n                    break;\n                case CLOSING_INTERRUPTING_FINALIZING:\n                    targetState = State.CLOSING_FINALIZING;\n                    break;\n                default:\n                    targetState = State.DEFAULT;\n                    break;\n            }\n            setState(targetState);\n        }\n    }\n\n    private void finishInterruptForChildContexts() {\n        PolyglotContextImpl[] childContextsToInterrupt;\n        synchronized (this) {\n            unsetInterrupting();\n            childContextsToInterrupt = childContexts.toArray(new PolyglotContextImpl[childContexts.size()]);\n        }\n        for (PolyglotContextImpl childCtx : childContextsToInterrupt) {\n            childCtx.finishInterruptForChildContexts();\n        }\n    }\n\n    private List<Future<Void>> interruptChildContexts() {\n        PolyglotContextImpl[] childContextsToInterrupt = null;\n        List<Future<Void>> futures;\n        synchronized (this) {\n            futures = new ArrayList<>(setInterrupting());\n            if (!futures.isEmpty()) {\n                childContextsToInterrupt = childContexts.toArray(new PolyglotContextImpl[childContexts.size()]);\n            }\n        }\n        if (childContextsToInterrupt != null) {\n            for (PolyglotContextImpl childCtx : childContextsToInterrupt) {\n                futures.addAll(childCtx.interruptChildContexts());\n            }\n        }\n        return futures;\n    }\n\n    private void validateInterruptPrecondition(PolyglotContextImpl operationSource) {\n        PolyglotContextImpl[] childContextsToInterrupt;\n        synchronized (this) {\n            PolyglotThreadInfo info = getCurrentThreadInfo();\n            if (info != PolyglotThreadInfo.NULL && info.isActive()) {\n                throw PolyglotEngineException.illegalState(String.format(\"Cannot interrupt context from a thread where %s context is active.\", this == operationSource ? \"the\" : \"its child\"));\n            }\n            childContextsToInterrupt = childContexts.toArray(new PolyglotContextImpl[childContexts.size()]);\n        }\n        for (PolyglotContextImpl childCtx : childContextsToInterrupt) {\n            childCtx.validateInterruptPrecondition(operationSource);\n        }\n    }\n\n    public boolean interrupt(Duration timeout) {\n        try {\n            if (parent != null) {\n                throw PolyglotEngineException.illegalState(\"Cannot interrupt inner context separately.\");\n            }\n            long startMillis = System.currentTimeMillis();\n            PolyglotContextImpl[] childContextsToInterrupt = null;\n            /*\n             * Two interrupt operations cannot be simultaneously in progress in the whole context\n             * hierarchy. Inner contexts cannot use interrupt separately and outer context use\n             * exclusive lock.\n             */\n            interruptingLock.lock();\n            try {\n                validateInterruptPrecondition(this);\n                List<Future<Void>> futures;\n                synchronized (this) {\n                    if (state.isClosed()) {\n                        // already closed\n                        return true;\n                    }\n                    futures = new ArrayList<>(setInterrupting());\n                    if (!futures.isEmpty()) {\n                        childContextsToInterrupt = childContexts.toArray(new PolyglotContextImpl[childContexts.size()]);\n                    }\n                }\n\n                if (childContextsToInterrupt != null) {\n                    for (PolyglotContextImpl childCtx : childContextsToInterrupt) {\n                        futures.addAll(childCtx.interruptChildContexts());\n                    }\n                }\n\n                /*\n                 * No matter whether we successfully transitioned into one of the interrupting\n                 * states, we wait for threads to be completed (which is done as a part of the\n                 * cancel method) as the states that override interrupting states also lead to\n                 * threads being stopped. If that happens before the timeout, the interrupt is\n                 * successful.\n                 */\n                return PolyglotEngineImpl.cancelOrExitOrInterrupt(this, futures, startMillis, timeout);\n            } finally {\n                try {\n                    if (childContextsToInterrupt != null) {\n                        PolyglotContextImpl[] childContextsToFinishInterrupt;\n                        synchronized (this) {\n                            unsetInterrupting();\n                            childContextsToFinishInterrupt = childContexts.toArray(new PolyglotContextImpl[childContexts.size()]);\n                        }\n                        for (PolyglotContextImpl childCtx : childContextsToFinishInterrupt) {\n                            childCtx.finishInterruptForChildContexts();\n                        }\n                    }\n                } finally {\n                    interruptingLock.unlock();\n                }\n            }\n        } catch (Throwable thr) {\n            throw PolyglotImpl.guestToHostException(engine, thr);\n        }\n    }\n\n    public Object asValue(Object hostValue) {\n        PolyglotLanguageContext languageContext = this.getHostContext();\n        Object prev = hostEnter(languageContext);\n        try {\n            checkClosed();\n            PolyglotLanguageContext targetLanguageContext;\n            if (getAPIAccess().isValue(hostValue)) {\n                // fast path for when no context migration is necessary\n                PolyglotLanguageContext valueContext = (PolyglotLanguageContext) getAPIAccess().getValueContext(hostValue);\n                if (valueContext != null && valueContext.context == this) {\n                    return hostValue;\n                }\n                targetLanguageContext = languageContext;\n            } else if (PolyglotWrapper.isInstance(hostValue)) {\n                // host wrappers can nicely reuse the associated context\n                targetLanguageContext = PolyglotWrapper.asInstance(hostValue).getLanguageContext();\n                if (this != targetLanguageContext.context) {\n                    // this will fail later in toGuestValue when migrating\n                    // or succeed in case of host languages.\n                    targetLanguageContext = languageContext;\n                }\n            } else {\n                targetLanguageContext = languageContext;\n            }\n            return targetLanguageContext.asValue(toGuestValue(null, hostValue, true));\n        } catch (Throwable e) {\n            throw PolyglotImpl.guestToHostException(this.getHostContext(), e, true);\n        } finally {\n            hostLeave(languageContext, prev);\n        }\n    }\n\n    static PolyglotEngineImpl getConstantEngine(Node node) {\n        if (!CompilerDirectives.inCompiledCode() ||\n                        !CompilerDirectives.isPartialEvaluationConstant(node)) {\n            return null;\n        }\n        if (node == null) {\n            return null;\n        }\n        RootNode root = node.getRootNode();\n        if (root == null) {\n            return null;\n        }\n        PolyglotSharingLayer layer = (PolyglotSharingLayer) EngineAccessor.NODES.getSharingLayer(root);\n        return layer != null ? layer.engine : null;\n    }\n\n    Object toGuestValue(Node node, Object hostValue, boolean asValue) {\n        PolyglotEngineImpl localEngine = getConstantEngine(node);\n        PolyglotContextImpl localContext;\n        if (localEngine == null) {\n            localEngine = this.engine;\n            localContext = this;\n        } else {\n            // lookup context as a constant\n            localContext = localEngine.singleContextValue.getConstant();\n            if (localContext == null) {\n                // not a constant use this\n                localContext = this;\n            }\n        }\n        Object value = PolyglotHostAccess.toGuestValue(localContext, hostValue);\n        return localEngine.host.toGuestValue(localContext.getHostContextImpl(), value, asValue);\n    }\n\n    /**\n     * Wait until the condition is false.\n     */\n    @SuppressWarnings(\"CatchMayIgnoreException\")\n    void waitUntilFalse(Supplier<Boolean> condition) {\n        assert Thread.holdsLock(this);\n        while (condition.get()) {\n            try {\n                wait();\n            } catch (InterruptedException e) {\n            }\n        }\n    }\n\n    /**\n     * Wait until the condition is false and return true, or wait until timeout while the condition\n     * is true and return false.\n     */\n    @SuppressWarnings(\"CatchMayIgnoreException\")\n    boolean waitUntilFalseWithTimeout(Supplier<Boolean> condition, long startMillis, long timeoutMillis) {\n        assert Thread.holdsLock(this);\n        long timeElapsed = System.currentTimeMillis() - startMillis;\n        boolean value;\n        while ((value = condition.get()) && timeElapsed < timeoutMillis) {\n            try {\n                wait(timeoutMillis - timeElapsed);\n            } catch (InterruptedException e) {\n            }\n            timeElapsed = System.currentTimeMillis() - startMillis;\n        }\n        /*\n         * The condition supplier might be racy. E.g., for hasActiveOtherThread, one of the threads\n         * might be just about to enter via fast path and so hasActiveOtherThread might return a\n         * different result if we executed it again after the while loop. The fast-path enter might\n         * not go through in the end, especially if this is waiting for cancellation of all threads,\n         * so it is not a problem that hasActiveOtherThread is racy, but it is important that the\n         * waiting method does not return a wrong value. That is why we store the result in a\n         * boolean so that the returned value corresponds to the reason why the while loop has\n         * ended.\n         */\n        return !value;\n    }\n\n    /**\n     * Wait until the condition is false and return true, or if timeoutMillis != 0, wait until\n     * timeout while the condition is true and return false.\n     */\n    boolean waitUntilFalse(Supplier<Boolean> condition, long startMillis, long timeoutMillis) {\n        if (timeoutMillis == 0) {\n            waitUntilFalse(condition);\n            return true;\n        } else {\n            return waitUntilFalseWithTimeout(condition, startMillis, timeoutMillis);\n        }\n    }\n\n    @SuppressWarnings(\"ConstantConditions\")\n    boolean waitForAllThreads(long startMillis, long timeoutMillis) {\n        synchronized (this) {\n            if (!waitUntilFalse(() -> hasActiveOtherThread(true, false), startMillis, timeoutMillis)) {\n                return false;\n            } else {\n                PolyglotThreadInfo currentThreadInfo = getCurrentThreadInfo();\n                boolean shouldLeaveAndEnter = false;\n                /*\n                 * If enteredCount == 0, then leaveAndEnter is not needed and if enteredCount > 1,\n                 * then we can't do it, so we have to live with the fact that we might trigger\n                 * multi-threading.\n                 */\n                if (currentThreadInfo != PolyglotThreadInfo.NULL && currentThreadInfo.getEnteredCount() == 1) {\n                    for (PolyglotThreadInfo threadInfo : threads.values()) {\n                        if (!threadInfo.isCurrent() && threadInfo.isInLeaveAndEnter()) {\n                            shouldLeaveAndEnter = true;\n                            break;\n                        }\n                    }\n                }\n\n                TruffleSafepoint.InterruptibleFunction<Void, Boolean> leaveAndEnterThreadInterrupter = (x) -> {\n                    /*\n                     * Threads might be deleted from the threads map while we iterate, so we have to\n                     * store them separately.\n                     */\n                    PolyglotThreadInfo[] threadInfos = threads.values().toArray(new PolyglotThreadInfo[0]);\n                    for (PolyglotThreadInfo threadInfo : threadInfos) {\n                        if (!threadInfo.isCurrent() && threadInfo.isInLeaveAndEnter()) {\n                            threadInfo.leaveAndEnterInterrupted = true;\n                            threadInfo.getLeaveAndEnterInterrupter().interrupt(threadInfo.getThread());\n                            if (!waitUntilFalse(() -> threadInfo.isInLeaveAndEnter() || threadInfo.isActive(), startMillis, timeoutMillis)) {\n                                return false;\n                            }\n                            assert !threadInfo.isInLeaveAndEnter();\n                        }\n                    }\n\n                    return true;\n                };\n\n                if (shouldLeaveAndEnter) {\n                    if (!leaveAndEnter(DO_NOTHING_INTERRUPTER, leaveAndEnterThreadInterrupter, null, true)) {\n                        return false;\n                    }\n                } else {\n                    try {\n                        if (!leaveAndEnterThreadInterrupter.apply(null)) {\n                            return false;\n                        }\n                    } catch (InterruptedException ie) {\n                        assert false;\n                    }\n                }\n\n                return waitUntilFalse(() -> hasActiveOtherThread(false, true) || hasAliveOtherPolyglotThread(), startMillis, timeoutMillis);\n            }\n        }\n    }\n\n    boolean isSingleThreaded() {\n        return singleThreaded;\n    }\n\n    Map<Thread, PolyglotThreadInfo> getSeenThreads() {\n        assert Thread.holdsLock(this);\n        return threads;\n    }\n\n    private boolean isActiveNotCancelled() {\n        return isActiveNotCancelled(true);\n    }\n\n    synchronized boolean isActiveNotCancelled(boolean includePolyglotThreads) {\n        for (PolyglotThreadInfo seenTinfo : threads.values()) {\n            if ((includePolyglotThreads || !seenTinfo.isPolyglotThread(this)) && seenTinfo.isActiveNotCancelled()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    synchronized boolean isActive() {\n        for (PolyglotThreadInfo seenTinfo : threads.values()) {\n            if (seenTinfo.isActive()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    synchronized boolean isActive(Thread thread) {\n        PolyglotThreadInfo info = threads.get(thread);\n        if (info == null || info == PolyglotThreadInfo.NULL) {\n            return false;\n        }\n        return info.isActive();\n    }\n\n    boolean hasActiveOtherThread(boolean includePolyglotThreads, boolean includeLeaveAndEnterThreads) {\n        assert Thread.holdsLock(this);\n        // send enters and leaves into a lock by setting the lastThread to null.\n        for (PolyglotThreadInfo otherInfo : threads.values()) {\n            if (!includePolyglotThreads && otherInfo.isPolyglotThread(this)) {\n                continue;\n            }\n            if (!otherInfo.isCurrent() && (otherInfo.isActive() || (includeLeaveAndEnterThreads && otherInfo.isInLeaveAndEnter()))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    boolean hasAliveOtherPolyglotThread() {\n        assert Thread.holdsLock(this);\n        for (PolyglotLanguageContext context : contexts) {\n            Set<PolyglotThread> contextOwnedAlivePolyglotThreads = context.getOwnedAlivePolyglotThreads();\n            if (contextOwnedAlivePolyglotThreads != null) {\n                for (Thread polyglotThread : contextOwnedAlivePolyglotThreads) {\n                    if (Thread.currentThread() != polyglotThread && polyglotThread.isAlive()) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    private void notifyThreadClosed(PolyglotThreadInfo info) {\n        assert Thread.holdsLock(this);\n        if (!info.cancelled) {\n            // clear interrupted status after closingThread\n            // needed because we interrupt when closingThread from another thread.\n            info.cancelled = true;\n            Thread.interrupted();\n        }\n        notifyAll();\n    }\n\n    long calculateHeapSize(long stopAtBytes, AtomicBoolean calculationCancelled) {\n        ObjectSizeCalculator localObjectSizeCalculator;\n        synchronized (this) {\n            localObjectSizeCalculator = objectSizeCalculator;\n            if (localObjectSizeCalculator == null) {\n                localObjectSizeCalculator = new ObjectSizeCalculator();\n                objectSizeCalculator = localObjectSizeCalculator;\n            }\n        }\n        return localObjectSizeCalculator.calculateObjectSize(getAPIAccess(), getContextHeapRoots(), stopAtBytes, calculationCancelled);\n    }\n\n    private Object[] getContextHeapRoots() {\n        List<Object> heapRoots = new ArrayList<>();\n        addRootPointersForContext(heapRoots);\n        addRootPointersForStackFrames(heapRoots);\n        return heapRoots.toArray();\n    }\n\n    private void addRootPointersForStackFrames(List<Object> heapRoots) {\n        PolyglotStackFramesRetriever.populateHeapRoots(this, heapRoots);\n    }\n\n    private void addRootPointersForContext(List<Object> heapRoots) {\n        synchronized (this) {\n            for (PolyglotLanguageContext context : contexts) {\n                if (context.isCreated()) {\n                    heapRoots.add(context.getContextImpl());\n                }\n            }\n            if (polyglotBindings != null) {\n                for (Map.Entry<String, Object> binding : polyglotBindings.entrySet()) {\n                    heapRoots.add(binding.getKey());\n                    if (binding.getValue() != null) {\n                        heapRoots.add(getAPIAccess().getValueReceiver(binding.getValue()));\n                    }\n                }\n            }\n        }\n        heapRoots.add(contextLocals);\n        PolyglotContextImpl[] childContextStartPoints;\n        synchronized (this) {\n            for (PolyglotThreadInfo info : threads.values()) {\n                heapRoots.add(info.getContextThreadLocals());\n            }\n            childContextStartPoints = childContexts.toArray(new PolyglotContextImpl[childContexts.size()]);\n        }\n        for (PolyglotContextImpl childCtx : childContextStartPoints) {\n            childCtx.addRootPointersForContext(heapRoots);\n        }\n    }\n\n    /**\n     * @return non-empty list of thread local action futures if this method sets the cancelling\n     *         state or obtains the futures from cancellationOrExitingFutures, empty list otherwise.\n     */\n    private List<Future<Void>> setCancelling(boolean resourceLimit, String message) {\n        assert message != null;\n        PolyglotContextImpl[] childContextsToCancel = null;\n        List<Future<Void>> futures = new ArrayList<>();\n        synchronized (this) {\n            if (!state.isInvalidOrClosed()) {\n                State targetState;\n                if (state.isClosing()) {\n                    targetState = State.CLOSING_CANCELLING;\n                } else {\n                    targetState = State.CANCELLING;\n                }\n                invalidResourceLimit = resourceLimit;\n                invalidMessage = message;\n                exitMessage = null;\n                setState(targetState);\n                submitCancellationThreadLocalAction(futures);\n                maybeSendInterrupt();\n                childContextsToCancel = childContexts.toArray(new PolyglotContextImpl[childContexts.size()]);\n            }\n        }\n        if (childContextsToCancel != null) {\n            assert !futures.isEmpty();\n            for (PolyglotContextImpl childCtx : childContextsToCancel) {\n                futures.addAll(childCtx.setCancelling(resourceLimit, message));\n            }\n        }\n        return getCancellingOrExitingFutures(futures);\n    }\n\n    private void submitCancellationThreadLocalAction(List<Future<Void>> futures) {\n        PolyglotThreadInfo info = getCurrentThreadInfo();\n        futures.add(threadLocalActions.submit(null, PolyglotEngineImpl.ENGINE_ID, new CancellationThreadLocalAction(), true));\n        if (info != PolyglotThreadInfo.NULL) {\n            info.cancelled = true;\n            Thread.interrupted();\n        }\n        setCachedThreadInfo(PolyglotThreadInfo.NULL);\n    }\n\n    /**\n     * @return non-empty list of thread local action futures if this method sets the exiting state\n     *         or obtains the futures from cancellationOrExitingFutures, empty list otherwise. One\n     *         exception to this rule is when config.useSystemExit == true, in that case the\n     *         returned futures are also empty as the context won't be closed in the standard way.\n     *         Instead, System.exit will be used to exit the whole VM.\n     */\n    private List<Future<Void>> setExiting(PolyglotContextImpl triggeringParent, int code, String message, boolean skipPendingExit) {\n        PolyglotContextImpl[] childContextsToCancel = null;\n        List<Future<Void>> futures = new ArrayList<>();\n        synchronized (this) {\n            if (!state.isInvalidOrClosed()) {\n                assert message != null;\n                State targetState;\n                if (state.isClosing()) {\n                    targetState = State.CLOSING_EXITING;\n                } else {\n                    targetState = State.EXITING;\n                }\n                this.skipPendingExit = skipPendingExit;\n                invalidMessage = message;\n                if (skipPendingExit) {\n                    /*\n                     * Setting the exiting state is supposed to match some other context we have no\n                     * direct reference to (e.g. isolated context) that this context is driven by.\n                     * This context is not being exited in the standard way and so it does not go\n                     * through the PENDING_EXIT state.\n                     */\n                    exitMessage = message;\n                    exitCode = code;\n                }\n                if (triggeringParent != null) {\n                    /*\n                     * triggeringParent is not null (and equal to parent) if the exit was initiated\n                     * by some ancestor of this context (not necessarily the parent) and not this\n                     * context directly. This means that the triggeringParent can be null even if\n                     * parent is not null.\n                     */\n                    exitMessage = triggeringParent.exitMessage;\n                    exitCode = triggeringParent.exitCode;\n                }\n                setState(targetState);\n                if (!config.useSystemExit) {\n                    submitCancellationThreadLocalAction(futures);\n                    maybeSendInterrupt();\n                }\n                childContextsToCancel = childContexts.toArray(new PolyglotContextImpl[childContexts.size()]);\n            }\n        }\n        if (childContextsToCancel != null) {\n            for (PolyglotContextImpl childCtx : childContextsToCancel) {\n                futures.addAll(childCtx.setExiting(this, code, message, skipPendingExit));\n            }\n        }\n        return getCancellingOrExitingFutures(futures);\n    }\n\n    private List<Future<Void>> getCancellingOrExitingFutures(List<Future<Void>> futures) {\n        List<Future<Void>> toRet = futures;\n        if (parent == null && toRet.isEmpty()) {\n            initiateCancelOrExitLock.lock();\n            try {\n                if (cancellationOrExitingFutures != null) {\n                    toRet = cancellationOrExitingFutures;\n                    cancellationOrExitingFutures = null;\n                }\n            } finally {\n                initiateCancelOrExitLock.unlock();\n            }\n        }\n        return toRet;\n    }\n\n    private void setClosingState() {\n        assert Thread.holdsLock(this);\n        closingThread = Thread.currentThread();\n        closingLock.lock();\n        State targetState;\n        switch (state) {\n            case CANCELLING:\n                targetState = State.CLOSING_CANCELLING;\n                break;\n            case INTERRUPTING:\n                targetState = State.CLOSING_INTERRUPTING;\n                break;\n            case EXITING:\n                targetState = State.CLOSING_EXITING;\n                break;\n            default:\n                targetState = State.CLOSING;\n                break;\n        }\n        setState(targetState);\n    }\n\n    private void setFinalizingState() {\n        assert Thread.holdsLock(this);\n        assert closingThread == Thread.currentThread();\n        assert closingLock.isHeldByCurrentThread();\n        State targetState;\n        switch (state) {\n            case CLOSING:\n                targetState = State.CLOSING_FINALIZING;\n                break;\n            case CLOSING_INTERRUPTING:\n                targetState = State.CLOSING_INTERRUPTING_FINALIZING;\n                break;\n            default:\n                return;\n        }\n        setState(targetState);\n    }\n\n    private void setClosedState() {\n        assert Thread.holdsLock(this);\n        assert state.isClosing() : state.name();\n        State targetState;\n        switch (state) {\n            case CLOSING_CANCELLING:\n                targetState = State.CLOSED_CANCELLED;\n                break;\n            case CLOSING_EXITING:\n                targetState = State.CLOSED_EXITED;\n                break;\n            case CLOSING_INTERRUPTING_FINALIZING:\n                targetState = State.CLOSED_INTERRUPTED;\n                break;\n            case CLOSING_FINALIZING:\n                targetState = State.CLOSED;\n                break;\n            default:\n                throw new IllegalStateException(\"Cannot close polyglot context in the current state!\");\n        }\n        setState(targetState);\n        assert state.isClosed() : state.name();\n    }\n\n    private void restoreFromClosingState(boolean cancelOperation) {\n        assert Thread.holdsLock(this);\n        assert state.isClosing() : state.name();\n        State targetState;\n        assert !cancelOperation : \"Close initiated for an invalid context must not fail!\";\n        switch (state) {\n            case CLOSING_INTERRUPTING:\n            case CLOSING_INTERRUPTING_FINALIZING:\n                targetState = State.INTERRUPTING;\n                break;\n            case CLOSING_CANCELLING:\n                targetState = State.CANCELLING;\n                break;\n            case CLOSING_PENDING_EXIT:\n                targetState = State.PENDING_EXIT;\n                break;\n            case CLOSING_EXITING:\n                targetState = State.EXITING;\n                break;\n            default:\n                targetState = State.DEFAULT;\n                break;\n        }\n        setState(targetState);\n    }\n\n    @SuppressWarnings({\"fallthrough\"})\n    @SuppressFBWarnings(\"UL_UNRELEASED_LOCK_EXCEPTION_PATH\")\n    boolean closeImpl(boolean notifyInstruments) {\n\n        /*\n         * Close operation initiated in the DEFAULT or INTERRUPTING state can fail in which case the\n         * context will go back to the corresponsing non-closing state e.g. DEFAULT ->\n         * CLOSING/CLOSING_FINALIZING -> DEFAULT. Please note that while the default/interrupting\n         * close is in progress, i.e. the context is in the CLOSING/CLOSING_FINALIZING or the\n         * CLOSING_INTERRUPTING/CLOSING_INTERRUPTING_FINALIZING state, the state can be overriden by\n         * the CLOSING_CANCELLING state. The CLOSING and CLOSING_INTERRUPTING states can also be\n         * overriden by the CLOSING_PENDING_EXIT and then the CLOSING_EXITING state. Even in these\n         * cases the default close can still fail and if that is the case the context state goes\n         * back to the CANCELLING or the EXITING state. The close operation is then guaranteed to be\n         * completed by the process that initiated cancel or exit.\n         *\n         * This block performs the following checks:\n         *\n         * 1) The close was already performed on another thread -> return true\n         *\n         * 2) The close is currently already being performed on this thread -> return true\n         *\n         * 3) The close is currently being performed on another thread -> wait for the other thread\n         * to finish closing and start checking again from check 1).\n         *\n         * 4) The close was not yet performed, cancelling or exiting is not in progress, the context\n         * is not in the PENDING_EXIT state, but other threads are still executing -> return false\n         *\n         * 5) The close was not yet performed and the context is in the PENDING_EXIT state -> wait\n         * for the context to go to an invalid state (CANCELLING, EXITING, or their closing or\n         * closed variants) and start checking from check 1).\n         *\n         * 6) The close was not yet performed and cancelling or exiting is in progress -> wait for\n         * other threads to complete and start checking again from check 1) skipping check 6) (this\n         * check) as no other threads can be executing anymore.\n         *\n         * 7) The close was not yet performed and no thread is executing -> perform close\n         */\n        boolean waitForClose = false;\n        boolean finishCancelOrExit = false;\n        boolean cancelOrExitOperation;\n        acquireClosingLock: while (true) {\n            if (waitForClose) {\n                closingLock.lock();\n                closingLock.unlock();\n                waitForClose = false;\n            }\n            synchronized (this) {\n                switch (state) {\n                    case CLOSED:\n                    case CLOSED_INTERRUPTED:\n                    case CLOSED_CANCELLED:\n                    case CLOSED_EXITED:\n                        return true;\n                    case CLOSING:\n                    case CLOSING_FINALIZING:\n                    case CLOSING_INTERRUPTING:\n                    case CLOSING_INTERRUPTING_FINALIZING:\n                    case CLOSING_CANCELLING:\n                    case CLOSING_PENDING_EXIT:\n                    case CLOSING_EXITING:\n                        assert closingThread != null;\n                        if (closingThread == Thread.currentThread()) {\n                            // currently closing recursively -> just complete\n                            return true;\n                        } else {\n                            // currently closing on another thread -> wait for other thread to\n                            // complete closing\n                            waitForClose = true;\n                            continue acquireClosingLock;\n                        }\n                    case PENDING_EXIT:\n                        waitUntilInvalid();\n                        continue acquireClosingLock;\n                    case CANCELLING:\n                    case EXITING:\n                        assert cachedThreadInfo == PolyglotThreadInfo.NULL;\n                        /*\n                         * When cancelling or exiting, we have to wait for all other threads to\n                         * complete - even for the the default close, otherwise the default close\n                         * executed prematurely as the result of leaving the context on the main\n                         * thread due to cancel exception could fail because of other threads still\n                         * being active. The correct behavior is that the normal close finishes\n                         * successfully and the cancel exception spreads further (if not caught\n                         * before close is executed).\n                         */\n                        if (!finishCancelOrExit) {\n                            waitForAllThreads(0, 0);\n                            waitForClose = true;\n                            finishCancelOrExit = true;\n                            /*\n                             * During wait this thread didn't hold the polyglot context lock, so\n                             * some other thread might have acquired closingLock in the meantime. In\n                             * that case it wouldn't be possible to acquire the closingLock by this\n                             * thread in the current synchronized block, because the thread that\n                             * holds it might need to acquire the context lock before releasing the\n                             * closingLock, but the context lock is held by this thread, and so we\n                             * have to exit the synchronized block and try again.\n                             */\n                            continue acquireClosingLock;\n                        }\n                        /*\n                         * Just continue with the close if we have already waited for threads in the\n                         * previous iteration of the main loop. We cannot wait for the close to be\n                         * completed by the thread that executes cancelling or exiting, because it\n                         * might be waiting for this thread which would lead to a deadlock. Default\n                         * close is allowed to be executed when entered. Also, this might be an\n                         * inner context, which, even if not entered, might block a parent's thread\n                         * which could be entered on the current thread.\n                         */\n                        setClosingState();\n                        cancelOrExitOperation = true;\n                        break acquireClosingLock;\n                    case INTERRUPTING:\n                    case DEFAULT:\n                        Thread current = Thread.currentThread();\n                        if (current instanceof SystemThread) {\n                            throw PolyglotEngineException.illegalState(\"Context cannot be closed normally on a system thread. The context must be cancelled or exited.\");\n                        }\n                        if (current instanceof PolyglotThread && !((PolyglotThread) current).isEnterAllowed()) {\n                            throw PolyglotEngineException.illegalState(\n                                            \"Context cannot be closed normally in polyglot thread's beforeEnter or afterLeave notifications. The context must be cancelled or exited.\");\n                        }\n\n                        if (hasActiveOtherThread(false, false)) {\n                            /*\n                             * We are not done executing, cannot close yet.\n                             */\n                            return false;\n                        }\n                        setClosingState();\n                        cancelOrExitOperation = false;\n                        break acquireClosingLock;\n                    default:\n                        assert false : state.name();\n                }\n            }\n        }\n\n        return finishClose(cancelOrExitOperation, notifyInstruments);\n    }\n\n    private void waitUntilInvalid() {\n        while (!state.isInvalidOrClosed()) {\n            try {\n                wait();\n            } catch (InterruptedException ie) {\n            }\n        }\n    }\n\n    synchronized void clearExplicitContextStack() {\n        if (parent == null) {\n            engine.polyglotHostService.notifyClearExplicitContextStack(this);\n        }\n        if (isActive(Thread.currentThread()) && !engine.getImpl().getRootImpl().isInCurrentEngineHostCallback(engine)) {\n            PolyglotThreadInfo threadInfo = getCurrentThreadInfo();\n            if (!threadInfo.explicitContextStack.isEmpty()) {\n                PolyglotContextImpl c = this;\n                while (!threadInfo.explicitContextStack.isEmpty()) {\n                    if (PolyglotFastThreadLocals.getContext(null) == this) {\n                        Object[] prev = threadInfo.explicitContextStack.removeLast();\n                        engine.leave(prev, c);\n                        c = prev != null ? (PolyglotContextImpl) prev[PolyglotFastThreadLocals.CONTEXT_INDEX] : null;\n                    } else {\n                        throw PolyglotEngineException.illegalState(\"Unable to automatically leave an explicitly entered context, some other context was entered in the meantime.\");\n                    }\n                }\n            }\n        }\n    }\n\n    private boolean finishClose(boolean cancelOrExitOperation, boolean notifyInstruments) {\n        /*\n         * If we reach here then we can continue with the close. This means that no other concurrent\n         * close is running and no other thread is currently executing. Note that only the context\n         * and closing lock should be acquired in this area to avoid deadlocks.\n         */\n        Thread[] remainingThreads = null;\n        List<PolyglotLanguageContext> disposedContexts = null;\n        boolean success = false;\n        try {\n            assert closingThread == Thread.currentThread();\n            assert closingLock.isHeldByCurrentThread() : \"lock is acquired\";\n            assert !state.isClosed();\n            Object[] prev;\n            try {\n                boolean enterMustSuceed = cancelOrExitOperation;\n                prev = this.enterThreadChanged(false, true, enterMustSuceed, false, false);\n            } catch (Throwable t) {\n                synchronized (this) {\n                    restoreFromClosingState(cancelOrExitOperation);\n                }\n                throw t;\n            }\n            if (cancelOrExitOperation) {\n                synchronized (this) {\n                    /*\n                     * Cancellation thread local action needs to be submitted here in case\n                     * finalizeContext runs guest code.\n                     */\n                    threadLocalActions.submit(new Thread[]{Thread.currentThread()}, PolyglotEngineImpl.ENGINE_ID, new CancellationThreadLocalAction(), true);\n                }\n            }\n            try {\n                if (cancelOrExitOperation) {\n                    closeChildContexts(notifyInstruments);\n                } else {\n                    exitContextNotification(TruffleLanguage.ExitMode.NATURAL, 0);\n                }\n\n                synchronized (this) {\n                    assert state != State.CLOSING_FINALIZING && state != State.CLOSING_INTERRUPTING_FINALIZING;\n                    setCachedThreadInfo(PolyglotThreadInfo.NULL);\n                    setFinalizingState();\n                    if (state == State.CLOSING_PENDING_EXIT) {\n                        /*\n                         * In case hard exit was triggered during the closing operation, we need to\n                         * wait until the hard exit notifications are finished or cancelled by\n                         * cancelling the whole context. Otherwise, we would execute the finalize\n                         * notifications prematurely.\n                         */\n                        waitUntilInvalid();\n                    }\n                }\n\n                finalizeContext(notifyInstruments, cancelOrExitOperation);\n\n                // finalization performed commit close -> no reinitialization allowed\n\n                disposedContexts = disposeContext();\n                success = true;\n            } finally {\n                synchronized (this) {\n                    /*\n                     * The assert is synchronized because all accesses to childContexts must be\n                     * synchronized. We cannot simply assert that childContexts are empty, because\n                     * removing the child context from its parent childContexts list can be done in\n                     * another thread after the assertion.\n                     */\n                    assert !success || getUnclosedChildContexts().isEmpty() : \"Polyglot context close marked as successful, but there are unclosed child contexts.\";\n                    this.leaveThreadChanged(prev, true, false);\n                    if (success) {\n                        remainingThreads = threads.keySet().toArray(new Thread[0]);\n                    }\n                    if (success) {\n                        setClosedState();\n                    } else {\n                        restoreFromClosingState(cancelOrExitOperation);\n                    }\n                    disposing = false;\n                    // triggers a thread changed event which requires slow path enter\n                    setCachedThreadInfo(PolyglotThreadInfo.NULL);\n                }\n            }\n        } finally {\n            synchronized (this) {\n                assert !state.isClosing();\n                closingThread = null;\n                closingLock.unlock();\n            }\n        }\n\n        /*\n         * No longer any lock is held. So we can acquire other locks to cleanup.\n         */\n        for (PolyglotLanguageContext context : disposedContexts) {\n            context.notifyDisposed(notifyInstruments);\n        }\n\n        if (success) {\n            try {\n                /*\n                 * We need to notify before we remove the context from engine's context list,\n                 * otherwise we couldn't use context locals in the context closed notification. New\n                 * instrument introducting new context locals doesn't initialize them in a context\n                 * if it's not in the engine's context list.\n                 */\n                if (notifyInstruments) {\n                    for (Thread thread : remainingThreads) {\n                        EngineAccessor.INSTRUMENT.notifyThreadFinished(engine, creatorTruffleContext, thread);\n                    }\n                    EngineAccessor.INSTRUMENT.notifyContextClosed(engine, creatorTruffleContext);\n                }\n            } finally {\n                if (parent != null) {\n                    synchronized (parent) {\n                        parent.childContexts.remove(this);\n                    }\n                } else if (notifyInstruments) {\n                    engine.disposeContext(this);\n                }\n            }\n            synchronized (this) {\n                // sends all threads to do slow-path enter/leave\n                setCachedThreadInfo(PolyglotThreadInfo.NULL);\n                /*\n                 * If we are closing from within an entered thread, we cannot clear locals as they\n                 * might be needed in e.g. onLeaveThread events. Moreover, closing a non-invalid\n                 * context does not prevent other threads from entering and, additionally, if the\n                 * context becomes invalid after some other thread has entered, then\n                 * PolyglotLanguageContext#dispose does not check for other entered main threads,\n                 * and so the close operation (started when the context was still non-invalid) can\n                 * proceed and reach this point. Therefore, we have to check for entered threads\n                 * here, and in case there is any, we cannot close PolyglotLanguageContexts and\n                 * clear locals.\n                 */\n                if (!isActive()) {\n                    threadLocalActions.notifyContextClosed();\n\n                    if (contexts != null) {\n                        for (PolyglotLanguageContext langContext : contexts) {\n                            langContext.close();\n                        }\n                    }\n                    if (contextLocals != null) {\n                        Arrays.fill(contextLocals, null);\n                    }\n                    for (PolyglotThreadInfo thread : threads.values()) {\n                        Object[] threadLocals = thread.getContextThreadLocals();\n                        if (threadLocals != null) {\n                            Arrays.fill(threadLocals, null);\n                        }\n                        PolyglotFastThreadLocals.cleanup(thread.fastThreadLocals);\n                    }\n                    localsCleared = true;\n                }\n            }\n            Object defaultLoggers = EngineAccessor.LANGUAGE.getDefaultLoggers();\n            Object engineLoggers = engine.getEngineLoggers();\n            Object[] loggersToRecompute = engineLoggers != null ? new Object[]{defaultLoggers, engineLoggers} : new Object[]{defaultLoggers};\n            EngineAccessor.LANGUAGE.configureLoggers(this, null, loggersToRecompute);\n            if (parent == null && this.config.logHandler != null && !PolyglotLoggers.haveSameTarget(this.config.logHandler, engine.logHandler)) {\n                this.config.logHandler.close();\n            }\n        }\n        return true;\n    }\n\n    private List<PolyglotContextImpl> getUnclosedChildContexts() {\n        assert Thread.holdsLock(this);\n        List<PolyglotContextImpl> unclosedChildContexts = new ArrayList<>();\n        for (PolyglotContextImpl childCtx : childContexts) {\n            if (!childCtx.state.isClosed()) {\n                unclosedChildContexts.add(childCtx);\n            }\n        }\n        return unclosedChildContexts;\n    }\n\n    private void closeChildContexts(boolean notifyInstruments) {\n        PolyglotContextImpl[] childrenToClose;\n        synchronized (this) {\n            childrenToClose = childContexts.toArray(new PolyglotContextImpl[childContexts.size()]);\n        }\n        for (PolyglotContextImpl childContext : childrenToClose) {\n            childContext.closeImpl(notifyInstruments);\n        }\n    }\n\n    @SuppressWarnings(\"serial\")\n    static final class ExitException extends ThreadDeath {\n        private static final long serialVersionUID = -4838571769179260137L;\n\n        private final Node location;\n        private final SourceSection sourceSection;\n        private final String exitMessage;\n        private final int exitCode;\n\n        ExitException(Node location, int exitCode, String exitMessage) {\n            this(location, null, exitCode, exitMessage);\n        }\n\n        ExitException(SourceSection sourceSection, int exitCode, String exitMessage) {\n            this(null, sourceSection, exitCode, exitMessage);\n        }\n\n        private ExitException(Node location, SourceSection sourceSection, int exitCode, String exitMessage) {\n            this.location = location;\n            this.sourceSection = sourceSection;\n            this.exitCode = exitCode;\n            this.exitMessage = exitMessage;\n        }\n\n        Node getLocation() {\n            return location;\n        }\n\n        SourceSection getSourceLocation() {\n            if (sourceSection != null) {\n                return sourceSection;\n            }\n            return location == null ? null : location.getEncapsulatingSourceSection();\n        }\n\n        @Override\n        public String getMessage() {\n            return exitMessage;\n        }\n\n        int getExitCode() {\n            return exitCode;\n        }\n    }\n\n    private boolean setPendingExit(int code) {\n        synchronized (this) {\n            State targetState;\n            switch (state) {\n                case DEFAULT:\n                case INTERRUPTING:\n                    targetState = State.PENDING_EXIT;\n                    break;\n                case CLOSING:\n                case CLOSING_INTERRUPTING:\n                    targetState = State.CLOSING_PENDING_EXIT;\n                    break;\n                default:\n                    return false;\n            }\n            exitCode = code;\n            exitMessage = \"Exit was called with exit code \" + code + \".\";\n            closeExitedTriggerThread = Thread.currentThread();\n            setState(targetState);\n            return true;\n        }\n    }\n\n    void closeExited(Node exitLocation, int code) {\n        if (setPendingExit(code)) {\n            /*\n             * If this thread set PENDING_EXIT state and ran exit notifications, it will also be the\n             * one to execute the transition to EXITING state, unless the exit notifications were\n             * cancelled by cancelling the whole context.\n             */\n            exitContextNotification(TruffleLanguage.ExitMode.HARD, code);\n            if (parent == null) {\n                engine.polyglotHostService.notifyContextCancellingOrExiting(this, true, code, false, exitMessage);\n            }\n            List<Future<Void>> futures = setExiting(null, code, exitMessage, false);\n            if (!futures.isEmpty()) {\n                closeHereOrCancelInCleanupThread(futures);\n            }\n        } else {\n            synchronized (this) {\n                if (!state.isInvalidOrClosed()) {\n                    /*\n                     * Normally, if closeExited is called more than once, the subsequent calls wait\n                     * until the context is invalid, which means that either the first call to\n                     * closeExited finished running the exit notifications and set the context state\n                     * to the (invalid) state EXITING, or the context was cancelled during the exit\n                     * notifications and it is in the (invalid) state CANCELLING. However, we cannot\n                     * wait for the invalid state when closeExited is called from an exit\n                     * notification because the invalid state is only set when exit notifications\n                     * are finished or cancelled, and so in these cases, we throw the exit exception\n                     * immediately.\n                     */\n                    PolyglotThreadInfo info = getCurrentThreadInfo();\n                    if (closeExitedTriggerThread == info.getThread() || (info.isPolyglotThread(this) && ((PolyglotThread) info.getThread()).hardExitNotificationThread)) {\n                        throw createExitException(exitLocation);\n                    }\n                }\n            }\n        }\n\n        /*\n         * It is possible that the context is not invalid, but the exit operation was not allowed,\n         * because the context is being closed in which case the state is neither invalid nor\n         * PENDING_EXIT. In this case the closeExited operation is a no-op.\n         */\n        State localState = state;\n        Node location = exitLocation != null ? exitLocation : uncachedLocation;\n        if (localState == State.PENDING_EXIT || localState == State.CLOSING_PENDING_EXIT || localState.isInvalidOrClosed()) {\n            /*\n             * Wait for the context to become invalid. If this is the first call to closeExited that\n             * ran the exit notifications and set the exiting state, then the context is already\n             * invalid, otherwise we wait here until the first call to closeExited has done its job.\n             */\n            TruffleSafepoint.setBlockedThreadInterruptible(location, new TruffleSafepoint.Interruptible<PolyglotContextImpl>() {\n                @SuppressWarnings(\"SynchronizationOnLocalVariableOrMethodParameter\")\n                @Override\n                public void apply(PolyglotContextImpl ctx) throws InterruptedException {\n                    synchronized (ctx) {\n                        while (!ctx.state.isInvalidOrClosed()) {\n                            ctx.wait();\n                        }\n                    }\n                }\n            }, this);\n\n            localState = state;\n            if (config.useSystemExit && (localState.isExiting() || localState == State.CLOSED_EXITED)) {\n                engine.host.hostExit(exitCode);\n            }\n            /*\n             * Poll will throw the correct exception. Either the ThreadDeath exit or the ThreadDeath\n             * cancel exception based on whether the exit notifications were finished and the hard\n             * exit can be completed, or the context was cancelled during exit notifications.\n             */\n            TruffleSafepoint.pollHere(location);\n        }\n    }\n\n    private void closeHereOrCancelInCleanupThread(List<Future<Void>> futures) {\n        boolean cancelInSeparateThread = false;\n        synchronized (this) {\n            PolyglotThreadInfo info = getCurrentThreadInfo();\n            Thread currentThread = Thread.currentThread();\n            if (info.isPolyglotThread(this) || (!singleThreaded && isActive(currentThread)) || closingThread == currentThread || currentThread instanceof SystemThread) {\n                /*\n                 * Polyglot thread or system thread must not cancel a context, because cancel waits\n                 * for polyglot threads and system threads to complete. Also, it is not allowed to\n                 * cancel in a thread where a multi-threaded context is entered. This would lead to\n                 * deadlock if more than one thread tried to do that as cancel waits for the context\n                 * not to be entered in all other threads.\n                 */\n                cancelInSeparateThread = true;\n            }\n        }\n        if (cancelInSeparateThread) {\n            if (!futures.isEmpty()) {\n                /*\n                 * Checking the futures for emptiness makes sure we don't register multiple cleanup\n                 * tasks if this is called from multiple threads\n                 */\n                registerCleanupTask(new Runnable() {\n                    @Override\n                    public void run() {\n                        PolyglotEngineImpl.cancelOrExit(PolyglotContextImpl.this, futures);\n                    }\n                });\n            }\n        } else {\n            closeAndMaybeWait(true, futures);\n        }\n    }\n\n    private void registerCleanupTask(Runnable cleanupTask) {\n        synchronized (this) {\n            if (!state.isClosed()) {\n                if (cleanupExecutorService == null) {\n                    cleanupExecutorService = Executors.newFixedThreadPool(1, new ThreadFactory() {\n                        @Override\n                        public Thread newThread(Runnable r) {\n                            Thread t = new Thread(r);\n                            t.setDaemon(true);\n                            return t;\n                        }\n                    });\n                }\n                assert cleanupFuture == null : \"Multiple cleanup tasks are currently not supported!\";\n                cleanupFuture = cleanupExecutorService.submit(cleanupTask);\n            }\n        }\n    }\n\n    void finishCleanup() {\n        ExecutorService localCleanupService;\n        synchronized (this) {\n            if (isActive(Thread.currentThread())) {\n                /*\n                 * The cleanup must be able to wait for the context to leave all threads which would\n                 * be impossible if it is still entered in the current thread.\n                 */\n                return;\n            }\n            localCleanupService = cleanupExecutorService;\n        }\n        if (localCleanupService != null) {\n            try {\n                try {\n                    cleanupFuture.get();\n                } catch (InterruptedException ie) {\n                    engine.getEngineLogger().log(Level.INFO, \"Waiting for polyglot context cleanup was interrupted!\", ie);\n                } catch (ExecutionException ee) {\n                    assert !(ee.getCause() instanceof AbstractTruffleException);\n                    throw sneakyThrow(ee.getCause());\n                }\n            } finally {\n                localCleanupService.shutdownNow();\n                while (!localCleanupService.isTerminated()) {\n                    try {\n                        if (!localCleanupService.awaitTermination(1, TimeUnit.MINUTES)) {\n                            throw new IllegalStateException(\"Context cleanup service timeout!\");\n                        }\n                    } catch (InterruptedException ie) {\n                        engine.getEngineLogger().log(Level.INFO, \"Waiting for polyglot context cleanup was interrupted!\", ie);\n                    }\n                }\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T extends Throwable> RuntimeException sneakyThrow(Throwable ex) throws T {\n        throw (T) ex;\n    }\n\n    private List<PolyglotLanguageContext> disposeContext() {\n        assert !this.disposing;\n        this.disposing = true;\n\n        List<PolyglotLanguageContext> disposedContexts = new ArrayList<>(contexts.length);\n        for (int i = contexts.length - 1; i >= 0; i--) {\n            PolyglotLanguageContext context = contexts[i];\n            boolean disposed = context.dispose();\n            if (disposed) {\n                disposedContexts.add(context);\n            }\n        }\n        Closeable[] toClose;\n        synchronized (this) {\n            toClose = closeables == null ? null : closeables.toArray(new Closeable[0]);\n        }\n        if (toClose != null) {\n            for (Closeable closeable : toClose) {\n                try {\n                    closeable.close();\n                } catch (IOException ioe) {\n                    engine.getEngineLogger().log(Level.WARNING, \"Failed to close \" + closeable, ioe);\n                }\n            }\n        }\n        return disposedContexts;\n    }\n\n    private void exitContextNotification(TruffleLanguage.ExitMode exitMode, int code) {\n        // we need to run exit notifications at least twice in case an exit notification run has\n        // initialized new contexts\n        boolean exitNotificationPerformed;\n        try {\n            do {\n                exitNotificationPerformed = false;\n                for (int i = contexts.length - 1; i >= 0; i--) {\n                    PolyglotLanguageContext context = contexts[i];\n                    if (context.isInitialized()) {\n                        exitNotificationPerformed |= context.exitContext(exitMode, code);\n                    }\n                }\n            } while (exitNotificationPerformed);\n        } catch (Throwable t) {\n            if (exitMode == TruffleLanguage.ExitMode.NATURAL || !(t instanceof CancelExecution)) {\n                throw t;\n            } else {\n                engine.getEngineLogger().log(Level.FINE, \"Execution was cancelled during exit notifications!\", t);\n            }\n        }\n\n    }\n\n    private void finalizeContext(boolean notifyInstruments, boolean mustSucceed) {\n        // we need to run finalization at least twice in case a finalization run has\n        // initialized new contexts\n        TruffleSafepoint safepoint = TruffleSafepoint.getCurrent();\n        boolean prevChangeAllowActions = PolyglotThreadLocalActions.TL_HANDSHAKE.setChangeAllowActions(safepoint, true);\n        try {\n            boolean finalizationPerformed;\n            do {\n                finalizationPerformed = false;\n                // inverse context order is already the right order for context\n                // disposal/finalization\n                for (int i = contexts.length - 1; i >= 0; i--) {\n                    PolyglotLanguageContext context = contexts[i];\n                    if (context.isInitialized()) {\n                        try {\n                            finalizationPerformed |= context.finalizeContext(mustSucceed, notifyInstruments);\n                        } finally {\n                            if (!PolyglotThreadLocalActions.TL_HANDSHAKE.isAllowActions(safepoint)) {\n                                safepoint.setAllowActions(true);\n                                throw new IllegalStateException(\n                                                \"TruffleSafepoint.setAllowActions is still disabled even though finalization completed. Make sure allow actions are reset in a finally block.\");\n                            }\n                        }\n                    }\n                }\n            } while (finalizationPerformed);\n        } finally {\n            PolyglotThreadLocalActions.TL_HANDSHAKE.setChangeAllowActions(safepoint, prevChangeAllowActions);\n        }\n\n        List<PolyglotContextImpl> unclosedChildContexts;\n        synchronized (this) {\n            unclosedChildContexts = getUnclosedChildContexts();\n        }\n        for (PolyglotContextImpl childCtx : unclosedChildContexts) {\n            if (childCtx.isActive()) {\n                throw new IllegalStateException(\"There is an active child contexts after finalizeContext!\");\n            }\n        }\n        if (!unclosedChildContexts.isEmpty()) {\n            closeChildContexts(notifyInstruments);\n        }\n\n        assert !finalizingEmbedderThreads;\n        finalizingEmbedderThreads = true;\n        try {\n            /*\n             * finalizing embedder and non-owned polyglot threads, all language contexts are\n             * finalized but still usable. Creation of new threads and initializing new language\n             * contexts is no longer allowed.\n             */\n            PolyglotThreadInfo[] embedderThreads;\n            Throwable ex = null;\n            synchronized (this) {\n                embedderThreads = getSeenThreads().values().stream().filter(threadInfo -> !threadInfo.isPolyglotThread(this)).toList().toArray(new PolyglotThreadInfo[0]);\n            }\n            for (PolyglotThreadInfo threadInfo : embedderThreads) {\n                ex = notifyThreadFinalizing(threadInfo, ex, mustSucceed);\n            }\n            if (ex != null) {\n                if (!mustSucceed || isInternalError(ex)) {\n                    sneakyThrow(ex);\n                } else {\n                    engine.getEngineLogger().log(Level.FINE,\n                                    \"Exception was thrown while finalizing a non-polyglot thread for a context that is being cancelled or exited. Such exceptions are expected during cancelling or exiting.\",\n                                    ex);\n                }\n\n            }\n        } finally {\n            finalizingEmbedderThreads = false;\n        }\n    }\n\n    synchronized void maybeSendInterrupt() {\n        if (!state.isInterrupting() && !state.isCancelling() && !state.isExiting()) {\n            return;\n        }\n        for (PolyglotThreadInfo threadInfo : threads.values()) {\n            if (!threadInfo.isCurrent() && threadInfo.isActiveNotCancelled()) {\n                /*\n                 * We send an interrupt to the thread to wake up and to run some guest language code\n                 * in case they are waiting in some async primitive. The interrupt is then cleared\n                 * when the closed is performed.\n                 */\n                threadInfo.getThread().interrupt();\n            }\n        }\n    }\n\n    Object getLocal(LocalLocation l) {\n        assert l.engine == this.engine : invalidSharingError(this.engine, l.engine);\n        return l.readLocal(this, this.contextLocals, false);\n    }\n\n    private Object[] getThreadLocals(Thread thread) {\n        assert Thread.holdsLock(this);\n        PolyglotThreadInfo threadInfo = threads.get(thread);\n        if (threadInfo == null) {\n            return null;\n        }\n        return threadInfo.getContextThreadLocals();\n    }\n\n    /*\n     * Reading from a different thread than the current thread requires synchronization. as\n     * threadIdToThreadLocal and threadLocals are always updated on the current thread under the\n     * context lock.\n     */\n    @TruffleBoundary\n    synchronized Object getThreadLocal(LocalLocation l, Thread t) {\n        assert l.engine == this.engine : invalidSharingError(this.engine, l.engine);\n        Object[] threadLocals = getThreadLocals(t);\n        if (threadLocals == null) {\n            return null;\n        }\n        return l.readLocal(this, threadLocals, true);\n    }\n\n    void initializeThreadLocals(PolyglotThreadInfo threadInfo) {\n        assert Thread.holdsLock(this);\n        assert Thread.currentThread() == threadInfo.getThread() : \"thread locals must only be initialized on the current thread\";\n\n        StableLocalLocations locations = engine.contextThreadLocalLocations;\n        Object[] locals = new Object[locations.locations.length];\n\n        Thread thread = threadInfo.getThread();\n        for (PolyglotInstrument instrument : engine.idToInstrument.values()) {\n            if (instrument.isCreated()) {\n                invokeContextLocalsFactory(this.contextLocals, instrument.contextLocalLocations);\n                invokeContextThreadFactory(locals, instrument.contextThreadLocalLocations, thread);\n            }\n        }\n        for (PolyglotLanguageContext language : contexts) {\n            if (language.isCreated()) {\n                invokeContextLocalsFactory(this.contextLocals, language.getLanguageInstance().contextLocalLocations);\n                invokeContextThreadFactory(locals, language.getLanguageInstance().contextThreadLocalLocations, thread);\n            }\n        }\n        threadInfo.setContextThreadLocals(locals);\n    }\n\n    void initializeContextLocals() {\n        assert Thread.holdsLock(this);\n\n        if (this.contextLocals != null) {\n            // Could have already been populated by resizeContextLocals.\n            return;\n        }\n\n        StableLocalLocations locations = engine.contextLocalLocations;\n        Object[] locals = new Object[locations.locations.length];\n        initializeInstrumentContextLocals(locals);\n        /*\n         * Languages will be initialized in PolyglotLanguageContext#ensureCreated().\n         */\n        assert this.contextLocals == null;\n        this.contextLocals = locals;\n    }\n\n    void initializeInstrumentContextLocals(Object[] locals) {\n        for (PolyglotInstrument instrument : engine.idToInstrument.values()) {\n            if (instrument.isCreated()) {\n                invokeContextLocalsFactory(locals, instrument.contextLocalLocations);\n            }\n        }\n    }\n\n    void initializeInstrumentContextThreadLocals() {\n        for (PolyglotInstrument instrument : engine.idToInstrument.values()) {\n            if (instrument.isCreated()) {\n                invokeContextThreadLocalFactory(instrument.contextThreadLocalLocations);\n            }\n        }\n    }\n\n    void invokeLocalsFactories(LocalLocation[] contextLocalLocations, LocalLocation[] contextThreadLocalLocations) {\n        PolyglotContextImpl[] localChildContexts;\n        synchronized (this) {\n            if (localsCleared) {\n                return;\n            }\n            /*\n             * contextLocals might not be initialized yet, in which case the context local factory\n             * for this instrument will be invoked during contextLocals initialization.\n             */\n            if (contextLocals != null) {\n                invokeContextLocalsFactory(contextLocals, contextLocalLocations);\n                invokeContextThreadLocalFactory(contextThreadLocalLocations);\n            }\n            localChildContexts = PolyglotContextImpl.this.childContexts.toArray(new PolyglotContextImpl[0]);\n        }\n        for (PolyglotContextImpl childCtx : localChildContexts) {\n            childCtx.invokeLocalsFactories(contextLocalLocations, contextThreadLocalLocations);\n        }\n    }\n\n    void resizeThreadLocals(StableLocalLocations locations) {\n        PolyglotContextImpl[] localChildContexts;\n        synchronized (this) {\n            if (localsCleared) {\n                return;\n            }\n            resizeContextThreadLocals(locations);\n            localChildContexts = PolyglotContextImpl.this.childContexts.toArray(new PolyglotContextImpl[0]);\n        }\n        for (PolyglotContextImpl childCtx : localChildContexts) {\n            childCtx.resizeThreadLocals(locations);\n        }\n    }\n\n    void resizeContextThreadLocals(StableLocalLocations locations) {\n        assert Thread.holdsLock(this);\n        for (PolyglotThreadInfo threadInfo : threads.values()) {\n            Object[] threadLocals = threadInfo.getContextThreadLocals();\n            if (threadLocals.length < locations.locations.length) {\n                threadInfo.setContextThreadLocals(Arrays.copyOf(threadLocals, locations.locations.length));\n            }\n        }\n    }\n\n    void resizeLocals(StableLocalLocations locations) {\n        PolyglotContextImpl[] localChildContexts;\n        synchronized (this) {\n            if (localsCleared) {\n                return;\n            }\n            resizeContextLocals(locations);\n            localChildContexts = PolyglotContextImpl.this.childContexts.toArray(new PolyglotContextImpl[0]);\n        }\n        for (PolyglotContextImpl childCtx : localChildContexts) {\n            childCtx.resizeLocals(locations);\n        }\n    }\n\n    void resizeContextLocals(StableLocalLocations locations) {\n        assert Thread.holdsLock(this);\n        Object[] oldLocals = this.contextLocals;\n        if (oldLocals != null) {\n            if (oldLocals.length > locations.locations.length) {\n                throw new AssertionError(\"Context locals array must never shrink.\");\n            } else if (locations.locations.length > oldLocals.length) {\n                this.contextLocals = Arrays.copyOf(oldLocals, locations.locations.length);\n            }\n        } else {\n            this.contextLocals = new Object[locations.locations.length];\n        }\n    }\n\n    void invokeContextLocalsFactory(Object[] locals, LocalLocation[] locations) {\n        assert Thread.holdsLock(this);\n        if (locations == null) {\n            return;\n        }\n        try {\n            for (int i = 0; i < locations.length; i++) {\n                LocalLocation location = locations[i];\n                if (locals[location.index] == null) {\n                    locals[location.index] = location.invokeFactory(this, null);\n                }\n            }\n        } catch (Throwable t) {\n            // reset values again the language failed to initialize\n            for (int i = 0; i < locations.length; i++) {\n                locals[locations[i].index] = null;\n            }\n            throw t;\n        }\n    }\n\n    void invokeContextThreadLocalFactory(LocalLocation[] locations) {\n        assert Thread.holdsLock(this);\n        if (locations == null) {\n            return;\n        }\n        for (PolyglotThreadInfo threadInfo : threads.values()) {\n            invokeContextThreadFactory(threadInfo.getContextThreadLocals(), locations, threadInfo.getThread());\n        }\n    }\n\n    private void invokeContextThreadFactory(Object[] threadLocals, LocalLocation[] locations, Thread thread) {\n        assert Thread.holdsLock(this);\n        if (locations == null) {\n            return;\n        }\n        try {\n            for (int i = 0; i < locations.length; i++) {\n                LocalLocation location = locations[i];\n                if (threadLocals[location.index] == null) {\n                    threadLocals[location.index] = location.invokeFactory(this, thread);\n                }\n            }\n        } catch (Throwable t) {\n            // reset values again the language failed to initialize\n            for (int i = 0; i < locations.length; i++) {\n                threadLocals[locations[i].index] = null;\n            }\n            throw t;\n        }\n    }\n\n    static String invalidSharingError(PolyglotEngineImpl expectedEngine, PolyglotEngineImpl actualEngine) {\n        return String.format(\"Detected invaliding sharing of context locals between polyglot engines. Expected engine %s but was %s.\", expectedEngine, actualEngine);\n    }\n\n    boolean patch(PolyglotContextConfig newConfig) {\n        CompilerAsserts.neverPartOfCompilation();\n        if (PreInitContextHostLanguage.isInstance(contexts[PolyglotEngineImpl.HOST_LANGUAGE_INDEX].language)) {\n            maybeInitializeHostLanguage(contexts);\n        }\n        this.config = newConfig;\n        threadLocalActions.onContextPatch();\n        EngineAccessor.LANGUAGE.configureLoggers(this, newConfig.logLevels, getAllLoggers());\n        final Object[] prev = engine.enter(this);\n        try {\n            for (int i = 0; i < this.contexts.length; i++) {\n                final PolyglotLanguageContext context = this.contexts[i];\n                if (context.language.isHost()) {\n                    initializeHostContext(context, newConfig);\n                }\n                if (!context.patch(newConfig)) {\n                    return false;\n                }\n            }\n        } finally {\n            engine.leave(prev, this);\n        }\n        return true;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    void initializeHostContext(PolyglotLanguageContext context, PolyglotContextConfig newConfig) {\n        Object contextImpl = context.getContextImpl();\n        if (contextImpl == null) {\n            throw new AssertionError(\"Host context not initialized.\");\n        }\n        this.hostContextImpl = contextImpl;\n\n        AbstractHostLanguageService currentHost = engine.host;\n        AbstractHostLanguageService newHost = context.lookupService(AbstractHostLanguageService.class);\n        if (newHost == null) {\n            throw new AssertionError(\"The engine host language must register a service of type:\" + AbstractHostLanguageService.class);\n        }\n        if (currentHost == null) {\n            engine.host = newHost;\n        } else if (currentHost != newHost) {\n            throw new AssertionError(\"Host service must not change per engine.\");\n        }\n        newHost.initializeHostContext(this, contextImpl, newConfig.hostAccess, newConfig.hostClassLoader, newConfig.classFilter, newConfig.hostClassLoadingAllowed,\n                        newConfig.hostLookupAllowed);\n    }\n\n    void replayInstrumentationEvents() {\n        notifyContextCreated();\n        EngineAccessor.INSTRUMENT.notifyThreadStarted(engine, creatorTruffleContext, Thread.currentThread());\n        for (PolyglotLanguageContext lc : contexts) {\n            LanguageInfo language = lc.language.info;\n            if (lc.eventsEnabled && lc.env != null) {\n                EngineAccessor.INSTRUMENT.notifyLanguageContextCreate(this, creatorTruffleContext, language);\n                EngineAccessor.INSTRUMENT.notifyLanguageContextCreated(this, creatorTruffleContext, language);\n                if (lc.isInitialized()) {\n                    EngineAccessor.INSTRUMENT.notifyLanguageContextInitialize(this, creatorTruffleContext, language);\n                    EngineAccessor.INSTRUMENT.notifyLanguageContextInitialized(this, creatorTruffleContext, language);\n                    if (lc.finalized) {\n                        EngineAccessor.INSTRUMENT.notifyLanguageContextFinalized(this, creatorTruffleContext, language);\n                    }\n                }\n            }\n        }\n    }\n\n    private synchronized void checkSubProcessFinished() {\n        ProcessHandlers.ProcessDecorator[] processes = subProcesses.toArray(new ProcessHandlers.ProcessDecorator[subProcesses.size()]);\n        for (ProcessHandlers.ProcessDecorator process : processes) {\n            if (process.isAlive()) {\n                throw new IllegalStateException(String.format(\"The context has an alive sub-process %s created by %s.\",\n                                process.getCommand(), process.getOwner().language.getId()));\n            }\n        }\n    }\n\n    private synchronized void checkSystemThreadsFinished() {\n        if (!activeSystemThreads.isEmpty()) {\n            LanguageSystemThread thread = activeSystemThreads.iterator().next();\n            throw new IllegalStateException(String.format(\"The context has an alive system thread %s created by language %s.\", thread.getName(), thread.languageId));\n        }\n    }\n\n    static PolyglotContextImpl preinitialize(final PolyglotEngineImpl engine, final PreinitConfig preinitConfig, PolyglotSharingLayer sharableLayer, Set<PolyglotLanguage> languagesToPreinitialize,\n                    boolean emitWarning) {\n        String tmpDir = System.getProperty(\"java.io.tmpdir\");\n        final FileSystemConfig fileSystemConfig = new FileSystemConfig(engine.getAPIAccess().getIOAccessAll(), new PreInitializeContextFileSystem(tmpDir), new PreInitializeContextFileSystem(tmpDir));\n        final PolyglotContextConfig config = new PolyglotContextConfig(engine, fileSystemConfig, preinitConfig);\n        final PolyglotContextImpl context = new PolyglotContextImpl(engine, config);\n        synchronized (engine.lock) {\n            engine.addContext(context);\n        }\n\n        context.sourcesToInvalidate = new ArrayList<>();\n\n        try {\n\n            if (sharableLayer != null) {\n                if (!context.claimSharingLayer(sharableLayer, languagesToPreinitialize)) {\n                    // could not claim layer. cannot preinitialize context.\n                    return null;\n                }\n            }\n\n            synchronized (context) {\n                context.initializeContextLocals();\n            }\n\n            if (!languagesToPreinitialize.isEmpty()) {\n                Object[] prev = context.engine.enter(context);\n                try {\n                    for (PolyglotLanguage language : languagesToPreinitialize) {\n                        assert language.engine == engine : \"invalid language\";\n\n                        if (overridesPatchContext(language.getId())) {\n                            context.getContextInitialized(language, null);\n                            LOG.log(Level.FINE, \"Pre-initialized context for language: {0}\", language.getId());\n                        } else {\n                            if (emitWarning) {\n                                LOG.log(Level.WARNING, \"Language {0} cannot be pre-initialized as it does not override TruffleLanguage.patchContext method.\", language.getId());\n                            }\n                        }\n                    }\n\n                } finally {\n                    context.leaveThreadChanged(prev, true, true);\n                }\n            }\n            return context;\n        } finally {\n\n            for (PolyglotLanguage language : engine.languages) {\n                if (language != null) {\n                    language.clearOptionValues();\n                }\n            }\n            synchronized (engine.lock) {\n                engine.removeContext(context);\n            }\n            for (Source sourceToInvalidate : context.sourcesToInvalidate) {\n                EngineAccessor.SOURCE.invalidateAfterPreinitialiation(sourceToInvalidate);\n            }\n            context.singleThreadValue.reset();\n            context.sourcesToInvalidate = null;\n            context.threadLocalActions.prepareContextStore();\n            Map<String, Path> languageHomes = new HashMap<>();\n            for (PolyglotLanguage language : engine.languages) {\n                if (language != null) {\n                    LanguageCache cache = language.cache;\n                    String languageHome = cache.getLanguageHome();\n                    if (languageHome != null) {\n                        languageHomes.put(cache.getId(), Path.of(languageHome));\n                    }\n                }\n            }\n\n            ((PreInitializeContextFileSystem) fileSystemConfig.fileSystem).onPreInitializeContextEnd(engine.internalResourceRoots, languageHomes);\n            ((PreInitializeContextFileSystem) fileSystemConfig.internalFileSystem).onPreInitializeContextEnd(engine.internalResourceRoots, languageHomes);\n            EngineAccessor.LANGUAGE.configureLoggers(context, null, context.getAllLoggers());\n        }\n    }\n\n    private void languageHomes(PolyglotEngineImpl engine, Map<String, Path> languageHomes) {\n        for (PolyglotLanguage language : engine.languages) {\n            if (language != null) {\n                LanguageCache cache = language.cache;\n                String languageHome = cache.getLanguageHome();\n                if (languageHome != null) {\n                    languageHomes.put(cache.getId(), Path.of(languageHome));\n                }\n            }\n        }\n    }\n\n    Object getOrCreateContextLoggers() {\n        Object res = contextBoundLoggers;\n        if (res == null) {\n            synchronized (this) {\n                res = contextBoundLoggers;\n                if (res == null) {\n                    res = LANGUAGE.createEngineLoggers(PolyglotLoggers.LoggerCache.newContextLoggerCache(this));\n                    EngineAccessor.LANGUAGE.configureLoggers(this, this.config.logLevels, res);\n                    contextBoundLoggers = res;\n                }\n            }\n        }\n        return res;\n    }\n\n    private Object[] getAllLoggers() {\n        Object defaultLoggers = EngineAccessor.LANGUAGE.getDefaultLoggers();\n        Object engineLoggers = engine.getEngineLoggers();\n        Object contextLoggers = contextBoundLoggers;\n        List<Object> allLoggers = new ArrayList<>(3);\n        allLoggers.add(defaultLoggers);\n        if (engineLoggers != null) {\n            allLoggers.add(engineLoggers);\n        }\n        if (contextLoggers != null) {\n            allLoggers.add(contextLoggers);\n        }\n        return allLoggers.toArray(new Object[0]);\n    }\n\n    static class ContextWeakReference extends WeakReference<PolyglotContextImpl> {\n\n        volatile boolean removed = false;\n        volatile PolyglotSharingLayer layer;\n\n        ContextWeakReference(PolyglotContextImpl referent) {\n            super(referent, referent.engine.contextsReferenceQueue);\n        }\n\n        void freeSharing(PolyglotContextImpl context) {\n            if (context != null) {\n                assert layer == null || layer.equals(context.layer);\n            }\n            if (layer != null && layer.isClaimed()) {\n                layer.engine.freeSharingLayer(layer, context);\n            }\n        }\n\n    }\n\n    private CancelExecution createCancelException(Node location) {\n        return new CancelExecution(location, invalidMessage, invalidResourceLimit);\n    }\n\n    private ExitException createExitException(Node location) {\n        return new ExitException(location, exitCode, exitMessage);\n    }\n\n    private static boolean overridesPatchContext(String languageId) {\n        if (TruffleOptions.AOT) {\n            return LanguageCache.overridesPathContext(languageId);\n        } else {\n            // Used by context pre-initialization tests on HotSpot\n            LanguageCache cache = LanguageCache.languages().get(languageId);\n            for (Method m : cache.loadLanguage().getClass().getDeclaredMethods()) {\n                if (m.getName().equals(\"patchContext\")) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    synchronized void registerOnDispose(Closeable closeable) {\n        if (disposing) {\n            throw new IllegalStateException(\"Cannot register closeable when context is being disposed.\");\n        }\n        if (closeables == null) {\n            closeables = Collections.newSetFromMap(new WeakHashMap<>());\n        }\n        closeables.add(Objects.requireNonNull(closeable));\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder b = new StringBuilder();\n        b.append(\"PolyglotContextImpl[\");\n        b.append(\"state=\");\n        State localState = state;\n        b.append(localState.name());\n        b.append(\",disposing=\");\n        b.append(disposing);\n        if (!localState.isClosed()) {\n            if (isActive()) {\n                b.append(\", active\");\n            } else {\n                b.append(\", inactive\");\n            }\n        }\n\n        b.append(\" languages=[\");\n        String sep = \"\";\n        for (PolyglotLanguageContext languageContext : contexts) {\n            if (languageContext.isInitialized() || languageContext.isCreated()) {\n                b.append(sep);\n                b.append(languageContext.language.getId());\n                sep = \", \";\n            }\n        }\n        b.append(\"]\");\n        b.append(\"]\");\n        return b.toString();\n    }\n\n    private static final class UncachedLocationNode extends HostToGuestRootNode {\n\n        UncachedLocationNode(PolyglotSharingLayer layer) {\n            super(layer);\n        }\n\n        @Override\n        protected Class<?> getReceiverType() {\n            throw CompilerDirectives.shouldNotReachHere();\n        }\n\n        @Override\n        protected Object executeImpl(PolyglotLanguageContext languageContext, Object receiver, Object[] args) {\n            throw CompilerDirectives.shouldNotReachHere();\n        }\n\n        @Override\n        public boolean isInternal() {\n            return true;\n        }\n\n    }\n\n    private final class CancellationThreadLocalAction extends ThreadLocalAction {\n        CancellationThreadLocalAction() {\n            super(false, false);\n        }\n\n        @Override\n        protected void perform(Access access) {\n            PolyglotContextImpl.this.threadLocalActions.submit(new Thread[]{access.getThread()}, PolyglotEngineImpl.ENGINE_ID, this, new HandshakeConfig(true, false, false, true));\n\n            State localState = PolyglotContextImpl.this.state;\n            if (localState.isCancelling() || localState.isExiting() || localState == State.CLOSED_CANCELLED || localState == State.CLOSED_EXITED) {\n                if (localState.isExiting() || localState == State.CLOSED_EXITED) {\n                    throw createExitException(access.getLocation());\n                } else {\n                    throw createCancelException(access.getLocation());\n                }\n            }\n        }\n    }\n\n    private final class InterruptThreadLocalAction extends ThreadLocalAction {\n        InterruptThreadLocalAction() {\n            super(true, false);\n        }\n\n        @Override\n        protected void perform(Access access) {\n            PolyglotContextImpl.this.threadLocalActions.submit(new Thread[]{access.getThread()}, PolyglotEngineImpl.ENGINE_ID, this, true);\n\n            State localState = state;\n            if (access.getThread() != PolyglotContextImpl.this.closingThread) {\n                if (localState.isInterrupting() || localState == State.CLOSED_INTERRUPTED) {\n                    PolyglotContextImpl[] interruptingChildContexts;\n                    synchronized (PolyglotContextImpl.this) {\n                        interruptingChildContexts = PolyglotContextImpl.this.childContexts.toArray(new PolyglotContextImpl[0]);\n                    }\n                    for (PolyglotContextImpl childCtx : interruptingChildContexts) {\n                        if (access.getThread() == childCtx.closingThread) {\n                            return;\n                        }\n                    }\n                    // Interrupt should never break a closing operation\n                    throw new PolyglotEngineImpl.InterruptExecution(access.getLocation());\n                }\n            }\n        }\n    }\n\n    @TruffleBoundary\n    void runOnCancelled() {\n        Runnable onCancelledRunnable = config.onCancelled;\n        if (onCancelledRunnable != null) {\n            onCancelledRunnable.run();\n        }\n    }\n\n    @TruffleBoundary\n    void runOnExited(int code) {\n        Consumer<Integer> onExitedRunnable = config.onExited;\n        if (onExitedRunnable != null) {\n            onExitedRunnable.accept(code);\n        }\n    }\n\n    @TruffleBoundary\n    void runOnClosed() {\n        Runnable onClosedRunnable = config.onClosed;\n        if (onClosedRunnable != null) {\n            onClosedRunnable.run();\n        }\n    }\n\n    synchronized void addSystemThread(LanguageSystemThread thread) {\n        if (!state.isClosed()) {\n            activeSystemThreads.add(thread);\n        }\n    }\n\n    synchronized void removeSystemThread(LanguageSystemThread thread) {\n        activeSystemThreads.remove(thread);\n    }\n\n}",
                "methodCount": 188
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 15,
                "candidates": [
                    {
                        "lineStart": 792,
                        "lineEnd": 797,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method pause to class ContextWeakReference",
                        "description": "Move method pause to com.oracle.truffle.polyglot.PolyglotContextImpl.ContextWeakReference\nRationale: The `pause` method seems to deal heavily with thread-local actions, which are associated with a specific context. The `PauseThreadLocalAction` class and its usage also imply that it is closely coupled with managing the state of the context. Additionally, the method name and functionality imply pausing and resuming specific tasks, which fits better with the responsibility of `ContextWeakReference` that handles context-specific actions and references. On the other hand, `State` is primarily focused on representing the lifecycle status of contexts and doesn't seem to have the proper infrastructure to handle thread-local actions directly.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 3252,
                        "lineEnd": 3255,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getLocal to class PolyglotEngineImpl",
                        "description": "Move method getLocal to com.oracle.truffle.polyglot.PolyglotEngineImpl\nRationale: The method `getLocal(LocalLocation l)` accesses `this.engine`, which directly relates to the `PolyglotEngineImpl` class that manages engine-related operations and properties. Furthermore, `PolyglotEngineImpl` maintains the context locals managed by the engine, making it the most appropriate class for housing this method. This alignment ensures clear encapsulation of engine-specific functionalities within the `PolyglotEngineImpl` class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 2486,
                        "lineEnd": 2510,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method restoreFromClosingState to class State",
                        "description": "Move method restoreFromClosingState to com.oracle.truffle.polyglot.PolyglotContextImpl.State\nRationale: The method `restoreFromClosingState()` is heavily reliant on the state transitions defined within the `State` enum. It switches between various states under certain conditions and directly manipulates state transitions. By placing this method within the `State` class, the logic is kept close to the state definitions it operates upon, ensuring better encapsulation and simplifying maintenance.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 625,
                        "lineEnd": 628,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method shouldCacheThreadInfo to class State",
                        "description": "Move method shouldCacheThreadInfo to com.oracle.truffle.polyglot.PolyglotContextImpl.State\nRationale: The method 'shouldCacheThreadInfo' checks the state and whether the thread info should be cached based on the current state. Since the 'State' enum already contains similar logic for handling state transitions and thread information caching, it is natural for this method to be part of the 'State' class. This would encapsulate state-related logic within a single class, making the code easier to manage and understand. The 'State' class also contains a private method of the same name that aligns closely with the functionality of the method that needs to be moved. Moving the method here maintains cohesion and improves encapsulation.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 2462,
                        "lineEnd": 2484,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method setClosedState to class State",
                        "description": "Move method setClosedState to com.oracle.truffle.polyglot.PolyglotContextImpl.State\nRationale: The method `setClosedState()` directly interacts with the `State` enum by checking and transitioning between various state values. Given that this logic is intrinsic to the states defined in the `State` enum, it is reasonable to relocate the method to the `State` class. This placement ensures that state-specific behaviors and transitions are encapsulated within the `State` class, adhering to the principles of cohesion and encapsulation. Furthermore, the `State` class already contains several methods that handle state validation and transitions, making it the most appropriate home for the `setClosedState()` method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 664,
                        "lineEnd": 666,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getInstrumentContextOptions to class PolyglotInstrument",
                        "description": "Move method getInstrumentContextOptions to com.oracle.truffle.polyglot.PolyglotInstrument\nRationale: The method getInstrumentContextOptions heavily relies on the PolyglotInstrument class because it requires an instance of PolyglotInstrument as a parameter. Furthermore, it deals directly with retrieving option values for an instrument, which aligns with the methods and responsibilities already present in the PolyglotInstrument class, such as getEngineOptionsInternal and getContextOptionsInternal.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 720,
                        "lineEnd": 722,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getContext to class PolyglotLanguage",
                        "description": "Move method getContext to com.oracle.truffle.polyglot.PolyglotLanguage\nRationale: The method getContext relies on the engineIndex field which is integral to the PolyglotLanguage class. The context is directly associated with the language and its configuration within the engine. Moving the method to PolyglotLanguage aligns with its existing responsibility of managing context-related operations, ensuring logical cohesiveness and better encapsulation.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 724,
                        "lineEnd": 726,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getContextImpl to class PolyglotLanguage",
                        "description": "Move method getContextImpl to com.oracle.truffle.polyglot.PolyglotLanguage\nRationale: The getContextImpl method directly interacts with the 'language.engineIndex' attribute specific to the PolyglotLanguage class. Furthermore, the method fetches the context implementation using indices relevant to the languages handled by the engine, which is a core responsibility of the PolyglotLanguage class. Moving this method to PolyglotLanguage ensures better encapsulation and aligns with the Single Responsibility Principle as the class should manage interactions related to language-specific operations.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1782,
                        "lineEnd": 1789,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method cancel to class State",
                        "description": "Move method cancel to com.oracle.truffle.polyglot.PolyglotContextImpl.State\nRationale: The 'cancel' method directly interacts with the state of the context, particularly with managing and transitioning its states. The State enum encapsulates various states including cancelling, and it appears designed to handle the state transitions and related logic. Moving the method to the State enum ensures state-related behavior is centralized, which improves cohesion and maintainability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 693,
                        "lineEnd": 703,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method createContextArray to class ContextWeakReference",
                        "description": "Move method createContextArray to com.oracle.truffle.polyglot.PolyglotContextImpl.ContextWeakReference\nRationale: The `createContextArray` method deals with the initialization and handling of multiple `PolyglotLanguageContext` instances based on the state and data held by the `engine`. This involves an operation that creates and maintains references to multiple contexts, which aligns closely with the responsibilities and data already managed by `ContextWeakReference`. This class is designed to handle references to `PolyglotContextImpl` objects, making it a suitable candidate for containing logic related to context management and reference handling. The method's primary purpose is unrelated to state transitions or definitions, making `State` a less appropriate target.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 2242,
                        "lineEnd": 2251,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method notifyThreadClosed to class PolyglotThreadInfo",
                        "description": "Move method notifyThreadClosed to com.oracle.truffle.polyglot.PolyglotThreadInfo\nRationale: The method `notifyThreadClosed(PolyglotThreadInfo info)` primarily operates on the state and behavior of the `PolyglotThreadInfo` object, setting its 'cancelled' status and managing interruption states. Placing this method in the `PolyglotThreadInfo` class closely aligns the method with the data it manipulates, promoting encapsulation and cohesion. Additionally, the `PolyglotThreadInfo` class is already aware of the thread-related context it operates in, making it a suitable host for this method functionality.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1445,
                        "lineEnd": 1451,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method checkClosedOrDisposing to class State",
                        "description": "Move method checkClosedOrDisposing to com.oracle.truffle.polyglot.PolyglotContextImpl.State\nRationale: The method 'checkClosedOrDisposing' involves checking the state of an object and performing actions based on whether it is closed or disposing. Since the State enum has methods to determine various states like isClosed and also has enums indicating different states, moving this method to the State class would keep all state-related logic together. Additionally, moving this method to the State class encapsulates the state transition logic, making the code more maintainable and easier to understand.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 2512,
                        "lineEnd": 2652,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method closeImpl to class State",
                        "description": "Move method closeImpl to com.oracle.truffle.polyglot.PolyglotContextImpl.State\nRationale: The 'closeImpl' method deals extensively with various states and transitions of the context, such as DEFAULT, CLOSING, INTERRUPTING, etc. The State class defines and manages these states, making it a logical home for such a method. The move would enhance cohesion by colocating the state handling logic with the state definitions, facilitating easier maintenance and readability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 738,
                        "lineEnd": 745,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method addChildContext to class State",
                        "description": "Move method addChildContext to com.oracle.truffle.polyglot.PolyglotContextImpl.State\nRationale: The method `addChildContext` includes checks related to the state of the context, particularly checking if the state is closed or closing. These checks make extensive use of the methods within the `State` enum related to closing and caching thread info. Thus, moving `addChildContext` into the `State` enum aligns with the class's responsibility for managing the context state, leading to cleaner code and encapsulation.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 3266,
                        "lineEnd": 3279,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getThreadLocal to class ContextWeakReference",
                        "description": "Move method getThreadLocal to com.oracle.truffle.polyglot.PolyglotContextImpl.ContextWeakReference\nRationale: The getThreadLocal method deals with thread local storage and synchronization, which are key elements managed by context references in a multi-threaded environment. ContextWeakReference handles tasks related to thread contexts and sharing layers, making it an appropriate class for this method. The method also checks context validity, which aligns with the responsibilities of managing weak references to contexts.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getHostContextImpl",
                            "method_signature": "public Object getHostContextImpl()",
                            "target_class": "PolyglotEngineImpl",
                            "rationale": "The method `getHostContextImpl` is about fetching an implementation that's directly related to the engine. Hence, it is more appropriate for it to be in the `PolyglotEngineImpl` class where the engines are managed."
                        },
                        {
                            "method_name": "getEngine",
                            "method_signature": "public PolyglotEngineImpl getEngine()",
                            "target_class": "PolyglotEngineImpl",
                            "rationale": "The method `getEngine` retrieves the engine instance. This functionality is more closely associated with the `PolyglotEngineImpl` class, as it better represents the responsibility of that class."
                        },
                        {
                            "method_name": "getAPIAccess",
                            "method_signature": "public APIAccess getAPIAccess()",
                            "target_class": "PolyglotEngineImpl",
                            "rationale": "Since `getAPIAccess` returns an API access object related to the engine, it seems more logical to place it within the `PolyglotEngineImpl` class."
                        },
                        {
                            "method_name": "setCachedThreadInfo",
                            "method_signature": "void setCachedThreadInfo(PolyglotThreadInfo info)",
                            "target_class": "PolyglotEngineImpl",
                            "rationale": "The method `setCachedThreadInfo` deals with thread information caching which is closely related to the engine's operation, making `PolyglotEngineImpl` a more suitable class."
                        },
                        {
                            "method_name": "getOrCreateContextLoggers",
                            "method_signature": "public Object getOrCreateContextLoggers()",
                            "target_class": "PolyglotEngineImpl",
                            "rationale": "This method deals with creating or obtaining context loggers, which is closely linked to the engine and its logging mechanisms. Thus, it should be moved to the `PolyglotEngineImpl` class."
                        },
                        {
                            "method_name": "runOnCancelled",
                            "method_signature": "void runOnCancelled()",
                            "target_class": "PolyglotEngineImpl",
                            "rationale": "The method `runOnCancelled` executes a cancellation routine related to the engine's state, and thus logically belongs in the `PolyglotEngineImpl` class."
                        },
                        {
                            "method_name": "runOnExited",
                            "method_signature": "void runOnExited(int code)",
                            "target_class": "PolyglotEngineImpl",
                            "rationale": "The method `runOnExited` handles exit routines which are state changes related to the engine. Therefore, it should be moved to `PolyglotEngineImpl`."
                        },
                        {
                            "method_name": "runOnClosed",
                            "method_signature": "void runOnClosed()",
                            "target_class": "PolyglotEngineImpl",
                            "rationale": "The method `runOnClosed` is part of handling the closure of the context which is directly managed by the engine, making `PolyglotEngineImpl` a more appropriate class."
                        }
                    ],
                    "llm_response_time": 14434
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "calculateHeapSize",
                            "method_signature": "long calculateHeapSize(long stopAtBytes, AtomicBoolean calculationCancelled)",
                            "target_class": "ObjectSizeCalculator",
                            "rationale": "The method is focused on calculating the size of objects and uses ObjectSizeCalculator, which indicates that it would be more appropriate to be placed in that class."
                        },
                        {
                            "method_name": "initializeHostContext",
                            "method_signature": "void initializeHostContext(PolyglotLanguageContext context, PolyglotContextConfig newConfig)",
                            "target_class": "PolyglotLanguageContext",
                            "rationale": "This method is deeply related to the initialization of contexts for a language, which suggests that it belongs to the PolyglotLanguageContext class."
                        },
                        {
                            "method_name": "exitContextNotification",
                            "method_signature": "void exitContextNotification(TruffleLanguage.ExitMode exitMode, int code)",
                            "target_class": "PolyglotLanguageContext",
                            "rationale": "This method is related to notifying language contexts about exit events, making it more appropriate to be moved to PolyglotLanguageContext."
                        },
                        {
                            "method_name": "parse",
                            "method_signature": "public Object parse(String languageId, Object source)",
                            "target_class": "PolyglotLanguageContext",
                            "rationale": "This method is focused on parsing using a specific language context, meaning it should exist within the PolyglotLanguageContext."
                        },
                        {
                            "method_name": "eval",
                            "method_signature": "public Object eval(String languageId, Object source)",
                            "target_class": "PolyglotLanguageContext",
                            "rationale": "This method evaluates source code within a specified language context, so it belongs to PolyglotLanguageContext."
                        },
                        {
                            "method_name": "initializeContextLocals",
                            "method_signature": "void initializeContextLocals()",
                            "target_class": "PolyglotLanguageContext",
                            "rationale": "The method is related to initializing language-specific context locals, indicating that it should be in PolyglotLanguageContext."
                        },
                        {
                            "method_name": "initializeThreadLocals",
                            "method_signature": "void initializeThreadLocals(PolyglotThreadInfo threadInfo)",
                            "target_class": "PolyglotThreadInfo",
                            "rationale": "This method initializes thread-specific locals and hence belongs to the PolyglotThreadInfo class."
                        }
                    ],
                    "llm_response_time": 9908
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "initializeHostContext",
                            "method_signature": "void initializeHostContext(PolyglotLanguageContext context, PolyglotContextConfig newConfig)",
                            "target_class": "PolyglotLanguageContext",
                            "rationale": "Since the `initializeHostContext` method primarily deals with initialization logic for `PolyglotLanguageContext` and modifies its state, it would be more appropriate to move this method to the `PolyglotLanguageContext` class to encapsulate the related functionality within the context it directly affects."
                        },
                        {
                            "method_name": "calculateHeapSize",
                            "method_signature": "long calculateHeapSize(long stopAtBytes, AtomicBoolean calculationCancelled)",
                            "target_class": "ObjectSizeCalculator",
                            "rationale": "The `calculateHeapSize` method is directly invoking the `ObjectSizeCalculator` to compute object sizes. It would be more appropriate to move this method to the `ObjectSizeCalculator` class to centralize the logic related to object size calculation."
                        },
                        {
                            "method_name": "runOnCancelled",
                            "method_signature": "void runOnCancelled()",
                            "target_class": "PolyglotContextConfig",
                            "rationale": "Since `runOnCancelled` method directly executes the `onCancelled` Runnable defined in `PolyglotContextConfig`, it makes sense to move it to the `PolyglotContextConfig` class to encapsulate the associated behavior with the configuration."
                        },
                        {
                            "method_name": "runOnExited",
                            "method_signature": "void runOnExited(int code)",
                            "target_class": "PolyglotContextConfig",
                            "rationale": "Since `runOnExited` method directly executes the `onExited` Consumer defined in `PolyglotContextConfig`, it makes sense to move it to the `PolyglotContextConfig` class to encapsulate the associated behavior with the configuration."
                        },
                        {
                            "method_name": "runOnClosed",
                            "method_signature": "void runOnClosed()",
                            "target_class": "PolyglotContextConfig",
                            "rationale": "Since `runOnClosed` method directly executes the `onClosed` Runnable defined in `PolyglotContextConfig`, it makes sense to move it to the `PolyglotContextConfig` class to encapsulate the associated behavior with the configuration."
                        },
                        {
                            "method_name": "maybeSendInterrupt",
                            "method_signature": "void maybeSendInterrupt()",
                            "target_class": "PolyglotThreadInfo",
                            "rationale": "The `maybeSendInterrupt` method manipulates the `PolyglotThreadInfo` to send interrupts to active threads. It makes logical sense to move it to the `PolyglotThreadInfo` class to manage the behavior associated with thread interruputs within the appropriate context."
                        },
                        {
                            "method_name": "exitContextNotification",
                            "method_signature": "void exitContextNotification(TruffleLanguage.ExitMode exitMode, int code)",
                            "target_class": "PolyglotLanguageContext",
                            "rationale": "The `exitContextNotification` method handles exit notifications related to `PolyglotLanguageContext`. Moving this method to `PolyglotLanguageContext` would encapsulate the behavior where contexts manage their own exit notifications."
                        },
                        {
                            "method_name": "initializeThreadLocals",
                            "method_signature": "void initializeThreadLocals(PolyglotThreadInfo threadInfo)",
                            "target_class": "PolyglotThreadInfo",
                            "rationale": "The `initializeThreadLocals` method initializes thread local variables specific to `PolyglotThreadInfo`. Moving this method to `PolyglotThreadInfo` would encapsulate the logic of thread local variable initialization within the class responsible for thread state."
                        },
                        {
                            "method_name": "invokeLocalsFactories",
                            "method_signature": "void invokeLocalsFactories(LocalLocation[] contextLocalLocations, LocalLocation[] contextThreadLocalLocations)",
                            "target_class": "PolyglotThreadInfo",
                            "rationale": "This method deals with invoking local factories associated with thread locals. Moving it to `PolyglotThreadInfo` would provide better encapsulation and centralize the logic directly affecting thread state in `PolyglotContextImpl`."
                        }
                    ],
                    "llm_response_time": 15552
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "isAdditionalTransitionConditionSatisfied",
                            "method_signature": "private isAdditionalTransitionConditionSatisfied(State fromState, State toState)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "shouldCacheThreadInfo",
                            "method_signature": "private shouldCacheThreadInfo()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "claimSharingLayer",
                            "method_signature": " claimSharingLayer(PolyglotLanguage language)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "claimSharingLayer",
                            "method_signature": " claimSharingLayer(PolyglotSharingLayer sharableLayer, Set<PolyglotLanguage> languages)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getInstrumentContextOptions",
                            "method_signature": " getInstrumentContextOptions(PolyglotInstrument instrument)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createContextArray",
                            "method_signature": "private createContextArray()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "maybeInitializeHostLanguage",
                            "method_signature": "private maybeInitializeHostLanguage(PolyglotLanguageContext[] contextsArray)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getContext",
                            "method_signature": " getContext(PolyglotLanguage language)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getContextImpl",
                            "method_signature": " getContextImpl(PolyglotLanguage language)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addChildContext",
                            "method_signature": " addChildContext(PolyglotContextImpl child)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "explicitEnter",
                            "method_signature": "public synchronized explicitEnter()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "explicitLeave",
                            "method_signature": "public synchronized explicitLeave()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "pause",
                            "method_signature": "synchronized pause()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "resume",
                            "method_signature": " resume(Future<Void> pauseFuture)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "enterThreadChanged",
                            "method_signature": "@TruffleBoundary enterThreadChanged(boolean enterReverted, boolean pollSafepoint, boolean mustSucceed, boolean polyglotThreadFirstEnter,\n                    boolean leaveAndEnter)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "checkAllThreadAccesses",
                            "method_signature": "private checkAllThreadAccesses(Thread enteringThread, boolean singleThread)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "leaveAndEnter",
                            "method_signature": "@SuppressWarnings(\"CatchMayIgnoreException\")\n    public leaveAndEnter(TruffleSafepoint.Interrupter interrupter, TruffleSafepoint.InterruptibleFunction<T, R> interruptible, T object, boolean mustSucceed)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "leaveThreadChanged",
                            "method_signature": "@TruffleBoundary leaveThreadChanged(Object[] prev, boolean entered, boolean finalizeAndDispose)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "finishThreadDispose",
                            "method_signature": "private finishThreadDispose(Thread current, PolyglotThreadInfo info, Throwable ex)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "notifyThreadFinalizing",
                            "method_signature": "private notifyThreadFinalizing(PolyglotThreadInfo threadInfo, Throwable previousEx, boolean mustSucceed)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "notifyThreadDisposing",
                            "method_signature": "private notifyThreadDisposing(PolyglotThreadInfo threadInfo, Throwable previousEx)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "initializeNewThread",
                            "method_signature": "private initializeNewThread(PolyglotThreadInfo threadInfo, boolean mustSucceed)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "transitionToMultiThreaded",
                            "method_signature": "private transitionToMultiThreaded(boolean mustSucceed)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createThreadInfo",
                            "method_signature": "private createThreadInfo(Thread current, boolean polyglotThreadFirstEnter)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "throwDeniedThreadAccess",
                            "method_signature": "static throwDeniedThreadAccess(Thread current, boolean accessSingleThreaded, List<PolyglotLanguage> deniedLanguages)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "checkClosedOrDisposing",
                            "method_signature": " checkClosedOrDisposing(boolean mustSucceed)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "checkClosed",
                            "method_signature": " checkClosed()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "checkCancelled",
                            "method_signature": "private checkCancelled()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "migrateValue",
                            "method_signature": " migrateValue(Object value, PolyglotContextImpl valueContext)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "migrateHostWrapper",
                            "method_signature": " migrateHostWrapper(PolyglotWrapper wrapper)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "findLanguageContext",
                            "method_signature": "@SuppressWarnings(\"rawtypes\") findLanguageContext(Class<? extends TruffleLanguage> languageClazz)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getLanguageContextImpl",
                            "method_signature": "private getLanguageContextImpl(Class<? extends TruffleLanguage<?>> languageClass)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "initializeInnerContextLanguage",
                            "method_signature": " initializeInnerContextLanguage(String languageId)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "requirePublicLanguage",
                            "method_signature": "public requirePublicLanguage(String languageId)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "printResult",
                            "method_signature": "@TruffleBoundary\n    static printResult(PolyglotLanguageContext languageContext, Object result)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "close",
                            "method_signature": "public close(boolean cancelIfExecuting)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "cancel",
                            "method_signature": " cancel(boolean resourceLimit, String message)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "closeAndMaybeWait",
                            "method_signature": " closeAndMaybeWait(boolean force, List<Future<Void>> futures)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setInterrupting",
                            "method_signature": "private setInterrupting()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "unsetInterrupting",
                            "method_signature": "private unsetInterrupting()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "finishInterruptForChildContexts",
                            "method_signature": "private finishInterruptForChildContexts()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interruptChildContexts",
                            "method_signature": "private interruptChildContexts()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "validateInterruptPrecondition",
                            "method_signature": "private validateInterruptPrecondition(PolyglotContextImpl operationSource)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "interrupt",
                            "method_signature": "public interrupt(Duration timeout)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "toGuestValue",
                            "method_signature": " toGuestValue(Node node, Object hostValue, boolean asValue)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "waitForAllThreads",
                            "method_signature": "@SuppressWarnings(\"ConstantConditions\") waitForAllThreads(long startMillis, long timeoutMillis)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isActiveNotCancelled",
                            "method_signature": "synchronized isActiveNotCancelled(boolean includePolyglotThreads)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isActive",
                            "method_signature": "synchronized isActive()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "hasActiveOtherThread",
                            "method_signature": " hasActiveOtherThread(boolean includePolyglotThreads, boolean includeLeaveAndEnterThreads)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "hasAliveOtherPolyglotThread",
                            "method_signature": " hasAliveOtherPolyglotThread()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "notifyThreadClosed",
                            "method_signature": "private notifyThreadClosed(PolyglotThreadInfo info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addRootPointersForContext",
                            "method_signature": "private addRootPointersForContext(List<Object> heapRoots)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setCancelling",
                            "method_signature": "private setCancelling(boolean resourceLimit, String message)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "submitCancellationThreadLocalAction",
                            "method_signature": "private submitCancellationThreadLocalAction(List<Future<Void>> futures)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setExiting",
                            "method_signature": "private setExiting(PolyglotContextImpl triggeringParent, int code, String message, boolean skipPendingExit)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setClosedState",
                            "method_signature": "private setClosedState()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "restoreFromClosingState",
                            "method_signature": "private restoreFromClosingState(boolean cancelOperation)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "closeImpl",
                            "method_signature": "@SuppressWarnings({\"fallthrough\"})\n    @SuppressFBWarnings(\"UL_UNRELEASED_LOCK_EXCEPTION_PATH\") closeImpl(boolean notifyInstruments)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "waitUntilInvalid",
                            "method_signature": "private waitUntilInvalid()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "clearExplicitContextStack",
                            "method_signature": "synchronized clearExplicitContextStack()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "finishClose",
                            "method_signature": "private finishClose(boolean cancelOrExitOperation, boolean notifyInstruments)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "closeChildContexts",
                            "method_signature": "private closeChildContexts(boolean notifyInstruments)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "finishCleanup",
                            "method_signature": " finishCleanup()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "disposeContext",
                            "method_signature": "private disposeContext()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "exitContextNotification",
                            "method_signature": "private exitContextNotification(TruffleLanguage.ExitMode exitMode, int code)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "finalizeContext",
                            "method_signature": "private finalizeContext(boolean notifyInstruments, boolean mustSucceed)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "maybeSendInterrupt",
                            "method_signature": "synchronized maybeSendInterrupt()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getLocal",
                            "method_signature": " getLocal(LocalLocation l)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getThreadLocal",
                            "method_signature": "@TruffleBoundary\n    synchronized getThreadLocal(LocalLocation l, Thread t)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "initializeThreadLocals",
                            "method_signature": " initializeThreadLocals(PolyglotThreadInfo threadInfo)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "initializeContextLocals",
                            "method_signature": " initializeContextLocals()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "initializeInstrumentContextLocals",
                            "method_signature": " initializeInstrumentContextLocals(Object[] locals)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "initializeInstrumentContextThreadLocals",
                            "method_signature": " initializeInstrumentContextThreadLocals()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "invokeLocalsFactories",
                            "method_signature": " invokeLocalsFactories(LocalLocation[] contextLocalLocations, LocalLocation[] contextThreadLocalLocations)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "resizeThreadLocals",
                            "method_signature": " resizeThreadLocals(StableLocalLocations locations)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "resizeContextThreadLocals",
                            "method_signature": " resizeContextThreadLocals(StableLocalLocations locations)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "resizeLocals",
                            "method_signature": " resizeLocals(StableLocalLocations locations)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "resizeContextLocals",
                            "method_signature": " resizeContextLocals(StableLocalLocations locations)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "invokeContextThreadLocalFactory",
                            "method_signature": " invokeContextThreadLocalFactory(LocalLocation[] locations)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "patch",
                            "method_signature": " patch(PolyglotContextConfig newConfig)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "initializeHostContext",
                            "method_signature": "@SuppressWarnings(\"unchecked\") initializeHostContext(PolyglotLanguageContext context, PolyglotContextConfig newConfig)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replayInstrumentationEvents",
                            "method_signature": " replayInstrumentationEvents()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "checkSubProcessFinished",
                            "method_signature": "private synchronized checkSubProcessFinished()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "preinitialize",
                            "method_signature": "static preinitialize(final PolyglotEngineImpl engine, final PreinitConfig preinitConfig, PolyglotSharingLayer sharableLayer, Set<PolyglotLanguage> languagesToPreinitialize,\n                    boolean emitWarning)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "languageHomes",
                            "method_signature": "private languageHomes(PolyglotEngineImpl engine, Map<String, Path> languageHomes)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "freeSharing",
                            "method_signature": " freeSharing(PolyglotContextImpl context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "runOnCancelled",
                            "method_signature": "@TruffleBoundary runOnCancelled()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "runOnExited",
                            "method_signature": "@TruffleBoundary runOnExited(int code)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "runOnClosed",
                            "method_signature": "@TruffleBoundary runOnClosed()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addSystemThread",
                            "method_signature": "synchronized addSystemThread(LanguageSystemThread thread)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "pause",
                            "method_signature": "synchronized pause()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getLocal",
                            "method_signature": " getLocal(LocalLocation l)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "restoreFromClosingState",
                            "method_signature": "private restoreFromClosingState(boolean cancelOperation)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "shouldCacheThreadInfo",
                            "method_signature": "private shouldCacheThreadInfo()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setClosedState",
                            "method_signature": "private setClosedState()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getInstrumentContextOptions",
                            "method_signature": " getInstrumentContextOptions(PolyglotInstrument instrument)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getContext",
                            "method_signature": " getContext(PolyglotLanguage language)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getContextImpl",
                            "method_signature": " getContextImpl(PolyglotLanguage language)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "cancel",
                            "method_signature": " cancel(boolean resourceLimit, String message)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createContextArray",
                            "method_signature": "private createContextArray()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "notifyThreadClosed",
                            "method_signature": "private notifyThreadClosed(PolyglotThreadInfo info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "checkClosedOrDisposing",
                            "method_signature": " checkClosedOrDisposing(boolean mustSucceed)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "closeImpl",
                            "method_signature": "@SuppressWarnings({\"fallthrough\"})\n    @SuppressFBWarnings(\"UL_UNRELEASED_LOCK_EXCEPTION_PATH\") closeImpl(boolean notifyInstruments)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addChildContext",
                            "method_signature": " addChildContext(PolyglotContextImpl child)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getThreadLocal",
                            "method_signature": "@TruffleBoundary\n    synchronized getThreadLocal(LocalLocation l, Thread t)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "synchronized pause()": {
                        "first": {
                            "method_name": "pause",
                            "method_signature": "synchronized pause()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3536119136787621
                    },
                    " getLocal(LocalLocation l)": {
                        "first": {
                            "method_name": "getLocal",
                            "method_signature": " getLocal(LocalLocation l)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.36074834877266587
                    },
                    "private restoreFromClosingState(boolean cancelOperation)": {
                        "first": {
                            "method_name": "restoreFromClosingState",
                            "method_signature": "private restoreFromClosingState(boolean cancelOperation)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4026669077804914
                    },
                    "private shouldCacheThreadInfo()": {
                        "first": {
                            "method_name": "shouldCacheThreadInfo",
                            "method_signature": "private shouldCacheThreadInfo()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.43511808990390044
                    },
                    "private setClosedState()": {
                        "first": {
                            "method_name": "setClosedState",
                            "method_signature": "private setClosedState()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4476951512971761
                    },
                    " getInstrumentContextOptions(PolyglotInstrument instrument)": {
                        "first": {
                            "method_name": "getInstrumentContextOptions",
                            "method_signature": " getInstrumentContextOptions(PolyglotInstrument instrument)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4529882889797103
                    },
                    " getContext(PolyglotLanguage language)": {
                        "first": {
                            "method_name": "getContext",
                            "method_signature": " getContext(PolyglotLanguage language)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.46081850243995665
                    },
                    " getContextImpl(PolyglotLanguage language)": {
                        "first": {
                            "method_name": "getContextImpl",
                            "method_signature": " getContextImpl(PolyglotLanguage language)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4652557227280419
                    },
                    " cancel(boolean resourceLimit, String message)": {
                        "first": {
                            "method_name": "cancel",
                            "method_signature": " cancel(boolean resourceLimit, String message)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.48723455107308056
                    },
                    "private createContextArray()": {
                        "first": {
                            "method_name": "createContextArray",
                            "method_signature": "private createContextArray()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4977474696211702
                    },
                    "private notifyThreadClosed(PolyglotThreadInfo info)": {
                        "first": {
                            "method_name": "notifyThreadClosed",
                            "method_signature": "private notifyThreadClosed(PolyglotThreadInfo info)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4977676526770797
                    },
                    " checkClosedOrDisposing(boolean mustSucceed)": {
                        "first": {
                            "method_name": "checkClosedOrDisposing",
                            "method_signature": " checkClosedOrDisposing(boolean mustSucceed)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.500054378453249
                    },
                    "@SuppressWarnings({\"fallthrough\"})\n    @SuppressFBWarnings(\"UL_UNRELEASED_LOCK_EXCEPTION_PATH\") closeImpl(boolean notifyInstruments)": {
                        "first": {
                            "method_name": "closeImpl",
                            "method_signature": "@SuppressWarnings({\"fallthrough\"})\n    @SuppressFBWarnings(\"UL_UNRELEASED_LOCK_EXCEPTION_PATH\") closeImpl(boolean notifyInstruments)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5064428869922042
                    },
                    " addChildContext(PolyglotContextImpl child)": {
                        "first": {
                            "method_name": "addChildContext",
                            "method_signature": " addChildContext(PolyglotContextImpl child)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.523010996316443
                    },
                    "@TruffleBoundary\n    synchronized getThreadLocal(LocalLocation l, Thread t)": {
                        "first": {
                            "method_name": "getThreadLocal",
                            "method_signature": "@TruffleBoundary\n    synchronized getThreadLocal(LocalLocation l, Thread t)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.536123021145314
                    }
                },
                "voyage": {
                    "@TruffleBoundary runOnExited(int code)": {
                        "first": {
                            "method_name": "runOnExited",
                            "method_signature": "@TruffleBoundary runOnExited(int code)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2876788734308428
                    },
                    "private waitUntilInvalid()": {
                        "first": {
                            "method_name": "waitUntilInvalid",
                            "method_signature": "private waitUntilInvalid()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3028022906499557
                    },
                    "@TruffleBoundary runOnCancelled()": {
                        "first": {
                            "method_name": "runOnCancelled",
                            "method_signature": "@TruffleBoundary runOnCancelled()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.30626343865310934
                    },
                    "private shouldCacheThreadInfo()": {
                        "first": {
                            "method_name": "shouldCacheThreadInfo",
                            "method_signature": "private shouldCacheThreadInfo()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.30993862744088657
                    },
                    " getInstrumentContextOptions(PolyglotInstrument instrument)": {
                        "first": {
                            "method_name": "getInstrumentContextOptions",
                            "method_signature": " getInstrumentContextOptions(PolyglotInstrument instrument)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.36398860732277044
                    },
                    "private synchronized checkSubProcessFinished()": {
                        "first": {
                            "method_name": "checkSubProcessFinished",
                            "method_signature": "private synchronized checkSubProcessFinished()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.36399444633855904
                    },
                    "@TruffleBoundary runOnClosed()": {
                        "first": {
                            "method_name": "runOnClosed",
                            "method_signature": "@TruffleBoundary runOnClosed()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.36504768069155885
                    },
                    "private checkCancelled()": {
                        "first": {
                            "method_name": "checkCancelled",
                            "method_signature": "private checkCancelled()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.37173128985468945
                    },
                    " resume(Future<Void> pauseFuture)": {
                        "first": {
                            "method_name": "resume",
                            "method_signature": " resume(Future<Void> pauseFuture)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.37207597268418147
                    },
                    "@TruffleBoundary\n    static printResult(PolyglotLanguageContext languageContext, Object result)": {
                        "first": {
                            "method_name": "printResult",
                            "method_signature": "@TruffleBoundary\n    static printResult(PolyglotLanguageContext languageContext, Object result)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.37294645298638046
                    },
                    "public requirePublicLanguage(String languageId)": {
                        "first": {
                            "method_name": "requirePublicLanguage",
                            "method_signature": "public requirePublicLanguage(String languageId)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.38288368266555173
                    },
                    " claimSharingLayer(PolyglotSharingLayer sharableLayer, Set<PolyglotLanguage> languages)": {
                        "first": {
                            "method_name": "claimSharingLayer",
                            "method_signature": " claimSharingLayer(PolyglotSharingLayer sharableLayer, Set<PolyglotLanguage> languages)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3855694254343347
                    },
                    "private languageHomes(PolyglotEngineImpl engine, Map<String, Path> languageHomes)": {
                        "first": {
                            "method_name": "languageHomes",
                            "method_signature": "private languageHomes(PolyglotEngineImpl engine, Map<String, Path> languageHomes)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.40161783907429643
                    },
                    "private isAdditionalTransitionConditionSatisfied(State fromState, State toState)": {
                        "first": {
                            "method_name": "isAdditionalTransitionConditionSatisfied",
                            "method_signature": "private isAdditionalTransitionConditionSatisfied(State fromState, State toState)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4044312450565545
                    },
                    " migrateHostWrapper(PolyglotWrapper wrapper)": {
                        "first": {
                            "method_name": "migrateHostWrapper",
                            "method_signature": " migrateHostWrapper(PolyglotWrapper wrapper)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.40813653092940116
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private notifyThreadClosed(PolyglotThreadInfo info)",
                        "private restoreFromClosingState(boolean cancelOperation)",
                        "private setClosedState()",
                        " checkClosedOrDisposing(boolean mustSucceed)",
                        " getContext(PolyglotLanguage language)",
                        " getContextImpl(PolyglotLanguage language)",
                        "private shouldCacheThreadInfo()",
                        " getInstrumentContextOptions(PolyglotInstrument instrument)",
                        " cancel(boolean resourceLimit, String message)",
                        " addChildContext(PolyglotContextImpl child)",
                        "private createContextArray()",
                        " getLocal(LocalLocation l)",
                        "@TruffleBoundary\n    synchronized getThreadLocal(LocalLocation l, Thread t)",
                        "synchronized pause()",
                        "@SuppressWarnings({\"fallthrough\"})\n    @SuppressFBWarnings(\"UL_UNRELEASED_LOCK_EXCEPTION_PATH\") closeImpl(boolean notifyInstruments)"
                    ],
                    "llm_response_time": 12905
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "private restoreFromClosingState(boolean cancelOperation)",
                        "private setClosedState()",
                        "private shouldCacheThreadInfo()",
                        "synchronized pause()"
                    ],
                    "llm_response_time": 6274
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private restoreFromClosingState(boolean cancelOperation)",
                        "synchronized pause()"
                    ],
                    "llm_response_time": 5221
                },
                "voyage": {
                    "priority_method_names": [
                        "private checkCancelled()",
                        "private isAdditionalTransitionConditionSatisfied(State fromState, State toState)",
                        "private shouldCacheThreadInfo()",
                        "private waitUntilInvalid()",
                        "private synchronized checkSubProcessFinished()",
                        " resume(Future<Void> pauseFuture)",
                        " migrateHostWrapper(PolyglotWrapper wrapper)",
                        " getInstrumentContextOptions(PolyglotInstrument instrument)",
                        " claimSharingLayer(PolyglotSharingLayer sharableLayer, Set<PolyglotLanguage> languages)",
                        "@TruffleBoundary\n    static printResult(PolyglotLanguageContext languageContext, Object result)",
                        "private languageHomes(PolyglotEngineImpl engine, Map<String, Path> languageHomes)",
                        "public requirePublicLanguage(String languageId)",
                        "@TruffleBoundary runOnCancelled()",
                        "@TruffleBoundary runOnExited(int code)",
                        "@TruffleBoundary runOnClosed()"
                    ],
                    "llm_response_time": 5609
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private shouldCacheThreadInfo()",
                        "private waitUntilInvalid()",
                        " getInstrumentContextOptions(PolyglotInstrument instrument)",
                        "@TruffleBoundary runOnExited(int code)",
                        "@TruffleBoundary runOnCancelled()"
                    ],
                    "llm_response_time": 6235
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private waitUntilInvalid()",
                        "@TruffleBoundary runOnExited(int code)",
                        "@TruffleBoundary runOnCancelled()"
                    ],
                    "llm_response_time": 7544
                }
            },
            "targetClassMap": {
                "pause": {
                    "target_classes": [
                        {
                            "class_name": "State",
                            "similarity_score": 0.056026919468442814
                        },
                        {
                            "class_name": "ContextWeakReference",
                            "similarity_score": 0.20412414523193154
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ContextWeakReference",
                        "State"
                    ],
                    "llm_response_time": 2172,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "getLocal": {
                    "target_classes": [
                        {
                            "class_name": "State",
                            "similarity_score": 0.08404037920266422
                        },
                        {
                            "class_name": "PolyglotThreadInfo",
                            "similarity_score": 0.3775074500263143
                        },
                        {
                            "class_name": "PolyglotEngineImpl",
                            "similarity_score": 0.35260854049394713
                        },
                        {
                            "class_name": "PolyglotBindings",
                            "similarity_score": 0.4169260787524219
                        },
                        {
                            "class_name": "ContextWeakReference",
                            "similarity_score": 0.3061862178478973
                        },
                        {
                            "class_name": "PolyglotContextConfig",
                            "similarity_score": 0.30856826074348387
                        },
                        {
                            "class_name": "FinalIntMap",
                            "similarity_score": 0.32534824027410336
                        },
                        {
                            "class_name": "ObjectSizeCalculator",
                            "similarity_score": 0.3406155031587283
                        },
                        {
                            "class_name": "PolyglotThreadLocalActions",
                            "similarity_score": 0.35121422337632646
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PolyglotEngineImpl",
                        "PolyglotBindings",
                        "PolyglotThreadInfo"
                    ],
                    "llm_response_time": 6373,
                    "similarity_computation_time": 14,
                    "similarity_metric": "cosine"
                },
                "restoreFromClosingState": {
                    "target_classes": [
                        {
                            "class_name": "State",
                            "similarity_score": 0.18420293550998923
                        },
                        {
                            "class_name": "ContextWeakReference",
                            "similarity_score": 0.23850748942291627
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "State",
                        "ContextWeakReference"
                    ],
                    "llm_response_time": 4788,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "shouldCacheThreadInfo": {
                    "target_classes": [
                        {
                            "class_name": "State",
                            "similarity_score": 0.12162781311465798
                        },
                        {
                            "class_name": "ContextWeakReference",
                            "similarity_score": 0.40004734568283146
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "State",
                        "ContextWeakReference"
                    ],
                    "llm_response_time": 2625,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "setClosedState": {
                    "target_classes": [
                        {
                            "class_name": "State",
                            "similarity_score": 0.25700440352069015
                        },
                        {
                            "class_name": "ContextWeakReference",
                            "similarity_score": 0.26196841599779197
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "State",
                        "ContextWeakReference"
                    ],
                    "llm_response_time": 2694,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "getInstrumentContextOptions": {
                    "target_classes": [
                        {
                            "class_name": "PolyglotInstrument",
                            "similarity_score": 0.546955666259824
                        },
                        {
                            "class_name": "State",
                            "similarity_score": 0.12705711054732238
                        },
                        {
                            "class_name": "PolyglotThreadInfo",
                            "similarity_score": 0.43794223134592525
                        },
                        {
                            "class_name": "PolyglotEngineImpl",
                            "similarity_score": 0.440014099154925
                        },
                        {
                            "class_name": "PolyglotSharingLayer",
                            "similarity_score": 0.42252766682260906
                        },
                        {
                            "class_name": "PolyglotBindings",
                            "similarity_score": 0.5102695573087364
                        },
                        {
                            "class_name": "PolyglotLanguage",
                            "similarity_score": 0.5418654098282415
                        },
                        {
                            "class_name": "ContextWeakReference",
                            "similarity_score": 0.38575837490522974
                        },
                        {
                            "class_name": "PolyglotContextConfig",
                            "similarity_score": 0.34783741772067367
                        },
                        {
                            "class_name": "FinalIntMap",
                            "similarity_score": 0.32792020314581577
                        },
                        {
                            "class_name": "ObjectSizeCalculator",
                            "similarity_score": 0.4416191301757055
                        },
                        {
                            "class_name": "PolyglotThreadLocalActions",
                            "similarity_score": 0.4592684064170613
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PolyglotInstrument",
                        "PolyglotLanguage",
                        "PolyglotBindings"
                    ],
                    "llm_response_time": 3509,
                    "similarity_computation_time": 10,
                    "similarity_metric": "cosine"
                },
                "getContext": {
                    "target_classes": [
                        {
                            "class_name": "PolyglotLanguage",
                            "similarity_score": 0.5418654098282415
                        },
                        {
                            "class_name": "State",
                            "similarity_score": 0.12705711054732238
                        },
                        {
                            "class_name": "PolyglotThreadInfo",
                            "similarity_score": 0.44359309884716297
                        },
                        {
                            "class_name": "PolyglotSharingLayer",
                            "similarity_score": 0.4347945990852009
                        },
                        {
                            "class_name": "PolyglotBindings",
                            "similarity_score": 0.5252774854648756
                        },
                        {
                            "class_name": "PolyglotLanguage",
                            "similarity_score": 0.5418654098282415
                        },
                        {
                            "class_name": "ContextWeakReference",
                            "similarity_score": 0.38575837490522974
                        },
                        {
                            "class_name": "PolyglotContextConfig",
                            "similarity_score": 0.34783741772067367
                        },
                        {
                            "class_name": "FinalIntMap",
                            "similarity_score": 0.32792020314581577
                        },
                        {
                            "class_name": "ObjectSizeCalculator",
                            "similarity_score": 0.44317962180176806
                        },
                        {
                            "class_name": "PolyglotThreadLocalActions",
                            "similarity_score": 0.4592684064170613
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PolyglotLanguage",
                        "PolyglotLanguage",
                        "PolyglotBindings"
                    ],
                    "llm_response_time": 2065,
                    "similarity_computation_time": 7,
                    "similarity_metric": "cosine"
                },
                "getContextImpl": {
                    "target_classes": [
                        {
                            "class_name": "PolyglotLanguage",
                            "similarity_score": 0.5384358819179362
                        },
                        {
                            "class_name": "State",
                            "similarity_score": 0.12705711054732238
                        },
                        {
                            "class_name": "PolyglotThreadInfo",
                            "similarity_score": 0.44924396634840075
                        },
                        {
                            "class_name": "PolyglotSharingLayer",
                            "similarity_score": 0.4334316066115796
                        },
                        {
                            "class_name": "PolyglotBindings",
                            "similarity_score": 0.5853091980894329
                        },
                        {
                            "class_name": "PolyglotLanguage",
                            "similarity_score": 0.5384358819179362
                        },
                        {
                            "class_name": "ContextWeakReference",
                            "similarity_score": 0.38575837490522974
                        },
                        {
                            "class_name": "PolyglotContextConfig",
                            "similarity_score": 0.36625233983529754
                        },
                        {
                            "class_name": "FinalIntMap",
                            "similarity_score": 0.3577311307045263
                        },
                        {
                            "class_name": "ObjectSizeCalculator",
                            "similarity_score": 0.48063142082726956
                        },
                        {
                            "class_name": "PolyglotThreadLocalActions",
                            "similarity_score": 0.46064759082071616
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PolyglotLanguage",
                        "PolyglotLanguage",
                        "PolyglotBindings"
                    ],
                    "llm_response_time": 2992,
                    "similarity_computation_time": 6,
                    "similarity_metric": "cosine"
                },
                "cancel": {
                    "target_classes": [
                        {
                            "class_name": "State",
                            "similarity_score": 0.07154948210500468
                        },
                        {
                            "class_name": "ContextWeakReference",
                            "similarity_score": 0.4287464628562721
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "State",
                        "ContextWeakReference"
                    ],
                    "llm_response_time": 2228,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "createContextArray": {
                    "target_classes": [
                        {
                            "class_name": "State",
                            "similarity_score": 0.06420342502573646
                        },
                        {
                            "class_name": "ContextWeakReference",
                            "similarity_score": 0.29127196471634353
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ContextWeakReference",
                        "State"
                    ],
                    "llm_response_time": 3488,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "notifyThreadClosed": {
                    "target_classes": [
                        {
                            "class_name": "PolyglotThreadInfo",
                            "similarity_score": 0.4868310562580341
                        },
                        {
                            "class_name": "State",
                            "similarity_score": 0.10394922519135033
                        },
                        {
                            "class_name": "PolyglotThreadInfo",
                            "similarity_score": 0.4868310562580341
                        },
                        {
                            "class_name": "PolyglotEngineImpl",
                            "similarity_score": 0.49151935903434557
                        },
                        {
                            "class_name": "PolyglotSharingLayer",
                            "similarity_score": 0.4860280620303846
                        },
                        {
                            "class_name": "PolyglotBindings",
                            "similarity_score": 0.4402873242404189
                        },
                        {
                            "class_name": "PolyglotLanguage",
                            "similarity_score": 0.4775527322016596
                        },
                        {
                            "class_name": "ContextWeakReference",
                            "similarity_score": 0.39848544566458644
                        },
                        {
                            "class_name": "PolyglotContextConfig",
                            "similarity_score": 0.4134217563682457
                        },
                        {
                            "class_name": "FinalIntMap",
                            "similarity_score": 0.3572157332402181
                        },
                        {
                            "class_name": "ObjectSizeCalculator",
                            "similarity_score": 0.4494188791110018
                        },
                        {
                            "class_name": "PolyglotThreadLocalActions",
                            "similarity_score": 0.5265642863372747
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PolyglotThreadInfo",
                        "PolyglotEngineImpl",
                        "PolyglotThreadLocalActions"
                    ],
                    "llm_response_time": 8283,
                    "similarity_computation_time": 10,
                    "similarity_metric": "cosine"
                },
                "checkClosedOrDisposing": {
                    "target_classes": [
                        {
                            "class_name": "State",
                            "similarity_score": 0.1176565308837299
                        },
                        {
                            "class_name": "ContextWeakReference",
                            "similarity_score": 0.4933000176438345
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "State",
                        "ContextWeakReference"
                    ],
                    "llm_response_time": 2500,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "closeImpl": {
                    "target_classes": [
                        {
                            "class_name": "State",
                            "similarity_score": 0.8536255476760131
                        },
                        {
                            "class_name": "ContextWeakReference",
                            "similarity_score": 0.15027143833665943
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "State",
                        "ContextWeakReference"
                    ],
                    "llm_response_time": 2516,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "addChildContext": {
                    "target_classes": [
                        {
                            "class_name": "State",
                            "similarity_score": 0.1202938538719346
                        },
                        {
                            "class_name": "ContextWeakReference",
                            "similarity_score": 0.4844813951249545
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "State",
                        "ContextWeakReference"
                    ],
                    "llm_response_time": 2730,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "getThreadLocal": {
                    "target_classes": [
                        {
                            "class_name": "State",
                            "similarity_score": 0.4493471984513753
                        },
                        {
                            "class_name": "ContextWeakReference",
                            "similarity_score": 0.27695585470349865
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ContextWeakReference",
                        "State"
                    ],
                    "llm_response_time": 1956,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "4943dd979eeaba50486f93ba4ff63ea9eb85160e",
        "url": "https://github.com/oracle/graal/commit/4943dd979eeaba50486f93ba4ff63ea9eb85160e",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public fireNodeEvent(e NodeEvent, node Node) : void extracted from private maybeNotifyInputChanged(node Node) : void in class jdk.graal.compiler.graph.Node & moved to class jdk.graal.compiler.graph.Graph",
            "leftSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                    "startLine": 1197,
                    "endLine": 1206,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "private maybeNotifyInputChanged(node Node) : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                    "startLine": 1200,
                    "endLine": 1200,
                    "startColumn": 13,
                    "endColumn": 66,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                    "startLine": 1202,
                    "endLine": 1202,
                    "startColumn": 17,
                    "endColumn": 69,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                    "startLine": 1201,
                    "endLine": 1203,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                    "startLine": 1201,
                    "endLine": 1203,
                    "startColumn": 35,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 700,
                    "endLine": 708,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public fireNodeEvent(e NodeEvent, node Node) : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 702,
                    "endLine": 702,
                    "startColumn": 13,
                    "endColumn": 53,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 704,
                    "endLine": 704,
                    "startColumn": 17,
                    "endColumn": 34,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 701,
                    "endLine": 707,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 701,
                    "endLine": 707,
                    "startColumn": 40,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                    "startLine": 1197,
                    "endLine": 1203,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "private maybeNotifyInputChanged(node Node) : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                    "startLine": 1200,
                    "endLine": 1200,
                    "startColumn": 13,
                    "endColumn": 69,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "graph.fireNodeEvent(Graph.NodeEvent.INPUT_CHANGED,node)"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 705,
                    "endLine": 705,
                    "startColumn": 17,
                    "endColumn": 28,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 703,
                    "endLine": 706,
                    "startColumn": 16,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 703,
                    "endLine": 706,
                    "startColumn": 13,
                    "endColumn": 33,
                    "codeElementType": "DO_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                }
            ],
            "isStatic": false
        },
        "ref_id": 488,
        "extraction_results": {
            "success": true,
            "newCommitHash": "ea3e8addca923104a2134a38798f312c9b108161",
            "newBranchName": "extract-fireNodeEvent-maybeNotifyInputChanged-9633a3f"
        },
        "telemetry": {
            "id": "bed5bc6d-36a3-448e-821e-809fb2972d35",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1761,
                "lineStart": 68,
                "lineEnd": 1828,
                "bodyLineStart": 68,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                "sourceCode": "/**\n * This class is the base class for all nodes. It represents a node that can be inserted in a\n * {@link Graph}.\n * <p>\n * Once a node has been added to a graph, it has a graph-unique {@link #id()}. Edges in the\n * subclasses are represented with annotated fields. There are two kind of edges: {@link Input} and\n * {@link Successor}. If a field of type {@link Node} is annotated with {@link Input} or\n * {@link Successor}, it must not be {@code null}. There is an edge from this node to the node\n * denoted by the field's value. A field annotated with {@link OptionalInput} is also such an edge\n * but it may be {@code null}.\n * <p>\n * Exactly one of {@link Input}, {@link OptionalInput}, or {@link Successor} must be applied to all\n * fields of a node that are of type {@link Node}. A field of type {@link NodeInputList} must be\n * annotated with {@link Input} or {@link OptionalInput}. A field of type {@link NodeSuccessorList}\n * must be annotated with {@link Successor}.\n * <p>\n * Nodes which are value numberable should implement the {@link ValueNumberable} interface.\n *\n * <h1>Assertions and Verification</h1>\n *\n * The Node class supplies the {@link #assertTrue(boolean, String, Object...)} and\n * {@link #assertFalse(boolean, String, Object...)} methods, which will check the supplied boolean\n * and throw a VerificationError if it has the wrong value. Both methods will always either throw an\n * exception or return true. They can thus be used within an assert statement, so that the check is\n * only performed if assertions are enabled.\n */\n@NodeInfo\npublic abstract class Node implements Cloneable, Formattable {\n\n    private static final Unsafe UNSAFE = getUnsafe();\n\n    public static final NodeClass<?> TYPE = null;\n\n    public static final boolean TRACK_CREATION_POSITION = Boolean.parseBoolean(Services.getSavedProperty(\"debug.graal.TrackNodeCreationPosition\"));\n\n    static final int DELETED_ID_START = -1000000000;\n    static final int INITIAL_ID = -1;\n    static final int ALIVE_ID_START = 0;\n\n    // The use of fully qualified class names here and in the rest\n    // of this file works around a problem javac has resolving symbols\n\n    /**\n     * Denotes a non-optional (non-null) node input. This should only be applied to fields of type\n     * {@link Node} or {@link NodeInputList}.\n     *\n     * Nodes that update fields of type {@link Node} outside of their constructor should call\n     * {@link Node#updateUsages(Node, Node)} just prior to the update.\n     */\n    @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)\n    @java.lang.annotation.Target(ElementType.FIELD)\n    public @interface Input {\n        InputType value() default InputType.Value;\n    }\n\n    /**\n     * Denotes an optional (nullable) node input. This should only be applied to fields of type\n     * {@link Node} or {@link NodeInputList}.\n     *\n     * Nodes that update fields of type {@link Node} outside of their constructor should call\n     * {@link Node#updateUsages(Node, Node)} just prior to the update.\n     */\n    @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)\n    @java.lang.annotation.Target(ElementType.FIELD)\n    public @interface OptionalInput {\n        InputType value() default InputType.Value;\n    }\n\n    /**\n     * Denotes a non-optional (non-null) node successor. This should only be applied to fields of\n     * type {@link Node} or {@link NodeSuccessorList}.\n     */\n    @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)\n    @java.lang.annotation.Target(ElementType.FIELD)\n    public @interface Successor {\n    }\n\n    /**\n     * Denotes that a parameter of an {@linkplain NodeIntrinsic intrinsic} method must be a compile\n     * time constant at all call sites to the intrinsic method.\n     */\n    @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)\n    @java.lang.annotation.Target(ElementType.PARAMETER)\n    public @interface ConstantNodeParameter {\n    }\n\n    /**\n     * Denotes an injected parameter in a {@linkplain NodeIntrinsic node intrinsic} constructor. If\n     * the constructor is called as part of node intrinsification, the node intrinsifier will inject\n     * an argument for the annotated parameter. Injected parameters must precede all non-injected\n     * parameters in a constructor. If the type of the annotated parameter is {@link Stamp}, the\n     * {@linkplain Stamp#javaType type} of the injected stamp is the return type of the annotated\n     * method (which cannot be {@code void}).\n     */\n    @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)\n    @java.lang.annotation.Target(ElementType.PARAMETER)\n    public @interface InjectedNodeParameter {\n    }\n\n    /**\n     * Annotates a method that can be replaced by a compiler intrinsic. A (resolved) call to the\n     * annotated method will be processed by a generated {@code InvocationPlugin} that calls either\n     * a factory method or a constructor corresponding with the annotated method. By default the\n     * intrinsics are implemented by invoking the constructor but a factory method may be used\n     * instead. To use a factory method the class implementing the intrinsic must be annotated with\n     * {@link NodeIntrinsicFactory}. To ease error checking of NodeIntrinsics all intrinsics are\n     * expected to be implemented in the same way, so it's not possible to mix constructor and\n     * factory intrinsification in the same class.\n     * <p>\n     * A factory method corresponding to an annotated method is a static method named\n     * {@code intrinsify} defined in the class denoted by {@link #value()}. In order, its signature\n     * is as follows:\n     * <ol>\n     * <li>A {@code GraphBuilderContext} parameter.</li>\n     * <li>A sequence of zero or more {@linkplain InjectedNodeParameter injected} parameters.</li>\n     * <li>Remaining parameters that match the declared parameters of the annotated method.</li>\n     * </ol>\n     * A constructor corresponding to an annotated method is defined in the class denoted by\n     * {@link #value()}. In order, its signature is as follows:\n     * <ol>\n     * <li>A sequence of zero or more {@linkplain InjectedNodeParameter injected} parameters.</li>\n     * <li>Remaining parameters that match the declared parameters of the annotated method.</li>\n     * </ol>\n     * There must be exactly one such factory method or constructor corresponding to a\n     * {@link NodeIntrinsic} annotated method.\n     */\n    @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)\n    @java.lang.annotation.Target(ElementType.METHOD)\n    public @interface NodeIntrinsic {\n\n        /**\n         * The class declaring the factory method or {@link Node} subclass declaring the constructor\n         * used to intrinsify a call to the annotated method. The default value is the class in\n         * which the annotated method is declared.\n         */\n        Class<?> value() default NodeIntrinsic.class;\n\n        /**\n         * If {@code true}, the factory method or constructor selected by the annotation must have\n         * an {@linkplain InjectedNodeParameter injected} {@link Stamp} parameter. Calling\n         * {@link AbstractPointerStamp#nonNull()} on the injected stamp is guaranteed to return\n         * {@code true}.\n         */\n        boolean injectedStampIsNonNull() default false;\n\n        /**\n         * If {@code true} then this is lowered into a node that has side effects.\n         */\n        boolean hasSideEffect() default false;\n    }\n\n    /**\n     * Marker annotation indicating that the class uses factory methods instead of constructors for\n     * intrinsification.\n     */\n    @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)\n    @java.lang.annotation.Target(ElementType.TYPE)\n    public @interface NodeIntrinsicFactory {\n    }\n\n    /**\n     * Marker for a node that can be replaced by another node via global value numbering. A\n     * {@linkplain NodeClass#isLeafNode() leaf} node can be replaced by another node of the same\n     * type that has exactly the same {@linkplain NodeClass#getData() data} values. A non-leaf node\n     * can be replaced by another node of the same type that has exactly the same data values as\n     * well as the same {@linkplain Node#inputs() inputs} and {@linkplain Node#successors()\n     * successors}.\n     */\n    public interface ValueNumberable {\n    }\n\n    /**\n     * Marker interface for nodes that contain other nodes. When the inputs to {@code this} change,\n     * users of {@code this} should also be placed on the work list for canonicalization.\n     *\n     * To illustrate this consider the following IR shape:\n     *\n     * <pre>\n     *                       Node n1\n     *                          |\n     *          IndirectInputCanonicalization\n     *          /               |            \\\n     *       usage1          usage2          usage3\n     * </pre>\n     *\n     * Now consider the following situation: this pattern is fully optimized, nothing can change.\n     * However, when the input node {@code n1} of {@code IndirectInputCanonicalization} changes to a\n     * new node {@code n2} suddenly the usage of {@code IndirectInputCanonicalization} can optimize\n     * itself: for example it can drop an input edge (any optimization is possible). Normally these\n     * patterns would be found by a full canonicalizer run, by implementing this interface\n     * incremental canonicalization will also consider the usages.\n     *\n     * <pre>\n     *                       NewNode n2\n     *                          |\n     *          IndirectInputCanonicalization\n     *          /               |            \\\n     *       usage1          usage2          usage3\n     * </pre>\n     *\n     * The pattern could optimize for example to\n     *\n     * <pre>\n     *                       NewNode n2---------------\n     *                          |                     |\n     *          IndirectInputCanonicalization         |\n     *          /               |                     |\n     *       usage1          usage2          usage3----\n     * </pre>\n     *\n     * where {@code usage3} completely skips {@code IndirectInputCanonicalization} now.\n     *\n     * Note that this is called {@code IndirectInputChangedCanonicalization} because {@code n1} is\n     * considered an indirect (transitive) input of {@code usage3}.\n     */\n    public interface IndirectInputChangedCanonicalization {\n    }\n\n    /**\n     * Marker interface for nodes where one input change can cause another input to optimize.\n     *\n     * Consider the following IR shape:\n     *\n     * <pre>\n     *            Node n1         Node n2\n     *               |               |\n     *          IndirectInputCanonicalization\n     * </pre>\n     *\n     * If now input {@code n1} is replaced by another node\n     *\n     * <pre>\n     *            NewNode n3      Node n2\n     *               |               |\n     *          IndirectInputCanonicalization\n     * </pre>\n     *\n     * this can cause n2 to optimize. This is especially relevant for local {@link Simplifiable}\n     * simplifications based on single input/usage patterns. Thus, in order to incrementally trigger\n     * the canonicalization of {@code n2} it is explicitly added to the worklist of the usage\n     * implements {@code InputsChangedCanonicalization}.\n     */\n    public interface InputsChangedCanonicalization {\n    }\n\n    /**\n     * The graph owning {@code this}.\n     */\n    private Graph graph;\n\n    /**\n     * @see #id()\n     */\n    int id;\n\n    // this next pointer is used in Graph to implement fast iteration over NodeClass types, it\n    // therefore points to the next Node of the same type.\n    Node typeCacheNext;\n\n    static final int INLINE_USAGE_COUNT = 2;\n    static final Node[] EMPTY_ARRAY = {};\n\n    /**\n     * Head of usage list (i.e. list of nodes that have {@code this} as an input). Note that each\n     * element denotes a specific usage so there can be duplicates in the list. For example, a\n     * {@code ConstNode} modeling a compile constant that is added to itself will show up twice in\n     * the usage list of the {@code AddNode}.\n     *\n     * The elements of the usage list in order are {@link #usage0}, {@link #usage1} and\n     * {@link #extraUsages}. The first null entry terminates the list.\n     */\n    Node usage0;\n    Node usage1;\n    Node[] extraUsages;\n    int extraUsagesCount;\n\n    private Node predecessor;\n    private NodeClass<? extends Node> nodeClass;\n\n    public static final int NOT_ITERABLE = -1;\n\n    static class NodeStackTrace {\n        final StackTraceElement[] stackTrace = new Throwable().getStackTrace();\n\n        private String getString(String label) {\n            StringBuilder sb = new StringBuilder();\n            if (label != null) {\n                sb.append(label).append(\": \");\n            }\n            for (StackTraceElement ste : stackTrace) {\n                sb.append(\"at \").append(ste.toString()).append('\\n');\n            }\n            return sb.toString();\n        }\n\n        String getStrackTraceString() {\n            return getString(null);\n        }\n\n        @Override\n        public String toString() {\n            return getString(getClass().getSimpleName());\n        }\n    }\n\n    static class NodeCreationStackTrace extends NodeStackTrace {\n    }\n\n    public static class NodeInsertionStackTrace extends NodeStackTrace {\n    }\n\n    @SuppressWarnings(\"this-escape\")\n    public Node(NodeClass<? extends Node> c) {\n        init(c);\n    }\n\n    final void init(NodeClass<? extends Node> c) {\n        assert c.getJavaClass() == this.getClass() : Assertions.errorMessageContext(\"c\", c, \"this\", this);\n        this.nodeClass = c;\n        id = INITIAL_ID;\n        extraUsages = EMPTY_ARRAY;\n        if (TRACK_CREATION_POSITION) {\n            setCreationPosition(new NodeCreationStackTrace());\n        }\n    }\n\n    /**\n     * Gets an identifier for {@code this} that is unique in the context of {@link #graph} iff\n     * {@code this.graph() != NULL && this.isAlive()}. The value returned by this method can change\n     * after the graph is {@linkplain Graph#maybeCompress() compressed}.\n     */\n    final int id() {\n        return id;\n    }\n\n    /**\n     * Gets the graph context of {@code this}.\n     */\n    public Graph graph() {\n        return graph;\n    }\n\n    /**\n     * Gets the option values associated with {@code this.graph()}.\n     */\n    public final OptionValues getOptions() {\n        return graph == null ? null : graph.getOptions();\n    }\n\n    /**\n     * Gets the debug context associated with {@code this.graph()}.\n     */\n    public final DebugContext getDebug() {\n        return graph.getDebug();\n    }\n\n    /**\n     * Returns an {@link NodeIterable iterable} which can be used to traverse all non-null input\n     * edges of {@code this}.\n     *\n     * @return an {@link NodeIterable iterable} for all non-null input edges.\n     */\n    public NodeIterable<Node> inputs() {\n        CompilationAlarm.checkProgress(this.graph);\n        return nodeClass.getInputIterable(this);\n    }\n\n    /**\n     * Returns an {@link Iterable iterable} which can be used to traverse all non-null input edges\n     * of {@code this}.\n     *\n     * @return an {@link Iterable iterable} for all non-null input edges.\n     */\n    public Iterable<Position> inputPositions() {\n        return nodeClass.getInputEdges().getPositionsIterable(this);\n    }\n\n    public abstract static class EdgeVisitor {\n\n        public abstract Node apply(Node source, Node target);\n\n    }\n\n    /**\n     * Applies the given visitor to all inputs of {@code this}.\n     *\n     * @param visitor the visitor to be applied to the inputs\n     */\n    public void applyInputs(EdgeVisitor visitor) {\n        nodeClass.applyInputs(this, visitor);\n    }\n\n    /**\n     * Applies the given visitor to all successors of {@code this}.\n     *\n     * @param visitor the visitor to be applied to the successors\n     */\n    public void applySuccessors(EdgeVisitor visitor) {\n        nodeClass.applySuccessors(this, visitor);\n    }\n\n    /**\n     * Returns an {@link NodeIterable iterable} which can be used to traverse all non-null successor\n     * edges of {@code this}.\n     *\n     * @return an {@link NodeIterable iterable} for all non-null successor edges.\n     */\n    public NodeIterable<Node> successors() {\n        assert !this.isDeleted() : this;\n        return nodeClass.getSuccessorIterable(this);\n    }\n\n    /**\n     * Returns an {@link Iterable iterable} which can be used to traverse all successor edge\n     * positions of {@code this}.\n     *\n     * @return an {@link Iterable iterable} for all successor edge positoins.\n     */\n    public Iterable<Position> successorPositions() {\n        return nodeClass.getSuccessorEdges().getPositionsIterable(this);\n    }\n\n    /**\n     * Gets the current number of usages {@code this} node has.\n     */\n    public int getUsageCount() {\n        if (usage0 == null) {\n            return 0;\n        }\n        if (usage1 == null) {\n            return 1;\n        }\n        return INLINE_USAGE_COUNT + extraUsagesCount;\n    }\n\n    /**\n     * Gets the list of nodes that use {@code this} (i.e., as an input).\n     */\n    public final NodeIterable<Node> usages() {\n        CompilationAlarm.checkProgress(this.graph);\n        return new NodeUsageIterable(this);\n    }\n\n    /**\n     * Checks whether {@code this} has no usages.\n     */\n    public final boolean hasNoUsages() {\n        return this.usage0 == null;\n    }\n\n    /**\n     * Checks whether {@code this} has usages.\n     */\n    public final boolean hasUsages() {\n        return this.usage0 != null;\n    }\n\n    /**\n     * Checks whether {@code this} has more than one usage.\n     */\n    public final boolean hasMoreThanOneUsage() {\n        return this.usage1 != null;\n    }\n\n    /**\n     * Checks whether {@code this} has exactly one usage.\n     */\n    public final boolean hasExactlyOneUsage() {\n        return hasUsages() && !hasMoreThanOneUsage();\n    }\n\n    /**\n     * Checks whether {@code this} has only one usage of type {@code inputType}.\n     *\n     * @param inputType the type of usages to look for\n     */\n    public final boolean hasExactlyOneUsageOfType(InputType inputType) {\n        int numUses = 0;\n        for (Node usage : usages()) {\n            for (Position pos : usage.inputPositions()) {\n                if (pos.get(usage) == this) {\n                    if (pos.getInputType() == inputType) {\n                        numUses++;\n                        if (numUses > 1) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        return numUses == 1;\n    }\n\n    /**\n     * Adds a given node to this node's {@linkplain #usages() usages}.\n     *\n     * @param node the node to add\n     */\n    void addUsage(Node node) {\n        incUsageModCount();\n        if (usage0 == null) {\n            usage0 = node;\n        } else if (usage1 == null) {\n            usage1 = node;\n        } else {\n            int length = extraUsages.length;\n            if (length == 0) {\n                extraUsages = new Node[4];\n            } else if (extraUsagesCount == length) {\n                Node[] newExtraUsages = new Node[length * 2 + 1];\n                System.arraycopy(extraUsages, 0, newExtraUsages, 0, length);\n                extraUsages = newExtraUsages;\n            }\n            extraUsages[extraUsagesCount++] = node;\n        }\n    }\n\n    private void movUsageFromEndTo(int destIndex) {\n        if (destIndex >= INLINE_USAGE_COUNT) {\n            movUsageFromEndToExtraUsages(destIndex - INLINE_USAGE_COUNT);\n        } else if (destIndex == 1) {\n            movUsageFromEndToIndexOne();\n        } else {\n            assert destIndex == 0 : destIndex;\n            movUsageFromEndToIndexZero();\n        }\n    }\n\n    private void movUsageFromEndToExtraUsages(int destExtraIndex) {\n        this.extraUsagesCount--;\n        Node n = extraUsages[extraUsagesCount];\n        extraUsages[destExtraIndex] = n;\n        extraUsages[extraUsagesCount] = null;\n    }\n\n    private void movUsageFromEndToIndexZero() {\n        if (extraUsagesCount > 0) {\n            this.extraUsagesCount--;\n            usage0 = extraUsages[extraUsagesCount];\n            extraUsages[extraUsagesCount] = null;\n        } else if (usage1 != null) {\n            usage0 = usage1;\n            usage1 = null;\n        } else {\n            usage0 = null;\n        }\n    }\n\n    private void movUsageFromEndToIndexOne() {\n        if (extraUsagesCount > 0) {\n            this.extraUsagesCount--;\n            usage1 = extraUsages[extraUsagesCount];\n            extraUsages[extraUsagesCount] = null;\n        } else {\n            assert usage1 != null;\n            usage1 = null;\n        }\n    }\n\n    /**\n     * Removes one occurrence of a given node from this node's {@linkplain #usages() usages}.\n     *\n     * @param node the node to remove\n     */\n    public boolean removeUsage(Node node) {\n        assert node != null;\n        // For large graphs, usage removal is performance critical.\n        // Furthermore, it is critical that this method maintains the invariant that the usage list\n        // has no null element preceding a non-null element.\n        if (usage0 == node) {\n            movUsageFromEndToIndexZero();\n            incUsageModCount();\n            return true;\n        }\n        if (usage1 == node) {\n            movUsageFromEndToIndexOne();\n            incUsageModCount();\n            return true;\n        }\n        for (int i = this.extraUsagesCount - 1; i >= 0; i--) {\n            if (extraUsages[i] == node) {\n                movUsageFromEndToExtraUsages(i);\n                incUsageModCount();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Removes all nodes in the provided set from {@code this} node's usages. This is significantly\n     * faster than repeated execution of {@link Node#removeUsage}.\n     */\n    public void removeUsages(EconomicSet<Node> toDelete) {\n        if (toDelete.size() == 0) {\n            return;\n        } else if (toDelete.size() == 1) {\n            removeUsage(toDelete.iterator().next());\n            return;\n        }\n\n        // requires iteration from back to front to check nodes prior to being moved to the front\n        for (int i = extraUsagesCount - 1; i >= 0; i--) {\n            if (toDelete.contains(extraUsages[i])) {\n                movUsageFromEndToExtraUsages(i);\n                incUsageModCount();\n            }\n        }\n        if (usage1 != null && toDelete.contains(usage1)) {\n            movUsageFromEndToIndexOne();\n            incUsageModCount();\n        }\n        if (usage0 != null && toDelete.contains(usage0)) {\n            movUsageFromEndToIndexZero();\n            incUsageModCount();\n        }\n    }\n\n    /**\n     * Removes all dead nodes from {@code this} node's usages. This is significantly faster than\n     * repeated execution of {@link Node#removeUsage}.\n     */\n    public void removeDeadUsages() {\n        // requires iteration from back to front to check nodes prior to being moved to the front\n        for (int i = extraUsagesCount - 1; i >= 0; i--) {\n            if (!extraUsages[i].isAlive()) {\n                movUsageFromEndToExtraUsages(i);\n                incUsageModCount();\n            }\n        }\n        if (usage1 != null && !usage1.isAlive()) {\n            movUsageFromEndToIndexOne();\n            incUsageModCount();\n        }\n        if (usage0 != null && !usage0.isAlive()) {\n            movUsageFromEndToIndexZero();\n            incUsageModCount();\n        }\n    }\n\n    public final Node predecessor() {\n        return predecessor;\n    }\n\n    public final int modCount() {\n        if (isNodeModificationCountsEnabled() && graph != null) {\n            return graph.getNodeModCount(this);\n        }\n        return 0;\n    }\n\n    final void incModCount() {\n        if (isNodeModificationCountsEnabled() && graph != null) {\n            graph.incNodeModCount(this);\n        }\n    }\n\n    final int usageModCount() {\n        if (isNodeModificationCountsEnabled() && graph != null) {\n            return graph.nodeUsageModCount(this);\n        }\n        return 0;\n    }\n\n    final void incUsageModCount() {\n        if (isNodeModificationCountsEnabled() && graph != null) {\n            graph.incNodeUsageModCount(this);\n        }\n    }\n\n    public final boolean isDeleted() {\n        return id <= DELETED_ID_START;\n    }\n\n    public final boolean isAlive() {\n        return id >= ALIVE_ID_START;\n    }\n\n    public final boolean isUnregistered() {\n        return id == INITIAL_ID;\n    }\n\n    /**\n     * Removes one occurrence of {@code this} from {@code oldInput}'s usages and adds it to\n     * {@code newInput}'s usages.\n     */\n    protected void updateUsages(Node oldInput, Node newInput) {\n        assert isAlive() && (newInput == null || newInput.isAlive()) : \"adding \" + newInput + \" to \" + this + \" instead of \" + oldInput;\n        if (oldInput != newInput) {\n            if (oldInput != null) {\n                boolean result = removeThisFromUsages(oldInput);\n                assertTrue(result, \"not found in usages, old input: %s\", oldInput);\n            }\n            maybeNotifyInputChanged(this);\n            if (newInput != null) {\n                newInput.addUsage(this);\n            }\n            if (oldInput != null && oldInput.hasNoUsages()) {\n                maybeNotifyZeroUsages(oldInput);\n            }\n        }\n    }\n\n    /**\n     * Updates the predecessor of the given nodes after a successor slot is changed from\n     * oldSuccessor to newSuccessor: removes {@code this} from oldSuccessor's predecessors and adds\n     * {@code this} to newSuccessor's predecessors.\n     */\n    protected void updatePredecessor(Node oldSuccessor, Node newSuccessor) {\n        assertTrue(isAlive() && (newSuccessor == null || newSuccessor.isAlive()) || newSuccessor == null && !isAlive(), \"adding %s to %s instead of %s\", newSuccessor, this, oldSuccessor);\n        assert graph == null || !graph.isFrozen();\n        if (oldSuccessor != newSuccessor) {\n            if (oldSuccessor != null) {\n                assertTrue(newSuccessor == null || oldSuccessor.predecessor == this, \"wrong predecessor in old successor (%s): %s, should be %s\", oldSuccessor, oldSuccessor.predecessor, this);\n                oldSuccessor.predecessor = null;\n            }\n            if (newSuccessor != null) {\n                assertTrue(newSuccessor.predecessor == null, \"unexpected non-null predecessor in new successor (%s): %s, this=%s\", newSuccessor, newSuccessor.predecessor, this);\n                newSuccessor.predecessor = this;\n                maybeNotifyInputChanged(newSuccessor);\n            }\n            maybeNotifyInputChanged(this);\n        }\n    }\n\n    void initialize(Graph newGraph) {\n        assertTrue(id == INITIAL_ID, \"unexpected id: %d\", id);\n        this.graph = newGraph;\n        newGraph.register(this);\n        NodeClass<? extends Node> nc = nodeClass;\n        nc.registerAtInputsAsUsage(this);\n        nc.registerAtSuccessorsAsPredecessor(this);\n    }\n\n    /**\n     * Information associated with {@code this}. A single value is stored directly in the field.\n     * Multiple values are stored by creating an Object[].\n     */\n    private Object annotation;\n\n    private <T> T getNodeInfo(Class<T> clazz) {\n        assert clazz != Object[].class;\n        if (annotation == null) {\n            return null;\n        }\n        if (clazz.isInstance(annotation)) {\n            return clazz.cast(annotation);\n        }\n        if (annotation.getClass() == Object[].class) {\n            Object[] annotations = (Object[]) annotation;\n            for (Object ann : annotations) {\n                if (clazz.isInstance(ann)) {\n                    return clazz.cast(ann);\n                }\n            }\n        }\n        return null;\n    }\n\n    private <T> void setNodeInfo(Class<T> clazz, T value) {\n        assert clazz != Object[].class;\n        if (annotation == null || clazz.isInstance(annotation)) {\n            // Replace the current value\n            this.annotation = value;\n        } else if (annotation.getClass() == Object[].class) {\n            Object[] annotations = (Object[]) annotation;\n            for (int i = 0; i < annotations.length; i++) {\n                if (clazz.isInstance(annotations[i])) {\n                    annotations[i] = value;\n                    return;\n                }\n            }\n            Object[] newAnnotations = Arrays.copyOf(annotations, annotations.length + 1);\n            newAnnotations[annotations.length] = value;\n            this.annotation = newAnnotations;\n        } else {\n            this.annotation = new Object[]{this.annotation, value};\n        }\n    }\n\n    /**\n     * Gets the source position information for {@code this} or null if it doesn't exist.\n     */\n    public NodeSourcePosition getNodeSourcePosition() {\n        return getNodeInfo(NodeSourcePosition.class);\n    }\n\n    /**\n     * Set the source position to {@code sourcePosition}. Setting it to null is ignored so that it's\n     * not accidentally cleared. Use {@link #clearNodeSourcePosition()} instead.\n     */\n    public void setNodeSourcePosition(NodeSourcePosition sourcePosition) {\n        if (sourcePosition == null) {\n            return;\n        }\n        setNodeInfo(NodeSourcePosition.class, sourcePosition);\n    }\n\n    public void clearNodeSourcePosition() {\n        setNodeInfo(NodeSourcePosition.class, null);\n    }\n\n    public NodeCreationStackTrace getCreationPosition() {\n        return getNodeInfo(NodeCreationStackTrace.class);\n    }\n\n    public void setCreationPosition(NodeCreationStackTrace trace) {\n        setNodeInfo(NodeCreationStackTrace.class, trace);\n    }\n\n    public NodeInsertionStackTrace getInsertionPosition() {\n        return getNodeInfo(NodeInsertionStackTrace.class);\n    }\n\n    public void setInsertionPosition(NodeInsertionStackTrace trace) {\n        setNodeInfo(NodeInsertionStackTrace.class, trace);\n    }\n\n    /**\n     * Update the source position only if it is null.\n     */\n    public void updateNodeSourcePosition(Supplier<NodeSourcePosition> sourcePositionSupp) {\n        if (this.getNodeSourcePosition() == null) {\n            setNodeSourcePosition(sourcePositionSupp.get());\n        }\n    }\n\n    public DebugCloseable withNodeSourcePosition() {\n        return graph.withNodeSourcePosition(this);\n    }\n\n    public final NodeClass<? extends Node> getNodeClass() {\n        return nodeClass;\n    }\n\n    public boolean isAllowedUsageType(InputType type) {\n        if (type == InputType.Value) {\n            return false;\n        }\n        return getNodeClass().getAllowedUsageTypes().contains(type);\n    }\n\n    private boolean checkReplaceWith(Node replacement) {\n        if (graph != null && graph.isFrozen()) {\n            fail(\"cannot modify frozen graph\");\n        }\n        if (replacement == this) {\n            fail(\"cannot replace a node with itself\");\n        }\n        if (isDeleted()) {\n            fail(\"cannot replace deleted node\");\n        }\n        if (replacement != null && replacement.isDeleted()) {\n            fail(\"cannot replace with deleted node %s\", replacement);\n        }\n        return true;\n    }\n\n    /**\n     * For each use of {@code this} in another node, replace it with {@code replacement}.\n     *\n     * This is shown by the graph transformation below where edges are from usages to inputs (e.g.\n     * {@code this} is an input of {@code n0}).\n     *\n     * Before:\n     *\n     * <pre>\n     *       this\n     *         ^\n     *         |\n     *        /|\\\n     *       / | \\\n     *      /  |  \\\n     *    n0  n1 ..nN\n     *\n     * </pre>\n     *\n     * After:\n     *\n     * <pre>\n     *     replacement\n     *         ^\n     *         |\n     *        /|\\\n     *       / | \\\n     *      /  |  \\\n     *    n0  n1 ..nN\n     * </pre>\n     *\n     * If {@code replacement == null}, then the edges are simply removed.\n     */\n    public final void replaceAtUsages(Node replacement) {\n        replaceAtAllUsages(replacement, false);\n    }\n\n    /**\n     * For each use of {@code this} in another node, {@code n}, replace it with {@code replacement}\n     * if {@code filter == null} or {@code filter.test(n) == true}.\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    public final void replaceAtUsages(Node replacement, Predicate<Node> filter) {\n        replaceAtUsages(replacement, filter, false, true);\n    }\n\n    /**\n     * For each use of {@code this} in another node, {@code n}, replace it with {@code replacement}\n     * if {@code filter == null} or {@code filter.test(n) == true}.\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    public final void replaceAtUsages(Node replacement, Predicate<Node> filter, boolean checkInvariants) {\n        replaceAtUsages(replacement, filter, false, checkInvariants);\n    }\n\n    /**\n     * For each use of {@code this} in another node, replace it with {@code replacement} and then\n     * {@linkplain #safeDelete() remove} {@code this} from the graph.\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    public final void replaceAtUsagesAndDelete(Node replacement) {\n        replaceAtUsages(replacement, null, true, true);\n        safeDelete();\n    }\n\n    /**\n     * For each use of {@code this} in another node, {@code n}, replace it with {@code replacement}\n     * if {@code filter == null} or {@code filter.test(n) == true}.\n     *\n     * @param forDeletion specifies if the caller will {@linkplain #safeDelete() remove}\n     *            {@code this} from the graph after this method returns\n     * @see #replaceAtUsages(Node)\n     */\n    private void replaceAtUsages(Node replacement, Predicate<Node> filter, boolean forDeletion, boolean checkInvariants) {\n        if (filter == null) {\n            replaceAtAllUsages(replacement, forDeletion);\n        } else {\n            replaceAtMatchingUsages(replacement, filter, forDeletion);\n        }\n        assert !checkInvariants || checkReplaceAtUsagesInvariants(replacement);\n    }\n\n    /**\n     * Subclasses can override this to check invariants related to replacing uses of {@code this}.\n     *\n     * @param replacement\n     * @return {@code true} if all invariants hold\n     */\n    protected boolean checkReplaceAtUsagesInvariants(Node replacement) {\n        return true;\n    }\n\n    /**\n     * For each use of {@code this} in another node, replace it with {@code replacement}.\n     *\n     * @param forDeletion specifies if the caller will {@linkplain #safeDelete() remove}\n     *            {@code this} from the graph after this method returns\n     */\n    public final void replaceAtAllUsages(Node replacement, boolean forDeletion) {\n        checkReplaceWith(replacement);\n        if (usage0 == null) {\n            return;\n        }\n        replaceAtUsage(replacement, forDeletion, usage0);\n        usage0 = null;\n\n        if (usage1 == null) {\n            return;\n        }\n        replaceAtUsage(replacement, forDeletion, usage1);\n        usage1 = null;\n\n        if (extraUsagesCount <= 0) {\n            return;\n        }\n        for (int i = 0; i < extraUsagesCount; i++) {\n            Node usage = extraUsages[i];\n            replaceAtUsage(replacement, forDeletion, usage);\n        }\n        this.extraUsages = EMPTY_ARRAY;\n        this.extraUsagesCount = 0;\n    }\n\n    /**\n     * For the use of {@code this} in another node represented by {@code usage}, replace it with\n     * {@code replacement}.\n     *\n     * @param forDeletion specifies if the caller will {@linkplain #safeDelete() remove}\n     *            {@code this} from the graph after this method returns\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    private void replaceAtUsage(Node replacement, boolean forDeletion, Node usage) {\n        boolean result = usage.getNodeClass().replaceFirstInput(usage, this, replacement);\n        assertTrue(result, \"not found in inputs, usage: %s\", usage);\n        /*\n         * Don't notify for nodes which are about to be deleted.\n         */\n        if (!forDeletion || usage != this) {\n            maybeNotifyInputChanged(usage);\n        }\n        if (replacement != null) {\n            replacement.addUsage(usage);\n        }\n    }\n\n    /**\n     * For each use of {@code this} in another node, {@code n}, replace it with {@code replacement}\n     * if {@code filter.test(n) == true}.\n     *\n     * @param forDeletion specifies if the caller will {@linkplain #safeDelete() remove}\n     *            {@code this} from the graph after this method returns\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    private void replaceAtMatchingUsages(Node replacement, Predicate<Node> filter, boolean forDeletion) {\n        Objects.requireNonNull(filter);\n        checkReplaceWith(replacement);\n        int i = 0;\n        int usageCount = this.getUsageCount();\n        while (i < usageCount) {\n            Node usage = this.getUsageAt(i);\n            if (filter.test(usage)) {\n                replaceAtUsage(replacement, forDeletion, usage);\n                this.movUsageFromEndTo(i);\n                usageCount--;\n            } else {\n                ++i;\n            }\n        }\n    }\n\n    private Node getUsageAt(int index) {\n        if (index == 0) {\n            return this.usage0;\n        } else if (index == 1) {\n            return this.usage1;\n        } else {\n            return this.extraUsages[index - INLINE_USAGE_COUNT];\n        }\n    }\n\n    public Node singleUsage() {\n        assert hasExactlyOneUsage();\n        return this.usage0;\n    }\n\n    /**\n     * For each use of {@code this} in another node, {@code n}, replace it with {@code replacement}\n     * if {@code filter.test(n) == true}.\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    public void replaceAtMatchingUsages(Node replacement, NodePredicate usagePredicate) {\n        checkReplaceWith(replacement);\n        replaceAtMatchingUsages(replacement, usagePredicate, false);\n    }\n\n    private void replaceAtUsagePos(Node replacement, Node usage, Position pos) {\n        pos.initialize(usage, replacement);\n        maybeNotifyInputChanged(usage);\n        if (replacement != null) {\n            replacement.addUsage(usage);\n        }\n    }\n\n    /**\n     * For each use of {@code this} in another node, {@code n}, replace it with {@code replacement}\n     * if the type of the use is {@code inputType}.\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    public void replaceAtUsages(Node replacement, InputType inputType) {\n        checkReplaceWith(replacement);\n        int i = 0;\n        int usageCount = this.getUsageCount();\n        if (usageCount == 0) {\n            return;\n        }\n        usages: while (i < usageCount) {\n            Node usage = this.getUsageAt(i);\n            for (Position pos : usage.inputPositions()) {\n                if (pos.getInputType() == inputType && pos.get(usage) == this) {\n                    replaceAtUsagePos(replacement, usage, pos);\n                    this.movUsageFromEndTo(i);\n                    usageCount--;\n                    continue usages;\n                }\n            }\n            i++;\n        }\n        if (hasNoUsages()) {\n            maybeNotifyZeroUsages(this);\n        }\n    }\n\n    /**\n     * For each use of {@code this} in another node, {@code n}, replace it with {@code replacement}\n     * if the type of the use is in {@code inputTypes}.\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    public void replaceAtUsages(Node replacement, InputType... inputTypes) {\n        checkReplaceWith(replacement);\n        int i = 0;\n        int usageCount = this.getUsageCount();\n        if (usageCount == 0) {\n            return;\n        }\n        usages: while (i < usageCount) {\n            Node usage = this.getUsageAt(i);\n            for (Position pos : usage.inputPositions()) {\n                for (InputType type : inputTypes) {\n                    if (pos.getInputType() == type && pos.get(usage) == this) {\n                        replaceAtUsagePos(replacement, usage, pos);\n                        this.movUsageFromEndTo(i);\n                        usageCount--;\n                        continue usages;\n                    }\n                }\n            }\n            i++;\n        }\n        if (hasNoUsages()) {\n            maybeNotifyZeroUsages(this);\n        }\n    }\n\n    private void maybeNotifyInputChanged(Node node) {\n        if (graph != null) {\n            assert !graph.isFrozen();\n            NodeEventListener listener = graph.nodeEventListener;\n            fireNodeEvent(node, listener);\n            graph.edgeModificationCount++;\n        }\n    }\n\n    private void fireNodeEvent(Node node, NodeEventListener listener) {\n        if (listener != null) {\n            listener.event(Graph.NodeEvent.INPUT_CHANGED, node);\n        }\n    }\n\n    /**\n     * Iterates over each {@link NodeEventListener} attached to {@code this.graph()} if\n     * {@code node.isAlive()} and notifies the listener that {@code node} has had its last usage\n     * removed.\n     */\n    public void maybeNotifyZeroUsages(Node node) {\n        if (graph != null && node.isAlive()) {\n            assert !graph.isFrozen();\n            NodeEventListener listener = graph.nodeEventListener;\n            if (listener != null) {\n                listener.event(Graph.NodeEvent.ZERO_USAGES, node);\n            }\n        }\n    }\n\n    /**\n     * Updates the control flow edge, if it exists, from {@link #predecessor()} to {@code this} to\n     * have a target of {@code replacement}.\n     */\n    public void replaceAtPredecessor(Node replacement) {\n        checkReplaceWith(replacement);\n        if (predecessor != null) {\n            if (!predecessor.getNodeClass().replaceFirstSuccessor(predecessor, this, replacement)) {\n                fail(\"not found in successors, predecessor: %s\", predecessor);\n            }\n            predecessor.updatePredecessor(this, replacement);\n        }\n    }\n\n    /**\n     * Replaces {@code this} at its predecessor (if any) and its usages with {@code replacement} and\n     * removes it from its graph.\n     */\n    public void replaceAndDelete(Node replacement) {\n        checkReplaceWith(replacement);\n        if (replacement == null) {\n            fail(\"cannot replace with null\");\n        }\n        if (this.hasUsages()) {\n            replaceAtUsages(replacement);\n        }\n        replaceAtPredecessor(replacement);\n        this.safeDelete();\n    }\n\n    /**\n     * Finds the first {@link Successor} in {@code this} whose value is {@code oldSuccessor} and\n     * replaces it with {@code newSuccessor}. The predecessor fields in {@code oldSuccessor} and\n     * {@code newSuccessor} are updated to reflect any change made.\n     */\n    public void replaceFirstSuccessor(Node oldSuccessor, Node newSuccessor) {\n        if (nodeClass.replaceFirstSuccessor(this, oldSuccessor, newSuccessor)) {\n            updatePredecessor(oldSuccessor, newSuccessor);\n        }\n    }\n\n    /**\n     * Finds the first {@link Input} or {@link OptionalInput} in {@code this} whose value is\n     * {@code oldInput} and replaces it with {@code newInput}. If the input is changed, the usage\n     * info for {@code oldInput} and {@code newInput} is updated as well.\n     *\n     * Before {@code this.replaceFirstInput(n0, n2)}:\n     *\n     * <pre>\n     *       n0  n1  n0\n     *        \\  |  /\n     *         \\ | /\n     *          \\|/\n     *           |\n     *           V\n     *         this\n     * </pre>\n     *\n     * After {@code this.replaceFirstInput(n0, n2)}:\n     *\n     * <pre>\n     *       n2  n1  n0\n     *        \\  |  /\n     *         \\ | /\n     *          \\|/\n     *           |\n     *           V\n     *         this\n     * </pre>\n     */\n    public void replaceFirstInput(Node oldInput, Node newInput) {\n        if (nodeClass.replaceFirstInput(this, oldInput, newInput)) {\n            updateUsages(oldInput, newInput);\n        }\n    }\n\n    /**\n     * Finds all {@link Input}s and {@link OptionalInput}s in {@code this} whose value is\n     * {@code oldInput} and replaces them with {@code newInput}. If any input is changed, the usage\n     * info for {@code oldInput} and {@code newInput} is updated as well.\n     *\n     * Before {@code this.replaceAllInputs(n0, n2)}:\n     *\n     * <pre>\n     *       n0  n1  n0\n     *        \\  |  /\n     *         \\ | /\n     *          \\|/\n     *           |\n     *           V\n     *         this\n     * </pre>\n     *\n     * After {@code this.replaceAllInputs(n0, n2)}:\n     *\n     * <pre>\n     *       n2  n1  n2\n     *        \\  |  /\n     *         \\ | /\n     *          \\|/\n     *           |\n     *           V\n     *         this\n     * </pre>\n     */\n    public void replaceAllInputs(Node oldInput, Node newInput) {\n        while (nodeClass.replaceFirstInput(this, oldInput, newInput)) {\n            updateUsages(oldInput, newInput);\n        }\n    }\n\n    public void clearInputs() {\n        assertFalse(isDeleted(), \"cannot clear inputs of deleted node\");\n        getNodeClass().unregisterAtInputsAsUsage(this);\n    }\n\n    boolean removeThisFromUsages(Node n) {\n        return n.removeUsage(this);\n    }\n\n    public void clearSuccessors() {\n        assertFalse(isDeleted(), \"cannot clear successors of deleted node\");\n        getNodeClass().unregisterAtSuccessorsAsPredecessor(this);\n    }\n\n    private boolean checkDeletion() {\n        assertTrue(isAlive(), \"must be alive\");\n        assertTrue(hasNoUsages(), \"cannot delete node %s because of usages: %s\", this, usages());\n        assertTrue(predecessor == null, \"cannot delete node %s because of predecessor: %s\", this, predecessor);\n        return true;\n    }\n\n    /**\n     * Removes {@code this} from {@code this.graph()}. This node must have no\n     * {@linkplain Node#usages() usages} and no {@linkplain #predecessor() predecessor}.\n     */\n    public void safeDelete() {\n        assert checkDeletion();\n        this.clearInputs();\n        this.clearSuccessors();\n        markDeleted();\n    }\n\n    public void markDeleted() {\n        graph.unregister(this);\n        id = DELETED_ID_START - id;\n        assert isDeleted();\n    }\n\n    public final Node copyWithInputs() {\n        return copyWithInputs(true);\n    }\n\n    public final Node copyWithInputs(boolean insertIntoGraph) {\n        Node newNode = clone(insertIntoGraph ? graph : null, WithOnlyInputEdges);\n        if (insertIntoGraph) {\n            for (Node input : inputs()) {\n                input.addUsage(newNode);\n            }\n        }\n        return newNode;\n    }\n\n    /**\n     * @param newNode the result of cloning {@code this} or {@link Unsafe#allocateInstance(Class)\n     *            raw allocating} a copy of {@code this}\n     * @param type the type of edges to process\n     * @param edgesToCopy if {@code type} is in this set, the edges are copied otherwise they are\n     *            cleared\n     */\n    private void copyOrClearEdgesForClone(Node newNode, Edges.Type type, EnumSet<Edges.Type> edgesToCopy) {\n        if (edgesToCopy.contains(type)) {\n            getNodeClass().getEdges(type).copy(this, newNode);\n        } else {\n            // The direct edges are already null\n            getNodeClass().getEdges(type).initializeLists(newNode, this);\n        }\n    }\n\n    public static final EnumSet<Edges.Type> WithAllEdges = EnumSet.allOf(Edges.Type.class);\n    public static final EnumSet<Edges.Type> WithOnlyInputEdges = EnumSet.of(Edges.Type.Inputs);\n\n    /**\n     * Makes a copy of {@code this} in(to) a given graph.\n     *\n     * @param into the graph in which the copy will be registered (which may be\n     *            {@code this.graph()}) or null if the copy should not be registered in a graph\n     * @param edgesToCopy specifies the edges to be copied. The edges not specified in this set are\n     *            initialized to their default value (i.e., {@code null} for a direct edge, an empty\n     *            list for an edge list)\n     * @return the copy of {@code this}\n     */\n    final Node clone(Graph into, EnumSet<Edges.Type> edgesToCopy) {\n        final NodeClass<? extends Node> nodeClassTmp = getNodeClass();\n        boolean useIntoLeafNodeCache = false;\n        if (into != null) {\n            if (nodeClassTmp.valueNumberable() && nodeClassTmp.isLeafNode()) {\n                useIntoLeafNodeCache = true;\n                Node otherNode = into.findNodeInCache(this);\n                if (otherNode != null) {\n                    return otherNode;\n                }\n            }\n        }\n\n        Node newNode = null;\n        try {\n            newNode = (Node) UNSAFE.allocateInstance(getClass());\n            newNode.nodeClass = nodeClassTmp;\n            nodeClassTmp.getData().copy(this, newNode);\n            copyOrClearEdgesForClone(newNode, Type.Inputs, edgesToCopy);\n            copyOrClearEdgesForClone(newNode, Type.Successors, edgesToCopy);\n        } catch (Exception e) {\n            throw new GraalGraphError(e).addContext(this);\n        }\n        newNode.graph = into;\n        newNode.id = INITIAL_ID;\n        if (getNodeSourcePosition() != null && (into == null || into.trackNodeSourcePosition())) {\n            newNode.setNodeSourcePosition(getNodeSourcePosition());\n        }\n        if (getInsertionPosition() != null) {\n            newNode.setInsertionPosition(getInsertionPosition());\n        }\n        if (into != null) {\n            into.register(newNode);\n        }\n        newNode.extraUsages = EMPTY_ARRAY;\n\n        if (into != null && useIntoLeafNodeCache) {\n            into.putNodeIntoCache(newNode);\n        }\n        newNode.afterClone(this);\n        return newNode;\n    }\n\n    protected void afterClone(@SuppressWarnings(\"unused\") Node other) {\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected boolean verifyInputs() {\n        InputEdges inputEdges = nodeClass.getInputEdges();\n\n        // Verify properties of direct inputs\n        for (int i = 0; i < inputEdges.getDirectCount(); i++) {\n            Node input = (Node) inputEdges.get(this, i);\n            verifyInput(inputEdges, i, input);\n        }\n\n        // Verify properties of input list objects\n        for (int i = inputEdges.getDirectCount(); i < inputEdges.getCount(); i++) {\n            Object inputList = inputEdges.get(this, i);\n            if (inputList == null) {\n                assertTrue(inputEdges.isOptional(i), \"non-optional input list %s cannot be null in %s (fix nullness or use @OptionalInput)\", inputEdges.getName(i), this);\n            } else {\n                NodeList<Node> nodeList = (NodeList<Node>) inputList;\n                for (Node input : nodeList) {\n                    verifyInput(inputEdges, i, input);\n                }\n            }\n        }\n        return true;\n    }\n\n    private void verifyInput(InputEdges inputEdges, int i, Node input) {\n        if (input == null) {\n            assertTrue(inputEdges.isOptional(i), \"non-optional input %s cannot be null in %s (fix nullness or use @OptionalInput)\", inputEdges.getName(i), this);\n        } else {\n            assertFalse(input.isDeleted(), \"input was deleted %s\", input);\n            assertTrue(input.isAlive(), \"input is not alive yet, i.e., it was not yet added to the graph\");\n            InputType inputType = inputEdges.getInputType(i);\n            assertTrue(inputType == InputType.Unchecked || input.isAllowedUsageType(inputType), \"invalid usage type input:%s inputType:%s inputField:%s\", input,\n                            inputType, inputEdges.getName(i));\n            Class<?> expectedType = i < inputEdges.getDirectCount() ? inputEdges.getType(i) : Node.class;\n            assertTrue(expectedType.isAssignableFrom(input.getClass()), \"Invalid input type for %s: expected a %s but was a %s\", inputEdges.getName(i), expectedType, input.getClass());\n        }\n    }\n\n    public final boolean verify() {\n        return verify(true);\n    }\n\n    /**\n     * Basic verification of node properties. This method is final so that a node cannot\n     * accidentally skip calling super(). Node specific verification should be done in\n     * {@link #verifyNode()}.\n     */\n    public final boolean verify(boolean verifyInputs) {\n        assertTrue(isAlive(), \"cannot verify inactive node %s\", this);\n        assertTrue(graph != null, \"null graph\");\n        if (verifyInputs) {\n            verifyInputs();\n        }\n        if (graph.verifyGraphEdges) {\n            verifyEdges();\n        }\n        verifyNode();\n        return true;\n    }\n\n    /**\n     * Verify node properties which are not covered by {@link #verify()}.\n     */\n    protected boolean verifyNode() {\n        return true;\n    }\n\n    /**\n     * Perform expensive verification of inputs, usages, predecessors and successors.\n     *\n     * @return true\n     */\n    public boolean verifyEdges() {\n        for (Node input : inputs()) {\n            assertTrue(input == null || input.usages().contains(this), \"missing usage of %s in input %s\", this, input);\n        }\n\n        for (Node successor : successors()) {\n            assertTrue(successor.predecessor() == this, \"missing predecessor in %s (actual: %s)\", successor, successor.predecessor());\n            assertTrue(successor.graph == graph, \"mismatching graph in successor %s\", successor);\n        }\n        for (Node usage : usages()) {\n            assertFalse(usage.isDeleted(), \"usage %s must never be deleted\", usage);\n            assertTrue(usage.inputs().contains(this), \"missing input in usage %s\", usage);\n            boolean foundThis = false;\n            for (Position pos : usage.inputPositions()) {\n                if (pos.get(usage) == this) {\n                    foundThis = true;\n                    if (pos.getInputType() != InputType.Unchecked) {\n                        assertTrue(isAllowedUsageType(pos.getInputType()), \"invalid input of type %s from %s to %s (%s)\", pos.getInputType(), usage, this, pos.getName());\n                    }\n                }\n            }\n            assertTrue(foundThis, \"missing input in usage %s\", usage);\n        }\n\n        if (predecessor != null) {\n            assertFalse(predecessor.isDeleted(), \"predecessor %s must never be deleted\", predecessor);\n            assertTrue(predecessor.successors().contains(this), \"missing successor in predecessor %s\", predecessor);\n        }\n        return true;\n    }\n\n    public boolean assertTrue(boolean condition, String message, Object... args) {\n        if (condition) {\n            return true;\n        } else {\n            throw fail(message, args);\n        }\n    }\n\n    public boolean assertFalse(boolean condition, String message, Object... args) {\n        if (condition) {\n            throw fail(message, args);\n        } else {\n            return true;\n        }\n    }\n\n    protected GraalGraphError fail(String message, Object... args) throws GraalGraphError {\n        throw new GraalGraphError(message, args).addContext(this);\n    }\n\n    public Iterable<? extends Node> cfgPredecessors() {\n        if (predecessor == null) {\n            return Collections.emptySet();\n        } else {\n            return Collections.singleton(predecessor);\n        }\n    }\n\n    /**\n     * Returns an iterator that will provide all control-flow successors of {@code this}. Normally\n     * this will be the contents of all fields annotated with {@link Successor}, but some node\n     * classes (like EndNode) may return different nodes.\n     */\n    public Iterable<? extends Node> cfgSuccessors() {\n        return successors();\n    }\n\n    /**\n     * Nodes using their {@link #id} as the hash code. This works very well when nodes of the same\n     * graph are stored in sets. It can give bad behavior when storing nodes of different graphs in\n     * the same set.\n     */\n    @Override\n    public final int hashCode() {\n        assert !this.isUnregistered() : \"node not yet constructed\";\n        if (this.isDeleted()) {\n            return -id + DELETED_ID_START;\n        }\n        return id;\n    }\n\n    /*\n     * Do not overwrite the equality test of a node in subclasses. Equality tests must rely solely\n     * on identity.\n     */\n\n    /**\n     * Provides a {@link Map} of properties of {@code this} for use in debugging (e.g., to view in\n     * the ideal graph visualizer).\n     */\n    public final Map<Object, Object> getDebugProperties() {\n        return getDebugProperties(new HashMap<>());\n    }\n\n    /**\n     * Fills a {@link Map} with properties of {@code this} for use in debugging (e.g., to view in\n     * the ideal graph visualizer). Subclasses overriding this method should also fill the map using\n     * their superclass.\n     *\n     * @param map\n     */\n    public Map<Object, Object> getDebugProperties(Map<Object, Object> map) {\n        Fields properties = getNodeClass().getData();\n        for (int i = 0; i < properties.getCount(); i++) {\n            Object value = properties.get(this, i);\n            if (properties.getType(i) == Character.TYPE) {\n                // Convert a char to an int as chars are not guaranteed to printable/viewable\n                char ch = (char) value;\n                value = Integer.valueOf(ch);\n            }\n            map.put(properties.getName(i), value);\n        }\n        NodeSourcePosition pos = getNodeSourcePosition();\n        if (pos != null) {\n            map.put(\"nodeSourcePosition\", pos);\n        }\n        NodeCreationStackTrace creation = getCreationPosition();\n        if (creation != null) {\n            map.put(\"nodeCreationPosition\", creation.getStrackTraceString());\n        }\n        NodeInsertionStackTrace insertion = getInsertionPosition();\n        if (insertion != null) {\n            map.put(\"nodeInsertionPosition\", insertion.getStrackTraceString());\n        }\n        return map;\n    }\n\n    /**\n     * This method is a shortcut for {@link #toString(Verbosity)} with {@link Verbosity#Short}.\n     */\n    @Override\n    public final String toString() {\n        return toString(Verbosity.Short);\n    }\n\n    /**\n     * Creates a String representation for {@code this} with a given {@link Verbosity}.\n     */\n    public String toString(Verbosity verbosity) {\n        switch (verbosity) {\n            case Id:\n                return Integer.toString(id);\n            case Name:\n                return getNodeClass().shortName();\n            case Short:\n                return toString(Verbosity.Id) + \"|\" + toString(Verbosity.Name);\n            case Long:\n                return toString(Verbosity.Short);\n            case Debugger:\n            case All: {\n                StringBuilder str = new StringBuilder();\n                str.append(toString(Verbosity.Short)).append(\" { \");\n                for (Map.Entry<Object, Object> entry : getDebugProperties().entrySet()) {\n                    str.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\", \");\n                }\n                str.append(\" }\");\n                return str.toString();\n            }\n            default:\n                throw new RuntimeException(\"unknown verbosity: \" + verbosity);\n        }\n    }\n\n    @Deprecated\n    public int getId() {\n        return id;\n    }\n\n    @Deprecated\n    public int getIdBeforeDeletion() {\n        assert isDeleted();\n        return (id - DELETED_ID_START) * -1;\n    }\n\n    @Override\n    public void formatTo(Formatter formatter, int flags, int width, int precision) {\n        if ((flags & FormattableFlags.ALTERNATE) == FormattableFlags.ALTERNATE) {\n            formatter.format(\"%s\", toString(Verbosity.Id));\n        } else if ((flags & FormattableFlags.UPPERCASE) == FormattableFlags.UPPERCASE) {\n            // Use All here since Long is only slightly longer than Short.\n            formatter.format(\"%s\", toString(Verbosity.All));\n        } else {\n            formatter.format(\"%s\", toString(Verbosity.Short));\n        }\n\n        boolean neighborsAlternate = ((flags & FormattableFlags.LEFT_JUSTIFY) == FormattableFlags.LEFT_JUSTIFY);\n        int neighborsFlags = (neighborsAlternate ? FormattableFlags.ALTERNATE | FormattableFlags.LEFT_JUSTIFY : 0);\n        if (width > 0) {\n            if (this.predecessor != null) {\n                formatter.format(\" pred={\");\n                this.predecessor.formatTo(formatter, neighborsFlags, width - 1, 0);\n                formatter.format(\"}\");\n            }\n\n            for (Position position : this.inputPositions()) {\n                Node input = position.get(this);\n                if (input != null) {\n                    formatter.format(\" \");\n                    formatter.format(position.getName());\n                    formatter.format(\"={\");\n                    input.formatTo(formatter, neighborsFlags, width - 1, 0);\n                    formatter.format(\"}\");\n                }\n            }\n        }\n\n        if (precision > 0) {\n            if (!hasNoUsages()) {\n                formatter.format(\" usages={\");\n                int z = 0;\n                for (Node usage : usages()) {\n                    if (z != 0) {\n                        formatter.format(\", \");\n                    }\n                    usage.formatTo(formatter, neighborsFlags, 0, precision - 1);\n                    ++z;\n                }\n                formatter.format(\"}\");\n            }\n\n            for (Position position : this.successorPositions()) {\n                Node successor = position.get(this);\n                if (successor != null) {\n                    formatter.format(\" \");\n                    formatter.format(position.getName());\n                    formatter.format(\"={\");\n                    successor.formatTo(formatter, neighborsFlags, 0, precision - 1);\n                    formatter.format(\"}\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Determines if this node's {@link NodeClass#getData() data} fields are equal to the data\n     * fields of another node of the same type. Primitive fields are compared by value and\n     * non-primitive fields are compared by {@link Objects#equals(Object, Object)}.\n     *\n     * The result of this method undefined if {@code other.getClass() != this.getClass()}.\n     *\n     * @param other a node of exactly the same type as {@code this}\n     * @return true if the data fields of this object and {@code other} are equal\n     */\n    public final boolean valueEquals(Node other) {\n        return getNodeClass().dataEquals(this, other);\n    }\n\n    /**\n     * Determines if {@code this} is equal to the other node while ignoring differences in\n     * {@linkplain Successor control-flow} edges.\n     *\n     */\n    public final boolean dataFlowEquals(Node other) {\n        return this == other || nodeClass == other.getNodeClass() && this.valueEquals(other) && nodeClass.equalInputs(this, other);\n    }\n\n    public final void pushInputs(NodeStack stack) {\n        getNodeClass().pushInputs(this, stack);\n    }\n\n    public final NodeSize estimatedNodeSize() {\n        try {\n            return dynamicNodeSizeEstimate();\n        } catch (Exception e) {\n            throw GraalError.shouldNotReachHere(e, \"Exception during node cost estimation\"); // ExcludeFromJacocoGeneratedReport\n        }\n    }\n\n    /**\n     * Node subclasses should override this method if they need to specify a dynamically calculated\n     * {@link NodeSize} value. If the node size is static please use {@link NodeInfo#size()}.\n     *\n     * NOTE: When overriding this method, make sure that *all* field reads are null checked (even if\n     * Java semantics seemingly make the value of the field non-null). This is necessary because\n     * node size estimates are needed even during graph decoding which, for some nodes, first\n     * reflectively creates a stub and then later, reflectively, populates its fields. This method\n     * could be invoked between these two points. For this reason, when overriding this method\n     * assume that all fields can and will be null.\n     *\n     * @return The estimated node size for this node.\n     */\n    protected NodeSize dynamicNodeSizeEstimate() {\n        return nodeClass.size();\n    }\n\n    public NodeCycles estimatedNodeCycles() {\n        return nodeClass.cycles();\n    }\n\n}",
                "methodCount": 120
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 9,
                "candidates": [
                    {
                        "lineStart": 1369,
                        "lineEnd": 1373,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method markDeleted to class Graph",
                        "description": "Move method markDeleted to jdk.graal.compiler.graph.Graph\nRationale: The method 'markDeleted()' interacts directly with the Graph class by calling the 'unregister()' method on the graph instance. Additionally, the method manipulates the id related directly to the graph's concept of node management. Therefore, 'markDeleted()' has a closer logical relationship with the Graph class than any other context likely present.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1342,
                        "lineEnd": 1344,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method removeThisFromUsages to class Graph",
                        "description": "Move method removeThisFromUsages to jdk.graal.compiler.graph.Graph\nRationale: The method `removeThisFromUsages(Node n)` is highly relevant to the functionality of managing nodes within a graph structure. Since `Graph` contains the set of nodes and manages their relationships, including registration, tracking, and removal of nodes, the method should be moved to this class. By doing this, the method will have direct access to the internal state and methods of `Graph` like `nodes`, `nodeUsageModCounts`, and relevant event listeners. This will facilitate better integration and maintainability of the code, as the functionality of node management is consolidated within the Graph class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 894,
                        "lineEnd": 896,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method withNodeSourcePosition to class Graph",
                        "description": "Move method withNodeSourcePosition to jdk.graal.compiler.graph.Graph\nRationale: The method 'withNodeSourcePosition()' is currently delegating its task to a method within the Graph class: 'graph.withNodeSourcePosition(this)'. This direct interaction with the Graph's method indicates that the functionality closely relates to the Graph class. Therefore, encapsulating this method within the Graph class would make the design more cohesive and logically structured.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1489,
                        "lineEnd": 1501,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method verifyInput to class InputEdges",
                        "description": "Move method verifyInput to jdk.graal.compiler.graph.InputEdges\nRationale: The method `verifyInput` relies heavily on the structure and members of the `InputEdges` class, such as `getInputType`, `isOptional`, `getName`, and `getType`. It performs validation based on the input types and optional status that are inherent properties of the `InputEdges`. Therefore, moving this method to `InputEdges` is appropriate, as it utilizes the class's core functionalities and maintains encapsulation principles.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1205,
                        "lineEnd": 1209,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method fireNodeEvent to class Graph",
                        "description": "Move method fireNodeEvent to jdk.graal.compiler.graph.Graph\nRationale: The fireNodeEvent() method is directly related to managing node events within a graph context, which is a core responsibility of the Graph class. The method interacts with NodeEventListener, but this is expected since listeners are typically managed outside of the listener class itself. Since the Graph class contains methods such as beforeDecodingFields() and afterDecodingFields() to handle node events, it is reasonable to manage firing node events within the Graph class instead. This avoids bloating the NodeEventListener class with method responsibilities outside listener functionality.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 724,
                        "lineEnd": 729,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method usageModCount to class Graph",
                        "description": "Move method usageModCount to jdk.graal.compiler.graph.Graph\nRationale: The method 'usageModCount()' is tightly coupled with the 'Graph' class because it directly uses the 'graph' instance and invokes the 'graph.nodeUsageModCount()' method. More importantly, the method relies on the 'isNodeModificationCountsEnabled()' static method within the 'Graph' class to determine its behavior. Given this strong dependency, it makes sense to place 'usageModCount()' within the 'Graph' class to keep related concerns together and enhance cohesion. Moving this method will allow better encapsulation and clearer structure within the object-oriented design.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 909,
                        "lineEnd": 923,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method checkReplaceWith to class Graph",
                        "description": "Move method checkReplaceWith to jdk.graal.compiler.graph.Graph\nRationale: The method `checkReplaceWith` makes extensive checks related to the state of the graph, such as whether it is frozen and whether nodes (including the replacement node) are deleted. These checks suggest that the method is concerned with the integrity of the graph's structure. As such, it aligns well with the responsibilities of the `Graph` class, which manages the nodes and the overall state of the graph. Furthermore, `Graph` already maintains properties and methods related to frozen states, such as the `FreezeState` and related methods like `unfreeze()`. Moving the method to `Graph` will centralize the graph-related integrity checks within the class responsible for the graph structure itself.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 718,
                        "lineEnd": 722,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method incModCount to class Graph",
                        "description": "Move method incModCount to jdk.graal.compiler.graph.Graph\nRationale: The method `incModCount()` interacts directly with properties and methods of the `Graph` class, such as checking the state of `isNodeModificationCountsEnabled()` and invoking `graph.incNodeModCount(this)`. Given that it modifies aspects of the graph and relies on graph-related checks and behaviors, it is more appropriate for it to be encapsulated within the `Graph` class to keep all graph-modifying operations in one place, thereby enhancing cohesion and maintainability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 731,
                        "lineEnd": 735,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method incUsageModCount to class Graph",
                        "description": "Move method incUsageModCount to jdk.graal.compiler.graph.Graph\nRationale: The method incUsageModCount() is tightly coupled with the Graph class, particularly with its node modification counting logic. The method directly interacts with the Graph's internal state through the `graph` field and the `isNodeModificationCountsEnabled()` method. Since `graph.incNodeUsageModCount(this)` is a direct Graph method invocation and the modification count logic is handled by the Graph class, it is more appropriate for incUsageModCount() to reside in the Graph class. This would centralize the modification counting logic within the Graph class, improving coherence and maintainability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "formatTo",
                            "method_signature": "public void formatTo(Formatter formatter, int flags, int width, int precision)",
                            "target_class": "formatter",
                            "rationale": "The formatTo method is responsible for converting the node's data into a specific string format. This kind of functionality is more appropriate for a Formatter utility class rather than the Node class itself, which should focus on core graph-related functionalities. Moving the method to a formatter class can help in maintaining single responsibility and clean separation of concerns."
                        },
                        {
                            "method_name": "copyWithInputs",
                            "method_signature": "public final Node copyWithInputs(boolean insertIntoGraph)",
                            "target_class": "Graph",
                            "rationale": "The method involves making copies of nodes and registering them in a graph, which pertains more to the graph's functionality rather than the node\u2019s functionality. It should be with the graph class to handle such operations within the context of the graph."
                        },
                        {
                            "method_name": "replaceAndDelete",
                            "method_signature": "public void replaceAndDelete(Node replacement)",
                            "target_class": "Graph",
                            "rationale": "This method manipulates multiple nodes and their connections within the graph. Such manipulations are more suited to be managed by the graph class itself, which deals with the overall structure and relationship of nodes."
                        },
                        {
                            "method_name": "graph",
                            "method_signature": "public Graph graph()",
                            "target_class": "Graph",
                            "rationale": "This method retrieves the graph associated with the node. It\u2019s logical to include graph-related actions and information within the Graph class to encapsulate all graph-specific logic in one place."
                        },
                        {
                            "method_name": "getOptions",
                            "method_signature": "public final OptionValues getOptions()",
                            "target_class": "Graph",
                            "rationale": "This method deals with getting the options from the associated graph, making it more relevant to the Graph class. Centralizing all option retrieving logic within the Graph class would ensure better cohesion."
                        },
                        {
                            "method_name": "getDebug",
                            "method_signature": "public final DebugContext getDebug()",
                            "target_class": "Graph",
                            "rationale": "The method returns the debug context associated with the graph, indicating that its primary functionality is more related to the graph than an individual node."
                        },
                        {
                            "method_name": "fireNodeEvent",
                            "method_signature": "private void fireNodeEvent(Node node, NodeEventListener listener)",
                            "target_class": "Graph",
                            "rationale": "This method deals with node events within the graph, making it suitable candidate logic to reside in the Graph class, which should handle event-related functionalities."
                        },
                        {
                            "method_name": "assertTrue",
                            "method_signature": "public boolean assertTrue(boolean condition, String message, Object... args)",
                            "target_class": "Assertions",
                            "rationale": "This method asserts the truth of a condition, which is a utility function and should be moved to a dedicated Assertions utility class to separate concerns and keep the Node class focused on graph-related behaviors."
                        },
                        {
                            "method_name": "assertFalse",
                            "method_signature": "public boolean assertFalse(boolean condition, String message, Object... args)",
                            "target_class": "Assertions",
                            "rationale": "Similar to assertTrue, this utility method should be part of a dedicated Assertions class to streamline the Node class and centralize assertion functionalities."
                        },
                        {
                            "method_name": "verify",
                            "method_signature": "public final boolean verify(boolean verifyInputs)",
                            "target_class": "Graphs",
                            "rationale": "This method is responsible for verifying node properties and inputs, making it more appropriate for the graph class. It encapsulates node verifications that are pertinent to the graph's correctness."
                        }
                    ],
                    "llm_response_time": 11452
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "assertTrue",
                            "method_signature": "public boolean assertTrue(boolean condition, String message, Object... args)",
                            "target_class": "NodeAssertionUtils",
                            "rationale": "The assertTrue method is a utility for assertions and is not specific to the core responsibilities of the Node class. It would be more appropriate in a utility class dedicated to assertions."
                        },
                        {
                            "method_name": "assertFalse",
                            "method_signature": "public boolean assertFalse(boolean condition, String message, Object... args)",
                            "target_class": "NodeAssertionUtils",
                            "rationale": "The assertFalse method is a utility for assertions and is not specific to the core responsibilities of the Node class. It would be more appropriate in a utility class dedicated to assertions."
                        },
                        {
                            "method_name": "fail",
                            "method_signature": "protected GraalGraphError fail(String message, Object... args)",
                            "target_class": "NodeAssertionUtils",
                            "rationale": "The fail method is a utility for throwing errors and is not specific to the core responsibilities of the Node class. It would be more appropriate in a utility class dedicated to error handling."
                        }
                    ],
                    "llm_response_time": 5431
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "incUsageModCount",
                            "method_signature": "private void incUsageModCount()",
                            "target_class": "Graph",
                            "rationale": "The method `incUsageModCount` is specific to the Graph's internal state modification and should be handled within the Graph class itself."
                        },
                        {
                            "method_name": "incModCount",
                            "method_signature": "final void incModCount()",
                            "target_class": "Graph",
                            "rationale": "The `incModCount` method also manages the internal state of the graph and is better placed within the Graph class."
                        },
                        {
                            "method_name": "usageModCount",
                            "method_signature": "final int usageModCount()",
                            "target_class": "Graph",
                            "rationale": "This method is involved in tracking modifications in the graph state, and thus should be placed in the Graph class."
                        },
                        {
                            "method_name": "isNodeModificationCountsEnabled",
                            "method_signature": "private boolean isNodeModificationCountsEnabled()",
                            "target_class": "Graph",
                            "rationale": "This method checks a condition related to the Graph's settings or state and is better placed within the Graph class."
                        },
                        {
                            "method_name": "removeThisFromUsages",
                            "method_signature": "boolean removeThisFromUsages(Node n)",
                            "target_class": "Graph",
                            "rationale": "Removing usages is an operation that modifies the graph structure, so it is more appropriate to be within the Graph class."
                        },
                        {
                            "method_name": "replaceFirstUsage",
                            "method_signature": "private void replaceFirstUsage(Node oldInput, Node newInput)",
                            "target_class": "Graph",
                            "rationale": "This method which handles updating the graph when an input is replaced is more suited to being within the Graph class."
                        },
                        {
                            "method_name": "safeDelete",
                            "method_signature": "public void safeDelete()",
                            "target_class": "Graph",
                            "rationale": "The `safeDelete` method deals with removing a node from the graph's structure, fitting it better into the Graph class."
                        },
                        {
                            "method_name": "markDeleted",
                            "method_signature": "public void markDeleted()",
                            "target_class": "Graph",
                            "rationale": "This method also deals with marking the node as deleted within the context of the graph's structure and should be within Graph."
                        },
                        {
                            "method_name": "initialize",
                            "method_signature": "void initialize(Graph newGraph)",
                            "target_class": "Graph",
                            "rationale": "This method initializes a node in a given graph, making it more appropriate for encapsulation within the Graph class."
                        }
                    ],
                    "llm_response_time": 8132
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "init",
                            "method_signature": "final init(NodeClass<? extends Node> c)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "inputs",
                            "method_signature": "public inputs()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "inputPositions",
                            "method_signature": "public inputPositions()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "applyInputs",
                            "method_signature": "public applyInputs(EdgeVisitor visitor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "applySuccessors",
                            "method_signature": "public applySuccessors(EdgeVisitor visitor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "successors",
                            "method_signature": "public successors()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "successorPositions",
                            "method_signature": "public successorPositions()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "hasExactlyOneUsageOfType",
                            "method_signature": "public final hasExactlyOneUsageOfType(InputType inputType)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeDeadUsages",
                            "method_signature": "public removeDeadUsages()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "modCount",
                            "method_signature": "public final modCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "incModCount",
                            "method_signature": "final incModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "usageModCount",
                            "method_signature": "final usageModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "incUsageModCount",
                            "method_signature": "final incUsageModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "updateUsages",
                            "method_signature": "protected updateUsages(Node oldInput, Node newInput)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "updatePredecessor",
                            "method_signature": "protected updatePredecessor(Node oldSuccessor, Node newSuccessor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "initialize",
                            "method_signature": " initialize(Graph newGraph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "withNodeSourcePosition",
                            "method_signature": "public withNodeSourcePosition()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "checkReplaceWith",
                            "method_signature": "private checkReplaceWith(Node replacement)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAtUsage",
                            "method_signature": "private replaceAtUsage(Node replacement, boolean forDeletion, Node usage)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAtUsagePos",
                            "method_signature": "private replaceAtUsagePos(Node replacement, Node usage, Position pos)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAtUsages",
                            "method_signature": "public replaceAtUsages(Node replacement, InputType inputType)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAtUsages",
                            "method_signature": "public replaceAtUsages(Node replacement, InputType... inputTypes)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "maybeNotifyInputChanged",
                            "method_signature": "private maybeNotifyInputChanged(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "fireNodeEvent",
                            "method_signature": "private fireNodeEvent(Node node, NodeEventListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "maybeNotifyZeroUsages",
                            "method_signature": "public maybeNotifyZeroUsages(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAtPredecessor",
                            "method_signature": "public replaceAtPredecessor(Node replacement)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceFirstSuccessor",
                            "method_signature": "public replaceFirstSuccessor(Node oldSuccessor, Node newSuccessor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceFirstInput",
                            "method_signature": "public replaceFirstInput(Node oldInput, Node newInput)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAllInputs",
                            "method_signature": "public replaceAllInputs(Node oldInput, Node newInput)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeThisFromUsages",
                            "method_signature": " removeThisFromUsages(Node n)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "markDeleted",
                            "method_signature": "public markDeleted()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "copyWithInputs",
                            "method_signature": "public final copyWithInputs(boolean insertIntoGraph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "clone",
                            "method_signature": "final clone(Graph into, EnumSet<Edges.Type> edgesToCopy)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verifyInputs",
                            "method_signature": "@SuppressWarnings(\"unchecked\")\n    protected verifyInputs()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verifyInput",
                            "method_signature": "private verifyInput(InputEdges inputEdges, int i, Node input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verify",
                            "method_signature": "public final verify(boolean verifyInputs)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verifyEdges",
                            "method_signature": "public verifyEdges()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "dataFlowEquals",
                            "method_signature": "public final dataFlowEquals(Node other)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "dynamicNodeSizeEstimate",
                            "method_signature": "protected dynamicNodeSizeEstimate()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "estimatedNodeCycles",
                            "method_signature": "public estimatedNodeCycles()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "initialize",
                            "method_signature": " initialize(Graph newGraph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "markDeleted",
                            "method_signature": "public markDeleted()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeThisFromUsages",
                            "method_signature": " removeThisFromUsages(Node n)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "init",
                            "method_signature": "final init(NodeClass<? extends Node> c)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "withNodeSourcePosition",
                            "method_signature": "public withNodeSourcePosition()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "estimatedNodeCycles",
                            "method_signature": "public estimatedNodeCycles()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verifyInput",
                            "method_signature": "private verifyInput(InputEdges inputEdges, int i, Node input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "maybeNotifyInputChanged",
                            "method_signature": "private maybeNotifyInputChanged(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAtUsagePos",
                            "method_signature": "private replaceAtUsagePos(Node replacement, Node usage, Position pos)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "fireNodeEvent",
                            "method_signature": "private fireNodeEvent(Node node, NodeEventListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verifyInputs",
                            "method_signature": "@SuppressWarnings(\"unchecked\")\n    protected verifyInputs()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "usageModCount",
                            "method_signature": "final usageModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "checkReplaceWith",
                            "method_signature": "private checkReplaceWith(Node replacement)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "incModCount",
                            "method_signature": "final incModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "incUsageModCount",
                            "method_signature": "final incUsageModCount()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    " initialize(Graph newGraph)": {
                        "first": {
                            "method_name": "initialize",
                            "method_signature": " initialize(Graph newGraph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.24367867242765143
                    },
                    "public markDeleted()": {
                        "first": {
                            "method_name": "markDeleted",
                            "method_signature": "public markDeleted()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.32051283558054755
                    },
                    " removeThisFromUsages(Node n)": {
                        "first": {
                            "method_name": "removeThisFromUsages",
                            "method_signature": " removeThisFromUsages(Node n)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3539632627099134
                    },
                    "final init(NodeClass<? extends Node> c)": {
                        "first": {
                            "method_name": "init",
                            "method_signature": "final init(NodeClass<? extends Node> c)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.38243794662341446
                    },
                    "public withNodeSourcePosition()": {
                        "first": {
                            "method_name": "withNodeSourcePosition",
                            "method_signature": "public withNodeSourcePosition()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3837526082643699
                    },
                    "public estimatedNodeCycles()": {
                        "first": {
                            "method_name": "estimatedNodeCycles",
                            "method_signature": "public estimatedNodeCycles()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3837526082643699
                    },
                    "private verifyInput(InputEdges inputEdges, int i, Node input)": {
                        "first": {
                            "method_name": "verifyInput",
                            "method_signature": "private verifyInput(InputEdges inputEdges, int i, Node input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3860640704385914
                    },
                    "private maybeNotifyInputChanged(Node node)": {
                        "first": {
                            "method_name": "maybeNotifyInputChanged",
                            "method_signature": "private maybeNotifyInputChanged(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.42704876827311206
                    },
                    "private replaceAtUsagePos(Node replacement, Node usage, Position pos)": {
                        "first": {
                            "method_name": "replaceAtUsagePos",
                            "method_signature": "private replaceAtUsagePos(Node replacement, Node usage, Position pos)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4295635462969479
                    },
                    "private fireNodeEvent(Node node, NodeEventListener listener)": {
                        "first": {
                            "method_name": "fireNodeEvent",
                            "method_signature": "private fireNodeEvent(Node node, NodeEventListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4406060280296532
                    },
                    "@SuppressWarnings(\"unchecked\")\n    protected verifyInputs()": {
                        "first": {
                            "method_name": "verifyInputs",
                            "method_signature": "@SuppressWarnings(\"unchecked\")\n    protected verifyInputs()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.46062779976286394
                    },
                    "final usageModCount()": {
                        "first": {
                            "method_name": "usageModCount",
                            "method_signature": "final usageModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.47457197642017174
                    },
                    "private checkReplaceWith(Node replacement)": {
                        "first": {
                            "method_name": "checkReplaceWith",
                            "method_signature": "private checkReplaceWith(Node replacement)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4831016127485738
                    },
                    "final incModCount()": {
                        "first": {
                            "method_name": "incModCount",
                            "method_signature": "final incModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.48433020399829624
                    },
                    "final incUsageModCount()": {
                        "first": {
                            "method_name": "incUsageModCount",
                            "method_signature": "final incUsageModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.48433020399829624
                    }
                },
                "voyage": {
                    "public withNodeSourcePosition()": {
                        "first": {
                            "method_name": "withNodeSourcePosition",
                            "method_signature": "public withNodeSourcePosition()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.39081353999186846
                    },
                    "public markDeleted()": {
                        "first": {
                            "method_name": "markDeleted",
                            "method_signature": "public markDeleted()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4025763369037029
                    },
                    "public successorPositions()": {
                        "first": {
                            "method_name": "successorPositions",
                            "method_signature": "public successorPositions()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4104299298080871
                    },
                    "public replaceFirstSuccessor(Node oldSuccessor, Node newSuccessor)": {
                        "first": {
                            "method_name": "replaceFirstSuccessor",
                            "method_signature": "public replaceFirstSuccessor(Node oldSuccessor, Node newSuccessor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.43044387165709647
                    },
                    "private fireNodeEvent(Node node, NodeEventListener listener)": {
                        "first": {
                            "method_name": "fireNodeEvent",
                            "method_signature": "private fireNodeEvent(Node node, NodeEventListener listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4306318830532662
                    },
                    "private checkReplaceWith(Node replacement)": {
                        "first": {
                            "method_name": "checkReplaceWith",
                            "method_signature": "private checkReplaceWith(Node replacement)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4550350628397588
                    },
                    "public replaceAtPredecessor(Node replacement)": {
                        "first": {
                            "method_name": "replaceAtPredecessor",
                            "method_signature": "public replaceAtPredecessor(Node replacement)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4556453445044351
                    },
                    "public final dataFlowEquals(Node other)": {
                        "first": {
                            "method_name": "dataFlowEquals",
                            "method_signature": "public final dataFlowEquals(Node other)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.46169355037925564
                    },
                    "public applySuccessors(EdgeVisitor visitor)": {
                        "first": {
                            "method_name": "applySuccessors",
                            "method_signature": "public applySuccessors(EdgeVisitor visitor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4619803829680196
                    },
                    "protected dynamicNodeSizeEstimate()": {
                        "first": {
                            "method_name": "dynamicNodeSizeEstimate",
                            "method_signature": "protected dynamicNodeSizeEstimate()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.46227524626838373
                    },
                    "public inputPositions()": {
                        "first": {
                            "method_name": "inputPositions",
                            "method_signature": "public inputPositions()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.46574532425313936
                    },
                    "private replaceAtUsagePos(Node replacement, Node usage, Position pos)": {
                        "first": {
                            "method_name": "replaceAtUsagePos",
                            "method_signature": "private replaceAtUsagePos(Node replacement, Node usage, Position pos)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.47298686926076183
                    },
                    "public estimatedNodeCycles()": {
                        "first": {
                            "method_name": "estimatedNodeCycles",
                            "method_signature": "public estimatedNodeCycles()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4759105166815951
                    },
                    "protected updatePredecessor(Node oldSuccessor, Node newSuccessor)": {
                        "first": {
                            "method_name": "updatePredecessor",
                            "method_signature": "protected updatePredecessor(Node oldSuccessor, Node newSuccessor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4797728997392213
                    },
                    "public final modCount()": {
                        "first": {
                            "method_name": "modCount",
                            "method_signature": "public final modCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4799737015360964
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "final init(NodeClass<? extends Node> c)",
                        "public markDeleted()",
                        "private verifyInput(InputEdges inputEdges, int i, Node input)",
                        "private maybeNotifyInputChanged(Node node)",
                        "private fireNodeEvent(Node node, NodeEventListener listener)",
                        "private replaceAtUsagePos(Node replacement, Node usage, Position pos)",
                        "public withNodeSourcePosition()",
                        "public estimatedNodeCycles()",
                        "@SuppressWarnings(\"unchecked\")\n    protected verifyInputs()",
                        "final usageModCount()",
                        "final incUsageModCount()",
                        "final incModCount()",
                        "private checkReplaceWith(Node replacement)"
                    ],
                    "llm_response_time": 4634
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "final init(NodeClass<? extends Node> c)",
                        "public markDeleted()",
                        "public withNodeSourcePosition()"
                    ],
                    "llm_response_time": 4949
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public markDeleted()"
                    ],
                    "llm_response_time": 3812
                },
                "voyage": {
                    "priority_method_names": [
                        "private fireNodeEvent(Node node, NodeEventListener listener)",
                        "private replaceAtUsagePos(Node replacement, Node usage, Position pos)",
                        "protected updatePredecessor(Node oldSuccessor, Node newSuccessor)",
                        "private checkReplaceWith(Node replacement)",
                        "public successorPositions()",
                        "public inputPositions()",
                        "public withNodeSourcePosition()",
                        "public markDeleted()",
                        "public final modCount()",
                        "public replaceFirstSuccessor(Node oldSuccessor, Node newSuccessor)",
                        "public replaceAtPredecessor(Node replacement)",
                        "public applySuccessors(EdgeVisitor visitor)",
                        "public final dataFlowEquals(Node other)",
                        "protected dynamicNodeSizeEstimate()",
                        "public estimatedNodeCycles()"
                    ],
                    "llm_response_time": 4227
                },
                "voyage-5": {
                    "priority_method_names": [],
                    "llm_response_time": 4821
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public markDeleted()",
                        "public withNodeSourcePosition()",
                        "public successorPositions()"
                    ],
                    "llm_response_time": 3792
                }
            },
            "targetClassMap": {
                "initialize": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3267,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "markDeleted": {
                    "target_classes": [
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.3719239533425367
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Graph"
                    ],
                    "llm_response_time": 2708,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "removeThisFromUsages": {
                    "target_classes": [
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.3886668970595633
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Graph"
                    ],
                    "llm_response_time": 3716,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "init": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2669,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "withNodeSourcePosition": {
                    "target_classes": [
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.43732925652880944
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Graph"
                    ],
                    "llm_response_time": 2510,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "estimatedNodeCycles": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2439,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "verifyInput": {
                    "target_classes": [
                        {
                            "class_name": "InputEdges",
                            "similarity_score": 0.3461649744052844
                        },
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.4072539371646267
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "InputEdges",
                        "Graph"
                    ],
                    "llm_response_time": 3657,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "maybeNotifyInputChanged": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1566,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "replaceAtUsagePos": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1991,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "fireNodeEvent": {
                    "target_classes": [
                        {
                            "class_name": "NodeEventListener",
                            "similarity_score": 0.23074398016049216
                        },
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.46137240896175796
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Graph",
                        "NodeEventListener"
                    ],
                    "llm_response_time": 4163,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "verifyInputs": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3483,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "usageModCount": {
                    "target_classes": [
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.529248104080078
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Graph"
                    ],
                    "llm_response_time": 3297,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "checkReplaceWith": {
                    "target_classes": [
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.49878849273875203
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Graph"
                    ],
                    "llm_response_time": 3558,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "incModCount": {
                    "target_classes": [
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.5036699707941317
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Graph"
                    ],
                    "llm_response_time": 2398,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "incUsageModCount": {
                    "target_classes": [
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.5036699707941317
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Graph"
                    ],
                    "llm_response_time": 3193,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "4943dd979eeaba50486f93ba4ff63ea9eb85160e",
        "url": "https://github.com/oracle/graal/commit/4943dd979eeaba50486f93ba4ff63ea9eb85160e",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public fireNodeEvent(e NodeEvent, node Node) : void extracted from public maybeNotifyZeroUsages(node Node) : void in class jdk.graal.compiler.graph.Node & moved to class jdk.graal.compiler.graph.Graph",
            "leftSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                    "startLine": 1208,
                    "endLine": 1221,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "public maybeNotifyZeroUsages(node Node) : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                    "startLine": 1216,
                    "endLine": 1216,
                    "startColumn": 13,
                    "endColumn": 66,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                    "startLine": 1218,
                    "endLine": 1218,
                    "startColumn": 17,
                    "endColumn": 67,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                    "startLine": 1217,
                    "endLine": 1219,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                    "startLine": 1217,
                    "endLine": 1219,
                    "startColumn": 35,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 700,
                    "endLine": 708,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public fireNodeEvent(e NodeEvent, node Node) : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 702,
                    "endLine": 702,
                    "startColumn": 13,
                    "endColumn": 53,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 704,
                    "endLine": 704,
                    "startColumn": 17,
                    "endColumn": 34,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 701,
                    "endLine": 707,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 701,
                    "endLine": 707,
                    "startColumn": 40,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                    "startLine": 1205,
                    "endLine": 1215,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "public maybeNotifyZeroUsages(node Node) : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                    "startLine": 1213,
                    "endLine": 1213,
                    "startColumn": 13,
                    "endColumn": 67,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "graph.fireNodeEvent(Graph.NodeEvent.ZERO_USAGES,node)"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 705,
                    "endLine": 705,
                    "startColumn": 17,
                    "endColumn": 28,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 703,
                    "endLine": 706,
                    "startColumn": 16,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Graph.java",
                    "startLine": 703,
                    "endLine": 706,
                    "startColumn": 13,
                    "endColumn": 33,
                    "codeElementType": "DO_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                }
            ],
            "isStatic": false
        },
        "ref_id": 489,
        "extraction_results": {
            "success": true,
            "newCommitHash": "3a0ba381b79623df51c83d7e265aed0f23bb6c7d",
            "newBranchName": "extract-fireNodeEvent-maybeNotifyZeroUsages-9633a3f"
        },
        "telemetry": {
            "id": "88f2e694-fe5a-444b-9771-42eb58bc5472",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1759,
                "lineStart": 68,
                "lineEnd": 1826,
                "bodyLineStart": 68,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/graph/Node.java",
                "sourceCode": "/**\n * This class is the base class for all nodes. It represents a node that can be inserted in a\n * {@link Graph}.\n * <p>\n * Once a node has been added to a graph, it has a graph-unique {@link #id()}. Edges in the\n * subclasses are represented with annotated fields. There are two kind of edges: {@link Input} and\n * {@link Successor}. If a field of type {@link Node} is annotated with {@link Input} or\n * {@link Successor}, it must not be {@code null}. There is an edge from this node to the node\n * denoted by the field's value. A field annotated with {@link OptionalInput} is also such an edge\n * but it may be {@code null}.\n * <p>\n * Exactly one of {@link Input}, {@link OptionalInput}, or {@link Successor} must be applied to all\n * fields of a node that are of type {@link Node}. A field of type {@link NodeInputList} must be\n * annotated with {@link Input} or {@link OptionalInput}. A field of type {@link NodeSuccessorList}\n * must be annotated with {@link Successor}.\n * <p>\n * Nodes which are value numberable should implement the {@link ValueNumberable} interface.\n *\n * <h1>Assertions and Verification</h1>\n *\n * The Node class supplies the {@link #assertTrue(boolean, String, Object...)} and\n * {@link #assertFalse(boolean, String, Object...)} methods, which will check the supplied boolean\n * and throw a VerificationError if it has the wrong value. Both methods will always either throw an\n * exception or return true. They can thus be used within an assert statement, so that the check is\n * only performed if assertions are enabled.\n */\n@NodeInfo\npublic abstract class Node implements Cloneable, Formattable {\n\n    private static final Unsafe UNSAFE = getUnsafe();\n\n    public static final NodeClass<?> TYPE = null;\n\n    public static final boolean TRACK_CREATION_POSITION = Boolean.parseBoolean(Services.getSavedProperty(\"debug.graal.TrackNodeCreationPosition\"));\n\n    static final int DELETED_ID_START = -1000000000;\n    static final int INITIAL_ID = -1;\n    static final int ALIVE_ID_START = 0;\n\n    // The use of fully qualified class names here and in the rest\n    // of this file works around a problem javac has resolving symbols\n\n    /**\n     * Denotes a non-optional (non-null) node input. This should only be applied to fields of type\n     * {@link Node} or {@link NodeInputList}.\n     *\n     * Nodes that update fields of type {@link Node} outside of their constructor should call\n     * {@link Node#updateUsages(Node, Node)} just prior to the update.\n     */\n    @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)\n    @java.lang.annotation.Target(ElementType.FIELD)\n    public @interface Input {\n        InputType value() default InputType.Value;\n    }\n\n    /**\n     * Denotes an optional (nullable) node input. This should only be applied to fields of type\n     * {@link Node} or {@link NodeInputList}.\n     *\n     * Nodes that update fields of type {@link Node} outside of their constructor should call\n     * {@link Node#updateUsages(Node, Node)} just prior to the update.\n     */\n    @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)\n    @java.lang.annotation.Target(ElementType.FIELD)\n    public @interface OptionalInput {\n        InputType value() default InputType.Value;\n    }\n\n    /**\n     * Denotes a non-optional (non-null) node successor. This should only be applied to fields of\n     * type {@link Node} or {@link NodeSuccessorList}.\n     */\n    @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)\n    @java.lang.annotation.Target(ElementType.FIELD)\n    public @interface Successor {\n    }\n\n    /**\n     * Denotes that a parameter of an {@linkplain NodeIntrinsic intrinsic} method must be a compile\n     * time constant at all call sites to the intrinsic method.\n     */\n    @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)\n    @java.lang.annotation.Target(ElementType.PARAMETER)\n    public @interface ConstantNodeParameter {\n    }\n\n    /**\n     * Denotes an injected parameter in a {@linkplain NodeIntrinsic node intrinsic} constructor. If\n     * the constructor is called as part of node intrinsification, the node intrinsifier will inject\n     * an argument for the annotated parameter. Injected parameters must precede all non-injected\n     * parameters in a constructor. If the type of the annotated parameter is {@link Stamp}, the\n     * {@linkplain Stamp#javaType type} of the injected stamp is the return type of the annotated\n     * method (which cannot be {@code void}).\n     */\n    @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)\n    @java.lang.annotation.Target(ElementType.PARAMETER)\n    public @interface InjectedNodeParameter {\n    }\n\n    /**\n     * Annotates a method that can be replaced by a compiler intrinsic. A (resolved) call to the\n     * annotated method will be processed by a generated {@code InvocationPlugin} that calls either\n     * a factory method or a constructor corresponding with the annotated method. By default the\n     * intrinsics are implemented by invoking the constructor but a factory method may be used\n     * instead. To use a factory method the class implementing the intrinsic must be annotated with\n     * {@link NodeIntrinsicFactory}. To ease error checking of NodeIntrinsics all intrinsics are\n     * expected to be implemented in the same way, so it's not possible to mix constructor and\n     * factory intrinsification in the same class.\n     * <p>\n     * A factory method corresponding to an annotated method is a static method named\n     * {@code intrinsify} defined in the class denoted by {@link #value()}. In order, its signature\n     * is as follows:\n     * <ol>\n     * <li>A {@code GraphBuilderContext} parameter.</li>\n     * <li>A sequence of zero or more {@linkplain InjectedNodeParameter injected} parameters.</li>\n     * <li>Remaining parameters that match the declared parameters of the annotated method.</li>\n     * </ol>\n     * A constructor corresponding to an annotated method is defined in the class denoted by\n     * {@link #value()}. In order, its signature is as follows:\n     * <ol>\n     * <li>A sequence of zero or more {@linkplain InjectedNodeParameter injected} parameters.</li>\n     * <li>Remaining parameters that match the declared parameters of the annotated method.</li>\n     * </ol>\n     * There must be exactly one such factory method or constructor corresponding to a\n     * {@link NodeIntrinsic} annotated method.\n     */\n    @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)\n    @java.lang.annotation.Target(ElementType.METHOD)\n    public @interface NodeIntrinsic {\n\n        /**\n         * The class declaring the factory method or {@link Node} subclass declaring the constructor\n         * used to intrinsify a call to the annotated method. The default value is the class in\n         * which the annotated method is declared.\n         */\n        Class<?> value() default NodeIntrinsic.class;\n\n        /**\n         * If {@code true}, the factory method or constructor selected by the annotation must have\n         * an {@linkplain InjectedNodeParameter injected} {@link Stamp} parameter. Calling\n         * {@link AbstractPointerStamp#nonNull()} on the injected stamp is guaranteed to return\n         * {@code true}.\n         */\n        boolean injectedStampIsNonNull() default false;\n\n        /**\n         * If {@code true} then this is lowered into a node that has side effects.\n         */\n        boolean hasSideEffect() default false;\n    }\n\n    /**\n     * Marker annotation indicating that the class uses factory methods instead of constructors for\n     * intrinsification.\n     */\n    @java.lang.annotation.Retention(RetentionPolicy.RUNTIME)\n    @java.lang.annotation.Target(ElementType.TYPE)\n    public @interface NodeIntrinsicFactory {\n    }\n\n    /**\n     * Marker for a node that can be replaced by another node via global value numbering. A\n     * {@linkplain NodeClass#isLeafNode() leaf} node can be replaced by another node of the same\n     * type that has exactly the same {@linkplain NodeClass#getData() data} values. A non-leaf node\n     * can be replaced by another node of the same type that has exactly the same data values as\n     * well as the same {@linkplain Node#inputs() inputs} and {@linkplain Node#successors()\n     * successors}.\n     */\n    public interface ValueNumberable {\n    }\n\n    /**\n     * Marker interface for nodes that contain other nodes. When the inputs to {@code this} change,\n     * users of {@code this} should also be placed on the work list for canonicalization.\n     *\n     * To illustrate this consider the following IR shape:\n     *\n     * <pre>\n     *                       Node n1\n     *                          |\n     *          IndirectInputCanonicalization\n     *          /               |            \\\n     *       usage1          usage2          usage3\n     * </pre>\n     *\n     * Now consider the following situation: this pattern is fully optimized, nothing can change.\n     * However, when the input node {@code n1} of {@code IndirectInputCanonicalization} changes to a\n     * new node {@code n2} suddenly the usage of {@code IndirectInputCanonicalization} can optimize\n     * itself: for example it can drop an input edge (any optimization is possible). Normally these\n     * patterns would be found by a full canonicalizer run, by implementing this interface\n     * incremental canonicalization will also consider the usages.\n     *\n     * <pre>\n     *                       NewNode n2\n     *                          |\n     *          IndirectInputCanonicalization\n     *          /               |            \\\n     *       usage1          usage2          usage3\n     * </pre>\n     *\n     * The pattern could optimize for example to\n     *\n     * <pre>\n     *                       NewNode n2---------------\n     *                          |                     |\n     *          IndirectInputCanonicalization         |\n     *          /               |                     |\n     *       usage1          usage2          usage3----\n     * </pre>\n     *\n     * where {@code usage3} completely skips {@code IndirectInputCanonicalization} now.\n     *\n     * Note that this is called {@code IndirectInputChangedCanonicalization} because {@code n1} is\n     * considered an indirect (transitive) input of {@code usage3}.\n     */\n    public interface IndirectInputChangedCanonicalization {\n    }\n\n    /**\n     * Marker interface for nodes where one input change can cause another input to optimize.\n     *\n     * Consider the following IR shape:\n     *\n     * <pre>\n     *            Node n1         Node n2\n     *               |               |\n     *          IndirectInputCanonicalization\n     * </pre>\n     *\n     * If now input {@code n1} is replaced by another node\n     *\n     * <pre>\n     *            NewNode n3      Node n2\n     *               |               |\n     *          IndirectInputCanonicalization\n     * </pre>\n     *\n     * this can cause n2 to optimize. This is especially relevant for local {@link Simplifiable}\n     * simplifications based on single input/usage patterns. Thus, in order to incrementally trigger\n     * the canonicalization of {@code n2} it is explicitly added to the worklist of the usage\n     * implements {@code InputsChangedCanonicalization}.\n     */\n    public interface InputsChangedCanonicalization {\n    }\n\n    /**\n     * The graph owning {@code this}.\n     */\n    private Graph graph;\n\n    /**\n     * @see #id()\n     */\n    int id;\n\n    // this next pointer is used in Graph to implement fast iteration over NodeClass types, it\n    // therefore points to the next Node of the same type.\n    Node typeCacheNext;\n\n    static final int INLINE_USAGE_COUNT = 2;\n    static final Node[] EMPTY_ARRAY = {};\n\n    /**\n     * Head of usage list (i.e. list of nodes that have {@code this} as an input). Note that each\n     * element denotes a specific usage so there can be duplicates in the list. For example, a\n     * {@code ConstNode} modeling a compile constant that is added to itself will show up twice in\n     * the usage list of the {@code AddNode}.\n     *\n     * The elements of the usage list in order are {@link #usage0}, {@link #usage1} and\n     * {@link #extraUsages}. The first null entry terminates the list.\n     */\n    Node usage0;\n    Node usage1;\n    Node[] extraUsages;\n    int extraUsagesCount;\n\n    private Node predecessor;\n    private NodeClass<? extends Node> nodeClass;\n\n    public static final int NOT_ITERABLE = -1;\n\n    static class NodeStackTrace {\n        final StackTraceElement[] stackTrace = new Throwable().getStackTrace();\n\n        private String getString(String label) {\n            StringBuilder sb = new StringBuilder();\n            if (label != null) {\n                sb.append(label).append(\": \");\n            }\n            for (StackTraceElement ste : stackTrace) {\n                sb.append(\"at \").append(ste.toString()).append('\\n');\n            }\n            return sb.toString();\n        }\n\n        String getStrackTraceString() {\n            return getString(null);\n        }\n\n        @Override\n        public String toString() {\n            return getString(getClass().getSimpleName());\n        }\n    }\n\n    static class NodeCreationStackTrace extends NodeStackTrace {\n    }\n\n    public static class NodeInsertionStackTrace extends NodeStackTrace {\n    }\n\n    @SuppressWarnings(\"this-escape\")\n    public Node(NodeClass<? extends Node> c) {\n        init(c);\n    }\n\n    final void init(NodeClass<? extends Node> c) {\n        assert c.getJavaClass() == this.getClass() : Assertions.errorMessageContext(\"c\", c, \"this\", this);\n        this.nodeClass = c;\n        id = INITIAL_ID;\n        extraUsages = EMPTY_ARRAY;\n        if (TRACK_CREATION_POSITION) {\n            setCreationPosition(new NodeCreationStackTrace());\n        }\n    }\n\n    /**\n     * Gets an identifier for {@code this} that is unique in the context of {@link #graph} iff\n     * {@code this.graph() != NULL && this.isAlive()}. The value returned by this method can change\n     * after the graph is {@linkplain Graph#maybeCompress() compressed}.\n     */\n    final int id() {\n        return id;\n    }\n\n    /**\n     * Gets the graph context of {@code this}.\n     */\n    public Graph graph() {\n        return graph;\n    }\n\n    /**\n     * Gets the option values associated with {@code this.graph()}.\n     */\n    public final OptionValues getOptions() {\n        return graph == null ? null : graph.getOptions();\n    }\n\n    /**\n     * Gets the debug context associated with {@code this.graph()}.\n     */\n    public final DebugContext getDebug() {\n        return graph.getDebug();\n    }\n\n    /**\n     * Returns an {@link NodeIterable iterable} which can be used to traverse all non-null input\n     * edges of {@code this}.\n     *\n     * @return an {@link NodeIterable iterable} for all non-null input edges.\n     */\n    public NodeIterable<Node> inputs() {\n        CompilationAlarm.checkProgress(this.graph);\n        return nodeClass.getInputIterable(this);\n    }\n\n    /**\n     * Returns an {@link Iterable iterable} which can be used to traverse all non-null input edges\n     * of {@code this}.\n     *\n     * @return an {@link Iterable iterable} for all non-null input edges.\n     */\n    public Iterable<Position> inputPositions() {\n        return nodeClass.getInputEdges().getPositionsIterable(this);\n    }\n\n    public abstract static class EdgeVisitor {\n\n        public abstract Node apply(Node source, Node target);\n\n    }\n\n    /**\n     * Applies the given visitor to all inputs of {@code this}.\n     *\n     * @param visitor the visitor to be applied to the inputs\n     */\n    public void applyInputs(EdgeVisitor visitor) {\n        nodeClass.applyInputs(this, visitor);\n    }\n\n    /**\n     * Applies the given visitor to all successors of {@code this}.\n     *\n     * @param visitor the visitor to be applied to the successors\n     */\n    public void applySuccessors(EdgeVisitor visitor) {\n        nodeClass.applySuccessors(this, visitor);\n    }\n\n    /**\n     * Returns an {@link NodeIterable iterable} which can be used to traverse all non-null successor\n     * edges of {@code this}.\n     *\n     * @return an {@link NodeIterable iterable} for all non-null successor edges.\n     */\n    public NodeIterable<Node> successors() {\n        assert !this.isDeleted() : this;\n        return nodeClass.getSuccessorIterable(this);\n    }\n\n    /**\n     * Returns an {@link Iterable iterable} which can be used to traverse all successor edge\n     * positions of {@code this}.\n     *\n     * @return an {@link Iterable iterable} for all successor edge positoins.\n     */\n    public Iterable<Position> successorPositions() {\n        return nodeClass.getSuccessorEdges().getPositionsIterable(this);\n    }\n\n    /**\n     * Gets the current number of usages {@code this} node has.\n     */\n    public int getUsageCount() {\n        if (usage0 == null) {\n            return 0;\n        }\n        if (usage1 == null) {\n            return 1;\n        }\n        return INLINE_USAGE_COUNT + extraUsagesCount;\n    }\n\n    /**\n     * Gets the list of nodes that use {@code this} (i.e., as an input).\n     */\n    public final NodeIterable<Node> usages() {\n        CompilationAlarm.checkProgress(this.graph);\n        return new NodeUsageIterable(this);\n    }\n\n    /**\n     * Checks whether {@code this} has no usages.\n     */\n    public final boolean hasNoUsages() {\n        return this.usage0 == null;\n    }\n\n    /**\n     * Checks whether {@code this} has usages.\n     */\n    public final boolean hasUsages() {\n        return this.usage0 != null;\n    }\n\n    /**\n     * Checks whether {@code this} has more than one usage.\n     */\n    public final boolean hasMoreThanOneUsage() {\n        return this.usage1 != null;\n    }\n\n    /**\n     * Checks whether {@code this} has exactly one usage.\n     */\n    public final boolean hasExactlyOneUsage() {\n        return hasUsages() && !hasMoreThanOneUsage();\n    }\n\n    /**\n     * Checks whether {@code this} has only one usage of type {@code inputType}.\n     *\n     * @param inputType the type of usages to look for\n     */\n    public final boolean hasExactlyOneUsageOfType(InputType inputType) {\n        int numUses = 0;\n        for (Node usage : usages()) {\n            for (Position pos : usage.inputPositions()) {\n                if (pos.get(usage) == this) {\n                    if (pos.getInputType() == inputType) {\n                        numUses++;\n                        if (numUses > 1) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        return numUses == 1;\n    }\n\n    /**\n     * Adds a given node to this node's {@linkplain #usages() usages}.\n     *\n     * @param node the node to add\n     */\n    void addUsage(Node node) {\n        incUsageModCount();\n        if (usage0 == null) {\n            usage0 = node;\n        } else if (usage1 == null) {\n            usage1 = node;\n        } else {\n            int length = extraUsages.length;\n            if (length == 0) {\n                extraUsages = new Node[4];\n            } else if (extraUsagesCount == length) {\n                Node[] newExtraUsages = new Node[length * 2 + 1];\n                System.arraycopy(extraUsages, 0, newExtraUsages, 0, length);\n                extraUsages = newExtraUsages;\n            }\n            extraUsages[extraUsagesCount++] = node;\n        }\n    }\n\n    private void movUsageFromEndTo(int destIndex) {\n        if (destIndex >= INLINE_USAGE_COUNT) {\n            movUsageFromEndToExtraUsages(destIndex - INLINE_USAGE_COUNT);\n        } else if (destIndex == 1) {\n            movUsageFromEndToIndexOne();\n        } else {\n            assert destIndex == 0 : destIndex;\n            movUsageFromEndToIndexZero();\n        }\n    }\n\n    private void movUsageFromEndToExtraUsages(int destExtraIndex) {\n        this.extraUsagesCount--;\n        Node n = extraUsages[extraUsagesCount];\n        extraUsages[destExtraIndex] = n;\n        extraUsages[extraUsagesCount] = null;\n    }\n\n    private void movUsageFromEndToIndexZero() {\n        if (extraUsagesCount > 0) {\n            this.extraUsagesCount--;\n            usage0 = extraUsages[extraUsagesCount];\n            extraUsages[extraUsagesCount] = null;\n        } else if (usage1 != null) {\n            usage0 = usage1;\n            usage1 = null;\n        } else {\n            usage0 = null;\n        }\n    }\n\n    private void movUsageFromEndToIndexOne() {\n        if (extraUsagesCount > 0) {\n            this.extraUsagesCount--;\n            usage1 = extraUsages[extraUsagesCount];\n            extraUsages[extraUsagesCount] = null;\n        } else {\n            assert usage1 != null;\n            usage1 = null;\n        }\n    }\n\n    /**\n     * Removes one occurrence of a given node from this node's {@linkplain #usages() usages}.\n     *\n     * @param node the node to remove\n     */\n    public boolean removeUsage(Node node) {\n        assert node != null;\n        // For large graphs, usage removal is performance critical.\n        // Furthermore, it is critical that this method maintains the invariant that the usage list\n        // has no null element preceding a non-null element.\n        if (usage0 == node) {\n            movUsageFromEndToIndexZero();\n            incUsageModCount();\n            return true;\n        }\n        if (usage1 == node) {\n            movUsageFromEndToIndexOne();\n            incUsageModCount();\n            return true;\n        }\n        for (int i = this.extraUsagesCount - 1; i >= 0; i--) {\n            if (extraUsages[i] == node) {\n                movUsageFromEndToExtraUsages(i);\n                incUsageModCount();\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Removes all nodes in the provided set from {@code this} node's usages. This is significantly\n     * faster than repeated execution of {@link Node#removeUsage}.\n     */\n    public void removeUsages(EconomicSet<Node> toDelete) {\n        if (toDelete.size() == 0) {\n            return;\n        } else if (toDelete.size() == 1) {\n            removeUsage(toDelete.iterator().next());\n            return;\n        }\n\n        // requires iteration from back to front to check nodes prior to being moved to the front\n        for (int i = extraUsagesCount - 1; i >= 0; i--) {\n            if (toDelete.contains(extraUsages[i])) {\n                movUsageFromEndToExtraUsages(i);\n                incUsageModCount();\n            }\n        }\n        if (usage1 != null && toDelete.contains(usage1)) {\n            movUsageFromEndToIndexOne();\n            incUsageModCount();\n        }\n        if (usage0 != null && toDelete.contains(usage0)) {\n            movUsageFromEndToIndexZero();\n            incUsageModCount();\n        }\n    }\n\n    /**\n     * Removes all dead nodes from {@code this} node's usages. This is significantly faster than\n     * repeated execution of {@link Node#removeUsage}.\n     */\n    public void removeDeadUsages() {\n        // requires iteration from back to front to check nodes prior to being moved to the front\n        for (int i = extraUsagesCount - 1; i >= 0; i--) {\n            if (!extraUsages[i].isAlive()) {\n                movUsageFromEndToExtraUsages(i);\n                incUsageModCount();\n            }\n        }\n        if (usage1 != null && !usage1.isAlive()) {\n            movUsageFromEndToIndexOne();\n            incUsageModCount();\n        }\n        if (usage0 != null && !usage0.isAlive()) {\n            movUsageFromEndToIndexZero();\n            incUsageModCount();\n        }\n    }\n\n    public final Node predecessor() {\n        return predecessor;\n    }\n\n    public final int modCount() {\n        if (isNodeModificationCountsEnabled() && graph != null) {\n            return graph.getNodeModCount(this);\n        }\n        return 0;\n    }\n\n    final void incModCount() {\n        if (isNodeModificationCountsEnabled() && graph != null) {\n            graph.incNodeModCount(this);\n        }\n    }\n\n    final int usageModCount() {\n        if (isNodeModificationCountsEnabled() && graph != null) {\n            return graph.nodeUsageModCount(this);\n        }\n        return 0;\n    }\n\n    final void incUsageModCount() {\n        if (isNodeModificationCountsEnabled() && graph != null) {\n            graph.incNodeUsageModCount(this);\n        }\n    }\n\n    public final boolean isDeleted() {\n        return id <= DELETED_ID_START;\n    }\n\n    public final boolean isAlive() {\n        return id >= ALIVE_ID_START;\n    }\n\n    public final boolean isUnregistered() {\n        return id == INITIAL_ID;\n    }\n\n    /**\n     * Removes one occurrence of {@code this} from {@code oldInput}'s usages and adds it to\n     * {@code newInput}'s usages.\n     */\n    protected void updateUsages(Node oldInput, Node newInput) {\n        assert isAlive() && (newInput == null || newInput.isAlive()) : \"adding \" + newInput + \" to \" + this + \" instead of \" + oldInput;\n        if (oldInput != newInput) {\n            if (oldInput != null) {\n                boolean result = removeThisFromUsages(oldInput);\n                assertTrue(result, \"not found in usages, old input: %s\", oldInput);\n            }\n            maybeNotifyInputChanged(this);\n            if (newInput != null) {\n                newInput.addUsage(this);\n            }\n            if (oldInput != null && oldInput.hasNoUsages()) {\n                maybeNotifyZeroUsages(oldInput);\n            }\n        }\n    }\n\n    /**\n     * Updates the predecessor of the given nodes after a successor slot is changed from\n     * oldSuccessor to newSuccessor: removes {@code this} from oldSuccessor's predecessors and adds\n     * {@code this} to newSuccessor's predecessors.\n     */\n    protected void updatePredecessor(Node oldSuccessor, Node newSuccessor) {\n        assertTrue(isAlive() && (newSuccessor == null || newSuccessor.isAlive()) || newSuccessor == null && !isAlive(), \"adding %s to %s instead of %s\", newSuccessor, this, oldSuccessor);\n        assert graph == null || !graph.isFrozen();\n        if (oldSuccessor != newSuccessor) {\n            if (oldSuccessor != null) {\n                assertTrue(newSuccessor == null || oldSuccessor.predecessor == this, \"wrong predecessor in old successor (%s): %s, should be %s\", oldSuccessor, oldSuccessor.predecessor, this);\n                oldSuccessor.predecessor = null;\n            }\n            if (newSuccessor != null) {\n                assertTrue(newSuccessor.predecessor == null, \"unexpected non-null predecessor in new successor (%s): %s, this=%s\", newSuccessor, newSuccessor.predecessor, this);\n                newSuccessor.predecessor = this;\n                maybeNotifyInputChanged(newSuccessor);\n            }\n            maybeNotifyInputChanged(this);\n        }\n    }\n\n    void initialize(Graph newGraph) {\n        assertTrue(id == INITIAL_ID, \"unexpected id: %d\", id);\n        this.graph = newGraph;\n        newGraph.register(this);\n        NodeClass<? extends Node> nc = nodeClass;\n        nc.registerAtInputsAsUsage(this);\n        nc.registerAtSuccessorsAsPredecessor(this);\n    }\n\n    /**\n     * Information associated with {@code this}. A single value is stored directly in the field.\n     * Multiple values are stored by creating an Object[].\n     */\n    private Object annotation;\n\n    private <T> T getNodeInfo(Class<T> clazz) {\n        assert clazz != Object[].class;\n        if (annotation == null) {\n            return null;\n        }\n        if (clazz.isInstance(annotation)) {\n            return clazz.cast(annotation);\n        }\n        if (annotation.getClass() == Object[].class) {\n            Object[] annotations = (Object[]) annotation;\n            for (Object ann : annotations) {\n                if (clazz.isInstance(ann)) {\n                    return clazz.cast(ann);\n                }\n            }\n        }\n        return null;\n    }\n\n    private <T> void setNodeInfo(Class<T> clazz, T value) {\n        assert clazz != Object[].class;\n        if (annotation == null || clazz.isInstance(annotation)) {\n            // Replace the current value\n            this.annotation = value;\n        } else if (annotation.getClass() == Object[].class) {\n            Object[] annotations = (Object[]) annotation;\n            for (int i = 0; i < annotations.length; i++) {\n                if (clazz.isInstance(annotations[i])) {\n                    annotations[i] = value;\n                    return;\n                }\n            }\n            Object[] newAnnotations = Arrays.copyOf(annotations, annotations.length + 1);\n            newAnnotations[annotations.length] = value;\n            this.annotation = newAnnotations;\n        } else {\n            this.annotation = new Object[]{this.annotation, value};\n        }\n    }\n\n    /**\n     * Gets the source position information for {@code this} or null if it doesn't exist.\n     */\n    public NodeSourcePosition getNodeSourcePosition() {\n        return getNodeInfo(NodeSourcePosition.class);\n    }\n\n    /**\n     * Set the source position to {@code sourcePosition}. Setting it to null is ignored so that it's\n     * not accidentally cleared. Use {@link #clearNodeSourcePosition()} instead.\n     */\n    public void setNodeSourcePosition(NodeSourcePosition sourcePosition) {\n        if (sourcePosition == null) {\n            return;\n        }\n        setNodeInfo(NodeSourcePosition.class, sourcePosition);\n    }\n\n    public void clearNodeSourcePosition() {\n        setNodeInfo(NodeSourcePosition.class, null);\n    }\n\n    public NodeCreationStackTrace getCreationPosition() {\n        return getNodeInfo(NodeCreationStackTrace.class);\n    }\n\n    public void setCreationPosition(NodeCreationStackTrace trace) {\n        setNodeInfo(NodeCreationStackTrace.class, trace);\n    }\n\n    public NodeInsertionStackTrace getInsertionPosition() {\n        return getNodeInfo(NodeInsertionStackTrace.class);\n    }\n\n    public void setInsertionPosition(NodeInsertionStackTrace trace) {\n        setNodeInfo(NodeInsertionStackTrace.class, trace);\n    }\n\n    /**\n     * Update the source position only if it is null.\n     */\n    public void updateNodeSourcePosition(Supplier<NodeSourcePosition> sourcePositionSupp) {\n        if (this.getNodeSourcePosition() == null) {\n            setNodeSourcePosition(sourcePositionSupp.get());\n        }\n    }\n\n    public DebugCloseable withNodeSourcePosition() {\n        return graph.withNodeSourcePosition(this);\n    }\n\n    public final NodeClass<? extends Node> getNodeClass() {\n        return nodeClass;\n    }\n\n    public boolean isAllowedUsageType(InputType type) {\n        if (type == InputType.Value) {\n            return false;\n        }\n        return getNodeClass().getAllowedUsageTypes().contains(type);\n    }\n\n    private boolean checkReplaceWith(Node replacement) {\n        if (graph != null && graph.isFrozen()) {\n            fail(\"cannot modify frozen graph\");\n        }\n        if (replacement == this) {\n            fail(\"cannot replace a node with itself\");\n        }\n        if (isDeleted()) {\n            fail(\"cannot replace deleted node\");\n        }\n        if (replacement != null && replacement.isDeleted()) {\n            fail(\"cannot replace with deleted node %s\", replacement);\n        }\n        return true;\n    }\n\n    /**\n     * For each use of {@code this} in another node, replace it with {@code replacement}.\n     *\n     * This is shown by the graph transformation below where edges are from usages to inputs (e.g.\n     * {@code this} is an input of {@code n0}).\n     *\n     * Before:\n     *\n     * <pre>\n     *       this\n     *         ^\n     *         |\n     *        /|\\\n     *       / | \\\n     *      /  |  \\\n     *    n0  n1 ..nN\n     *\n     * </pre>\n     *\n     * After:\n     *\n     * <pre>\n     *     replacement\n     *         ^\n     *         |\n     *        /|\\\n     *       / | \\\n     *      /  |  \\\n     *    n0  n1 ..nN\n     * </pre>\n     *\n     * If {@code replacement == null}, then the edges are simply removed.\n     */\n    public final void replaceAtUsages(Node replacement) {\n        replaceAtAllUsages(replacement, false);\n    }\n\n    /**\n     * For each use of {@code this} in another node, {@code n}, replace it with {@code replacement}\n     * if {@code filter == null} or {@code filter.test(n) == true}.\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    public final void replaceAtUsages(Node replacement, Predicate<Node> filter) {\n        replaceAtUsages(replacement, filter, false, true);\n    }\n\n    /**\n     * For each use of {@code this} in another node, {@code n}, replace it with {@code replacement}\n     * if {@code filter == null} or {@code filter.test(n) == true}.\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    public final void replaceAtUsages(Node replacement, Predicate<Node> filter, boolean checkInvariants) {\n        replaceAtUsages(replacement, filter, false, checkInvariants);\n    }\n\n    /**\n     * For each use of {@code this} in another node, replace it with {@code replacement} and then\n     * {@linkplain #safeDelete() remove} {@code this} from the graph.\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    public final void replaceAtUsagesAndDelete(Node replacement) {\n        replaceAtUsages(replacement, null, true, true);\n        safeDelete();\n    }\n\n    /**\n     * For each use of {@code this} in another node, {@code n}, replace it with {@code replacement}\n     * if {@code filter == null} or {@code filter.test(n) == true}.\n     *\n     * @param forDeletion specifies if the caller will {@linkplain #safeDelete() remove}\n     *            {@code this} from the graph after this method returns\n     * @see #replaceAtUsages(Node)\n     */\n    private void replaceAtUsages(Node replacement, Predicate<Node> filter, boolean forDeletion, boolean checkInvariants) {\n        if (filter == null) {\n            replaceAtAllUsages(replacement, forDeletion);\n        } else {\n            replaceAtMatchingUsages(replacement, filter, forDeletion);\n        }\n        assert !checkInvariants || checkReplaceAtUsagesInvariants(replacement);\n    }\n\n    /**\n     * Subclasses can override this to check invariants related to replacing uses of {@code this}.\n     *\n     * @param replacement\n     * @return {@code true} if all invariants hold\n     */\n    protected boolean checkReplaceAtUsagesInvariants(Node replacement) {\n        return true;\n    }\n\n    /**\n     * For each use of {@code this} in another node, replace it with {@code replacement}.\n     *\n     * @param forDeletion specifies if the caller will {@linkplain #safeDelete() remove}\n     *            {@code this} from the graph after this method returns\n     */\n    public final void replaceAtAllUsages(Node replacement, boolean forDeletion) {\n        checkReplaceWith(replacement);\n        if (usage0 == null) {\n            return;\n        }\n        replaceAtUsage(replacement, forDeletion, usage0);\n        usage0 = null;\n\n        if (usage1 == null) {\n            return;\n        }\n        replaceAtUsage(replacement, forDeletion, usage1);\n        usage1 = null;\n\n        if (extraUsagesCount <= 0) {\n            return;\n        }\n        for (int i = 0; i < extraUsagesCount; i++) {\n            Node usage = extraUsages[i];\n            replaceAtUsage(replacement, forDeletion, usage);\n        }\n        this.extraUsages = EMPTY_ARRAY;\n        this.extraUsagesCount = 0;\n    }\n\n    /**\n     * For the use of {@code this} in another node represented by {@code usage}, replace it with\n     * {@code replacement}.\n     *\n     * @param forDeletion specifies if the caller will {@linkplain #safeDelete() remove}\n     *            {@code this} from the graph after this method returns\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    private void replaceAtUsage(Node replacement, boolean forDeletion, Node usage) {\n        boolean result = usage.getNodeClass().replaceFirstInput(usage, this, replacement);\n        assertTrue(result, \"not found in inputs, usage: %s\", usage);\n        /*\n         * Don't notify for nodes which are about to be deleted.\n         */\n        if (!forDeletion || usage != this) {\n            maybeNotifyInputChanged(usage);\n        }\n        if (replacement != null) {\n            replacement.addUsage(usage);\n        }\n    }\n\n    /**\n     * For each use of {@code this} in another node, {@code n}, replace it with {@code replacement}\n     * if {@code filter.test(n) == true}.\n     *\n     * @param forDeletion specifies if the caller will {@linkplain #safeDelete() remove}\n     *            {@code this} from the graph after this method returns\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    private void replaceAtMatchingUsages(Node replacement, Predicate<Node> filter, boolean forDeletion) {\n        Objects.requireNonNull(filter);\n        checkReplaceWith(replacement);\n        int i = 0;\n        int usageCount = this.getUsageCount();\n        while (i < usageCount) {\n            Node usage = this.getUsageAt(i);\n            if (filter.test(usage)) {\n                replaceAtUsage(replacement, forDeletion, usage);\n                this.movUsageFromEndTo(i);\n                usageCount--;\n            } else {\n                ++i;\n            }\n        }\n    }\n\n    private Node getUsageAt(int index) {\n        if (index == 0) {\n            return this.usage0;\n        } else if (index == 1) {\n            return this.usage1;\n        } else {\n            return this.extraUsages[index - INLINE_USAGE_COUNT];\n        }\n    }\n\n    public Node singleUsage() {\n        assert hasExactlyOneUsage();\n        return this.usage0;\n    }\n\n    /**\n     * For each use of {@code this} in another node, {@code n}, replace it with {@code replacement}\n     * if {@code filter.test(n) == true}.\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    public void replaceAtMatchingUsages(Node replacement, NodePredicate usagePredicate) {\n        checkReplaceWith(replacement);\n        replaceAtMatchingUsages(replacement, usagePredicate, false);\n    }\n\n    private void replaceAtUsagePos(Node replacement, Node usage, Position pos) {\n        pos.initialize(usage, replacement);\n        maybeNotifyInputChanged(usage);\n        if (replacement != null) {\n            replacement.addUsage(usage);\n        }\n    }\n\n    /**\n     * For each use of {@code this} in another node, {@code n}, replace it with {@code replacement}\n     * if the type of the use is {@code inputType}.\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    public void replaceAtUsages(Node replacement, InputType inputType) {\n        checkReplaceWith(replacement);\n        int i = 0;\n        int usageCount = this.getUsageCount();\n        if (usageCount == 0) {\n            return;\n        }\n        usages: while (i < usageCount) {\n            Node usage = this.getUsageAt(i);\n            for (Position pos : usage.inputPositions()) {\n                if (pos.getInputType() == inputType && pos.get(usage) == this) {\n                    replaceAtUsagePos(replacement, usage, pos);\n                    this.movUsageFromEndTo(i);\n                    usageCount--;\n                    continue usages;\n                }\n            }\n            i++;\n        }\n        if (hasNoUsages()) {\n            maybeNotifyZeroUsages(this);\n        }\n    }\n\n    /**\n     * For each use of {@code this} in another node, {@code n}, replace it with {@code replacement}\n     * if the type of the use is in {@code inputTypes}.\n     *\n     * @see #replaceAtUsages(Node)\n     */\n    public void replaceAtUsages(Node replacement, InputType... inputTypes) {\n        checkReplaceWith(replacement);\n        int i = 0;\n        int usageCount = this.getUsageCount();\n        if (usageCount == 0) {\n            return;\n        }\n        usages: while (i < usageCount) {\n            Node usage = this.getUsageAt(i);\n            for (Position pos : usage.inputPositions()) {\n                for (InputType type : inputTypes) {\n                    if (pos.getInputType() == type && pos.get(usage) == this) {\n                        replaceAtUsagePos(replacement, usage, pos);\n                        this.movUsageFromEndTo(i);\n                        usageCount--;\n                        continue usages;\n                    }\n                }\n            }\n            i++;\n        }\n        if (hasNoUsages()) {\n            maybeNotifyZeroUsages(this);\n        }\n    }\n\n    private void maybeNotifyInputChanged(Node node) {\n        if (graph != null) {\n            assert !graph.isFrozen();\n            NodeEventListener listener = graph.nodeEventListener;\n            fireNodeEvent(node, listener, Graph.NodeEvent.INPUT_CHANGED);\n            graph.edgeModificationCount++;\n        }\n    }\n\n    /**\n     * Iterates over each {@link NodeEventListener} attached to {@code this.graph()} if\n     * {@code node.isAlive()} and notifies the listener that {@code node} has had its last usage\n     * removed.\n     */\n    public void maybeNotifyZeroUsages(Node node) {\n        if (graph != null && node.isAlive()) {\n            assert !graph.isFrozen();\n            NodeEventListener listener = graph.nodeEventListener;\n            fireNodeEvent(node, listener, Graph.NodeEvent.ZERO_USAGES);\n        }\n    }\n\n    private void fireNodeEvent(Node node, NodeEventListener listener, Graph.NodeEvent nodeEvent) {\n        if (listener != null) {\n            listener.event(nodeEvent, node);\n        }\n    }\n\n    /**\n     * Updates the control flow edge, if it exists, from {@link #predecessor()} to {@code this} to\n     * have a target of {@code replacement}.\n     */\n    public void replaceAtPredecessor(Node replacement) {\n        checkReplaceWith(replacement);\n        if (predecessor != null) {\n            if (!predecessor.getNodeClass().replaceFirstSuccessor(predecessor, this, replacement)) {\n                fail(\"not found in successors, predecessor: %s\", predecessor);\n            }\n            predecessor.updatePredecessor(this, replacement);\n        }\n    }\n\n    /**\n     * Replaces {@code this} at its predecessor (if any) and its usages with {@code replacement} and\n     * removes it from its graph.\n     */\n    public void replaceAndDelete(Node replacement) {\n        checkReplaceWith(replacement);\n        if (replacement == null) {\n            fail(\"cannot replace with null\");\n        }\n        if (this.hasUsages()) {\n            replaceAtUsages(replacement);\n        }\n        replaceAtPredecessor(replacement);\n        this.safeDelete();\n    }\n\n    /**\n     * Finds the first {@link Successor} in {@code this} whose value is {@code oldSuccessor} and\n     * replaces it with {@code newSuccessor}. The predecessor fields in {@code oldSuccessor} and\n     * {@code newSuccessor} are updated to reflect any change made.\n     */\n    public void replaceFirstSuccessor(Node oldSuccessor, Node newSuccessor) {\n        if (nodeClass.replaceFirstSuccessor(this, oldSuccessor, newSuccessor)) {\n            updatePredecessor(oldSuccessor, newSuccessor);\n        }\n    }\n\n    /**\n     * Finds the first {@link Input} or {@link OptionalInput} in {@code this} whose value is\n     * {@code oldInput} and replaces it with {@code newInput}. If the input is changed, the usage\n     * info for {@code oldInput} and {@code newInput} is updated as well.\n     *\n     * Before {@code this.replaceFirstInput(n0, n2)}:\n     *\n     * <pre>\n     *       n0  n1  n0\n     *        \\  |  /\n     *         \\ | /\n     *          \\|/\n     *           |\n     *           V\n     *         this\n     * </pre>\n     *\n     * After {@code this.replaceFirstInput(n0, n2)}:\n     *\n     * <pre>\n     *       n2  n1  n0\n     *        \\  |  /\n     *         \\ | /\n     *          \\|/\n     *           |\n     *           V\n     *         this\n     * </pre>\n     */\n    public void replaceFirstInput(Node oldInput, Node newInput) {\n        if (nodeClass.replaceFirstInput(this, oldInput, newInput)) {\n            updateUsages(oldInput, newInput);\n        }\n    }\n\n    /**\n     * Finds all {@link Input}s and {@link OptionalInput}s in {@code this} whose value is\n     * {@code oldInput} and replaces them with {@code newInput}. If any input is changed, the usage\n     * info for {@code oldInput} and {@code newInput} is updated as well.\n     *\n     * Before {@code this.replaceAllInputs(n0, n2)}:\n     *\n     * <pre>\n     *       n0  n1  n0\n     *        \\  |  /\n     *         \\ | /\n     *          \\|/\n     *           |\n     *           V\n     *         this\n     * </pre>\n     *\n     * After {@code this.replaceAllInputs(n0, n2)}:\n     *\n     * <pre>\n     *       n2  n1  n2\n     *        \\  |  /\n     *         \\ | /\n     *          \\|/\n     *           |\n     *           V\n     *         this\n     * </pre>\n     */\n    public void replaceAllInputs(Node oldInput, Node newInput) {\n        while (nodeClass.replaceFirstInput(this, oldInput, newInput)) {\n            updateUsages(oldInput, newInput);\n        }\n    }\n\n    public void clearInputs() {\n        assertFalse(isDeleted(), \"cannot clear inputs of deleted node\");\n        getNodeClass().unregisterAtInputsAsUsage(this);\n    }\n\n    boolean removeThisFromUsages(Node n) {\n        return n.removeUsage(this);\n    }\n\n    public void clearSuccessors() {\n        assertFalse(isDeleted(), \"cannot clear successors of deleted node\");\n        getNodeClass().unregisterAtSuccessorsAsPredecessor(this);\n    }\n\n    private boolean checkDeletion() {\n        assertTrue(isAlive(), \"must be alive\");\n        assertTrue(hasNoUsages(), \"cannot delete node %s because of usages: %s\", this, usages());\n        assertTrue(predecessor == null, \"cannot delete node %s because of predecessor: %s\", this, predecessor);\n        return true;\n    }\n\n    /**\n     * Removes {@code this} from {@code this.graph()}. This node must have no\n     * {@linkplain Node#usages() usages} and no {@linkplain #predecessor() predecessor}.\n     */\n    public void safeDelete() {\n        assert checkDeletion();\n        this.clearInputs();\n        this.clearSuccessors();\n        markDeleted();\n    }\n\n    public void markDeleted() {\n        graph.unregister(this);\n        id = DELETED_ID_START - id;\n        assert isDeleted();\n    }\n\n    public final Node copyWithInputs() {\n        return copyWithInputs(true);\n    }\n\n    public final Node copyWithInputs(boolean insertIntoGraph) {\n        Node newNode = clone(insertIntoGraph ? graph : null, WithOnlyInputEdges);\n        if (insertIntoGraph) {\n            for (Node input : inputs()) {\n                input.addUsage(newNode);\n            }\n        }\n        return newNode;\n    }\n\n    /**\n     * @param newNode the result of cloning {@code this} or {@link Unsafe#allocateInstance(Class)\n     *            raw allocating} a copy of {@code this}\n     * @param type the type of edges to process\n     * @param edgesToCopy if {@code type} is in this set, the edges are copied otherwise they are\n     *            cleared\n     */\n    private void copyOrClearEdgesForClone(Node newNode, Edges.Type type, EnumSet<Edges.Type> edgesToCopy) {\n        if (edgesToCopy.contains(type)) {\n            getNodeClass().getEdges(type).copy(this, newNode);\n        } else {\n            // The direct edges are already null\n            getNodeClass().getEdges(type).initializeLists(newNode, this);\n        }\n    }\n\n    public static final EnumSet<Edges.Type> WithAllEdges = EnumSet.allOf(Edges.Type.class);\n    public static final EnumSet<Edges.Type> WithOnlyInputEdges = EnumSet.of(Edges.Type.Inputs);\n\n    /**\n     * Makes a copy of {@code this} in(to) a given graph.\n     *\n     * @param into the graph in which the copy will be registered (which may be\n     *            {@code this.graph()}) or null if the copy should not be registered in a graph\n     * @param edgesToCopy specifies the edges to be copied. The edges not specified in this set are\n     *            initialized to their default value (i.e., {@code null} for a direct edge, an empty\n     *            list for an edge list)\n     * @return the copy of {@code this}\n     */\n    final Node clone(Graph into, EnumSet<Edges.Type> edgesToCopy) {\n        final NodeClass<? extends Node> nodeClassTmp = getNodeClass();\n        boolean useIntoLeafNodeCache = false;\n        if (into != null) {\n            if (nodeClassTmp.valueNumberable() && nodeClassTmp.isLeafNode()) {\n                useIntoLeafNodeCache = true;\n                Node otherNode = into.findNodeInCache(this);\n                if (otherNode != null) {\n                    return otherNode;\n                }\n            }\n        }\n\n        Node newNode = null;\n        try {\n            newNode = (Node) UNSAFE.allocateInstance(getClass());\n            newNode.nodeClass = nodeClassTmp;\n            nodeClassTmp.getData().copy(this, newNode);\n            copyOrClearEdgesForClone(newNode, Type.Inputs, edgesToCopy);\n            copyOrClearEdgesForClone(newNode, Type.Successors, edgesToCopy);\n        } catch (Exception e) {\n            throw new GraalGraphError(e).addContext(this);\n        }\n        newNode.graph = into;\n        newNode.id = INITIAL_ID;\n        if (getNodeSourcePosition() != null && (into == null || into.trackNodeSourcePosition())) {\n            newNode.setNodeSourcePosition(getNodeSourcePosition());\n        }\n        if (getInsertionPosition() != null) {\n            newNode.setInsertionPosition(getInsertionPosition());\n        }\n        if (into != null) {\n            into.register(newNode);\n        }\n        newNode.extraUsages = EMPTY_ARRAY;\n\n        if (into != null && useIntoLeafNodeCache) {\n            into.putNodeIntoCache(newNode);\n        }\n        newNode.afterClone(this);\n        return newNode;\n    }\n\n    protected void afterClone(@SuppressWarnings(\"unused\") Node other) {\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected boolean verifyInputs() {\n        InputEdges inputEdges = nodeClass.getInputEdges();\n\n        // Verify properties of direct inputs\n        for (int i = 0; i < inputEdges.getDirectCount(); i++) {\n            Node input = (Node) inputEdges.get(this, i);\n            verifyInput(inputEdges, i, input);\n        }\n\n        // Verify properties of input list objects\n        for (int i = inputEdges.getDirectCount(); i < inputEdges.getCount(); i++) {\n            Object inputList = inputEdges.get(this, i);\n            if (inputList == null) {\n                assertTrue(inputEdges.isOptional(i), \"non-optional input list %s cannot be null in %s (fix nullness or use @OptionalInput)\", inputEdges.getName(i), this);\n            } else {\n                NodeList<Node> nodeList = (NodeList<Node>) inputList;\n                for (Node input : nodeList) {\n                    verifyInput(inputEdges, i, input);\n                }\n            }\n        }\n        return true;\n    }\n\n    private void verifyInput(InputEdges inputEdges, int i, Node input) {\n        if (input == null) {\n            assertTrue(inputEdges.isOptional(i), \"non-optional input %s cannot be null in %s (fix nullness or use @OptionalInput)\", inputEdges.getName(i), this);\n        } else {\n            assertFalse(input.isDeleted(), \"input was deleted %s\", input);\n            assertTrue(input.isAlive(), \"input is not alive yet, i.e., it was not yet added to the graph\");\n            InputType inputType = inputEdges.getInputType(i);\n            assertTrue(inputType == InputType.Unchecked || input.isAllowedUsageType(inputType), \"invalid usage type input:%s inputType:%s inputField:%s\", input,\n                            inputType, inputEdges.getName(i));\n            Class<?> expectedType = i < inputEdges.getDirectCount() ? inputEdges.getType(i) : Node.class;\n            assertTrue(expectedType.isAssignableFrom(input.getClass()), \"Invalid input type for %s: expected a %s but was a %s\", inputEdges.getName(i), expectedType, input.getClass());\n        }\n    }\n\n    public final boolean verify() {\n        return verify(true);\n    }\n\n    /**\n     * Basic verification of node properties. This method is final so that a node cannot\n     * accidentally skip calling super(). Node specific verification should be done in\n     * {@link #verifyNode()}.\n     */\n    public final boolean verify(boolean verifyInputs) {\n        assertTrue(isAlive(), \"cannot verify inactive node %s\", this);\n        assertTrue(graph != null, \"null graph\");\n        if (verifyInputs) {\n            verifyInputs();\n        }\n        if (graph.verifyGraphEdges) {\n            verifyEdges();\n        }\n        verifyNode();\n        return true;\n    }\n\n    /**\n     * Verify node properties which are not covered by {@link #verify()}.\n     */\n    protected boolean verifyNode() {\n        return true;\n    }\n\n    /**\n     * Perform expensive verification of inputs, usages, predecessors and successors.\n     *\n     * @return true\n     */\n    public boolean verifyEdges() {\n        for (Node input : inputs()) {\n            assertTrue(input == null || input.usages().contains(this), \"missing usage of %s in input %s\", this, input);\n        }\n\n        for (Node successor : successors()) {\n            assertTrue(successor.predecessor() == this, \"missing predecessor in %s (actual: %s)\", successor, successor.predecessor());\n            assertTrue(successor.graph == graph, \"mismatching graph in successor %s\", successor);\n        }\n        for (Node usage : usages()) {\n            assertFalse(usage.isDeleted(), \"usage %s must never be deleted\", usage);\n            assertTrue(usage.inputs().contains(this), \"missing input in usage %s\", usage);\n            boolean foundThis = false;\n            for (Position pos : usage.inputPositions()) {\n                if (pos.get(usage) == this) {\n                    foundThis = true;\n                    if (pos.getInputType() != InputType.Unchecked) {\n                        assertTrue(isAllowedUsageType(pos.getInputType()), \"invalid input of type %s from %s to %s (%s)\", pos.getInputType(), usage, this, pos.getName());\n                    }\n                }\n            }\n            assertTrue(foundThis, \"missing input in usage %s\", usage);\n        }\n\n        if (predecessor != null) {\n            assertFalse(predecessor.isDeleted(), \"predecessor %s must never be deleted\", predecessor);\n            assertTrue(predecessor.successors().contains(this), \"missing successor in predecessor %s\", predecessor);\n        }\n        return true;\n    }\n\n    public boolean assertTrue(boolean condition, String message, Object... args) {\n        if (condition) {\n            return true;\n        } else {\n            throw fail(message, args);\n        }\n    }\n\n    public boolean assertFalse(boolean condition, String message, Object... args) {\n        if (condition) {\n            throw fail(message, args);\n        } else {\n            return true;\n        }\n    }\n\n    protected GraalGraphError fail(String message, Object... args) throws GraalGraphError {\n        throw new GraalGraphError(message, args).addContext(this);\n    }\n\n    public Iterable<? extends Node> cfgPredecessors() {\n        if (predecessor == null) {\n            return Collections.emptySet();\n        } else {\n            return Collections.singleton(predecessor);\n        }\n    }\n\n    /**\n     * Returns an iterator that will provide all control-flow successors of {@code this}. Normally\n     * this will be the contents of all fields annotated with {@link Successor}, but some node\n     * classes (like EndNode) may return different nodes.\n     */\n    public Iterable<? extends Node> cfgSuccessors() {\n        return successors();\n    }\n\n    /**\n     * Nodes using their {@link #id} as the hash code. This works very well when nodes of the same\n     * graph are stored in sets. It can give bad behavior when storing nodes of different graphs in\n     * the same set.\n     */\n    @Override\n    public final int hashCode() {\n        assert !this.isUnregistered() : \"node not yet constructed\";\n        if (this.isDeleted()) {\n            return -id + DELETED_ID_START;\n        }\n        return id;\n    }\n\n    /*\n     * Do not overwrite the equality test of a node in subclasses. Equality tests must rely solely\n     * on identity.\n     */\n\n    /**\n     * Provides a {@link Map} of properties of {@code this} for use in debugging (e.g., to view in\n     * the ideal graph visualizer).\n     */\n    public final Map<Object, Object> getDebugProperties() {\n        return getDebugProperties(new HashMap<>());\n    }\n\n    /**\n     * Fills a {@link Map} with properties of {@code this} for use in debugging (e.g., to view in\n     * the ideal graph visualizer). Subclasses overriding this method should also fill the map using\n     * their superclass.\n     *\n     * @param map\n     */\n    public Map<Object, Object> getDebugProperties(Map<Object, Object> map) {\n        Fields properties = getNodeClass().getData();\n        for (int i = 0; i < properties.getCount(); i++) {\n            Object value = properties.get(this, i);\n            if (properties.getType(i) == Character.TYPE) {\n                // Convert a char to an int as chars are not guaranteed to printable/viewable\n                char ch = (char) value;\n                value = Integer.valueOf(ch);\n            }\n            map.put(properties.getName(i), value);\n        }\n        NodeSourcePosition pos = getNodeSourcePosition();\n        if (pos != null) {\n            map.put(\"nodeSourcePosition\", pos);\n        }\n        NodeCreationStackTrace creation = getCreationPosition();\n        if (creation != null) {\n            map.put(\"nodeCreationPosition\", creation.getStrackTraceString());\n        }\n        NodeInsertionStackTrace insertion = getInsertionPosition();\n        if (insertion != null) {\n            map.put(\"nodeInsertionPosition\", insertion.getStrackTraceString());\n        }\n        return map;\n    }\n\n    /**\n     * This method is a shortcut for {@link #toString(Verbosity)} with {@link Verbosity#Short}.\n     */\n    @Override\n    public final String toString() {\n        return toString(Verbosity.Short);\n    }\n\n    /**\n     * Creates a String representation for {@code this} with a given {@link Verbosity}.\n     */\n    public String toString(Verbosity verbosity) {\n        switch (verbosity) {\n            case Id:\n                return Integer.toString(id);\n            case Name:\n                return getNodeClass().shortName();\n            case Short:\n                return toString(Verbosity.Id) + \"|\" + toString(Verbosity.Name);\n            case Long:\n                return toString(Verbosity.Short);\n            case Debugger:\n            case All: {\n                StringBuilder str = new StringBuilder();\n                str.append(toString(Verbosity.Short)).append(\" { \");\n                for (Map.Entry<Object, Object> entry : getDebugProperties().entrySet()) {\n                    str.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\", \");\n                }\n                str.append(\" }\");\n                return str.toString();\n            }\n            default:\n                throw new RuntimeException(\"unknown verbosity: \" + verbosity);\n        }\n    }\n\n    @Deprecated\n    public int getId() {\n        return id;\n    }\n\n    @Deprecated\n    public int getIdBeforeDeletion() {\n        assert isDeleted();\n        return (id - DELETED_ID_START) * -1;\n    }\n\n    @Override\n    public void formatTo(Formatter formatter, int flags, int width, int precision) {\n        if ((flags & FormattableFlags.ALTERNATE) == FormattableFlags.ALTERNATE) {\n            formatter.format(\"%s\", toString(Verbosity.Id));\n        } else if ((flags & FormattableFlags.UPPERCASE) == FormattableFlags.UPPERCASE) {\n            // Use All here since Long is only slightly longer than Short.\n            formatter.format(\"%s\", toString(Verbosity.All));\n        } else {\n            formatter.format(\"%s\", toString(Verbosity.Short));\n        }\n\n        boolean neighborsAlternate = ((flags & FormattableFlags.LEFT_JUSTIFY) == FormattableFlags.LEFT_JUSTIFY);\n        int neighborsFlags = (neighborsAlternate ? FormattableFlags.ALTERNATE | FormattableFlags.LEFT_JUSTIFY : 0);\n        if (width > 0) {\n            if (this.predecessor != null) {\n                formatter.format(\" pred={\");\n                this.predecessor.formatTo(formatter, neighborsFlags, width - 1, 0);\n                formatter.format(\"}\");\n            }\n\n            for (Position position : this.inputPositions()) {\n                Node input = position.get(this);\n                if (input != null) {\n                    formatter.format(\" \");\n                    formatter.format(position.getName());\n                    formatter.format(\"={\");\n                    input.formatTo(formatter, neighborsFlags, width - 1, 0);\n                    formatter.format(\"}\");\n                }\n            }\n        }\n\n        if (precision > 0) {\n            if (!hasNoUsages()) {\n                formatter.format(\" usages={\");\n                int z = 0;\n                for (Node usage : usages()) {\n                    if (z != 0) {\n                        formatter.format(\", \");\n                    }\n                    usage.formatTo(formatter, neighborsFlags, 0, precision - 1);\n                    ++z;\n                }\n                formatter.format(\"}\");\n            }\n\n            for (Position position : this.successorPositions()) {\n                Node successor = position.get(this);\n                if (successor != null) {\n                    formatter.format(\" \");\n                    formatter.format(position.getName());\n                    formatter.format(\"={\");\n                    successor.formatTo(formatter, neighborsFlags, 0, precision - 1);\n                    formatter.format(\"}\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Determines if this node's {@link NodeClass#getData() data} fields are equal to the data\n     * fields of another node of the same type. Primitive fields are compared by value and\n     * non-primitive fields are compared by {@link Objects#equals(Object, Object)}.\n     *\n     * The result of this method undefined if {@code other.getClass() != this.getClass()}.\n     *\n     * @param other a node of exactly the same type as {@code this}\n     * @return true if the data fields of this object and {@code other} are equal\n     */\n    public final boolean valueEquals(Node other) {\n        return getNodeClass().dataEquals(this, other);\n    }\n\n    /**\n     * Determines if {@code this} is equal to the other node while ignoring differences in\n     * {@linkplain Successor control-flow} edges.\n     *\n     */\n    public final boolean dataFlowEquals(Node other) {\n        return this == other || nodeClass == other.getNodeClass() && this.valueEquals(other) && nodeClass.equalInputs(this, other);\n    }\n\n    public final void pushInputs(NodeStack stack) {\n        getNodeClass().pushInputs(this, stack);\n    }\n\n    public final NodeSize estimatedNodeSize() {\n        try {\n            return dynamicNodeSizeEstimate();\n        } catch (Exception e) {\n            throw GraalError.shouldNotReachHere(e, \"Exception during node cost estimation\"); // ExcludeFromJacocoGeneratedReport\n        }\n    }\n\n    /**\n     * Node subclasses should override this method if they need to specify a dynamically calculated\n     * {@link NodeSize} value. If the node size is static please use {@link NodeInfo#size()}.\n     *\n     * NOTE: When overriding this method, make sure that *all* field reads are null checked (even if\n     * Java semantics seemingly make the value of the field non-null). This is necessary because\n     * node size estimates are needed even during graph decoding which, for some nodes, first\n     * reflectively creates a stub and then later, reflectively, populates its fields. This method\n     * could be invoked between these two points. For this reason, when overriding this method\n     * assume that all fields can and will be null.\n     *\n     * @return The estimated node size for this node.\n     */\n    protected NodeSize dynamicNodeSizeEstimate() {\n        return nodeClass.size();\n    }\n\n    public NodeCycles estimatedNodeCycles() {\n        return nodeClass.cycles();\n    }\n\n}",
                "methodCount": 120
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 9,
                "candidates": [
                    {
                        "lineStart": 1367,
                        "lineEnd": 1371,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method markDeleted to class Graph",
                        "description": "Move method markDeleted to jdk.graal.compiler.graph.Graph\nRationale: The method 'markDeleted()' interacts directly with the Graph class by calling the 'unregister()' method on the graph instance. Additionally, the method manipulates the id related directly to the graph's concept of node management. Therefore, 'markDeleted()' has a closer logical relationship with the Graph class than any other context likely present.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1340,
                        "lineEnd": 1342,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method removeThisFromUsages to class Graph",
                        "description": "Move method removeThisFromUsages to jdk.graal.compiler.graph.Graph\nRationale: The method `removeThisFromUsages(Node n)` is highly relevant to the functionality of managing nodes within a graph structure. Since `Graph` contains the set of nodes and manages their relationships, including registration, tracking, and removal of nodes, the method should be moved to this class. By doing this, the method will have direct access to the internal state and methods of `Graph` like `nodes`, `nodeUsageModCounts`, and relevant event listeners. This will facilitate better integration and maintainability of the code, as the functionality of node management is consolidated within the Graph class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 894,
                        "lineEnd": 896,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method withNodeSourcePosition to class Graph",
                        "description": "Move method withNodeSourcePosition to jdk.graal.compiler.graph.Graph\nRationale: The method 'withNodeSourcePosition()' is currently delegating its task to a method within the Graph class: 'graph.withNodeSourcePosition(this)'. This direct interaction with the Graph's method indicates that the functionality closely relates to the Graph class. Therefore, encapsulating this method within the Graph class would make the design more cohesive and logically structured.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1487,
                        "lineEnd": 1499,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method verifyInput to class InputEdges",
                        "description": "Move method verifyInput to jdk.graal.compiler.graph.InputEdges\nRationale: The method `verifyInput` relies heavily on the structure and members of the `InputEdges` class, such as `getInputType`, `isOptional`, `getName`, and `getType`. It performs validation based on the input types and optional status that are inherent properties of the `InputEdges`. Therefore, moving this method to `InputEdges` is appropriate, as it utilizes the class's core functionalities and maintains encapsulation principles.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1218,
                        "lineEnd": 1222,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method fireNodeEvent to class NodeEventListener",
                        "description": "Move method fireNodeEvent to jdk.graal.compiler.graph.Graph.NodeEventListener\nRationale: The method fireNodeEvent deals directly with notifying the NodeEventListener about events related to a Node. This functionality is tightly coupled with the responsibilities of the NodeEventListener class, making it the most appropriate place for this method. Moving the method to NodeEventListener also makes sense because it encapsulates the event-handling logic within the listener itself, which aligns with typical event-driven design patterns.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 724,
                        "lineEnd": 729,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method usageModCount to class Graph",
                        "description": "Move method usageModCount to jdk.graal.compiler.graph.Graph\nRationale: The method 'usageModCount()' is tightly coupled with the 'Graph' class because it directly uses the 'graph' instance and invokes the 'graph.nodeUsageModCount()' method. More importantly, the method relies on the 'isNodeModificationCountsEnabled()' static method within the 'Graph' class to determine its behavior. Given this strong dependency, it makes sense to place 'usageModCount()' within the 'Graph' class to keep related concerns together and enhance cohesion. Moving this method will allow better encapsulation and clearer structure within the object-oriented design.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 909,
                        "lineEnd": 923,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method checkReplaceWith to class Graph",
                        "description": "Move method checkReplaceWith to jdk.graal.compiler.graph.Graph\nRationale: The method `checkReplaceWith` makes extensive checks related to the state of the graph, such as whether it is frozen and whether nodes (including the replacement node) are deleted. These checks suggest that the method is concerned with the integrity of the graph's structure. As such, it aligns well with the responsibilities of the `Graph` class, which manages the nodes and the overall state of the graph. Furthermore, `Graph` already maintains properties and methods related to frozen states, such as the `FreezeState` and related methods like `unfreeze()`. Moving the method to `Graph` will centralize the graph-related integrity checks within the class responsible for the graph structure itself.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 718,
                        "lineEnd": 722,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method incModCount to class Graph",
                        "description": "Move method incModCount to jdk.graal.compiler.graph.Graph\nRationale: The method `incModCount()` interacts directly with properties and methods of the `Graph` class, such as checking the state of `isNodeModificationCountsEnabled()` and invoking `graph.incNodeModCount(this)`. Given that it modifies aspects of the graph and relies on graph-related checks and behaviors, it is more appropriate for it to be encapsulated within the `Graph` class to keep all graph-modifying operations in one place, thereby enhancing cohesion and maintainability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 731,
                        "lineEnd": 735,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method incUsageModCount to class Graph",
                        "description": "Move method incUsageModCount to jdk.graal.compiler.graph.Graph\nRationale: The method incUsageModCount() is tightly coupled with the Graph class, particularly with its node modification counting logic. The method directly interacts with the Graph's internal state through the `graph` field and the `isNodeModificationCountsEnabled()` method. Since `graph.incNodeUsageModCount(this)` is a direct Graph method invocation and the modification count logic is handled by the Graph class, it is more appropriate for incUsageModCount() to reside in the Graph class. This would centralize the modification counting logic within the Graph class, improving coherence and maintainability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getUnsafe",
                            "method_signature": "private static Unsafe getUnsafe()",
                            "target_class": "UtilityClass",
                            "rationale": "The getUnsafe() method is generally used to obtain an instance of the Unsafe class, typically for low-level operations that are not specific to the Node class. Moving it to a utility class makes it more reusable and separates concerns."
                        },
                        {
                            "method_name": "assertTrue",
                            "method_signature": "public boolean assertTrue(boolean condition, String message, Object... args)",
                            "target_class": "Assertions",
                            "rationale": "The assertTrue method is a generic utility for checking conditions, throwing an exception if the condition is false. This behavior is not specific to the Node class and could be reused across other classes, so it should be moved to a dedicated Assertions class."
                        },
                        {
                            "method_name": "assertFalse",
                            "method_signature": "public boolean assertFalse(boolean condition, String message, Object... args)",
                            "target_class": "Assertions",
                            "rationale": "Similar to the assertTrue method, assertFalse method is a generic utility for checking conditions and is not specific to Node class. It is better placed in a dedicated Assertions class for reuse."
                        },
                        {
                            "method_name": "fail",
                            "method_signature": "protected GraalGraphError fail(String message, Object... args)",
                            "target_class": "Assertions",
                            "rationale": "The fail method is used for error handling, which is a common utility function not tied to the Node class. Moving it to an Assertions class helps in centralizing error handling logic."
                        },
                        {
                            "method_name": "fieldsTo",
                            "method_signature": "public NodeFormat appendFields(NodeFormat format, int flags, int width, int precision)",
                            "target_class": "Formatter",
                            "rationale": "The fieldsTo method is responsible for handling formatting, which is a distinct concern. Moving it to a Formatter class makes it reusable and keeps the Node class focused on core functionalities."
                        }
                    ],
                    "llm_response_time": 7025
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "replaceAtUsages",
                            "method_signature": "public final void replaceAtUsages(Node replacement)",
                            "target_class": "Graph",
                            "rationale": "This method performs operations that are related to the graph structure rather than the Node itself. Moving it to the Graph class would centralize operations affecting the graph and better encapsulate graph-specific logic."
                        },
                        {
                            "method_name": "replaceAtPredecessor",
                            "method_signature": "public void replaceAtPredecessor(Node replacement)",
                            "target_class": "Graph",
                            "rationale": "Similar to replaceAtUsages, this method involves modifying relationships between nodes, which is better placed in a class that manages the graph structure."
                        },
                        {
                            "method_name": "replaceAndDelete",
                            "method_signature": "public void replaceAndDelete(Node replacement)",
                            "target_class": "Graph",
                            "rationale": "This method is involved in handling graph modifications, such as node replacement and deletion. Thus, it would be more appropriate in the Graph class."
                        },
                        {
                            "method_name": "safeDelete",
                            "method_signature": "public void safeDelete()",
                            "target_class": "Graph",
                            "rationale": "This method deals with the deletion of nodes within the graph, which logically falls under the management of the Graph class."
                        },
                        {
                            "method_name": "markDeleted",
                            "method_signature": "public void markDeleted()",
                            "target_class": "Graph",
                            "rationale": "The marking of a node as deleted and managing its status should be handled by the Graph class, which is responsible for the lifecycle of nodes."
                        }
                    ],
                    "llm_response_time": 5692
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "applyInputs",
                            "method_signature": "public void applyInputs(EdgeVisitor visitor)",
                            "target_class": "NodeClass",
                            "rationale": "The applyInputs() method heavily relies on nodeClass and doesn't primarily act on the state of the Node instance."
                        },
                        {
                            "method_name": "applySuccessors",
                            "method_signature": "public void applySuccessors(EdgeVisitor visitor)",
                            "target_class": "NodeClass",
                            "rationale": "Similar to applyInputs(), applySuccessors() heavily relies on nodeClass and doesn't act directly on the Node instance."
                        },
                        {
                            "method_name": "verifyInputs",
                            "method_signature": "protected boolean verifyInputs()",
                            "target_class": "NodeClass",
                            "rationale": "verifyInputs() uses the nodeClass extensively to validate input fields, and would be more appropriately placed within the NodeClass class."
                        },
                        {
                            "method_name": "verify",
                            "method_signature": "public final boolean verify(boolean verifyInputs)",
                            "target_class": "NodeClass",
                            "rationale": "The verify method encapsulates validation logic that typically belongs in NodeClass, making it a more suitable location for this method."
                        }
                    ],
                    "llm_response_time": 4636
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "init",
                            "method_signature": "final init(NodeClass<? extends Node> c)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "inputs",
                            "method_signature": "public inputs()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "inputPositions",
                            "method_signature": "public inputPositions()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "applyInputs",
                            "method_signature": "public applyInputs(EdgeVisitor visitor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "applySuccessors",
                            "method_signature": "public applySuccessors(EdgeVisitor visitor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "successors",
                            "method_signature": "public successors()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "successorPositions",
                            "method_signature": "public successorPositions()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "hasExactlyOneUsageOfType",
                            "method_signature": "public final hasExactlyOneUsageOfType(InputType inputType)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeDeadUsages",
                            "method_signature": "public removeDeadUsages()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "modCount",
                            "method_signature": "public final modCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "incModCount",
                            "method_signature": "final incModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "usageModCount",
                            "method_signature": "final usageModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "incUsageModCount",
                            "method_signature": "final incUsageModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "updateUsages",
                            "method_signature": "protected updateUsages(Node oldInput, Node newInput)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "updatePredecessor",
                            "method_signature": "protected updatePredecessor(Node oldSuccessor, Node newSuccessor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "initialize",
                            "method_signature": " initialize(Graph newGraph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "withNodeSourcePosition",
                            "method_signature": "public withNodeSourcePosition()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "checkReplaceWith",
                            "method_signature": "private checkReplaceWith(Node replacement)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAtUsage",
                            "method_signature": "private replaceAtUsage(Node replacement, boolean forDeletion, Node usage)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAtUsagePos",
                            "method_signature": "private replaceAtUsagePos(Node replacement, Node usage, Position pos)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAtUsages",
                            "method_signature": "public replaceAtUsages(Node replacement, InputType inputType)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAtUsages",
                            "method_signature": "public replaceAtUsages(Node replacement, InputType... inputTypes)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "maybeNotifyInputChanged",
                            "method_signature": "private maybeNotifyInputChanged(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "maybeNotifyZeroUsages",
                            "method_signature": "public maybeNotifyZeroUsages(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "fireNodeEvent",
                            "method_signature": "private fireNodeEvent(Node node, NodeEventListener listener, Graph.NodeEvent nodeEvent)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAtPredecessor",
                            "method_signature": "public replaceAtPredecessor(Node replacement)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceFirstSuccessor",
                            "method_signature": "public replaceFirstSuccessor(Node oldSuccessor, Node newSuccessor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceFirstInput",
                            "method_signature": "public replaceFirstInput(Node oldInput, Node newInput)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAllInputs",
                            "method_signature": "public replaceAllInputs(Node oldInput, Node newInput)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeThisFromUsages",
                            "method_signature": " removeThisFromUsages(Node n)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "markDeleted",
                            "method_signature": "public markDeleted()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "copyWithInputs",
                            "method_signature": "public final copyWithInputs(boolean insertIntoGraph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "clone",
                            "method_signature": "final clone(Graph into, EnumSet<Edges.Type> edgesToCopy)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verifyInputs",
                            "method_signature": "@SuppressWarnings(\"unchecked\")\n    protected verifyInputs()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verifyInput",
                            "method_signature": "private verifyInput(InputEdges inputEdges, int i, Node input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verify",
                            "method_signature": "public final verify(boolean verifyInputs)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verifyEdges",
                            "method_signature": "public verifyEdges()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "dataFlowEquals",
                            "method_signature": "public final dataFlowEquals(Node other)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "dynamicNodeSizeEstimate",
                            "method_signature": "protected dynamicNodeSizeEstimate()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "estimatedNodeCycles",
                            "method_signature": "public estimatedNodeCycles()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "initialize",
                            "method_signature": " initialize(Graph newGraph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "markDeleted",
                            "method_signature": "public markDeleted()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "removeThisFromUsages",
                            "method_signature": " removeThisFromUsages(Node n)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "init",
                            "method_signature": "final init(NodeClass<? extends Node> c)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "withNodeSourcePosition",
                            "method_signature": "public withNodeSourcePosition()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "estimatedNodeCycles",
                            "method_signature": "public estimatedNodeCycles()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verifyInput",
                            "method_signature": "private verifyInput(InputEdges inputEdges, int i, Node input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "maybeNotifyInputChanged",
                            "method_signature": "private maybeNotifyInputChanged(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "fireNodeEvent",
                            "method_signature": "private fireNodeEvent(Node node, NodeEventListener listener, Graph.NodeEvent nodeEvent)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "replaceAtUsagePos",
                            "method_signature": "private replaceAtUsagePos(Node replacement, Node usage, Position pos)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "verifyInputs",
                            "method_signature": "@SuppressWarnings(\"unchecked\")\n    protected verifyInputs()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "usageModCount",
                            "method_signature": "final usageModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "checkReplaceWith",
                            "method_signature": "private checkReplaceWith(Node replacement)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "incModCount",
                            "method_signature": "final incModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "incUsageModCount",
                            "method_signature": "final incUsageModCount()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    " initialize(Graph newGraph)": {
                        "first": {
                            "method_name": "initialize",
                            "method_signature": " initialize(Graph newGraph)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.24350764071908626
                    },
                    "public markDeleted()": {
                        "first": {
                            "method_name": "markDeleted",
                            "method_signature": "public markDeleted()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3202360029374852
                    },
                    " removeThisFromUsages(Node n)": {
                        "first": {
                            "method_name": "removeThisFromUsages",
                            "method_signature": " removeThisFromUsages(Node n)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.35346598168944204
                    },
                    "final init(NodeClass<? extends Node> c)": {
                        "first": {
                            "method_name": "init",
                            "method_signature": "final init(NodeClass<? extends Node> c)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3819591868819131
                    },
                    "public withNodeSourcePosition()": {
                        "first": {
                            "method_name": "withNodeSourcePosition",
                            "method_signature": "public withNodeSourcePosition()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3832984798245837
                    },
                    "public estimatedNodeCycles()": {
                        "first": {
                            "method_name": "estimatedNodeCycles",
                            "method_signature": "public estimatedNodeCycles()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3832984798245837
                    },
                    "private verifyInput(InputEdges inputEdges, int i, Node input)": {
                        "first": {
                            "method_name": "verifyInput",
                            "method_signature": "private verifyInput(InputEdges inputEdges, int i, Node input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.38573568619413046
                    },
                    "private maybeNotifyInputChanged(Node node)": {
                        "first": {
                            "method_name": "maybeNotifyInputChanged",
                            "method_signature": "private maybeNotifyInputChanged(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4183133441934555
                    },
                    "private fireNodeEvent(Node node, NodeEventListener listener, Graph.NodeEvent nodeEvent)": {
                        "first": {
                            "method_name": "fireNodeEvent",
                            "method_signature": "private fireNodeEvent(Node node, NodeEventListener listener, Graph.NodeEvent nodeEvent)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4187118715562931
                    },
                    "private replaceAtUsagePos(Node replacement, Node usage, Position pos)": {
                        "first": {
                            "method_name": "replaceAtUsagePos",
                            "method_signature": "private replaceAtUsagePos(Node replacement, Node usage, Position pos)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.42827183835473676
                    },
                    "@SuppressWarnings(\"unchecked\")\n    protected verifyInputs()": {
                        "first": {
                            "method_name": "verifyInputs",
                            "method_signature": "@SuppressWarnings(\"unchecked\")\n    protected verifyInputs()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4601127552508589
                    },
                    "final usageModCount()": {
                        "first": {
                            "method_name": "usageModCount",
                            "method_signature": "final usageModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4733039986589524
                    },
                    "private checkReplaceWith(Node replacement)": {
                        "first": {
                            "method_name": "checkReplaceWith",
                            "method_signature": "private checkReplaceWith(Node replacement)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4819733348397612
                    },
                    "final incModCount()": {
                        "first": {
                            "method_name": "incModCount",
                            "method_signature": "final incModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.48282185195252453
                    },
                    "final incUsageModCount()": {
                        "first": {
                            "method_name": "incUsageModCount",
                            "method_signature": "final incUsageModCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.48282185195252453
                    }
                },
                "voyage": {
                    "private fireNodeEvent(Node node, NodeEventListener listener, Graph.NodeEvent nodeEvent)": {
                        "first": {
                            "method_name": "fireNodeEvent",
                            "method_signature": "private fireNodeEvent(Node node, NodeEventListener listener, Graph.NodeEvent nodeEvent)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3561574352951883
                    },
                    "public withNodeSourcePosition()": {
                        "first": {
                            "method_name": "withNodeSourcePosition",
                            "method_signature": "public withNodeSourcePosition()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.39167843195077784
                    },
                    "public markDeleted()": {
                        "first": {
                            "method_name": "markDeleted",
                            "method_signature": "public markDeleted()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.40264434654769166
                    },
                    "public successorPositions()": {
                        "first": {
                            "method_name": "successorPositions",
                            "method_signature": "public successorPositions()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.410014472079337
                    },
                    "public replaceFirstSuccessor(Node oldSuccessor, Node newSuccessor)": {
                        "first": {
                            "method_name": "replaceFirstSuccessor",
                            "method_signature": "public replaceFirstSuccessor(Node oldSuccessor, Node newSuccessor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4313999838648405
                    },
                    "private checkReplaceWith(Node replacement)": {
                        "first": {
                            "method_name": "checkReplaceWith",
                            "method_signature": "private checkReplaceWith(Node replacement)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4549851977013257
                    },
                    "public replaceAtPredecessor(Node replacement)": {
                        "first": {
                            "method_name": "replaceAtPredecessor",
                            "method_signature": "public replaceAtPredecessor(Node replacement)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4551882472662303
                    },
                    "public applySuccessors(EdgeVisitor visitor)": {
                        "first": {
                            "method_name": "applySuccessors",
                            "method_signature": "public applySuccessors(EdgeVisitor visitor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.460709760832749
                    },
                    "public final dataFlowEquals(Node other)": {
                        "first": {
                            "method_name": "dataFlowEquals",
                            "method_signature": "public final dataFlowEquals(Node other)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.46127314741153347
                    },
                    "protected dynamicNodeSizeEstimate()": {
                        "first": {
                            "method_name": "dynamicNodeSizeEstimate",
                            "method_signature": "protected dynamicNodeSizeEstimate()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4623284995501987
                    },
                    "public inputPositions()": {
                        "first": {
                            "method_name": "inputPositions",
                            "method_signature": "public inputPositions()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.46600995684209956
                    },
                    "private replaceAtUsagePos(Node replacement, Node usage, Position pos)": {
                        "first": {
                            "method_name": "replaceAtUsagePos",
                            "method_signature": "private replaceAtUsagePos(Node replacement, Node usage, Position pos)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4719654776906519
                    },
                    "public estimatedNodeCycles()": {
                        "first": {
                            "method_name": "estimatedNodeCycles",
                            "method_signature": "public estimatedNodeCycles()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4762909978232515
                    },
                    "protected updatePredecessor(Node oldSuccessor, Node newSuccessor)": {
                        "first": {
                            "method_name": "updatePredecessor",
                            "method_signature": "protected updatePredecessor(Node oldSuccessor, Node newSuccessor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4793123549605381
                    },
                    "public final modCount()": {
                        "first": {
                            "method_name": "modCount",
                            "method_signature": "public final modCount()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4804596532708239
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private fireNodeEvent(Node node, NodeEventListener listener, Graph.NodeEvent nodeEvent)",
                        "private maybeNotifyInputChanged(Node node)",
                        " removeThisFromUsages(Node n)",
                        "public markDeleted()",
                        "final usageModCount()",
                        "final incUsageModCount()",
                        "final incModCount()",
                        "private checkReplaceWith(Node replacement)",
                        " initialize(Graph newGraph)",
                        "final init(NodeClass<? extends Node> c)",
                        "public withNodeSourcePosition()",
                        "private verifyInput(InputEdges inputEdges, int i, Node input)",
                        "private replaceAtUsagePos(Node replacement, Node usage, Position pos)",
                        "public estimatedNodeCycles()"
                    ],
                    "llm_response_time": 4697
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "final init(NodeClass<? extends Node> c)",
                        "public markDeleted()",
                        "public withNodeSourcePosition()"
                    ],
                    "llm_response_time": 4502
                },
                "tf-df-3": {
                    "priority_method_names": [],
                    "llm_response_time": 3223
                },
                "voyage": {
                    "priority_method_names": [
                        "private fireNodeEvent(Node node, NodeEventListener listener, Graph.NodeEvent nodeEvent)",
                        "protected updatePredecessor(Node oldSuccessor, Node newSuccessor)",
                        "private checkReplaceWith(Node replacement)",
                        "private replaceAtUsagePos(Node replacement, Node usage, Position pos)",
                        "protected dynamicNodeSizeEstimate()",
                        "public applySuccessors(EdgeVisitor visitor)",
                        "public replaceFirstSuccessor(Node oldSuccessor, Node newSuccessor)",
                        "public replaceAtPredecessor(Node replacement)",
                        "public successorPositions()",
                        "public inputPositions()",
                        "public estimatedNodeCycles()",
                        "public withNodeSourcePosition()",
                        "public final dataFlowEquals(Node other)",
                        "public markDeleted()",
                        "public final modCount()"
                    ],
                    "llm_response_time": 9512
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private fireNodeEvent(Node node, NodeEventListener listener, Graph.NodeEvent nodeEvent)",
                        "public markDeleted()",
                        "public replaceFirstSuccessor(Node oldSuccessor, Node newSuccessor)",
                        "public withNodeSourcePosition()",
                        "public successorPositions()"
                    ],
                    "llm_response_time": 5101
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public withNodeSourcePosition()",
                        "private fireNodeEvent(Node node, NodeEventListener listener, Graph.NodeEvent nodeEvent)",
                        "public markDeleted()"
                    ],
                    "llm_response_time": 4344
                }
            },
            "targetClassMap": {
                "initialize": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 0,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "markDeleted": {
                    "target_classes": [
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.3719239533425367
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Graph"
                    ],
                    "llm_response_time": 0,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "removeThisFromUsages": {
                    "target_classes": [
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.3886668970595633
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Graph"
                    ],
                    "llm_response_time": 0,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "init": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 0,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "withNodeSourcePosition": {
                    "target_classes": [
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.43732925652880944
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Graph"
                    ],
                    "llm_response_time": 0,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "estimatedNodeCycles": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 0,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "verifyInput": {
                    "target_classes": [
                        {
                            "class_name": "InputEdges",
                            "similarity_score": 0.3461649744052844
                        },
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.4072539371646267
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "InputEdges",
                        "Graph"
                    ],
                    "llm_response_time": 0,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "maybeNotifyInputChanged": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2432,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "fireNodeEvent": {
                    "target_classes": [
                        {
                            "class_name": "NodeEventListener",
                            "similarity_score": 0.22000575277665646
                        },
                        {
                            "class_name": "NodeEvent",
                            "similarity_score": 0.03244214994438681
                        },
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.43918836353253626
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "NodeEventListener",
                        "Graph",
                        "NodeEvent"
                    ],
                    "llm_response_time": 4367,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "replaceAtUsagePos": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 0,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "verifyInputs": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 0,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "usageModCount": {
                    "target_classes": [
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.529248104080078
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Graph"
                    ],
                    "llm_response_time": 0,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "checkReplaceWith": {
                    "target_classes": [
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.49878849273875203
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Graph"
                    ],
                    "llm_response_time": 0,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "incModCount": {
                    "target_classes": [
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.5036699707941317
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Graph"
                    ],
                    "llm_response_time": 0,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "incUsageModCount": {
                    "target_classes": [
                        {
                            "class_name": "Graph",
                            "similarity_score": 0.5036699707941317
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Graph"
                    ],
                    "llm_response_time": 0,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "d450dc2e5817d2bbeb9c0e9cecff779910255a67",
        "url": "https://github.com/oracle/graal/commit/d450dc2e5817d2bbeb9c0e9cecff779910255a67",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public notWeakerThan(connectBlocks boolean, computeFrequency boolean, computeLoops boolean, computeDominators boolean, computePostdominators boolean) : boolean extracted from package compute(graph StructuredGraph, backendBlocks boolean, connectBlocks boolean, computeFrequency boolean, computeLoops boolean, computeDominators boolean, computePostdominators boolean) : ControlFlowGraph in class jdk.graal.compiler.nodes.cfg.ControlFlowGraph & moved to class jdk.graal.compiler.nodes.cfg.ControlFlowGraph.BuildConfiguration",
            "leftSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/cfg/ControlFlowGraph.java",
                    "startLine": 133,
                    "endLine": 196,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "package compute(graph StructuredGraph, backendBlocks boolean, connectBlocks boolean, computeFrequency boolean, computeLoops boolean, computeDominators boolean, computePostdominators boolean) : ControlFlowGraph"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/cfg/ControlFlowGraph.java",
                    "startLine": 182,
                    "endLine": 182,
                    "startColumn": 17,
                    "endColumn": 93,
                    "codeElementType": "IF_STATEMENT_CONDITION",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/cfg/ControlFlowGraph.java",
                    "startLine": 186,
                    "endLine": 186,
                    "startColumn": 17,
                    "endColumn": 80,
                    "codeElementType": "IF_STATEMENT_CONDITION",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/cfg/ControlFlowGraph.java",
                    "startLine": 179,
                    "endLine": 179,
                    "startColumn": 17,
                    "endColumn": 83,
                    "codeElementType": "IF_STATEMENT_CONDITION",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/cfg/ControlFlowGraph.java",
                    "startLine": 175,
                    "endLine": 175,
                    "startColumn": 17,
                    "endColumn": 70,
                    "codeElementType": "IF_STATEMENT_CONDITION",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/cfg/ControlFlowGraph.java",
                    "startLine": 232,
                    "endLine": 241,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public notWeakerThan(connectBlocks boolean, computeFrequency boolean, computeLoops boolean, computeDominators boolean, computePostdominators boolean) : boolean"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/cfg/ControlFlowGraph.java",
                    "startLine": 239,
                    "endLine": 240,
                    "startColumn": 13,
                    "endColumn": 134,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/cfg/ControlFlowGraph.java",
                    "startLine": 133,
                    "endLine": 193,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "package compute(graph StructuredGraph, modifiableBlocks boolean, connectBlocks boolean, computeFrequency boolean, computeLoops boolean, computeDominators boolean, computePostdominators boolean) : ControlFlowGraph"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/cfg/ControlFlowGraph.java",
                    "startLine": 149,
                    "endLine": 149,
                    "startColumn": 21,
                    "endColumn": 139,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "cfg.buildConfig.notWeakerThan(connectBlocks,computeFrequency,computeLoops,computeDominators,computePostdominators)"
                }
            ],
            "isStatic": false
        },
        "ref_id": 490,
        "extraction_results": {
            "success": true,
            "newCommitHash": "c87ca336197635cd25fcb9bba370d9b35ebbb4b6",
            "newBranchName": "extract-notWeakerThan-compute-4943dd9"
        },
        "telemetry": {
            "id": "16e767bc-e340-4a3c-b830-f54c133b3487",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1317,
                "lineStart": 70,
                "lineEnd": 1386,
                "bodyLineStart": 70,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/nodes/cfg/ControlFlowGraph.java",
                "sourceCode": "public final class ControlFlowGraph implements AbstractControlFlowGraph<HIRBlock> {\n\n    public static class CFGOptions {\n        /**\n         * Take {@link LoopEndNode} frequencies to calculate the frequency of a loop instead of\n         * {@link LoopExitNode} frequency. For this a sum of the {@link LoopEndNode} frequencies is\n         * taken. This sum is subtracted from 1 to get the frequency of all paths out of the loop.\n         * Note that this ignores the frequency of all paths out of the loop that do not go through\n         * a loop exit, i.e. control flow sinks like deopt nodes that do not require explicit loop\n         * exit nodes. The formula that must hold here is sumLoopEndFrequency + sumSinkFrequency +\n         * sumLoopExitFrequency = 1.\n         *\n         * This option only exists to debug loop frequency calculation differences when taking exits\n         * or ends. A vastly different loop frequency calculated with the {@link LoopEndNode} sum\n         * indicates there are many non 0 frequency paths out of a loop.\n         */\n        //@formatter:off\n        @Option(help = \"Derive loop frequencies only from backedge frequencies instead of from loop exit frequencies.\", type = OptionType.Debug)\n        public static final OptionKey<Boolean> UseLoopEndFrequencies = new OptionKey<>(false);\n        @Option(help = \"Debug flag to dump loop frequency differences computed based on loop end or exit nodes.\" +\n                       \"If the frequencies diverge a lot, this may indicate missing profiles on control flow\" +\n                       \"inside the loop body.\", type = OptionType.Debug)\n        public static final OptionKey<Boolean> DumpEndVersusExitLoopFrequencies = new OptionKey<>(false);\n        @Option(help = \"Scaling factor of frequency difference computed based on loop ends or exits\", type = OptionType.Debug)\n        public static final OptionKey<Double> LoopExitVsLoopEndFrequencyDiff = new OptionKey<>(1000D);\n        //@formatter:on\n    }\n\n    /**\n     * Don't allow relative frequency values to be become too small or too high as this makes\n     * frequency calculations over- or underflow the range of a double. This commonly happens with\n     * infinite loops within infinite loops. The value is chosen a bit lower than half the maximum\n     * exponent supported by double. That way we can never overflow to infinity when multiplying two\n     * relative frequency values.\n     */\n    public static final double MIN_RELATIVE_FREQUENCY = 0x1.0p-500;\n    public static final double MAX_RELATIVE_FREQUENCY = 1 / MIN_RELATIVE_FREQUENCY;\n\n    public final StructuredGraph graph;\n    private BuildConfig buildConfig;\n\n    private NodeMap<HIRBlock> nodeToBlock;\n    private HIRBlock[] reversePostOrder;\n    private List<Loop<HIRBlock>> loops;\n    private int maxDominatorDepth;\n    private EconomicMap<LoopBeginNode, LoopFrequencyData> localLoopFrequencyData;\n\n    public interface RecursiveVisitor<V> {\n        V enter(HIRBlock b);\n\n        void exit(HIRBlock b, V value);\n    }\n\n    private static final MemUseTrackerKey CFG_MEMORY = DebugContext.memUseTracker(\"CFGComputation\");\n\n    public static ControlFlowGraphBuilder newBuilder(StructuredGraph structuredGraph) {\n        return new ControlFlowGraphBuilder(structuredGraph);\n    }\n\n    public static ControlFlowGraph computeForSchedule(StructuredGraph graph) {\n        return compute(graph, true, true, true, true, true, false);\n    }\n\n    /**\n     * Creates a control flow graph from the nodes in {@code graph}.\n     *\n     * @param backendBlocks specifies if the blocks can have their edges edited\n     * @param connectBlocks\n     * @param computeFrequency\n     * @param computeLoops\n     * @param computeDominators\n     * @param computePostdominators\n     */\n    @SuppressWarnings(\"try\")\n    static ControlFlowGraph compute(StructuredGraph graph, boolean backendBlocks, boolean connectBlocks, boolean computeFrequency, boolean computeLoops, boolean computeDominators,\n                    boolean computePostdominators) {\n        ControlFlowGraph lastCFG = graph.getLastCFG();\n\n        try (DebugCloseable c = CFG_MEMORY.start(graph.getDebug())) {\n            ControlFlowGraph cfg;\n            if (lastCFG != null && graph.isLastCFGValid() && (lastCFG.buildConfig.backendBlocks == backendBlocks)) {\n                if (lastCFG.buildConfig.hasAllParams(backendBlocks, connectBlocks, computeFrequency, computeLoops, computeDominators, computePostdominators)) {\n                    return lastCFG;\n                }\n                cfg = lastCFG;\n            } else {\n                cfg = new ControlFlowGraph(graph);\n            }\n\n            if (cfg != lastCFG) {\n                cfg.identifyBlocks(backendBlocks);\n            }\n\n            boolean loopInfoComputed = false;\n            if (CFGOptions.DumpEndVersusExitLoopFrequencies.getValue(graph.getOptions())) {\n                // additional loop info for sink frequencies inside the loop body\n                if (!cfg.buildConfig.computeLoops) {\n                    cfg.computeLoopInformation();\n                }\n                if (!cfg.buildConfig.computeDominators) {\n                    cfg.computeDominators();\n                }\n                loopInfoComputed = true;\n            }\n\n            if (computeFrequency && !cfg.buildConfig.computeFrequency) {\n                cfg.computeFrequencies();\n            }\n\n            if (computeLoops && !loopInfoComputed && !cfg.buildConfig.computeLoops) {\n                cfg.computeLoopInformation();\n            }\n            if (computeDominators && !loopInfoComputed && !cfg.buildConfig.computeDominators) {\n                cfg.computeDominators();\n                assert cfg.verifyRPOInnerLoopsFirst();\n            }\n            if (computePostdominators && !cfg.buildConfig.computePostdominators) {\n                cfg.computePostdominators();\n            }\n\n            // there's not much to verify when connectBlocks == false\n            assert !(connectBlocks || computeLoops || computeDominators || computePostdominators) || CFGVerifier.verify(cfg);\n            cfg.buildConfig.update(backendBlocks, connectBlocks, computeFrequency, computeLoops | loopInfoComputed, computeDominators | loopInfoComputed, computePostdominators);\n            graph.setLastCFG(cfg);\n            return cfg;\n        }\n    }\n\n    private boolean notWeakerThan(boolean computeDominators, boolean loopInfoComputed, ControlFlowGraph cfg) {\n        return computeDominators && !loopInfoComputed && !cfg.buildConfig.computeDominators;\n    }\n\n    private static class BuildConfig {\n        private boolean backendBlocks = false;\n        private boolean connectBlocks = false;\n        private boolean computeFrequency = false;\n        private boolean computeLoops = false;\n        private boolean computeDominators = false;\n        private boolean computePostdominators = false;\n\n        @SuppressWarnings(\"hiding\")\n        public void update(boolean backendBlocks, boolean connectBlocks, boolean computeFrequency, boolean computeLoops, boolean computeDominators, boolean computePostdominators) {\n            this.backendBlocks |= backendBlocks;\n            this.connectBlocks |= connectBlocks;\n            this.computeFrequency |= computeFrequency;\n            this.computeLoops |= computeLoops;\n            this.computeDominators |= computeDominators;\n            this.computePostdominators |= computePostdominators;\n        }\n\n        /**\n         * Checks that this build configuration is not weaker than a build configuration from the\n         * provided parameters. That is, if for each parameter p the following holds:\n         * {@code (p -> this.p)} which is equivalent to {@code (!p || this.p)}.\n         */\n        @SuppressWarnings(\"hiding\")\n        public boolean hasAllParams(boolean backendBlocks, boolean connectBlocks, boolean computeFrequency, boolean computeLoops, boolean computeDominators, boolean computePostdominators) {\n            return (this.backendBlocks || !backendBlocks) && (this.connectBlocks || !connectBlocks) && (this.computeFrequency || !computeFrequency) && (this.computeLoops || !computeLoops) &&\n                            (this.computeDominators || !computeDominators) && (this.computePostdominators || !computePostdominators);\n        }\n    }\n\n    private void identifyBlocks(boolean makeEditable) {\n        int numBlocks = 0;\n        for (AbstractBeginNode begin : graph.getNodes(AbstractBeginNode.TYPE)) {\n            GraalError.guarantee(begin.predecessor() != null || (begin instanceof StartNode || begin instanceof AbstractMergeNode), \"Disconnected control flow %s encountered\", begin);\n            HIRBlock block = makeEditable ? new HIRBlock.ModifiableBlock(begin, this) : new HIRBlock.UnmodifiableBlock(begin, this);\n            identifyBlock(block);\n            numBlocks++;\n            if (numBlocks > AbstractControlFlowGraph.LAST_VALID_BLOCK_INDEX) {\n                throw new RetryableBailoutException(\"Graph too large to safely compile in reasonable time. Graph contains more than %d basic blocks\",\n                                AbstractControlFlowGraph.LAST_VALID_BLOCK_INDEX);\n            }\n        }\n        reversePostOrder = ReversePostOrder.identifyBlocks(this, numBlocks);\n    }\n\n    public double localLoopFrequency(LoopBeginNode lb) {\n        return localLoopFrequencyData.get(lb).getLoopFrequency();\n    }\n\n    public ProfileSource localLoopFrequencySource(LoopBeginNode lb) {\n        return localLoopFrequencyData.get(lb).getProfileSource();\n    }\n\n    public EconomicMap<LoopBeginNode, LoopFrequencyData> getLocalLoopFrequencyData() {\n        return localLoopFrequencyData;\n    }\n\n    /**\n     * Update the cached local loop frequency for the given loop. Future queries of\n     * {@link #localLoopFrequency(LoopBeginNode)} on <em>this</em> {@link ControlFlowGraph} instance\n     * will return the updated value. This is useful for phases to record temporary effects of\n     * transformations on loop frequencies, without having to recompute a CFG.\n     * </p>\n     *\n     * The updated frequency is a cached value local to this CFG. It is <em>not</em> persisted in\n     * the IR graph. Newly computed {@link ControlFlowGraph} instances will recompute a frequency\n     * from loop exit probabilities, they will not see this locally cached value. Persistent changes\n     * to loop frequencies must be modeled by changing loop exit probabilities in the graph.\n     */\n    public void updateCachedLocalLoopFrequency(LoopBeginNode lb, Function<LoopFrequencyData, LoopFrequencyData> updater) {\n        localLoopFrequencyData.put(lb, updater.apply(localLoopFrequencyData.get(lb)));\n    }\n\n    /**\n     * Debug only decorator for {@link RecursiveVisitor} to log all basic blocks how they are\n     * visited one by one.\n     */\n    public static class LoggingCFGDecorator implements ControlFlowGraph.RecursiveVisitor<HIRBlock> {\n        private final ControlFlowGraph.RecursiveVisitor<HIRBlock> visitor;\n        private String indent = \"\";\n\n        public LoggingCFGDecorator(ControlFlowGraph.RecursiveVisitor<HIRBlock> visitor, ControlFlowGraph cfg) {\n            this.visitor = visitor;\n            TTY.printf(\"DomTree for %s%n\", cfg.graph);\n            printDomTree(cfg.getStartBlock(), \"\");\n        }\n\n        private static void printDomTree(HIRBlock cur, String indent) {\n            TTY.printf(\"%s%s [dom %s, post dom %s]%n\", indent, cur, cur.getDominator(), cur.getPostdominator());\n            HIRBlock dominated = cur.getFirstDominated();\n            while (dominated != null) {\n                printDomTree(dominated, indent + \"\\t\");\n                dominated = dominated.getDominatedSibling();\n            }\n        }\n\n        @Override\n        public HIRBlock enter(HIRBlock b) {\n            TTY.printf(\"%sEnter block %s for %s%n\", indent, b, visitor);\n            indent += \"\\t\";\n            return visitor.enter(b);\n        }\n\n        @Override\n        public void exit(HIRBlock b, HIRBlock value) {\n            indent = indent.substring(0, indent.length() - 1);\n            TTY.printf(\"%sExit block %s with value %s for %s%n\", indent, b, value, visitor);\n            visitor.exit(b, value);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <V> void visitDominatorTreeDefault(RecursiveVisitor<V> visitor) {\n\n        HIRBlock[] stack = new HIRBlock[maxDominatorDepth + 1];\n        HIRBlock current = getStartBlock();\n        int tos = 0;\n        Object[] values = null;\n        int valuesTOS = 0;\n\n        while (tos >= 0) {\n            HIRBlock state = stack[tos];\n            if (state == null || state.getDominator() == null || state.getDominator().getPostdominator() != state) {\n                if (state == null) {\n                    // We enter this block for the first time.\n                    V value = visitor.enter(current);\n                    if (value != null || values != null) {\n                        if (values == null) {\n                            values = new Object[maxDominatorDepth + 1];\n                        }\n                        values[valuesTOS++] = value;\n                    }\n\n                    HIRBlock dominated = skipPostDom(current.getFirstDominated());\n                    if (dominated != null) {\n                        // Descend into dominated.\n                        stack[tos] = dominated;\n                        current = dominated;\n                        stack[++tos] = null;\n                        continue;\n                    }\n                } else {\n                    HIRBlock next = skipPostDom(state.getDominatedSibling());\n                    if (next != null) {\n                        // Descend into dominated.\n                        stack[tos] = next;\n                        current = next;\n                        stack[++tos] = null;\n                        continue;\n                    }\n                }\n\n                // Finished processing all normal dominators.\n                HIRBlock postDom = current.getPostdominator();\n                if (postDom != null && postDom.getDominator() == current) {\n                    // Descend into post dominator.\n                    stack[tos] = postDom;\n                    current = postDom;\n                    stack[++tos] = null;\n                    continue;\n                }\n            }\n\n            // Finished processing this node, exit and pop from stack.\n            V value = null;\n            if (values != null && valuesTOS > 0) {\n                value = (V) values[--valuesTOS];\n            }\n            visitor.exit(current, value);\n            current = current.getDominator();\n            --tos;\n        }\n    }\n\n    private static HIRBlock skipPostDom(HIRBlock block) {\n        if (block != null && block.getDominator().getPostdominator() == block) {\n            // This is an always reached block.\n            return block.getDominatedSibling();\n        }\n        return block;\n    }\n\n    public static final class DeferredExit {\n\n        public DeferredExit(HIRBlock block, DeferredExit next) {\n            this.block = block;\n            this.next = next;\n        }\n\n        private final HIRBlock block;\n        private final DeferredExit next;\n    }\n\n    public static void addDeferredExit(DeferredExit[] deferredExits, HIRBlock b) {\n        Loop<HIRBlock> outermostExited = b.getDominator().getLoop();\n        Loop<HIRBlock> exitBlockLoop = b.getLoop();\n        assert outermostExited != null : \"Dominator must be in a loop. Possible cause is a missing loop exit node.\";\n        while (outermostExited.getParent() != null && outermostExited.getParent() != exitBlockLoop) {\n            outermostExited = outermostExited.getParent();\n        }\n        int loopIndex = outermostExited.getIndex();\n        deferredExits[loopIndex] = new DeferredExit(b, deferredExits[loopIndex]);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public <V> void visitDominatorTreeDeferLoopExits(RecursiveVisitor<V> visitor) {\n        HIRBlock[] stack = new HIRBlock[getBlocks().length];\n        int tos = 0;\n        BasicBlockSet visited = this.createBasicBlockSet();\n        int loopCount = getLoops().size();\n        DeferredExit[] deferredExits = new DeferredExit[loopCount];\n        Object[] values = null;\n        int valuesTOS = 0;\n        stack[0] = getStartBlock();\n        List<HIRBlock> dominated = new ArrayList<>(3);\n\n        while (tos >= 0) {\n            HIRBlock cur = stack[tos];\n            if (visited.get(cur)) {\n                V value = null;\n                if (values != null && valuesTOS > 0) {\n                    value = (V) values[--valuesTOS];\n                }\n                visitor.exit(cur, value);\n                --tos;\n                if (cur.isLoopHeader()) {\n                    int loopIndex = cur.getLoop().getIndex();\n                    DeferredExit deferredExit = deferredExits[loopIndex];\n                    if (deferredExit != null) {\n                        while (deferredExit != null) {\n                            stack[++tos] = deferredExit.block;\n                            deferredExit = deferredExit.next;\n                        }\n                        deferredExits[loopIndex] = null;\n                    }\n                }\n            } else {\n                visited.set(cur);\n                V value = visitor.enter(cur);\n                if (value != null || values != null) {\n                    if (values == null) {\n                        values = new Object[maxDominatorDepth + 1];\n                    }\n                    values[valuesTOS++] = value;\n                }\n\n                HIRBlock alwaysReached = cur.getPostdominator();\n                if (alwaysReached != null) {\n                    if (alwaysReached.getDominator() != cur) {\n                        alwaysReached = null;\n                    } else if (isDominatorTreeLoopExit(alwaysReached)) {\n                        addDeferredExit(deferredExits, alwaysReached);\n                    } else {\n                        stack[++tos] = alwaysReached;\n                    }\n                }\n\n                dominated.clear();\n\n                HIRBlock b = cur.getFirstDominated();\n                while (b != null) {\n                    dominated.add(b);\n                    b = b.getDominatedSibling();\n                }\n\n                /*\n                 * Push dominated blocks to stack in reverse order, to make sure that branches are\n                 * handled before merges. This facilitates phi optimizations.\n                 */\n                while (!dominated.isEmpty()) {\n                    b = dominated.removeLast();\n                    if (b != alwaysReached) {\n                        if (isDominatorTreeLoopExit(b)) {\n                            addDeferredExit(deferredExits, b);\n                        } else {\n                            stack[++tos] = b;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public <V> void visitDominatorTree(RecursiveVisitor<V> visitor, boolean deferLoopExits) {\n        if (deferLoopExits && this.getLoops().size() > 0) {\n            visitDominatorTreeDeferLoopExits(visitor);\n        } else {\n            visitDominatorTreeDefault(visitor);\n        }\n    }\n\n    public static boolean isDominatorTreeLoopExit(HIRBlock b) {\n        return isDominatorTreeLoopExit(b, false);\n    }\n\n    public static boolean isDominatorTreeLoopExit(HIRBlock b, boolean considerRealExits) {\n        HIRBlock dominator = b.getDominator();\n        if (dominator != null && b.getLoop() != dominator.getLoop() && (!b.isLoopHeader() || dominator.getLoopDepth() >= b.getLoopDepth())) {\n            return true;\n        }\n        if (considerRealExits) {\n            if (b.getBeginNode() instanceof LoopExitNode) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private ControlFlowGraph(StructuredGraph graph) {\n        this.graph = graph;\n        this.nodeToBlock = graph.createNodeMap();\n        this.buildConfig = new BuildConfig();\n    }\n\n    /**\n     * Utility class to verify that {@link ReversePostOrder} only produces reverse post order\n     * traversals of the graph that contain inner loops before outer ones.\n     */\n    private static class RPOLoopVerification {\n        int endsVisited;\n        int exitsVisited;\n        LoopBeginNode lb;\n\n        RPOLoopVerification(LoopBeginNode lb) {\n            this.lb = lb;\n        }\n\n        boolean loopFullyProcessed() {\n            return lb.getLoopEndCount() == endsVisited && exitsVisited == lb.loopExits().count();\n        }\n\n        boolean allEndsVisited() {\n            return lb.getLoopEndCount() == endsVisited;\n        }\n\n    }\n\n    /**\n     * Verification method to ensure that inner loops are processed before outer ones: see\n     * {@link ControlFlowGraph#computeFrequencies()} for details.\n     */\n    private boolean verifyRPOInnerLoopsFirst() {\n        return rpoInnerLoopsFirst(b -> {\n        }, b -> {\n        });\n    }\n\n    /**\n     * Special note on loop exit nodes and dominator tree loop exits: Graal has a \"closed\" loop\n     * form, this means every {@link LoopBeginNode} needs explicit {@link LoopEndNode} nodes and (if\n     * it is not an endless loop) {@link LoopExitNode}. For every path exiting a loop a\n     * {@link LoopExitNode} is required. There is one exception to that rule:\n     * {@link DeoptimizeNode}.\n     *\n     * Graal does not mandate that a {@link DeoptimizeNode} is preceded by a {@link LoopExitNode}.\n     * In the following example\n     *\n     * <pre>\n     * for (int i = 0; i < end; i++) {\n     *     if (condition) {\n     *         deoptimize;\n     *     }\n     * }\n     * </pre>\n     *\n     * the IR does not have a preceding loop exit node before the deopt node. However, for regular\n     * control flow sinks (returns, throws, etc) like in the following example\n     *\n     * <pre>\n     * for (int i = 0; i < end; i++) {\n     *     if (condition) {\n     *         return;\n     *     }\n     * }\n     * </pre>\n     *\n     * Graal IR creates a {@link LoopExitNode} before the {@link ReturnNode}.\n     *\n     * Because of the \"imprecision\" in the definition a regular basic block exiting a loop and a\n     * \"dominator tree\" loop exit are not necessarily the same. If a path after a control flow split\n     * unconditionally flows into a deopt it is a \"dominator loop exit\" while a regular loop exit\n     * block contains a {@linkplain LoopExitNode}.\n     */\n    private boolean rpoInnerLoopsFirst(Consumer<HIRBlock> perBasicBlockOption, Consumer<LoopBeginNode> loopClosedAction) {\n        // worst case all loops in the graph are nested\n        RPOLoopVerification[] openLoops = new RPOLoopVerification[graph.getNodes(LoopBeginNode.TYPE).count()];\n        int tos = 0;\n        for (HIRBlock b : reversePostOrder) {\n            // we see a loop end, open a new verification level in the loop stack\n            if (b.isLoopHeader()) {\n                RPOLoopVerification lv = new RPOLoopVerification((LoopBeginNode) b.getBeginNode());\n                openLoops[tos++] = lv;\n            }\n\n            // process this basic block\n            perBasicBlockOption.accept(b);\n\n            /*\n             * General note on the verification of loop exits: A loop exit node and a dominator tree\n             * loop exit are not necessarily the same, see javadoc of this method. Ideally, we would\n             * like to visit all dominator loop exits during RPO verification, however we do not\n             * know how many there are (given the deopt issue above), thus we just determine by the\n             * loop exit nodes seen.\n             */\n            boolean wasExit = predecessorBlockSequentialLoopExit(b);\n\n            FixedNode f = b.getBeginNode();\n            while (true) { // TERMINATION ARGUMENT: processing loop exit node predecessors\n                CompilationAlarm.checkProgress(graph);\n                if (f instanceof LoopExitNode) {\n                    LoopBeginNode closedLoop = ((LoopExitNode) f).loopBegin();\n                    RPOLoopVerification lv = openLoops[tos - 1];\n                    assert lv.lb == closedLoop : \"Must close inner loops first before closing other ones stackLoop=\" + lv.lb + \" exited loop=\" + closedLoop + \" block=\" + b;\n                    if (!lv.allEndsVisited()) {\n                        throw GraalError.shouldNotReachHere(\n                                        \"Loop ends should be visited before exits. This is a major error in the reverse post order of the control \" +\n                                                        \"flow graph of this method. This typically means wrongly specified control-split nodes have been processed in ReversePostOrder.java.\"); // ExcludeFromJacocoGeneratedReport\n                    }\n                    lv.exitsVisited++;\n                    if (lv.loopFullyProcessed()) {\n                        loopClosedAction.accept(lv.lb);\n                        tos--;\n                    }\n                    wasExit = true;\n                }\n                if (f == b.getEndNode()) {\n                    break;\n                }\n                f = ((FixedWithNextNode) f).next();\n            }\n\n            if (b.isLoopEnd()) {\n                RPOLoopVerification lv = null;\n                LoopEndNode len = (LoopEndNode) b.getEndNode();\n                int index = tos - 1;\n                if (wasExit) {\n                    // irregular case a basic block that is a loop exit to an inner loop followed by\n                    // a loop end to an outer loop, while the inner loop potentially is not\n                    // finished, we still need to allow such cases since the code in the fraction\n                    // between loop exit inner and end outer is fine, it does not change the\n                    // verification logic since its a single basic block\n                    while (openLoops[index].lb != len.loopBegin()) {\n                        index--;\n                    }\n                    lv = openLoops[index];\n                } else {\n                    // regular case, this block contains a loop end to the inner most loop\n                    lv = openLoops[tos - 1];\n                }\n                LoopBeginNode closedLoop = ((LoopEndNode) b.getEndNode()).loopBegin();\n                assert lv.lb == closedLoop : \"Must close inner loops first before closing other ones stackLoop=\" + lv.lb + \" ended loop=\" + closedLoop + \" block=\" + b + \"->\" + b.getBeginNode();\n                lv.endsVisited++;\n                if (lv.loopFullyProcessed()) {\n                    loopClosedAction.accept(lv.lb);\n                    // the current loop was exited but we also end an outer loop, find this one and\n                    // remove it from the verification stack since its done\n                    if (lv.lb != openLoops[tos - 1].lb) {\n                        // we actually finished the outer loop already completely through this\n                        // exit-end scenario, remove it from the stack\n                        RPOLoopVerification[] tmp = new RPOLoopVerification[openLoops.length];\n                        System.arraycopy(openLoops, 0, tmp, 0, index);\n                        System.arraycopy(openLoops, index + 1, tmp, index, openLoops.length - (index + 1));\n                        openLoops = tmp;\n                    }\n                    tos--;\n                }\n            }\n        }\n        assert tos == 0 : \"Unfinished loops on stack \" + tos;\n        return true;\n    }\n\n    /**\n     * Determine if sequential predecessor blocks of this block in a not-fully-canonicalized graph\n     * exit a loop.\n     *\n     * Example: Sequential basic block: loop exit -> invoke -> killing begin -> loopend/exit\n     *\n     * These cases cause problems in the {@link #verifyRPOInnerLoopsFirst()} loop verification of\n     * inner loop blocks because the granularity of loop ends and exits are not on block boundaries:\n     * a loop exit block can also be a loop end to an outer loop, which makes verification that the\n     * inner loop is fully processed before we process the rest of the outer loop tricky (since we\n     * already visit a loop end to an outer loop while we should first stricly process all loop\n     * ends/exits of inner loops).\n     */\n    private static boolean predecessorBlockSequentialLoopExit(HIRBlock b) {\n        HIRBlock cur = b;\n        // while cur has a single predecessor which has a single successor which is cur, i.e., a\n        // sequential successor, this typically only happens in not-fully-canonicalized graphs\n        while (cur.getPredecessorCount() == 1 && cur.getPredecessorAt(0).getSuccessorCount() == 1) {\n            HIRBlock pred = cur.getPredecessorAt(0);\n            FixedNode f = pred.getBeginNode();\n            while (true) { // TERMINATION ARGUMENT: process loop exit predecessor nodes\n                CompilationAlarm.checkProgress(b.getCfg().graph);\n                if (f instanceof LoopExitNode) {\n                    return true;\n                }\n                if (f == pred.getEndNode()) {\n                    break;\n                }\n                f = ((FixedWithNextNode) f).next();\n            }\n            cur = cur.getPredecessorAt(0);\n        }\n        return false;\n    }\n\n    private void computeDominators() {\n        assert reversePostOrder[0].getPredecessorCount() == 0 : \"start block has no predecessor and therefore no dominator\";\n        HIRBlock[] blocks = reversePostOrder;\n        int curMaxDominatorDepth = 0;\n        for (int i = 1; i < blocks.length; i++) {\n            HIRBlock block = blocks[i];\n            assert NumUtil.assertPositiveInt(block.getPredecessorCount());\n            HIRBlock dominator = null;\n            for (int j = 0; j < block.getPredecessorCount(); j++) {\n                HIRBlock pred = block.getPredecessorAt(j);\n                if (!pred.isLoopEnd()) {\n                    dominator = ((dominator == null) ? pred : commonDominatorRaw(dominator, pred));\n                }\n            }\n            // Fortify: Suppress Null Dereference false positive (every block apart from the first\n            // is guaranteed to have a predecessor)\n            assert dominator != null;\n\n            // Set dominator.\n            block.setDominator(dominator);\n\n            // Keep dominated linked list sorted by block ID such that predecessor blocks are always\n            // before successor blocks.\n            HIRBlock currentDominated = dominator.getFirstDominated();\n            if (currentDominated != null && currentDominated.getId() < block.getId()) {\n                while (currentDominated.getDominatedSibling() != null && currentDominated.getDominatedSibling().getId() < block.getId()) {\n                    currentDominated = currentDominated.getDominatedSibling();\n                }\n                block.setDominatedSibling(currentDominated.getDominatedSibling());\n                currentDominated.setDominatedSibling(block);\n            } else {\n                block.setDominatedSibling(dominator.getFirstDominated());\n                dominator.setFirstDominated(block);\n            }\n\n            curMaxDominatorDepth = Math.max(curMaxDominatorDepth, block.getDominatorDepth());\n        }\n        this.maxDominatorDepth = curMaxDominatorDepth;\n        calcDominatorRanges(getStartBlock(), reversePostOrder.length);\n    }\n\n    private static void calcDominatorRanges(HIRBlock block, int size) {\n        HIRBlock[] stack = new HIRBlock[size];\n        stack[0] = block;\n        int tos = 0;\n        int myNumber = 0;\n\n        do {\n            HIRBlock cur = stack[tos];\n            HIRBlock dominated = cur.getFirstDominated();\n\n            if (cur.getDominatorNumber() == -1) {\n                cur.setDominatorNumber(myNumber);\n                if (dominated != null) {\n                    // Push children onto stack.\n                    do {\n                        stack[++tos] = dominated;\n                        dominated = dominated.getDominatedSibling();\n                    } while (dominated != null);\n                } else {\n                    cur.setMaxChildDomNumber(myNumber);\n                    --tos;\n                }\n                myNumber = myNumber + 1;\n            } else {\n                cur.setMaxChildDomNumber(dominated.getMaxChildDominatorNumber());\n                --tos;\n            }\n        } while (tos >= 0);\n    }\n\n    private static HIRBlock commonDominatorRaw(HIRBlock a, HIRBlock b) {\n        int aDomDepth = a.getDominatorDepth();\n        int bDomDepth = b.getDominatorDepth();\n        if (aDomDepth > bDomDepth) {\n            return commonDominatorRawSameDepth(a.getDominator(aDomDepth - bDomDepth), b);\n        } else {\n            return commonDominatorRawSameDepth(a, b.getDominator(bDomDepth - aDomDepth));\n        }\n    }\n\n    private static HIRBlock commonDominatorRawSameDepth(HIRBlock a, HIRBlock b) {\n        HIRBlock iterA = a;\n        HIRBlock iterB = b;\n        while (iterA != iterB) {\n            iterA = iterA.getDominator();\n            iterB = iterB.getDominator();\n        }\n        return iterA;\n    }\n\n    @Override\n    public HIRBlock[] getBlocks() {\n        return reversePostOrder;\n    }\n\n    @Override\n    public HIRBlock getStartBlock() {\n        return reversePostOrder[0];\n    }\n\n    public HIRBlock[] reversePostOrder() {\n        return reversePostOrder;\n    }\n\n    public NodeMap<HIRBlock> getNodeToBlock() {\n        return nodeToBlock;\n    }\n\n    public HIRBlock blockFor(Node node) {\n        return nodeToBlock.get(node);\n    }\n\n    public HIRBlock commonDominatorFor(NodeIterable<? extends Node> nodes) {\n        HIRBlock commonDom = null;\n        for (Node n : nodes) {\n            HIRBlock b = blockFor(n);\n            commonDom = (HIRBlock) AbstractControlFlowGraph.commonDominator(commonDom, b);\n        }\n        return commonDom;\n    }\n\n    @Override\n    public List<Loop<HIRBlock>> getLoops() {\n        return loops;\n    }\n\n    public int getMaxDominatorDepth() {\n        return maxDominatorDepth;\n    }\n\n    private void identifyBlock(HIRBlock block) {\n        FixedWithNextNode cur = block.getBeginNode();\n        while (true) { // TERMINATION ARGUMENT: processing fixed nodes of a basic block, bound if\n                       // the graph is valid\n            CompilationAlarm.checkProgress(graph);\n            assert cur.isAlive() : cur;\n            assert nodeToBlock.get(cur) == null;\n            nodeToBlock.set(cur, block);\n            FixedNode next = cur.next();\n            assert next != null : cur;\n            if (next instanceof AbstractBeginNode) {\n                block.endNode = cur;\n                return;\n            } else if (next instanceof FixedWithNextNode) {\n                cur = (FixedWithNextNode) next;\n            } else {\n                nodeToBlock.set(next, block);\n                block.endNode = next;\n                return;\n            }\n        }\n    }\n\n    private void finishLocalLoopFrequency(LoopBeginNode lb) {\n        calculateLocalLoopFrequency(lb);\n        double sumAllLexFrequency = 0;\n        /*\n         * Take the sum of all exit frequencies and scale each exit with the importance in relation\n         * to the other exits. This factor is multiplied with the real predecessor frequency.\n         *\n         * Note that this code is only correct if the reverse post order includes inner loops\n         * completely before containing outer loops and that dominating loops have their loop exits\n         * fully processed before processing any dominated code.\n         */\n        for (LoopExitNode lex : lb.loopExits()) {\n            sumAllLexFrequency += blockFor(lex).relativeFrequency;\n        }\n        for (LoopExitNode lex : lb.loopExits()) {\n            HIRBlock lexBlock = blockFor(lex);\n            assert lexBlock != null;\n            final double lexFrequency = lexBlock.getRelativeFrequency();\n            final double scaleLexFrequency = lexFrequency / sumAllLexFrequency;\n            final double loopPredFrequency = blockFor(lb.forwardEnd()).relativeFrequency;\n            final double exitFrequency = multiplyRelativeFrequencies(scaleLexFrequency, loopPredFrequency);\n            lexBlock.setRelativeFrequency(exitFrequency);\n            GraalError.guarantee(blockFor(lex).relativeFrequency <= loopPredFrequency, \"Lex frequency %f must be below pred frequency %f\", loopPredFrequency, exitFrequency);\n        }\n    }\n\n    private void computeLocalLoopFrequencies() {\n        rpoInnerLoopsFirst(b -> {\n            perBasicBlockFrequencyAction(b, true);\n        }, lb -> {\n            finishLocalLoopFrequency(lb);\n        });\n    }\n\n    private double calculateLocalLoopFrequency(LoopBeginNode lb) {\n        HIRBlock header = blockFor(lb);\n        assert header != null;\n        double loopFrequency = -1;\n        ProfileSource source = ProfileSource.UNKNOWN;\n\n        if (CFGOptions.UseLoopEndFrequencies.getValue(lb.graph().getOptions())) {\n            double loopEndFrequency = 0D;\n            for (LoopEndNode len : lb.loopEnds()) {\n                HIRBlock endBlock = blockFor(len);\n                assert endBlock != null;\n                assert endBlock.relativeFrequency >= 0D : Assertions.errorMessageContext(\"endblock\", endBlock, \"endblock.rf\", endBlock.relativeFrequency);\n                loopEndFrequency += endBlock.relativeFrequency;\n                source = source.combine(endBlock.frequencySource);\n            }\n\n            loopEndFrequency = Math.min(1, loopEndFrequency);\n            loopEndFrequency = Math.max(ControlFlowGraph.MIN_RELATIVE_FREQUENCY, loopEndFrequency);\n\n            if (loopEndFrequency == 1D) {\n                // endless loop, loop with exit and deopt unconditionally after the exit\n                loopFrequency = MAX_RELATIVE_FREQUENCY;\n            } else {\n                double exitFrequency = 1D - loopEndFrequency;\n                loopFrequency = 1D / exitFrequency;\n\n                assert Double.isFinite(loopFrequency) : \"Loop=\" + lb + \" Loop Frequency=\" + loopFrequency + \" endFrequency=\" + loopEndFrequency;\n                assert !Double.isNaN(loopFrequency) : \"Loop=\" + lb + \" Loop Frequency=\" + loopFrequency + \" endFrequency=\" + loopEndFrequency;\n            }\n        } else {\n            /*\n             * Ideally we would like to use the loop end frequency sum here because it respects\n             * control flow sinks (unwinds and deopts) inside the loop (this can be seen in the\n             * branch above). However, if we ever exit a loop in compiled code it means we did not\n             * do so by an unwind or deopt but a loop exit, thus we ignore the end (and sink)\n             * frequencies and compute loop frequency purely based on the exit frequencies.\n             */\n            double loopExitFrequencySum = 0D;\n            for (LoopExitNode lex : lb.loopExits()) {\n                HIRBlock lexBlock = blockFor(lex);\n                assert lexBlock != null;\n                assert lexBlock.relativeFrequency >= 0D : Assertions.errorMessageContext(\"lexBlock\", lexBlock);\n                loopExitFrequencySum += lexBlock.relativeFrequency;\n                source = source.combine(lexBlock.frequencySource);\n            }\n\n            loopExitFrequencySum = Math.min(1, loopExitFrequencySum);\n            loopExitFrequencySum = Math.max(ControlFlowGraph.MIN_RELATIVE_FREQUENCY, loopExitFrequencySum);\n\n            loopFrequency = 1D / loopExitFrequencySum;\n            assert Double.isFinite(loopFrequency) : \"Loop=\" + lb + \" Loop Frequency=\" + loopFrequency + \" lexFrequencySum=\" + loopExitFrequencySum;\n            assert !Double.isNaN(loopFrequency) : \"Loop=\" + lb + \" Loop Frequency=\" + loopFrequency + \" lexFrequencySum=\" + loopExitFrequencySum;\n\n            if (CFGOptions.DumpEndVersusExitLoopFrequencies.getValue(lb.getOptions())) {\n                debugLocalLoopFrequencies(lb, loopFrequency, loopExitFrequencySum);\n            }\n        }\n\n        localLoopFrequencyData.put(lb, LoopFrequencyData.create(loopFrequency, source));\n        return loopFrequency;\n    }\n\n    @SuppressWarnings(\"try\")\n    private void debugLocalLoopFrequencies(LoopBeginNode lb, final double loopFrequency, final double loopExitFrequencySum) {\n        try (DebugContext.Scope s = lb.getDebug().scope(\"CFGFrequencyInfo\")) {\n            /*\n             * For loops without loop exit nodes we may only have deopt loop exit paths, they are\n             * however not part of the loop data structure of a Loop<HIR>, thus it might be that the\n             * reverse post order did not yet visit all sinks\n             */\n            boolean sinkingImplicitExitsFullyVisited = true;\n            double loopSinkFrequencySum = 0D;\n            for (HIRBlock loopBlock : blockFor(lb).getLoop().getBlocks()) {\n                FixedNode blockEndNode = loopBlock.getEndNode();\n                if (blockEndNode instanceof ControlSinkNode) {\n                    double sinkBlockFrequency = blockFor(blockEndNode).relativeFrequency;\n                    loopSinkFrequencySum += sinkBlockFrequency;\n                }\n                if (blockFor(blockEndNode).relativeFrequency == -1D) {\n                    sinkingImplicitExitsFullyVisited = false;\n                }\n            }\n            final double delta = 0.01D;\n            if (sinkingImplicitExitsFullyVisited) {\n                // verify integrity of the CFG so far\n                outer: for (HIRBlock loopBlock : blockFor(lb).getLoop().getBlocks()) {\n                    if (loopBlock.isLoopHeader()) {\n                        // loop exit successor frequency is weighted differently\n                        continue;\n                    }\n                    if (isDominatorTreeLoopExit(loopBlock, true)) {\n                        // loop exit successor frequency is weighted differently\n                        continue outer;\n                    }\n                    for (int i = 0; i < loopBlock.getSuccessorCount(); i++) {\n                        HIRBlock succ = loopBlock.getSuccessorAt(i);\n                        if (isDominatorTreeLoopExit(succ, true)) {\n                            // loop exit successor frequency is weighted differently\n                            continue outer;\n                        }\n                        if (succ.isLoopHeader()) {\n                            // header frequency is set to 1 artificially to compute local\n                            // frequencies\n                            continue outer;\n                        }\n                    }\n                    final double selfFrequency = loopBlock.relativeFrequency;\n                    double succFrequency = 0D;\n                    for (int i = 0; i < loopBlock.getSuccessorCount(); i++) {\n                        HIRBlock succ = loopBlock.getSuccessorAt(i);\n                        succFrequency += succ.relativeFrequency;\n                    }\n                    if (loopBlock.getSuccessorCount() == 0) {\n                        GraalError.guarantee(loopBlock.getEndNode() instanceof ControlSinkNode, \"Must sink if there is no successor\");\n                        // frequency \"lost\"\n                        continue;\n                    }\n                    if (succFrequency < selfFrequency - delta) {\n                        String format = \"Successors must add up for block %s with begin %s, selfF=%f succF=%f\";\n                        graph.getDebug().dump(DebugContext.VERBOSE_LEVEL, graph, format, loopBlock, loopBlock.getBeginNode(), selfFrequency, succFrequency);\n                        throw GraalError.shouldNotReachHere(String.format(format, loopBlock, loopBlock.getBeginNode(), selfFrequency, succFrequency)); // ExcludeFromJacocoGeneratedReport\n                    }\n                }\n            }\n            double loopEndFrequencySum = 0D;\n            for (LoopEndNode len : lb.loopEnds()) {\n                HIRBlock lenBlock = blockFor(len);\n                loopEndFrequencySum += lenBlock.relativeFrequency;\n            }\n            double endBasedFrequency = 1D / (1D - loopEndFrequencySum);\n            if (loopEndFrequencySum == 1D) {\n                // loop without any loop exits (and no sinks)\n                endBasedFrequency = MAX_RELATIVE_FREQUENCY;\n            }\n            // verify inner loop frequency calculations used sane loop exit frequencies\n            for (HIRBlock loopBlock : blockFor(lb).getLoop().getBlocks()) {\n                if (loopBlock.isLoopHeader() && loopBlock.getBeginNode() != lb) {\n                    LoopBeginNode otherLoop = (LoopBeginNode) loopBlock.getBeginNode();\n                    double otherLoopExitFrequencySum = 0D;\n                    for (LoopExitNode lex : otherLoop.loopExits()) {\n                        otherLoopExitFrequencySum += blockFor(lex).relativeFrequency;\n                    }\n                    // forward end\n                    final double predFrequency = loopBlock.getFirstPredecessor().relativeFrequency;\n                    final double frequencyDifference = Math.abs(predFrequency - otherLoopExitFrequencySum);\n                    if (frequencyDifference > delta) {\n                        graph.getDebug().dump(DebugContext.VERBOSE_LEVEL, graph, \"Frequencies diverge too much\");\n                        throw GraalError.shouldNotReachHere(\"Frequencies diverge too much\"); // ExcludeFromJacocoGeneratedReport\n                    }\n                }\n            }\n            /*\n             * \"Endless\" looking loops, i.e., loops without exit nodes (only deopt exits) look like\n             * inifinite loops if we take an exit frequency of \"0\", which results in max frequency\n             */\n            final boolean hasLoopExits = lb.loopExits().count() > 0;\n            if (Math.abs(endBasedFrequency - loopFrequency) > CFGOptions.LoopExitVsLoopEndFrequencyDiff.getValue(lb.getOptions()) && hasLoopExits) {\n                graph.getDebug().dump(DebugContext.VERBOSE_LEVEL, graph,\n                                \"Frequency divergence for loop %s,exitBasedFrequency=%.4f endBasedFrequency=%.4f, exitFSum=%.2f / endFSum=%.2f/ sinkSum=%.2f [allSum=%f]\", lb,\n                                loopFrequency, endBasedFrequency, loopExitFrequencySum, loopEndFrequencySum,\n                                loopSinkFrequencySum,\n                                (loopExitFrequencySum + loopEndFrequencySum + loopSinkFrequencySum));\n            }\n        }\n    }\n\n    private void resetBlockFrequencies() {\n        for (HIRBlock block : reversePostOrder) {\n            block.setRelativeFrequency(0);\n        }\n    }\n\n    private void computeFrequenciesFromLocal() {\n        for (HIRBlock block : reversePostOrder) {\n            perBasicBlockFrequencyAction(block, false);\n        }\n    }\n\n    private void perBasicBlockFrequencyAction(HIRBlock b, boolean computingLocalLoopFrequencies) {\n        double relativeFrequency = -1D;\n        ProfileSource source = ProfileSource.UNKNOWN;\n        if (b.getPredecessorCount() == 0) {\n            relativeFrequency = 1D;\n        } else if (b.getPredecessorCount() == 1) {\n            HIRBlock pred = b.getPredecessorAt(0);\n            relativeFrequency = pred.relativeFrequency;\n            if (pred.getSuccessorCount() > 1) {\n                assert pred.getEndNode() instanceof ControlSplitNode : Assertions.errorMessage(pred, pred.getEndNode());\n                ControlSplitNode controlSplit = (ControlSplitNode) pred.getEndNode();\n                relativeFrequency = multiplyRelativeFrequencies(relativeFrequency, controlSplit.probability(b.getBeginNode()));\n                if (computingLocalLoopFrequencies) {\n                    source = controlSplit.getProfileData().getProfileSource();\n                }\n            }\n        } else {\n            relativeFrequency = b.getPredecessorAt(0).relativeFrequency;\n            for (int i = 1; i < b.getPredecessorCount(); ++i) {\n                HIRBlock pred = b.getPredecessorAt(i);\n                relativeFrequency += pred.relativeFrequency;\n                if (computingLocalLoopFrequencies) {\n                    if (pred.frequencySource != null) {\n                        source = source.combine(pred.frequencySource);\n                    }\n                }\n            }\n            if (b.getBeginNode() instanceof LoopBeginNode) {\n                if (computingLocalLoopFrequencies) {\n                    // start with a \"local\" loop, i.e., assume no dominating code with different\n                    // frequencies\n                    relativeFrequency = 1D;\n                    source = ProfileSource.UNKNOWN;\n                } else {\n                    // take the previously computed local frequency\n                    LoopBeginNode loopBegin = (LoopBeginNode) b.getBeginNode();\n                    relativeFrequency = multiplyRelativeFrequencies(relativeFrequency, localLoopFrequencyData.get(loopBegin).getLoopFrequency());\n                }\n            }\n        }\n        if (relativeFrequency < MIN_RELATIVE_FREQUENCY) {\n            relativeFrequency = MIN_RELATIVE_FREQUENCY;\n        } else if (relativeFrequency > MAX_RELATIVE_FREQUENCY) {\n            relativeFrequency = MAX_RELATIVE_FREQUENCY;\n        }\n\n        b.setRelativeFrequency(relativeFrequency);\n        if (computingLocalLoopFrequencies) {\n            b.setFrequencySource(source);\n        }\n    }\n\n    //@formatter:off\n    /*\n     * Compute the frequency data for the entire control flow graph.\n     * In the following documentation the term \"local loop frequency\" describes the frequency of a loop\n     * without any enclosing code, i.e., the loop in a form where it is not dominated by any other control flow.\n     *\n     * The real frequency of a loop is then the result of multiplying the local loop frequency with the frequency\n     * of the basic block dominating the loop.\n     *\n     * Consider the following CFG:\n     *\n     *\n     *\n     *                                [B0: Loop 1 Header]\n     *                                        |\n     *                                     [B1:if]\n     *                                      /  \\\n     *                    [B2: Loop 2 Header]  [B9: Loop Exit Loop1 + Return]\n     *                              |\n     *                          [B3: If]\n     *                           /    \\\n     *         [B4: LoopEnd Loop2]    [B5: LoopExit Loop2 + If]\n     *                                         /     \\\n     *                                      [B6]     [B7]\n     *                                         \\     /\n     *                                [B8:Merge + LoopEnd Loop1]\n     *\n     *\n     *  The frequency of the loop exit basic blocks depends on the frequency of the loop header.\n     *  Why? Because the loop header is visited multiple times so the frequency of the loop exit block\n     *  has to be multiplied by the frequency of the loop header (which is the frequency of all loop\n     *  end blocks combined). The frequency of the loop header can be derived by summing up the frequency\n     *  of all loop end blocks which gives us the frequency for exiting the loop (1- sumLoopEndFrequency).\n     *  The frequency of the loop can then be calculated by 1 / frequencyToExitTheLoop.\n     *\n     *  In a final step we  multiply the frequency of each exit with the frequency to exit the overall\n     *  loop to account for the loop frequency.\n     *\n     *  Ideally we would only process all basic blocks once here, however, given that the frequency of an\n     *  outer loop depends on loop end frequencies which can depend on the frequency of inner loops,\n     *  we either ensure to process inner loops first or perform the entire process until a fix point is reached.\n     *\n     *  However, we can utilize a \"smart\" reverse post order with inner loops first to reach that goal.\n     *\n     *  Graph theory states that there are multiple correct reverse post order (RPO) traversals\n     *  for any given graph. Consider for example the following RPO for the CFG above:\n     *      [B0,B1,B2,B3,B4,B5,B6,B7,B8,B9]\n     *\n     *  The inner loop is sequentially in the traversal, thus we can compute its local frequency and\n     *  then propagate it outwards by processing the entire CFG once again.\n     *\n     *  However, there are other valid RPOs that do not allow a single pass over all loops to calculate local\n     *  frequencies: e.g. [B0,B1,B9,B2,B3,B5,B6,B7,B8,B4], thus this phase ensures that we have the \"right\" RPO.\n     *\n     *  Implementation notes:\n     *  The algorithm to compute the loop frequencies works in two passes: the first pass computes\n     *  the local loop frequencies, i.e., for every loop predecessor block a relative frequency of 1\n     *  is assumed, then the frequency inside the loop is propagated and multiplied by control split\n     *  probabilities. If a loop is finished the exit frequency is set accordingly.\n     *\n     *  The second pass then propagates relative frequencies into the entire CFG by using the,\n     *  already correct, local loop frequencies for the body of the loop.\n     */\n    //@formatter:on\n    private void computeFrequencies() {\n        /*\n         * General note: While it is not verified that the reverse post order contains inner loops\n         * first yet, this will be verified once we calculate dominance information, thus we should\n         * be good here.\n         */\n        localLoopFrequencyData = EconomicMap.create();\n\n        // pass 1 compute \"local\" loop frequencies, i.e., the actual frequency of each self\n        // contained loop, inner loops first, then outer loops\n        computeLocalLoopFrequencies();\n\n        // reset everything again\n        resetBlockFrequencies();\n\n        // pass 2 propagate the outer frequencies into the inner ones multiplying the local loop\n        // frequencies by the loop predecessor frequencies\n        computeFrequenciesFromLocal();\n\n        if (Assertions.assertionsEnabled()) {\n            for (HIRBlock block : reversePostOrder) {\n                assert block.getRelativeFrequency() >= 0 : \"Must have a relative frequency set, block \" + block;\n            }\n        }\n    }\n\n    private void computeLoopInformation() {\n        loops = new ArrayList<>(graph.getNodes(LoopBeginNode.TYPE).count());\n        if (graph.hasLoops()) {\n            HIRBlock[] stack = new HIRBlock[this.reversePostOrder.length];\n            for (HIRBlock block : reversePostOrder) {\n                AbstractBeginNode beginNode = block.getBeginNode();\n                if (beginNode instanceof LoopBeginNode) {\n                    Loop<HIRBlock> parent = block.getLoop();\n                    Loop<HIRBlock> loop = new HIRLoop(parent, loops.size(), block);\n                    if (parent != null) {\n                        parent.getChildren().add(loop);\n                    }\n                    loops.add(loop);\n                    block.setLoop(loop);\n                    loop.getBlocks().add(block);\n\n                    LoopBeginNode loopBegin = (LoopBeginNode) beginNode;\n                    for (LoopEndNode end : loopBegin.loopEnds()) {\n                        HIRBlock endBlock = nodeToBlock.get(end);\n                        computeLoopBlocks(endBlock, loop, stack, true);\n                    }\n\n                    // Note that at this point, due to traversal order, child loops of `loop` have\n                    // not been discovered yet.\n                    for (HIRBlock b : loop.getBlocks()) {\n                        for (int i = 0; i < b.getSuccessorCount(); i++) {\n                            HIRBlock sux = b.getSuccessorAt(i);\n                            if (sux.getLoop() != loop) {\n                                assert sux.getLoopDepth() < loop.getDepth() : Assertions.errorMessageContext(\"sux\", sux, \"sux.loopDepth\", sux.getLoopDepth(), \"loop\", loop, \"loop.loopDepth\",\n                                                loop.getDepth());\n                                loop.getNaturalExits().add(sux);\n                            }\n                        }\n                    }\n                    loop.getNaturalExits().sort(BasicBlock.BLOCK_ID_COMPARATOR);\n\n                    if (!graph.getGuardsStage().areFrameStatesAtDeopts()) {\n                        for (LoopExitNode exit : loopBegin.loopExits()) {\n                            HIRBlock exitBlock = nodeToBlock.get(exit);\n                            assert exitBlock.getPredecessorCount() == 1 : Assertions.errorMessage(exit, exitBlock);\n                            computeLoopBlocks(exitBlock.getFirstPredecessor(), loop, stack, true);\n                            loop.getLoopExits().add(exitBlock);\n                        }\n                        loop.getLoopExits().sort(BasicBlock.BLOCK_ID_COMPARATOR);\n\n                        // The following loop can add new blocks to the end of the loop's block\n                        // list.\n                        int size = loop.getBlocks().size();\n                        for (int i = 0; i < size; ++i) {\n                            HIRBlock b = loop.getBlocks().get(i);\n                            for (int j = 0; j < b.getSuccessorCount(); j++) {\n                                HIRBlock sux = b.getSuccessorAt(j);\n                                if (sux.getLoop() != loop) {\n                                    AbstractBeginNode begin = sux.getBeginNode();\n                                    if (!loopBegin.isLoopExit(begin)) {\n                                        assert !(begin instanceof LoopBeginNode) : Assertions.errorMessageContext(\"begin\", begin);\n                                        assert sux.getLoopDepth() < loop.getDepth() : Assertions.errorMessageContext(\"sux\", sux, \"sux.loopDepth\", sux.getLoopDepth(), \"loop\", loop,\n                                                        \"loop.loopDepth\",\n                                                        loop.getDepth());\n                                        graph.getDebug().log(DebugContext.VERBOSE_LEVEL, \"Unexpected loop exit with %s, including whole branch in the loop\", sux);\n                                        computeLoopBlocks(sux, loop, stack, false);\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        loop.getLoopExits().addAll(loop.getNaturalExits());\n                    }\n                }\n            }\n        }\n    }\n\n    private static void computeLoopBlocks(HIRBlock start, Loop<HIRBlock> loop, HIRBlock[] stack, boolean usePred) {\n        if (start.getLoop() != loop) {\n            start.setLoop(loop);\n            stack[0] = start;\n            loop.getBlocks().add(start);\n            int tos = 0;\n            do {\n                HIRBlock block = stack[tos--];\n\n                // Add predecessors or successors to the loop.\n                for (int i = 0; i < (usePred ? block.getPredecessorCount() : block.getSuccessorCount()); i++) {\n                    HIRBlock b = (usePred ? block.getPredecessorAt(i) : block.getSuccessorAt(i));\n                    if (b.getLoop() != loop) {\n                        stack[++tos] = b;\n                        b.setLoop(loop);\n                        loop.getBlocks().add(b);\n                    }\n                }\n            } while (tos >= 0);\n        }\n    }\n\n    public void computePostdominators() {\n        HIRBlock[] reversePostOrderTmp = this.reversePostOrder;\n        outer: for (int j = reversePostOrderTmp.length - 1; j >= 0; --j) {\n            HIRBlock block = reversePostOrderTmp[j];\n            if (block.isLoopEnd()) {\n                // We do not want the loop header registered as the postdominator of the loop end.\n                continue;\n            }\n            if (block.getSuccessorCount() == 0) {\n                // No successors => no postdominator.\n                continue;\n            }\n            HIRBlock firstSucc = block.getSuccessorAt(0);\n            if (block.getSuccessorCount() == 1) {\n                block.postdominator = firstSucc.getId();\n                continue;\n            }\n            HIRBlock postdominator = firstSucc;\n            for (int i = 0; i < block.getSuccessorCount(); i++) {\n                HIRBlock sux = block.getSuccessorAt(i);\n                postdominator = commonPostdominator(postdominator, sux);\n                if (postdominator == null) {\n                    // There is a dead end => no postdominator available.\n                    continue outer;\n                }\n            }\n            assert !block.containsSucc(postdominator) : \"Block \" + block + \" has a wrong post dominator: \" + postdominator;\n            block.setPostDominator(postdominator);\n        }\n    }\n\n    private static HIRBlock commonPostdominator(HIRBlock a, HIRBlock b) {\n        HIRBlock iterA = a;\n        HIRBlock iterB = b;\n        while (iterA != iterB) {\n            if (iterA.getId() < iterB.getId()) {\n                iterA = iterA.getPostdominator();\n                if (iterA == null) {\n                    return null;\n                }\n            } else {\n                assert iterB.getId() < iterA.getId() : Assertions.errorMessageContext(\"a\", a, \"b\", b, \"iterB.id\", iterB.getId(), \"iterA.id\", iterA.getId());\n                iterB = iterB.getPostdominator();\n                if (iterB == null) {\n                    return null;\n                }\n            }\n        }\n        return iterA;\n    }\n\n    public void setNodeToBlock(NodeMap<HIRBlock> nodeMap) {\n        this.nodeToBlock = nodeMap;\n    }\n\n    public static double multiplyRelativeFrequencies(double a, double b, double c) {\n        return multiplyRelativeFrequencies(multiplyRelativeFrequencies(a, b), c);\n    }\n\n    /**\n     * Multiplies a and b and clamps the between {@link ControlFlowGraph#MIN_RELATIVE_FREQUENCY} and\n     * {@link ControlFlowGraph#MAX_RELATIVE_FREQUENCY}.\n     */\n    public static double multiplyRelativeFrequencies(double a, double b) {\n        assert !Double.isNaN(a) && !Double.isNaN(b) && Double.isFinite(a) && Double.isFinite(b) : a + \" \" + b;\n        double r = a * b;\n        if (r > MAX_RELATIVE_FREQUENCY) {\n            return MAX_RELATIVE_FREQUENCY;\n        }\n        if (r < MIN_RELATIVE_FREQUENCY) {\n            return MIN_RELATIVE_FREQUENCY;\n        }\n        return r;\n    }\n}",
                "methodCount": 60
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 13,
                "candidates": [
                    {
                        "lineStart": 197,
                        "lineEnd": 199,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method notWeakerThan to class BuildConfig",
                        "description": "Move method notWeakerThan to jdk.graal.compiler.nodes.cfg.ControlFlowGraph.BuildConfig\nRationale: The method notWeakerThan heavily relies on the computeDominators field, which is a part of the BuildConfig class. Since this method compares the current state of the configuration and the ControlFlowGraph's build configuration, it logically aligns with the existing hasAllParams method. By moving the notWeakerThan method to BuildConfig, we maintain cohesion and encapsulate related logic within the same class. This makes the code easier to maintain and improve.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 817,
                        "lineEnd": 819,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method blockFor to class MemUseTrackerKey",
                        "description": "Move method blockFor to jdk.graal.compiler.debug.MemUseTrackerKey\nRationale: The method blockFor() deals with associating a Node object with an HIRBlock, which does not align with memory usage tracking, the main purpose of the MemUseTrackerKey class. This class is focused on metrics and memory tracking, not mapping nodes to blocks in a hierarchical representation. Therefore, MemUseTrackerKey is not a fitting target for this method. Consider other classes in the project's hierarchy that handle nodes, blocks, or similar structures for a more appropriate placement.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1126,
                        "lineEnd": 1214,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method computeFrequencies to class BuildConfig",
                        "description": "Move method computeFrequencies to jdk.graal.compiler.nodes.cfg.ControlFlowGraph.BuildConfig\nRationale: The method computeFrequencies() is focused on computing control flow graph (CFG) frequencies, a task closely related to the configuration and setup of a build process in a compiler or analysis tool. The BuildConfig class already contains fields and methods related to building processes such as computeFrequency, computeLoops, and computeDominators. Thus, moving the method to this class aligns closely with the existing responsibilities and functionalities of BuildConfig, ensuring a coherent design.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 375,
                        "lineEnd": 381,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method skipPostDom to class InteropUtils",
                        "description": "move method skipPostDom to PsiClass:InteropUtils\nRationale: The method `skipPostDom` seems to be handling dominator and postdominator relationships, which is closely related to the concept of meta and hierarchical organization, making it more relevant to `InteropUtils` which deals with the hierarchy and characterization of classes (`Klass`), metadata, and exception handling. `NativeImageResourceFileSystemUtil` focuses on file system operations, while `ConstantFoldUtil` caters to constant folding optimization, neither of which aligns with the functionality offered by `skipPostDom`, which fits more naturally with the utility methods in `InteropUtils`.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 288,
                        "lineEnd": 295,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method printDomTree to class FileUtils",
                        "description": "move method printDomTree to PsiClass:FileUtils\nRationale: The `printDomTree` method deals primarily with printing and iterating through a hierarchical structure of objects, which can conceptually align with utility operations involving input streams. Moving the method to the `FileUtils` class is appropriate since `FileUtils` handles comprehensive operations related to I/O streams and file handling, and this method complements the class's functionality by providing a means to print structured data.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1062,
                        "lineEnd": 1066,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method resetBlockFrequencies to class BuildConfig",
                        "description": "Move method resetBlockFrequencies to jdk.graal.compiler.nodes.cfg.ControlFlowGraph.BuildConfig\nRationale: The resetBlockFrequencies() method is setting the relative frequency of HIRBlock objects, which appears to be related to build configurations. BuildConfig contains parameters and methods that deal with computing frequencies, loops, dominators, and postdominators, which suggests it handles the configuration of blocks and their properties during a build process. Thus, it is logical to relocate resetBlockFrequencies() to BuildConfig because it aligns with the responsibilities and functionalities already present in the BuildConfig class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 231,
                        "lineEnd": 244,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method identifyBlocks to class BuildConfig",
                        "description": "Move method identifyBlocks to jdk.graal.compiler.nodes.cfg.ControlFlowGraph.BuildConfig\nRationale: The identifyBlocks method appears to be responsible for identifying and processing blocks within a control flow graph structure, which closely aligns with build configuration aspects like computing dominators, loops, and block connectivity. The BuildConfig class already manages aspects of graph building and control flow analysis, making it a more appropriate location for this method as it would logically centralize these functionalities together.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 394,
                        "lineEnd": 403,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method addDeferredExit to class InliningUtil",
                        "description": "move method addDeferredExit to PsiClass:InliningUtil\nRationale: The method `addDeferredExit` manipulates loops, dominators, and deferred exits which indicates it is involved with control flow and inlining operations. The `InliningUtil` class already contains methods for tracing inlining decisions, working with method invocations, and performing inlining-related modifications on the control flow graph. Therefore, moving `addDeferredExit` to `InliningUtil` places it closer to related functionalities and maintains cohesive code organization.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 779,
                        "lineEnd": 787,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method commonDominatorRaw to class LoggingCFGDecorator",
                        "description": "move method commonDominatorRaw to PsiClass:LoggingCFGDecorator\nRationale: The method commonDominatorRaw() is related to the dominator tree of control flow graphs, which matches the functionality described in LoggingCFGDecorator. This class is already implementing methods that deal with dominator and post-dominator concepts, making it a suitable environment for the commonDominatorRaw method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 496,
                        "lineEnd": 507,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method isDominatorTreeLoopExit to class ConditionalEliminationUtil",
                        "description": "move method isDominatorTreeLoopExit to PsiClass:ConditionalEliminationUtil\nRationale: The method isDominatorTreeLoopExit() is responsible for making a determination based on dominator and loop structures which are common in various optimization techniques in compiler design. ConditionalEliminationUtil deals with various conditional and logical evaluations, making it a fitting parent class given its existing context and utility methods for such analysis. This relocation also aligns logically with the purpose and functionalities present in ConditionalEliminationUtil.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 896,
                        "lineEnd": 956,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method calculateLocalLoopFrequency to class BuildConfig",
                        "description": "Move method calculateLocalLoopFrequency to jdk.graal.compiler.nodes.cfg.ControlFlowGraph.BuildConfig\nRationale: The method `calculateLocalLoopFrequency` involves calculating loop frequencies and interacts heavily with control flow graph options (`CFGOptions`), block structures (`HIRBlock`), and loop nodes (`LoopBeginNode`, `LoopEndNode`, `LoopExitNode`). These domain-specific terms indicate a strong association with configurations and computations related to control flow and loops, which align with the responsibilities of the `BuildConfig` class. Given that `BuildConfig` already handles whether to compute frequencies, loops, and dominators, it makes sense for this class to house the frequency calculation method as well. Moreover, `BuildConfig` ensures the integrity of various computation configurations, strengthening the rationale for colocating all relevant calculation methods in this class. MemUseTrackerKey, on the other hand, is focused on tracking memory usage and provides no relevant context or utilities for loop frequency calculation, making it an unsuitable target.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 839,
                        "lineEnd": 860,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method identifyBlock to class BuildConfig",
                        "description": "Move method identifyBlock to jdk.graal.compiler.nodes.cfg.ControlFlowGraph.BuildConfig\nRationale: The method `identifyBlock(HIRBlock block)` is primarily concerned with traversing and identifying nodes in basic blocks, which is more aligned with configuration and processing of graph structures in the existing class `BuildConfig`. This class already includes methods related to configuring and validating blocks, such as `update` and `hasAllParams`. Moving the method to `BuildConfig` would provide a cohesive grouping of functionalities related to block processing and configuration.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 862,
                        "lineEnd": 886,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method finishLocalLoopFrequency to class BuildConfig",
                        "description": "Move method finishLocalLoopFrequency to jdk.graal.compiler.nodes.cfg.ControlFlowGraph.BuildConfig\nRationale: The finishLocalLoopFrequency method is closely related to computeFrequency, computeLoops, and other properties managed by the BuildConfig class. This method is involved in calculating loop frequencies and exits, which aligns with the duties of the BuildConfig class, especially its computeFrequency and computeLoops functions. MemUseTrackerKey, on the other hand, deals with memory usage tracking and does not seem relevant to the frequency and loop computations.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "computeForSchedule",
                            "method_signature": "public static ControlFlowGraph computeForSchedule(StructuredGraph graph)",
                            "target_class": "ControlFlowGraphBuilder",
                            "rationale": "The computeForSchedule method should be moved to the ControlFlowGraphBuilder class because it is related to the construction of a ControlFlowGraph, which is the responsibility of the builder class."
                        },
                        {
                            "method_name": "compute",
                            "method_signature": "static ControlFlowGraph compute(StructuredGraph graph, boolean backendBlocks, boolean connectBlocks, boolean computeFrequency, boolean computeLoops, boolean computeDominators, boolean computePostdominators)",
                            "target_class": "ControlFlowGraphBuilder",
                            "rationale": "The compute method is heavily involved in the creation and configuration of the ControlFlowGraph. This fits the responsibility of the ControlFlowGraphBuilder class better than the ControlFlowGraph class itself."
                        },
                        {
                            "method_name": "newBuilder",
                            "method_signature": "public static ControlFlowGraphBuilder newBuilder(StructuredGraph structuredGraph)",
                            "target_class": "ControlFlowGraphBuilder",
                            "rationale": "The newBuilder method is responsible for initializing a new builder, and thus should be located in the ControlFlowGraphBuilder class."
                        }
                    ],
                    "llm_response_time": 5404
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "multiplyRelativeFrequencies",
                            "method_signature": "public static double multiplyRelativeFrequencies(double a, double b)",
                            "target_class": "FrequencyUtils",
                            "rationale": "The method multiplyRelativeFrequencies handles mathematical operations related to frequencies. As it's a utility function not specific to the ControlFlowGraph, extracting it to a utility class like FrequencyUtils would enhance code modularity and reusability."
                        },
                        {
                            "method_name": "multiplyRelativeFrequencies",
                            "method_signature": "public static double multiplyRelativeFrequencies(double a, double b, double c)",
                            "target_class": "FrequencyUtils",
                            "rationale": "Like its single-parameter counterpart, the three-parameter multiplyRelativeFrequencies also deals with frequency multiplications and should be moved to the FrequencyUtils class for the same reasons."
                        }
                    ],
                    "llm_response_time": 3924
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "addDeferredExit",
                            "method_signature": "public static void addDeferredExit(DeferredExit[] deferredExits, HIRBlock b)",
                            "target_class": "DeferredExit",
                            "rationale": "The method `addDeferredExit` manipulates instances of `DeferredExit` and manages their linkages, which are more cohesive within the `DeferredExit` class."
                        },
                        {
                            "method_name": "computeLoopBlocks",
                            "method_signature": "public static void computeLoopBlocks(HIRBlock start, Loop<HIRBlock> loop, HIRBlock[] stack, boolean usePred)",
                            "target_class": "Loop",
                            "rationale": "The `computeLoopBlocks` method is responsible for populating and managing loop blocks which is directly related to the `Loop` class. Hence, it should be moved to the `Loop` class."
                        },
                        {
                            "method_name": "commonDominatorRaw",
                            "method_signature": "private static HIRBlock commonDominatorRaw(HIRBlock a, HIRBlock b)",
                            "target_class": "HIRBlock",
                            "rationale": "The method `commonDominatorRaw` operates primarily on `HIRBlock` instances and is better suited within the `HIRBlock` class."
                        },
                        {
                            "method_name": "commonDominatorRawSameDepth",
                            "method_signature": "private static HIRBlock commonDominatorRawSameDepth(HIRBlock a, HIRBlock b)",
                            "target_class": "HIRBlock",
                            "rationale": "The method `commonDominatorRawSameDepth` is a utility function strictly working with `HIRBlock` instances, making it more fitting within the `HIRBlock` class."
                        },
                        {
                            "method_name": "commonPostdominator",
                            "method_signature": "private static HIRBlock commonPostdominator(HIRBlock a, HIRBlock b)",
                            "target_class": "HIRBlock",
                            "rationale": "This method calculates the common postdominator for HIRBlock instances, which logically fits inside the `HIRBlock` class."
                        },
                        {
                            "method_name": "multiplyRelativeFrequencies",
                            "method_signature": "public static double multiplyRelativeFrequencies(double a, double b, double c)",
                            "target_class": "HIRBlock",
                            "rationale": "This method multiplies the relative frequencies of blocks. Such utility functions are better suited within the `HIRBlock` class."
                        },
                        {
                            "method_name": "multiplyRelativeFrequencies",
                            "method_signature": "public static double multiplyRelativeFrequencies(double a, double b)",
                            "target_class": "HIRBlock",
                            "rationale": "Similar to the overloaded method, this utility function is specifically dealing with block relative frequencies, making it more appropriate for the `HIRBlock` class."
                        }
                    ],
                    "llm_response_time": 8089
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "compute",
                            "method_signature": "@SuppressWarnings(\"try\")\n    static compute(StructuredGraph graph, boolean backendBlocks, boolean connectBlocks, boolean computeFrequency, boolean computeLoops, boolean computeDominators,\n                    boolean computePostdominators)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "notWeakerThan",
                            "method_signature": "private notWeakerThan(boolean computeDominators, boolean loopInfoComputed, ControlFlowGraph cfg)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "identifyBlocks",
                            "method_signature": "private identifyBlocks(boolean makeEditable)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "printDomTree",
                            "method_signature": "private static printDomTree(HIRBlock cur, String indent)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "visitDominatorTreeDefault",
                            "method_signature": "@SuppressWarnings(\"unchecked\")\n    public visitDominatorTreeDefault(RecursiveVisitor<V> visitor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "skipPostDom",
                            "method_signature": "private static skipPostDom(HIRBlock block)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addDeferredExit",
                            "method_signature": "public static addDeferredExit(DeferredExit[] deferredExits, HIRBlock b)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "visitDominatorTreeDeferLoopExits",
                            "method_signature": "@SuppressWarnings({\"unchecked\"})\n    public visitDominatorTreeDeferLoopExits(RecursiveVisitor<V> visitor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isDominatorTreeLoopExit",
                            "method_signature": "public static isDominatorTreeLoopExit(HIRBlock b, boolean considerRealExits)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "loopFullyProcessed",
                            "method_signature": " loopFullyProcessed()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "allEndsVisited",
                            "method_signature": " allEndsVisited()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "rpoInnerLoopsFirst",
                            "method_signature": "private rpoInnerLoopsFirst(Consumer<HIRBlock> perBasicBlockOption, Consumer<LoopBeginNode> loopClosedAction)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "predecessorBlockSequentialLoopExit",
                            "method_signature": "private static predecessorBlockSequentialLoopExit(HIRBlock b)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "commonDominatorRaw",
                            "method_signature": "private static commonDominatorRaw(HIRBlock a, HIRBlock b)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "blockFor",
                            "method_signature": "public blockFor(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "identifyBlock",
                            "method_signature": "private identifyBlock(HIRBlock block)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "finishLocalLoopFrequency",
                            "method_signature": "private finishLocalLoopFrequency(LoopBeginNode lb)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "calculateLocalLoopFrequency",
                            "method_signature": "private calculateLocalLoopFrequency(LoopBeginNode lb)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "debugLocalLoopFrequencies",
                            "method_signature": "@SuppressWarnings(\"try\")\n    private debugLocalLoopFrequencies(LoopBeginNode lb, final double loopFrequency, final double loopExitFrequencySum)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "resetBlockFrequencies",
                            "method_signature": "private resetBlockFrequencies()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "perBasicBlockFrequencyAction",
                            "method_signature": "private perBasicBlockFrequencyAction(HIRBlock b, boolean computingLocalLoopFrequencies)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "computeFrequencies",
                            "method_signature": "private computeFrequencies()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "computeLoopInformation",
                            "method_signature": "private computeLoopInformation()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "computeLoopBlocks",
                            "method_signature": "private static computeLoopBlocks(HIRBlock start, Loop<HIRBlock> loop, HIRBlock[] stack, boolean usePred)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "notWeakerThan",
                            "method_signature": "private notWeakerThan(boolean computeDominators, boolean loopInfoComputed, ControlFlowGraph cfg)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "loopFullyProcessed",
                            "method_signature": " loopFullyProcessed()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "allEndsVisited",
                            "method_signature": " allEndsVisited()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "blockFor",
                            "method_signature": "public blockFor(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "computeFrequencies",
                            "method_signature": "private computeFrequencies()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "skipPostDom",
                            "method_signature": "private static skipPostDom(HIRBlock block)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "printDomTree",
                            "method_signature": "private static printDomTree(HIRBlock cur, String indent)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "resetBlockFrequencies",
                            "method_signature": "private resetBlockFrequencies()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "identifyBlocks",
                            "method_signature": "private identifyBlocks(boolean makeEditable)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addDeferredExit",
                            "method_signature": "public static addDeferredExit(DeferredExit[] deferredExits, HIRBlock b)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "commonDominatorRaw",
                            "method_signature": "private static commonDominatorRaw(HIRBlock a, HIRBlock b)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isDominatorTreeLoopExit",
                            "method_signature": "public static isDominatorTreeLoopExit(HIRBlock b, boolean considerRealExits)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "calculateLocalLoopFrequency",
                            "method_signature": "private calculateLocalLoopFrequency(LoopBeginNode lb)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "identifyBlock",
                            "method_signature": "private identifyBlock(HIRBlock block)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "finishLocalLoopFrequency",
                            "method_signature": "private finishLocalLoopFrequency(LoopBeginNode lb)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "private notWeakerThan(boolean computeDominators, boolean loopInfoComputed, ControlFlowGraph cfg)": {
                        "first": {
                            "method_name": "notWeakerThan",
                            "method_signature": "private notWeakerThan(boolean computeDominators, boolean loopInfoComputed, ControlFlowGraph cfg)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.27836721553700305
                    },
                    " loopFullyProcessed()": {
                        "first": {
                            "method_name": "loopFullyProcessed",
                            "method_signature": " loopFullyProcessed()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3046162309172959
                    },
                    " allEndsVisited()": {
                        "first": {
                            "method_name": "allEndsVisited",
                            "method_signature": " allEndsVisited()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3645778103119774
                    },
                    "public blockFor(Node node)": {
                        "first": {
                            "method_name": "blockFor",
                            "method_signature": "public blockFor(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3788167813805959
                    },
                    "private computeFrequencies()": {
                        "first": {
                            "method_name": "computeFrequencies",
                            "method_signature": "private computeFrequencies()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.40830778774462234
                    },
                    "private static skipPostDom(HIRBlock block)": {
                        "first": {
                            "method_name": "skipPostDom",
                            "method_signature": "private static skipPostDom(HIRBlock block)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4493329686279366
                    },
                    "private static printDomTree(HIRBlock cur, String indent)": {
                        "first": {
                            "method_name": "printDomTree",
                            "method_signature": "private static printDomTree(HIRBlock cur, String indent)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4624793614873314
                    },
                    "private resetBlockFrequencies()": {
                        "first": {
                            "method_name": "resetBlockFrequencies",
                            "method_signature": "private resetBlockFrequencies()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4878964177016768
                    },
                    "private identifyBlocks(boolean makeEditable)": {
                        "first": {
                            "method_name": "identifyBlocks",
                            "method_signature": "private identifyBlocks(boolean makeEditable)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4956514369005153
                    },
                    "public static addDeferredExit(DeferredExit[] deferredExits, HIRBlock b)": {
                        "first": {
                            "method_name": "addDeferredExit",
                            "method_signature": "public static addDeferredExit(DeferredExit[] deferredExits, HIRBlock b)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5450207851852436
                    },
                    "private static commonDominatorRaw(HIRBlock a, HIRBlock b)": {
                        "first": {
                            "method_name": "commonDominatorRaw",
                            "method_signature": "private static commonDominatorRaw(HIRBlock a, HIRBlock b)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5548264629216734
                    },
                    "public static isDominatorTreeLoopExit(HIRBlock b, boolean considerRealExits)": {
                        "first": {
                            "method_name": "isDominatorTreeLoopExit",
                            "method_signature": "public static isDominatorTreeLoopExit(HIRBlock b, boolean considerRealExits)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5597823653692514
                    },
                    "private calculateLocalLoopFrequency(LoopBeginNode lb)": {
                        "first": {
                            "method_name": "calculateLocalLoopFrequency",
                            "method_signature": "private calculateLocalLoopFrequency(LoopBeginNode lb)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6313266428180764
                    },
                    "private identifyBlock(HIRBlock block)": {
                        "first": {
                            "method_name": "identifyBlock",
                            "method_signature": "private identifyBlock(HIRBlock block)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6371121258209707
                    },
                    "private finishLocalLoopFrequency(LoopBeginNode lb)": {
                        "first": {
                            "method_name": "finishLocalLoopFrequency",
                            "method_signature": "private finishLocalLoopFrequency(LoopBeginNode lb)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6445168613352016
                    }
                },
                "voyage": {
                    "public blockFor(Node node)": {
                        "first": {
                            "method_name": "blockFor",
                            "method_signature": "public blockFor(Node node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3424525753245505
                    },
                    "private static skipPostDom(HIRBlock block)": {
                        "first": {
                            "method_name": "skipPostDom",
                            "method_signature": "private static skipPostDom(HIRBlock block)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.36955268378574263
                    },
                    " allEndsVisited()": {
                        "first": {
                            "method_name": "allEndsVisited",
                            "method_signature": " allEndsVisited()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.40628553242184823
                    },
                    "private static printDomTree(HIRBlock cur, String indent)": {
                        "first": {
                            "method_name": "printDomTree",
                            "method_signature": "private static printDomTree(HIRBlock cur, String indent)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4141495893085002
                    },
                    "private static commonDominatorRaw(HIRBlock a, HIRBlock b)": {
                        "first": {
                            "method_name": "commonDominatorRaw",
                            "method_signature": "private static commonDominatorRaw(HIRBlock a, HIRBlock b)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4156132128081595
                    },
                    " loopFullyProcessed()": {
                        "first": {
                            "method_name": "loopFullyProcessed",
                            "method_signature": " loopFullyProcessed()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4644813560485412
                    },
                    "@SuppressWarnings(\"unchecked\")\n    public visitDominatorTreeDefault(RecursiveVisitor<V> visitor)": {
                        "first": {
                            "method_name": "visitDominatorTreeDefault",
                            "method_signature": "@SuppressWarnings(\"unchecked\")\n    public visitDominatorTreeDefault(RecursiveVisitor<V> visitor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.466886499125083
                    },
                    "private identifyBlock(HIRBlock block)": {
                        "first": {
                            "method_name": "identifyBlock",
                            "method_signature": "private identifyBlock(HIRBlock block)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.47771445149172687
                    },
                    "public static addDeferredExit(DeferredExit[] deferredExits, HIRBlock b)": {
                        "first": {
                            "method_name": "addDeferredExit",
                            "method_signature": "public static addDeferredExit(DeferredExit[] deferredExits, HIRBlock b)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.49176029730968757
                    },
                    "private notWeakerThan(boolean computeDominators, boolean loopInfoComputed, ControlFlowGraph cfg)": {
                        "first": {
                            "method_name": "notWeakerThan",
                            "method_signature": "private notWeakerThan(boolean computeDominators, boolean loopInfoComputed, ControlFlowGraph cfg)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5221050953999661
                    },
                    "public static isDominatorTreeLoopExit(HIRBlock b, boolean considerRealExits)": {
                        "first": {
                            "method_name": "isDominatorTreeLoopExit",
                            "method_signature": "public static isDominatorTreeLoopExit(HIRBlock b, boolean considerRealExits)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5224205701177442
                    },
                    "private static computeLoopBlocks(HIRBlock start, Loop<HIRBlock> loop, HIRBlock[] stack, boolean usePred)": {
                        "first": {
                            "method_name": "computeLoopBlocks",
                            "method_signature": "private static computeLoopBlocks(HIRBlock start, Loop<HIRBlock> loop, HIRBlock[] stack, boolean usePred)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5268210302437409
                    },
                    "private identifyBlocks(boolean makeEditable)": {
                        "first": {
                            "method_name": "identifyBlocks",
                            "method_signature": "private identifyBlocks(boolean makeEditable)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5390748503393507
                    },
                    "private resetBlockFrequencies()": {
                        "first": {
                            "method_name": "resetBlockFrequencies",
                            "method_signature": "private resetBlockFrequencies()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5541051667290731
                    },
                    "@SuppressWarnings({\"unchecked\"})\n    public visitDominatorTreeDeferLoopExits(RecursiveVisitor<V> visitor)": {
                        "first": {
                            "method_name": "visitDominatorTreeDeferLoopExits",
                            "method_signature": "@SuppressWarnings({\"unchecked\"})\n    public visitDominatorTreeDeferLoopExits(RecursiveVisitor<V> visitor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5645090498569
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public blockFor(Node node)",
                        "private static commonDominatorRaw(HIRBlock a, HIRBlock b)",
                        "private static skipPostDom(HIRBlock block)",
                        "private static printDomTree(HIRBlock cur, String indent)",
                        "public static isDominatorTreeLoopExit(HIRBlock b, boolean considerRealExits)",
                        "private notWeakerThan(boolean computeDominators, boolean loopInfoComputed, ControlFlowGraph cfg)",
                        "private identifyBlocks(boolean makeEditable)",
                        "public static addDeferredExit(DeferredExit[] deferredExits, HIRBlock b)",
                        "private calculateLocalLoopFrequency(LoopBeginNode lb)",
                        "private finishLocalLoopFrequency(LoopBeginNode lb)",
                        "private identifyBlock(HIRBlock block)",
                        "private computeFrequencies()",
                        "private resetBlockFrequencies()"
                    ],
                    "llm_response_time": 6687
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "private computeFrequencies()",
                        "private notWeakerThan(boolean computeDominators, boolean loopInfoComputed, ControlFlowGraph cfg)",
                        "public blockFor(Node node)"
                    ],
                    "llm_response_time": 4335
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private notWeakerThan(boolean computeDominators, boolean loopInfoComputed, ControlFlowGraph cfg)"
                    ],
                    "llm_response_time": 3327
                },
                "voyage": {
                    "priority_method_names": [
                        "private identifyBlocks(boolean makeEditable)",
                        "private identifyBlock(HIRBlock block)",
                        "@SuppressWarnings(\"unchecked\")\n    public visitDominatorTreeDefault(RecursiveVisitor<V> visitor)",
                        "@SuppressWarnings({\"unchecked\"})\n    public visitDominatorTreeDeferLoopExits(RecursiveVisitor<V> visitor)",
                        "private resetBlockFrequencies()",
                        "public static isDominatorTreeLoopExit(HIRBlock b, boolean considerRealExits)",
                        "public static addDeferredExit(DeferredExit[] deferredExits, HIRBlock b)",
                        "private notWeakerThan(boolean computeDominators, boolean loopInfoComputed, ControlFlowGraph cfg)",
                        "private static computeLoopBlocks(HIRBlock start, Loop<HIRBlock> loop, HIRBlock[] stack, boolean usePred)",
                        "public blockFor(Node node)",
                        "private static commonDominatorRaw(HIRBlock a, HIRBlock b)",
                        "private static printDomTree(HIRBlock cur, String indent)",
                        "private static skipPostDom(HIRBlock block)"
                    ],
                    "llm_response_time": 3463
                },
                "voyage-5": {
                    "priority_method_names": [],
                    "llm_response_time": 3898
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private static skipPostDom(HIRBlock block)",
                        "public blockFor(Node node)"
                    ],
                    "llm_response_time": 4474
                }
            },
            "targetClassMap": {
                "notWeakerThan": {
                    "target_classes": [
                        {
                            "class_name": "BuildConfig",
                            "similarity_score": 0.5281434769396315
                        },
                        {
                            "class_name": "MemUseTrackerKey",
                            "similarity_score": 0.08342797655898931
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BuildConfig",
                        "MemUseTrackerKey"
                    ],
                    "llm_response_time": 2342,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "loopFullyProcessed": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3416,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "allEndsVisited": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2679,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "blockFor": {
                    "target_classes": [
                        {
                            "class_name": "MemUseTrackerKey",
                            "similarity_score": 0.1507556722888818
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "MemUseTrackerKey"
                    ],
                    "llm_response_time": 1767,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "computeFrequencies": {
                    "target_classes": [
                        {
                            "class_name": "BuildConfig",
                            "similarity_score": 0.15355164847022396
                        },
                        {
                            "class_name": "MemUseTrackerKey",
                            "similarity_score": 0.6391828296725158
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BuildConfig",
                        "MemUseTrackerKey"
                    ],
                    "llm_response_time": 2568,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "skipPostDom": {
                    "target_classes": [
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.5155242909234052
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.5357441253154591
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.5146041138542006
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.24167282940239235
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.38106706953708663
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.20200005523616324
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.3649240279167723
                        },
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.2960121959537151
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.5066046616377116
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.19772684983891423
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.3221121704880595
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.38474771354786247
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.46744564028813956
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.36562691266157965
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.3653970256803164
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.4581024256481616
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.3478075090155132
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.5158134509023098
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.40019969593002
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.41369160100338115
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.42022291892197117
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.5294484060018881
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.29087812087051923
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.3677068926367432
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.4775582359114631
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.3090977212369663
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.29106846305425754
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.44900101186648056
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.26295512165214413
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.5253664868283217
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.41876284319478446
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.389482324453319
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.33239215498424596
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.39557740264262
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.4267653082711477
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.4255444695773583
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.47236777317182965
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.41299552315279336
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.4689766702080085
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.4228491300986216
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.46525042788159493
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.4714884528705344
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.5112978216843828
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.3400230627682166
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.3262207015786648
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.5457440841661912
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.271386335853092
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.4937200262492047
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.32105800691887537
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.4998398299243962
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.4255357676568044
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.48388016469212713
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.4639675351080828
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.45284720116249816
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.38503946086793817
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.2627927933169423
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.4201940315752688
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.4066136663535858
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.3458896767067982
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.4821194450465936
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.36725474509854344
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.4023398993836124
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.4937396093522556
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.3765598704469496
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.3734080224074693
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.3337082989881422
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.31622776601683794
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.34846602621858475
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.36666666666666664
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.4840148912929297
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.5201657916520549
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.2782238481873478
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.26723979879122584
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.4320403326327437
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.45752291431728564
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.24489169769281907
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.2956049366879345
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.21114460292333603
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.5086938251105255
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.5503953220024497
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.3966281376000721
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.3875289504790439
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.37267799624996495
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.17740004829626463
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.4465164577487581
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.14085904245475275
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.4452495790585651
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.32220111626441317
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.24072846024282468
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.45566118843288356
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.371249277864033
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.4560502925159229
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.36620480644702175
                        },
                        {
                            "class_name": "ReversePostOrder",
                            "similarity_score": 0.3571214810256428
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.3835632600263446
                        },
                        {
                            "class_name": "StackElement",
                            "similarity_score": 0.36099743619057767
                        },
                        {
                            "class_name": "InvalidMacroException",
                            "similarity_score": 0.31980107453341566
                        },
                        {
                            "class_name": "ExitException",
                            "similarity_score": 0.3191423692521127
                        },
                        {
                            "class_name": "AtomicBoolean",
                            "similarity_score": 0.35393643879943626
                        },
                        {
                            "class_name": "AtomicInteger",
                            "similarity_score": 0.3158410289299912
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "InteropUtils",
                        "ConstantFoldUtil",
                        "NativeImageResourceFileSystemUtil"
                    ],
                    "llm_response_time": 4138,
                    "similarity_computation_time": 34,
                    "similarity_metric": "cosine"
                },
                "printDomTree": {
                    "target_classes": [
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.44422044408307887
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.3223629753131259
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.34274131236883804
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.3964317198154728
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.36429357376538263
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.20042848048159143
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.26550218930577685
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.29774995472636945
                        },
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.2858722427721523
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.40259165357181925
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.3189146025394619
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.3814465974057265
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.37643176942082945
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.16932096418124498
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.3521626521761314
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.14538147604363605
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.39330779436538155
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.20533816427970852
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.3256185573300481
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.38523472987446145
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.2551563311439096
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.2944768643381002
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.35357884918695753
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.44657187882517263
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.23268825492918171
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.45771821047576056
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.22410159903373797
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.3273704876626916
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.2513836813221147
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.43307775861326503
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.2076817156661948
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.3931994451599934
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.242911941205294
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.3634077838892617
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.4071123162613124
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.4623363934533625
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.35719575602125997
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.4346187010502081
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.2814326349826046
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.3469411766768386
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.3063983092241644
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.42787716071971094
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.44212004731840227
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.2998656375995913
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.341666727194366
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.3570111829228918
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.3576599301078414
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.3368264237831139
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.35751443281487766
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.22797791627299085
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.3698838623090771
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.43677732135949526
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.3699305099410977
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.4542481494739414
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.38987105777638104
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.42437890059988
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.42530691518982555
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.4065670324618239
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.5127506643963614
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.3532987974943735
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.44452008102203316
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.385366152853779
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.32637668288410976
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.2477520417046002
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.31804264478427524
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.2653955210788148
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.298860935000391
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.3209924032060348
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.25148706181010205
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.41554345509308743
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.3475605261357093
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.16718346377260584
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.35386186803414216
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.46425662883461194
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.4193339702352674
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.3843345502499299
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.2301265302035757
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.19716663081491595
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.4650174384809207
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.4153040338414985
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.3448281541042982
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.3296902366978935
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.16199455554074874
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.40345127011913023
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.2850357771438991
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.3508009070389559
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.307124923275015
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.10088823912213014
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.362093929922078
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.23232092779870986
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.2864844293375908
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.4496417540198411
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.32996304620812117
                        },
                        {
                            "class_name": "UnsafeMemoryUtil",
                            "similarity_score": 0.3166297428852128
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.2769584082967294
                        },
                        {
                            "class_name": "StackElement",
                            "similarity_score": 0.3193570089530485
                        },
                        {
                            "class_name": "ReversePostOrder",
                            "similarity_score": 0.2950211293197377
                        },
                        {
                            "class_name": "ExitException",
                            "similarity_score": 0.3336625515205745
                        },
                        {
                            "class_name": "AtomicBoolean",
                            "similarity_score": 0.4368983516463091
                        },
                        {
                            "class_name": "AtomicInteger",
                            "similarity_score": 0.38783681014615906
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "FileUtils",
                        "Target_java_util_regex_Pattern",
                        "Target_java_util_regex_Matcher"
                    ],
                    "llm_response_time": 3966,
                    "similarity_computation_time": 26,
                    "similarity_metric": "cosine"
                },
                "resetBlockFrequencies": {
                    "target_classes": [
                        {
                            "class_name": "BuildConfig",
                            "similarity_score": 0.1972113550143831
                        },
                        {
                            "class_name": "MemUseTrackerKey",
                            "similarity_score": 0.1809806914982567
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BuildConfig",
                        "MemUseTrackerKey"
                    ],
                    "llm_response_time": 2617,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "identifyBlocks": {
                    "target_classes": [
                        {
                            "class_name": "BuildConfig",
                            "similarity_score": 0.2299405276276553
                        },
                        {
                            "class_name": "MemUseTrackerKey",
                            "similarity_score": 0.15315693761503704
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BuildConfig",
                        "MemUseTrackerKey"
                    ],
                    "llm_response_time": 1723,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "addDeferredExit": {
                    "target_classes": [
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.24867896096521908
                        },
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.4728742564711641
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.29783741203978065
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.39162398816009103
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.44354244316934716
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.37179043621465924
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.25552078288922553
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.4213749140395263
                        },
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.3552146351444581
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.4752010100999365
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.5060835400166295
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.4676674793986949
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.1957484066144552
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.19430495483952342
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.3196083529645188
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.275523056707214
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.3619915262101211
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.3782539724202234
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.35464447783460973
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.29521222716438683
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.2685980945910752
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.43932980041990016
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.3045435760726645
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.4735938446006973
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.33119247348018127
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.2833034752485343
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.23151266802010112
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.29604462320866853
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.2824646951940774
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.38256232359044146
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.19415368184485465
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.37115374447904514
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.21677749238103
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.3895198672702742
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.3377622437948524
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.34847094295087877
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.4374352037983727
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.33653889369030165
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.4317416612616456
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.3120857859471409
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.393943848835249
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.24557634905750386
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.4364645523785737
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.2999494140456736
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.4160856555173138
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.44878033099608877
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.38524754757573415
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.37495173590188063
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.27915025672895694
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.35583808894348246
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.46797928190779015
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.5057168903013101
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.2796177442102841
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.38367994752106505
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.4512750654122684
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.29381681504298734
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.2030406121840614
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.22
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.33957029952440787
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.350269438069157
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.3806987087570892
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.4035556254807296
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.3753225470733015
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.34160672811751924
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.41346006744674685
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.3781905497725309
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.27381413850285735
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.5109189129335695
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.3636619309193636
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.4243086319249827
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.3650618101412603
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.2551260192812284
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.431589413808014
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.47040868510875244
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.348706653614796
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.48813508588193655
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.2908752577009276
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.2780070605157258
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.41712893659063094
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.33995005182504245
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.25849213105659874
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.33140686244339645
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.30281331944409007
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.10644002897775877
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.40591199488931323
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.33488734331156855
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.3055959569249712
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.24509473387126982
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.3189628319030185
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.2363515791475006
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.3649814329130818
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.4219335530758004
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.23599865304363624
                        },
                        {
                            "class_name": "UnsafeMemoryUtil",
                            "similarity_score": 0.27791013395195124
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.2898494256847728
                        },
                        {
                            "class_name": "StackElement",
                            "similarity_score": 0.309426373877638
                        },
                        {
                            "class_name": "ReversePostOrder",
                            "similarity_score": 0.36867541129411946
                        },
                        {
                            "class_name": "ExitException",
                            "similarity_score": 0.2959320151246863
                        },
                        {
                            "class_name": "InvalidMacroException",
                            "similarity_score": 0.23452078799117146
                        },
                        {
                            "class_name": "AtomicBoolean",
                            "similarity_score": 0.4543556144588112
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "InliningUtil",
                        "BundleSerializationUtils",
                        "String"
                    ],
                    "llm_response_time": 4372,
                    "similarity_computation_time": 45,
                    "similarity_metric": "cosine"
                },
                "commonDominatorRaw": {
                    "target_classes": [
                        {
                            "class_name": "LoggingCFGDecorator",
                            "similarity_score": 0.45942314310824295
                        },
                        {
                            "class_name": "RPOLoopVerification",
                            "similarity_score": 0.4427270711489536
                        },
                        {
                            "class_name": "BuildConfig",
                            "similarity_score": 0.20845242077071663
                        },
                        {
                            "class_name": "DeferredExit",
                            "similarity_score": 0.3752393871932282
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "LoggingCFGDecorator",
                        "RPOLoopVerification",
                        "DeferredExit"
                    ],
                    "llm_response_time": 3251,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "isDominatorTreeLoopExit": {
                    "target_classes": [
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.6760988638000704
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.6872402929847751
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.6598824895412287
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.4961922808941729
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.35884386112819644
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.5356843705043363
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.4704128412189329
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.4831182636361311
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.41498579205189096
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.5671893032102436
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.48706466786466673
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.7057305136678
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.5926549917371302
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.5104990014057544
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.5029928404142274
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.23619656113864917
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.4316197723395945
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.27359242952554846
                        },
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.3577004221903404
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.6921641651195225
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.6249873547849412
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.38010712444051736
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.21351985493051465
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.6038796090503157
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.3341957878105008
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.5746818041577118
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.36276955948093026
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.5303332773505147
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.3182938145380093
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.7016780764531569
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.3914282674832274
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.4750208571524907
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.4319933228311349
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.5128498623119716
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.47814550024634495
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.4190009519712443
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.5584967515720785
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.6507904374257738
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.6140823411795029
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.6200266889375754
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.5997321125882941
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.4041397800589649
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.5986209579354846
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.43328649047264695
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.4527096457478694
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.46639906720279845
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.5710508366641941
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.5260717041977649
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.5405821986176016
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.5123852958665691
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.5051004824223428
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.5892123444410498
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.6430750874042238
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.5365863102527421
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.35849435619080383
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.6701836538633472
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.42943321132138507
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.45262514388672725
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.6545637474097746
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.5557612560932679
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.5436281376670059
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.44542003382912243
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.5197873813655159
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.38743696329836763
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.5958043703832022
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.386458056672356
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.48717074536697924
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.3586370014508247
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.460630169398467
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.6736795557505845
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.3238519115868974
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.6454045130312701
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.3737755990364073
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.5631670145593775
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.5609961638668108
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.3721545754373558
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.3338957499759107
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.255519649265603
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.6795102302860404
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.6398677264115199
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.4697161901456929
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.5056484940159757
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.5243998846320381
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.1970895780239282
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.43911321451194946
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.4757404028896287
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.5732295883054659
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.20147536618614256
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.644880104344725
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.27836908092500673
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.4988037464285879
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.5778807095563255
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.4097416695087593
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.5709649070017873
                        },
                        {
                            "class_name": "AtomicBoolean",
                            "similarity_score": 0.5077907700570296
                        },
                        {
                            "class_name": "AtomicInteger",
                            "similarity_score": 0.44072463312956656
                        },
                        {
                            "class_name": "AtomicLong",
                            "similarity_score": 0.4291787254896737
                        },
                        {
                            "class_name": "AtomicPointer",
                            "similarity_score": 0.46980407791709455
                        },
                        {
                            "class_name": "CEntryPointUtilityNode",
                            "similarity_score": 0.5520530330888002
                        },
                        {
                            "class_name": "AtomicReference",
                            "similarity_score": 0.48452328796017985
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ConditionalEliminationUtil",
                        "LIRValueUtil",
                        "VirtualUtil"
                    ],
                    "llm_response_time": 3913,
                    "similarity_computation_time": 109,
                    "similarity_metric": "cosine"
                },
                "calculateLocalLoopFrequency": {
                    "target_classes": [
                        {
                            "class_name": "BuildConfig",
                            "similarity_score": 0.1854878330241646
                        },
                        {
                            "class_name": "MemUseTrackerKey",
                            "similarity_score": 0.25142487937454044
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BuildConfig",
                        "MemUseTrackerKey"
                    ],
                    "llm_response_time": 3183,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "identifyBlock": {
                    "target_classes": [
                        {
                            "class_name": "BuildConfig",
                            "similarity_score": 0.21812979003736452
                        },
                        {
                            "class_name": "MemUseTrackerKey",
                            "similarity_score": 0.2014944787705732
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BuildConfig",
                        "MemUseTrackerKey"
                    ],
                    "llm_response_time": 2383,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "finishLocalLoopFrequency": {
                    "target_classes": [
                        {
                            "class_name": "BuildConfig",
                            "similarity_score": 0.23311064250621213
                        },
                        {
                            "class_name": "MemUseTrackerKey",
                            "similarity_score": 0.4631687524597616
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BuildConfig",
                        "MemUseTrackerKey"
                    ],
                    "llm_response_time": 2057,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "06e830443f638e80588387e122a92351b1e11675",
        "url": "https://github.com/oracle/graal/commit/06e830443f638e80588387e122a92351b1e11675",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method package endRecording() : void extracted from public endRecording() : void in class com.oracle.svm.core.jfr.SubstrateJVM & moved to class com.oracle.svm.core.jfr.JfrRecorderThread",
            "leftSideLocations": [
                {
                    "filePath": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jfr/SubstrateJVM.java",
                    "startLine": 345,
                    "endLine": 355,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "public endRecording() : void"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jfr/SubstrateJVM.java",
                    "startLine": 354,
                    "endLine": 354,
                    "startColumn": 9,
                    "endColumn": 24,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jfr/SubstrateJVM.java",
                    "startLine": 353,
                    "endLine": 353,
                    "startColumn": 9,
                    "endColumn": 72,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jfr/JfrRecorderThread.java",
                    "startLine": 113,
                    "endLine": 121,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "package endRecording() : void"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jfr/JfrRecorderThread.java",
                    "startLine": 117,
                    "endLine": 117,
                    "startColumn": 13,
                    "endColumn": 28,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jfr/JfrRecorderThread.java",
                    "startLine": 116,
                    "endLine": 116,
                    "startColumn": 13,
                    "endColumn": 102,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jfr/SubstrateJVM.java",
                    "startLine": 345,
                    "endLine": 354,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "public endRecording() : void"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jfr/SubstrateJVM.java",
                    "startLine": 353,
                    "endLine": 353,
                    "startColumn": 9,
                    "endColumn": 38,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "recorderThread.endRecording()"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jfr/JfrRecorderThread.java",
                    "startLine": 114,
                    "endLine": 114,
                    "startColumn": 9,
                    "endColumn": 21,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jfr/JfrRecorderThread.java",
                    "startLine": 119,
                    "endLine": 119,
                    "startColumn": 13,
                    "endColumn": 27,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jfr/JfrRecorderThread.java",
                    "startLine": 115,
                    "endLine": 120,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "TRY_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jfr/JfrRecorderThread.java",
                    "startLine": 118,
                    "endLine": 120,
                    "startColumn": 19,
                    "endColumn": 10,
                    "codeElementType": "FINALLY_BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                }
            ],
            "isStatic": false
        },
        "ref_id": 491,
        "extraction_results": {
            "success": true,
            "newCommitHash": "39102b1cc735d9432bdadb318dd4378f877ca443",
            "newBranchName": "extract-endRecording-endRecording-fc7078a"
        },
        "telemetry": {
            "id": "06c771e4-e7e0-41ff-9d9b-b205597a864b",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 768,
                "lineStart": 62,
                "lineEnd": 829,
                "bodyLineStart": 62,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jfr/SubstrateJVM.java",
                "sourceCode": "/**\n * Manager class that handles most JFR Java API, see {@link Target_jdk_jfr_internal_JVM}.\n * <p>\n * Here is the execution order of relevant API methods:\n * <ul>\n * <li>{@link #createJFR} - initialize the JFR infrastructure but don't record any events yet.</li>\n * <li>{@link #setOutput} - set the path of the file where the JFR data should be written to.</li>\n * <li>{@link #beginRecording} - start recording JFR events.</li>\n * <li>{@link #setOutput} - either switch to a new file or close the current file.</li>\n * <li>{@link #endRecording()} - end recording JFR events.</li>\n * <li>{@link #destroyJFR()} - destroy the JFR infrastructure and free data.</li>\n * </ul>\n */\npublic class SubstrateJVM {\n    private final List<Configuration> knownConfigurations;\n    private final JfrOptionSet options;\n    private final JfrNativeEventSetting[] eventSettings;\n\n    private final JfrSymbolRepository symbolRepo;\n    private final JfrTypeRepository typeRepo;\n    private final JfrThreadRepository threadRepo;\n    private final JfrStackTraceRepository stackTraceRepo;\n    private final JfrMethodRepository methodRepo;\n    private final JfrOldObjectRepository oldObjectRepo;\n\n    private final JfrThreadLocal threadLocal;\n    private final JfrGlobalMemory globalMemory;\n    private final SamplerBufferPool samplerBufferPool;\n    private final JfrUnlockedChunkWriter unlockedChunkWriter;\n    private final JfrRecorderThread recorderThread;\n    private final JfrOldObjectProfiler oldObjectProfiler;\n\n    private final JfrLogging jfrLogging;\n    private final JfrEventThrottling eventThrottler;\n\n    private boolean initialized;\n    /*\n     * We need this separate field for all JDK versions, i.e., even for versions where the field\n     * JVM.recording is present (JVM.recording is not set for all the cases that we are interested\n     * in).\n     */\n    private volatile boolean recording;\n    public boolean getRecording(){\n        return recording;\n    }\n    private String dumpPath;\n\n    @Platforms(Platform.HOSTED_ONLY.class)\n    public SubstrateJVM(List<Configuration> configurations, boolean writeFile) {\n        this.knownConfigurations = configurations;\n\n        options = new JfrOptionSet();\n\n        int eventCount = JfrMetadataTypeLibrary.getPlatformEventCount();\n        eventSettings = new JfrNativeEventSetting[eventCount];\n        for (int i = 0; i < eventSettings.length; i++) {\n            eventSettings[i] = new JfrNativeEventSetting();\n        }\n\n        symbolRepo = new JfrSymbolRepository();\n        typeRepo = new JfrTypeRepository();\n        threadRepo = new JfrThreadRepository();\n        stackTraceRepo = new JfrStackTraceRepository();\n        methodRepo = new JfrMethodRepository();\n        oldObjectRepo = new JfrOldObjectRepository();\n\n        threadLocal = new JfrThreadLocal();\n        globalMemory = new JfrGlobalMemory();\n        samplerBufferPool = new SamplerBufferPool();\n        unlockedChunkWriter = writeFile ? new JfrChunkFileWriter(globalMemory, stackTraceRepo, methodRepo, typeRepo, symbolRepo, threadRepo, oldObjectRepo) : new JfrChunkNoWriter();\n        recorderThread = new JfrRecorderThread(globalMemory, unlockedChunkWriter);\n        oldObjectProfiler = new JfrOldObjectProfiler();\n\n        jfrLogging = new JfrLogging();\n        eventThrottler = new JfrEventThrottling();\n\n        initialized = false;\n        recording = false;\n    }\n\n    @Fold\n    public static SubstrateJVM get() {\n        return ImageSingletons.lookup(SubstrateJVM.class);\n    }\n\n    @Fold\n    public static List<Configuration> getKnownConfigurations() {\n        return get().knownConfigurations;\n    }\n\n    @Fold\n    public static JfrGlobalMemory getGlobalMemory() {\n        return get().globalMemory;\n    }\n\n    @Fold\n    public static JfrRecorderThread getRecorderThread() {\n        return get().recorderThread;\n    }\n\n    @Fold\n    public static JfrThreadLocal getThreadLocal() {\n        return get().threadLocal;\n    }\n\n    @Fold\n    public static SamplerBufferPool getSamplerBufferPool() {\n        return get().samplerBufferPool;\n    }\n\n    @Fold\n    public static JfrUnlockedChunkWriter getChunkWriter() {\n        return get().unlockedChunkWriter;\n    }\n\n    @Fold\n    public static JfrTypeRepository getTypeRepository() {\n        return get().typeRepo;\n    }\n\n    @Fold\n    public static JfrSymbolRepository getSymbolRepository() {\n        return get().symbolRepo;\n    }\n\n    @Fold\n    public static JfrThreadRepository getThreadRepo() {\n        return get().threadRepo;\n    }\n\n    @Fold\n    public static JfrMethodRepository getMethodRepo() {\n        return get().methodRepo;\n    }\n\n    @Fold\n    public static JfrStackTraceRepository getStackTraceRepo() {\n        return get().stackTraceRepo;\n    }\n\n    @Fold\n    public static JfrLogging getLogging() {\n        return get().jfrLogging;\n    }\n\n    @Fold\n    public static JfrOldObjectProfiler getOldObjectProfiler() {\n        return get().oldObjectProfiler;\n    }\n\n    @Fold\n    public static JfrOldObjectRepository getOldObjectRepository() {\n        return get().oldObjectRepo;\n    }\n\n    @Fold\n    public static JfrEventThrottling getEventThrottling() {\n        return get().eventThrottler;\n    }\n\n    @Uninterruptible(reason = \"Prevent races with VM operations that start/stop recording.\", callerMustBe = true)\n    protected boolean isRecording() {\n        return recording;\n    }\n\n    /**\n     * See {@link JVM#createJFR}. Until {@link #beginRecording} is executed, no JFR events can be\n     * triggered yet. So, we don't need to take any precautions here.\n     */\n    public boolean createJFR(boolean simulateFailure) {\n        if (simulateFailure) {\n            throw new IllegalStateException(\"Unable to start JFR\");\n        } else if (initialized) {\n            throw new IllegalStateException(\"JFR was already started before\");\n        }\n\n        options.validateAndAdjustMemoryOptions();\n\n        JfrTicks.initialize();\n        threadLocal.initialize(options.threadBufferSize.getValue());\n        globalMemory.initialize(options.globalBufferSize.getValue(), options.globalBufferCount.getValue());\n        unlockedChunkWriter.initialize(options.maxChunkSize.getValue());\n        stackTraceRepo.setStackTraceDepth(NumUtil.safeToInt(options.stackDepth.getValue()));\n\n        recorderThread.start();\n\n        initialized = true;\n        return true;\n    }\n\n    /**\n     * See {@link JVM#destroyJFR}. This method is only called after the recording was already\n     * stopped. As no JFR events can be triggered by the current or any other thread, we don't need\n     * to take any precautions here.\n     */\n    public boolean destroyJFR() {\n        assert !recording : \"must already have been stopped\";\n        if (!initialized) {\n            return false;\n        }\n\n        recorderThread.shutdown();\n\n        JfrTeardownOperation vmOp = new JfrTeardownOperation();\n        vmOp.enqueue();\n\n        return true;\n    }\n\n    @Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public long getStackTraceId(long eventTypeId, int skipCount) {\n        if (isStackTraceEnabled(eventTypeId)) {\n            return getStackTraceId(skipCount);\n        } else {\n            return 0L;\n        }\n    }\n\n    /**\n     * See {@link JVM#getStackTraceId}.\n     */\n    @Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public long getStackTraceId(int skipCount) {\n        if (isRecording()) {\n            return stackTraceRepo.getStackTraceId(skipCount);\n        }\n        return 0L;\n    }\n\n    @Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public long getStackTraceId(JfrEvent eventType, int skipCount) {\n        return getStackTraceId(eventType.getId(), skipCount);\n    }\n\n    /**\n     * See {@link JVM#getThreadId}.\n     */\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public static long getThreadId(Thread thread) {\n        if (HasJfrSupport.get()) {\n            return JavaThreads.getThreadId(thread);\n        }\n        return 0;\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public static long getCurrentThreadId() {\n        if (HasJfrSupport.get()) {\n            return JavaThreads.getCurrentThreadId();\n        }\n        return 0;\n    }\n\n    /**\n     * See {@link JVM#storeMetadataDescriptor}.\n     */\n    public void storeMetadataDescriptor(byte[] bytes) {\n        JfrChunkWriter chunkWriter = unlockedChunkWriter.lock();\n        try {\n            chunkWriter.setMetadata(bytes);\n        } finally {\n            chunkWriter.unlock();\n        }\n    }\n\n    /**\n     * See {@link JVM#beginRecording}.\n     */\n    public void beginRecording() {\n        if (recording) {\n            return;\n        }\n\n        JfrChunkWriter chunkWriter = unlockedChunkWriter.lock();\n        try {\n            // It is possible that setOutput was called with a filename earlier. In that case, we\n            // need to start recording to the specified file right away.\n            chunkWriter.maybeOpenFile();\n        } finally {\n            chunkWriter.unlock();\n        }\n\n        JfrBeginRecordingOperation vmOp = new JfrBeginRecordingOperation();\n        vmOp.enqueue();\n    }\n\n    /**\n     * See {@link JVM#endRecording}.\n     */\n    public void endRecording() {\n        if (!getRecording()) {\n            return;\n        }\n\n        JfrEndRecordingOperation vmOp = new JfrEndRecordingOperation();\n        vmOp.enqueue();\n    }\n\n    /**\n     * See {@link JVM#getClassId}.\n     */\n    @Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public long getClassId(Class<?> clazz) {\n        if (isRecording()) {\n            return typeRepo.getClassId(clazz);\n        }\n        return 0L;\n    }\n\n    /**\n     * See {@link JVM#setOutput}. The JFR infrastructure also calls this method when it is time to\n     * rotate the file.\n     */\n    public void setOutput(String file) {\n        JfrChunkWriter chunkWriter = unlockedChunkWriter.lock();\n        try {\n            if (recording) {\n                boolean existingFile = chunkWriter.hasOpenFile();\n                if (existingFile) {\n                    chunkWriter.closeFile();\n                }\n                if (file != null) {\n                    chunkWriter.openFile(file);\n                    // If in-memory recording was active so far, we should notify the recorder\n                    // thread because the global memory buffers could be rather full.\n                    if (!existingFile) {\n                        recorderThread.signal();\n                    }\n                }\n            } else {\n                chunkWriter.setFilename(file);\n            }\n        } finally {\n            chunkWriter.unlock();\n        }\n    }\n\n    /**\n     * See {@link JVM#setFileNotification}.\n     */\n    public void setFileNotification(long delta) {\n        options.maxChunkSize.setUserValue(delta);\n    }\n\n    /**\n     * See {@link JVM#setGlobalBufferCount}.\n     */\n    public void setGlobalBufferCount(long count) {\n        options.globalBufferCount.setUserValue(count);\n    }\n\n    /**\n     * See {@link JVM#setGlobalBufferSize}.\n     */\n    public void setGlobalBufferSize(long size) {\n        options.globalBufferSize.setUserValue(size);\n    }\n\n    /**\n     * See {@link JVM#setMemorySize}.\n     */\n    public void setMemorySize(long size) {\n        options.memorySize.setUserValue(size);\n    }\n\n    /**\n     * See {@code JVM#setMethodSamplingInterval}.\n     */\n    public void setMethodSamplingInterval(long type, long intervalMillis) {\n        if (type != JfrEvent.ExecutionSample.getId()) {\n            // JFR is currently only supporting ExecutionSample event, but this method is called\n            // during JFR startup, so we can't throw an error.\n            return;\n        }\n\n        JfrExecutionSampler.singleton().setIntervalMillis(intervalMillis);\n\n        if (intervalMillis > 0) {\n            setStackTraceEnabled(type, true);\n            setEnabled(type, true);\n        }\n\n        updateSampler();\n    }\n\n    @Uninterruptible(reason = \"Prevent races with VM operations that start/stop recording.\")\n    private void updateSampler() {\n        if (recording) {\n            updateSampler0();\n        }\n    }\n\n    @Uninterruptible(reason = \"The executed VM operation rechecks if JFR recording is active.\", calleeMustBe = false)\n    private static void updateSampler0() {\n        JfrExecutionSampler.singleton().update();\n    }\n\n    /**\n     * See {@code JVM#setSampleThreads}.\n     */\n    public void setSampleThreads(boolean sampleThreads) {\n        setEnabled(JfrEvent.ExecutionSample.getId(), sampleThreads);\n        setEnabled(JfrEvent.NativeMethodSample.getId(), sampleThreads);\n    }\n\n    /**\n     * See {@link JVM#setCompressedIntegers}.\n     */\n    public void setCompressedIntegers(boolean compressed) {\n        if (!compressed) {\n            throw new IllegalStateException(\"JFR currently only supports compressed integers.\");\n        }\n    }\n\n    /**\n     * See {@link JVM#setStackDepth}.\n     */\n    public void setStackDepth(int depth) {\n        options.stackDepth.setUserValue(depth);\n    }\n\n    /**\n     * See {@link JVM#setStackTraceEnabled}.\n     */\n    public void setStackTraceEnabled(long eventTypeId, boolean enabled) {\n        eventSettings[NumUtil.safeToInt(eventTypeId)].setStackTrace(enabled);\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public boolean isStackTraceEnabled(long eventTypeId) {\n        assert (int) eventTypeId == eventTypeId;\n        return eventSettings[(int) eventTypeId].hasStackTrace();\n    }\n\n    /**\n     * See {@link JVM#setThreadBufferSize}.\n     */\n    public void setThreadBufferSize(long size) {\n        options.threadBufferSize.setUserValue(size);\n    }\n\n    /**\n     * See {@link JVM#flush}.\n     */\n    @Uninterruptible(reason = \"Accesses a JFR buffer.\")\n    public boolean flush(Target_jdk_jfr_internal_event_EventWriter writer, int uncommittedSize, int requestedSize) {\n        assert writer != null;\n        assert uncommittedSize >= 0;\n\n        JfrBuffer oldBuffer = threadLocal.getJavaBuffer();\n        assert oldBuffer.isNonNull() : \"Java EventWriter should not be used otherwise\";\n        JfrBuffer newBuffer = JfrThreadLocal.flushToGlobalMemory(oldBuffer, WordFactory.unsigned(uncommittedSize), requestedSize);\n        if (newBuffer.isNull()) {\n            /* The flush failed, so mark the EventWriter as invalid for this write attempt. */\n            JfrEventWriterAccess.update(writer, oldBuffer, 0, false);\n        } else {\n            JfrEventWriterAccess.update(writer, newBuffer, uncommittedSize, true);\n        }\n\n        /*\n         * Return false to signal that there is no need to do another flush at the end of the\n         * current event.\n         */\n        return false;\n    }\n\n    public void flush() {\n        JfrChunkWriter chunkWriter = unlockedChunkWriter.lock();\n        try {\n            if (recording) {\n                boolean existingFile = chunkWriter.hasOpenFile();\n                if (existingFile) {\n                    chunkWriter.flush();\n                }\n            }\n        } finally {\n            chunkWriter.unlock();\n        }\n    }\n\n    @Uninterruptible(reason = \"Accesses a native JFR buffer.\")\n    public long commit(long nextPosition) {\n        assert nextPosition != 0 : \"invariant\";\n\n        JfrBuffer current = threadLocal.getExistingJavaBuffer();\n        if (current.isNull()) {\n            /* This is a commit for a recording session that is no longer active - ignore it. */\n            return nextPosition;\n        }\n\n        Pointer next = WordFactory.pointer(nextPosition);\n        assert next.aboveOrEqual(current.getCommittedPos()) : \"invariant\";\n        assert next.belowOrEqual(JfrBufferAccess.getDataEnd(current)) : \"invariant\";\n        if (JfrThreadLocal.isNotified()) {\n            JfrThreadLocal.clearNotification();\n            return current.getCommittedPos().rawValue();\n        }\n        current.setCommittedPos(next);\n        return nextPosition;\n    }\n\n    public void markChunkFinal() {\n        JfrChunkWriter chunkWriter = unlockedChunkWriter.lock();\n        try {\n            if (recording) {\n                boolean existingFile = chunkWriter.hasOpenFile();\n                if (existingFile) {\n                    chunkWriter.markChunkFinal();\n                }\n            }\n        } finally {\n            chunkWriter.unlock();\n        }\n    }\n\n    /**\n     * See {@link JVM#setRepositoryLocation}.\n     */\n    public void setRepositoryLocation(@SuppressWarnings(\"unused\") String dirText) {\n        // Would only be used in case of an emergency dump, which is not supported at the moment.\n    }\n\n    /**\n     * See {@code JfrEmergencyDump::set_dump_path}.\n     */\n    public void setDumpPath(String dumpPathText) {\n        dumpPath = dumpPathText;\n    }\n\n    /**\n     * See {@code JVM#getDumpPath()}.\n     */\n    public String getDumpPath() {\n        if (dumpPath == null) {\n            dumpPath = Target_jdk_jfr_internal_SecuritySupport.getPathInProperty(\"user.home\", null).toString();\n        }\n        return dumpPath;\n    }\n\n    /**\n     * See {@link JVM#abort}.\n     */\n    public void abort(String errorMsg) {\n        throw VMError.shouldNotReachHere(errorMsg);\n    }\n\n    /**\n     * See {@link JVM#shouldRotateDisk}.\n     */\n    public boolean shouldRotateDisk() {\n        JfrChunkWriter chunkWriter = unlockedChunkWriter.lock();\n        try {\n            return chunkWriter.shouldRotateDisk();\n        } finally {\n            chunkWriter.unlock();\n        }\n    }\n\n    /**\n     * See {@link JVM#emitOldObjectSamples(long, boolean, boolean)}.\n     */\n    void emitOldObjectSamples(long cutoff, boolean emitAll, boolean skipBFS) {\n        oldObjectProfiler.emit(cutoff, emitAll, skipBFS);\n    }\n\n    public long getChunkStartNanos() {\n        JfrChunkWriter chunkWriter = unlockedChunkWriter.lock();\n        try {\n            return chunkWriter.getChunkStartNanos();\n        } finally {\n            chunkWriter.unlock();\n        }\n    }\n\n    /**\n     * See {@link JVM#log}.\n     */\n    public void log(int tagSetId, int level, String message) {\n        jfrLogging.log(tagSetId, level, message);\n    }\n\n    /**\n     * See {@link JVM#logEvent}.\n     */\n    public void logEvent(int level, String[] lines, boolean system) {\n        jfrLogging.logEvent(level, lines, system);\n    }\n\n    /**\n     * See {@link JVM#subscribeLogLevel}.\n     */\n    public void subscribeLogLevel(@SuppressWarnings(\"unused\") LogTag lt, @SuppressWarnings(\"unused\") int tagSetId) {\n        // Currently unused because logging support is minimal.\n    }\n\n    /**\n     * See {@link JVM#getEventWriter}.\n     */\n    public Target_jdk_jfr_internal_event_EventWriter getEventWriter() {\n        return JfrThreadLocal.getEventWriter();\n    }\n\n    /**\n     * See {@link JVM#newEventWriter}.\n     */\n    public Target_jdk_jfr_internal_event_EventWriter newEventWriter() {\n        return threadLocal.newEventWriter();\n    }\n\n    /**\n     * See {@link JVM#setEnabled}.\n     */\n    public void setEnabled(long eventTypeId, boolean newValue) {\n        boolean oldValue = eventSettings[NumUtil.safeToInt(eventTypeId)].isEnabled();\n        if (newValue != oldValue) {\n            eventSettings[NumUtil.safeToInt(eventTypeId)].setEnabled(newValue);\n\n            if (eventTypeId == JfrEvent.ExecutionSample.getId()) {\n                updateSampler();\n            }\n        }\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public boolean isEnabled(JfrEvent event) {\n        return eventSettings[(int) event.getId()].isEnabled();\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public void setLarge(JfrEvent event, boolean large) {\n        eventSettings[(int) event.getId()].setLarge(large);\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public boolean isLarge(JfrEvent event) {\n        return eventSettings[(int) event.getId()].isLarge();\n    }\n\n    /**\n     * See {@link JVM#setThrottle}.\n     */\n    public boolean setThrottle(long eventTypeId, long eventSampleSize, long periodMs) {\n        return eventThrottler.setThrottle(eventTypeId, eventSampleSize, periodMs);\n    }\n\n    /**\n     * See {@link JVM#setThreshold}.\n     */\n    public boolean setThreshold(long eventTypeId, long ticks) {\n        eventSettings[NumUtil.safeToInt(eventTypeId)].setThresholdTicks(ticks);\n        return true;\n    }\n\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    long getThresholdTicks(JfrEvent event) {\n        return eventSettings[(int) event.getId()].getThresholdTicks();\n    }\n\n    /**\n     * See {@link JVM#setCutoff}.\n     */\n    public boolean setCutoff(long eventTypeId, long cutoffTicks) {\n        eventSettings[NumUtil.safeToInt(eventTypeId)].setCutoffTicks(cutoffTicks);\n        return true;\n    }\n\n    public boolean setConfiguration(Class<? extends Event> eventClass, Object configuration) {\n        DynamicHub.fromClass(eventClass).setJrfEventConfiguration(configuration);\n        return true;\n    }\n\n    public Object getConfiguration(Class<? extends Event> eventClass) {\n        return DynamicHub.fromClass(eventClass).getJfrEventConfiguration();\n    }\n\n    private static class JfrBeginRecordingOperation extends JavaVMOperation {\n        JfrBeginRecordingOperation() {\n            super(VMOperationInfos.get(JfrBeginRecordingOperation.class, \"JFR begin recording\", SystemEffect.SAFEPOINT));\n        }\n\n        @Override\n        protected void operate() {\n            SubstrateJVM.getOldObjectProfiler().reset();\n            JfrAllocationEvents.reset();\n\n            SubstrateJVM.get().recording = true;\n            /* Recording is enabled, so JFR events can be triggered at any time. */\n            SubstrateJVM.getThreadRepo().registerRunningThreads();\n\n            JfrExecutionSampler.singleton().update();\n        }\n    }\n\n    public static class JfrEndRecordingOperation extends JavaVMOperation {\n        JfrEndRecordingOperation() {\n            super(VMOperationInfos.get(JfrEndRecordingOperation.class, \"JFR end recording\", SystemEffect.SAFEPOINT));\n        }\n\n        /**\n         * When the safepoint ends, it is guaranteed that all {@link JfrNativeEventWriter}s finished\n         * their job and that no further JFR events will be triggered. It is also guaranteed that no\n         * thread executes any code related to the execution sampling.\n         */\n        @Override\n        protected void operate() {\n            SubstrateJVM.get().recording = false;\n            JfrExecutionSampler.singleton().update();\n\n            if (SubstrateSigprofHandler.Options.JfrBasedExecutionSamplerStatistics.getValue()) {\n                printSamplerStatistics();\n            }\n\n            /* No further JFR events are emitted, so free some JFR-related buffers. */\n            for (IsolateThread isolateThread = VMThreads.firstThread(); isolateThread.isNonNull(); isolateThread = VMThreads.nextThread(isolateThread)) {\n                JfrThreadLocal.stopRecording(isolateThread, false);\n            }\n\n            /* Process any remaining full buffers (if there are any). */\n            SamplerBuffersAccess.processFullBuffers(false);\n\n            /*\n             * If JFR recording is restarted later on, then it needs to start with a clean state.\n             * Therefore, we clear all data that is still pending.\n             */\n            SubstrateJVM.getThreadLocal().teardown();\n            SubstrateJVM.getSamplerBufferPool().teardown();\n            SubstrateJVM.getGlobalMemory().clear();\n            SubstrateJVM.getOldObjectProfiler().teardown();\n        }\n    }\n\n    private static void printSamplerStatistics() {\n        long missedSamples = SamplerStatistics.singleton().getMissedSamples();\n        long unparseableStacks = SamplerStatistics.singleton().getUnparseableSamples();\n        for (IsolateThread isolateThread = VMThreads.firstThread(); isolateThread.isNonNull(); isolateThread = VMThreads.nextThread(isolateThread)) {\n            missedSamples += JfrThreadLocal.getMissedSamples(isolateThread);\n            unparseableStacks += JfrThreadLocal.getUnparseableStacks(isolateThread);\n        }\n\n        Log log = Log.log();\n        log.string(\"JFR sampler statistics\").indent(true);\n        log.string(\"Missed samples: \").unsigned(missedSamples).newline();\n        log.string(\"Unparseable stacks: \").unsigned(unparseableStacks).indent(false);\n    }\n\n    private class JfrTeardownOperation extends JavaVMOperation {\n        JfrTeardownOperation() {\n            super(VMOperationInfos.get(JfrTeardownOperation.class, \"JFR teardown\", SystemEffect.SAFEPOINT));\n        }\n\n        @Override\n        protected void operate() {\n            if (!initialized) {\n                return;\n            }\n\n            globalMemory.teardown();\n            symbolRepo.teardown();\n            threadRepo.teardown();\n            stackTraceRepo.teardown();\n            methodRepo.teardown();\n            typeRepo.teardown();\n            oldObjectRepo.teardown();\n\n            initialized = false;\n        }\n    }\n}",
                "methodCount": 77
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 14,
                "candidates": [
                    {
                        "lineStart": 619,
                        "lineEnd": 624,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method emitOldObjectSamples to class JfrOldObjectProfiler",
                        "description": "Move method emitOldObjectSamples to com.oracle.svm.core.jfr.oldobject.JfrOldObjectProfiler\nRationale: The emitOldObjectSamples() method directly calls oldObjectProfiler.emit() with the same parameters. This indicates that the functionality of emitting old object samples is closely related to having access to internal mechanisms of JfrOldObjectProfiler. Therefore, placing the method in JfrOldObjectProfiler consolidates related operations within the same class, enhancing cohesion and making the code more maintainable.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 290,
                        "lineEnd": 293,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getStackTraceId to class JfrStackTraceRepository",
                        "description": "Move method getStackTraceId to com.oracle.svm.core.jfr.JfrStackTraceRepository\nRationale: The method `getStackTraceId(JfrEvent eventType, int skipCount)` is closely related to operations involving stack trace IDs and their management, which aligns well with the responsibilities of `JfrStackTraceRepository`. This repository already handles various stack trace-related functions, making it the most suitable destination for this method. Furthermore, the method directly calls an overloaded version of `getStackTraceId(int skipCount)`, which is already a member of `JfrStackTraceRepository`, indicating that it belongs logically in the same class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 635,
                        "lineEnd": 640,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method log to class JfrLogging",
                        "description": "Move method log to com.oracle.svm.core.jfr.logging.JfrLogging\nRationale: The method `log(int tagSetId, int level, String message)` interacts directly with the `jfrLogging` instance within its body, indicating a tight coupling with logging functionalities. The `JfrLogging` class already defines a similar `log` method with the same signature, suggesting that this method correctly belongs within the `JfrLogging` class, ensuring cohesion and single responsibility for logging operations. Additionally, moving it here consolidates all logging-related methods in one place, making the codebase easier to maintain and understand.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 714,
                        "lineEnd": 717,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getThresholdTicks to class JfrUnlockedChunkWriter",
                        "description": "Move method getThresholdTicks to com.oracle.svm.core.jfr.JfrUnlockedChunkWriter\nRationale: The method `getThresholdTicks()` deals with retrieving settings related to a `JfrEvent`. None of the methods in `JfrUnlockedChunkWriter` directly match with the intent of this method, but since `JfrUnlockedChunkWriter` involves interactions that do not require holding a lock and considering it might be common for `getThresholdTicks()` to be called in such a context, it could make sense to move this method into `JfrUnlockedChunkWriter`. Additionally, the method annotation `@Uninterruptible` suggests that the operation is critical and cannot afford to be interrupted, aligning with the lock-free operations `JfrUnlockedChunkWriter` intends to handle. The existing class likely deals with unrelated functionality, hence the method would be more appropriately placed within `JfrUnlockedChunkWriter`.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 642,
                        "lineEnd": 647,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method logEvent to class JfrLogging",
                        "description": "Move method logEvent to com.oracle.svm.core.jfr.logging.JfrLogging\nRationale: The method logEvent is already present in the JfrLogging class and is responsible for handling logging functionality. Moving this method to JfrLogging consolidates logging-related logic within a single class. The JfrLogging class has methods like parseConfiguration(), warnInternal(), and log() which are clearly related to logging functionalities. Having all logging-related methods in JfrLogging ensures better cohesion and maintainability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 699,
                        "lineEnd": 704,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method setThrottle to class JfrEventThrottling",
                        "description": "Move method setThrottle to com.oracle.svm.core.jfr.throttling.JfrEventThrottling\nRationale: null",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 689,
                        "lineEnd": 692,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method setLarge to class JfrUnlockedChunkWriter",
                        "description": "Move method setLarge to com.oracle.svm.core.jfr.JfrUnlockedChunkWriter\nRationale: The method `setLarge` involves modifying the settings of a JFR event, which fits well with the responsibilities of `JfrUnlockedChunkWriter`. This class is already designed to handle JFR-related operations without holding a lock, aligning with the `@Uninterruptible` annotation on `setLarge`. Therefore, it is a logical place to move this method to ensure that event settings can be modified in an uninterruptible and thread-safe manner.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 541,
                        "lineEnd": 560,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method commit to class JfrThreadLocal",
                        "description": "Move method commit to com.oracle.svm.core.jfr.JfrThreadLocal\nRationale: The method 'commit' heavily relies on accessing and modifying the thread-local JFR buffer, which is managed by JfrThreadLocal. It needs to access thread-local values and check conditions based on those values. Since JfrThreadLocal class is designed to handle such JFR buffer operations and thread-local storage, moving the method to this class aligns well with its responsibilities. By being a part of JfrThreadLocal, the method also gains access to the private fields and methods seamlessly, ensuring a cohesive design and easier maintenance.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 684,
                        "lineEnd": 687,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method isEnabled to class JfrUnlockedChunkWriter",
                        "description": "Move method isEnabled to com.oracle.svm.core.jfr.JfrUnlockedChunkWriter\nRationale: The isEnabled() method evaluates the enabled status of an event based on certain settings. Since it has behavior related to event settings, which are possibly tied to event data writing and synchronization in JfrUnlockedChunkWriter, moving the isEnabled() method to this interface allows better encapsulation of event-related functionalities within the same interface. This change consolidates related functionality, possibly improving the coherence and maintainability of the code.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 694,
                        "lineEnd": 697,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method isLarge to class JfrUnlockedChunkWriter",
                        "description": "Move method isLarge to com.oracle.svm.core.jfr.JfrUnlockedChunkWriter\nRationale: The method isLarge() checks if a JfrEvent is large, and this could be considered as part of the functionality of a JfrChunkWriter which JfrUnlockedChunkWriter is related to. As JfrUnlockedChunkWriter handles methods that do not need locking, this method fits the criteria and could logically belong here. It would make sense to centralize related event handling or inspecting methods under JfrUnlockedChunkWriter. Additionally, since JfrUnlockedChunkWriter already manages methods that need to be thread-safe without explicit locking, the Uninterruptibility annotation aligns well with this class's existing methods.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 251,
                        "lineEnd": 268,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method destroyJFR to class JfrUnlockedChunkWriter",
                        "description": "Move method destroyJFR to com.oracle.svm.core.jfr.JfrUnlockedChunkWriter\nRationale: The destroyJFR() method appears to directly interact with Java Flight Recorder (JFR) resources, particularly focusing on stopping recordings and teardown operations. The JfrUnlockedChunkWriter interface, which involves methods for handling chunk writing in JFR without locks, is a more appropriate place for this method. By placing destroyJFR() in JfrUnlockedChunkWriter, it ensures cohesion as the interface deals with operations involving JFR and chunk writing, including teardown logic. Since JfrUnlockedChunkWriter is designed for unblocked operations, this method aligns with its purpose.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 502,
                        "lineEnd": 525,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method flush to class JfrThreadLocal",
                        "description": "Move method flush to com.oracle.svm.core.jfr.JfrThreadLocal\nRationale: The flush method is concerned with managing JFR buffers in a thread-local context, particularly by interacting with JfrBuffer objects and performing operations such as flushing to global memory. The JfrThreadLocal class already handles various JFR-specific thread local values, including the buffers. Thus, it is a natural fit for the flush method. The other candidate, JfrUnlockedChunkWriter, focuses on chunk writing mechanisms and doesn\u2019t align well with the buffer management tasks encapsulated in the flush method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 226,
                        "lineEnd": 249,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method createJFR to class JfrUnlockedChunkWriter",
                        "description": "Move method createJFR to com.oracle.svm.core.jfr.JfrUnlockedChunkWriter\nRationale: The createJFR method involves the initialization workflow of various components involved in JFR (Java Flight Recorder) and specifically initializes the 'unlockedChunkWriter', which is a dependency defined in the JfrUnlockedChunkWriter interface. Moving this method to JfrUnlockedChunkWriter will encapsulate the initialization logic within a relevant context. This way, the method will be closer to the resource it primarily interacts with, improving cohesion and maintainability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 663,
                        "lineEnd": 668,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method newEventWriter to class JfrThreadLocal",
                        "description": "Move method newEventWriter to com.oracle.svm.core.jfr.JfrThreadLocal\nRationale: The method `newEventWriter()` relies heavily on the instance of `Target_jdk_jfr_internal_event_EventWriter` which is returned by the instance method `threadLocal.newEventWriter()`, making it more appropriate to place this method within the `JfrThreadLocal` class. Additionally, this method deals with thread-local JFR events which align with the responsibilities and data managed by `JfrThreadLocal`, further justifying moving the method to this target class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getThreadId",
                            "method_signature": "public static long getThreadId(Thread thread)",
                            "target_class": "JavaThreads",
                            "rationale": "This method directly interacts with the `JavaThreads` class and can be more appropriately placed there to encapsulate thread-related functionality."
                        },
                        {
                            "method_name": "getCurrentThreadId",
                            "method_signature": "public static long getCurrentThreadId()",
                            "target_class": "JavaThreads",
                            "rationale": "Similar to `getThreadId`, this method is directly related to thread handling and can be logically grouped with the other thread-related methods in the `JavaThreads` class."
                        },
                        {
                            "method_name": "setMethodSamplingInterval",
                            "method_signature": "public void setMethodSamplingInterval(long type, long intervalMillis)",
                            "target_class": "JfrExecutionSampler",
                            "rationale": "This method configures the sampling interval for the `JfrExecutionSampler`. It would be more appropriate to have it within the `JfrExecutionSampler` class to encapsulate the sampler configuration."
                        },
                        {
                            "method_name": "setSampleThreads",
                            "method_signature": "public void setSampleThreads(boolean sampleThreads)",
                            "target_class": "JfrExecutionSampler",
                            "rationale": "This method sets the sampling for threads, aligning with the responsibilities of the `JfrExecutionSampler` class, which can handle whether threads should be sampled."
                        },
                        {
                            "method_name": "setCompressedIntegers",
                            "method_signature": "public void setCompressedIntegers(boolean compressed)",
                            "target_class": "JfrLogging",
                            "rationale": "This method handles settings related to JFR logging and would be more coherent inside the `JfrLogging` class."
                        },
                        {
                            "method_name": "log",
                            "method_signature": "public void log(int tagSetId, int level, String message)",
                            "target_class": "JfrLogging",
                            "rationale": "This method is explicitly for logging JFR messages, making it a better fit within the `JfrLogging` class to maintain logging responsibilities in one place."
                        },
                        {
                            "method_name": "logEvent",
                            "method_signature": "public void logEvent(int level, String[] lines, boolean system)",
                            "target_class": "JfrLogging",
                            "rationale": "Like `log`, this method deals with logging specific events, making it appropriate to move it to the `JfrLogging` class."
                        }
                    ],
                    "llm_response_time": 7365
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "getThreadId",
                            "method_signature": "public static long getThreadId(Thread thread)",
                            "target_class": "JavaThreads",
                            "rationale": "This method directly uses the JavaThreads class for operations. It would be more logical to have this method in the JavaThreads class."
                        },
                        {
                            "method_name": "getCurrentThreadId",
                            "method_signature": "public static long getCurrentThreadId()",
                            "target_class": "JavaThreads",
                            "rationale": "Similar to getThreadId, this method relies on JavaThreads class and would fit better there."
                        },
                        {
                            "method_name": "log",
                            "method_signature": "public void log(int tagSetId, int level, String message)",
                            "target_class": "JfrLogging",
                            "rationale": "This method uses jfrLogging instance and performs logging actions. This functionality is more appropriate in the JfrLogging class."
                        },
                        {
                            "method_name": "logEvent",
                            "method_signature": "public void logEvent(int level, String[] lines, boolean system)",
                            "target_class": "JfrLogging",
                            "rationale": "Similar to the log method, this method also handles logging operations which should be part of JfrLogging class."
                        }
                    ],
                    "llm_response_time": 4119
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "getStackTraceId",
                            "method_signature": "public long getStackTraceId(long eventTypeId, int skipCount)",
                            "target_class": "JfrStackTraceRepository",
                            "rationale": "The method getStackTraceId() is concerned with stack trace IDs, which is the responsibility of JfrStackTraceRepository. Moving it there enhances cohesion and isolates stack trace logic within the appropriate class."
                        },
                        {
                            "method_name": "getStackTraceId",
                            "method_signature": "public long getStackTraceId(int skipCount)",
                            "target_class": "JfrStackTraceRepository",
                            "rationale": "Similar to the other getStackTraceId method, this method is focused on managing stack trace IDs and should be moved to JfrStackTraceRepository for better cohesion."
                        },
                        {
                            "method_name": "getStackTraceId",
                            "method_signature": "public long getStackTraceId(JfrEvent eventType, int skipCount)",
                            "target_class": "JfrStackTraceRepository",
                            "rationale": "This method also deals with stack trace IDs and is better placed in JfrStackTraceRepository to centralize stack trace logic."
                        },
                        {
                            "method_name": "getClassId",
                            "method_signature": "public long getClassId(Class<?> clazz)",
                            "target_class": "JfrTypeRepository",
                            "rationale": "getClassId() manages class IDs, which is a task that belongs in JfrTypeRepository. This enhances the SRP (Single Responsibility Principle) by ensuring class ID management is in the appropriate repository."
                        },
                        {
                            "method_name": "setDumpPath",
                            "method_signature": "public void setDumpPath(String dumpPathText)",
                            "target_class": "JfrEmergencyDump",
                            "rationale": "Setting the dump path is related to emergency dumping configurations, thus making more sense to move it to JfrEmergencyDump class."
                        },
                        {
                            "method_name": "getDumpPath",
                            "method_signature": "public String getDumpPath()",
                            "target_class": "JfrEmergencyDump",
                            "rationale": "Retrieving the dump path is relevant to the emergency dump configuration, so it is logical to place this method in the JfrEmergencyDump class."
                        },
                        {
                            "method_name": "emitOldObjectSamples",
                            "method_signature": "void emitOldObjectSamples(long cutoff, boolean emitAll, boolean skipBFS)",
                            "target_class": "JfrOldObjectProfiler",
                            "rationale": "This method is focused on emitting old object samples, which is the responsibility of JfrOldObjectProfiler. Moving it here enhances the cohesion."
                        },
                        {
                            "method_name": "log",
                            "method_signature": "public void log(int tagSetId, int level, String message)",
                            "target_class": "JfrLogging",
                            "rationale": "The log() method is related to logging functionality, which belongs in the JfrLogging class to keep the logging logic centralized."
                        },
                        {
                            "method_name": "logEvent",
                            "method_signature": "public void logEvent(int level, String[] lines, boolean system)",
                            "target_class": "JfrLogging",
                            "rationale": "Similar to the log method, this method also deals with logging events and should thus be placed in the JfrLogging class for cohesiveness."
                        },
                        {
                            "method_name": "setEnabled",
                            "method_signature": "public void setEnabled(long eventTypeId, boolean newValue)",
                            "target_class": "JfrNativeEventSetting",
                            "rationale": "This method manages the enabling or disabling of events, which should be managed within JfrNativeEventSetting where event settings are handled."
                        },
                        {
                            "method_name": "setStackTraceEnabled",
                            "method_signature": "public void setStackTraceEnabled(long eventTypeId, boolean enabled)",
                            "target_class": "JfrNativeEventSetting",
                            "rationale": "Enabling or disabling stack traces for specific events is a task for JfrNativeEventSetting, thus moving this method there improves cohesion."
                        },
                        {
                            "method_name": "isStackTraceEnabled",
                            "method_signature": "public boolean isStackTraceEnabled(long eventTypeId)",
                            "target_class": "JfrNativeEventSetting",
                            "rationale": "Checking if stack trace is enabled for a particular event is part of the event settings and should be within JfrNativeEventSetting."
                        },
                        {
                            "method_name": "setThreshold",
                            "method_signature": "public boolean setThreshold(long eventTypeId, long ticks)",
                            "target_class": "JfrNativeEventSetting",
                            "rationale": "Setting the threshold for events is a specific event setting functionality and should be moved to JfrNativeEventSetting."
                        },
                        {
                            "method_name": "setCutoff",
                            "method_signature": "public boolean setCutoff(long eventTypeId, long cutoffTicks)",
                            "target_class": "JfrNativeEventSetting",
                            "rationale": "Similar to setThreshold, setting cutoff ticks for events is part of event settings and belongs in JfrNativeEventSetting."
                        },
                        {
                            "method_name": "flush",
                            "method_signature": "public boolean flush(Target_jdk_jfr_internal_event_EventWriter writer, int uncommittedSize, int requestedSize)",
                            "target_class": "JfrChunkWriter",
                            "rationale": "This method deals with flushing event data to a writer, which is a task for JfrChunkWriter."
                        }
                    ],
                    "llm_response_time": 12350
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "createJFR",
                            "method_signature": "public createJFR(boolean simulateFailure)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "destroyJFR",
                            "method_signature": "public destroyJFR()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getStackTraceId",
                            "method_signature": "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getStackTraceId(int skipCount)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getStackTraceId",
                            "method_signature": "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getStackTraceId(JfrEvent eventType, int skipCount)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "storeMetadataDescriptor",
                            "method_signature": "public storeMetadataDescriptor(byte[] bytes)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "beginRecording",
                            "method_signature": "public beginRecording()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getClassId",
                            "method_signature": "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getClassId(Class<?> clazz)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setMethodSamplingInterval",
                            "method_signature": "public setMethodSamplingInterval(long type, long intervalMillis)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "flush",
                            "method_signature": "@Uninterruptible(reason = \"Accesses a JFR buffer.\")\n    public flush(Target_jdk_jfr_internal_event_EventWriter writer, int uncommittedSize, int requestedSize)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "flush",
                            "method_signature": "public flush()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "commit",
                            "method_signature": "@Uninterruptible(reason = \"Accesses a native JFR buffer.\")\n    public commit(long nextPosition)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "markChunkFinal",
                            "method_signature": "public markChunkFinal()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "shouldRotateDisk",
                            "method_signature": "public shouldRotateDisk()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "emitOldObjectSamples",
                            "method_signature": " emitOldObjectSamples(long cutoff, boolean emitAll, boolean skipBFS)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "log",
                            "method_signature": "public log(int tagSetId, int level, String message)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "logEvent",
                            "method_signature": "public logEvent(int level, String[] lines, boolean system)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "newEventWriter",
                            "method_signature": "public newEventWriter()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setEnabled",
                            "method_signature": "public setEnabled(long eventTypeId, boolean newValue)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isEnabled",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isEnabled(JfrEvent event)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setLarge",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public setLarge(JfrEvent event, boolean large)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isLarge",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isLarge(JfrEvent event)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setThrottle",
                            "method_signature": "public setThrottle(long eventTypeId, long eventSampleSize, long periodMs)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getThresholdTicks",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true) getThresholdTicks(JfrEvent event)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "emitOldObjectSamples",
                            "method_signature": " emitOldObjectSamples(long cutoff, boolean emitAll, boolean skipBFS)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getStackTraceId",
                            "method_signature": "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getStackTraceId(JfrEvent eventType, int skipCount)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "log",
                            "method_signature": "public log(int tagSetId, int level, String message)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getThresholdTicks",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true) getThresholdTicks(JfrEvent event)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "logEvent",
                            "method_signature": "public logEvent(int level, String[] lines, boolean system)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setThrottle",
                            "method_signature": "public setThrottle(long eventTypeId, long eventSampleSize, long periodMs)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setLarge",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public setLarge(JfrEvent event, boolean large)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "commit",
                            "method_signature": "@Uninterruptible(reason = \"Accesses a native JFR buffer.\")\n    public commit(long nextPosition)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isEnabled",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isEnabled(JfrEvent event)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isLarge",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isLarge(JfrEvent event)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "setMethodSamplingInterval",
                            "method_signature": "public setMethodSamplingInterval(long type, long intervalMillis)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "destroyJFR",
                            "method_signature": "public destroyJFR()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "flush",
                            "method_signature": "@Uninterruptible(reason = \"Accesses a JFR buffer.\")\n    public flush(Target_jdk_jfr_internal_event_EventWriter writer, int uncommittedSize, int requestedSize)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createJFR",
                            "method_signature": "public createJFR(boolean simulateFailure)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "newEventWriter",
                            "method_signature": "public newEventWriter()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    " emitOldObjectSamples(long cutoff, boolean emitAll, boolean skipBFS)": {
                        "first": {
                            "method_name": "emitOldObjectSamples",
                            "method_signature": " emitOldObjectSamples(long cutoff, boolean emitAll, boolean skipBFS)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.42915876631092903
                    },
                    "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getStackTraceId(JfrEvent eventType, int skipCount)": {
                        "first": {
                            "method_name": "getStackTraceId",
                            "method_signature": "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getStackTraceId(JfrEvent eventType, int skipCount)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.46971666331388146
                    },
                    "public log(int tagSetId, int level, String message)": {
                        "first": {
                            "method_name": "log",
                            "method_signature": "public log(int tagSetId, int level, String message)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.48344619403152933
                    },
                    "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true) getThresholdTicks(JfrEvent event)": {
                        "first": {
                            "method_name": "getThresholdTicks",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true) getThresholdTicks(JfrEvent event)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4841024807450458
                    },
                    "public logEvent(int level, String[] lines, boolean system)": {
                        "first": {
                            "method_name": "logEvent",
                            "method_signature": "public logEvent(int level, String[] lines, boolean system)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.497064466697407
                    },
                    "public setThrottle(long eventTypeId, long eventSampleSize, long periodMs)": {
                        "first": {
                            "method_name": "setThrottle",
                            "method_signature": "public setThrottle(long eventTypeId, long eventSampleSize, long periodMs)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5056181957060429
                    },
                    "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public setLarge(JfrEvent event, boolean large)": {
                        "first": {
                            "method_name": "setLarge",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public setLarge(JfrEvent event, boolean large)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5072824676775364
                    },
                    "@Uninterruptible(reason = \"Accesses a native JFR buffer.\")\n    public commit(long nextPosition)": {
                        "first": {
                            "method_name": "commit",
                            "method_signature": "@Uninterruptible(reason = \"Accesses a native JFR buffer.\")\n    public commit(long nextPosition)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5336413767462067
                    },
                    "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isEnabled(JfrEvent event)": {
                        "first": {
                            "method_name": "isEnabled",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isEnabled(JfrEvent event)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5381379960284759
                    },
                    "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isLarge(JfrEvent event)": {
                        "first": {
                            "method_name": "isLarge",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isLarge(JfrEvent event)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5381379960284759
                    },
                    "public setMethodSamplingInterval(long type, long intervalMillis)": {
                        "first": {
                            "method_name": "setMethodSamplingInterval",
                            "method_signature": "public setMethodSamplingInterval(long type, long intervalMillis)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.553089115345752
                    },
                    "public destroyJFR()": {
                        "first": {
                            "method_name": "destroyJFR",
                            "method_signature": "public destroyJFR()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5720701659794021
                    },
                    "@Uninterruptible(reason = \"Accesses a JFR buffer.\")\n    public flush(Target_jdk_jfr_internal_event_EventWriter writer, int uncommittedSize, int requestedSize)": {
                        "first": {
                            "method_name": "flush",
                            "method_signature": "@Uninterruptible(reason = \"Accesses a JFR buffer.\")\n    public flush(Target_jdk_jfr_internal_event_EventWriter writer, int uncommittedSize, int requestedSize)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5764031206967649
                    },
                    "public createJFR(boolean simulateFailure)": {
                        "first": {
                            "method_name": "createJFR",
                            "method_signature": "public createJFR(boolean simulateFailure)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6149097708640129
                    },
                    "public newEventWriter()": {
                        "first": {
                            "method_name": "newEventWriter",
                            "method_signature": "public newEventWriter()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6252288451730623
                    }
                },
                "voyage": {
                    "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isEnabled(JfrEvent event)": {
                        "first": {
                            "method_name": "isEnabled",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isEnabled(JfrEvent event)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.41424549680333417
                    },
                    "@Uninterruptible(reason = \"Accesses a native JFR buffer.\")\n    public commit(long nextPosition)": {
                        "first": {
                            "method_name": "commit",
                            "method_signature": "@Uninterruptible(reason = \"Accesses a native JFR buffer.\")\n    public commit(long nextPosition)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.43560836753844223
                    },
                    "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true) getThresholdTicks(JfrEvent event)": {
                        "first": {
                            "method_name": "getThresholdTicks",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true) getThresholdTicks(JfrEvent event)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.44362998036115586
                    },
                    "public markChunkFinal()": {
                        "first": {
                            "method_name": "markChunkFinal",
                            "method_signature": "public markChunkFinal()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.44583824232270314
                    },
                    "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isLarge(JfrEvent event)": {
                        "first": {
                            "method_name": "isLarge",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isLarge(JfrEvent event)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.44767251495240534
                    },
                    "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getStackTraceId(JfrEvent eventType, int skipCount)": {
                        "first": {
                            "method_name": "getStackTraceId",
                            "method_signature": "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getStackTraceId(JfrEvent eventType, int skipCount)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4561094901971965
                    },
                    "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public setLarge(JfrEvent event, boolean large)": {
                        "first": {
                            "method_name": "setLarge",
                            "method_signature": "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public setLarge(JfrEvent event, boolean large)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4705767541959172
                    },
                    "public flush()": {
                        "first": {
                            "method_name": "flush",
                            "method_signature": "public flush()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4869147282336059
                    },
                    "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getClassId(Class<?> clazz)": {
                        "first": {
                            "method_name": "getClassId",
                            "method_signature": "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getClassId(Class<?> clazz)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4915649798577843
                    },
                    " emitOldObjectSamples(long cutoff, boolean emitAll, boolean skipBFS)": {
                        "first": {
                            "method_name": "emitOldObjectSamples",
                            "method_signature": " emitOldObjectSamples(long cutoff, boolean emitAll, boolean skipBFS)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5100560100430652
                    },
                    "public setThrottle(long eventTypeId, long eventSampleSize, long periodMs)": {
                        "first": {
                            "method_name": "setThrottle",
                            "method_signature": "public setThrottle(long eventTypeId, long eventSampleSize, long periodMs)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5165643056248204
                    },
                    "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getStackTraceId(int skipCount)": {
                        "first": {
                            "method_name": "getStackTraceId",
                            "method_signature": "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getStackTraceId(int skipCount)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.535405874248964
                    },
                    "public log(int tagSetId, int level, String message)": {
                        "first": {
                            "method_name": "log",
                            "method_signature": "public log(int tagSetId, int level, String message)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5392562574144054
                    },
                    "public storeMetadataDescriptor(byte[] bytes)": {
                        "first": {
                            "method_name": "storeMetadataDescriptor",
                            "method_signature": "public storeMetadataDescriptor(byte[] bytes)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5455097654277526
                    },
                    "public shouldRotateDisk()": {
                        "first": {
                            "method_name": "shouldRotateDisk",
                            "method_signature": "public shouldRotateDisk()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5521319433796497
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isEnabled(JfrEvent event)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isLarge(JfrEvent event)",
                        "@Uninterruptible(reason = \"Accesses a native JFR buffer.\")\n    public commit(long nextPosition)",
                        "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getStackTraceId(JfrEvent eventType, int skipCount)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public setLarge(JfrEvent event, boolean large)",
                        "@Uninterruptible(reason = \"Accesses a JFR buffer.\")\n    public flush(Target_jdk_jfr_internal_event_EventWriter writer, int uncommittedSize, int requestedSize)",
                        "public setMethodSamplingInterval(long type, long intervalMillis)",
                        "public log(int tagSetId, int level, String message)",
                        "public logEvent(int level, String[] lines, boolean system)",
                        "public setThrottle(long eventTypeId, long eventSampleSize, long periodMs)",
                        "public destroyJFR()",
                        "public newEventWriter()",
                        "public createJFR(boolean simulateFailure)"
                    ],
                    "llm_response_time": 5237
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public log(int tagSetId, int level, String message)",
                        "public logEvent(int level, String[] lines, boolean system)",
                        "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getStackTraceId(JfrEvent eventType, int skipCount)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true) getThresholdTicks(JfrEvent event)"
                    ],
                    "llm_response_time": 2606
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public log(int tagSetId, int level, String message)",
                        "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getStackTraceId(JfrEvent eventType, int skipCount)"
                    ],
                    "llm_response_time": 3983
                },
                "voyage": {
                    "priority_method_names": [
                        "@Uninterruptible(reason = \"Accesses a native JFR buffer.\")\n    public commit(long nextPosition)",
                        "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getStackTraceId(JfrEvent eventType, int skipCount)",
                        "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getStackTraceId(int skipCount)",
                        "@Uninterruptible(reason = \"Result is only valid until epoch changes.\", callerMustBe = true)\n    public getClassId(Class<?> clazz)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isEnabled(JfrEvent event)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public setLarge(JfrEvent event, boolean large)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isLarge(JfrEvent event)",
                        " emitOldObjectSamples(long cutoff, boolean emitAll, boolean skipBFS)",
                        "public storeMetadataDescriptor(byte[] bytes)",
                        "public markChunkFinal()",
                        "public log(int tagSetId, int level, String message)",
                        "public flush()",
                        "public shouldRotateDisk()",
                        "public setThrottle(long eventTypeId, long eventSampleSize, long periodMs)"
                    ],
                    "llm_response_time": 7017
                },
                "voyage-5": {
                    "priority_method_names": [
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true) getThresholdTicks(JfrEvent event)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isEnabled(JfrEvent event)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isLarge(JfrEvent event)",
                        "@Uninterruptible(reason = \"Accesses a native JFR buffer.\")\n    public commit(long nextPosition)",
                        "public markChunkFinal()"
                    ],
                    "llm_response_time": 8190
                },
                "voyage-3": {
                    "priority_method_names": [
                        "@Uninterruptible(reason = \"Accesses a native JFR buffer.\")\n    public commit(long nextPosition)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true) getThresholdTicks(JfrEvent event)",
                        "@Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public isEnabled(JfrEvent event)"
                    ],
                    "llm_response_time": 6280
                }
            },
            "targetClassMap": {
                "emitOldObjectSamples": {
                    "target_classes": [
                        {
                            "class_name": "JfrUnlockedChunkWriter",
                            "similarity_score": 0.3236377285026343
                        },
                        {
                            "class_name": "JfrOldObjectProfiler",
                            "similarity_score": 0.34631547881816654
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JfrOldObjectProfiler",
                        "JfrUnlockedChunkWriter"
                    ],
                    "llm_response_time": 2237,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "getStackTraceId": {
                    "target_classes": [
                        {
                            "class_name": "JfrEvent",
                            "similarity_score": 0.40972028871573896
                        },
                        {
                            "class_name": "JfrOptionSet",
                            "similarity_score": 0.39776211130498734
                        },
                        {
                            "class_name": "JfrSymbolRepository",
                            "similarity_score": 0.5935283928571394
                        },
                        {
                            "class_name": "JfrTypeRepository",
                            "similarity_score": 0.4008209219120745
                        },
                        {
                            "class_name": "JfrThreadRepository",
                            "similarity_score": 0.5379726154238232
                        },
                        {
                            "class_name": "JfrStackTraceRepository",
                            "similarity_score": 0.603176857780412
                        },
                        {
                            "class_name": "JfrMethodRepository",
                            "similarity_score": 0.5556423350075929
                        },
                        {
                            "class_name": "JfrOldObjectRepository",
                            "similarity_score": 0.5746493688313499
                        },
                        {
                            "class_name": "JfrThreadLocal",
                            "similarity_score": 0.4922384091264421
                        },
                        {
                            "class_name": "JfrGlobalMemory",
                            "similarity_score": 0.45220358085863765
                        },
                        {
                            "class_name": "SamplerBufferPool",
                            "similarity_score": 0.5200212788063125
                        },
                        {
                            "class_name": "JfrUnlockedChunkWriter",
                            "similarity_score": 0.058722021951470346
                        },
                        {
                            "class_name": "JfrRecorderThread",
                            "similarity_score": 0.44765056609726245
                        },
                        {
                            "class_name": "JfrOldObjectProfiler",
                            "similarity_score": 0.46126106589060323
                        },
                        {
                            "class_name": "JfrLogging",
                            "similarity_score": 0.4659629763480172
                        },
                        {
                            "class_name": "JfrEventThrottling",
                            "similarity_score": 0.46142322482192344
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JfrStackTraceRepository",
                        "JfrSymbolRepository",
                        "JfrOldObjectRepository"
                    ],
                    "llm_response_time": 4106,
                    "similarity_computation_time": 7,
                    "similarity_metric": "cosine"
                },
                "log": {
                    "target_classes": [
                        {
                            "class_name": "JfrUnlockedChunkWriter",
                            "similarity_score": 0.3075406977753958
                        },
                        {
                            "class_name": "JfrLogging",
                            "similarity_score": 0.36204761427705706
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JfrLogging",
                        "JfrUnlockedChunkWriter"
                    ],
                    "llm_response_time": 2618,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "getThresholdTicks": {
                    "target_classes": [
                        {
                            "class_name": "JfrUnlockedChunkWriter",
                            "similarity_score": 0.02694351152071961
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JfrUnlockedChunkWriter"
                    ],
                    "llm_response_time": 2350,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "logEvent": {
                    "target_classes": [
                        {
                            "class_name": "JfrUnlockedChunkWriter",
                            "similarity_score": 0.33316908925667876
                        },
                        {
                            "class_name": "JfrLogging",
                            "similarity_score": 0.3235319106305616
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JfrLogging",
                        "JfrUnlockedChunkWriter"
                    ],
                    "llm_response_time": 4156,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "setThrottle": {
                    "target_classes": [
                        {
                            "class_name": "JfrUnlockedChunkWriter",
                            "similarity_score": 0.2996645634283651
                        },
                        {
                            "class_name": "JfrEventThrottling",
                            "similarity_score": 0.503416596907764
                        }
                    ],
                    "llm_response_time": 2306,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine",
                    "target_class_priority_explanation": "[\n    {\n        \"target_class\": \"JfrEventThrottling\",\n        \"rationale\": \"The method setThrottle(long eventTypeId, long eventSampleSize, long periodMs) is handling event throttling, which clearly fits within the responsibilities of the JfrEventThrottling class as it already manages throttling configurations. This method directly pertains to event throttler configurations, thus aligning it with JfrEventThrottling centralizes throttling concerns in a single class, maintains cohesion, and enhances code maintainability.\"\n    },\n    {\n        \"target_class\": \"JfrUnlockedChunkWriter\",\n        \"rationale\": \"The JfrUnlockedChunkWriter interface is primarily focused on chunk writing operations and concurrency control. Introducing a throttling method here would dilute its focus and violate the single responsibility principle. Therefore, it is less appropriate as a target for the setThrottle method.\n    }\n]"
                },
                "setLarge": {
                    "target_classes": [
                        {
                            "class_name": "JfrUnlockedChunkWriter",
                            "similarity_score": 0.07688517444384894
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JfrUnlockedChunkWriter"
                    ],
                    "llm_response_time": 1859,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "commit": {
                    "target_classes": [
                        {
                            "class_name": "JfrThreadLocal",
                            "similarity_score": 0.575630649250289
                        },
                        {
                            "class_name": "JfrUnlockedChunkWriter",
                            "similarity_score": 0.16943316505572864
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JfrThreadLocal",
                        "JfrUnlockedChunkWriter"
                    ],
                    "llm_response_time": 3112,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "isEnabled": {
                    "target_classes": [
                        {
                            "class_name": "JfrUnlockedChunkWriter",
                            "similarity_score": 0.06565321642986127
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JfrUnlockedChunkWriter"
                    ],
                    "llm_response_time": 1946,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "isLarge": {
                    "target_classes": [
                        {
                            "class_name": "JfrUnlockedChunkWriter",
                            "similarity_score": 0.06565321642986127
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JfrUnlockedChunkWriter"
                    ],
                    "llm_response_time": 2416,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "setMethodSamplingInterval": {
                    "target_classes": [
                        {
                            "class_name": "JfrUnlockedChunkWriter",
                            "similarity_score": 0.23271358898964636
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JfrUnlockedChunkWriter"
                    ],
                    "llm_response_time": 2156,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "destroyJFR": {
                    "target_classes": [
                        {
                            "class_name": "JfrUnlockedChunkWriter",
                            "similarity_score": 0.4155136643142639
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JfrUnlockedChunkWriter"
                    ],
                    "llm_response_time": 2081,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "flush": {
                    "target_classes": [
                        {
                            "class_name": "JfrThreadLocal",
                            "similarity_score": 0.6105230564700953
                        },
                        {
                            "class_name": "JfrUnlockedChunkWriter",
                            "similarity_score": 0.45222873192927227
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JfrThreadLocal",
                        "JfrUnlockedChunkWriter"
                    ],
                    "llm_response_time": 3384,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "createJFR": {
                    "target_classes": [
                        {
                            "class_name": "JfrUnlockedChunkWriter",
                            "similarity_score": 0.29521286423310117
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JfrUnlockedChunkWriter"
                    ],
                    "llm_response_time": 1680,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "newEventWriter": {
                    "target_classes": [
                        {
                            "class_name": "JfrThreadLocal",
                            "similarity_score": 0.43371189934727805
                        },
                        {
                            "class_name": "JfrUnlockedChunkWriter",
                            "similarity_score": 0.37459084664106235
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "JfrThreadLocal",
                        "JfrUnlockedChunkWriter"
                    ],
                    "llm_response_time": 3341,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "dd975be5c61014a1febde1b8d3f67a2e50e84b63",
        "url": "https://github.com/oracle/graal/commit/dd975be5c61014a1febde1b8d3f67a2e50e84b63",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public toJson(builder JsonBuilder.ObjectBuilder) : void extracted from public afterCompilation(access AfterCompilationAccess) : void in class com.oracle.svm.hosted.dashboard.DashboardDumpFeature & moved to class com.oracle.svm.hosted.dashboard.CodeBreakdown",
            "leftSideLocations": [
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/dashboard/DashboardDumpFeature.java",
                    "startLine": 152,
                    "endLine": 183,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "public afterCompilation(access AfterCompilationAccess) : void"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/dashboard/DashboardDumpFeature.java",
                    "startLine": 174,
                    "endLine": 174,
                    "startColumn": 41,
                    "endColumn": 54,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/dashboard/CodeBreakdown.java",
                    "startLine": 63,
                    "endLine": 74,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public toJson(builder JsonBuilder.ObjectBuilder) : void"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/dashboard/CodeBreakdown.java",
                    "startLine": 64,
                    "endLine": 64,
                    "startColumn": 9,
                    "endColumn": 17,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/dashboard/DashboardDumpFeature.java",
                    "startLine": 163,
                    "endLine": 195,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "public afterCompilation(access AfterCompilationAccess) : void"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/dashboard/DashboardDumpFeature.java",
                    "startLine": 174,
                    "endLine": 174,
                    "startColumn": 41,
                    "endColumn": 61,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "dump.toJson(builder)"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/dashboard/CodeBreakdown.java",
                    "startLine": 68,
                    "endLine": 70,
                    "startColumn": 21,
                    "endColumn": 63,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/dashboard/CodeBreakdown.java",
                    "startLine": 67,
                    "endLine": 71,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "TRY_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/dashboard/CodeBreakdown.java",
                    "startLine": 66,
                    "endLine": 72,
                    "startColumn": 70,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/dashboard/CodeBreakdown.java",
                    "startLine": 66,
                    "endLine": 72,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "ENHANCED_FOR_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/dashboard/CodeBreakdown.java",
                    "startLine": 65,
                    "endLine": 73,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "TRY_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                }
            ],
            "isStatic": false
        },
        "ref_id": 495,
        "extraction_results": {
            "success": true,
            "newCommitHash": "70e3402349041725ede71febccbbe12a6aaef398",
            "newBranchName": "extract-toJson-afterCompilation-26fbc9c-1"
        },
        "telemetry": {
            "id": "7e476a4f-b68b-4fad-828b-7c01d234c94a",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 321,
                "lineStart": 52,
                "lineEnd": 372,
                "bodyLineStart": 52,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/dashboard/DashboardDumpFeature.java",
                "sourceCode": "@AutomaticallyRegisteredFeature\npublic class DashboardDumpFeature implements InternalFeature {\n\n    private static boolean isHeapBreakdownDumped() {\n        return DashboardOptions.DashboardAll.getValue() || DashboardOptions.DashboardHeap.getValue();\n    }\n\n    private static boolean isPointsToDumped() {\n        return DashboardOptions.DashboardAll.getValue() || DashboardOptions.DashboardPointsTo.getValue();\n    }\n\n    private static boolean isCodeBreakdownDumped() {\n        return DashboardOptions.DashboardAll.getValue() || DashboardOptions.DashboardCode.getValue();\n    }\n\n    private static boolean isBgvFormat() {\n        return DashboardOptions.DashboardBgv.getValue();\n    }\n\n    private static boolean isJsonFormat() {\n        return DashboardOptions.DashboardJson.getValue() || isPretty();\n    }\n\n    private static boolean isPretty() {\n        return DashboardOptions.DashboardPretty.getValue();\n    }\n\n    private static Path getFile(String extension) {\n        String fileName = DashboardOptions.DashboardDump.getValue();\n        if (fileName == null) {\n            fileName = SubstrateOptions.Name.getValue(); // Use image name by default.\n        }\n        return new File(fileName + \".\" + extension).getAbsoluteFile().toPath();\n    }\n\n    private StringWriter jsonOutput = null;\n    private JsonWriter jsonWriter = null;\n    private JsonBuilder.ObjectBuilder objectBuilder = null;\n\n    public DashboardDumpFeature() {\n        if (isSane()) {\n            if (isJsonFormat()) {\n                jsonOutput = new StringWriter();\n                jsonWriter = isPretty() ? new JsonPrettyWriter(jsonOutput) : new JsonWriter(jsonOutput);\n                try {\n                    objectBuilder = jsonWriter.objectBuilder();\n                } catch (IOException ex) {\n                    System.getLogger(DashboardDumpFeature.class.getName()).log(Level.ERROR, \"IOException during Dashboard json dump header\", ex);\n                }\n                ReportUtils.report(\"Dashboard JSON dump header\", getFile(\"dump\"), false, os -> {\n                });\n            }\n            if (isBgvFormat()) {\n                ReportUtils.report(\"Dashboard BGV dump header\", getFile(\"bgv\"), false, os -> {\n                    try {\n                        GraphOutput.newBuilder(VoidGraphStructure.INSTANCE).build(Channels.newChannel(os)).close();\n                    } catch (IOException ex) {\n                        System.getLogger(DashboardDumpFeature.class.getName()).log(Level.ERROR, \"IOException during Dashboard BGV dump header\", ex);\n                    }\n                });\n            }\n        }\n    }\n\n    @Override\n    public boolean isInConfiguration(IsInConfigurationAccess access) {\n        return isSane();\n    }\n\n    private static boolean isSane() {\n        return isHeapBreakdownDumped() || isPointsToDumped() || isCodeBreakdownDumped();\n    }\n\n    @Override\n    public void onAnalysisExit(OnAnalysisExitAccess access) {\n        if (isPointsToDumped()) {\n            PointsToBreakdown pointsTo = new PointsToBreakdown(access);\n            if (isJsonFormat()) {\n                ReportUtils.report(\n                                \"Dashboard PointsTo analysis JSON dump\",\n                                getFile(\"dump\"),\n                                true,\n                                os -> {\n                                    try {\n                                        try (JsonBuilder.ObjectBuilder builder = objectBuilder.append(\"points-to\").object()) {\n                                            pointsTo.toJson(builder);\n                                        }\n                                    } catch (IOException ex) {\n                                        ((AfterCompilationAccessImpl) access).getDebugContext().log(\"Dump of PointsTo analysis failed with: %s\", ex);\n                                    }\n                                });\n            }\n            if (isBgvFormat()) {\n                ReportUtils.report(\n                                \"Dashboard PointsTo analysis BGV dump\",\n                                getFile(\"bgv\"),\n                                true,\n                                os -> {\n                                    try (GraphOutput<?, ?> out = GraphOutput.newBuilder(VoidGraphStructure.INSTANCE).embedded(true).build(Channels.newChannel(os))) {\n                                        out.beginGroup(null, \"points-to\", null, null, 0, Collections.emptyMap());\n                                        pointsTo.dump(out);\n                                        out.endGroup();\n                                    } catch (IOException ex) {\n                                        ((OnAnalysisExitAccessImpl) access).getDebugContext().log(\"Dump of PointsTo analysis failed with: %s\", ex);\n                                    }\n                                });\n            }\n        }\n    }\n\n\n    @Override\n    public void afterCompilation(AfterCompilationAccess access) {\n        if (isCodeBreakdownDumped() || isPointsToDumped()) {\n            CodeBreakdown dump = new CodeBreakdown(access);\n            if (isJsonFormat()) {\n                ReportUtils.report(\n                                \"Dashboard Code-Breakdown JSON dump\",\n                                getFile(\"dump\"),\n                                true,\n                                os -> {\n                                    try (JsonBuilder.ObjectBuilder builder = objectBuilder.append(\"code-breakdown\").object()) {\n                                        dump.build();\n                                        try (JsonBuilder.ArrayBuilder array = builder.append(\"code-size\").array()) {\n                                            for (Map.Entry<String, Integer> entry : dump.getData().entrySet()) {\n                                                try (JsonBuilder.ObjectBuilder object = array.nextEntry().object()) {\n                                                    object\n                                                            .append(\"name\", entry.getKey())\n                                                            .append(\"size\", entry.getValue());\n                                                }\n                                            }\n                                        }\n                                    } catch (IOException ex) {\n                                        ((AfterCompilationAccessImpl) access).getDebugContext().log(\"Dump of Code-Breakdown failed with: %s\", ex);\n                                    }\n                                });\n            }\n            if (isBgvFormat()) {\n                ReportUtils.report(\n                                \"Dashboard Code-Breakdown BGV dump\",\n                                getFile(\"bgv\"),\n                                true,\n                                os -> {\n                                    try (GraphOutput<?, ?> out = GraphOutput.newBuilder(VoidGraphStructure.INSTANCE).embedded(true).build(Channels.newChannel(os))) {\n                                        out.beginGroup(null, \"code-breakdown\", null, null, 0, dump.getData());\n                                        out.endGroup();\n                                    } catch (IOException ex) {\n                                        ((AfterCompilationAccessImpl) access).getDebugContext().log(\"Dump of Code-Breakdown failed with: %s\", ex);\n                                    }\n                                });\n            }\n        }\n    }\n\n    private void toJson(CodeBreakdown dump, JsonBuilder.ObjectBuilder builder) throws IOException {\n        dump.build();\n        try (JsonBuilder.ArrayBuilder array = builder.append(\"code-size\").array()) {\n            for (Map.Entry<String, Integer> entry : dump.getData().entrySet()) {\n                try (JsonBuilder.ObjectBuilder object = array.nextEntry().object()) {\n                    object\n                            .append(\"name\", entry.getKey())\n                            .append(\"size\", entry.getValue());\n                }\n            }\n        }\n    }\n\n    @Override\n    public void afterHeapLayout(AfterHeapLayoutAccess access) {\n        if (isHeapBreakdownDumped()) {\n            HeapBreakdown dump = new HeapBreakdown(access);\n            if (isJsonFormat()) {\n                ReportUtils.report(\n                                \"Dashboard Heap-Breakdown JSON dump\",\n                                getFile(\"dump\"),\n                                true,\n                                os -> {\n                                    try (JsonBuilder.ObjectBuilder builder = objectBuilder.append(\"heap-breakdown\").object()) {\n                                        dump.toJson(builder);\n                                    } catch (IOException ex) {\n                                        ((AfterCompilationAccessImpl) access).getDebugContext().log(\"Dump of Heap-Breakdown failed with: %s\", ex);\n                                    }\n                                });\n            }\n            if (isBgvFormat()) {\n                ReportUtils.report(\n                                \"Dashboard Heap-Breakdown BGV dump\",\n                                getFile(\"bgv\"),\n                                true,\n                                os -> {\n                                    try (GraphOutput<?, ?> out = GraphOutput.newBuilder(VoidGraphStructure.INSTANCE).embedded(true).build(Channels.newChannel(os))) {\n                                        out.beginGroup(null, \"heap-breakdown\", null, null, 0, dump.getData());\n                                        out.endGroup();\n                                    } catch (IOException ex) {\n                                        ((AfterHeapLayoutAccessImpl) access).getDebugContext().log(\"Dump of Heap-Breakdown failed with: %s\", ex);\n                                    }\n                                });\n            }\n        }\n    }\n\n    @Override\n    public void cleanup() {\n        if (isJsonFormat()) {\n            try {\n                if (objectBuilder != null) {\n                    objectBuilder.close();\n                }\n                if (jsonWriter != null) {\n                    jsonWriter.close();\n                }\n            } catch (IOException ex) {\n                System.getLogger(DashboardDumpFeature.class.getName()).log(Level.ERROR, \"IOException during Dashboard json dump end\", ex);\n            }\n\n            ReportUtils.report(\"Dashboard JSON dump end\", getFile(\"dump\"), true, os -> {\n                try (PrintWriter pw = new PrintWriter(os)) {\n                    pw.print(jsonOutput.toString());\n                }\n            });\n        }\n        System.out.println(\"Print of Dashboard dump output ended.\");\n    }\n\n    public static final class VoidGraphStructure implements GraphStructure<Void, Void, Void, Void> {\n\n        public static final GraphStructure<Void, Void, Void, Void> INSTANCE = new VoidGraphStructure();\n\n        private VoidGraphStructure() {\n        }\n\n        @Override\n        public Void graph(Void currentGraph, Object obj) {\n            return null;\n        }\n\n        @Override\n        public Iterable<? extends Void> nodes(Void graph) {\n            return Collections.emptyList();\n        }\n\n        @Override\n        public int nodesCount(Void graph) {\n            return 0;\n        }\n\n        @Override\n        public int nodeId(Void node) {\n            return 0;\n        }\n\n        @Override\n        public boolean nodeHasPredecessor(Void node) {\n            return false;\n        }\n\n        @Override\n        public void nodeProperties(Void graph, Void node, Map<String, ? super Object> properties) {\n        }\n\n        @Override\n        public Void node(Object obj) {\n            return null;\n        }\n\n        @Override\n        public Void nodeClass(Object obj) {\n            return null;\n        }\n\n        @Override\n        public Void classForNode(Void node) {\n            return null;\n        }\n\n        @Override\n        public String nameTemplate(Void nodeClass) {\n            return null;\n        }\n\n        @Override\n        public Object nodeClassType(Void nodeClass) {\n            return null;\n        }\n\n        @Override\n        public Void portInputs(Void nodeClass) {\n            return null;\n        }\n\n        @Override\n        public Void portOutputs(Void nodeClass) {\n            return null;\n        }\n\n        @Override\n        public int portSize(Void port) {\n            return 0;\n        }\n\n        @Override\n        public boolean edgeDirect(Void port, int index) {\n            return false;\n        }\n\n        @Override\n        public String edgeName(Void port, int index) {\n            return null;\n        }\n\n        @Override\n        public Object edgeType(Void port, int index) {\n            return null;\n        }\n\n        @Override\n        public Collection<? extends Void> edgeNodes(Void graph, Void node, Void port, int index) {\n            return null;\n        }\n    }\n}",
                "methodCount": 34
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 8,
                "candidates": [
                    {
                        "lineStart": 78,
                        "lineEnd": 84,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method getFile to class CodeBreakdown",
                        "description": "move method getFile to PsiClass:CodeBreakdown\nRationale: The getFile method handles file paths and extensions, which aligns more closely with CodeBreakdown's responsibility of managing compiled code data. Moving the method to CodeBreakdown would centralize file-related operations, as this class is already interacting with compiled code tasks.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 70,
                        "lineEnd": 72,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method isJsonFormat to class VoidGraphStructure",
                        "description": "move method isJsonFormat to PsiClass:VoidGraphStructure\nRationale: The 'isJsonFormat()' method doesn't appear to be related to graph structures or the operations defined within the 'VoidGraphStructure' class. As such, moving the method to 'VoidGraphStructure' would not be appropriate, and it's recommended to consider another class more closely related to the operations performed in 'isJsonFormat()', specifically classes handling dashboard options or configurations.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 62,
                        "lineEnd": 64,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method isCodeBreakdownDumped to class CodeBreakdown",
                        "description": "move method isCodeBreakdownDumped to PsiClass:CodeBreakdown\nRationale: The method `isCodeBreakdownDumped()` checks if specific dashboard options are enabled, which ties closely with the functionality that manages code breakdowns. The `CodeBreakdown` class seems to cater to the code analysis and keeping track of compilation data. This makes it a more suitable class for managing whether the code breakdown state is to be dumped.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 54,
                        "lineEnd": 56,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method isHeapBreakdownDumped to class CodeBreakdown",
                        "description": "move method isHeapBreakdownDumped to PsiClass:CodeBreakdown\nRationale: The method `isHeapBreakdownDumped` checks specific dashboard options that seem to be related to some sort of feature breakdown or analysis. Given that `CodeBreakdown` holds state related to compilation tasks and performs some kind of data aggregation and analysis, it makes sense to move the method here. This class is likely involved in areas where such a check would be necessary to decide whether a heap breakdown dump is required.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 58,
                        "lineEnd": 60,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method isPointsToDumped to class CodeBreakdown",
                        "description": "move method isPointsToDumped to PsiClass:CodeBreakdown\nRationale: The `isPointsToDumped` method checks a dashboard-related option, suggesting it is related to state or behavior that may tie in with compilation details. The `CodeBreakdown` class handles post-compilation data extraction and possesses a boolean state and a compilation access feature. Moving `isPointsToDumped` here aligns it with the context of managing and accessing compilation-related data. It doesn't logically fit with `InflatableArrayList` which deals with list manipulations, nor does it belong to `VoidGraphStructure` which deals with graph structure representations.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 66,
                        "lineEnd": 68,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method isBgvFormat to class CodeBreakdown",
                        "description": "move method isBgvFormat to PsiClass:CodeBreakdown\nRationale: The method `isBgvFormat` checks a value from `DashboardOptions.DashboardBgv`, which implies that it is concerned with some higher-level logic related to the code's configuration or state. The `CodeBreakdown` class, which already deals with building data and accessing post-compilation information, appears to be a better fit since it is likely involved with configuration states and statistics gathering. The `InflatableArrayList` and `VoidGraphStructure` classes, on the other hand, deal with specific data structures and graph operations, respectively, neither of which aligns with the purpose of `isBgvFormat`.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 74,
                        "lineEnd": 76,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method isPretty to class CodeBreakdown",
                        "description": "move method isPretty to PsiClass:CodeBreakdown\nRationale: The method `isPretty()` is related to checking a dashboard's prettiness setting, which seems to be a configuration or a static behavior check. The `CodeBreakdown` class deals with compilation tasks and has instances where settings or configurations could be applied or checked during the compiling process. It makes sense to move this method to `CodeBreakdown` because its function could directly relate to how compilation data is displayed or processed.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 205,
                        "lineEnd": 216,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method toJson to class CodeBreakdown",
                        "description": "Move method toJson to com.oracle.svm.hosted.dashboard.CodeBreakdown\nRationale: The toJson method is closely related to the CodeBreakdown class because it operates on its internal state to serialize it into JSON. It calls the build() method from the CodeBreakdown class and uses getData() to access the internal data structure. Given these dependencies, it is more logical for the method to reside within the CodeBreakdown class. This allows the method to directly access the internal state without needing to expose internal details or methods unnecessarily.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "isHeapBreakdownDumped",
                            "method_signature": "private static boolean isHeapBreakdownDumped()",
                            "target_class": "DashboardOptions",
                            "rationale": "The method isHeapBreakdownDumped() is more related to the state of DashboardOptions rather than the core functionality of DashboardDumpFeature."
                        },
                        {
                            "method_name": "isPointsToDumped",
                            "method_signature": "private static boolean isPointsToDumped()",
                            "target_class": "DashboardOptions",
                            "rationale": "The method isPointsToDumped() depends on DashboardOptions and should be co-located with similar options methods."
                        },
                        {
                            "method_name": "isCodeBreakdownDumped",
                            "method_signature": "private static boolean isCodeBreakdownDumped()",
                            "target_class": "DashboardOptions",
                            "rationale": "The method isCodeBreakdownDumped() is checking options specific to DashboardOptions and belongs there."
                        },
                        {
                            "method_name": "isBgvFormat",
                            "method_signature": "private static boolean isBgvFormat()",
                            "target_class": "DashboardOptions",
                            "rationale": "The method isBgvFormat() is a formatting option specific to DashboardOptions and should be part of it."
                        },
                        {
                            "method_name": "isJsonFormat",
                            "method_signature": "private static boolean isJsonFormat()",
                            "target_class": "DashboardOptions",
                            "rationale": "The method isJsonFormat() checks a formatting option specific to DashboardOptions, thus it should be moved there."
                        },
                        {
                            "method_name": "isPretty",
                            "method_signature": "private static boolean isPretty()",
                            "target_class": "DashboardOptions",
                            "rationale": "The method isPretty() determines if pretty printing is enabled, which is an option and should be part of DashboardOptions."
                        },
                        {
                            "method_name": "getFile",
                            "method_signature": "private static Path getFile(String extension)",
                            "target_class": "DashboardOptions",
                            "rationale": "The method getFile() handles file naming conventions based on options, making it a better fit within DashboardOptions."
                        },
                        {
                            "method_name": "isSane",
                            "method_signature": "private static boolean isSane()",
                            "target_class": "DashboardOptions",
                            "rationale": "The method isSane() aggregates multiple option checks from DashboardOptions, so it logically belongs there."
                        }
                    ],
                    "llm_response_time": 6097
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "isHeapBreakdownDumped",
                            "method_signature": "private static boolean isHeapBreakdownDumped()",
                            "target_class": "DashboardOptions",
                            "rationale": "The method checks options related to the dashboard configuration, which fits more naturally within the DashboardOptions class."
                        },
                        {
                            "method_name": "isPointsToDumped",
                            "method_signature": "private static boolean isPointsToDumped()",
                            "target_class": "DashboardOptions",
                            "rationale": "Similar to isHeapBreakdownDumped, this method also checks specific dashboard options and should be moved to the DashboardOptions class."
                        },
                        {
                            "method_name": "isCodeBreakdownDumped",
                            "method_signature": "private static boolean isCodeBreakdownDumped()",
                            "target_class": "DashboardOptions",
                            "rationale": "The method is mainly related to dashboard option checks, making DashboardOptions a more appropriate class."
                        },
                        {
                            "method_name": "isBgvFormat",
                            "method_signature": "private static boolean isBgvFormat()",
                            "target_class": "DashboardOptions",
                            "rationale": "This method checks for a specific format option, which is relevant to dashboard options and should be moved to the DashboardOptions class."
                        },
                        {
                            "method_name": "isJsonFormat",
                            "method_signature": "private static boolean isJsonFormat()",
                            "target_class": "DashboardOptions",
                            "rationale": "Just like isBgvFormat, this method deals with the format options and should reside in DashboardOptions."
                        },
                        {
                            "method_name": "isPretty",
                            "method_signature": "private static boolean isPretty()",
                            "target_class": "DashboardOptions",
                            "rationale": "The method checks for a pretty-print option\u2014it\u2019s directly related to dashboard options and thus belongs in the DashboardOptions class."
                        },
                        {
                            "method_name": "getFile",
                            "method_signature": "private static Path getFile(String extension)",
                            "target_class": "DashboardOptions",
                            "rationale": "Generating file paths based on dashboard options is more related to configuration settings and would be better placed within the DashboardOptions class."
                        }
                    ],
                    "llm_response_time": 5665
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "isHeapBreakdownDumped",
                            "method_signature": "private static boolean isHeapBreakdownDumped()",
                            "target_class": "DashboardOptions",
                            "rationale": "The method isHeapBreakdownDumped() mainly operates on values from the DashboardOptions class. It would be more coherent to have this logic inside DashboardOptions, consolidating related configuration checks."
                        },
                        {
                            "method_name": "isPointsToDumped",
                            "method_signature": "private static boolean isPointsToDumped()",
                            "target_class": "DashboardOptions",
                            "rationale": "Similar to isHeapBreakdownDumped(), isPointsToDumped() checks configuration values from DashboardOptions. Moving it there keeps configuration logic encapsulated."
                        },
                        {
                            "method_name": "isCodeBreakdownDumped",
                            "method_signature": "private static boolean isCodeBreakdownDumped()",
                            "target_class": "DashboardOptions",
                            "rationale": "As with the other methods, isCodeBreakdownDumped() primarily concerns itself with checking DashboardOptions and should ideally be placed there."
                        },
                        {
                            "method_name": "isBgvFormat",
                            "method_signature": "private static boolean isBgvFormat()",
                            "target_class": "DashboardOptions",
                            "rationale": "The method isBgvFormat() checks a configuration setting in DashboardOptions, indicating that it logically belongs in that class."
                        },
                        {
                            "method_name": "isJsonFormat",
                            "method_signature": "private static boolean isJsonFormat()",
                            "target_class": "DashboardOptions",
                            "rationale": "isJsonFormat() checks the DashboardOptions to determine if the format is JSON, so it should be moved to DashboardOptions."
                        },
                        {
                            "method_name": "isPretty",
                            "method_signature": "private static boolean isPretty()",
                            "target_class": "DashboardOptions",
                            "rationale": "isPretty() directly relates to the DashboardOptions class and should therefore be moved to it to maintain cohesion."
                        },
                        {
                            "method_name": "getFile",
                            "method_signature": "private static Path getFile(String extension)",
                            "target_class": "DashboardOptions",
                            "rationale": "getFile() constructs a file path based on values from DashboardOptions. Moving it to DashboardOptions aligns the method with its primary data source."
                        },
                        {
                            "method_name": "isSane",
                            "method_signature": "private static boolean isSane()",
                            "target_class": "DashboardOptions",
                            "rationale": "The method isSane() consolidates multiple checks that are based on DashboardOptions. Placing it within DashboardOptions encapsulates these related behaviors."
                        }
                    ],
                    "llm_response_time": 6298
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "isHeapBreakdownDumped",
                            "method_signature": "private static isHeapBreakdownDumped()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isPointsToDumped",
                            "method_signature": "private static isPointsToDumped()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isCodeBreakdownDumped",
                            "method_signature": "private static isCodeBreakdownDumped()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isBgvFormat",
                            "method_signature": "private static isBgvFormat()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isJsonFormat",
                            "method_signature": "private static isJsonFormat()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isPretty",
                            "method_signature": "private static isPretty()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getFile",
                            "method_signature": "private static getFile(String extension)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "toJson",
                            "method_signature": "private toJson(CodeBreakdown dump, JsonBuilder.ObjectBuilder builder)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "getFile",
                            "method_signature": "private static getFile(String extension)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isJsonFormat",
                            "method_signature": "private static isJsonFormat()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isCodeBreakdownDumped",
                            "method_signature": "private static isCodeBreakdownDumped()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isHeapBreakdownDumped",
                            "method_signature": "private static isHeapBreakdownDumped()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isPointsToDumped",
                            "method_signature": "private static isPointsToDumped()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isBgvFormat",
                            "method_signature": "private static isBgvFormat()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isPretty",
                            "method_signature": "private static isPretty()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "toJson",
                            "method_signature": "private toJson(CodeBreakdown dump, JsonBuilder.ObjectBuilder builder)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "private static getFile(String extension)": {
                        "first": {
                            "method_name": "getFile",
                            "method_signature": "private static getFile(String extension)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.48906281744335167
                    },
                    "private static isJsonFormat()": {
                        "first": {
                            "method_name": "isJsonFormat",
                            "method_signature": "private static isJsonFormat()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5135264993127422
                    },
                    "private static isCodeBreakdownDumped()": {
                        "first": {
                            "method_name": "isCodeBreakdownDumped",
                            "method_signature": "private static isCodeBreakdownDumped()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5181660265978684
                    },
                    "private static isHeapBreakdownDumped()": {
                        "first": {
                            "method_name": "isHeapBreakdownDumped",
                            "method_signature": "private static isHeapBreakdownDumped()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5204861582335072
                    },
                    "private static isPointsToDumped()": {
                        "first": {
                            "method_name": "isPointsToDumped",
                            "method_signature": "private static isPointsToDumped()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5204861582335072
                    },
                    "private static isBgvFormat()": {
                        "first": {
                            "method_name": "isBgvFormat",
                            "method_signature": "private static isBgvFormat()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5585558742605552
                    },
                    "private static isPretty()": {
                        "first": {
                            "method_name": "isPretty",
                            "method_signature": "private static isPretty()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5611475284301536
                    },
                    "private toJson(CodeBreakdown dump, JsonBuilder.ObjectBuilder builder)": {
                        "first": {
                            "method_name": "toJson",
                            "method_signature": "private toJson(CodeBreakdown dump, JsonBuilder.ObjectBuilder builder)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6823082192126828
                    }
                },
                "voyage": {
                    "private static getFile(String extension)": {
                        "first": {
                            "method_name": "getFile",
                            "method_signature": "private static getFile(String extension)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.36802487612903645
                    },
                    "private static isBgvFormat()": {
                        "first": {
                            "method_name": "isBgvFormat",
                            "method_signature": "private static isBgvFormat()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4338469537453747
                    },
                    "private static isJsonFormat()": {
                        "first": {
                            "method_name": "isJsonFormat",
                            "method_signature": "private static isJsonFormat()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.47937175053232745
                    },
                    "private static isPretty()": {
                        "first": {
                            "method_name": "isPretty",
                            "method_signature": "private static isPretty()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4873350171393243
                    },
                    "private toJson(CodeBreakdown dump, JsonBuilder.ObjectBuilder builder)": {
                        "first": {
                            "method_name": "toJson",
                            "method_signature": "private toJson(CodeBreakdown dump, JsonBuilder.ObjectBuilder builder)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.49915774954815684
                    },
                    "private static isPointsToDumped()": {
                        "first": {
                            "method_name": "isPointsToDumped",
                            "method_signature": "private static isPointsToDumped()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5564586592592281
                    },
                    "private static isCodeBreakdownDumped()": {
                        "first": {
                            "method_name": "isCodeBreakdownDumped",
                            "method_signature": "private static isCodeBreakdownDumped()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5782552338164744
                    },
                    "private static isHeapBreakdownDumped()": {
                        "first": {
                            "method_name": "isHeapBreakdownDumped",
                            "method_signature": "private static isHeapBreakdownDumped()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6033962065984392
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private static getFile(String extension)",
                        "private toJson(CodeBreakdown dump, JsonBuilder.ObjectBuilder builder)",
                        "private static isJsonFormat()",
                        "private static isBgvFormat()",
                        "private static isCodeBreakdownDumped()",
                        "private static isHeapBreakdownDumped()",
                        "private static isPointsToDumped()",
                        "private static isPretty()"
                    ],
                    "llm_response_time": 4590
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "private static getFile(String extension)",
                        "private static isJsonFormat()",
                        "private static isCodeBreakdownDumped()",
                        "private static isHeapBreakdownDumped()",
                        "private static isPointsToDumped()"
                    ],
                    "llm_response_time": 3779
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private static getFile(String extension)",
                        "private static isJsonFormat()",
                        "private static isCodeBreakdownDumped()"
                    ],
                    "llm_response_time": 1231
                },
                "voyage": {
                    "priority_method_names": [
                        "private static getFile(String extension)",
                        "private toJson(CodeBreakdown dump, JsonBuilder.ObjectBuilder builder)",
                        "private static isHeapBreakdownDumped()",
                        "private static isPointsToDumped()",
                        "private static isCodeBreakdownDumped()",
                        "private static isJsonFormat()",
                        "private static isPretty()",
                        "private static isBgvFormat()"
                    ],
                    "llm_response_time": 5779
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private static getFile(String extension)",
                        "private toJson(CodeBreakdown dump, JsonBuilder.ObjectBuilder builder)",
                        "private static isJsonFormat()",
                        "private static isBgvFormat()",
                        "private static isPretty()"
                    ],
                    "llm_response_time": 3410
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private static getFile(String extension)",
                        "private static isJsonFormat()",
                        "private static isBgvFormat()"
                    ],
                    "llm_response_time": 1300
                }
            },
            "targetClassMap": {
                "getFile": {
                    "target_classes": [
                        {
                            "class_name": "DashboardTypeFlowNames",
                            "similarity_score": 0.3358614856998334
                        },
                        {
                            "class_name": "PointsToBreakdown",
                            "similarity_score": 0.42617901109610934
                        },
                        {
                            "class_name": "VoidGraphStructure",
                            "similarity_score": 0.3356363135746585
                        },
                        {
                            "class_name": "Port",
                            "similarity_score": 0.35610392357834175
                        },
                        {
                            "class_name": "CodeBreakdown",
                            "similarity_score": 0.4868284355300601
                        },
                        {
                            "class_name": "InflatableArrayList",
                            "similarity_score": 0.40397858162338846
                        },
                        {
                            "class_name": "HeapBreakdown",
                            "similarity_score": 0.5437780169711197
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CodeBreakdown",
                        "PointsToBreakdown",
                        "HeapBreakdown"
                    ],
                    "llm_response_time": 4095,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "isJsonFormat": {
                    "target_classes": [
                        {
                            "class_name": "VoidGraphStructure",
                            "similarity_score": 0.4109656851564354
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "VoidGraphStructure"
                    ],
                    "llm_response_time": 1931,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "isCodeBreakdownDumped": {
                    "target_classes": [
                        {
                            "class_name": "DashboardTypeFlowNames",
                            "similarity_score": 0.2611714500396042
                        },
                        {
                            "class_name": "PointsToBreakdown",
                            "similarity_score": 0.3301103168860377
                        },
                        {
                            "class_name": "CodeBreakdown",
                            "similarity_score": 0.4290412953563084
                        },
                        {
                            "class_name": "Port",
                            "similarity_score": 0.3909350184867624
                        },
                        {
                            "class_name": "InflatableArrayList",
                            "similarity_score": 0.46073929912086503
                        },
                        {
                            "class_name": "HeapBreakdown",
                            "similarity_score": 0.3719924439802217
                        },
                        {
                            "class_name": "VoidGraphStructure",
                            "similarity_score": 0.4109656851564354
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CodeBreakdown",
                        "VoidGraphStructure",
                        "InflatableArrayList"
                    ],
                    "llm_response_time": 3325,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "isHeapBreakdownDumped": {
                    "target_classes": [
                        {
                            "class_name": "DashboardTypeFlowNames",
                            "similarity_score": 0.2611714500396042
                        },
                        {
                            "class_name": "PointsToBreakdown",
                            "similarity_score": 0.3301103168860377
                        },
                        {
                            "class_name": "InflatableArrayList",
                            "similarity_score": 0.46073929912086503
                        },
                        {
                            "class_name": "HeapBreakdown",
                            "similarity_score": 0.3719924439802217
                        },
                        {
                            "class_name": "CodeBreakdown",
                            "similarity_score": 0.4290412953563084
                        },
                        {
                            "class_name": "VoidGraphStructure",
                            "similarity_score": 0.4109656851564354
                        },
                        {
                            "class_name": "Port",
                            "similarity_score": 0.3909350184867624
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CodeBreakdown",
                        "VoidGraphStructure",
                        "InflatableArrayList"
                    ],
                    "llm_response_time": 3197,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "isPointsToDumped": {
                    "target_classes": [
                        {
                            "class_name": "DashboardTypeFlowNames",
                            "similarity_score": 0.2611714500396042
                        },
                        {
                            "class_name": "PointsToBreakdown",
                            "similarity_score": 0.3301103168860377
                        },
                        {
                            "class_name": "InflatableArrayList",
                            "similarity_score": 0.46073929912086503
                        },
                        {
                            "class_name": "CodeBreakdown",
                            "similarity_score": 0.4290412953563084
                        },
                        {
                            "class_name": "HeapBreakdown",
                            "similarity_score": 0.3719924439802217
                        },
                        {
                            "class_name": "VoidGraphStructure",
                            "similarity_score": 0.4109656851564354
                        },
                        {
                            "class_name": "Port",
                            "similarity_score": 0.3909350184867624
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CodeBreakdown",
                        "InflatableArrayList",
                        "VoidGraphStructure"
                    ],
                    "llm_response_time": 2362,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "isBgvFormat": {
                    "target_classes": [
                        {
                            "class_name": "DashboardTypeFlowNames",
                            "similarity_score": 0.29199855803537256
                        },
                        {
                            "class_name": "PointsToBreakdown",
                            "similarity_score": 0.3656036337420877
                        },
                        {
                            "class_name": "InflatableArrayList",
                            "similarity_score": 0.5151221963699316
                        },
                        {
                            "class_name": "CodeBreakdown",
                            "similarity_score": 0.4796827507856352
                        },
                        {
                            "class_name": "HeapBreakdown",
                            "similarity_score": 0.415900195928029
                        },
                        {
                            "class_name": "VoidGraphStructure",
                            "similarity_score": 0.4594736042147829
                        },
                        {
                            "class_name": "Port",
                            "similarity_score": 0.43707863806076885
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CodeBreakdown",
                        "VoidGraphStructure",
                        "InflatableArrayList"
                    ],
                    "llm_response_time": 3879,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "isPretty": {
                    "target_classes": [
                        {
                            "class_name": "DashboardTypeFlowNames",
                            "similarity_score": 0.29199855803537256
                        },
                        {
                            "class_name": "PointsToBreakdown",
                            "similarity_score": 0.3656036337420877
                        },
                        {
                            "class_name": "InflatableArrayList",
                            "similarity_score": 0.5151221963699316
                        },
                        {
                            "class_name": "HeapBreakdown",
                            "similarity_score": 0.415900195928029
                        },
                        {
                            "class_name": "CodeBreakdown",
                            "similarity_score": 0.4796827507856352
                        },
                        {
                            "class_name": "VoidGraphStructure",
                            "similarity_score": 0.4594736042147829
                        },
                        {
                            "class_name": "Port",
                            "similarity_score": 0.43707863806076885
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CodeBreakdown",
                        "VoidGraphStructure",
                        "InflatableArrayList"
                    ],
                    "llm_response_time": 3448,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "toJson": {
                    "target_classes": [
                        {
                            "class_name": "CodeBreakdown",
                            "similarity_score": 0.6387628544802596
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "CodeBreakdown"
                    ],
                    "llm_response_time": 2811,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "e2b81f790c3f1c2e2d2b137ea1ff1824a6f696e2",
        "url": "https://github.com/oracle/graal/commit/e2b81f790c3f1c2e2d2b137ea1ff1824a6f696e2",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public registerAsUnsafeAllocated(reason Object) : boolean extracted from private registerClass(condition ConfigurationCondition, clazz Class<?>, unsafeInstantiated boolean, allowForName boolean) : void in class com.oracle.svm.hosted.reflect.ReflectionDataBuilder & moved to class com.oracle.graal.pointsto.meta.AnalysisType",
            "leftSideLocations": [
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/reflect/ReflectionDataBuilder.java",
                    "startLine": 226,
                    "endLine": 258,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "private registerClass(condition ConfigurationCondition, clazz Class<?>, unsafeInstantiated boolean, allowForName boolean) : void"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/reflect/ReflectionDataBuilder.java",
                    "startLine": 234,
                    "endLine": 234,
                    "startColumn": 13,
                    "endColumn": 74,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "substratevm/src/com.oracle.graal.pointsto/src/com/oracle/graal/pointsto/meta/AnalysisType.java",
                    "startLine": 531,
                    "endLine": 534,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public registerAsUnsafeAllocated(reason Object) : boolean"
                },
                {
                    "filePath": "substratevm/src/com.oracle.graal.pointsto/src/com/oracle/graal/pointsto/meta/AnalysisType.java",
                    "startLine": 532,
                    "endLine": 532,
                    "startColumn": 9,
                    "endColumn": 40,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/reflect/ReflectionDataBuilder.java",
                    "startLine": 226,
                    "endLine": 258,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "private registerClass(condition ConfigurationCondition, clazz Class<?>, unsafeInstantiated boolean, allowForName boolean) : void"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/reflect/ReflectionDataBuilder.java",
                    "startLine": 234,
                    "endLine": 234,
                    "startColumn": 13,
                    "endColumn": 76,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "type.registerAsUnsafeAllocated(\"Is registered for reflection.\")"
                },
                {
                    "filePath": "substratevm/src/com.oracle.graal.pointsto/src/com/oracle/graal/pointsto/meta/AnalysisType.java",
                    "startLine": 533,
                    "endLine": 533,
                    "startColumn": 9,
                    "endColumn": 78,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                }
            ],
            "isStatic": false
        },
        "ref_id": 497,
        "extraction_results": {
            "success": true,
            "newCommitHash": "ecc656d04d0eff6ad53d74d5179f005b36b3d0fc",
            "newBranchName": "extract-registerAsUnsafeAllocated-registerClass-a25a7b6"
        },
        "telemetry": {
          "id": "934551fb-58aa-4907-abe3-60cb9a5d1fcb",
          "hostFunctionTelemetryData": {
            "hostFunctionSize": 1088,
            "lineStart": 102,
            "lineEnd": 1189,
            "bodyLineStart": 102,
            "language": "java",
            "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/reflect/ReflectionDataBuilder.java",
            "sourceCode": "public class ReflectionDataBuilder extends ConditionalConfigurationRegistry implements RuntimeReflectionSupport, ReflectionHostedSupport {\n    private AnalysisMetaAccess metaAccess;\n    private AnalysisUniverse universe;\n    private final SubstrateAnnotationExtractor annotationExtractor;\n    private BeforeAnalysisAccessImpl analysisAccess;\n\n    private boolean sealed;\n\n    // Reflection data\n    private final Map<Class<?>, RecordComponent[]> registeredRecordComponents = new ConcurrentHashMap<>();\n\n    /**\n     * Member classes accessible for reflection through {@link Class#getDeclaredClasses()} and\n     * {@link Class#getClasses()}.\n     */\n    private final Map<Class<?>, Set<Class<?>>> innerClasses = new ConcurrentHashMap<>();\n    private final Map<Class<?>, Integer> enabledQueriesFlags = new ConcurrentHashMap<>();\n    private final Map<AnalysisField, Field> registeredFields = new ConcurrentHashMap<>();\n    private final Set<AnalysisField> hidingFields = ConcurrentHashMap.newKeySet();\n    private final Map<AnalysisMethod, Executable> registeredMethods = new ConcurrentHashMap<>();\n    private final Map<AnalysisMethod, Object> methodAccessors = new ConcurrentHashMap<>();\n    private final Set<AnalysisMethod> hidingMethods = ConcurrentHashMap.newKeySet();\n\n    // Heap reflection data\n    private final Set<DynamicHub> heapDynamicHubs = ConcurrentHashMap.newKeySet();\n    private final Map<AnalysisField, Field> heapFields = new ConcurrentHashMap<>();\n    private final Map<AnalysisMethod, Executable> heapMethods = new ConcurrentHashMap<>();\n\n    // Negative queries\n    private final Map<AnalysisType, Set<String>> negativeFieldLookups = new ConcurrentHashMap<>();\n    private final Map<AnalysisType, Set<AnalysisMethod.Signature>> negativeMethodLookups = new ConcurrentHashMap<>();\n    private final Map<AnalysisType, Set<AnalysisType[]>> negativeConstructorLookups = new ConcurrentHashMap<>();\n\n    // Linkage error handling\n    private final Map<Class<?>, Throwable> classLookupExceptions = new ConcurrentHashMap<>();\n    private final Map<Class<?>, Throwable> fieldLookupExceptions = new ConcurrentHashMap<>();\n    private final Map<Class<?>, Throwable> methodLookupExceptions = new ConcurrentHashMap<>();\n    private final Map<Class<?>, Throwable> constructorLookupExceptions = new ConcurrentHashMap<>();\n\n    // Intermediate bookkeeping\n    private final Map<Type, Set<Integer>> processedTypes = new ConcurrentHashMap<>();\n    private final Map<Class<?>, Set<Method>> pendingRecordClasses;\n\n    record ConditionalTask(ConfigurationCondition condition, Consumer<ConfigurationCondition> task) {\n    }\n\n    private final Set<ConditionalTask> pendingConditionalTasks = ConcurrentHashMap.newKeySet();\n\n    // Annotations handling\n    private final Map<AnnotatedElement, AnnotationValue[]> filteredAnnotations = new ConcurrentHashMap<>();\n    private final Map<AnalysisMethod, AnnotationValue[][]> filteredParameterAnnotations = new ConcurrentHashMap<>();\n    private final Map<AnnotatedElement, TypeAnnotationValue[]> filteredTypeAnnotations = new ConcurrentHashMap<>();\n\n    ReflectionDataBuilder(SubstrateAnnotationExtractor annotationExtractor) {\n        this.annotationExtractor = annotationExtractor;\n        pendingRecordClasses = !throwMissingRegistrationErrors() ? new ConcurrentHashMap<>() : null;\n    }\n\n    public void duringSetup(AnalysisMetaAccess analysisMetaAccess, AnalysisUniverse analysisUniverse) {\n        this.metaAccess = analysisMetaAccess;\n        this.universe = analysisUniverse;\n        for (var conditionalTask : pendingConditionalTasks) {\n            registerConditionalConfiguration(conditionalTask.condition, (cnd) -> universe.getBigbang().postTask(debug -> conditionalTask.task.accept(cnd)));\n        }\n        pendingConditionalTasks.clear();\n    }\n\n    public void beforeAnalysis(BeforeAnalysisAccessImpl beforeAnalysisAccess) {\n        this.analysisAccess = beforeAnalysisAccess;\n    }\n\n    private void runConditionalInAnalysisTask(ConfigurationCondition condition, Consumer<ConfigurationCondition> task) {\n        if (sealed) {\n            throw UserError.abort(\"Too late to add classes, methods, and fields for reflective access. Registration must happen in a Feature before the analysis has finished.\");\n        }\n\n        if (universe != null) {\n            registerConditionalConfiguration(condition, (cnd) -> universe.getBigbang().postTask(debug -> task.accept(cnd)));\n        } else {\n            pendingConditionalTasks.add(new ConditionalTask(condition, task));\n            VMError.guarantee(universe == null, \"There shouldn't be a race condition on Feature.duringSetup.\");\n        }\n    }\n\n    private void setQueryFlag(Class<?> clazz, int flag) {\n        enabledQueriesFlags.compute(clazz, (key, oldValue) -> (oldValue == null) ? flag : (oldValue | flag));\n    }\n\n    @Override\n    public void register(ConfigurationCondition condition, boolean unsafeInstantiated, Class<?> clazz) {\n        Objects.requireNonNull(clazz, () -> nullErrorMessage(\"class\"));\n        runConditionalInAnalysisTask(condition, (cnd) -> registerClass(cnd, clazz, unsafeInstantiated, true));\n    }\n\n    @Override\n    public void registerAllClassesQuery(ConfigurationCondition condition, Class<?> clazz) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            setQueryFlag(clazz, ALL_CLASSES_FLAG);\n            try {\n                for (Class<?> innerClass : clazz.getClasses()) {\n                    innerClasses.computeIfAbsent(innerClass.getDeclaringClass(), c -> ConcurrentHashMap.newKeySet()).add(innerClass);\n                    registerClass(cnd, innerClass, false, !MissingRegistrationUtils.throwMissingRegistrationErrors());\n                }\n            } catch (LinkageError e) {\n                registerLinkageError(clazz, e, classLookupExceptions);\n            }\n        });\n    }\n\n    @Override\n    public void registerAllDeclaredClassesQuery(ConfigurationCondition condition, Class<?> clazz) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            setQueryFlag(clazz, ALL_DECLARED_CLASSES_FLAG);\n            try {\n                for (Class<?> innerClass : clazz.getDeclaredClasses()) {\n                    innerClasses.computeIfAbsent(clazz, c -> ConcurrentHashMap.newKeySet()).add(innerClass);\n                    registerClass(cnd, innerClass, false, !MissingRegistrationUtils.throwMissingRegistrationErrors());\n                }\n            } catch (LinkageError e) {\n                registerLinkageError(clazz, e, classLookupExceptions);\n            }\n        });\n    }\n\n    private void registerClass(ConfigurationCondition condition, Class<?> clazz, boolean unsafeInstantiated, boolean allowForName) {\n        if (shouldExcludeClass(clazz)) {\n            return;\n        }\n\n        AnalysisType type = metaAccess.lookupJavaType(clazz);\n        type.registerAsReachable(\"Is registered for reflection.\");\n        if (unsafeInstantiated) {\n            registerAsUnsafeAllocated(type, \"Is registered for reflection.\");\n        }\n\n        if (allowForName) {\n            ClassForNameSupport.singleton().registerClass(condition, clazz);\n\n            if (!MissingRegistrationUtils.throwMissingRegistrationErrors()) {\n                /*\n                 * We have to ensure that code that relies on classes registered for reflection\n                 * being accessible through Class.get(Declared)Classes() keeps working. However,\n                 * this behavior means that those methods can return incomplete sets of inner\n                 * classes, which is not coherent with the Java specification and is therefore\n                 * disabled under the strict metadata mode (-H:ThrowMissingRegistrationErrors).\n                 */\n                try {\n                    if (clazz.getEnclosingClass() != null) {\n                        Class<?> enclosingClass = metaAccess.lookupJavaType(clazz.getEnclosingClass()).getJavaClass();\n                        innerClasses.computeIfAbsent(enclosingClass, (enclosingType) -> ConcurrentHashMap.newKeySet()).add(clazz);\n                    }\n                } catch (LinkageError e) {\n                    reportLinkingErrors(clazz, List.of(e));\n                }\n            }\n        }\n    }\n\n    private void registerAsUnsafeAllocated(AnalysisType type, String reason) {\n        type.registerAsInstantiated(reason);\n    }\n\n    @Override\n    public void registerClassLookupException(ConfigurationCondition condition, String typeName, Throwable t) {\n        runConditionalInAnalysisTask(condition, (cnd) -> ClassForNameSupport.singleton().registerExceptionForClass(cnd, typeName, t));\n    }\n\n    @Override\n    public void registerClassLookup(ConfigurationCondition condition, String typeName) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            try {\n                registerClass(cnd, Class.forName(typeName, false, ClassLoader.getSystemClassLoader()), false, true);\n            } catch (ClassNotFoundException e) {\n                ClassForNameSupport.singleton().registerNegativeQuery(cnd, typeName);\n            } catch (Throwable t) {\n                ClassForNameSupport.singleton().registerExceptionForClass(cnd, typeName, t);\n            }\n        });\n    }\n\n    @Override\n    public void registerAllRecordComponentsQuery(ConfigurationCondition condition, Class<?> clazz) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            setQueryFlag(clazz, ALL_RECORD_COMPONENTS_FLAG);\n            registerRecordComponents(clazz);\n        });\n    }\n\n    @Override\n    public void registerAllPermittedSubclassesQuery(ConfigurationCondition condition, Class<?> clazz) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            setQueryFlag(clazz, ALL_PERMITTED_SUBCLASSES_FLAG);\n            if (clazz.isSealed()) {\n                for (Class<?> permittedSubclass : clazz.getPermittedSubclasses()) {\n                    registerClass(condition, permittedSubclass, false, false);\n                }\n            }\n        });\n    }\n\n    @Override\n    public void registerAllNestMembersQuery(ConfigurationCondition condition, Class<?> clazz) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            setQueryFlag(clazz, ALL_NEST_MEMBERS_FLAG);\n            for (Class<?> nestMember : clazz.getNestMembers()) {\n                if (nestMember != clazz) {\n                    registerClass(condition, nestMember, false, false);\n                }\n            }\n        });\n    }\n\n    @Override\n    public void registerAllSignersQuery(ConfigurationCondition condition, Class<?> clazz) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            setQueryFlag(clazz, ALL_SIGNERS_FLAG);\n            Object[] signers = clazz.getSigners();\n            if (signers != null) {\n                for (Object signer : signers) {\n                    metaAccess.lookupJavaType(signer.getClass()).registerAsInstantiated(\"signer\");\n                }\n            }\n        });\n    }\n\n    @Override\n    public void register(ConfigurationCondition condition, boolean queriedOnly, Executable... executables) {\n        requireNonNull(executables, \"executable\");\n        runConditionalInAnalysisTask(condition, (cnd) -> registerMethods(queriedOnly, executables));\n    }\n\n    @Override\n    public void registerAllMethodsQuery(ConfigurationCondition condition, boolean queriedOnly, Class<?> clazz) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            for (Class<?> current = clazz; current != null; current = current.getSuperclass()) {\n                setQueryFlag(current, ALL_METHODS_FLAG);\n            }\n            try {\n                registerMethods(queriedOnly, clazz.getMethods());\n            } catch (LinkageError e) {\n                registerLinkageError(clazz, e, methodLookupExceptions);\n            }\n        });\n    }\n\n    @Override\n    public void registerAllDeclaredMethodsQuery(ConfigurationCondition condition, boolean queriedOnly, Class<?> clazz) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            setQueryFlag(clazz, ALL_DECLARED_METHODS_FLAG);\n            try {\n                registerMethods(queriedOnly, clazz.getDeclaredMethods());\n            } catch (LinkageError e) {\n                registerLinkageError(clazz, e, methodLookupExceptions);\n            }\n        });\n    }\n\n    @Override\n    public void registerAllConstructorsQuery(ConfigurationCondition condition, boolean queriedOnly, Class<?> clazz) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            for (Class<?> current = clazz; current != null; current = current.getSuperclass()) {\n                setQueryFlag(current, ALL_CONSTRUCTORS_FLAG);\n            }\n            try {\n                registerMethods(queriedOnly, clazz.getConstructors());\n            } catch (LinkageError e) {\n                registerLinkageError(clazz, e, constructorLookupExceptions);\n            }\n        });\n    }\n\n    @Override\n    public void registerAllDeclaredConstructorsQuery(ConfigurationCondition condition, boolean queriedOnly, Class<?> clazz) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            setQueryFlag(clazz, ALL_DECLARED_CONSTRUCTORS_FLAG);\n            try {\n                registerMethods(queriedOnly, clazz.getDeclaredConstructors());\n            } catch (LinkageError e) {\n                registerLinkageError(clazz, e, constructorLookupExceptions);\n            }\n        });\n    }\n\n    private void registerMethods(boolean queriedOnly, Executable[] reflectExecutables) {\n        for (Executable reflectExecutable : reflectExecutables) {\n            registerMethod(queriedOnly, reflectExecutable);\n        }\n    }\n\n    private void registerMethod(boolean queriedOnly, Executable reflectExecutable) {\n        if (SubstitutionReflectivityFilter.shouldExclude(reflectExecutable, metaAccess, universe)) {\n            return;\n        }\n\n        AnalysisMethod analysisMethod = metaAccess.lookupJavaMethod(reflectExecutable);\n        if (registeredMethods.put(analysisMethod, reflectExecutable) == null) {\n            registerTypesForMethod(analysisMethod, reflectExecutable);\n            AnalysisType declaringType = analysisMethod.getDeclaringClass();\n            Class<?> declaringClass = declaringType.getJavaClass();\n\n            /*\n             * The image needs to know about subtypes shadowing methods registered for reflection to\n             * ensure the correctness of run-time reflection queries.\n             */\n            analysisAccess.registerSubtypeReachabilityHandler(\n                            (access, subType) -> universe.getBigbang().postTask(debug -> checkSubtypeForOverridingMethod(analysisMethod, metaAccess.lookupJavaType(subType))), declaringClass);\n\n            if (declaringType.isAnnotation() && !analysisMethod.isConstructor()) {\n                processAnnotationMethod(queriedOnly, (Method) reflectExecutable);\n            }\n\n            if (!throwMissingRegistrationErrors() && declaringClass.isRecord()) {\n                pendingRecordClasses.computeIfPresent(declaringClass, (clazz, unregisteredAccessors) -> {\n                    if (unregisteredAccessors.remove(reflectExecutable) && unregisteredAccessors.isEmpty()) {\n                        registerRecordComponents(declaringClass);\n                    }\n                    return unregisteredAccessors;\n                });\n            }\n        }\n\n        /*\n         * We need to run this even if the method has already been registered, in case it was only\n         * registered as queried.\n         */\n        if (!queriedOnly) {\n            methodAccessors.computeIfAbsent(analysisMethod, aMethod -> {\n                SubstrateAccessor accessor = ImageSingletons.lookup(ReflectionFeature.class).getOrCreateAccessor(reflectExecutable);\n                universe.getHeapScanner().rescanObject(accessor);\n                return accessor;\n            });\n        }\n    }\n\n    @Override\n    public void registerMethodLookup(ConfigurationCondition condition, Class<?> declaringClass, String methodName, Class<?>... parameterTypes) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            try {\n                registerMethod(true, declaringClass.getDeclaredMethod(methodName, parameterTypes));\n            } catch (NoSuchMethodException e) {\n                negativeMethodLookups.computeIfAbsent(metaAccess.lookupJavaType(declaringClass), (key) -> ConcurrentHashMap.newKeySet())\n                                .add(new AnalysisMethod.Signature(methodName, metaAccess.lookupJavaTypes(parameterTypes)));\n            }\n        });\n    }\n\n    @Override\n    public void registerConstructorLookup(ConfigurationCondition condition, Class<?> declaringClass, Class<?>... parameterTypes) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            try {\n                registerMethod(true, declaringClass.getDeclaredConstructor(parameterTypes));\n            } catch (NoSuchMethodException e) {\n                negativeConstructorLookups.computeIfAbsent(metaAccess.lookupJavaType(declaringClass), (key) -> ConcurrentHashMap.newKeySet())\n                                .add(metaAccess.lookupJavaTypes(parameterTypes));\n            }\n        });\n    }\n\n    @Override\n    public void register(ConfigurationCondition condition, boolean finalIsWritable, Field... fields) {\n        requireNonNull(fields, \"field\");\n        runConditionalInAnalysisTask(condition, (cnd) -> registerFields(false, fields));\n    }\n\n    @Override\n    public void registerAllFieldsQuery(ConfigurationCondition condition, Class<?> clazz) {\n        registerAllFieldsQuery(condition, false, clazz);\n    }\n\n    private void registerAllFieldsQuery(ConfigurationCondition condition, boolean queriedOnly, Class<?> clazz) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            for (Class<?> current = clazz; current != null; current = current.getSuperclass()) {\n                setQueryFlag(current, ALL_FIELDS_FLAG);\n            }\n            try {\n                registerFields(queriedOnly, clazz.getFields());\n            } catch (LinkageError e) {\n                registerLinkageError(clazz, e, fieldLookupExceptions);\n            }\n        });\n    }\n\n    @Override\n    public void registerAllDeclaredFieldsQuery(ConfigurationCondition condition, Class<?> clazz) {\n        registerAllDeclaredFieldsQuery(condition, false, clazz);\n    }\n\n    private void registerAllDeclaredFieldsQuery(ConfigurationCondition condition, boolean queriedOnly, Class<?> clazz) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            setQueryFlag(clazz, ALL_DECLARED_FIELDS_FLAG);\n            try {\n                registerFields(queriedOnly, clazz.getDeclaredFields());\n            } catch (LinkageError e) {\n                registerLinkageError(clazz, e, fieldLookupExceptions);\n            }\n        });\n    }\n\n    private void registerFields(boolean queriedOnly, Field[] reflectFields) {\n        for (Field reflectField : reflectFields) {\n            registerField(queriedOnly, reflectField);\n        }\n    }\n\n    private void registerField(boolean queriedOnly, Field reflectField) {\n        if (SubstitutionReflectivityFilter.shouldExclude(reflectField, metaAccess, universe)) {\n            return;\n        }\n\n        AnalysisField analysisField = metaAccess.lookupJavaField(reflectField);\n        if (registeredFields.put(analysisField, reflectField) == null) {\n            registerTypesForField(analysisField, reflectField, true);\n            AnalysisType declaringClass = analysisField.getDeclaringClass();\n\n            /*\n             * The image needs to know about subtypes shadowing fields registered for reflection to\n             * ensure the correctness of run-time reflection queries.\n             */\n            analysisAccess.registerSubtypeReachabilityHandler(\n                            (access, subType) -> universe.getBigbang().postTask(debug -> checkSubtypeForOverridingField(analysisField, metaAccess.lookupJavaType(subType))),\n                            declaringClass.getJavaClass());\n\n            if (declaringClass.isAnnotation()) {\n                processAnnotationField(reflectField);\n            }\n        }\n\n        /*\n         * We need to run this even if the method has already been registered, in case it was only\n         * registered as queried.\n         */\n        if (!queriedOnly) {\n            registerTypesForField(analysisField, reflectField, false);\n        }\n    }\n\n    @Override\n    public void registerFieldLookup(ConfigurationCondition condition, Class<?> declaringClass, String fieldName) {\n        runConditionalInAnalysisTask(condition, (cnd) -> {\n            try {\n                registerField(false, declaringClass.getDeclaredField(fieldName));\n            } catch (NoSuchFieldException e) {\n                negativeFieldLookups.computeIfAbsent(metaAccess.lookupJavaType(declaringClass), (key) -> ConcurrentHashMap.newKeySet()).add(fieldName);\n            }\n        });\n    }\n\n    /*\n     * Proxy classes for annotations present the annotation default methods and fields as their own.\n     */\n    @SuppressWarnings(\"deprecation\")\n    private void processAnnotationMethod(boolean queriedOnly, Method method) {\n        Class<?> annotationClass = method.getDeclaringClass();\n        Class<?> proxyClass = Proxy.getProxyClass(annotationClass.getClassLoader(), annotationClass);\n        try {\n            var condition = ConfigurationCondition.create(proxyClass, true);\n            register(condition, queriedOnly, proxyClass.getDeclaredMethod(method.getName(), method.getParameterTypes()));\n        } catch (NoSuchMethodException e) {\n            /*\n             * The annotation member is not present in the proxy class so we don't add it.\n             */\n        }\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private void processAnnotationField(Field field) {\n        Class<?> annotationClass = field.getDeclaringClass();\n        Class<?> proxyClass = Proxy.getProxyClass(annotationClass.getClassLoader(), annotationClass);\n        try {\n            var condition = ConfigurationCondition.create(proxyClass, true);\n            register(condition, false, proxyClass.getDeclaredField(field.getName()));\n        } catch (NoSuchFieldException e) {\n            /*\n             * The annotation member is not present in the proxy class so we don't add it.\n             */\n        }\n    }\n\n    /**\n     * @see ReflectionHostedSupport#getHidingReflectionFields()\n     */\n    private void checkSubtypeForOverridingField(AnalysisField field, AnalysisType subtype) {\n        try {\n            ResolvedJavaField[] subClassFields = field.isStatic() ? subtype.getStaticFields() : subtype.getInstanceFields(false);\n            for (ResolvedJavaField javaField : subClassFields) {\n                AnalysisField subclassField = (AnalysisField) javaField;\n                if (subclassField.getName().equals(field.getName())) {\n                    hidingFields.add(subclassField);\n                }\n            }\n        } catch (UnsupportedFeatureException | LinkageError e) {\n            /*\n             * A field that is not supposed to end up in the image is considered as being absent for\n             * reflection purposes.\n             */\n        }\n    }\n\n    /**\n     * Using {@link AnalysisType#findMethod(String, Signature)} here which uses\n     * {@link Class#getDeclaredMethods()} internally, instead of\n     * {@link AnalysisType#resolveConcreteMethod(ResolvedJavaMethod)} which gives different results\n     * in at least two scenarios:\n     * <p>\n     * 1) When resolving a static method, resolveConcreteMethod does not return a subclass method\n     * with the same signature, since they are actually fully distinct methods. However, these\n     * methods need to be included in the hiding list because them showing up in a reflection query\n     * would be wrong.\n     * <p>\n     * 2) When resolving an interface method from an abstract class, resolveConcreteMethod returns\n     * an undeclared method with the abstract subclass as declaring class, which is not the\n     * reflection API behavior.\n     *\n     * @see ReflectionHostedSupport#getHidingReflectionMethods()\n     */\n    private void checkSubtypeForOverridingMethod(AnalysisMethod method, AnalysisType subtype) {\n        try {\n            AnalysisMethod subClassMethod = subtype.findMethod(method.getName(), method.getSignature());\n            if (subClassMethod != null) {\n                hidingMethods.add(subClassMethod);\n            }\n        } catch (UnsupportedFeatureException | LinkageError e) {\n            /*\n             * A method that is not supposed to end up in the image is considered as being absent\n             * for reflection purposes.\n             */\n        }\n    }\n\n    private void registerTypesForClass(AnalysisType analysisType, Class<?> clazz) {\n        /*\n         * The generic signature is parsed at run time, so we need to make all the types necessary\n         * for parsing also available at run time.\n         */\n        registerTypesForGenericSignature(queryGenericInfo(clazz::getTypeParameters));\n        registerTypesForGenericSignature(queryGenericInfo(clazz::getGenericSuperclass));\n        registerTypesForGenericSignature(queryGenericInfo(clazz::getGenericInterfaces));\n\n        registerTypesForEnclosingMethodInfo(clazz);\n        if (!throwMissingRegistrationErrors()) {\n            maybeRegisterRecordComponents(clazz);\n        }\n\n        registerTypesForAnnotations(analysisType);\n        registerTypesForTypeAnnotations(analysisType);\n    }\n\n    private void registerRecordComponents(Class<?> clazz) {\n        RecordComponent[] recordComponents = clazz.getRecordComponents();\n        if (recordComponents == null) {\n            return;\n        }\n        for (RecordComponent recordComponent : recordComponents) {\n            registerTypesForRecordComponent(recordComponent);\n        }\n        registeredRecordComponents.put(clazz, recordComponents);\n    }\n\n    private void registerTypesForEnclosingMethodInfo(Class<?> clazz) {\n        Object[] enclosingMethodInfo = getEnclosingMethodInfo(clazz);\n        if (enclosingMethodInfo == null) {\n            return; /* Nothing to do. */\n        }\n\n        /* Ensure the class stored in the enclosing method info is available at run time. */\n        metaAccess.lookupJavaType((Class<?>) enclosingMethodInfo[0]).registerAsReachable(\"Is used by the enclosing method info of an element registered for reflection.\");\n\n        Executable enclosingMethodOrConstructor;\n        try {\n            enclosingMethodOrConstructor = Optional.<Executable> ofNullable(clazz.getEnclosingMethod())\n                            .orElse(clazz.getEnclosingConstructor());\n        } catch (TypeNotPresentException | LinkageError | InternalError e) {\n            /*\n             * These are rethrown at run time. However, note that `LinkageError` is rethrown as\n             * `InternalError` due to GR-40122.\n             */\n            return;\n        }\n\n        if (enclosingMethodOrConstructor != null) {\n            /* Make the metadata for the enclosing method or constructor available at run time. */\n            RuntimeReflection.registerAsQueried(enclosingMethodOrConstructor);\n        }\n    }\n\n    private final Method getEnclosingMethod0 = ReflectionUtil.lookupMethod(Class.class, \"getEnclosingMethod0\");\n\n    private Object[] getEnclosingMethodInfo(Class<?> clazz) {\n        try {\n            return (Object[]) getEnclosingMethod0.invoke(clazz);\n        } catch (InvocationTargetException e) {\n            if (e.getCause() instanceof LinkageError) {\n                /*\n                 * This error is handled when creating `DynamicHub` (but is then triggered by\n                 * `Class.getDeclaringClass0`), so we can simply ignore it here.\n                 */\n                return null;\n            }\n            throw VMError.shouldNotReachHere(e);\n        } catch (IllegalAccessException e) {\n            throw VMError.shouldNotReachHere(e);\n        }\n    }\n\n    private void registerTypesForField(AnalysisField analysisField, Field reflectField, boolean queriedOnly) {\n        if (!queriedOnly) {\n            /*\n             * Reflection accessors use Unsafe, so ensure that all reflectively accessible fields\n             * are registered as unsafe-accessible, whether they have been explicitly registered or\n             * their Field object is reachable in the image heap.\n             */\n            analysisField.registerAsUnsafeAccessed(\"is registered for reflection.\");\n        }\n\n        /*\n         * The generic signature is parsed at run time, so we need to make all the types necessary\n         * for parsing also available at run time.\n         */\n        registerTypesForGenericSignature(queryGenericInfo(reflectField::getGenericType));\n\n        /*\n         * Enable runtime instantiation of annotations\n         */\n        registerTypesForAnnotations(analysisField);\n        registerTypesForTypeAnnotations(analysisField);\n    }\n\n    private void registerTypesForMethod(AnalysisMethod analysisMethod, Executable reflectExecutable) {\n        /*\n         * The generic signature is parsed at run time, so we need to make all the types necessary\n         * for parsing also available at run time.\n         */\n        registerTypesForGenericSignature(queryGenericInfo(reflectExecutable::getTypeParameters));\n        registerTypesForGenericSignature(queryGenericInfo(reflectExecutable::getGenericParameterTypes));\n        registerTypesForGenericSignature(queryGenericInfo(reflectExecutable::getGenericExceptionTypes));\n        if (!analysisMethod.isConstructor()) {\n            registerTypesForGenericSignature(queryGenericInfo(((Method) reflectExecutable)::getGenericReturnType));\n        }\n\n        /*\n         * Enable runtime instantiation of annotations\n         */\n        registerTypesForAnnotations(analysisMethod);\n        registerTypesForParameterAnnotations(analysisMethod);\n        registerTypesForTypeAnnotations(analysisMethod);\n        if (!analysisMethod.isConstructor()) {\n            registerTypesForAnnotationDefault(analysisMethod);\n        }\n    }\n\n    private void registerTypesForGenericSignature(Type[] types) {\n        registerTypesForGenericSignature(types, 0);\n    }\n\n    private void registerTypesForGenericSignature(Type[] types, int dimension) {\n        if (types != null) {\n            for (Type type : types) {\n                registerTypesForGenericSignature(type, dimension);\n            }\n        }\n    }\n\n    private void registerTypesForGenericSignature(Type type) {\n        registerTypesForGenericSignature(type, 0);\n    }\n\n    /*\n     * We need the dimension argument to keep track of how deep in the stack of GenericArrayType\n     * instances we are so we register the correct array type once we get to the leaf Class object.\n     */\n    private void registerTypesForGenericSignature(Type type, int dimension) {\n        try {\n            if (type == null || !processedTypes.computeIfAbsent(type, t -> ConcurrentHashMap.newKeySet()).add(dimension)) {\n                return;\n            }\n        } catch (MalformedParameterizedTypeException | TypeNotPresentException | LinkageError e) {\n            /*\n             * Hash code computation can trigger an exception if a type in wildcard bounds is\n             * missing, in which case we cannot add `type` to `processedTypes`, but even so, we\n             * still have to process it. Otherwise, we might fail to make some type reachable.\n             */\n        }\n\n        if (type instanceof Class<?>) {\n            Class<?> clazz = (Class<?>) type;\n            if (shouldExcludeClass(clazz)) {\n                return;\n            }\n\n            if (dimension > 0) {\n                /*\n                 * We only need to register the array type here, since it is the one that gets\n                 * stored in the heap. The component type will be registered elsewhere if needed.\n                 */\n                metaAccess.lookupJavaType(clazz).getArrayClass(dimension).registerAsReachable(\"Is used by generic signature of element registered for reflection.\");\n            }\n\n            /*\n             * Reflection signature parsing will try to instantiate classes via Class.forName().\n             */\n            ClassForNameSupport.singleton().registerClass(clazz);\n        } else if (type instanceof TypeVariable<?>) {\n            /* Bounds are reified lazily. */\n            registerTypesForGenericSignature(queryGenericInfo(((TypeVariable<?>) type)::getBounds), dimension);\n        } else if (type instanceof GenericArrayType) {\n            registerTypesForGenericSignature(queryGenericInfo(((GenericArrayType) type)::getGenericComponentType), dimension + 1);\n        } else if (type instanceof ParameterizedType) {\n            ParameterizedType parameterizedType = (ParameterizedType) type;\n            registerTypesForGenericSignature(queryGenericInfo(parameterizedType::getActualTypeArguments));\n            registerTypesForGenericSignature(queryGenericInfo(parameterizedType::getRawType), dimension);\n            registerTypesForGenericSignature(queryGenericInfo(parameterizedType::getOwnerType));\n        } else if (type instanceof WildcardType) {\n            /* Bounds are reified lazily. */\n            WildcardType wildcardType = (WildcardType) type;\n            registerTypesForGenericSignature(queryGenericInfo(wildcardType::getLowerBounds), dimension);\n            registerTypesForGenericSignature(queryGenericInfo(wildcardType::getUpperBounds), dimension);\n        }\n    }\n\n    private void registerTypesForRecordComponent(RecordComponent recordComponent) {\n        Method accessorOrNull = recordComponent.getAccessor();\n        if (accessorOrNull != null) {\n            register(ConfigurationCondition.alwaysTrue(), true, accessorOrNull);\n        }\n        registerTypesForAnnotations(recordComponent);\n        registerTypesForTypeAnnotations(recordComponent);\n    }\n\n    private void registerTypesForAnnotations(AnnotatedElement annotatedElement) {\n        if (annotatedElement != null) {\n            if (!filteredAnnotations.containsKey(annotatedElement)) {\n                List<AnnotationValue> includedAnnotations = new ArrayList<>();\n                for (AnnotationValue annotation : annotationExtractor.getDeclaredAnnotationData(annotatedElement)) {\n                    if (includeAnnotation(annotation)) {\n                        includedAnnotations.add(annotation);\n                        registerTypesForAnnotation(annotation);\n                    }\n                }\n                filteredAnnotations.put(annotatedElement, includedAnnotations.toArray(new AnnotationValue[0]));\n            }\n        }\n    }\n\n    private void registerTypesForParameterAnnotations(AnalysisMethod method) {\n        if (method != null) {\n            if (!filteredParameterAnnotations.containsKey(method)) {\n                AnnotationValue[][] parameterAnnotations = annotationExtractor.getParameterAnnotationData(method);\n                AnnotationValue[][] includedParameterAnnotations = new AnnotationValue[parameterAnnotations.length][];\n                for (int i = 0; i < includedParameterAnnotations.length; ++i) {\n                    AnnotationValue[] annotations = parameterAnnotations[i];\n                    List<AnnotationValue> includedAnnotations = new ArrayList<>();\n                    for (AnnotationValue annotation : annotations) {\n                        if (includeAnnotation(annotation)) {\n                            includedAnnotations.add(annotation);\n                            registerTypesForAnnotation(annotation);\n                        }\n                    }\n                    includedParameterAnnotations[i] = includedAnnotations.toArray(new AnnotationValue[0]);\n                }\n                filteredParameterAnnotations.put(method, includedParameterAnnotations);\n            }\n        }\n    }\n\n    private void registerTypesForTypeAnnotations(AnnotatedElement annotatedElement) {\n        if (annotatedElement != null) {\n            if (!filteredTypeAnnotations.containsKey(annotatedElement)) {\n                List<TypeAnnotationValue> includedTypeAnnotations = new ArrayList<>();\n                for (TypeAnnotationValue typeAnnotation : annotationExtractor.getTypeAnnotationData(annotatedElement)) {\n                    if (includeAnnotation(typeAnnotation.getAnnotationData())) {\n                        includedTypeAnnotations.add(typeAnnotation);\n                        registerTypesForAnnotation(typeAnnotation.getAnnotationData());\n                    }\n                }\n                filteredTypeAnnotations.put(annotatedElement, includedTypeAnnotations.toArray(new TypeAnnotationValue[0]));\n            }\n        }\n    }\n\n    private void registerTypesForAnnotationDefault(AnalysisMethod method) {\n        AnnotationMemberValue annotationDefault = annotationExtractor.getAnnotationDefaultData(method);\n        if (annotationDefault != null) {\n            registerTypes(annotationDefault.getTypes());\n        }\n    }\n\n    private boolean includeAnnotation(AnnotationValue annotationValue) {\n        if (annotationValue == null) {\n            return false;\n        }\n        for (Class<?> type : annotationValue.getTypes()) {\n            if (type == null || SubstitutionReflectivityFilter.shouldExclude(type, metaAccess, universe)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void registerTypesForAnnotation(AnnotationValue annotationValue) {\n        registerTypes(annotationValue.getTypes());\n    }\n\n    @SuppressWarnings(\"cast\")\n    private void registerTypes(Collection<Class<?>> types) {\n        for (Class<?> type : types) {\n            AnalysisType analysisType = metaAccess.lookupJavaType(type);\n            analysisType.registerAsReachable(\"Is used by annotation of element registered for reflection.\");\n            if (type.isAnnotation()) {\n                RuntimeProxyCreation.register(type);\n                RuntimeReflection.registerAllDeclaredMethods(type);\n            }\n            /*\n             * Exception proxies are stored as-is in the image heap\n             */\n            if (ExceptionProxy.class.isAssignableFrom(type)) {\n                registerAsUnsafeAllocated(analysisType, \"Is used by annotation of element registered for reflection.\");\n            }\n        }\n    }\n\n    private boolean shouldExcludeClass(Class<?> clazz) {\n        if (clazz.isPrimitive()) {\n            return true; // primitives cannot be looked up by name and have no methods or fields\n        }\n        return SubstitutionReflectivityFilter.shouldExclude(clazz, metaAccess, universe);\n    }\n\n    private static <T> T queryGenericInfo(Callable<T> callable) {\n        try {\n            return callable.call();\n        } catch (MalformedParameterizedTypeException | TypeNotPresentException | LinkageError e) {\n            /* These are rethrown at run time, so we can simply ignore them when querying. */\n            return null;\n        } catch (Throwable t) {\n            throw VMError.shouldNotReachHere(t);\n        }\n    }\n\n    private void maybeRegisterRecordComponents(Class<?> clazz) {\n        if (!clazz.isRecord()) {\n            return;\n        }\n\n        /*\n         * RecordComponent objects expose the \"accessor method\" as a java.lang.reflect.Method\n         * object. We leverage this tight coupling of RecordComponent and its accessor method to\n         * avoid a separate reflection configuration for record components: When all accessor\n         * methods of the record class are registered for reflection, then the record components are\n         * available. We do not want to expose a partial list of record components, that would be\n         * confusing and error-prone. So as soon as a single accessor method is missing from the\n         * reflection configuration, we provide no record components. Accessing the record\n         * components in that case will throw an exception at image run time, see\n         * DynamicHub.getRecordComponents0().\n         */\n        Method[] accessors = RecordUtils.getRecordComponentAccessorMethods(clazz);\n        Set<Method> unregisteredAccessors = ConcurrentHashMap.newKeySet();\n        for (Method accessor : accessors) {\n            if (SubstitutionReflectivityFilter.shouldExclude(accessor, metaAccess, universe)) {\n                return;\n            }\n            unregisteredAccessors.add(accessor);\n        }\n        pendingRecordClasses.put(clazz, unregisteredAccessors);\n\n        unregisteredAccessors.removeIf(accessor -> registeredMethods.containsKey(metaAccess.lookupJavaMethod(accessor)));\n        if (unregisteredAccessors.isEmpty()) {\n            registerRecordComponents(clazz);\n        }\n    }\n\n    private static void registerLinkageError(Class<?> clazz, LinkageError error, Map<Class<?>, Throwable> errorMap) {\n        if (LinkAtBuildTimeSupport.singleton().linkAtBuildTime(clazz)) {\n            throw error;\n        } else {\n            errorMap.put(clazz, error);\n        }\n    }\n\n    private static void reportLinkingErrors(Class<?> clazz, List<Throwable> errors) {\n        if (errors.isEmpty()) {\n            return;\n        }\n        String messages = errors.stream().map(e -> e.getClass().getTypeName() + \": \" + e.getMessage())\n                        .distinct().collect(Collectors.joining(\", \"));\n        LogUtils.warning(\"Could not register complete reflection metadata for %s. Reason(s): %s.\", clazz.getTypeName(), messages);\n    }\n\n    protected void afterAnalysis() {\n        sealed = true;\n        processedTypes.clear();\n        if (!throwMissingRegistrationErrors()) {\n            pendingRecordClasses.clear();\n        }\n    }\n\n    @Override\n    public Map<Class<?>, Set<Class<?>>> getReflectionInnerClasses() {\n        assert sealed;\n        return Collections.unmodifiableMap(innerClasses);\n    }\n\n    public int getEnabledReflectionQueries(Class<?> clazz) {\n        int enabledQueries = enabledQueriesFlags.getOrDefault(clazz, 0);\n        /*\n         * Primitives, arrays and object are registered by default since they provide reflective\n         * access to either no members or only Object methods.\n         */\n        if (clazz == Object.class || clazz.isPrimitive() || clazz.isArray()) {\n            enabledQueries |= ALL_DECLARED_CLASSES_FLAG | ALL_CLASSES_FLAG | ALL_DECLARED_CONSTRUCTORS_FLAG | ALL_CONSTRUCTORS_FLAG | ALL_DECLARED_METHODS_FLAG | ALL_METHODS_FLAG |\n                            ALL_DECLARED_FIELDS_FLAG | ALL_FIELDS_FLAG;\n        }\n        return enabledQueries;\n    }\n\n    @Override\n    public Map<AnalysisField, Field> getReflectionFields() {\n        assert sealed;\n        return Collections.unmodifiableMap(registeredFields);\n    }\n\n    @Override\n    public Map<AnalysisMethod, Executable> getReflectionExecutables() {\n        assert sealed;\n        return Collections.unmodifiableMap(registeredMethods);\n    }\n\n    @Override\n    public Object getAccessor(AnalysisMethod method) {\n        assert sealed;\n        return methodAccessors.get(method);\n    }\n\n    @Override\n    public Set<ResolvedJavaField> getHidingReflectionFields() {\n        assert sealed;\n        return Collections.unmodifiableSet(hidingFields);\n    }\n\n    @Override\n    public Set<ResolvedJavaMethod> getHidingReflectionMethods() {\n        assert sealed;\n        return Collections.unmodifiableSet(hidingMethods);\n    }\n\n    @Override\n    public RecordComponent[] getRecordComponents(Class<?> type) {\n        assert sealed;\n        return registeredRecordComponents.get(type);\n    }\n\n    @Override\n    public void registerHeapDynamicHub(Object object, ScanReason reason) {\n        assert !sealed;\n        DynamicHub hub = (DynamicHub) object;\n        Class<?> javaClass = hub.getHostedJavaClass();\n        if (heapDynamicHubs.add(hub) && !SubstitutionReflectivityFilter.shouldExclude(javaClass, metaAccess, universe)) {\n            registerTypesForClass(metaAccess.lookupJavaType(javaClass), javaClass);\n        }\n    }\n\n    @Override\n    public Set<DynamicHub> getHeapDynamicHubs() {\n        assert sealed;\n        return Collections.unmodifiableSet(heapDynamicHubs);\n    }\n\n    @Override\n    public void registerHeapReflectionField(Field reflectField, ScanReason reason) {\n        assert !sealed;\n        AnalysisField analysisField = metaAccess.lookupJavaField(reflectField);\n        if (heapFields.put(analysisField, reflectField) == null && !SubstitutionReflectivityFilter.shouldExclude(reflectField, metaAccess, universe)) {\n            registerTypesForField(analysisField, reflectField, false);\n            if (analysisField.getDeclaringClass().isAnnotation()) {\n                processAnnotationField(reflectField);\n            }\n        }\n    }\n\n    @Override\n    public void registerHeapReflectionExecutable(Executable reflectExecutable, ScanReason reason) {\n        assert !sealed;\n        AnalysisMethod analysisMethod = metaAccess.lookupJavaMethod(reflectExecutable);\n        if (heapMethods.put(analysisMethod, reflectExecutable) == null && !SubstitutionReflectivityFilter.shouldExclude(reflectExecutable, metaAccess, universe)) {\n            registerTypesForMethod(analysisMethod, reflectExecutable);\n            if (reflectExecutable instanceof Method && reflectExecutable.getDeclaringClass().isAnnotation()) {\n                processAnnotationMethod(false, (Method) reflectExecutable);\n            }\n        }\n    }\n\n    @Override\n    public Map<AnalysisField, Field> getHeapReflectionFields() {\n        assert sealed;\n        return Collections.unmodifiableMap(heapFields);\n    }\n\n    @Override\n    public Map<AnalysisMethod, Executable> getHeapReflectionExecutables() {\n        assert sealed;\n        return Collections.unmodifiableMap(heapMethods);\n    }\n\n    @Override\n    public Map<AnalysisType, Set<String>> getNegativeFieldQueries() {\n        return Collections.unmodifiableMap(negativeFieldLookups);\n    }\n\n    @Override\n    public Map<AnalysisType, Set<AnalysisMethod.Signature>> getNegativeMethodQueries() {\n        return Collections.unmodifiableMap(negativeMethodLookups);\n    }\n\n    @Override\n    public Map<AnalysisType, Set<AnalysisType[]>> getNegativeConstructorQueries() {\n        return Collections.unmodifiableMap(negativeConstructorLookups);\n    }\n\n    @Override\n    public Map<Class<?>, Throwable> getClassLookupErrors() {\n        return Collections.unmodifiableMap(classLookupExceptions);\n    }\n\n    @Override\n    public Map<Class<?>, Throwable> getFieldLookupErrors() {\n        return Collections.unmodifiableMap(fieldLookupExceptions);\n    }\n\n    @Override\n    public Map<Class<?>, Throwable> getMethodLookupErrors() {\n        return Collections.unmodifiableMap(methodLookupExceptions);\n    }\n\n    @Override\n    public Map<Class<?>, Throwable> getConstructorLookupErrors() {\n        return Collections.unmodifiableMap(constructorLookupExceptions);\n    }\n\n    private static final AnnotationValue[] NO_ANNOTATIONS = new AnnotationValue[0];\n\n    public AnnotationValue[] getAnnotationData(AnnotatedElement element) {\n        assert sealed;\n        return filteredAnnotations.getOrDefault(element, NO_ANNOTATIONS);\n    }\n\n    private static final AnnotationValue[][] NO_PARAMETER_ANNOTATIONS = new AnnotationValue[0][0];\n\n    public AnnotationValue[][] getParameterAnnotationData(AnalysisMethod element) {\n        assert sealed;\n        return filteredParameterAnnotations.getOrDefault(element, NO_PARAMETER_ANNOTATIONS);\n    }\n\n    private static final TypeAnnotationValue[] NO_TYPE_ANNOTATIONS = new TypeAnnotationValue[0];\n\n    public TypeAnnotationValue[] getTypeAnnotationData(AnnotatedElement element) {\n        assert sealed;\n        return filteredTypeAnnotations.getOrDefault(element, NO_TYPE_ANNOTATIONS);\n    }\n\n    public AnnotationMemberValue getAnnotationDefaultData(AnnotatedElement element) {\n        return annotationExtractor.getAnnotationDefaultData(element);\n    }\n\n    @Override\n    public int getReflectionMethodsCount() {\n        return registeredMethods.size();\n    }\n\n    @Override\n    public int getReflectionFieldsCount() {\n        return registeredFields.size();\n    }\n\n    private static void requireNonNull(Object[] values, String kind) {\n        for (Object value : values) {\n            Objects.requireNonNull(value, () -> nullErrorMessage(kind));\n        }\n    }\n\n    private static String nullErrorMessage(String kind) {\n        return \"Cannot register null value as \" + kind + \" for reflection. Please ensure that all values you register are not null.\";\n    }\n\n    public static class TestBackdoor {\n        public static void registerField(ReflectionDataBuilder reflectionDataBuilder, boolean queriedOnly, Field field) {\n            reflectionDataBuilder.runConditionalInAnalysisTask(ConfigurationCondition.alwaysTrue(), (cnd) -> reflectionDataBuilder.registerField(queriedOnly, field));\n        }\n    }\n}",
            "methodCount": 91
          },
          "candidatesTelemetryData": {
            "numberOfSuggestions": 3,
            "candidates": [
              {
                "lineStart": 1184,
                "lineEnd": 1186,
                "refactoringType": "MyMoveStaticMethodRefactoring",
                "refactoringInfo": "Move Static method registerField to class ReflectionDataBuilder",
                "description": "move method registerField to PsiClass:ReflectionDataBuilder\nRationale: The method registerField heavily relies on ReflectionDataBuilder's context and private methods to execute its functionality. Hence, it would be more coherent to keep the method within the ReflectionDataBuilder class as it directly interacts with its internal state and processes like running a conditional analysis task.",
                "couldCreateRefObject": true,
                "applied": false,
                "startedRefactoringFlow": false,
                "undone": false
              },
              {
                "lineStart": 1159,
                "lineEnd": 1161,
                "refactoringType": "MyMoveInstanceMethodRefactoring",
                "refactoringInfo": "Move method getAnnotationDefaultData to class SubstrateAnnotationExtractor",
                "description": "Move method getAnnotationDefaultData to com.oracle.svm.hosted.annotation.SubstrateAnnotationExtractor\nRationale: The method getAnnotationDefaultData() is specifically tied to the functionality of extracting annotation-related data, which is the core responsibility of SubstrateAnnotationExtractor. This class already hosts other similar methods like getDeclaredAnnotationData() and getTypeAnnotationData(), making it the most cohesive and appropriate location for getAnnotationDefaultData().",
                "couldCreateRefObject": true,
                "applied": false,
                "startedRefactoringFlow": false,
                "undone": false
              },
              {
                "lineStart": 259,
                "lineEnd": 261,
                "refactoringType": "MyMoveInstanceMethodRefactoring",
                "refactoringInfo": "Move method registerAsUnsafeAllocated to class BeforeAnalysisAccessImpl",
                "description": "Move method registerAsUnsafeAllocated to com.oracle.svm.hosted.FeatureImpl.BeforeAnalysisAccessImpl\nRationale: The method has a similar function, `registerAsUnsafeAccessed` in this class that performs registration tasks using `AnalysisType`. It aligns semantically with the responsibilities of `BeforeAnalysisAccessImpl` and extends its capabilities.",
                "couldCreateRefObject": true,
                "applied": false,
                "startedRefactoringFlow": false,
                "undone": false
              }
            ]
          },
          "elapsedTime": [
            {
              "candidateIndex": 0,
              "elapsedTime": 5312
            },
            {
              "candidateIndex": 2,
              "elapsedTime": 19679
            }
          ],
          "processingTime": {
            "llmResponseTime": -1,
            "pluginProcessingTime": -1,
            "totalTime": 146851
          },
          "iterationData": [
            {
              "iteration_num": 1,
              "suggested_move_methods": [
                {
                  "method_name": "registerConditionalConfiguration(ConfigurationCondition, Consumer<ConfigurationCondition>)",
                  "method_signature": "private void registerConditionalConfiguration(ConfigurationCondition condition, Consumer<ConfigurationCondition> task)",
                  "target_class": "ConditionalConfigurationRegistry",
                  "rationale": "The method `registerConditionalConfiguration()` appears to be related to registering and managing configurations based on conditions. This logic seems more appropriate for the conditional configuration management system, which `ConditionalConfigurationRegistry` represents."
                },
                {
                  "method_name": "lookupJavaType(Class<?>)",
                  "method_signature": "public AnalysisType lookupJavaType(Class<?> clazz)",
                  "target_class": "AnalysisMetaAccess",
                  "rationale": "The method `lookupJavaType()` directly engages with the AnalysisMetaAccess to look up types. This function is central to the `AnalysisMetaAccess` class and therefore, should be moved for cohesive design."
                },
                {
                  "method_name": "runConditionalInAnalysisTask(ConfigurationCondition, Consumer<ConfigurationCondition>)",
                  "method_signature": "private void runConditionalInAnalysisTask(ConfigurationCondition condition, Consumer<ConfigurationCondition> task)",
                  "target_class": "ConditionalConfigurationRegistry",
                  "rationale": "This method's job is to schedule the given task based on the universe's state or add it to pending conditional tasks. This fits cohesively with the responsibilities of managing tasks triggered by configuration conditions, residing better in `ConditionalConfigurationRegistry`."
                },
                {
                  "method_name": "lookupJavaMethod(Executable)",
                  "method_signature": "public AnalysisMethod lookupJavaMethod(Executable executable)",
                  "target_class": "AnalysisMetaAccess",
                  "rationale": "The method `lookupJavaMethod()` is responsible for converting reflection-based Executable objects into AnalysisMethod objects. Given `AnalysisMetaAccess` deals with these conversions, the method should be moved there."
                }
              ],
              "llm_response_time": 7316
            },
            {
              "iteration_num": 2,
              "suggested_move_methods": [
                {
                  "method_name": "registerTypesForClass",
                  "method_signature": "private void registerTypesForClass(AnalysisType analysisType, Class<?> clazz)",
                  "target_class": "ClassTypeRegistrar",
                  "rationale": "The method is specific to registering types for a given class, which can be abstracted into a dedicated class for handling such registrations."
                },
                {
                  "method_name": "registerTypesForEnclosingMethodInfo",
                  "method_signature": "private void registerTypesForEnclosingMethodInfo(Class<?> clazz)",
                  "target_class": "ClassTypeRegistrar",
                  "rationale": "This method's functionality involves registering types based on the enclosing method information of a class, which makes it a good candidate to move to a specialized class handling type registrations."
                },
                {
                  "method_name": "registerRecordComponents",
                  "method_signature": "private void registerRecordComponents(Class<?> clazz)",
                  "target_class": "RecordComponentRegistrar",
                  "rationale": "This method specifically deals with registering record components. It should be moved to a class that specializes in handling record components, making the codebase more modular and understandable."
                },
                {
                  "method_name": "registerTypesForField",
                  "method_signature": "private void registerTypesForField(AnalysisField analysisField, Field reflectField, boolean queriedOnly)",
                  "target_class": "FieldTypeRegistrar",
                  "rationale": "The method exclusively manages the registration of field types. It would be more appropriate to handle this in a dedicated class for better separation of concerns and clearer responsibilities."
                },
                {
                  "method_name": "registerTypesForMethod",
                  "method_signature": "private void registerTypesForMethod(AnalysisMethod analysisMethod, Executable reflectExecutable)",
                  "target_class": "MethodTypeRegistrar",
                  "rationale": "The method's functionality is focused on managing the registration of method types. Hence, it should reside in a class dedicated to method type registration."
                },
                {
                  "method_name": "registerTypesForGenericSignature",
                  "method_signature": "private void registerTypesForGenericSignature(Type[] types)",
                  "target_class": "GenericTypeRegistrar",
                  "rationale": "The method specifically registers types for generic signatures, so having it in a dedicated class for generic type registrations would improve modularity and make the code easier to maintain."
                },
                {
                  "method_name": "registerTypesForGenericSignature",
                  "method_signature": "private void registerTypesForGenericSignature(Type type, int dimension)",
                  "target_class": "GenericTypeRegistrar",
                  "rationale": "As with the overloaded method, this variant also specifically deals with registering types for generic signatures and should be managed by a dedicated registrar class."
                },
                {
                  "method_name": "registerTypesForRecordComponent",
                  "method_signature": "private void registerTypesForRecordComponent(RecordComponent recordComponent)",
                  "target_class": "RecordComponentRegistrar",
                  "rationale": "This method pertains to the registration of types for record components, which makes it suitable to reside in the RecordComponentRegistrar class."
                },
                {
                  "method_name": "registerTypesForAnnotations",
                  "method_signature": "private void registerTypesForAnnotations(AnnotatedElement annotatedElement)",
                  "target_class": "AnnotationTypeRegistrar",
                  "rationale": "This method specifically manages the registration of types for annotations. Moving it to a class dedicated to annotation type registration would enhance modularity."
                },
                {
                  "method_name": "registerTypesForParameterAnnotations",
                  "method_signature": "private void registerTypesForParameterAnnotations(AnalysisMethod method)",
                  "target_class": "MethodAnnotationRegistrar",
                  "rationale": "This method exclusively handles the registration of parameter annotations for methods and should be moved to a specialized class for handling method annotations."
                },
                {
                  "method_name": "registerTypesForTypeAnnotations",
                  "method_signature": "private void registerTypesForTypeAnnotations(AnnotatedElement annotatedElement)",
                  "target_class": "TypeAnnotationRegistrar",
                  "rationale": "The method deals with registering type annotations and should be managed by a class specifically focused on that responsibility."
                },
                {
                  "method_name": "registerTypesForAnnotationDefault",
                  "method_signature": "private void registerTypesForAnnotationDefault(AnalysisMethod method)",
                  "target_class": "AnnotationDefaultRegistrar",
                  "rationale": "This method handles the registration of types for annotation defaults and would be better placed in a dedicated class managing annotation defaults."
                }
              ],
              "llm_response_time": 12842
            },
            {
              "iteration_num": 3,
              "suggested_move_methods": [
                {
                  "method_name": "registerLinkageError",
                  "method_signature": "private static void registerLinkageError(Class<?> clazz, LinkageError error, Map<Class<?>, Throwable> errorMap)",
                  "target_class": "LinkageErrorHandler",
                  "rationale": "The method focuses exclusively on handling linkage errors during class registration, which is a distinct concern best encapsulated in a specialized class."
                },
                {
                  "method_name": "reportLinkingErrors",
                  "method_signature": "private static void reportLinkingErrors(Class<?> clazz, List<Throwable> errors)",
                  "target_class": "LinkageErrorHandler",
                  "rationale": "This method deals with reporting linking errors, which is a responsibility best delegated to a dedicated error handling class."
                },
                {
                  "method_name": "queryGenericInfo",
                  "method_signature": "private static <T> T queryGenericInfo(Callable<T> callable)",
                  "target_class": "GenericInfoQueryUtils",
                  "rationale": "This utility function is focused on querying generic information, which suggests the creation of a utility class for handling such queries."
                },
                {
                  "method_name": "registerTypesForRecordComponent",
                  "method_signature": "private void registerTypesForRecordComponent(RecordComponent recordComponent)",
                  "target_class": "RecordComponentUtils",
                  "rationale": "The method is concerned with registering types for a RecordComponent, which implies it would be more appropriately placed in a utility class focused on record components."
                },
                {
                  "method_name": "registerTypesForAnnotations",
                  "method_signature": "private void registerTypesForAnnotations(AnnotatedElement annotatedElement)",
                  "target_class": "AnnotationUtils",
                  "rationale": "This method handles the registration of types for annotations, indicating it belongs to a more dedicated class focused on annotation handling."
                },
                {
                  "method_name": "includeAnnotation",
                  "method_signature": "private boolean includeAnnotation(AnnotationValue annotationValue)",
                  "target_class": "AnnotationUtils",
                  "rationale": "Determining whether to include an annotation is a specific concern that should be handled within a utility class dedicated to annotation processing."
                },
                {
                  "method_name": "registerTypesForAnnotation",
                  "method_signature": "private void registerTypesForAnnotation(AnnotationValue annotationValue)",
                  "target_class": "AnnotationUtils",
                  "rationale": "This method handles the registration of types for a specific annotation, which is better suited for a utility class dealing with annotation-related tasks."
                },
                {
                  "method_name": "shouldExcludeClass",
                  "method_signature": "private boolean shouldExcludeClass(Class<?> clazz)",
                  "target_class": "ClassExclusionUtils",
                  "rationale": "Deciding whether a class should be excluded is a specific concern that suggests creating a utility class dedicated to this type of logic."
                }
              ],
              "llm_response_time": 8526
            },
            {
              "iteration_num": -1,
              "suggested_move_methods": [
                {
                  "method_name": "duringSetup",
                  "method_signature": "public duringSetup(AnalysisMetaAccess analysisMetaAccess, AnalysisUniverse analysisUniverse)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "runConditionalInAnalysisTask",
                  "method_signature": "private runConditionalInAnalysisTask(ConfigurationCondition condition, Consumer<ConfigurationCondition> task)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerClass",
                  "method_signature": "private registerClass(ConfigurationCondition condition, Class<?> clazz, boolean unsafeInstantiated, boolean allowForName)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerAsUnsafeAllocated",
                  "method_signature": "private registerAsUnsafeAllocated(AnalysisType type, String reason)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerMethod",
                  "method_signature": "private registerMethod(boolean queriedOnly, Executable reflectExecutable)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerField",
                  "method_signature": "private registerField(boolean queriedOnly, Field reflectField)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "checkSubtypeForOverridingField",
                  "method_signature": "private checkSubtypeForOverridingField(AnalysisField field, AnalysisType subtype)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "checkSubtypeForOverridingMethod",
                  "method_signature": "private checkSubtypeForOverridingMethod(AnalysisMethod method, AnalysisType subtype)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypesForEnclosingMethodInfo",
                  "method_signature": "private registerTypesForEnclosingMethodInfo(Class<?> clazz)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypesForField",
                  "method_signature": "private registerTypesForField(AnalysisField analysisField, Field reflectField, boolean queriedOnly)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypesForMethod",
                  "method_signature": "private registerTypesForMethod(AnalysisMethod analysisMethod, Executable reflectExecutable)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypesForGenericSignature",
                  "method_signature": "private registerTypesForGenericSignature(Type type, int dimension)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypesForAnnotations",
                  "method_signature": "private registerTypesForAnnotations(AnnotatedElement annotatedElement)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypesForParameterAnnotations",
                  "method_signature": "private registerTypesForParameterAnnotations(AnalysisMethod method)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypesForTypeAnnotations",
                  "method_signature": "private registerTypesForTypeAnnotations(AnnotatedElement annotatedElement)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypesForAnnotationDefault",
                  "method_signature": "private registerTypesForAnnotationDefault(AnalysisMethod method)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "includeAnnotation",
                  "method_signature": "private includeAnnotation(AnnotationValue annotationValue)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypesForAnnotation",
                  "method_signature": "private registerTypesForAnnotation(AnnotationValue annotationValue)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypes",
                  "method_signature": "@SuppressWarnings(\"cast\")\n    private registerTypes(Collection<Class<?>> types)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "maybeRegisterRecordComponents",
                  "method_signature": "private maybeRegisterRecordComponents(Class<?> clazz)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "getAnnotationDefaultData",
                  "method_signature": "public getAnnotationDefaultData(AnnotatedElement element)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerField",
                  "method_signature": "public static registerField(ReflectionDataBuilder reflectionDataBuilder, boolean queriedOnly, Field field)",
                  "target_class": "",
                  "rationale": ""
                }
              ],
              "llm_response_time": 0
            },
            {
              "iteration_num": -2,
              "suggested_move_methods": [
                {
                  "method_name": "checkSubtypeForOverridingMethod",
                  "method_signature": "private checkSubtypeForOverridingMethod(AnalysisMethod method, AnalysisType subtype)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerField",
                  "method_signature": "public static registerField(ReflectionDataBuilder reflectionDataBuilder, boolean queriedOnly, Field field)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypesForField",
                  "method_signature": "private registerTypesForField(AnalysisField analysisField, Field reflectField, boolean queriedOnly)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "getAnnotationDefaultData",
                  "method_signature": "public getAnnotationDefaultData(AnnotatedElement element)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerAsUnsafeAllocated",
                  "method_signature": "private registerAsUnsafeAllocated(AnalysisType type, String reason)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "maybeRegisterRecordComponents",
                  "method_signature": "private maybeRegisterRecordComponents(Class<?> clazz)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypesForAnnotation",
                  "method_signature": "private registerTypesForAnnotation(AnnotationValue annotationValue)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "duringSetup",
                  "method_signature": "public duringSetup(AnalysisMetaAccess analysisMetaAccess, AnalysisUniverse analysisUniverse)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypesForMethod",
                  "method_signature": "private registerTypesForMethod(AnalysisMethod analysisMethod, Executable reflectExecutable)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypesForEnclosingMethodInfo",
                  "method_signature": "private registerTypesForEnclosingMethodInfo(Class<?> clazz)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "runConditionalInAnalysisTask",
                  "method_signature": "private runConditionalInAnalysisTask(ConfigurationCondition condition, Consumer<ConfigurationCondition> task)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypes",
                  "method_signature": "@SuppressWarnings(\"cast\")\n    private registerTypes(Collection<Class<?>> types)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypesForGenericSignature",
                  "method_signature": "private registerTypesForGenericSignature(Type type, int dimension)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "registerTypesForAnnotationDefault",
                  "method_signature": "private registerTypesForAnnotationDefault(AnalysisMethod method)",
                  "target_class": "",
                  "rationale": ""
                },
                {
                  "method_name": "includeAnnotation",
                  "method_signature": "private includeAnnotation(AnnotationValue annotationValue)",
                  "target_class": "",
                  "rationale": ""
                }
              ],
              "llm_response_time": 0
            }
          ],
          "methodCompatibilityScores": {
            "tf-idf": {
              "private checkSubtypeForOverridingMethod(AnalysisMethod method, AnalysisType subtype)": {
                "first": {
                  "method_name": "checkSubtypeForOverridingMethod",
                  "method_signature": "private checkSubtypeForOverridingMethod(AnalysisMethod method, AnalysisType subtype)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.41472285267794895
              },
              "public static registerField(ReflectionDataBuilder reflectionDataBuilder, boolean queriedOnly, Field field)": {
                "first": {
                  "method_name": "registerField",
                  "method_signature": "public static registerField(ReflectionDataBuilder reflectionDataBuilder, boolean queriedOnly, Field field)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.4203368332954146
              },
              "private registerTypesForField(AnalysisField analysisField, Field reflectField, boolean queriedOnly)": {
                "first": {
                  "method_name": "registerTypesForField",
                  "method_signature": "private registerTypesForField(AnalysisField analysisField, Field reflectField, boolean queriedOnly)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.4419990100334722
              },
              "public getAnnotationDefaultData(AnnotatedElement element)": {
                "first": {
                  "method_name": "getAnnotationDefaultData",
                  "method_signature": "public getAnnotationDefaultData(AnnotatedElement element)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.4849043572142029
              },
              "private registerAsUnsafeAllocated(AnalysisType type, String reason)": {
                "first": {
                  "method_name": "registerAsUnsafeAllocated",
                  "method_signature": "private registerAsUnsafeAllocated(AnalysisType type, String reason)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.4975627690312236
              },
              "private maybeRegisterRecordComponents(Class<?> clazz)": {
                "first": {
                  "method_name": "maybeRegisterRecordComponents",
                  "method_signature": "private maybeRegisterRecordComponents(Class<?> clazz)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.5474515397343347
              },
              "private registerTypesForAnnotation(AnnotationValue annotationValue)": {
                "first": {
                  "method_name": "registerTypesForAnnotation",
                  "method_signature": "private registerTypesForAnnotation(AnnotationValue annotationValue)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.555018355997769
              },
              "public duringSetup(AnalysisMetaAccess analysisMetaAccess, AnalysisUniverse analysisUniverse)": {
                "first": {
                  "method_name": "duringSetup",
                  "method_signature": "public duringSetup(AnalysisMetaAccess analysisMetaAccess, AnalysisUniverse analysisUniverse)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.5625465248024346
              },
              "private registerTypesForMethod(AnalysisMethod analysisMethod, Executable reflectExecutable)": {
                "first": {
                  "method_name": "registerTypesForMethod",
                  "method_signature": "private registerTypesForMethod(AnalysisMethod analysisMethod, Executable reflectExecutable)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.5914337679287841
              },
              "private registerTypesForEnclosingMethodInfo(Class<?> clazz)": {
                "first": {
                  "method_name": "registerTypesForEnclosingMethodInfo",
                  "method_signature": "private registerTypesForEnclosingMethodInfo(Class<?> clazz)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.6121210603463891
              },
              "private runConditionalInAnalysisTask(ConfigurationCondition condition, Consumer<ConfigurationCondition> task)": {
                "first": {
                  "method_name": "runConditionalInAnalysisTask",
                  "method_signature": "private runConditionalInAnalysisTask(ConfigurationCondition condition, Consumer<ConfigurationCondition> task)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.632481674734895
              },
              "@SuppressWarnings(\"cast\")\n    private registerTypes(Collection<Class<?>> types)": {
                "first": {
                  "method_name": "registerTypes",
                  "method_signature": "@SuppressWarnings(\"cast\")\n    private registerTypes(Collection<Class<?>> types)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.6373211538948239
              },
              "private registerTypesForGenericSignature(Type type, int dimension)": {
                "first": {
                  "method_name": "registerTypesForGenericSignature",
                  "method_signature": "private registerTypesForGenericSignature(Type type, int dimension)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.6430864266032412
              },
              "private registerTypesForAnnotationDefault(AnalysisMethod method)": {
                "first": {
                  "method_name": "registerTypesForAnnotationDefault",
                  "method_signature": "private registerTypesForAnnotationDefault(AnalysisMethod method)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.6687693082392819
              },
              "private includeAnnotation(AnnotationValue annotationValue)": {
                "first": {
                  "method_name": "includeAnnotation",
                  "method_signature": "private includeAnnotation(AnnotationValue annotationValue)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.6827199118016605
              }
            },
            "voyage": {
              "public getAnnotationDefaultData(AnnotatedElement element)": {
                "first": {
                  "method_name": "getAnnotationDefaultData",
                  "method_signature": "public getAnnotationDefaultData(AnnotatedElement element)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.3199177195484654
              },
              "private includeAnnotation(AnnotationValue annotationValue)": {
                "first": {
                  "method_name": "includeAnnotation",
                  "method_signature": "private includeAnnotation(AnnotationValue annotationValue)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.38905912019821964
              },
              "public duringSetup(AnalysisMetaAccess analysisMetaAccess, AnalysisUniverse analysisUniverse)": {
                "first": {
                  "method_name": "duringSetup",
                  "method_signature": "public duringSetup(AnalysisMetaAccess analysisMetaAccess, AnalysisUniverse analysisUniverse)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.41552151050199015
              },
              "private registerAsUnsafeAllocated(AnalysisType type, String reason)": {
                "first": {
                  "method_name": "registerAsUnsafeAllocated",
                  "method_signature": "private registerAsUnsafeAllocated(AnalysisType type, String reason)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.4382462310604788
              },
              "private runConditionalInAnalysisTask(ConfigurationCondition condition, Consumer<ConfigurationCondition> task)": {
                "first": {
                  "method_name": "runConditionalInAnalysisTask",
                  "method_signature": "private runConditionalInAnalysisTask(ConfigurationCondition condition, Consumer<ConfigurationCondition> task)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.4468372606779906
              },
              "private checkSubtypeForOverridingMethod(AnalysisMethod method, AnalysisType subtype)": {
                "first": {
                  "method_name": "checkSubtypeForOverridingMethod",
                  "method_signature": "private checkSubtypeForOverridingMethod(AnalysisMethod method, AnalysisType subtype)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.4734546508801582
              },
              "private registerTypesForParameterAnnotations(AnalysisMethod method)": {
                "first": {
                  "method_name": "registerTypesForParameterAnnotations",
                  "method_signature": "private registerTypesForParameterAnnotations(AnalysisMethod method)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.4871047141260113
              },
              "private registerTypesForAnnotationDefault(AnalysisMethod method)": {
                "first": {
                  "method_name": "registerTypesForAnnotationDefault",
                  "method_signature": "private registerTypesForAnnotationDefault(AnalysisMethod method)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.48724435421623485
              },
              "private registerTypesForAnnotation(AnnotationValue annotationValue)": {
                "first": {
                  "method_name": "registerTypesForAnnotation",
                  "method_signature": "private registerTypesForAnnotation(AnnotationValue annotationValue)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.5094581690666872
              },
              "private registerTypesForTypeAnnotations(AnnotatedElement annotatedElement)": {
                "first": {
                  "method_name": "registerTypesForTypeAnnotations",
                  "method_signature": "private registerTypesForTypeAnnotations(AnnotatedElement annotatedElement)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.509927440890521
              },
              "private checkSubtypeForOverridingField(AnalysisField field, AnalysisType subtype)": {
                "first": {
                  "method_name": "checkSubtypeForOverridingField",
                  "method_signature": "private checkSubtypeForOverridingField(AnalysisField field, AnalysisType subtype)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.5177984804933757
              },
              "private registerTypesForAnnotations(AnnotatedElement annotatedElement)": {
                "first": {
                  "method_name": "registerTypesForAnnotations",
                  "method_signature": "private registerTypesForAnnotations(AnnotatedElement annotatedElement)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.5462712747443412
              },
              "private maybeRegisterRecordComponents(Class<?> clazz)": {
                "first": {
                  "method_name": "maybeRegisterRecordComponents",
                  "method_signature": "private maybeRegisterRecordComponents(Class<?> clazz)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.5736817158812728
              },
              "private registerTypesForGenericSignature(Type type, int dimension)": {
                "first": {
                  "method_name": "registerTypesForGenericSignature",
                  "method_signature": "private registerTypesForGenericSignature(Type type, int dimension)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.5802841366211621
              },
              "private registerTypesForEnclosingMethodInfo(Class<?> clazz)": {
                "first": {
                  "method_name": "registerTypesForEnclosingMethodInfo",
                  "method_signature": "private registerTypesForEnclosingMethodInfo(Class<?> clazz)",
                  "target_class": "",
                  "rationale": ""
                },
                "second": 0.6163105816313349
              }
            }
          },
          "llmMethodPriority": {
            "tf-idf": {
              "priority_method_names": [
                "private runConditionalInAnalysisTask(ConfigurationCondition condition, Consumer<ConfigurationCondition> task)",
                "private registerTypesForMethod(AnalysisMethod analysisMethod, Executable reflectExecutable)",
                "private registerTypesForField(AnalysisField analysisField, Field reflectField, boolean queriedOnly)",
                "private checkSubtypeForOverridingMethod(AnalysisMethod method, AnalysisType subtype)",
                "private registerTypesForGenericSignature(Type type, int dimension)",
                "private registerTypesForAnnotation(AnnotationValue annotationValue)",
                "private registerAsUnsafeAllocated(AnalysisType type, String reason)",
                "private registerTypesForAnnotationDefault(AnalysisMethod method)",
                "private includeAnnotation(AnnotationValue annotationValue)",
                "private maybeRegisterRecordComponents(Class<?> clazz)",
                "private registerTypesForEnclosingMethodInfo(Class<?> clazz)",
                "public duringSetup(AnalysisMetaAccess analysisMetaAccess, AnalysisUniverse analysisUniverse)",
                "public getAnnotationDefaultData(AnnotatedElement element)",
                "public static registerField(ReflectionDataBuilder reflectionDataBuilder, boolean queriedOnly, Field field)"
              ],
              "llm_response_time": 4461
            },
            "tf-idf-5": {
              "priority_method_names": [
                "private registerTypesForField(AnalysisField analysisField, Field reflectField, boolean queriedOnly)",
                "private checkSubtypeForOverridingMethod(AnalysisMethod method, AnalysisType subtype)",
                "private registerAsUnsafeAllocated(AnalysisType type, String reason)",
                "public getAnnotationDefaultData(AnnotatedElement element)",
                "public static registerField(ReflectionDataBuilder reflectionDataBuilder, boolean queriedOnly, Field field)"
              ],
              "llm_response_time": 5382
            },
            "tf-df-3": {
              "priority_method_names": [
                "private registerTypesForField(AnalysisField analysisField, Field reflectField, boolean queriedOnly)",
                "private checkSubtypeForOverridingMethod(AnalysisMethod method, AnalysisType subtype)",
                "public static registerField(ReflectionDataBuilder reflectionDataBuilder, boolean queriedOnly, Field field)"
              ],
              "llm_response_time": 4988
            },
            "voyage": {
              "priority_method_names": [
                "private runConditionalInAnalysisTask(ConfigurationCondition condition, Consumer<ConfigurationCondition> task)",
                "public duringSetup(AnalysisMetaAccess analysisMetaAccess, AnalysisUniverse analysisUniverse)",
                "private checkSubtypeForOverridingMethod(AnalysisMethod method, AnalysisType subtype)",
                "private checkSubtypeForOverridingField(AnalysisField field, AnalysisType subtype)",
                "private registerTypesForGenericSignature(Type type, int dimension)",
                "private registerAsUnsafeAllocated(AnalysisType type, String reason)",
                "private maybeRegisterRecordComponents(Class<?> clazz)",
                "private registerTypesForAnnotationDefault(AnalysisMethod method)",
                "private registerTypesForParameterAnnotations(AnalysisMethod method)",
                "private registerTypesForAnnotations(AnnotatedElement annotatedElement)",
                "private registerTypesForTypeAnnotations(AnnotatedElement annotatedElement)",
                "private registerTypesForAnnotation(AnnotationValue annotationValue)",
                "private registerTypesForEnclosingMethodInfo(Class<?> clazz)",
                "public getAnnotationDefaultData(AnnotatedElement element)",
                "private includeAnnotation(AnnotationValue annotationValue)"
              ],
              "llm_response_time": 8938
            },
            "voyage-5": {
              "priority_method_names": [],
              "llm_response_time": 4639
            },
            "voyage-3": {
              "priority_method_names": [
                "public duringSetup(AnalysisMetaAccess analysisMetaAccess, AnalysisUniverse analysisUniverse)",
                "private includeAnnotation(AnnotationValue annotationValue)",
                "public getAnnotationDefaultData(AnnotatedElement element)"
              ],
              "llm_response_time": 4289
            }
          },
          "targetClassMap": {
            "checkSubtypeForOverridingMethod": {
              "target_classes": [],
              "target_classes_sorted_by_llm": [],
              "llm_response_time": 2503,
              "similarity_computation_time": 0,
              "similarity_metric": "cosine"
            },
            "registerField": {
              "target_classes": [
                {
                  "class_name": "ReflectionDataBuilder",
                  "similarity_score": 0.4271766639615776
                },
                {
                  "class_name": "ConditionalTask",
                  "similarity_score": 0.1889822365046136
                }
              ],
              "target_classes_sorted_by_llm": [
                "ReflectionDataBuilder",
                "ConditionalTask"
              ],
              "llm_response_time": 3826,
              "similarity_computation_time": 8,
              "similarity_metric": "cosine"
            },
            "registerTypesForField": {
              "target_classes": [],
              "target_classes_sorted_by_llm": [],
              "llm_response_time": 4511,
              "similarity_computation_time": 0,
              "similarity_metric": "cosine"
            },
            "getAnnotationDefaultData": {
              "target_classes": [
                {
                  "class_name": "SubstrateAnnotationExtractor",
                  "similarity_score": 0.4885344207052942
                }
              ],
              "target_classes_sorted_by_llm": [
                "SubstrateAnnotationExtractor"
              ],
              "llm_response_time": 2426,
              "similarity_computation_time": 1,
              "similarity_metric": "cosine"
            },
            "registerAsUnsafeAllocated": {
              "target_classes": [
                {
                  "class_name": "AnalysisType",
                  "similarity_score": 0.3514291650194352
                },
                {
                  "class_name": "AnalysisMetaAccess",
                  "similarity_score": 0.30919620705155315
                },
                {
                  "class_name": "AnalysisUniverse",
                  "similarity_score": 0.40207738641045704
                },
                {
                  "class_name": "SubstrateAnnotationExtractor",
                  "similarity_score": 0.40011254071707675
                },
                {
                  "class_name": "BeforeAnalysisAccessImpl",
                  "similarity_score": 0.5018184786040089
                }
              ],
              "target_classes_sorted_by_llm": [
                "BeforeAnalysisAccessImpl",
                "AnalysisUniverse",
                "SubstrateAnnotationExtractor"
              ],
              "llm_response_time": 5068,
              "similarity_computation_time": 12,
              "similarity_metric": "cosine"
            },
            "maybeRegisterRecordComponents": {
              "target_classes": [],
              "target_classes_sorted_by_llm": [],
              "llm_response_time": 2797,
              "similarity_computation_time": 0,
              "similarity_metric": "cosine"
            },
            "registerTypesForAnnotation": {
              "target_classes": [],
              "target_classes_sorted_by_llm": [],
              "llm_response_time": 3410,
              "similarity_computation_time": 0,
              "similarity_metric": "cosine"
            },
            "duringSetup": {
              "target_classes": [],
              "target_classes_sorted_by_llm": [],
              "llm_response_time": 2835,
              "similarity_computation_time": 0,
              "similarity_metric": "cosine"
            },
            "registerTypesForMethod": {
              "target_classes": [],
              "target_classes_sorted_by_llm": [],
              "llm_response_time": 5506,
              "similarity_computation_time": 0,
              "similarity_metric": "cosine"
            },
            "registerTypesForEnclosingMethodInfo": {
              "target_classes": [],
              "target_classes_sorted_by_llm": [],
              "llm_response_time": 2974,
              "similarity_computation_time": 0,
              "similarity_metric": "cosine"
            },
            "runConditionalInAnalysisTask": {
              "target_classes": [],
              "target_classes_sorted_by_llm": [],
              "llm_response_time": 3622,
              "similarity_computation_time": 0,
              "similarity_metric": "cosine"
            },
            "registerTypes": {
              "target_classes": [],
              "target_classes_sorted_by_llm": [],
              "llm_response_time": 3331,
              "similarity_computation_time": 0,
              "similarity_metric": "cosine"
            },
            "registerTypesForGenericSignature": {
              "target_classes": [],
              "target_classes_sorted_by_llm": [],
              "llm_response_time": 3785,
              "similarity_computation_time": 0,
              "similarity_metric": "cosine"
            },
            "registerTypesForAnnotationDefault": {
              "target_classes": [],
              "target_classes_sorted_by_llm": [],
              "llm_response_time": 3251,
              "similarity_computation_time": 0,
              "similarity_metric": "cosine"
            },
            "includeAnnotation": {
              "target_classes": [],
              "target_classes_sorted_by_llm": [],
              "llm_response_time": 3593,
              "similarity_computation_time": 0,
              "similarity_metric": "cosine"
            }
          }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "59063acffc31c2ba274cfe09856964c0a07a2cd0",
        "url": "https://github.com/oracle/graal/commit/59063acffc31c2ba274cfe09856964c0a07a2cd0",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public pop(k JavaKind) : JavaKind extracted from private popSignature(sig Symbol<Type>[], isStatic boolean, frame Builder) : void in class com.oracle.truffle.espresso.analysis.frame.FrameAnalysis & moved to class com.oracle.truffle.espresso.vm.continuation.EspressoFrameDescriptor.Builder",
            "leftSideLocations": [
                {
                    "filePath": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/analysis/frame/FrameAnalysis.java",
                    "startLine": 287,
                    "endLine": 298,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "private popSignature(sig Symbol<Type>[], isStatic boolean, frame Builder) : void"
                },
                {
                    "filePath": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/analysis/frame/FrameAnalysis.java",
                    "startLine": 292,
                    "endLine": 292,
                    "startColumn": 17,
                    "endColumn": 29,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/analysis/frame/FrameAnalysis.java",
                    "startLine": 290,
                    "endLine": 290,
                    "startColumn": 13,
                    "endColumn": 25,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/analysis/frame/FrameAnalysis.java",
                    "startLine": 291,
                    "endLine": 293,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/analysis/frame/FrameAnalysis.java",
                    "startLine": 291,
                    "endLine": 293,
                    "startColumn": 36,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/vm/continuation/EspressoFrameDescriptor.java",
                    "startLine": 306,
                    "endLine": 314,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public pop(k JavaKind) : JavaKind"
                },
                {
                    "filePath": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/vm/continuation/EspressoFrameDescriptor.java",
                    "startLine": 310,
                    "endLine": 310,
                    "startColumn": 17,
                    "endColumn": 40,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/vm/continuation/EspressoFrameDescriptor.java",
                    "startLine": 307,
                    "endLine": 307,
                    "startColumn": 13,
                    "endColumn": 34,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/vm/continuation/EspressoFrameDescriptor.java",
                    "startLine": 309,
                    "endLine": 312,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/vm/continuation/EspressoFrameDescriptor.java",
                    "startLine": 309,
                    "endLine": 312,
                    "startColumn": 36,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/analysis/frame/FrameAnalysis.java",
                    "startLine": 287,
                    "endLine": 295,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "private popSignature(sig Symbol<Type>[], isStatic boolean, frame Builder) : void"
                },
                {
                    "filePath": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/analysis/frame/FrameAnalysis.java",
                    "startLine": 290,
                    "endLine": 290,
                    "startColumn": 13,
                    "endColumn": 25,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "frame.pop(k)"
                },
                {
                    "filePath": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/vm/continuation/EspressoFrameDescriptor.java",
                    "startLine": 308,
                    "endLine": 308,
                    "startColumn": 13,
                    "endColumn": 29,
                    "codeElementType": "ASSERT_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/vm/continuation/EspressoFrameDescriptor.java",
                    "startLine": 311,
                    "endLine": 311,
                    "startColumn": 17,
                    "endColumn": 50,
                    "codeElementType": "ASSERT_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/vm/continuation/EspressoFrameDescriptor.java",
                    "startLine": 313,
                    "endLine": 313,
                    "startColumn": 13,
                    "endColumn": 24,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                }
            ],
            "isStatic": false
        },
        "ref_id": 500,
        "extraction_results": {
            "success": true,
            "newCommitHash": "da227e8cbc7fe514a8193e2e8aca4fcdc2efd640",
            "newBranchName": "extract-pop-popSignature-861ec35"
        },
        "telemetry": {
            "id": "46455e0b-aaf0-4a16-a1e3-7f24f2c2ae9f",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 564,
                "lineStart": 252,
                "lineEnd": 815,
                "bodyLineStart": 252,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/espresso/src/com.oracle.truffle.espresso/src/com/oracle/truffle/espresso/analysis/frame/FrameAnalysis.java",
                "sourceCode": "/**\n * Statically analyses bytecodes to produce a {@link EspressoFrameDescriptor frame description} for\n * the given BCI.\n */\npublic final class FrameAnalysis {\n    private final EspressoLanguage lang;\n    private final Method.MethodVersion m;\n\n    private final LivenessAnalysis la;\n    private final BytecodeStream bs;\n    private final ConstantPool pool;\n    private final int targetBci;\n\n    private final Builder[] states;\n    private final BitSet branchTargets;\n    private final BitSet processStatus;\n\n    private final ArrayDeque<Integer> queue = new ArrayDeque<>(2);\n\n    public static EspressoFrameDescriptor apply(Method.MethodVersion m, int bci) {\n        return new FrameAnalysis(bci, m).apply();\n    }\n\n    private FrameAnalysis(int targetBci, Method.MethodVersion m) {\n        this.lang = m.getMethod().getLanguage();\n        this.la = m.getLivenessAnalysis();\n        this.bs = new BytecodeStream(m.getOriginalCode());\n        this.targetBci = targetBci;\n        this.states = new Builder[bs.endBCI()];\n        this.pool = m.getDeclaringKlass().getLinkedKlass().getParserKlass().getConstantPool();\n        this.m = m;\n        this.branchTargets = new BitSet(bs.endBCI());\n        this.processStatus = new BitSet(bs.endBCI());\n    }\n\n    private static void popSignature(Symbol<Type>[] sig, boolean isStatic, Builder frame) {\n        for (int i = 0; i < Signatures.parameterCount(sig); i++) {\n            JavaKind k = Signatures.parameterKind(sig, i);\n\n            frame.pop();\n            if (k.needsTwoSlots()) {\n                assert frame.pop() == JavaKind.Illegal;\n            }\n        }\n        if (!isStatic) {\n            frame.pop();\n        }\n    }\n\n    private int pop(Builder frame, JavaKind k) {\n        frame.pop();\n        if (k.needsTwoSlots()) {\n            assert frame.pop() == JavaKind.Illegal;\n        }\n        return frame.getTop();\n    }\n\n    private EspressoFrameDescriptor apply() {\n        markBranchTargets();\n\n        buildInitialFrame();\n        int startBci = 0;\n        push(startBci);\n\n        while (!queue.isEmpty()) {\n            startBci = pop();\n            buildStates(startBci);\n        }\n\n        Builder state = states[targetBci];\n        int opcode = bs.opcode(targetBci);\n        // For continuations purposes, we need to mutate the state to having popped arguments, but\n        // not having yet pushed a result.\n        assert Bytecodes.isInvoke(opcode);\n        handleInvoke(state, targetBci, opcode, false);\n        return state.build();\n    }\n\n    private void buildInitialFrame() {\n        Builder frame = new Builder(m.getMaxLocals(), m.getMaxStackSize());\n        Symbol<Type>[] sig = m.getMethod().getParsedSignature();\n        int receiverShift = 0;\n        if (!m.isStatic()) {\n            frame.putLocal(0, JavaKind.Object);\n            receiverShift = 1;\n        }\n        int localPos = 0;\n        for (int sigPos = 0; sigPos < Signatures.parameterCount(sig); sigPos++) {\n            JavaKind k = Signatures.parameterKind(sig, sigPos);\n            if (k.isStackInt()) {\n                k = JavaKind.Int;\n            }\n            frame.putLocal(receiverShift + localPos, k);\n            if (k.needsTwoSlots()) {\n                localPos++;\n                frame.putLocal(receiverShift + localPos, JavaKind.Illegal);\n            }\n            localPos++;\n        }\n        la.onStart(frame);\n        frame.setBci(0);\n        assert frame.isRecord();\n        states[0] = frame;\n    }\n\n    private void markBranchTargets() {\n        int bci = 0;\n        boolean validTarget = false;\n        while (bci < bs.endBCI()) {\n            int opcode = bs.opcode(bci);\n            if (Bytecodes.isBranch(opcode)) {\n                branchTargets.set(bs.readBranchDest(bci));\n            } else if (opcode == TABLESWITCH || opcode == LOOKUPSWITCH) {\n                BytecodeSwitch helper = BytecodeSwitch.get(opcode);\n                for (int i = 0; i < helper.numberOfCases(bs, opcode); i++) {\n                    branchTargets.set(helper.targetAt(bs, bci, i));\n                }\n                branchTargets.set(helper.defaultTarget(bs, bci));\n            }\n            if (bci == targetBci) {\n                validTarget = true;\n            }\n            bci = bs.nextBCI(bci);\n        }\n\n        if (!validTarget) {\n            Meta meta = m.getDeclaringKlass().getMeta();\n            throw meta.throwExceptionWithMessage(meta.java_lang_IllegalArgumentException, \"Target bci is not a valid bytecode.\");\n        }\n\n        ExceptionHandler[] handlers = m.getExceptionHandlers();\n        for (ExceptionHandler handler : handlers) {\n            branchTargets.set(handler.getHandlerBCI());\n        }\n    }\n\n    private void buildStates(int startBci) {\n        Builder frame = states[startBci].copy();\n        int bci = startBci;\n        while (bci < bs.endBCI()) {\n            if (branchTargets.get(bci)) {\n                Builder registered = states[bci];\n                assert (registered == null) || frame.sameTop(registered);\n                if (merge(bci, frame) && processStatus.get(bci)) {\n                    // If already processed, and merge succeeded, we can stop process for this\n                    // block.\n                    return;\n                }\n                // Verification is already run, so we know that processing will succeed.\n                processStatus.set(bci);\n                // keep going with updated frame, as it is be the most precise.\n                frame = registered == null ? frame : states[bci].copy();\n            }\n            if (bci == targetBci) {\n                // At this point, the current working frame can only be more precise.\n                registerState(bci, frame);\n                if (!la.isEmpty()) {\n                    // With LA, merging should always succeed.\n                    queue.clear();\n                    return;\n                }\n            }\n            assert frame.isWorking();\n            int opcode = bs.currentBC(bci);\n            switch (opcode) {\n                case NOP: // fallthrough\n                case IINC: // fallthrough\n                case CHECKCAST:\n                    break;\n                case ACONST_NULL, ALOAD, ALOAD_0, ALOAD_1, ALOAD_2, ALOAD_3, NEW:\n                    frame.push(JavaKind.Object);\n                    break;\n                case ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5: // fallthrough\n                case BIPUSH, SIPUSH: // fallthrough\n                case ILOAD, ILOAD_0, ILOAD_1, ILOAD_2, ILOAD_3:\n                    frame.push(JavaKind.Int);\n                    break;\n                case LCONST_0, LCONST_1, LLOAD, LLOAD_0, LLOAD_1, LLOAD_2, LLOAD_3:\n                    frame.push(JavaKind.Long);\n                    break;\n                case FCONST_0, FCONST_1, FCONST_2, FLOAD, FLOAD_0, FLOAD_1, FLOAD_2, FLOAD_3:\n                    frame.push(JavaKind.Float);\n                    break;\n                case DCONST_0, DCONST_1, DLOAD, DLOAD_0, DLOAD_1, DLOAD_2, DLOAD_3:\n                    frame.push(JavaKind.Double);\n                    break;\n                case LDC, LDC_W, LDC2_W: {\n                    ldc(bci, frame);\n                    break;\n                }\n                case IALOAD, BALOAD, CALOAD, SALOAD: // fallthrough\n                case IADD, ISUB, IMUL, IDIV, IREM, ISHL, ISHR, IUSHR, IAND, IOR, IXOR: // fallthrough\n                case FCMPL, FCMPG:\n                    frame.pop();\n                    frame.pop();\n                    frame.push(JavaKind.Int);\n                    break;\n                case LALOAD:\n                    frame.pop();\n                    frame.pop();\n                    frame.push(JavaKind.Long);\n                    break;\n                case FALOAD, FADD, FSUB, FMUL, FDIV, FREM:\n                    frame.pop();\n                    frame.pop();\n                    frame.push(JavaKind.Float);\n                    break;\n                case DALOAD:\n                    frame.pop();\n                    frame.pop();\n                    frame.push(JavaKind.Double);\n                    break;\n                case AALOAD:\n                    frame.pop();\n                    frame.pop();\n                    frame.push(JavaKind.Object);\n                    break;\n                case ISTORE:\n                    frame.pop();\n                    frame.putLocal(bs.readLocalIndex(bci), JavaKind.Int);\n                    break;\n                case LSTORE:\n                    frame.pop2();\n                    frame.putLocal(bs.readLocalIndex(bci), JavaKind.Long);\n                    break;\n                case FSTORE:\n                    frame.pop();\n                    frame.putLocal(bs.readLocalIndex(bci), JavaKind.Float);\n                    break;\n                case DSTORE:\n                    frame.pop2();\n                    frame.putLocal(bs.readLocalIndex(bci), JavaKind.Double);\n                    break;\n                case ASTORE:\n                    frame.pop();\n                    frame.putLocal(bs.readLocalIndex(bci), JavaKind.Object);\n                    break;\n                case ISTORE_0, ISTORE_1, ISTORE_2, ISTORE_3:\n                    frame.pop();\n                    frame.putLocal(opcode - ISTORE_0, JavaKind.Int);\n                    break;\n                case LSTORE_0, LSTORE_1, LSTORE_2, LSTORE_3:\n                    frame.pop2();\n                    frame.putLocal(opcode - LSTORE_0, JavaKind.Long);\n                    break;\n                case FSTORE_0, FSTORE_1, FSTORE_2, FSTORE_3:\n                    frame.pop();\n                    frame.putLocal(opcode - FSTORE_0, JavaKind.Float);\n                    break;\n                case DSTORE_0, DSTORE_1, DSTORE_2, DSTORE_3:\n                    frame.pop2();\n                    frame.putLocal(opcode - DSTORE_0, JavaKind.Double);\n                    break;\n                case ASTORE_0, ASTORE_1, ASTORE_2, ASTORE_3:\n                    frame.pop();\n                    frame.putLocal(opcode - ASTORE_0, JavaKind.Object);\n                    break;\n                case IASTORE, FASTORE, AASTORE, BASTORE, CASTORE, SASTORE:\n                    frame.pop();\n                    frame.pop();\n                    frame.pop();\n                    break;\n                case LASTORE, DASTORE:\n                    frame.pop2();\n                    frame.pop();\n                    frame.pop();\n                    break;\n                case POP, MONITORENTER, MONITOREXIT:\n                    frame.pop();\n                    break;\n                case POP2:\n                    frame.pop();\n                    frame.pop();\n                    break;\n                case DUP: {\n                    JavaKind k = frame.pop();\n                    frame.push(k, false);\n                    frame.push(k, false);\n                    break;\n                }\n                case DUP_X1: {\n                    JavaKind v1 = frame.pop();\n                    JavaKind v2 = frame.pop();\n                    frame.push(v1, false);\n                    frame.push(v2, false);\n                    frame.push(v1, false);\n                    break;\n                }\n                case DUP_X2: {\n                    JavaKind v1 = frame.pop();\n                    JavaKind v2 = frame.pop();\n                    JavaKind v3 = frame.pop();\n                    frame.push(v1, false);\n                    frame.push(v3, false);\n                    frame.push(v2, false);\n                    frame.push(v1, false);\n                    break;\n                }\n                case DUP2: {\n                    JavaKind v1 = frame.pop();\n                    JavaKind v2 = frame.pop();\n                    frame.push(v2, false);\n                    frame.push(v1, false);\n                    frame.push(v2, false);\n                    frame.push(v1, false);\n                    break;\n                }\n                case DUP2_X1: {\n                    JavaKind v1 = frame.pop();\n                    JavaKind v2 = frame.pop();\n                    JavaKind v3 = frame.pop();\n                    frame.push(v2, false);\n                    frame.push(v1, false);\n                    frame.push(v3, false);\n                    frame.push(v2, false);\n                    frame.push(v1, false);\n                    break;\n                }\n                case DUP2_X2: {\n                    JavaKind v1 = frame.pop();\n                    JavaKind v2 = frame.pop();\n                    JavaKind v3 = frame.pop();\n                    JavaKind v4 = frame.pop();\n                    frame.push(v2, false);\n                    frame.push(v1, false);\n                    frame.push(v4, false);\n                    frame.push(v3, false);\n                    frame.push(v2, false);\n                    frame.push(v1, false);\n                    break;\n                }\n                case SWAP: {\n                    JavaKind k1 = frame.pop();\n                    JavaKind k2 = frame.pop();\n                    frame.push(k1, false);\n                    frame.push(k2, false);\n                    break;\n                }\n                case LADD, LSUB, LMUL, LDIV, LREM, LSHL, LSHR, LUSHR, LAND, LOR, LXOR:\n                    frame.pop2();\n                    frame.pop2();\n                    frame.push(JavaKind.Long);\n                    break;\n                case DADD, DSUB, DMUL, DDIV, DREM:\n                    frame.pop2();\n                    frame.pop2();\n                    frame.push(JavaKind.Double);\n                    break;\n                case INEG, F2I, I2B, I2C, I2S: // fallthrough\n                case ARRAYLENGTH: // fallthrough\n                case INSTANCEOF:\n                    frame.pop();\n                    frame.push(JavaKind.Int);\n                    break;\n                case LNEG, D2L:\n                    frame.pop2();\n                    frame.push(JavaKind.Long);\n                    break;\n                case FNEG, I2F:\n                    frame.pop();\n                    frame.push(JavaKind.Float);\n                    break;\n                case DNEG, L2D:\n                    frame.pop2();\n                    frame.push(JavaKind.Double);\n                    break;\n                case I2L, F2L:\n                    frame.pop();\n                    frame.push(JavaKind.Long);\n                    break;\n                case I2D, F2D:\n                    frame.pop();\n                    frame.push(JavaKind.Double);\n                    break;\n                case L2I, D2I:\n                    frame.pop2();\n                    frame.push(JavaKind.Int);\n                    break;\n                case L2F, D2F:\n                    frame.pop2();\n                    frame.push(JavaKind.Float);\n                    break;\n                case LCMP, DCMPL, DCMPG:\n                    frame.pop2();\n                    frame.pop2();\n                    frame.push(JavaKind.Int);\n                    break;\n                case IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE, IFNULL, IFNONNULL:\n                    frame.pop();\n                    branch(bci, bs.readBranchDest(bci), frame);\n                    break;\n                case IF_ICMPEQ, IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ACMPEQ, IF_ACMPNE:\n                    frame.pop();\n                    frame.pop();\n                    branch(bci, bs.readBranchDest(bci), frame);\n                    break;\n                case GOTO, GOTO_W:\n                    branch(bci, bs.readBranchDest(bci), frame);\n                    return;\n                case JSR, JSR_W, RET:\n                    throw EspressoError.shouldNotReachHere(\"Should have prevented jsr/ret\");\n                case TABLESWITCH, LOOKUPSWITCH: {\n                    frame.pop();\n                    BytecodeSwitch bytecodeSwitch = BytecodeSwitch.get(bci);\n                    for (int i = 0; i <= bytecodeSwitch.numberOfCases(bs, bci); i++) {\n                        branch(bci, i, frame);\n                    }\n                    branch(bci, bytecodeSwitch.defaultTarget(bs, bci), frame);\n                    return;\n                }\n                case IRETURN, FRETURN, ARETURN, ATHROW:\n                    frame.pop();\n                    return;\n                case LRETURN, DRETURN:\n                    frame.pop2();\n                    return;\n                case RETURN:\n                    return;\n                case GETSTATIC, GETFIELD: {\n                    Symbol<Type> type = pool.fieldAt(bs.readCPI(bci)).getType(pool);\n                    if (opcode == GETFIELD) {\n                        frame.pop();\n                    }\n                    frame.push(Types.getJavaKind(type));\n                    break;\n                }\n                case PUTSTATIC, PUTFIELD: {\n                    Symbol<Type> type = pool.fieldAt(bs.readCPI(bci)).getType(pool);\n                    if (Types.getJavaKind(type).needsTwoSlots()) {\n                        frame.pop2();\n                    } else {\n                        frame.pop();\n                    }\n                    if (opcode == PUTFIELD) {\n                        frame.pop();\n                    }\n                    break;\n                }\n                case INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC, INVOKEINTERFACE: {\n                    handleInvoke(frame, bci, opcode, true);\n                    break;\n                }\n                case NEWARRAY, ANEWARRAY:\n                    frame.pop();\n                    frame.push(JavaKind.Object);\n                    break;\n                case MULTIANEWARRAY: {\n                    int dim = bs.readUByte(bci + 3);\n                    for (int i = 0; i < dim; i++) {\n                        frame.pop();\n                    }\n                    frame.push(JavaKind.Object);\n                    break;\n                }\n                case INVOKEDYNAMIC: {\n                    InvokeDynamicConstant indy = pool.indyAt(bs.readCPI(bci));\n                    Symbol<Type>[] sig = lang.getSignatures().parsed(indy.getSignature(pool));\n                    popSignature(sig, true, frame);\n                    frame.push(Signatures.returnKind(sig));\n                    break;\n                }\n                default:\n                    throw EspressoError.shouldNotReachHere(Bytecodes.nameOf(opcode));\n\n            }\n            la.performPostBCI(frame, bci);\n            if (Bytecodes.canTrap(opcode)) {\n                ExceptionHandler[] handlers = m.getExceptionHandlers();\n                for (ExceptionHandler handler : handlers) {\n                    if (handler.covers(bci)) {\n                        Builder copy = frame.copy();\n                        copy.clearStack();\n                        copy.push(JavaKind.Object);\n                        branch(bci, handler.getHandlerBCI(), copy);\n                    }\n                }\n            }\n            int next = bs.nextBCI(bci);\n            la.performOnEdge(frame, bci, next);\n            bci = next;\n        }\n    }\n\n    private void handleInvoke(Builder frame, int bci, int opcode, boolean pushResult) {\n        MethodRefConstant ref = pool.methodAt(bs.readCPI(bci));\n        Symbol<Type>[] sig = lang.getSignatures().parsed(ref.getSignature(pool));\n        popSignature(sig, opcode == INVOKESTATIC, frame);\n        if (pushResult) {\n            frame.push(Signatures.returnKind(sig));\n        }\n    }\n\n    private boolean merge(int bci, Builder frame) {\n        Builder targetState = states[bci];\n        if (targetState == null) {\n            registerState(bci, frame.copy());\n            return false;\n        }\n        Builder merged = frame.mergeInto(targetState, bci);\n        if (merged == targetState) {\n            return true;\n        }\n        assert la.isEmpty();\n        registerState(bci, merged);\n        return false;\n    }\n\n    private void ldc(int bci, Builder frame) {\n        char cpi = bs.readCPI(bci);\n        ConstantPool.Tag tag = pool.tagAt(cpi);\n        switch (tag) {\n            case INTEGER -> frame.push(JavaKind.Int);\n            case FLOAT -> frame.push(JavaKind.Float);\n            case LONG -> frame.push(JavaKind.Long);\n            case DOUBLE -> frame.push(JavaKind.Double);\n            case CLASS, STRING, METHODHANDLE, METHODTYPE -> frame.push(JavaKind.Object);\n            case DYNAMIC -> frame.push(Types.getJavaKind(((DynamicConstant) pool.at(cpi)).getTypeSymbol(pool)));\n            default -> throw EspressoError.shouldNotReachHere(tag.toString());\n        }\n    }\n\n    private void branch(int from, int target, Builder f) {\n        assert f.isWorking();\n        Builder targetState = states[target];\n        if (targetState == null) {\n            Builder newState = f.copy();\n            la.performOnEdge(newState, from, target);\n            registerState(target, newState);\n            push(target);\n            return;\n        }\n        // The state stored in the states has already been applied liveness analysis.\n        assert targetState.isRecord();\n        Builder merged = f.mergeInto(targetState, target);\n        if (merged == targetState) {\n            return;\n        }\n        assert la.isEmpty();\n        registerState(target, merged);\n        processStatus.clear(target);\n        push(target);\n    }\n\n    private void registerState(int target, Builder newState) {\n        assert newState.isWorking();\n        assert (states[target] == null || (newState.sameTop(states[target])));\n        Builder copy = newState.copy();\n        copy.setBci(target);\n        assert copy.isRecord();\n        states[target] = copy;\n    }\n\n    private void push(int bci) {\n        assert states[bci] != null;\n        assert states[bci].isRecord();\n        queue.push(bci);\n    }\n\n    private int pop() {\n        int next = queue.pop();\n        assert states[next] != null && states[next].isRecord();\n        return next;\n    }\n}",
                "methodCount": 15
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 2,
                "candidates": [
                    {
                        "lineStart": 300,
                        "lineEnd": 306,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method pop to class Builder",
                        "description": "Move method pop to com.oracle.truffle.espresso.vm.continuation.EspressoFrameDescriptor.Builder\nRationale: The `pop` method is manipulating the `Builder` class directly by calling its `pop` method, checking the state of the `kinds` array, and getting the top value from it. Given that it interacts heavily with `Builder`, it is logical to move the `pop` method to the `Builder` class, as this ensures cohesive behavior, encapsulation, and better organization of code responsibilities.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 286,
                        "lineEnd": 298,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method popSignature to class GraphUtil",
                        "description": "move method popSignature to PsiClass:GraphUtil\nRationale: The method `popSignature` deals with stack frames and Java kinds, both of which are closely associated with operations typical of graph and node processing\u2014key domains of the `GraphUtil` class. `GraphUtil` already contains methods managing complex data manipulation, like node elimination (`tryKillUnused`) and validation (`normalizeLoops`). Moving `popSignature` here would align its responsibilities with those of the existing methods.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [],
                    "llm_response_time": 3665
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "popSignature",
                            "method_signature": "private static void popSignature(Symbol<Type>[] sig, boolean isStatic, Builder frame)",
                            "target_class": "Builder",
                            "rationale": "The method `popSignature` deals with operations directly on the `Builder` object, making it more suitable to be in the `Builder` class where related operations are encapsulated."
                        },
                        {
                            "method_name": "ldc",
                            "method_signature": "private void ldc(int bci, Builder frame)",
                            "target_class": "Builder",
                            "rationale": "The `ldc` method primarily manipulates the `Builder` instance based on bytecode information and should therefore reside in the `Builder` class to maintain encapsulation and reduce dependency."
                        },
                        {
                            "method_name": "handleInvoke",
                            "method_signature": "private void handleInvoke(Builder frame, int bci, int opcode, boolean pushResult)",
                            "target_class": "Builder",
                            "rationale": "The method `handleInvoke` manages the state changes in the `Builder` object according to the opcode, indicating that it is better placed within the `Builder` class."
                        }
                    ],
                    "llm_response_time": 3871
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "popSignature",
                            "method_signature": "private static void popSignature(Symbol<Type>[] sig, boolean isStatic, Builder frame)",
                            "target_class": "Builder",
                            "rationale": "This method operates on a `Builder` object and its signature. Handling the signature and popping the frame should logically belong to the `Builder` class."
                        },
                        {
                            "method_name": "ldc",
                            "method_signature": "private void ldc(int bci, Builder frame)",
                            "target_class": "Builder",
                            "rationale": "This method deals with loading constants into the `Builder`. Hence, this process fits better within the `Builder` class itself."
                        },
                        {
                            "method_name": "handleInvoke",
                            "method_signature": "private void handleInvoke(Builder frame, int bci, int opcode, boolean pushResult)",
                            "target_class": "Builder",
                            "rationale": "The `handleInvoke` method is managing the invocation bytecodes by operating on the `Builder` object. This suggests it should be part of the `Builder` class."
                        },
                        {
                            "method_name": "branch",
                            "method_signature": "private void branch(int from, int target, Builder f)",
                            "target_class": "Builder",
                            "rationale": "The `branch` method is closely associated with the decision-making and state transitions in the `Builder` object, indicating it may be better placed inside the `Builder` class."
                        },
                        {
                            "method_name": "registerState",
                            "method_signature": "private void registerState(int target, Builder newState)",
                            "target_class": "Builder",
                            "rationale": "The concept of registering a state is intrinsic to the `Builder` object. Moving this method to the `Builder` class enhances cohesion."
                        }
                    ],
                    "llm_response_time": 4736
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "popSignature",
                            "method_signature": "private static popSignature(Symbol<Type>[] sig, boolean isStatic, Builder frame)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "pop",
                            "method_signature": "private pop(Builder frame, JavaKind k)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "apply",
                            "method_signature": "private apply()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "buildInitialFrame",
                            "method_signature": "private buildInitialFrame()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "markBranchTargets",
                            "method_signature": "private markBranchTargets()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "buildStates",
                            "method_signature": "private buildStates(int startBci)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleInvoke",
                            "method_signature": "private handleInvoke(Builder frame, int bci, int opcode, boolean pushResult)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "merge",
                            "method_signature": "private merge(int bci, Builder frame)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "ldc",
                            "method_signature": "private ldc(int bci, Builder frame)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "branch",
                            "method_signature": "private branch(int from, int target, Builder f)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "registerState",
                            "method_signature": "private registerState(int target, Builder newState)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "registerState",
                            "method_signature": "private registerState(int target, Builder newState)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "ldc",
                            "method_signature": "private ldc(int bci, Builder frame)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "apply",
                            "method_signature": "private apply()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "branch",
                            "method_signature": "private branch(int from, int target, Builder f)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "buildStates",
                            "method_signature": "private buildStates(int startBci)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "merge",
                            "method_signature": "private merge(int bci, Builder frame)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleInvoke",
                            "method_signature": "private handleInvoke(Builder frame, int bci, int opcode, boolean pushResult)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "pop",
                            "method_signature": "private pop(Builder frame, JavaKind k)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "buildInitialFrame",
                            "method_signature": "private buildInitialFrame()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "markBranchTargets",
                            "method_signature": "private markBranchTargets()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "popSignature",
                            "method_signature": "private static popSignature(Symbol<Type>[] sig, boolean isStatic, Builder frame)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "private registerState(int target, Builder newState)": {
                        "first": {
                            "method_name": "registerState",
                            "method_signature": "private registerState(int target, Builder newState)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3767297832725886
                    },
                    "private ldc(int bci, Builder frame)": {
                        "first": {
                            "method_name": "ldc",
                            "method_signature": "private ldc(int bci, Builder frame)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4423096149404436
                    },
                    "private apply()": {
                        "first": {
                            "method_name": "apply",
                            "method_signature": "private apply()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.45372036683892414
                    },
                    "private branch(int from, int target, Builder f)": {
                        "first": {
                            "method_name": "branch",
                            "method_signature": "private branch(int from, int target, Builder f)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.455083786623885
                    },
                    "private buildStates(int startBci)": {
                        "first": {
                            "method_name": "buildStates",
                            "method_signature": "private buildStates(int startBci)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.46680791989044085
                    },
                    "private merge(int bci, Builder frame)": {
                        "first": {
                            "method_name": "merge",
                            "method_signature": "private merge(int bci, Builder frame)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.47383194471646267
                    },
                    "private handleInvoke(Builder frame, int bci, int opcode, boolean pushResult)": {
                        "first": {
                            "method_name": "handleInvoke",
                            "method_signature": "private handleInvoke(Builder frame, int bci, int opcode, boolean pushResult)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4968112184203771
                    },
                    "private pop(Builder frame, JavaKind k)": {
                        "first": {
                            "method_name": "pop",
                            "method_signature": "private pop(Builder frame, JavaKind k)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5064861003165091
                    },
                    "private buildInitialFrame()": {
                        "first": {
                            "method_name": "buildInitialFrame",
                            "method_signature": "private buildInitialFrame()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5887162415501516
                    },
                    "private markBranchTargets()": {
                        "first": {
                            "method_name": "markBranchTargets",
                            "method_signature": "private markBranchTargets()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6089160095968222
                    },
                    "private static popSignature(Symbol<Type>[] sig, boolean isStatic, Builder frame)": {
                        "first": {
                            "method_name": "popSignature",
                            "method_signature": "private static popSignature(Symbol<Type>[] sig, boolean isStatic, Builder frame)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6421399808976201
                    }
                },
                "voyage": {
                    "private registerState(int target, Builder newState)": {
                        "first": {
                            "method_name": "registerState",
                            "method_signature": "private registerState(int target, Builder newState)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3947867800857989
                    },
                    "private static popSignature(Symbol<Type>[] sig, boolean isStatic, Builder frame)": {
                        "first": {
                            "method_name": "popSignature",
                            "method_signature": "private static popSignature(Symbol<Type>[] sig, boolean isStatic, Builder frame)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.45335360328110097
                    },
                    "private pop(Builder frame, JavaKind k)": {
                        "first": {
                            "method_name": "pop",
                            "method_signature": "private pop(Builder frame, JavaKind k)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4888380533783951
                    },
                    "private branch(int from, int target, Builder f)": {
                        "first": {
                            "method_name": "branch",
                            "method_signature": "private branch(int from, int target, Builder f)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5050556647179599
                    },
                    "private handleInvoke(Builder frame, int bci, int opcode, boolean pushResult)": {
                        "first": {
                            "method_name": "handleInvoke",
                            "method_signature": "private handleInvoke(Builder frame, int bci, int opcode, boolean pushResult)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5157339735491936
                    },
                    "private merge(int bci, Builder frame)": {
                        "first": {
                            "method_name": "merge",
                            "method_signature": "private merge(int bci, Builder frame)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5255246884347127
                    },
                    "private markBranchTargets()": {
                        "first": {
                            "method_name": "markBranchTargets",
                            "method_signature": "private markBranchTargets()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5792039312724006
                    },
                    "private buildInitialFrame()": {
                        "first": {
                            "method_name": "buildInitialFrame",
                            "method_signature": "private buildInitialFrame()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6108912116641331
                    },
                    "private ldc(int bci, Builder frame)": {
                        "first": {
                            "method_name": "ldc",
                            "method_signature": "private ldc(int bci, Builder frame)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6623733003780894
                    },
                    "private apply()": {
                        "first": {
                            "method_name": "apply",
                            "method_signature": "private apply()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.701626592931075
                    },
                    "private buildStates(int startBci)": {
                        "first": {
                            "method_name": "buildStates",
                            "method_signature": "private buildStates(int startBci)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7795466620662646
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private buildStates(int startBci)",
                        "private markBranchTargets()",
                        "private buildInitialFrame()",
                        "private handleInvoke(Builder frame, int bci, int opcode, boolean pushResult)",
                        "private branch(int from, int target, Builder f)",
                        "private merge(int bci, Builder frame)",
                        "private ldc(int bci, Builder frame)",
                        "private registerState(int target, Builder newState)",
                        "private pop(Builder frame, JavaKind k)",
                        "private apply()",
                        "private static popSignature(Symbol<Type>[] sig, boolean isStatic, Builder frame)"
                    ],
                    "llm_response_time": 2907
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "private buildStates(int startBci)",
                        "private branch(int from, int target, Builder f)",
                        "private registerState(int target, Builder newState)",
                        "private ldc(int bci, Builder frame)",
                        "private apply()"
                    ],
                    "llm_response_time": 3690
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private apply()",
                        "private registerState(int target, Builder newState)",
                        "private ldc(int bci, Builder frame)"
                    ],
                    "llm_response_time": 4738
                },
                "voyage": {
                    "priority_method_names": [
                        "private static popSignature(Symbol<Type>[] sig, boolean isStatic, Builder frame)",
                        "private pop(Builder frame, JavaKind k)",
                        "private handleInvoke(Builder frame, int bci, int opcode, boolean pushResult)",
                        "private ldc(int bci, Builder frame)",
                        "private registerState(int target, Builder newState)",
                        "private merge(int bci, Builder frame)",
                        "private branch(int from, int target, Builder f)",
                        "private markBranchTargets()",
                        "private buildInitialFrame()",
                        "private buildStates(int startBci)",
                        "private apply()"
                    ],
                    "llm_response_time": 5339
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private static popSignature(Symbol<Type>[] sig, boolean isStatic, Builder frame)",
                        "private handleInvoke(Builder frame, int bci, int opcode, boolean pushResult)",
                        "private branch(int from, int target, Builder f)",
                        "private registerState(int target, Builder newState)",
                        "private pop(Builder frame, JavaKind k)"
                    ],
                    "llm_response_time": 4130
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private static popSignature(Symbol<Type>[] sig, boolean isStatic, Builder frame)",
                        "private pop(Builder frame, JavaKind k)",
                        "private registerState(int target, Builder newState)"
                    ],
                    "llm_response_time": 3185
                }
            },
            "targetClassMap": {
                "registerState": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3103,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "ldc": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4145,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "apply": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3739,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "branch": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3286,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "buildStates": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4304,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "merge": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2788,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "handleInvoke": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3542,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "pop": {
                    "target_classes": [
                        {
                            "class_name": "Builder",
                            "similarity_score": 0.6004190930141866
                        },
                        {
                            "class_name": "JavaKind",
                            "similarity_score": 0.47670303670344766
                        },
                        {
                            "class_name": "EspressoLanguage",
                            "similarity_score": 0.5355833212171145
                        },
                        {
                            "class_name": "MethodVersion",
                            "similarity_score": 0.617087757184675
                        },
                        {
                            "class_name": "LivenessAnalysis",
                            "similarity_score": 0.5520993165201306
                        },
                        {
                            "class_name": "BytecodeStream",
                            "similarity_score": 0.37241053203483593
                        },
                        {
                            "class_name": "ConstantPool",
                            "similarity_score": 0.5163254715513826
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Builder",
                        "LivenessAnalysis",
                        "MethodVersion"
                    ],
                    "llm_response_time": 4000,
                    "similarity_computation_time": 10,
                    "similarity_metric": "cosine"
                },
                "buildInitialFrame": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3121,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "markBranchTargets": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3387,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "popSignature": {
                    "target_classes": [
                        {
                            "class_name": "Util",
                            "similarity_score": 0.6476589860599845
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.589241899558793
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.45877759284039427
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.5590454158338585
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.5448323383621696
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.613311389110916
                        },
                        {
                            "class_name": "Utils",
                            "similarity_score": 0.43219608579517754
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.6234988151151662
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.6688114228890165
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.5090391824387153
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.4914799196462915
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.5764363350677574
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.40712826560868287
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.5147026082155801
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.5230652901927886
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.4276433946595939
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.6375588214939957
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.5747418731388725
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.3530434122277525
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.43442675096440736
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.4513683024091646
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.46408409744989865
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.557724619743212
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.5488487051459883
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.5073614386739402
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.39071281509197453
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.6165770779109557
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.34703952827571904
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.3687533717186978
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.42671306376431994
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.5487833840826932
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.39793990046684397
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.698479233997502
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.6135993163917004
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.6007656962928867
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.5494847512014115
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.4385388728874624
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.4942165808414715
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.6110218571800227
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.24699212498879328
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.5856532123153049
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.5011589355903016
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.550811917947874
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.40759213918908754
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.46937171907908604
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.5615409357557373
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.47210288625573577
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.31221181874292175
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.2512448332625903
                        },
                        {
                            "class_name": "Target_java_util_concurrent_locks_AbstractOwnableSynchronizer",
                            "similarity_score": 0.6053674710792153
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.6195582431419406
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.49398803687730497
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.3723187320409216
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.47283022137062086
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.5949289177914677
                        },
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.6778781226504315
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.5427049711816605
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.5368574408037822
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.4493306296887526
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.27187266778738295
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.46691514624524866
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.5714757391143074
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.5489056050906037
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.6264875326108492
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.5005821203789286
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.5483952411481793
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.37530596503786307
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.6404230597816931
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.2719205837053269
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.3597433655919084
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.23081102802702852
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.25198893185505744
                        },
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.46078657307963256
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.5695596312204558
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.6273275464702619
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.32456904453882107
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.4885565727344019
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.31421884257798
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.6674405327476761
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.5205700775643539
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.41645667189847796
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.3564544259682249
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.5378410475424181
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.36535516408189733
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.48910515007962796
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.42384796981348644
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.439705639805931
                        },
                        {
                            "class_name": "AtomicBoolean",
                            "similarity_score": 0.5549040245349087
                        },
                        {
                            "class_name": "AtomicInteger",
                            "similarity_score": 0.46676972117173554
                        },
                        {
                            "class_name": "AtomicLong",
                            "similarity_score": 0.44379583407382
                        },
                        {
                            "class_name": "AtomicPointer",
                            "similarity_score": 0.531549151105534
                        },
                        {
                            "class_name": "AtomicReference",
                            "similarity_score": 0.5303002368360675
                        },
                        {
                            "class_name": "AtomicUnsigned",
                            "similarity_score": 0.17766019547258607
                        },
                        {
                            "class_name": "AtomicWord",
                            "similarity_score": 0.1962691052369491
                        },
                        {
                            "class_name": "CEntryPointUtilityNode",
                            "similarity_score": 0.4912848035345693
                        },
                        {
                            "class_name": "ExitException",
                            "similarity_score": 0.42785921963963236
                        },
                        {
                            "class_name": "InvalidMacroException",
                            "similarity_score": 0.42420535923005726
                        },
                        {
                            "class_name": "StackElement",
                            "similarity_score": 0.4466592858469899
                        },
                        {
                            "class_name": "UnsafeMemoryUtil",
                            "similarity_score": 0.4386205999499751
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.472361244295727
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "GraphUtil",
                        "FileUtils",
                        "Target_java_util_regex_Pattern"
                    ],
                    "llm_response_time": 3942,
                    "similarity_computation_time": 82,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "980115905f92f0abdc70769d2118711bf563ce5f",
        "url": "https://github.com/oracle/graal/commit/980115905f92f0abdc70769d2118711bf563ce5f",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public areNextInOrder(block HIRBlock, successor HIRBlock) : boolean extracted from public isNormalLoopExit(block HIRBlock, successor HIRBlock, stackifierData StackifierData) : boolean in class jdk.graal.compiler.hightiercodegen.reconstruction.stackifier.blocks.LabeledBlockGeneration & moved to class jdk.graal.compiler.hightiercodegen.reconstruction.StackifierData",
            "leftSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/hightiercodegen/reconstruction/stackifier/blocks/LabeledBlockGeneration.java",
                    "startLine": 330,
                    "endLine": 373,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "public isNormalLoopExit(block HIRBlock, successor HIRBlock, stackifierData StackifierData) : boolean"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/hightiercodegen/reconstruction/stackifier/blocks/LabeledBlockGeneration.java",
                    "startLine": 370,
                    "endLine": 370,
                    "startColumn": 13,
                    "endColumn": 67,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/hightiercodegen/reconstruction/StackifierData.java",
                    "startLine": 112,
                    "endLine": 118,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public areNextInOrder(block HIRBlock, successor HIRBlock) : boolean"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/hightiercodegen/reconstruction/StackifierData.java",
                    "startLine": 117,
                    "endLine": 117,
                    "startColumn": 9,
                    "endColumn": 63,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/hightiercodegen/reconstruction/stackifier/blocks/LabeledBlockGeneration.java",
                    "startLine": 330,
                    "endLine": 373,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "public isNormalLoopExit(block HIRBlock, successor HIRBlock, stackifierData StackifierData) : boolean"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/hightiercodegen/reconstruction/stackifier/blocks/LabeledBlockGeneration.java",
                    "startLine": 370,
                    "endLine": 370,
                    "startColumn": 20,
                    "endColumn": 75,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "stackifierData.areNextInOrder(lastLoopBlock,successor)"
                }
            ],
            "isStatic": false
        },
        "ref_id": 520,
        "extraction_results": {
            "success": true,
            "newCommitHash": "1474cba384b3ef13c94e9c2e47139550049c5880",
            "newBranchName": "extract-areNextInOrder-isNormalLoopExit-2adb917"
        },
        "telemetry": {
            "id": "4fb6078a-e3b3-4c53-b716-22a50586923d",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 494,
                "lineStart": 53,
                "lineEnd": 546,
                "bodyLineStart": 53,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/hightiercodegen/reconstruction/stackifier/blocks/LabeledBlockGeneration.java",
                "sourceCode": "/**\n * This class generates {@link LabeledBlock}s that enable us to do forward jumps and skip over basic\n * blocks.\n *\n * This class iterates over all basic blocks and checks for each forward edge if a\n * {@link LabeledBlock} is needed and generates one if that is the case. We store mappings from\n * {@link HIRBlock} to {@link LabeledBlock} in order to store where a {@link LabeledBlock} starts\n * and ends. {@link StackifierIRWalker} uses these maps to generate the corresponding code before\n * each basic block.\n *\n * See {@link StackifierIRWalker} for some examples.\n *\n */\npublic class LabeledBlockGeneration {\n\n    public static final String LabeledBlockPrefix = \"lb\";\n\n    /**\n     * The beginnings of the LabeledBlocks need to be sorted such that the outermost block is\n     * generated first and the innermost block last, if multiple labeled blocks start at the same\n     * basic block.\n     */\n    protected final EconomicMap<HIRBlock, SortedSet<LabeledBlock>> labeledBlockStarts = EconomicMap.create();\n    protected final EconomicMap<HIRBlock, LabeledBlock> labeledBlockEnds = EconomicMap.create();\n\n    protected final LabeledBlockGenerator labeledBlockGenerator = new LabeledBlockGenerator();\n    protected final ControlFlowGraph cfg;\n    protected final StackifierData stackifierData;\n\n    public LabeledBlockGeneration(StackifierData stackifierData, ControlFlowGraph cfg) {\n        this.stackifierData = stackifierData;\n        this.cfg = cfg;\n    }\n\n    /**\n     * Checks whether a LabeledBlock needs to be generated for the edge from block to successor. No\n     * LabeledBlock will be generated if the successor is reached via a back edge, i.e. the block is\n     * a loop end.\n     *\n     * Example: Suppose we have the Java program where A, B and C roughly correspond to basic\n     * blocks.\n     *\n     * <pre>\n     * if (A()) {\n     *     B();\n     * }\n     * C();\n     * </pre>\n     *\n     * The only valid topological order is A->B->C. The basic blocks will be lowered in that order.\n     * The basic block A has two successors, namely B and C. The code for B can be generated\n     * directly after A, since B directly follows A. Therefore we do not need a {@link LabeledBlock}\n     * in that case. But for the successor C we need a jump that skips B. Therefore for A and C a\n     * {@link LabeledBlock} is needed. This will produce the following pseudocode.\n     *\n     * <pre>\n     * block0: {\n     *     if (A()) {\n     *\n     *     } else {\n     *         break block0;\n     *     }\n     *     B();\n     * } // block0\n     * C();\n     * </pre>\n     *\n     * @param block start of the edge\n     * @param successor end of the edge\n     * @return true iff a {@link LabeledBlock} is needed\n     */\n    public boolean isLabeledBlockNeeded(HIRBlock block, HIRBlock successor) {\n        if (assertionsEnabled()) {\n            boolean found = false;\n            for (int i = 0; i < block.getSuccessorCount(); i++) {\n                HIRBlock s = block.getSuccessorAt(i);\n                found = found || s == successor;\n            }\n            assert found;\n        }\n        ScopeContainer scopeContainer = stackifierData.getScopeEntry(block.getEndNode());\n        if (block.isLoopEnd()) {\n            assert block.getSuccessorCount() == 1 : Assertions.errorMessage(block);\n            // loopEndNodes have back edges and therefore do not need a forward jump\n            return false;\n        }\n        if (isNormalLoopExit(block, successor, stackifierData)) {\n            return false;\n        }\n\n        if (block.getEndNode() instanceof IfNode) {\n            if (((IfNode) block.getEndNode()).trueSuccessor() == successor.getBeginNode()) {\n                // successor is the true successor\n                if (((IfScopeContainer) scopeContainer).getThenScope() != null) {\n                    return false;\n                }\n            } else {\n                if (((IfScopeContainer) scopeContainer).getElseScope() != null) {\n                    return false;\n                }\n            }\n        } else if (block.getEndNode() instanceof InvokeWithExceptionNode) {\n            InvokeWithExceptionNode invokeWithExc = (InvokeWithExceptionNode) block.getEndNode();\n            if (invokeWithExc.getPrimarySuccessor() == successor.getBeginNode()) {\n                return !isJumpingOverCatchBlock(block, successor, stackifierData);\n            } else {\n                assert invokeWithExc.exceptionEdge() == successor.getBeginNode() : Assertions.errorMessage(invokeWithExc, successor);\n                if (((CatchScopeContainer) scopeContainer).getCatchScope() != null) {\n                    return false;\n                }\n            }\n        } else if (block.getEndNode() instanceof IntegerSwitchNode) {\n            IntegerSwitchNode switchNode = (IntegerSwitchNode) block.getEndNode();\n            Scope[] caseScopes = ((SwitchScopeContainer) stackifierData.getScopeEntry(switchNode)).getCaseScopes();\n            for (int i = 0; i < switchNode.getSuccessorCount(); i++) {\n                if (switchNode.blockSuccessor(i) == successor.getBeginNode()) {\n                    return caseScopes[i] == null;\n                }\n            }\n            GraalError.shouldNotReachHere(\"successor of switchnode not found in its successor list\"); // ExcludeFromJacocoGeneratedReport\n        }\n        if (isLastBlockInThenBranch(block, stackifierData)) {\n            return !isJumpingToAfterElseBranch(block, successor, stackifierData);\n        }\n        if (isLastBlockInSwitchArm(block, stackifierData)) {\n            /*\n             * Always generate a labeled block around switch statements as a target for switch arms\n             * to jump out of. This can result in less than optimal code if all switch arms jump to\n             * the merge block after the switch, but determining that is tricky to do correctly\n             * without having knowing the order in which blocks will be lowered.\n             */\n            return true;\n        }\n        return successor.getId() != block.getId() + 1;\n    }\n\n    /**\n     * Checks if the last block in a then branch jumps to after the else scope of an {@link IfNode}.\n     *\n     * Example:\n     *\n     * <pre>\n     * if (condition) {\n     *     A();\n     * } else {\n     *     B();\n     * }\n     * C();\n     * </pre>\n     *\n     * In the example above, we have an edge from the basic block {@code A} to {@code C}. We do not\n     * need a labeled break for this edge, since we jump to {@code C} automatically from {@code A}.\n     *\n     * @param block last block in a then-branch of an {@link IfNode}, see\n     *            {@link #isLastBlockInThenBranch}\n     * @param successor target of the jump\n     * @return true iff the edge from {@code block} to {@code successor} jumps over the else scope\n     *         of the {@link IfNode}\n     */\n    private static boolean isJumpingToAfterElseBranch(HIRBlock block, HIRBlock successor, StackifierData stackifierData) {\n        Scope scope = stackifierData.getEnclosingScope().get(block);\n        HIRBlock startBlock = scope.getStartBlock();\n        IfScopeContainer ifScopeContainer = (IfScopeContainer) stackifierData.getScopeEntry(startBlock.getEndNode());\n        Scope elseScope = ifScopeContainer.getElseScope();\n        if (elseScope == null) {\n            return false;\n        }\n        HIRBlock[] blocks = stackifierData.getBlocks();\n        for (int id = block.getId() + 1; id < successor.getId(); id++) {\n            if (!elseScope.getBlocks().contains(blocks[id])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks if the given block is the last block in the then-branch of an {@link IfNode}.\n     *\n     * Example:\n     *\n     * <pre>\n     * if (condition) {\n     *     A();\n     *     B();\n     * } else {\n     *     C();\n     * }\n     * </pre>\n     *\n     * For the example above this function returns true for the basic block {@code B} and false\n     * otherwise.\n     */\n    private static boolean isLastBlockInThenBranch(HIRBlock block, StackifierData stackifierData) {\n        Scope scope = stackifierData.getEnclosingScope().get(block);\n        if (scope != null) {\n            HIRBlock startBlock = scope.getStartBlock();\n            if (startBlock.getEndNode() instanceof IfNode) {\n                IfScopeContainer ifScopeContainer = (IfScopeContainer) stackifierData.getScopeEntry(startBlock.getEndNode());\n                return ifScopeContainer.getThenScope() == scope && scope.getLastBlock() == block;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the given block is the last block in one of the arms of an\n     * {@link IntegerSwitchNode}.\n     *\n     * Example:\n     *\n     * <pre>\n     * switch (x) {\n     *     case 1:\n     *         A();\n     *         B();\n     *         break;\n     * }\n     * C();\n     * </pre>\n     *\n     * For the example above this function returns true for the basic block {@code B} and false\n     * otherwise.\n     */\n    private static boolean isLastBlockInSwitchArm(HIRBlock block, StackifierData stackifierData) {\n        Scope scope = stackifierData.getEnclosingScope().get(block);\n        if (scope != null) {\n            HIRBlock startBlock = scope.getStartBlock();\n            if (startBlock.getEndNode() instanceof IntegerSwitchNode) {\n                return scope.getLastBlock() == block;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the edge from {@code block} to {@code successor} is jumping over all\n     * {@link HIRBlock}s in the catch scope.\n     * <p>\n     * Example:\n     *\n     * <pre>\n     *     try {\n     *         A()\n     *     } catch (e) {\n     *         B(e);\n     *     }\n     *     C();\n     * </pre>\n     * <p>\n     * In the above example, basic block {@code C} is the primary successor of {@code A}. For this\n     * edge we do not need to generate a labeled break because at the end of the {@code try} block,\n     * we jump to after the catch block implicitly.\n     *\n     * @param block block ending with a {@link InvokeWithExceptionNode}\n     * @param successor primary successor of the {@link InvokeWithExceptionNode}\n     */\n    private static boolean isJumpingOverCatchBlock(HIRBlock block, HIRBlock successor, StackifierData stackifierData) {\n        assert block.getEndNode() instanceof InvokeWithExceptionNode : Assertions.errorMessage(block, block.getEndNode());\n        assert block.getFirstSuccessor() == successor : Assertions.errorMessage(block, successor);\n        CatchScopeContainer catchScopeContainer = (CatchScopeContainer) stackifierData.getScopeEntry(block.getEndNode());\n        Scope catchScope = catchScopeContainer.getCatchScope();\n\n        if (catchScope == null) {\n            return false;\n        }\n\n        EconomicSet<HIRBlock> blocksInCatchScope = catchScope.getBlocks();\n        HIRBlock[] allBlocks = stackifierData.getBlocks();\n        for (int id = block.getId() + 1; id < successor.getId(); id++) {\n            if (!blocksInCatchScope.contains(allBlocks[id])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Check if the jump from {@code block} to {@code successor} is a simple break out of a loop. In\n     * that case the jump can be simply done with a {@code break looplabel}, without having to\n     * generate a {@link LabeledBlock}. Not \"normal\" loop exits can be caused by loops with multiple\n     * exits that go to different basic blocks.\n     *\n     * Example:\n     *\n     * <pre>\n     * block0: {\n     *     while (condition) {\n     *         A();\n     *         if (condition1) {\n     *             break;\n     *         }\n     *         B();\n     *         if (condition2) {\n     *             break block0;\n     *         }\n     *         C();\n     *     } // end loop\n     *     D();\n     * } // block0\n     * E();\n     * </pre>\n     *\n     * In the above example, the break in the first if is a \"normal\" jump out of the loop and\n     * therefore does not need a {@link LabeledBlock}. The second break jumps out of the loop and\n     * skips some code after the loop. This jump needs a {@link LabeledBlock}.\n     *\n     * @param block start of the jump\n     * @param successor end of the jump\n     * @param stackifierData data from cf reconstruction\n     * @return true iff the jump from block to successor can be done with a simple break statement,\n     *         i.e. jump to the end of the loop.\n     */\n    public static boolean isNormalLoopExit(HIRBlock block, HIRBlock successor, StackifierData stackifierData) {\n        CFGLoop<HIRBlock> l1 = block.getLoop();\n        if (l1 != null) {\n            HIRBlock lastLoopBlock = ((LoopScopeContainer) stackifierData.getScopeEntry(l1.getHeader().getBeginNode())).getLoopScope().getLastBlock();\n            return lastLoopBlock.getId() + 1 == successor.getId();\n        }\n        return false;\n    }\n\n    private boolean areNextInOrder(HIRBlock successor, HIRBlock lastLoopBlock) {\n        return lastLoopBlock.getId() + 1 == successor.getId();\n    }\n\n    /**\n     * Creates a new sortedSet for {@link LabeledBlock}. The {@link LabeledBlock} are sorted such\n     * that the block that closes last comes first, i.e. they are sorted by descending block id of\n     * their ending basic blocks. This is useful for sorting {@link LabeledBlock} that start at the\n     * same basic block such that the outermost {@link LabeledBlock} comes first and the innermost\n     * last.\n     *\n     * @return sorted Set according to the ends of the {@link LabeledBlock}s\n     */\n    public static SortedSet<LabeledBlock> getSortedSetByLabeledBlockEnd() {\n        return new TreeSet<>((b1, b2) -> b2.getEnd().getId() - b1.getEnd().getId());\n    }\n\n    private static HIRBlock commonDominatorFor(HIRBlock b, boolean pred) {\n        HIRBlock commonDom = null;\n        for (int i = 0; i < (pred ? b.getPredecessorCount() : b.getSuccessorCount()); i++) {\n            HIRBlock block = pred ? b.getPredecessorAt(i) : b.getSuccessorAt(i);\n            commonDom = (HIRBlock) AbstractControlFlowGraph.commonDominator(commonDom, block);\n        }\n        return commonDom;\n    }\n\n    /**\n     * Iterates over all basic block and checks for each forward edge if a {@link LabeledBlock} is\n     * needed. If a {@link LabeledBlock} already ends at the jump target, no new\n     * {@link LabeledBlock} is generated and instead the existing one will be used.\n     */\n    public void generateLabeledBlocks() {\n        stackifierData.setLabeledBlockStarts(labeledBlockStarts);\n        stackifierData.setLabeledBlockEnd(labeledBlockEnds);\n\n        for (HIRBlock block : stackifierData.getBlocks()) {\n            for (int i = 0; i < block.getSuccessorCount(); i++) {\n                HIRBlock successor = block.getSuccessorAt(i);\n                if (isLabeledBlockNeeded(block, successor)) {\n                    HIRBlock labeledBlockStart = getLabeledBlockStart(block, successor);\n\n                    if (!labeledBlockEndsBeforeBasicBlock(successor)) {\n                        LabeledBlock labeledBlock = labeledBlockGenerator.generateLabeledBlock(labeledBlockStart, successor);\n                        addToMaps(labeledBlock);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Get the position where a LabeledBlock can start. Compute common dominator of all predecessors\n     * of {@code successor} and then move the start of the LabeledBlock up until all\n     * {@link LabeledBlock} that end between {@code predecessor} and {@code successor} are closed.\n     *\n     * The end of the {@link LabeledBlock} is determined by the jump target, e.g. it has to end\n     * before C in the example below. But for the start of the {@link LabeledBlock} we have more\n     * freedom. We could place the start at the very beginning of the function (or if we are inside\n     * a loop, right after the loop header). This would result in very deeply nested blocks. The\n     * later the block start is generated the lower the nesting will be. Therefore, we try to place\n     * the start as late as possible.\n     *\n     * For this 2 things need to be considered. If multiple basic blocks jump to the target, all\n     * these basic blocks must be contained within the {@link LabeledBlock}. Secondly, since the\n     * {@link LabeledBlock} cannot overlap, we have to put the start before all\n     * {@link LabeledBlock}s that end between {@code predecessor} and {@code successor}.\n     *\n     * Example: Suppose we have the Java program:\n     *\n     * <pre>\n     * if (A()) {\n     *     B();\n     * } else {\n     *     C();\n     * }\n     * D();\n     * </pre>\n     *\n     * If we have the topological order A->B->C->D we need a {@link LabeledBlock} from B to D in\n     * order to jump over C. D has two predecessors, namely B and C, which are dominated by A. Thus\n     * the {@link LabeledBlock} has to start at least before A. If there were {@link LabeledBlock}s\n     * ending between {@code predecessor} and {@code successor}, we would place the start of the new\n     * {@link LabeledBlock} before all of them.\n     *\n     * @param predecessor basic block from where the jump is done\n     * @param successor target of the jump\n     * @return basic block where the \"blockLabel:{ ...\" should be placed\n     */\n    private HIRBlock getLabeledBlockStart(HIRBlock predecessor, HIRBlock successor) {\n        HIRBlock earliestStart = predecessor;\n        if (successor.getPredecessorCount() > 1) {\n            earliestStart = commonDominatorFor(successor, true);\n        }\n        Scope startScope = stackifierData.getEnclosingScope().get(earliestStart);\n        Scope endScope = stackifierData.getEnclosingScope().get(successor);\n        if (successor.isLoopHeader()) {\n            /**\n             * Special case when successor is a loop header: A loop scope includes the loopHeader\n             * (see {@link StackifierScopeComputation#computeLoopScopes()}), whereas other scopes do\n             * not include the basic block that creates a scope. For example, a basic block\n             * containing an {@link IfNode} does not belong to the respective then-scope a\n             * else-scope. Consequently, if successor is a loop Header, {@code endScope} is the\n             * loopScope created by {@code successor}. But we want to jump to just before\n             * {@code successor}. Therefore, {@code endScope} should be the scope that contains the\n             * loop created by {@code successor} which is the parent scope.\n             */\n            endScope = endScope.getParentScope();\n        }\n        if (startScope != endScope) {\n            while (startScope != null && startScope.getParentScope() != endScope) {\n                startScope = startScope.getParentScope();\n            }\n            if (startScope == null) {\n                assert endScope == null : cfg.graph.method().getDeclaringClass().getUnqualifiedName() + \".\" + cfg.graph.method().getName() + \" Cannot jump from start of a method into a scope \" +\n                                endScope;\n                earliestStart = cfg.getStartBlock();\n            } else {\n                earliestStart = startScope.getStartBlock();\n            }\n        }\n        for (HIRBlock b : labeledBlockEnds.getKeys()) {\n            if (predecessor.getId() < b.getId() && b.getId() < successor.getId()) {\n                // a LabeledBlock ends between break and \".. }\"\n                LabeledBlock forwardBlock = labeledBlockEnds.get(b);\n                if (forwardBlock.getStart().getId() < earliestStart.getId()) {\n                    earliestStart = forwardBlock.getStart();\n                }\n            }\n        }\n        return earliestStart;\n    }\n\n    /**\n     * Checks if a {@link LabeledBlock} ends before the given basic block.\n     *\n     * @param labeledBlockEnd basic block for which a {@link LabeledBlock} is queried\n     * @return true iff a {@link LabeledBlock} ends before {@code labeledBlockEnd}\n     */\n    private boolean labeledBlockEndsBeforeBasicBlock(HIRBlock labeledBlockEnd) {\n        return labeledBlockEnds.get(labeledBlockEnd) != null;\n    }\n\n    /**\n     * Stores the given {@link LabeledBlock} in maps that map from {@link HIRBlock} to the start and\n     * end of the given {@link LabeledBlock}. These maps will be used in the\n     * {@link StackifierIRWalker} for generating the corresponding code before or after a basic\n     * block.\n     *\n     * @param labeledBLock block to be stored in the maps\n     */\n    private void addToMaps(LabeledBlock labeledBLock) {\n        if (labeledBlockStarts.get(labeledBLock.getStart()) == null) {\n            labeledBlockStarts.put(labeledBLock.getStart(), getSortedSetByLabeledBlockEnd());\n        }\n        labeledBlockStarts.get(labeledBLock.getStart()).add(labeledBLock);\n        HIRBlock endBlock = labeledBLock.getEnd();\n        assert !labeledBlockEnds.containsKey(endBlock);\n        labeledBlockEnds.put(endBlock, labeledBLock);\n    }\n\n    /**\n     * Generates {@link LabeledBlock}s with unique labels.\n     */\n    private static class LabeledBlockGenerator {\n\n        private int currentId = 0;\n\n        public LabeledBlock generateLabeledBlock(HIRBlock start, HIRBlock end) {\n            return new LabeledBlock(start, end, currentId++);\n        }\n    }\n}",
                "methodCount": 15
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 9,
                "candidates": [
                    {
                        "lineStart": 374,
                        "lineEnd": 376,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method areNextInOrder to class HIRBlock",
                        "description": "Move method areNextInOrder to jdk.graal.compiler.nodes.cfg.HIRBlock\nRationale: The method `areNextInOrder` directly references properties of the HIRBlock class (e.g., getId()) to determine the order of blocks. This makes it tightly coupled with the HIRBlock class. Moving this method to HIRBlock will reduce unnecessary coupling with other classes and will allow direct access to HIRBlock attributes and methods, which is a better design choice.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 391,
                        "lineEnd": 398,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method commonDominatorFor to class BundleSerializationUtils",
                        "description": "move method commonDominatorFor to PsiClass:BundleSerializationUtils\nRationale: The method commonDominatorFor() involves iterating through predecessors or successors and requires finding a common dominator. This more closely aligns with the utility functions found in BundleSerializationUtils, which deals with serialized content extraction. Moving the method to this class increases cohesion as both method and class are oriented towards data and control-flow manipulation, which doesn't fit in the String-related classes.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 516,
                        "lineEnd": 532,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method addToMaps to class LabeledBlockGenerator",
                        "description": "Move method addToMaps to jdk.graal.compiler.hightiercodegen.reconstruction.stackifier.blocks.LabeledBlockGeneration.LabeledBlockGenerator\nRationale: The `addToMaps` method involves operations that pertain to the creation and management of `LabeledBlock` instances, particularly in associating these blocks with `HIRBlock` start and end points using maps. The current method doesn't naturally belong to the `LabeledBlock` class, which is focused on representing individual labeled blocks rather than managing collections of them. By moving `addToMaps` to the `LabeledBlockGenerator` class, the logic for creating and organizing labeled blocks would be centralized, facilitating better cohesion and encapsulation.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 329,
                        "lineEnd": 372,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method isNormalLoopExit to class BasicBlockOrderUtils",
                        "description": "move method isNormalLoopExit to PsiClass:BasicBlockOrderUtils\nRationale: The method `isNormalLoopExit` is highly related to control flow and basic block manipulation, which falls under the domain of `BasicBlockOrderUtils`. This class already deals with methods that analyze basic block structures and their relationships (such as checking block order, marking successors, and priorities within loops). Moving the method here aligns with the class's responsibility, promoting cohesion and keeping related functionality together.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 257,
                        "lineEnd": 285,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method isLastBlockInSwitchArm to class BasicBlockOrderUtils",
                        "description": "move method isLastBlockInSwitchArm to PsiClass:BasicBlockOrderUtils\nRationale: The method `isLastBlockInSwitchArm` checks for block positioning within a switch arm, which directly relates to block ordering and positioning concepts. `BasicBlockOrderUtils` already manages utilities for checking block order and their relative properties, making it the ideal class for housing this method. Moving this method to `BasicBlockOrderUtils` would centralize block order-related functionalities, enhancing code maintenance and coherence.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 424,
                        "lineEnd": 504,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getLabeledBlockStart to class LabeledBlockGenerator",
                        "description": "Move method getLabeledBlockStart to jdk.graal.compiler.hightiercodegen.reconstruction.stackifier.blocks.LabeledBlockGeneration.LabeledBlockGenerator\nRationale: The getLabeledBlockStart() method is responsible for determining the start position of a LabeledBlock in relation to predecessor and successor HIRBlocks. This is a logical extension of the responsibilities of LabeledBlockGenerator, which is concerned with the lifecycle of LabeledBlocks, including their creation and management. Moving this method to LabeledBlockGenerator centralizes all logic related to LabeledBlock placement and generation, making the codebase more modular, cohesive and easier to maintain.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 228,
                        "lineEnd": 255,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method isLastBlockInThenBranch to class BasicBlockOrderUtils",
                        "description": "move method isLastBlockInThenBranch to PsiClass:BasicBlockOrderUtils\nRationale: The `isLastBlockInThenBranch` method heavily interacts with concepts like `HIRBlock`, `Scope`, `IfScopeContainer`, and `IfNode`. These concepts align closely with the utility methods found in `BasicBlockOrderUtils`, which deals with processing and validating orderings and relationships of basic blocks within control flow graphs. Therefore, `BasicBlockOrderUtils` is the most appropriate target class for this method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 287,
                        "lineEnd": 327,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method isJumpingOverCatchBlock to class BasicBlockOrderUtils",
                        "description": "move method isJumpingOverCatchBlock to PsiClass:BasicBlockOrderUtils\nRationale: The method isJumpingOverCatchBlock() is directly related to the control flow within a basic block, particularly in the context of exception handling and block transitions. BasicBlockOrderUtils is designed to handle various utility functions related to the ordering and organization of basic blocks, making it a suitable class to host this method. The method relies on analyzing block transitions and their specific properties, which aligns well with the responsibilities of BasicBlockOrderUtils.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 188,
                        "lineEnd": 226,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method isJumpingToAfterElseBranch to class BasicBlockOrderUtils",
                        "description": "move method isJumpingToAfterElseBranch to PsiClass:BasicBlockOrderUtils\nRationale: The `isJumpingToAfterElseBranch` method analyzes control flow by checking if a specific block jumps to a block after the else scope, which is highly related to the ordering and control flow logic managed by the `BasicBlockOrderUtils` class. The `BasicBlockOrderUtils` class already contains methods for checking block order, managing priority queues, and finding successors based on loop depth and probability. Hence, this class is the most appropriate target.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "isJumpingToAfterElseBranch",
                            "method_signature": "private static boolean isJumpingToAfterElseBranch(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "StackifierData",
                            "rationale": "The method `isJumpingToAfterElseBranch` deals with logic closely related to the handling of `StackifierData`, and its presence in `LabeledBlockGeneration` adds unnecessary coupling. Moving it to `StackifierData` would simplify the `LabeledBlockGeneration` class and make the functionality more cohesive."
                        },
                        {
                            "method_name": "isLastBlockInThenBranch",
                            "method_signature": "private static boolean isLastBlockInThenBranch(HIRBlock block, StackifierData stackifierData)",
                            "target_class": "StackifierData",
                            "rationale": "This method primarily deals with checking scope properties within the `StackifierData`. Moving it to `StackifierData` aligns it with the data it operates on and reduces the responsibility of `LabeledBlockGeneration`."
                        },
                        {
                            "method_name": "isLastBlockInSwitchArm",
                            "method_signature": "private static boolean isLastBlockInSwitchArm(HIRBlock block, StackifierData stackifierData)",
                            "target_class": "StackifierData",
                            "rationale": "Similar to `isLastBlockInThenBranch`, this method operates on scope data within `StackifierData` and should be moved there to keep related functionality together."
                        },
                        {
                            "method_name": "isJumpingOverCatchBlock",
                            "method_signature": "private static boolean isJumpingOverCatchBlock(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "StackifierData",
                            "rationale": "The method `isJumpingOverCatchBlock` operates mostly on `StackifierData`, making it a good candidate to move into `StackifierData`. This will keep `LabeledBlockGeneration` focused on its primary concern."
                        },
                        {
                            "method_name": "isNormalLoopExit",
                            "method_signature": "public static boolean isNormalLoopExit(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "StackifierData",
                            "rationale": "Since this method checks the normal loop exit condition using data from the `StackifierData` class, moving it to `StackifierData` would make the logic more centralized, and reduce the coupling in `LabeledBlockGeneration`."
                        },
                        {
                            "method_name": "commonDominatorFor",
                            "method_signature": "private static HIRBlock commonDominatorFor(HIRBlock b, boolean pred)",
                            "target_class": "AbstractControlFlowGraph",
                            "rationale": "The method `commonDominatorFor` is related to control flow graph analysis and operates on `HIRBlock` and its successors or predecessors. Its functionality is more aligned with the responsibilities of the `AbstractControlFlowGraph`."
                        }
                    ],
                    "llm_response_time": 8737
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "isJumpingToAfterElseBranch",
                            "method_signature": "private static boolean isJumpingToAfterElseBranch(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "StackifierData",
                            "rationale": "The method `isJumpingToAfterElseBranch` checks specific conditions related to the control flow and scope data managed within the `StackifierData` class. It would be better suited there to keep all related logic centralized."
                        },
                        {
                            "method_name": "isLastBlockInThenBranch",
                            "method_signature": "private static boolean isLastBlockInThenBranch(HIRBlock block, StackifierData stackifierData)",
                            "target_class": "StackifierData",
                            "rationale": "This method determines if a block is the last block in a then-branch, a determination closely tied to the data maintained in `StackifierData`. Moving it there would keep the logic closer to the data it operates on."
                        },
                        {
                            "method_name": "isLastBlockInSwitchArm",
                            "method_signature": "private static boolean isLastBlockInSwitchArm(HIRBlock block, StackifierData stackifierData)",
                            "target_class": "StackifierData",
                            "rationale": "The method deals specifically with examining the positions and scopes of blocks within a switch arm, operations heavily reliant on `StackifierData`. Thus, it fits better in that class."
                        },
                        {
                            "method_name": "isJumpingOverCatchBlock",
                            "method_signature": "private static boolean isJumpingOverCatchBlock(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "StackifierData",
                            "rationale": "This method involves checking catch block conditions, which are closely related to the control flow data encompassed within `StackifierData`. As such, relocating it there centralizes related logic."
                        },
                        {
                            "method_name": "isNormalLoopExit",
                            "method_signature": "public static boolean isNormalLoopExit(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "StackifierData",
                            "rationale": "The method evaluates loop exits, an operation integrally linked to the control flow details managed by `StackifierData`. Placing it there keeps the responsibility with the data it depends on."
                        }
                    ],
                    "llm_response_time": 6330
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "isJumpingToAfterElseBranch",
                            "method_signature": "private static boolean isJumpingToAfterElseBranch(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "StackifierScopeChecker",
                            "rationale": "The method is primarily concerned with verifying specific conditions in scope processing, which is more related to the responsibilities of a class that manages or evaluates stackifier scope data."
                        },
                        {
                            "method_name": "isLastBlockInThenBranch",
                            "method_signature": "private static boolean isLastBlockInThenBranch(HIRBlock block, StackifierData stackifierData)",
                            "target_class": "StackifierScopeChecker",
                            "rationale": "This method specifically checks if a block is the last in the then-branch, which is a detailed scope-related check. It's better suited in a class handling stackifier scope checks."
                        },
                        {
                            "method_name": "isLastBlockInSwitchArm",
                            "method_signature": "private static boolean isLastBlockInSwitchArm(HIRBlock block, StackifierData stackifierData)",
                            "target_class": "StackifierScopeChecker",
                            "rationale": "This method evaluates whether a block is the last in a switch arm, which again is focused on assessing scopes. It fits naturally in a class specialized in checking stackifier-related scope conditions."
                        },
                        {
                            "method_name": "isJumpingOverCatchBlock",
                            "method_signature": "private static boolean isJumpingOverCatchBlock(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "StackifierScopeChecker",
                            "rationale": "The method checks if a jump over a catch block occurs, which is a highly specific scope-related check. Moving it to a scope checking class ensures better cohesion and separation of concerns."
                        },
                        {
                            "method_name": "isNormalLoopExit",
                            "method_signature": "public static boolean isNormalLoopExit(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "StackifierScopeChecker",
                            "rationale": "This method determines if a jump is a normal loop exit, which involves checking loop scopes. It's more appropriate to have it in a class that handles various scope evaluations."
                        },
                        {
                            "method_name": "commonDominatorFor",
                            "method_signature": "private static HIRBlock commonDominatorFor(HIRBlock b, boolean pred)",
                            "target_class": "ControlFlowAnalysis",
                            "rationale": "Finding the common dominator is a control flow analysis task, making it more suitable for a class dealing specifically with control flow graph (CFG) analysis."
                        }
                    ],
                    "llm_response_time": 6534
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "isLabeledBlockNeeded",
                            "method_signature": "public isLabeledBlockNeeded(HIRBlock block, HIRBlock successor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isJumpingToAfterElseBranch",
                            "method_signature": "private static isJumpingToAfterElseBranch(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isLastBlockInThenBranch",
                            "method_signature": "private static isLastBlockInThenBranch(HIRBlock block, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isLastBlockInSwitchArm",
                            "method_signature": "private static isLastBlockInSwitchArm(HIRBlock block, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isJumpingOverCatchBlock",
                            "method_signature": "private static isJumpingOverCatchBlock(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isNormalLoopExit",
                            "method_signature": "public static isNormalLoopExit(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "areNextInOrder",
                            "method_signature": "private areNextInOrder(HIRBlock successor, HIRBlock lastLoopBlock)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "commonDominatorFor",
                            "method_signature": "private static commonDominatorFor(HIRBlock b, boolean pred)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "generateLabeledBlocks",
                            "method_signature": "public generateLabeledBlocks()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getLabeledBlockStart",
                            "method_signature": "private getLabeledBlockStart(HIRBlock predecessor, HIRBlock successor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addToMaps",
                            "method_signature": "private addToMaps(LabeledBlock labeledBLock)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "areNextInOrder",
                            "method_signature": "private areNextInOrder(HIRBlock successor, HIRBlock lastLoopBlock)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "commonDominatorFor",
                            "method_signature": "private static commonDominatorFor(HIRBlock b, boolean pred)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "generateLabeledBlocks",
                            "method_signature": "public generateLabeledBlocks()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "addToMaps",
                            "method_signature": "private addToMaps(LabeledBlock labeledBLock)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isLabeledBlockNeeded",
                            "method_signature": "public isLabeledBlockNeeded(HIRBlock block, HIRBlock successor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isNormalLoopExit",
                            "method_signature": "public static isNormalLoopExit(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isLastBlockInSwitchArm",
                            "method_signature": "private static isLastBlockInSwitchArm(HIRBlock block, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getLabeledBlockStart",
                            "method_signature": "private getLabeledBlockStart(HIRBlock predecessor, HIRBlock successor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isLastBlockInThenBranch",
                            "method_signature": "private static isLastBlockInThenBranch(HIRBlock block, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isJumpingOverCatchBlock",
                            "method_signature": "private static isJumpingOverCatchBlock(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isJumpingToAfterElseBranch",
                            "method_signature": "private static isJumpingToAfterElseBranch(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "private areNextInOrder(HIRBlock successor, HIRBlock lastLoopBlock)": {
                        "first": {
                            "method_name": "areNextInOrder",
                            "method_signature": "private areNextInOrder(HIRBlock successor, HIRBlock lastLoopBlock)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.21126499207147809
                    },
                    "private static commonDominatorFor(HIRBlock b, boolean pred)": {
                        "first": {
                            "method_name": "commonDominatorFor",
                            "method_signature": "private static commonDominatorFor(HIRBlock b, boolean pred)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.2603454259132793
                    },
                    "public generateLabeledBlocks()": {
                        "first": {
                            "method_name": "generateLabeledBlocks",
                            "method_signature": "public generateLabeledBlocks()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6354282185227553
                    },
                    "private addToMaps(LabeledBlock labeledBLock)": {
                        "first": {
                            "method_name": "addToMaps",
                            "method_signature": "private addToMaps(LabeledBlock labeledBLock)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7534139658221813
                    },
                    "public isLabeledBlockNeeded(HIRBlock block, HIRBlock successor)": {
                        "first": {
                            "method_name": "isLabeledBlockNeeded",
                            "method_signature": "public isLabeledBlockNeeded(HIRBlock block, HIRBlock successor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.8738310264662694
                    },
                    "public static isNormalLoopExit(HIRBlock block, HIRBlock successor, StackifierData stackifierData)": {
                        "first": {
                            "method_name": "isNormalLoopExit",
                            "method_signature": "public static isNormalLoopExit(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.8768719092167937
                    },
                    "private static isLastBlockInSwitchArm(HIRBlock block, StackifierData stackifierData)": {
                        "first": {
                            "method_name": "isLastBlockInSwitchArm",
                            "method_signature": "private static isLastBlockInSwitchArm(HIRBlock block, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.8829018060373677
                    },
                    "private getLabeledBlockStart(HIRBlock predecessor, HIRBlock successor)": {
                        "first": {
                            "method_name": "getLabeledBlockStart",
                            "method_signature": "private getLabeledBlockStart(HIRBlock predecessor, HIRBlock successor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.8848849790845067
                    },
                    "private static isLastBlockInThenBranch(HIRBlock block, StackifierData stackifierData)": {
                        "first": {
                            "method_name": "isLastBlockInThenBranch",
                            "method_signature": "private static isLastBlockInThenBranch(HIRBlock block, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.8850372588875643
                    },
                    "private static isJumpingOverCatchBlock(HIRBlock block, HIRBlock successor, StackifierData stackifierData)": {
                        "first": {
                            "method_name": "isJumpingOverCatchBlock",
                            "method_signature": "private static isJumpingOverCatchBlock(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.8996327624170304
                    },
                    "private static isJumpingToAfterElseBranch(HIRBlock block, HIRBlock successor, StackifierData stackifierData)": {
                        "first": {
                            "method_name": "isJumpingToAfterElseBranch",
                            "method_signature": "private static isJumpingToAfterElseBranch(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.9033729976522634
                    }
                },
                "voyage": {
                    "private static commonDominatorFor(HIRBlock b, boolean pred)": {
                        "first": {
                            "method_name": "commonDominatorFor",
                            "method_signature": "private static commonDominatorFor(HIRBlock b, boolean pred)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.507340045612411
                    },
                    "private areNextInOrder(HIRBlock successor, HIRBlock lastLoopBlock)": {
                        "first": {
                            "method_name": "areNextInOrder",
                            "method_signature": "private areNextInOrder(HIRBlock successor, HIRBlock lastLoopBlock)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5711615460938595
                    },
                    "private static isLastBlockInThenBranch(HIRBlock block, StackifierData stackifierData)": {
                        "first": {
                            "method_name": "isLastBlockInThenBranch",
                            "method_signature": "private static isLastBlockInThenBranch(HIRBlock block, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6144932964906334
                    },
                    "private static isLastBlockInSwitchArm(HIRBlock block, StackifierData stackifierData)": {
                        "first": {
                            "method_name": "isLastBlockInSwitchArm",
                            "method_signature": "private static isLastBlockInSwitchArm(HIRBlock block, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6226613581814296
                    },
                    "private addToMaps(LabeledBlock labeledBLock)": {
                        "first": {
                            "method_name": "addToMaps",
                            "method_signature": "private addToMaps(LabeledBlock labeledBLock)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6589382238886875
                    },
                    "private static isJumpingToAfterElseBranch(HIRBlock block, HIRBlock successor, StackifierData stackifierData)": {
                        "first": {
                            "method_name": "isJumpingToAfterElseBranch",
                            "method_signature": "private static isJumpingToAfterElseBranch(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6752560485866693
                    },
                    "private static isJumpingOverCatchBlock(HIRBlock block, HIRBlock successor, StackifierData stackifierData)": {
                        "first": {
                            "method_name": "isJumpingOverCatchBlock",
                            "method_signature": "private static isJumpingOverCatchBlock(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6849905461747077
                    },
                    "public static isNormalLoopExit(HIRBlock block, HIRBlock successor, StackifierData stackifierData)": {
                        "first": {
                            "method_name": "isNormalLoopExit",
                            "method_signature": "public static isNormalLoopExit(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6943832427445997
                    },
                    "public isLabeledBlockNeeded(HIRBlock block, HIRBlock successor)": {
                        "first": {
                            "method_name": "isLabeledBlockNeeded",
                            "method_signature": "public isLabeledBlockNeeded(HIRBlock block, HIRBlock successor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7708678648646692
                    },
                    "private getLabeledBlockStart(HIRBlock predecessor, HIRBlock successor)": {
                        "first": {
                            "method_name": "getLabeledBlockStart",
                            "method_signature": "private getLabeledBlockStart(HIRBlock predecessor, HIRBlock successor)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7755129516054436
                    },
                    "public generateLabeledBlocks()": {
                        "first": {
                            "method_name": "generateLabeledBlocks",
                            "method_signature": "public generateLabeledBlocks()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.8057215799053589
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public isLabeledBlockNeeded(HIRBlock block, HIRBlock successor)",
                        "public generateLabeledBlocks()",
                        "private getLabeledBlockStart(HIRBlock predecessor, HIRBlock successor)",
                        "private addToMaps(LabeledBlock labeledBLock)",
                        "public static isNormalLoopExit(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                        "private static commonDominatorFor(HIRBlock b, boolean pred)",
                        "private static isJumpingToAfterElseBranch(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                        "private static isJumpingOverCatchBlock(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                        "private static isLastBlockInThenBranch(HIRBlock block, StackifierData stackifierData)",
                        "private static isLastBlockInSwitchArm(HIRBlock block, StackifierData stackifierData)",
                        "private areNextInOrder(HIRBlock successor, HIRBlock lastLoopBlock)"
                    ],
                    "llm_response_time": 5683
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public isLabeledBlockNeeded(HIRBlock block, HIRBlock successor)",
                        "public generateLabeledBlocks()",
                        "private static commonDominatorFor(HIRBlock b, boolean pred)",
                        "private addToMaps(LabeledBlock labeledBLock)",
                        "private areNextInOrder(HIRBlock successor, HIRBlock lastLoopBlock)"
                    ],
                    "llm_response_time": 4914
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public generateLabeledBlocks()",
                        "private static commonDominatorFor(HIRBlock b, boolean pred)",
                        "private areNextInOrder(HIRBlock successor, HIRBlock lastLoopBlock)"
                    ],
                    "llm_response_time": 3704
                },
                "voyage": {
                    "priority_method_names": [
                        "public generateLabeledBlocks()",
                        "public isLabeledBlockNeeded(HIRBlock block, HIRBlock successor)",
                        "private getLabeledBlockStart(HIRBlock predecessor, HIRBlock successor)",
                        "private addToMaps(LabeledBlock labeledBLock)",
                        "private static isJumpingToAfterElseBranch(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                        "private static isJumpingOverCatchBlock(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                        "public static isNormalLoopExit(HIRBlock block, HIRBlock successor, StackifierData stackifierData)",
                        "private static isLastBlockInThenBranch(HIRBlock block, StackifierData stackifierData)",
                        "private static isLastBlockInSwitchArm(HIRBlock block, StackifierData stackifierData)",
                        "private static commonDominatorFor(HIRBlock b, boolean pred)",
                        "private areNextInOrder(HIRBlock successor, HIRBlock lastLoopBlock)"
                    ],
                    "llm_response_time": 2908
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private addToMaps(LabeledBlock labeledBLock)",
                        "private static commonDominatorFor(HIRBlock b, boolean pred)",
                        "private static isLastBlockInThenBranch(HIRBlock block, StackifierData stackifierData)",
                        "private static isLastBlockInSwitchArm(HIRBlock block, StackifierData stackifierData)",
                        "private areNextInOrder(HIRBlock successor, HIRBlock lastLoopBlock)"
                    ],
                    "llm_response_time": 4407
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private static isLastBlockInThenBranch(HIRBlock block, StackifierData stackifierData)",
                        "private static commonDominatorFor(HIRBlock b, boolean pred)",
                        "private areNextInOrder(HIRBlock successor, HIRBlock lastLoopBlock)"
                    ],
                    "llm_response_time": 4094
                }
            },
            "targetClassMap": {
                "areNextInOrder": {
                    "target_classes": [
                        {
                            "class_name": "HIRBlock",
                            "similarity_score": 0.4120039058195536
                        },
                        {
                            "class_name": "HIRBlock",
                            "similarity_score": 0.4120039058195536
                        },
                        {
                            "class_name": "LabeledBlockGenerator",
                            "similarity_score": 0.3423683940087303
                        },
                        {
                            "class_name": "ControlFlowGraph",
                            "similarity_score": 0.35224659215848847
                        },
                        {
                            "class_name": "StackifierData",
                            "similarity_score": 0.3437007242572504
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HIRBlock",
                        "HIRBlock",
                        "ControlFlowGraph"
                    ],
                    "llm_response_time": 5378,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "commonDominatorFor": {
                    "target_classes": [
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.4775726245800626
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.44791945548006257
                        },
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.4807255040977894
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.2725345442326085
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.44583655818326784
                        },
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.4174795643315468
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.4728287946346656
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.36300602595544545
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.14662795566061101
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.3580780238039719
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.1663197113724176
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.19295655970719433
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.450529614501012
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.36244139299128686
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.3230855684283847
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.3731535082885995
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.3395625397961618
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.376523997127132
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.32231112042686694
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.2824986488248238
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.3883280926029752
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.39883770581262296
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.38845422899897164
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.2965091471254894
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.24527956744902846
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.24386857429958608
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.27026533810839254
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.27252155541123385
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.405830675690798
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.3437250839704362
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.3547834286585087
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.2005056146071265
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.2232726002722706
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.17694958208152356
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.3418990745365506
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.3316709759504015
                        },
                        {
                            "class_name": "GlobUtils",
                            "similarity_score": 0.36037816316096843
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.36808298198751793
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.3698126316140541
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.3480297826800171
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.40905020358743766
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.38732604494141404
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.4013676707139605
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.4446443441415689
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.3825155522031499
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.36538913840111664
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.5219681082042589
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.5125406792853264
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.384935095791247
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.37873445548248363
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.3930444964992947
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.36732968159993273
                        },
                        {
                            "class_name": "ArrayUtil",
                            "similarity_score": 0.18580300697695717
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.3910548673648537
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.3965620036068631
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.4317002251815378
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.39688253140933016
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.4101779581585916
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.47235286327888626
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.44665340789420205
                        },
                        {
                            "class_name": "MissingJNIRegistrationUtils",
                            "similarity_score": 0.19961208870703284
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.307118445351366
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.4101338598604125
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.32956597836525253
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.4672809012981348
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.3389694316527754
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.4260874657537614
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.283167222458102
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.3009122016061097
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.3593206887542729
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.3516107748438625
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.5171765249206048
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.2294465424027453
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.23408229439226114
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.31244660579301475
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.3937316599989986
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.4960155752389403
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.43418113589361124
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.4539132829323974
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.28730130129002907
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.24918544938338874
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.43859740195392477
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.3978814405498701
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.2641241040955598
                        },
                        {
                            "class_name": "Target_java_util_concurrent_locks_AbstractOwnableSynchronizer",
                            "similarity_score": 0.38115729660543185
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.32334644037646054
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.34175846212075917
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.10678168370696801
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.3919559884265041
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.3663967458131496
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.16816030000289778
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.3991920337917404
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.21515557750587072
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.2909117952678402
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.2971304601215057
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.4474835915085304
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.30002721458707465
                        },
                        {
                            "class_name": "UnsafeMemoryUtil",
                            "similarity_score": 0.19713285391010119
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.26207620915585295
                        },
                        {
                            "class_name": "StackElement",
                            "similarity_score": 0.32594055994239807
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BundleSerializationUtils",
                        "StringUtil",
                        "String"
                    ],
                    "llm_response_time": 3210,
                    "similarity_computation_time": 50,
                    "similarity_metric": "cosine"
                },
                "generateLabeledBlocks": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3458,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "addToMaps": {
                    "target_classes": [
                        {
                            "class_name": "LabeledBlock",
                            "similarity_score": 0.552532101512818
                        },
                        {
                            "class_name": "LabeledBlockGenerator",
                            "similarity_score": 0.30175284349079223
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "LabeledBlockGenerator",
                        "LabeledBlock"
                    ],
                    "llm_response_time": 2839,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "isLabeledBlockNeeded": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1843,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "isNormalLoopExit": {
                    "target_classes": [
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.6304405280296589
                        },
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.6935886069139673
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.4119284901975629
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.7404365908523849
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.5603015299114679
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.21134445588139783
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.4696863835794954
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.13789850646982213
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.5857563838484497
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.3107074873867956
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.5434681924772573
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.4344456917644328
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.7392766914075576
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.45329235649577504
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.6114961820018393
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.30060957477982425
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.23431864694118498
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.3399549398955638
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.19865851115803304
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.561298856498214
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.7999237255016968
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.1649716760136472
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.5293926093132756
                        },
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.5242326733024781
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.2772599980835634
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.6316439260156592
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.38802178087902695
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.711288728516832
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.2239249506078817
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.47822760748962123
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.4684847644409394
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.6615459323395206
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.33090747283931604
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.5831099556159436
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.18040631815012179
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.3385701273184142
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.19287986644873262
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.5065592251947548
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.16355579575417228
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.6980487159346244
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.32783850171332435
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.17944496240573565
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.3019829437687445
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.37793709965198186
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.16435947050092609
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.21020081992054512
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.3754200381499736
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.17800547291122307
                        },
                        {
                            "class_name": "ArrayUtil",
                            "similarity_score": 0.2394447731609963
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.21633523469058497
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.15209199088363187
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.5302720059829383
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.1557733455877757
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.5106614785033697
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.16370130243622838
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.1458648296092317
                        },
                        {
                            "class_name": "MissingJNIRegistrationUtils",
                            "similarity_score": 0.11486381372648036
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.4059560923385133
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.3803679309772039
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.31341732249534454
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.3311263725026163
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.2582174632520339
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.22236072910154547
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.13289077740885644
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.3455600897644262
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.2178856342638673
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.13175014662303383
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.7116615522460373
                        },
                        {
                            "class_name": "GlobUtils",
                            "similarity_score": 0.2887000659299559
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.19119225087580005
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.5266198681912752
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.21784127331944492
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.19097885354754401
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.15942688583318676
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.5514295392307503
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.5405269595774006
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.1915626733152971
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.19549852230713557
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.44946740219610604
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.6687967202779913
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.6922608003747415
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.21146118872674988
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.19967273202499436
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.22089110978989995
                        },
                        {
                            "class_name": "Target_java_util_concurrent_locks_AbstractOwnableSynchronizer",
                            "similarity_score": 0.19364213901789906
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.6599744661224587
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.42390784625243555
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.12755924644859304
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.27355133624371375
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.13757137667643604
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.6441824575484759
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.3996813790971282
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.24469658392571852
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.13714244250269028
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.5356280337465184
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.32841021982561824
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.12570239510172143
                        },
                        {
                            "class_name": "StackElement",
                            "similarity_score": 0.1405757590600431
                        },
                        {
                            "class_name": "UnsafeMemoryUtil",
                            "similarity_score": 0.175995427505229
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.556680313268942
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BasicBlockOrderUtils",
                        "PathUtilities",
                        "StubUtil"
                    ],
                    "llm_response_time": 4220,
                    "similarity_computation_time": 51,
                    "similarity_metric": "cosine"
                },
                "isLastBlockInSwitchArm": {
                    "target_classes": [
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.5151607895248884
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.5984883629069581
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.4809096878773114
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.5455446649974608
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.41338268424347024
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.7219214878327394
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.4814633002154127
                        },
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.7253479458419183
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.32757728410371056
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.6123260684332388
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.2046590413076619
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.8376300557757417
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.633210652595517
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.284049908411309
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.6919226603041073
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.5090483906016058
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.5944867770234056
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.30735297155630414
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.3078211006833872
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.2892709559399512
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.5314659815623202
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.23669816946848662
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.5755883697052779
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.34499846330466494
                        },
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.5959145671327128
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.6545381369714599
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.4036424863567852
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.7115130552921143
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.30874720289598373
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.5271306243429765
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.5017339153237292
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.6878414231869947
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.40097710460102004
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.5765999761251578
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.2175970699446223
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.4185274013628038
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.24856374482783958
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.2404544139913325
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.4015134362456215
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.2580973391717414
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.2620941504370971
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.2154214494494
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.5697306210843591
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.30340956826370835
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.3302308841526227
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.4043616011004994
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.16885773938440568
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.2752903686124221
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.2284676594241938
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.7036391897308224
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.442547346136602
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.5838168824534489
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.5770343471474769
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.3894942223314538
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.18090680674665816
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.20899864686219677
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.23437398425881048
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.3421619392585948
                        },
                        {
                            "class_name": "ArrayUtil",
                            "similarity_score": 0.26639771383306554
                        },
                        {
                            "class_name": "MissingJNIRegistrationUtils",
                            "similarity_score": 0.12695127935431788
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.41969843210423907
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.4327745897519816
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.3240903716417377
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.39615733591117336
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.3192996105651869
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.5257356881085351
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.2759243150113646
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.29937865942749653
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.1946216926274369
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.2762411192424451
                        },
                        {
                            "class_name": "GlobUtils",
                            "similarity_score": 0.37478046636814943
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.6084016086076415
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.23030728136615086
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.18115789195666254
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.735699555772015
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.5642565525684063
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.28684232046403846
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.2723496134137251
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.4953912276311175
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.6541134147202199
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.651768578380072
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.299904362053633
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.29403190279760244
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.24841862877188986
                        },
                        {
                            "class_name": "Target_java_util_concurrent_locks_AbstractOwnableSynchronizer",
                            "similarity_score": 0.2511441707374727
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.6769145563690669
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.46368438696446673
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.17993535904889696
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.3041191275793586
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.4256656229607142
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.20365154069287472
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.6052949928557546
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.3485719541932064
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.49558112287560885
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.2096473710830169
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.3993976358082589
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.19591900487702774
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.5758500578787845
                        },
                        {
                            "class_name": "StackElement",
                            "similarity_score": 0.20160142227246908
                        },
                        {
                            "class_name": "ExitException",
                            "similarity_score": 0.17427535920618922
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BasicBlockOrderUtils",
                        "SSAUtil",
                        "DeoptimizationUtils"
                    ],
                    "llm_response_time": 3965,
                    "similarity_computation_time": 27,
                    "similarity_metric": "cosine"
                },
                "getLabeledBlockStart": {
                    "target_classes": [
                        {
                            "class_name": "LabeledBlockGenerator",
                            "similarity_score": 0.2797402446666433
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "LabeledBlockGenerator"
                    ],
                    "llm_response_time": 2950,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "isLastBlockInThenBranch": {
                    "target_classes": [
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.261792063562258
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.2929221967829785
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.5664740541589733
                        },
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.6739246550337533
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.63661640879838
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.5636650062703991
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.8366678587670116
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.6072831981065111
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.3929792686697318
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.5879532709674377
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.5235272673312411
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.37887878082465376
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.3668212296297303
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.3597864401829013
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.6687120410487277
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.4799412814823249
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.358022370980683
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.5550635517767573
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.7338229195153191
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.6534081065818051
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.38059445058485974
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.5482514417805229
                        },
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.7352517607534862
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.6784619418863541
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.6164146058190761
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.6628473930655016
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.44759357719715004
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.7107705304339356
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.40371861924460506
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.5740397675195448
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.5590401290635773
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.7007815737009384
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.42139106789816666
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.5797983209213368
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.2778286432678969
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.4078092288178248
                        },
                        {
                            "class_name": "GlobUtils",
                            "similarity_score": 0.4534371551081319
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.3331297172022455
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.4824998794045557
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.2943799790103119
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.3273618810957635
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.34585680455281415
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.3791591333867183
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.45867069161762364
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.23284515771189987
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.39915719018503437
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.2813757601726271
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.7675364507929684
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.5027810963156005
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.6579521692526354
                        },
                        {
                            "class_name": "ArrayUtil",
                            "similarity_score": 0.29300697906102635
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.27151133129919297
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.22580511908995538
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.37759483392153054
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.4900310669727214
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.5980806472051011
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.647967836395207
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.23752556415563966
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.29764059369715384
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.21873897558087457
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.2868299540918083
                        },
                        {
                            "class_name": "MissingJNIRegistrationUtils",
                            "similarity_score": 0.15568803251783836
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.45349608639465855
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.4987242494196208
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.3633285595977323
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.4534924256713167
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.3529546997363154
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.24706611403461343
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.7391622616466088
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.345399772788837
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.48182895628814015
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.6240739867709129
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.35796595672475395
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.5725319659901893
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.3769737233469434
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.6042573324070272
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.3672685278316211
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.3314207686249928
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.5419970303747135
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.6609902966383876
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.6469288337684895
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.3920415250484114
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.379044454906256
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.3021161823863956
                        },
                        {
                            "class_name": "Target_java_util_concurrent_locks_AbstractOwnableSynchronizer",
                            "similarity_score": 0.33852847054202867
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.7010288613191363
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.26343422397525684
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.4895464900505632
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.36746653185270667
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.2574747427380611
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.23046507657634294
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.5859391982645956
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.42741330160714675
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.5232814225338983
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.43829939135290163
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.46765787261443825
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.2496706519658327
                        },
                        {
                            "class_name": "ExitException",
                            "similarity_score": 0.2221735373224766
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.6106501594038561
                        },
                        {
                            "class_name": "CEntryPointUtilityNode",
                            "similarity_score": 0.3453230211477224
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BasicBlockOrderUtils",
                        "SubstrateUtil",
                        "DeoptimizationUtils"
                    ],
                    "llm_response_time": 4322,
                    "similarity_computation_time": 90,
                    "similarity_metric": "cosine"
                },
                "isJumpingOverCatchBlock": {
                    "target_classes": [
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.6290915429221688
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.8232225238291667
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.5249870475733461
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.5830342762871792
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.7508131672996732
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.5740403623436366
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.5309342823057334
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.612490446526146
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.23775353945833483
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.3554916605745148
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.6549198115474495
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.44127414944636567
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.2960803338636696
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.541735777905716
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.3234436664905999
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.2692330951598631
                        },
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.6331083748464396
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.36083255600968644
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.6277653027479692
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.7334561249518142
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.6430960939893279
                        },
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.7484128657683071
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.37159378221715267
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.58288467473614
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.3366803506838279
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.6986298459442842
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.42283756151593543
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.7175906970344912
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.33874483161824026
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.5455296327892323
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.5475851700503483
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.6766846278308637
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.3754818409372782
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.2741579866172355
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.5862596667223465
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.4597143998995351
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.22086305214969307
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.3564019854253709
                        },
                        {
                            "class_name": "ArrayUtil",
                            "similarity_score": 0.2727547640103149
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.30346313841752814
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.4635780836578669
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.4422277808997943
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.2981857635058894
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.29556773482336796
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.29637163763127733
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.3365782007310376
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.2663296893915068
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.24658528932174728
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.2641616987983768
                        },
                        {
                            "class_name": "MissingJNIRegistrationUtils",
                            "similarity_score": 0.17240522810743902
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.584595989998144
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.46630723218795306
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.4648472776968025
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.6173302786532534
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.37225857470859697
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.44582742175822876
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.2197970921805962
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.25030423029922727
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.4850055981815867
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.1955604828154819
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.2640594689769418
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.7545533384992735
                        },
                        {
                            "class_name": "GlobUtils",
                            "similarity_score": 0.39578671852034464
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.6164242697737279
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.36508346864873104
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.2998356080559538
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.574088653722093
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.3102882639949989
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.2382580746252774
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.3401804855855857
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.7381711703211961
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.3296992382110716
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.46535526222442014
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.5900572409541035
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.37809408539673034
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.6045298280214588
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.3426662577359823
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.3083205069712683
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.5395153856558322
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.6728926178051094
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.6679152457490695
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.32053241057811455
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.3410756915789783
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.3209577520852779
                        },
                        {
                            "class_name": "Target_java_util_concurrent_locks_AbstractOwnableSynchronizer",
                            "similarity_score": 0.3010387030572983
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.7009295622538669
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.3205207755979528
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.20896109086342507
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.23686353886438583
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.23793074579509155
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.5135447624078311
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.6212778634083606
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.37423274598173933
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.4447856950825218
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.5217147321298736
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.44359241189484483
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.2159823153022958
                        },
                        {
                            "class_name": "CEntryPointUtilityNode",
                            "similarity_score": 0.32167138212507357
                        },
                        {
                            "class_name": "AtomicBoolean",
                            "similarity_score": 0.2931906165895441
                        },
                        {
                            "class_name": "AtomicInteger",
                            "similarity_score": 0.27063790948198757
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BasicBlockOrderUtils",
                        "DeoptimizationUtils",
                        "PathUtilities"
                    ],
                    "llm_response_time": 4553,
                    "similarity_computation_time": 116,
                    "similarity_metric": "cosine"
                },
                "isJumpingToAfterElseBranch": {
                    "target_classes": [
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.6210572852006796
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.351948953387409
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.23366729236801995
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.6198970923587591
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.26530768417033423
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.31902546527062137
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.6249808706368783
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.5421665079146377
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.8054493670400453
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.5470489926967338
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.5530830136085897
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.508647666830037
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.6141671392123416
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.5654005705798713
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.33696351251185025
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.7496599901702984
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.6471803925664542
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.2893567429291888
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.42917207428697884
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.3314401204766496
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.563242936982073
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.37280133712968866
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.7349749295430524
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.6368087687027947
                        },
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.7232399575536635
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.6995364685015102
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.41526574346445816
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.7097344965861417
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.3207279426255138
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.5276319923154004
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.5468666422878713
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.6737431674571093
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.3609134441516681
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.594589693387968
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.3510717128909043
                        },
                        {
                            "class_name": "GlobUtils",
                            "similarity_score": 0.41009130974883945
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.28832519241530113
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.24193227768122288
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.6148813177243371
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.2900438909061878
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.47482897442887534
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.2543041586056723
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.2712368746990152
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.7464968678503909
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.26177307818034834
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.4601018712290395
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.22800682146314652
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.3043833198964101
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.3589558373072495
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.2524077938655568
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.1835325870964494
                        },
                        {
                            "class_name": "ArrayUtil",
                            "similarity_score": 0.2705469681330302
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.46755075214077474
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.43610950007556326
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.5837897391374353
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.33227605308494956
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.3084813242574904
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.31962855648636473
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.2759541492739585
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.2582119342550097
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.25089128588975024
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.5813708036627112
                        },
                        {
                            "class_name": "MissingJNIRegistrationUtils",
                            "similarity_score": 0.16866579584343763
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.45696414202298946
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.4570678137636859
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.6207289590280207
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.36122806505161476
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.4397076403622362
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.21343269889757052
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.2515061900672475
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.7328863388488331
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.3254760460843451
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.38718246137529044
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.4769453806877852
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.5812578520052785
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.6118992354315829
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.3331261468804628
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.2958415338224313
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.5498582567076465
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.6807993873156913
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.6712385315927362
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.3167344537374846
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.33232388374993493
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.27163348555816863
                        },
                        {
                            "class_name": "Target_java_util_concurrent_locks_AbstractOwnableSynchronizer",
                            "similarity_score": 0.31391488592074923
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.703643608321902
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.23038566805576735
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.2296237264190583
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.620442379890098
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.36584964585612506
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.5124280208962644
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.3285412300992244
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.4389462412795382
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.20214311719570915
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.5087528527553238
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.4423287141745592
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.20803254808259367
                        },
                        {
                            "class_name": "ExitException",
                            "similarity_score": 0.18827043647441977
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.6046204521162303
                        },
                        {
                            "class_name": "InvalidMacroException",
                            "similarity_score": 0.17468428144447087
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BasicBlockOrderUtils",
                        "DeoptimizationUtils",
                        "PathUtilities"
                    ],
                    "llm_response_time": 4282,
                    "similarity_computation_time": 94,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "8aea207041533f50e294b14291597c89f77a0f22",
        "url": "https://github.com/oracle/graal/commit/8aea207041533f50e294b14291597c89f77a0f22",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public sortAndAssignOffsets() : int extracted from public beforeCompilation(config BeforeCompilationAccess) : void in class com.oracle.svm.hosted.thread.VMThreadFeature & moved to class com.oracle.svm.hosted.thread.VMThreadLocalCollector",
            "leftSideLocations": [
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 220,
                    "endLine": 249,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "public beforeCompilation(config BeforeCompilationAccess) : void"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 224,
                    "endLine": 224,
                    "startColumn": 9,
                    "endColumn": 28,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 226,
                    "endLine": 226,
                    "startColumn": 13,
                    "endColumn": 59,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 227,
                    "endLine": 227,
                    "startColumn": 13,
                    "endColumn": 65,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 230,
                    "endLine": 230,
                    "startColumn": 17,
                    "endColumn": 70,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 232,
                    "endLine": 232,
                    "startColumn": 13,
                    "endColumn": 38,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 233,
                    "endLine": 233,
                    "startColumn": 13,
                    "endColumn": 44,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 236,
                    "endLine": 236,
                    "startColumn": 17,
                    "endColumn": 130,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 223,
                    "endLine": 223,
                    "startColumn": 9,
                    "endColumn": 74,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 222,
                    "endLine": 222,
                    "startColumn": 9,
                    "endColumn": 98,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 229,
                    "endLine": 231,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 235,
                    "endLine": 237,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 225,
                    "endLine": 238,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "ENHANCED_FOR_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 229,
                    "endLine": 231,
                    "startColumn": 32,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 235,
                    "endLine": 237,
                    "startColumn": 47,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 225,
                    "endLine": 238,
                    "startColumn": 63,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 147,
                    "endLine": 168,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public sortAndAssignOffsets() : int"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 151,
                    "endLine": 151,
                    "startColumn": 9,
                    "endColumn": 28,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 153,
                    "endLine": 153,
                    "startColumn": 13,
                    "endColumn": 59,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 154,
                    "endLine": 154,
                    "startColumn": 13,
                    "endColumn": 65,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 157,
                    "endLine": 157,
                    "startColumn": 17,
                    "endColumn": 70,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 159,
                    "endLine": 159,
                    "startColumn": 13,
                    "endColumn": 38,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 160,
                    "endLine": 160,
                    "startColumn": 13,
                    "endColumn": 44,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 163,
                    "endLine": 163,
                    "startColumn": 17,
                    "endColumn": 130,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 150,
                    "endLine": 150,
                    "startColumn": 9,
                    "endColumn": 52,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 148,
                    "endLine": 148,
                    "startColumn": 9,
                    "endColumn": 28,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 156,
                    "endLine": 158,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 162,
                    "endLine": 164,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 152,
                    "endLine": 165,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "ENHANCED_FOR_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 156,
                    "endLine": 158,
                    "startColumn": 32,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 162,
                    "endLine": 164,
                    "startColumn": 47,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 152,
                    "endLine": 165,
                    "startColumn": 63,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 225,
                    "endLine": 250,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "public beforeCompilation(config BeforeCompilationAccess) : void"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                    "startLine": 228,
                    "endLine": 228,
                    "startColumn": 26,
                    "endColumn": 69,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "threadLocalCollector.sortAndAssignOffsets()"
                },
                {
                    "filePath": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadLocalCollector.java",
                    "startLine": 167,
                    "endLine": 167,
                    "startColumn": 9,
                    "endColumn": 27,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                }
            ],
            "isStatic": false
        },
        "ref_id": 528,
        "extraction_results": {
            "success": true,
            "newCommitHash": "a673079ff9cfdc0e82be4e17c1c8cfe5d6290b6e",
            "newBranchName": "extract-sortAndAssignOffsets-beforeCompilation-89a77ab"
        },
        "telemetry": {
            "id": "42d34ce1-ee34-4e0e-a686-844a7367f804",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 194,
                "lineStart": 66,
                "lineEnd": 259,
                "bodyLineStart": 66,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/thread/VMThreadFeature.java",
                "sourceCode": "/**\n * Collects all VM thread local variables during native image generation and assigns them their\n * offset in the {@link IsolateThread} data structure.\n */\n@AutomaticallyRegisteredFeature\n@Platforms(InternalPlatform.NATIVE_ONLY.class)\npublic class VMThreadFeature implements InternalFeature {\n\n    private final VMThreadLocalCollector threadLocalCollector = new VMThreadLocalCollector();\n    private final VMThreadLocalSupport threadLocalSupport = new VMThreadLocalSupport();\n\n    @Override\n    public void duringSetup(DuringSetupAccess config) {\n        ImageSingletons.add(VMThreadLocalSupport.class, threadLocalSupport);\n        /*\n         * While technically threadLocalCollector does not replace an object, it does collect\n         * information needed by the invocation plugin used to create VMThreadLocalAccess nodes (and\n         * also remove the original FastThreadLocal constant from the graph).\n         *\n         * It would be possible to create VMThreadLocalAccess nodes via a canonicalization phase\n         * after analysis has completed, which would have the potential benefit of reducing the\n         * number of thread locals instantiated; however, this requires careful coordination with\n         * snippet graphs, especially for runtime compilation, and likely the added complexity would\n         * outweigh the benefits.\n         */\n        config.registerObjectReplacer(threadLocalCollector);\n    }\n\n    /**\n     * Intrinsify the {@code get()} and {@code set()} methods during bytecode parsing. We know that\n     * every subclass of VMThreadLocal has the same methods. Only the signatures differ based on the\n     * type of value.\n     * <p>\n     * When the {@link IsolateThread} is not passed in as a parameter, we use the\n     * {@link LoadVMThreadLocalNode current thread}. We do not need read/write barriers since we\n     * access memory that we manage ourselfs.\n     */\n    @Override\n    public void registerInvocationPlugins(Providers providers, Plugins plugins, ParsingReason reason) {\n        for (Class<? extends FastThreadLocal> threadLocalClass : VMThreadLocalInfo.THREAD_LOCAL_CLASSES) {\n            Registration r = new Registration(plugins.getInvocationPlugins(), threadLocalClass);\n            Class<?> valueClass = VMThreadLocalInfo.getValueClass(threadLocalClass);\n            registerAccessors(r, valueClass, false);\n            registerAccessors(r, valueClass, true);\n\n            /* compareAndSet() method without the VMThread parameter. */\n            r.register(new RequiredInvocationPlugin(\"compareAndSet\", Receiver.class, valueClass, valueClass) {\n                @Override\n                public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode expect, ValueNode update) {\n                    ValueNode threadNode = currentThread(b);\n                    return handleCompareAndSet(b, targetMethod, receiver, threadNode, expect, update);\n                }\n            });\n            /* get() method with the VMThread parameter. */\n            r.register(new RequiredInvocationPlugin(\"compareAndSet\", Receiver.class, IsolateThread.class, valueClass, valueClass) {\n                @Override\n                public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, ValueNode expect, ValueNode update) {\n                    return handleCompareAndSet(b, targetMethod, receiver, threadNode, expect, update);\n                }\n            });\n        }\n\n        Class<?>[] typesWithGetAddress = new Class<?>[]{FastThreadLocalBytes.class, FastThreadLocalWord.class};\n        for (Class<?> type : typesWithGetAddress) {\n            Registration r = new Registration(plugins.getInvocationPlugins(), type);\n            /* getAddress() method without the VMThread parameter. */\n            r.register(new RequiredInvocationPlugin(\"getAddress\", Receiver.class) {\n                @Override\n                public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {\n                    ValueNode threadNode = currentThread(b);\n                    return handleGetAddress(b, targetMethod, receiver, threadNode);\n                }\n            });\n            /* getAddress() method with the VMThread parameter. */\n            r.register(new RequiredInvocationPlugin(\"getAddress\", Receiver.class, IsolateThread.class) {\n                @Override\n                public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode) {\n                    return handleGetAddress(b, targetMethod, receiver, threadNode);\n                }\n            });\n        }\n    }\n\n    private void registerAccessors(Registration r, Class<?> valueClass, boolean isVolatile) {\n        String suffix = isVolatile ? \"Volatile\" : \"\";\n\n        /* get() method without the VMThread parameter. */\n        r.register(new RequiredInvocationPlugin(\"get\" + suffix, Receiver.class) {\n            @Override\n            public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {\n                ValueNode threadNode = currentThread(b);\n                return handleGet(b, targetMethod, receiver, threadNode, isVolatile);\n            }\n        });\n        /* get() method with the VMThread parameter. */\n        r.register(new RequiredInvocationPlugin(\"get\" + suffix, Receiver.class, IsolateThread.class) {\n            @Override\n            public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode) {\n                return handleGet(b, targetMethod, receiver, threadNode, isVolatile);\n            }\n        });\n        /* set() method without the VMThread parameter. */\n        r.register(new RequiredInvocationPlugin(\"set\" + suffix, Receiver.class, valueClass) {\n            @Override\n            public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode valueNode) {\n                ValueNode threadNode = currentThread(b);\n                return handleSet(b, receiver, threadNode, valueNode, isVolatile);\n            }\n        });\n        /* set() method with the VMThread parameter. */\n        r.register(new RequiredInvocationPlugin(\"set\" + suffix, Receiver.class, IsolateThread.class, valueClass) {\n            @Override\n            public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, ValueNode valueNode) {\n                return handleSet(b, receiver, threadNode, valueNode, isVolatile);\n            }\n        });\n    }\n\n    private static ValueNode currentThread(GraphBuilderContext b) {\n        return b.add(ReadReservedRegister.createReadIsolateThreadNode(b.getGraph()));\n    }\n\n    private boolean handleGet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, boolean isVolatile) {\n        VMThreadLocalInfo threadLocalInfo = threadLocalCollector.findInfo(b, receiver.get(true));\n\n        LoadVMThreadLocalNode node = new LoadVMThreadLocalNode(b.getMetaAccess(), threadLocalInfo, threadNode, BarrierType.NONE, isVolatile ? MemoryOrderMode.VOLATILE : MemoryOrderMode.PLAIN);\n        b.addPush(targetMethod.getSignature().getReturnKind(), node);\n\n        return true;\n    }\n\n    private boolean handleSet(GraphBuilderContext b, Receiver receiver, ValueNode threadNode, ValueNode valueNode, boolean isVolatile) {\n        VMThreadLocalInfo threadLocalInfo = threadLocalCollector.findInfo(b, receiver.get(true));\n\n        StoreVMThreadLocalNode store = b.add(new StoreVMThreadLocalNode(threadLocalInfo, threadNode, valueNode, BarrierType.NONE, isVolatile ? MemoryOrderMode.VOLATILE : MemoryOrderMode.PLAIN));\n        assert store.stateAfter() != null : store + \" has no state after with graph builder context \" + b;\n        return true;\n    }\n\n    private boolean handleCompareAndSet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, ValueNode expect,\n                    ValueNode update) {\n        VMThreadLocalInfo threadLocalInfo = threadLocalCollector.findInfo(b, receiver.get(true));\n        CompareAndSetVMThreadLocalNode cas = new CompareAndSetVMThreadLocalNode(threadLocalInfo, threadNode, expect, update);\n        b.addPush(targetMethod.getSignature().getReturnKind(), cas);\n        assert cas.stateAfter() != null : cas + \" has no state after with graph builder context \" + b;\n        return true;\n    }\n\n    private boolean handleGetAddress(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode) {\n        VMThreadLocalInfo threadLocalInfo = threadLocalCollector.findInfo(b, receiver.get(true));\n        b.addPush(targetMethod.getSignature().getReturnKind(), new AddressOfVMThreadLocalNode(threadLocalInfo, threadNode));\n        return true;\n    }\n\n    @Override\n    public void beforeCompilation(BeforeCompilationAccess config) {\n        List<VMThreadLocalInfo> sortedThreadLocalInfos = threadLocalCollector.sortThreadLocals();\n        SubstrateReferenceMap referenceMap = new SubstrateReferenceMap();\n        int nextOffset = 0;\n        nextOffset = sortAndAssignOffsets(sortedThreadLocalInfos, nextOffset, referenceMap);\n\n        InstanceReferenceMapEncoder encoder = new InstanceReferenceMapEncoder();\n        encoder.add(referenceMap);\n        NonmovableArray<Byte> referenceMapEncoding = encoder.encodeAll();\n        threadLocalSupport.vmThreadReferenceMapEncoding = NonmovableArrays.getHostedArray(referenceMapEncoding);\n        threadLocalSupport.vmThreadReferenceMapIndex = encoder.lookupEncoding(referenceMap);\n        threadLocalSupport.vmThreadSize = nextOffset;\n\n        /* Remember the final sorted list. */\n        VMThreadLocalInfos.setInfos(sortedThreadLocalInfos);\n    }\n\n    private int sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap) {\n        for (VMThreadLocalInfo info : sortedThreadLocalInfos) {\n            int alignment = Math.min(8, info.sizeInBytes);\n            nextOffset = NumUtil.roundUp(nextOffset, alignment);\n\n            if (info.isObject) {\n                referenceMap.markReferenceAtOffset(nextOffset, true);\n            }\n            info.offset = nextOffset;\n            nextOffset += info.sizeInBytes;\n\n            if (info.offset > info.maxOffset) {\n                VMError.shouldNotReachHere(\"Too many thread local variables with maximum offset \" + info.maxOffset + \" defined\");\n            }\n        }\n        return nextOffset;\n    }\n\n    public int offsetOf(FastThreadLocal threadLocal) {\n        return threadLocalCollector.getInfo(threadLocal).offset;\n    }\n}",
                "methodCount": 19
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 6,
                "candidates": [
                    {
                        "lineStart": 183,
                        "lineEnd": 185,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method currentThread to class NativeUtils",
                        "description": "move method currentThread to PsiClass:NativeUtils\nRationale: The method currentThread() deals with 'GraphBuilderContext' and utilizes methods like 'add' and 'createReadIsolateThreadNode', which are lower-level operations typically associated with native utilities and thread management. NativeUtils is responsible for handling lower-level system utilities and existing methods that interact with the system's native functionalities. Therefore, moving currentThread() to NativeUtils aligns with existing responsibilities and ensures cohesiveness.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 237,
                        "lineEnd": 253,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method sortAndAssignOffsets to class VMThreadLocalCollector",
                        "description": "Move method sortAndAssignOffsets to com.oracle.svm.hosted.thread.VMThreadLocalCollector\nRationale: The method sortAndAssignOffsets relies heavily on processing and managing VMThreadLocalInfo objects, which are centrally maintained and utilized by VMThreadLocalCollector. The primary purpose of VMThreadLocalCollector is to manage and sort VMThreadLocalInfo instances, which aligns with the tasks this method performs. Additionally, moving the method to VMThreadLocalCollector ensures that all thread local collection logic is encapsulated within a single class, enhancing maintenance and readability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 196,
                        "lineEnd": 202,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method handleSet to class GraphBuilderContext",
                        "description": "Move method handleSet to jdk.graal.compiler.nodes.graphbuilderconf.GraphBuilderContext\nRationale: The `handleSet()` method interacts closely with the `GraphBuilderContext` by calling its methods such as `b.add()`. The method is heavily involved in manipulating the graph-building context and requires access to the graph-building utilities provided by `GraphBuilderContext`. Additionally, the `findInfo()` method call to `VMThreadLocalCollector` can be easily handled within `GraphBuilderContext`, making it a more logical place for this method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 204,
                        "lineEnd": 211,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method handleCompareAndSet to class GraphBuilderContext",
                        "description": "Move method handleCompareAndSet to jdk.graal.compiler.nodes.graphbuilderconf.GraphBuilderContext\nRationale: The method `handleCompareAndSet` uses various methods and properties of the `GraphBuilderContext` class extensively, such as `b.addPush()` and `b` being passed as the `GraphBuilderContext` instance. It interacts directly with the graph manipulation and bytecode parsing responsibilities, which are core functionalities provided by `GraphBuilderContext`. Therefore, placing this method in the `GraphBuilderContext` class aligns well with its existing responsibilities and functions, making it the most appropriate target class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 187,
                        "lineEnd": 194,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method handleGet to class GraphBuilderContext",
                        "description": "Move method handleGet to jdk.graal.compiler.nodes.graphbuilderconf.GraphBuilderContext\nRationale: The method handleGet relies heavily on the GraphBuilderContext to function. It calls several methods provided by GraphBuilderContext such as getMetaAccess() and addPush(), and interacts with the GraphBuilder framework. Moving this method to GraphBuilderContext maintains coherence and encapsulates functionality related to graph building and context handling within the same class. Furthermore, it uses many parameters and methods unique to the GraphBuilderContext making it a natural choice for relocation.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 213,
                        "lineEnd": 217,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method handleGetAddress to class GraphBuilderContext",
                        "description": "Move method handleGetAddress to jdk.graal.compiler.nodes.graphbuilderconf.GraphBuilderContext\nRationale: The handleGetAddress() method interacts closely with the GraphBuilderContext class, using its addPush() and other stack manipulation functions to add a value to the graph. This association emphasizes that the method should be within GraphBuilderContext as it directly alters the graph-building process, making it closely tied to the workflow and functionality defined in GraphBuilderContext. Additionally, the use of the GraphBuilderContext parameter (b) and ResolvedJavaMethod (targetMethod) signifies that this method is fundamentally involved in the operations typical for graph building and bytecode parsing which are central to GraphBuilderContext.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "offsetOf",
                            "method_signature": "public int offsetOf(FastThreadLocal threadLocal)",
                            "target_class": "VMThreadLocalCollector",
                            "rationale": "The offsetOf method directly accesses the VMThreadLocalCollector, making it more appropriate to be encapsulated within the VMThreadLocalCollector class."
                        },
                        {
                            "method_name": "sortAndAssignOffsets",
                            "method_signature": "private int sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap)",
                            "target_class": "VMThreadLocalCollector",
                            "rationale": "The sortAndAssignOffsets method deals primarily with the VMThreadLocalCollector's responsibilities and better fits within that class."
                        },
                        {
                            "method_name": "handleGet",
                            "method_signature": "private boolean handleGet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, boolean isVolatile)",
                            "target_class": "VMThreadLocalSupport",
                            "rationale": "The handleGet method operates on VM thread locals and is closely related to VMThreadLocalSupport, making it better suited for that class."
                        },
                        {
                            "method_name": "handleSet",
                            "method_signature": "private boolean handleSet(GraphBuilderContext b, Receiver receiver, ValueNode threadNode, ValueNode valueNode, boolean isVolatile)",
                            "target_class": "VMThreadLocalSupport",
                            "rationale": "Similar to handleGet, the handleSet method manages VM thread locals and logically belongs in the VMThreadLocalSupport class."
                        },
                        {
                            "method_name": "handleCompareAndSet",
                            "method_signature": "private boolean handleCompareAndSet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, ValueNode expect, ValueNode update)",
                            "target_class": "VMThreadLocalSupport",
                            "rationale": "The handleCompareAndSet method is intricately involved with the operations of VM thread locals, thus fitting more naturally in VMThreadLocalSupport."
                        },
                        {
                            "method_name": "handleGetAddress",
                            "method_signature": "private boolean handleGetAddress(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode)",
                            "target_class": "VMThreadLocalSupport",
                            "rationale": "Given the nature of handleGetAddress's operations, it is more appropriate to be part of the VMThreadLocalSupport class."
                        }
                    ],
                    "llm_response_time": 5975
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "offsetOf",
                            "method_signature": "public int offsetOf(FastThreadLocal threadLocal)",
                            "target_class": "VMThreadLocalCollector",
                            "rationale": "The method offsetOf relies on data and operations specific to VMThreadLocalCollector. It would be more appropriate to place this method in the VMThreadLocalCollector class as it deals with the information that VMThreadLocalCollector holds."
                        },
                        {
                            "method_name": "sortAndAssignOffsets",
                            "method_signature": "private int sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap)",
                            "target_class": "VMThreadLocalCollector",
                            "rationale": "The sortAndAssignOffsets method handles operations on VMThreadLocalInfo instances, which are strongly related to thread local variable collection and management. Hence, it would be more appropriately placed in the VMThreadLocalCollector class."
                        }
                    ],
                    "llm_response_time": 2985
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "sortAndAssignOffsets",
                            "method_signature": "private int sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap)",
                            "target_class": "VMThreadLocalCollector",
                            "rationale": "The sortAndAssignOffsets method handles operations specifically related to VMThreadLocalInfo collection and references, which aligns more closely with the responsibilities of VMThreadLocalCollector."
                        },
                        {
                            "method_name": "offsetOf",
                            "method_signature": "public int offsetOf(FastThreadLocal threadLocal)",
                            "target_class": "VMThreadLocalCollector",
                            "rationale": "The offsetOf method deals directly with the VMThreadLocalCollector by retrieving specific information (offset) about threadLocal, making it a better fit for the VMThreadLocalCollector class."
                        },
                        {
                            "method_name": "currentThread",
                            "method_signature": "private static ValueNode currentThread(GraphBuilderContext b)",
                            "target_class": "VMThreadLocalSupport",
                            "rationale": "The currentThread method is responsible for reading the current thread, a functionality that aligns more closely with the VMThreadLocalSupport class."
                        },
                        {
                            "method_name": "handleGet",
                            "method_signature": "private boolean handleGet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, boolean isVolatile)",
                            "target_class": "VMThreadLocalSupport",
                            "rationale": "The handleGet method handles reading VMThreadLocal values, which fits better with thread-local support responsibilities of VMThreadLocalSupport."
                        },
                        {
                            "method_name": "handleSet",
                            "method_signature": "private boolean handleSet(GraphBuilderContext b, Receiver receiver, ValueNode threadNode, ValueNode valueNode, boolean isVolatile)",
                            "target_class": "VMThreadLocalSupport",
                            "rationale": "The handleSet method handles writing VMThreadLocal values, which fits better with thread-local support responsibilities of VMThreadLocalSupport."
                        },
                        {
                            "method_name": "handleCompareAndSet",
                            "method_signature": "private boolean handleCompareAndSet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, ValueNode expect, ValueNode update)",
                            "target_class": "VMThreadLocalSupport",
                            "rationale": "The handleCompareAndSet method is responsible for handling compare-and-set operations for thread-local variables, fitting more closely with the responsibilities of VMThreadLocalSupport."
                        },
                        {
                            "method_name": "handleGetAddress",
                            "method_signature": "private boolean handleGetAddress(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode)",
                            "target_class": "VMThreadLocalSupport",
                            "rationale": "The handleGetAddress method deals with getting the address of VMThreadLocal values, making it more appropriate for the VMThreadLocalSupport class."
                        }
                    ],
                    "llm_response_time": 6877
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "currentThread",
                            "method_signature": "private static currentThread(GraphBuilderContext b)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleGet",
                            "method_signature": "private handleGet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, boolean isVolatile)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleSet",
                            "method_signature": "private handleSet(GraphBuilderContext b, Receiver receiver, ValueNode threadNode, ValueNode valueNode, boolean isVolatile)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleCompareAndSet",
                            "method_signature": "private handleCompareAndSet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, ValueNode expect,\n                    ValueNode update)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleGetAddress",
                            "method_signature": "private handleGetAddress(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "sortAndAssignOffsets",
                            "method_signature": "private sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "currentThread",
                            "method_signature": "private static currentThread(GraphBuilderContext b)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "sortAndAssignOffsets",
                            "method_signature": "private sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleSet",
                            "method_signature": "private handleSet(GraphBuilderContext b, Receiver receiver, ValueNode threadNode, ValueNode valueNode, boolean isVolatile)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleCompareAndSet",
                            "method_signature": "private handleCompareAndSet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, ValueNode expect,\n                    ValueNode update)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleGet",
                            "method_signature": "private handleGet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, boolean isVolatile)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleGetAddress",
                            "method_signature": "private handleGetAddress(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "private static currentThread(GraphBuilderContext b)": {
                        "first": {
                            "method_name": "currentThread",
                            "method_signature": "private static currentThread(GraphBuilderContext b)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.37396318721371
                    },
                    "private sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap)": {
                        "first": {
                            "method_name": "sortAndAssignOffsets",
                            "method_signature": "private sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4178226121413394
                    },
                    "private handleSet(GraphBuilderContext b, Receiver receiver, ValueNode threadNode, ValueNode valueNode, boolean isVolatile)": {
                        "first": {
                            "method_name": "handleSet",
                            "method_signature": "private handleSet(GraphBuilderContext b, Receiver receiver, ValueNode threadNode, ValueNode valueNode, boolean isVolatile)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.48435210113219523
                    },
                    "private handleCompareAndSet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, ValueNode expect,\n                    ValueNode update)": {
                        "first": {
                            "method_name": "handleCompareAndSet",
                            "method_signature": "private handleCompareAndSet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, ValueNode expect,\n                    ValueNode update)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5425590829949175
                    },
                    "private handleGet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, boolean isVolatile)": {
                        "first": {
                            "method_name": "handleGet",
                            "method_signature": "private handleGet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, boolean isVolatile)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5623895191980425
                    },
                    "private handleGetAddress(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode)": {
                        "first": {
                            "method_name": "handleGetAddress",
                            "method_signature": "private handleGetAddress(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5657757923741527
                    }
                },
                "voyage": {
                    "private static currentThread(GraphBuilderContext b)": {
                        "first": {
                            "method_name": "currentThread",
                            "method_signature": "private static currentThread(GraphBuilderContext b)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4978077021768743
                    },
                    "private handleCompareAndSet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, ValueNode expect,\n                    ValueNode update)": {
                        "first": {
                            "method_name": "handleCompareAndSet",
                            "method_signature": "private handleCompareAndSet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, ValueNode expect,\n                    ValueNode update)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5043361185917242
                    },
                    "private sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap)": {
                        "first": {
                            "method_name": "sortAndAssignOffsets",
                            "method_signature": "private sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5138613514318399
                    },
                    "private handleGetAddress(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode)": {
                        "first": {
                            "method_name": "handleGetAddress",
                            "method_signature": "private handleGetAddress(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5594801271883363
                    },
                    "private handleSet(GraphBuilderContext b, Receiver receiver, ValueNode threadNode, ValueNode valueNode, boolean isVolatile)": {
                        "first": {
                            "method_name": "handleSet",
                            "method_signature": "private handleSet(GraphBuilderContext b, Receiver receiver, ValueNode threadNode, ValueNode valueNode, boolean isVolatile)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5603488241456767
                    },
                    "private handleGet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, boolean isVolatile)": {
                        "first": {
                            "method_name": "handleGet",
                            "method_signature": "private handleGet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, boolean isVolatile)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5943512244688276
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap)",
                        "private handleSet(GraphBuilderContext b, Receiver receiver, ValueNode threadNode, ValueNode valueNode, boolean isVolatile)",
                        "private handleGet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, boolean isVolatile)",
                        "private handleGetAddress(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode)",
                        "private static currentThread(GraphBuilderContext b)"
                    ],
                    "llm_response_time": 3193
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "private sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap)",
                        "private static currentThread(GraphBuilderContext b)",
                        "private handleSet(GraphBuilderContext b, Receiver receiver, ValueNode threadNode, ValueNode valueNode, boolean isVolatile)",
                        "private handleGet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, boolean isVolatile)"
                    ],
                    "llm_response_time": 4900
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap)",
                        "private handleSet(GraphBuilderContext b, Receiver receiver, ValueNode threadNode, ValueNode valueNode, boolean isVolatile)",
                        "private static currentThread(GraphBuilderContext b)"
                    ],
                    "llm_response_time": 3992
                },
                "voyage": {
                    "priority_method_names": [
                        "private sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap)",
                        "private handleGet(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode, boolean isVolatile)",
                        "private handleSet(GraphBuilderContext b, Receiver receiver, ValueNode threadNode, ValueNode valueNode, boolean isVolatile)",
                        "private handleGetAddress(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode)",
                        "private static currentThread(GraphBuilderContext b)"
                    ],
                    "llm_response_time": 5429
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap)",
                        "private handleSet(GraphBuilderContext b, Receiver receiver, ValueNode threadNode, ValueNode valueNode, boolean isVolatile)",
                        "private handleGetAddress(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode threadNode)",
                        "private static currentThread(GraphBuilderContext b)"
                    ],
                    "llm_response_time": 6302
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private sortAndAssignOffsets(List<VMThreadLocalInfo> sortedThreadLocalInfos, int nextOffset, SubstrateReferenceMap referenceMap)",
                        "private static currentThread(GraphBuilderContext b)"
                    ],
                    "llm_response_time": 4686
                }
            },
            "targetClassMap": {
                "currentThread": {
                    "target_classes": [
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.42600643361512924
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.4355163866123252
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.30448223046932277
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.5393308788692646
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.42295493443781357
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.5008952558646071
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.42376953204480977
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.42008402520840293
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.3348006918570716
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.31170812110189233
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.4161502110969443
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.47287799241095896
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.23097828906119441
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.3893957789726338
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.2856661086149273
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.40019849476037667
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.4874250766273118
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.35800757350424023
                        },
                        {
                            "class_name": "MissingJNIRegistrationUtils",
                            "similarity_score": 0.24934012186016719
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.3208862152563441
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.4468424124822087
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.388850360242746
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.3680117765652781
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.3862160813477717
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.4625924443258073
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.30685820596610774
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.3689323936863109
                        },
                        {
                            "class_name": "ArrayUtil",
                            "similarity_score": 0.2328335661670159
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.360211422396787
                        },
                        {
                            "class_name": "GlobUtils",
                            "similarity_score": 0.3493982837762231
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.5036554011451931
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.2609765612629318
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.4
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.4891995904702286
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.40542704285759035
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.3447675706207963
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.3842734199843614
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.4611813527273016
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.24257737852669553
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.5111066790571479
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.2284086026558024
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.2601323442853824
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.20527947506435448
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.39946980601234033
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.34101940821038984
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.5503953220024497
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.5447945117232603
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.4778948196482323
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.47007819313777954
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.4423458818515064
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.30088078687557224
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.4747809034364905
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.4665959914057206
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.423981802262146
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.3892199991139531
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.3074704252058897
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.6342147997770687
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.482386325468387
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.15653375612247375
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.2742481130259784
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.30056041659003363
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.23311508977566436
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.3714805510117293
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.46440369468973514
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.39084256181065413
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.2609978754859403
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.3732568389434776
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.46258003426114613
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.4161528374070254
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.49034208079719993
                        },
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.4468652995814619
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.4009024532043414
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.5133254994122544
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.4607032393498821
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.22233900305020096
                        },
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.2565439031598864
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.2514373006621585
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.17816153940083965
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.2667428566318556
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.44406693481300274
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.2587139100125934
                        },
                        {
                            "class_name": "Target_java_util_concurrent_locks_AbstractOwnableSynchronizer",
                            "similarity_score": 0.38313051408846055
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.44417348431849013
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.39333108840606035
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.448184575833388
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.2928819019390717
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.3541204372937959
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.2918650119236377
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.3757476534604519
                        },
                        {
                            "class_name": "CEntryPointUtilityNode",
                            "similarity_score": 0.46639324460188303
                        },
                        {
                            "class_name": "AtomicBoolean",
                            "similarity_score": 0.41155399860399566
                        },
                        {
                            "class_name": "AtomicInteger",
                            "similarity_score": 0.34883934538536343
                        },
                        {
                            "class_name": "AtomicLong",
                            "similarity_score": 0.3284792661962705
                        },
                        {
                            "class_name": "AtomicPointer",
                            "similarity_score": 0.4195013356261801
                        },
                        {
                            "class_name": "AtomicReference",
                            "similarity_score": 0.4009634698823127
                        },
                        {
                            "class_name": "AtomicUnsigned",
                            "similarity_score": 0.13085598064755344
                        },
                        {
                            "class_name": "AtomicWord",
                            "similarity_score": 0.12503380479819487
                        },
                        {
                            "class_name": "ExitException",
                            "similarity_score": 0.4061811972299616
                        },
                        {
                            "class_name": "InvalidMacroException",
                            "similarity_score": 0.3553345272593507
                        },
                        {
                            "class_name": "UnsafeMemoryUtil",
                            "similarity_score": 0.280717307022173
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "NativeUtils",
                        "MathUtil",
                        "NativeImageResourceFileSystemUtil"
                    ],
                    "llm_response_time": 3097,
                    "similarity_computation_time": 74,
                    "similarity_metric": "cosine"
                },
                "sortAndAssignOffsets": {
                    "target_classes": [
                        {
                            "class_name": "SubstrateReferenceMap",
                            "similarity_score": 0.6409298632464101
                        },
                        {
                            "class_name": "VMThreadLocalCollector",
                            "similarity_score": 0.5990242360460171
                        },
                        {
                            "class_name": "VMThreadLocalSupport",
                            "similarity_score": 0.4203739049612718
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "VMThreadLocalCollector",
                        "VMThreadLocalSupport",
                        "SubstrateReferenceMap"
                    ],
                    "llm_response_time": 3383,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "handleSet": {
                    "target_classes": [
                        {
                            "class_name": "GraphBuilderContext",
                            "similarity_score": 0.17969777273727577
                        },
                        {
                            "class_name": "Receiver",
                            "similarity_score": 0.07085351319371781
                        },
                        {
                            "class_name": "VMThreadLocalCollector",
                            "similarity_score": 0.34595017707435755
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "GraphBuilderContext",
                        "VMThreadLocalCollector",
                        "Receiver"
                    ],
                    "llm_response_time": 3854,
                    "similarity_computation_time": 8,
                    "similarity_metric": "cosine"
                },
                "handleCompareAndSet": {
                    "target_classes": [
                        {
                            "class_name": "GraphBuilderContext",
                            "similarity_score": 0.18097677658427297
                        },
                        {
                            "class_name": "Receiver",
                            "similarity_score": 0.07730429961089472
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "GraphBuilderContext",
                        "Receiver"
                    ],
                    "llm_response_time": 3155,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "handleGet": {
                    "target_classes": [
                        {
                            "class_name": "GraphBuilderContext",
                            "similarity_score": 0.18621803089694972
                        },
                        {
                            "class_name": "Receiver",
                            "similarity_score": 0.053738150125194
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "GraphBuilderContext",
                        "Receiver"
                    ],
                    "llm_response_time": 3198,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "handleGetAddress": {
                    "target_classes": [
                        {
                            "class_name": "GraphBuilderContext",
                            "similarity_score": 0.19381093037181327
                        },
                        {
                            "class_name": "Receiver",
                            "similarity_score": 0.07261785883857189
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "GraphBuilderContext",
                        "Receiver"
                    ],
                    "llm_response_time": 4262,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "abef2e2e60ecca41f00b487d04696a7bc53f4c85",
        "url": "https://github.com/oracle/graal/commit/abef2e2e60ecca41f00b487d04696a7bc53f4c85",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public moveInt(dst Register, imm int) : void extracted from public emitCode(crb CompilationResultBuilder, masm AMD64MacroAssembler) : void in class jdk.graal.compiler.lir.amd64.AMD64ConvertFloatToIntegerOp & moved to class jdk.graal.compiler.asm.amd64.AMD64MacroAssembler",
            "leftSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/lir/amd64/AMD64ConvertFloatToIntegerOp.java",
                    "startLine": 86,
                    "endLine": 163,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "public emitCode(crb CompilationResultBuilder, masm AMD64MacroAssembler) : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/lir/amd64/AMD64ConvertFloatToIntegerOp.java",
                    "startLine": 132,
                    "endLine": 132,
                    "startColumn": 17,
                    "endColumn": 35,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1443,
                    "endLine": 1452,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public moveInt(dst Register, imm int) : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1451,
                    "endLine": 1451,
                    "startColumn": 9,
                    "endColumn": 24,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/lir/amd64/AMD64ConvertFloatToIntegerOp.java",
                    "startLine": 86,
                    "endLine": 163,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "public emitCode(crb CompilationResultBuilder, masm AMD64MacroAssembler) : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/lir/amd64/AMD64ConvertFloatToIntegerOp.java",
                    "startLine": 132,
                    "endLine": 132,
                    "startColumn": 17,
                    "endColumn": 37,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "masm.moveInt(dst,0)"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1445,
                    "endLine": 1445,
                    "startColumn": 13,
                    "endColumn": 65,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1447,
                    "endLine": 1447,
                    "startColumn": 17,
                    "endColumn": 46,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1448,
                    "endLine": 1448,
                    "startColumn": 17,
                    "endColumn": 24,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1446,
                    "endLine": 1449,
                    "startColumn": 59,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1446,
                    "endLine": 1449,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1444,
                    "endLine": 1450,
                    "startColumn": 23,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1444,
                    "endLine": 1450,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                }
            ],
            "isStatic": false
        },
        "ref_id": 563,
        "extraction_results": {
            "success": true,
            "newCommitHash": "0d144e149b34e174e452827083b42720ae984d65",
            "newBranchName": "extract-moveInt-emitCode-db59458"
        },
        "telemetry": {
            "id": "20a411ea-4113-495e-953a-cf0800cb3748",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 128,
                "lineStart": 48,
                "lineEnd": 175,
                "bodyLineStart": 48,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/lir/amd64/AMD64ConvertFloatToIntegerOp.java",
                "sourceCode": "/**\n * Floating point to integer conversion according to Java semantics. This wraps an AMD64 conversion\n * instruction and adjusts its result as needed. According to Java semantics, NaN inputs should be\n * mapped to 0, and values outside the integer type's range should be mapped to {@code MIN_VALUE} or\n * {@code MAX_VALUE} according to the input's sign. The AMD64 instructions produce {@code MIN_VALUE}\n * for NaNs and all values outside the integer type's range. So we need to fix up the result for\n * NaNs and positive overflowing values. Negative overflowing values keep {@code MIN_VALUE}.\n */\npublic class AMD64ConvertFloatToIntegerOp extends AMD64LIRInstruction {\n    public static final LIRInstructionClass<AMD64ConvertFloatToIntegerOp> TYPE = LIRInstructionClass.create(AMD64ConvertFloatToIntegerOp.class);\n\n    @Def({REG}) protected Value dstValue;\n    @Alive({REG}) protected Value srcValue;\n    @Temp({REG, ILLEGAL}) protected Value tmpValue;\n\n    private final OpcodeEmitter opcode;\n    private final boolean canBeNaN;\n    private final boolean canOverflow;\n\n    @FunctionalInterface\n    public interface OpcodeEmitter {\n        /** Emit the actual conversion instruction. */\n        void emit(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register dst, Register src);\n    }\n\n    public AMD64ConvertFloatToIntegerOp(LIRGeneratorTool tool, OpcodeEmitter opcode, Value dstValue, Value srcValue, boolean canBeNaN, boolean canOverflow) {\n        super(TYPE);\n        this.dstValue = dstValue;\n        this.srcValue = srcValue;\n        this.opcode = opcode;\n        this.tmpValue = canOverflow ? tool.newVariable(srcValue.getValueKind()) : Value.ILLEGAL;\n        this.canBeNaN = canBeNaN;\n        this.canOverflow = canOverflow;\n\n        GraalError.guarantee(srcValue.getPlatformKind() instanceof AMD64Kind kind && kind.getVectorLength() == 1 && kind.isXMM(), \"source must be scalar floating-point: %s\", srcValue);\n        GraalError.guarantee(dstValue.getPlatformKind() instanceof AMD64Kind kind && kind.getVectorLength() == 1 && kind.isInteger(), \"destination must be integer: %s\", dstValue);\n    }\n\n    @Override\n    public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n        Register dst = asRegister(dstValue);\n        Register src = asRegister(srcValue);\n        Label fixupPath = new Label();\n        Label done = new Label();\n\n        opcode.emit(crb, masm, dst, src);\n\n        if (!canBeNaN && !canOverflow) {\n            /* No fixup needed. */\n            return;\n        }\n\n        int integerBytes = dstValue.getPlatformKind().getSizeInBytes();\n        GraalError.guarantee(integerBytes == 4 || integerBytes == 8, \"unexpected target %s\", dstValue);\n        OperandSize floatSize = switch (srcValue.getPlatformKind().getSizeInBytes()) {\n            case 4 -> OperandSize.PS;\n            case 8 -> OperandSize.PD;\n            default -> throw GraalError.shouldNotReachHere(\"unexpected input %s\".formatted(srcValue));\n        };\n\n        /*\n         * if (dst == MIN_VALUE) { goto fixupPath; }\n         */\n        if (integerBytes == 4) {\n            masm.cmplAndJcc(dst, Integer.MIN_VALUE, AMD64Assembler.ConditionFlag.Equal, fixupPath, false);\n        } else {\n            masm.cmpq(dst, (AMD64Address) crb.asLongConstRef(JavaConstant.forLong(Long.MIN_VALUE)));\n            masm.jcc(AMD64Assembler.ConditionFlag.Equal, fixupPath);\n        }\n\n        crb.getLIR().addSlowPath(this, () -> {\n            masm.bind(fixupPath);\n\n            if (canBeNaN) {\n                /*\n                 * if (isNaN(src)) { result = 0; goto done; }\n                 *\n                 * The isNaN check is implemented as src != src. C2's fixup stubs check for a NaN\n                 * bit pattern directly, using the same number of cycles but using an extra general\n                 * purpose register.\n                 */\n                Label isNotNaN = new Label();\n                UCOMIS.emit(masm, floatSize, src, src);\n                masm.jcc(AMD64Assembler.ConditionFlag.NoParity, isNotNaN, true);\n                moveInt(masm, dst, 0);\n                masm.jmp(done);\n                masm.bind(isNotNaN);\n            }\n\n            if (canOverflow) {\n                /*\n                 * if (src > 0.0) { result = MAX_VALUE; }\n                 *\n                 * We use an actual floating point compare, C2's stubs check the sign bit in a GPR.\n                 */\n                Register zero = asRegister(tmpValue);\n                masm.pxor(AVXKind.AVXSize.XMM, zero, zero);\n                UCOMIS.emit(masm, floatSize, src, zero);\n                masm.jcc(AMD64Assembler.ConditionFlag.BelowEqual, done);\n                /*\n                 * MAX_VALUE is the bitwise negation of MIN_VALUE, which is already in dst. A\n                 * negation takes the same number of cycles as a move, but its encoding is shorter.\n                 */\n                if (integerBytes == 4) {\n                    masm.notl(dst);\n                } else {\n                    masm.notq(dst);\n                }\n            }\n\n            /* Return to inline code. */\n            masm.jmp(done);\n        });\n\n        masm.bind(done);\n    }\n\n    private void moveInt(AMD64MacroAssembler masm, Register dst, int imm) {\n        if (imm == 0) {\n            Register zeroValueRegister = masm.getZeroValueRegister();\n            if (!Register.None.equals(zeroValueRegister)) {\n                masm.movl(dst, zeroValueRegister);\n                return;\n            }\n        }\n        masm.movl(dst, imm);\n    }\n}",
                "methodCount": 4
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 164,
                        "lineEnd": 173,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method moveInt to class AMD64MacroAssembler",
                        "description": "Move method moveInt to jdk.graal.compiler.asm.amd64.AMD64MacroAssembler\nRationale: The moveInt() method directly interacts with the AMD64MacroAssembler\u2019s capabilities, such as retrieving the zero-value register and performing movl operations. It is imperative for the method to stay within a class that has direct control over these fundamental operations. This ensures encapsulation and consistency in handling low-level assembly instructions.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [],
                    "llm_response_time": 1415
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "moveInt",
                            "method_signature": "private void moveInt(AMD64MacroAssembler masm, Register dst, int imm)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "The moveInt() method focuses on low-level assembly operations that are more appropriate for the AMD64MacroAssembler class, which deals with assembly-specific tasks."
                        }
                    ],
                    "llm_response_time": 2021
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [],
                    "llm_response_time": 1163
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "moveInt",
                            "method_signature": "private moveInt(AMD64MacroAssembler masm, Register dst, int imm)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "moveInt",
                            "method_signature": "private moveInt(AMD64MacroAssembler masm, Register dst, int imm)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "private moveInt(AMD64MacroAssembler masm, Register dst, int imm)": {
                        "first": {
                            "method_name": "moveInt",
                            "method_signature": "private moveInt(AMD64MacroAssembler masm, Register dst, int imm)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.468772004083801
                    }
                },
                "voyage": {
                    "private moveInt(AMD64MacroAssembler masm, Register dst, int imm)": {
                        "first": {
                            "method_name": "moveInt",
                            "method_signature": "private moveInt(AMD64MacroAssembler masm, Register dst, int imm)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5808982575015863
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private moveInt(AMD64MacroAssembler masm, Register dst, int imm)"
                    ],
                    "llm_response_time": 1121
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "private moveInt(AMD64MacroAssembler masm, Register dst, int imm)"
                    ],
                    "llm_response_time": 1
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private moveInt(AMD64MacroAssembler masm, Register dst, int imm)"
                    ],
                    "llm_response_time": 0
                },
                "voyage": {
                    "priority_method_names": [
                        "private moveInt(AMD64MacroAssembler masm, Register dst, int imm)"
                    ],
                    "llm_response_time": 0
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private moveInt(AMD64MacroAssembler masm, Register dst, int imm)"
                    ],
                    "llm_response_time": 0
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private moveInt(AMD64MacroAssembler masm, Register dst, int imm)"
                    ],
                    "llm_response_time": 0
                }
            },
            "targetClassMap": {
                "moveInt": {
                    "target_classes": [
                        {
                            "class_name": "AMD64MacroAssembler",
                            "similarity_score": 0.6730774797754364
                        },
                        {
                            "class_name": "OpcodeEmitter",
                            "similarity_score": 0.3870693672140189
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "AMD64MacroAssembler",
                        "OpcodeEmitter"
                    ],
                    "llm_response_time": 3894,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/oracle/graal.git",
        "sha1": "abef2e2e60ecca41f00b487d04696a7bc53f4c85",
        "url": "https://github.com/oracle/graal/commit/abef2e2e60ecca41f00b487d04696a7bc53f4c85",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public moveIntSignExtend(result Register, imm int) : void extracted from public const2reg(crb CompilationResultBuilder, masm AMD64MacroAssembler, result Register, input JavaConstant, moveKind AMD64Kind) : void in class jdk.graal.compiler.lir.amd64.AMD64Move & moved to class jdk.graal.compiler.asm.amd64.AMD64MacroAssembler",
            "leftSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/lir/amd64/AMD64Move.java",
                    "startLine": 684,
                    "endLine": 764,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "public const2reg(crb CompilationResultBuilder, masm AMD64MacroAssembler, result Register, input JavaConstant, moveKind AMD64Kind) : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/lir/amd64/AMD64Move.java",
                    "startLine": 706,
                    "endLine": 706,
                    "startColumn": 21,
                    "endColumn": 63,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1465,
                    "endLine": 1474,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public moveIntSignExtend(result Register, imm int) : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1473,
                    "endLine": 1473,
                    "startColumn": 9,
                    "endColumn": 29,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/lir/amd64/AMD64Move.java",
                    "startLine": 684,
                    "endLine": 763,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "public const2reg(crb CompilationResultBuilder, masm AMD64MacroAssembler, result Register, input JavaConstant, moveKind AMD64Kind) : void"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/lir/amd64/AMD64Move.java",
                    "startLine": 705,
                    "endLine": 705,
                    "startColumn": 21,
                    "endColumn": 73,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "masm.moveIntSignExtend(result,(int)input.asLong())"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/lir/amd64/AMD64Move.java",
                    "startLine": 739,
                    "endLine": 739,
                    "startColumn": 25,
                    "endColumn": 58,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "masm.moveIntSignExtend(result,0)"
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1467,
                    "endLine": 1467,
                    "startColumn": 13,
                    "endColumn": 65,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1470,
                    "endLine": 1470,
                    "startColumn": 17,
                    "endColumn": 24,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1469,
                    "endLine": 1469,
                    "startColumn": 17,
                    "endColumn": 49,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1468,
                    "endLine": 1471,
                    "startColumn": 59,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1468,
                    "endLine": 1471,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1466,
                    "endLine": 1472,
                    "startColumn": 23,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/asm/amd64/AMD64MacroAssembler.java",
                    "startLine": 1466,
                    "endLine": 1472,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                }
            ],
            "isStatic": false
        },
        "ref_id": 565,
        "extraction_results": {
            "success": true,
            "newCommitHash": "ca02acf4f5c1dac329f8d8135e1ff840a8b77a53",
            "newBranchName": "extract-moveIntSignExtend-const2reg-db59458"
        },
        "telemetry": {
            "id": "cc0add24-5053-4ea3-a4cd-6e53274a8af0",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1048,
                "lineStart": 64,
                "lineEnd": 1111,
                "bodyLineStart": 64,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/graal/compiler/src/jdk.graal.compiler/src/jdk/graal/compiler/lir/amd64/AMD64Move.java",
                "sourceCode": "public class AMD64Move {\n\n    private abstract static class AbstractMoveOp extends AMD64LIRInstruction implements StandardOp.ValueMoveOp {\n        public static final LIRInstructionClass<AbstractMoveOp> TYPE = LIRInstructionClass.create(AbstractMoveOp.class);\n\n        private AMD64Kind moveKind;\n\n        protected AbstractMoveOp(LIRInstructionClass<? extends AbstractMoveOp> c, AMD64Kind moveKind) {\n            super(c);\n            this.moveKind = moveKind;\n        }\n\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            move(moveKind, crb, masm, getResult(), getInput());\n        }\n    }\n\n    @Opcode(\"MOVE\")\n    public static final class MoveToRegOp extends AbstractMoveOp {\n        public static final LIRInstructionClass<MoveToRegOp> TYPE = LIRInstructionClass.create(MoveToRegOp.class);\n\n        @Def({OperandFlag.REG, OperandFlag.STACK, OperandFlag.HINT}) protected AllocatableValue result;\n        @Use({OperandFlag.REG, OperandFlag.STACK}) protected AllocatableValue input;\n\n        public MoveToRegOp(AMD64Kind moveKind, AllocatableValue result, AllocatableValue input) {\n            super(TYPE, moveKind);\n            this.result = result;\n            this.input = input;\n        }\n\n        @Override\n        public AllocatableValue getInput() {\n            return input;\n        }\n\n        @Override\n        public AllocatableValue getResult() {\n            return result;\n        }\n    }\n\n    @Opcode(\"MOVE\")\n    public static final class MoveFromRegOp extends AbstractMoveOp {\n        public static final LIRInstructionClass<MoveFromRegOp> TYPE = LIRInstructionClass.create(MoveFromRegOp.class);\n\n        @Def({OperandFlag.REG, OperandFlag.STACK}) protected AllocatableValue result;\n        @Use({OperandFlag.REG, OperandFlag.HINT}) protected AllocatableValue input;\n\n        public MoveFromRegOp(AMD64Kind moveKind, AllocatableValue result, AllocatableValue input) {\n            super(TYPE, moveKind);\n            this.result = result;\n            this.input = input;\n        }\n\n        @Override\n        public AllocatableValue getInput() {\n            return input;\n        }\n\n        @Override\n        public AllocatableValue getResult() {\n            return result;\n        }\n    }\n\n    @Opcode(\"MOVE\")\n    public static class MoveFromConstOp extends AMD64LIRInstruction implements StandardOp.LoadConstantOp {\n        public static final LIRInstructionClass<MoveFromConstOp> TYPE = LIRInstructionClass.create(MoveFromConstOp.class);\n\n        @Def({OperandFlag.REG, OperandFlag.STACK}) protected AllocatableValue result;\n        private final JavaConstant input;\n\n        public MoveFromConstOp(AllocatableValue result, JavaConstant input) {\n            super(TYPE);\n            this.result = result;\n            this.input = input;\n        }\n\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            if (isRegister(result)) {\n                const2reg(crb, masm, asRegister(result), input, (AMD64Kind) result.getPlatformKind());\n            } else {\n                assert isStackSlot(result);\n                const2stack(crb, masm, result, input);\n            }\n        }\n\n        @Override\n        public Constant getConstant() {\n            return input;\n        }\n\n        @Override\n        public AllocatableValue getResult() {\n            return result;\n        }\n    }\n\n    @Opcode(\"STACKMOVE\")\n    public static final class AMD64StackMove extends AMD64LIRInstruction implements StandardOp.ValueMoveOp {\n        public static final LIRInstructionClass<AMD64StackMove> TYPE = LIRInstructionClass.create(AMD64StackMove.class);\n\n        @Def({OperandFlag.STACK}) protected AllocatableValue result;\n        @Use({OperandFlag.STACK, OperandFlag.HINT}) protected AllocatableValue input;\n        @Alive({OperandFlag.STACK, OperandFlag.UNINITIALIZED}) private AllocatableValue backupSlot;\n\n        private Register scratch;\n\n        public AMD64StackMove(AllocatableValue result, AllocatableValue input, Register scratch, AllocatableValue backupSlot) {\n            super(TYPE);\n            this.result = result;\n            this.input = input;\n            this.backupSlot = backupSlot;\n            this.scratch = scratch;\n        }\n\n        @Override\n        public AllocatableValue getInput() {\n            return input;\n        }\n\n        @Override\n        public AllocatableValue getResult() {\n            return result;\n        }\n\n        public Register getScratchRegister() {\n            return scratch;\n        }\n\n        public AllocatableValue getBackupSlot() {\n            return backupSlot;\n        }\n\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            AMD64Kind backupKind = (AMD64Kind) backupSlot.getPlatformKind();\n            if (backupKind.isXMM()) {\n                // graal doesn't use vector values, so it's safe to backup using DOUBLE\n                backupKind = AMD64Kind.DOUBLE;\n            }\n\n            // backup scratch register\n            reg2stack(backupKind, crb, masm, backupSlot, scratch);\n            // move stack slot\n            stack2reg((AMD64Kind) getInput().getPlatformKind(), crb, masm, scratch, getInput());\n            reg2stack((AMD64Kind) getResult().getPlatformKind(), crb, masm, getResult(), scratch);\n            // restore scratch register\n            stack2reg(backupKind, crb, masm, scratch, backupSlot);\n        }\n    }\n\n    @Opcode(\"MULTISTACKMOVE\")\n    public static final class AMD64MultiStackMove extends AMD64LIRInstruction {\n        public static final LIRInstructionClass<AMD64MultiStackMove> TYPE = LIRInstructionClass.create(AMD64MultiStackMove.class);\n\n        @Def({OperandFlag.STACK}) protected AllocatableValue[] results;\n        @Use({OperandFlag.STACK}) protected Value[] inputs;\n        @Alive({OperandFlag.STACK, OperandFlag.UNINITIALIZED}) private AllocatableValue backupSlot;\n\n        private Register scratch;\n\n        public AMD64MultiStackMove(AllocatableValue[] results, Value[] inputs, Register scratch, AllocatableValue backupSlot) {\n            super(TYPE);\n            this.results = results;\n            this.inputs = inputs;\n            this.backupSlot = backupSlot;\n            this.scratch = scratch;\n        }\n\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            AMD64Kind backupKind = (AMD64Kind) backupSlot.getPlatformKind();\n            if (backupKind.isXMM()) {\n                // graal doesn't use vector values, so it's safe to backup using DOUBLE\n                backupKind = AMD64Kind.DOUBLE;\n            }\n\n            // backup scratch register\n            move(backupKind, crb, masm, backupSlot, scratch.asValue(backupSlot.getValueKind()));\n            for (int i = 0; i < results.length; i++) {\n                Value input = inputs[i];\n                AllocatableValue result = results[i];\n                // move stack slot\n                move((AMD64Kind) input.getPlatformKind(), crb, masm, scratch.asValue(input.getValueKind()), input);\n                move((AMD64Kind) result.getPlatformKind(), crb, masm, result, scratch.asValue(result.getValueKind()));\n            }\n            // restore scratch register\n            move(backupKind, crb, masm, scratch.asValue(backupSlot.getValueKind()), backupSlot);\n        }\n    }\n\n    public static final class LeaOp extends AMD64LIRInstruction {\n        public static final LIRInstructionClass<LeaOp> TYPE = LIRInstructionClass.create(LeaOp.class);\n\n        @Def({OperandFlag.REG}) protected AllocatableValue result;\n        @Use({OperandFlag.COMPOSITE, OperandFlag.UNINITIALIZED}) protected AMD64AddressValue address;\n        private final OperandSize size;\n\n        public LeaOp(AllocatableValue result, AMD64AddressValue address, OperandSize size) {\n            super(TYPE);\n            this.result = result;\n            this.address = address;\n            this.size = size;\n        }\n\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            if (size == OperandSize.QWORD) {\n                masm.leaq(asRegister(result, AMD64Kind.QWORD), address.toAddress());\n            } else {\n                assert size == OperandSize.DWORD : size;\n                masm.lead(asRegister(result, AMD64Kind.DWORD), address.toAddress());\n            }\n        }\n    }\n\n    public static final class LeaDataOp extends AMD64LIRInstruction {\n        public static final LIRInstructionClass<LeaDataOp> TYPE = LIRInstructionClass.create(LeaDataOp.class);\n\n        @Def({OperandFlag.REG}) protected AllocatableValue result;\n        private final DataPointerConstant data;\n\n        public LeaDataOp(AllocatableValue result, DataPointerConstant data) {\n            super(TYPE);\n            this.result = result;\n            this.data = data;\n        }\n\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            masm.leaq(asRegister(result), (AMD64Address) crb.recordDataReferenceInCode(data));\n        }\n    }\n\n    public static final class StackLeaOp extends AMD64LIRInstruction {\n        public static final LIRInstructionClass<StackLeaOp> TYPE = LIRInstructionClass.create(StackLeaOp.class);\n\n        @Def({OperandFlag.REG}) protected AllocatableValue result;\n        @Use({OperandFlag.STACK, OperandFlag.UNINITIALIZED}) protected AllocatableValue slot;\n\n        public StackLeaOp(AllocatableValue result, AllocatableValue slot) {\n            super(TYPE);\n            this.result = result;\n            this.slot = slot;\n            assert slot instanceof VirtualStackSlot || slot instanceof StackSlot : slot;\n        }\n\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            masm.leaq(asRegister(result, AMD64Kind.QWORD), (AMD64Address) crb.asAddress(slot));\n        }\n    }\n\n    public static final class MembarOp extends AMD64LIRInstruction {\n        public static final LIRInstructionClass<MembarOp> TYPE = LIRInstructionClass.create(MembarOp.class);\n\n        private final int barriers;\n\n        public MembarOp(final int barriers) {\n            super(TYPE);\n            this.barriers = barriers;\n        }\n\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            masm.membar(barriers);\n        }\n    }\n\n    public static final class NullCheckOp extends AMD64LIRInstruction implements StandardOp.NullCheck {\n        public static final LIRInstructionClass<NullCheckOp> TYPE = LIRInstructionClass.create(NullCheckOp.class);\n\n        @Use({OperandFlag.COMPOSITE}) protected AMD64AddressValue address;\n        @State protected LIRFrameState state;\n\n        public NullCheckOp(AMD64AddressValue address, LIRFrameState state) {\n            super(TYPE);\n            this.address = address;\n            this.state = state;\n        }\n\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            crb.recordImplicitException(masm.position(), state);\n            masm.nullCheck(address.toAddress());\n        }\n\n        @Override\n        public Value getCheckedValue() {\n            return address.base;\n        }\n\n        @Override\n        public LIRFrameState getState() {\n            return state;\n        }\n    }\n\n    @Opcode(\"CAS\")\n    public static final class CompareAndSwapOp extends AMD64LIRInstruction {\n        public static final LIRInstructionClass<CompareAndSwapOp> TYPE = LIRInstructionClass.create(CompareAndSwapOp.class);\n\n        private final AMD64Kind accessKind;\n\n        @Def protected AllocatableValue result;\n        @Use({OperandFlag.COMPOSITE}) protected AMD64AddressValue address;\n        @Use protected AllocatableValue cmpValue;\n        @Use protected AllocatableValue newValue;\n\n        public CompareAndSwapOp(AMD64Kind accessKind, AllocatableValue result, AMD64AddressValue address, AllocatableValue cmpValue, AllocatableValue newValue) {\n            super(TYPE);\n            this.accessKind = accessKind;\n            this.result = result;\n            this.address = address;\n            this.cmpValue = cmpValue;\n            this.newValue = newValue;\n        }\n\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            assert asRegister(cmpValue).equals(AMD64.rax) : cmpValue;\n            assert asRegister(result).equals(AMD64.rax) : result;\n\n            if (crb.target.isMP) {\n                masm.lock();\n            }\n            switch (accessKind) {\n                case BYTE:\n                    masm.cmpxchgb(asRegister(newValue), address.toAddress());\n                    break;\n                case WORD:\n                    masm.cmpxchgw(asRegister(newValue), address.toAddress());\n                    break;\n                case DWORD:\n                    masm.cmpxchgl(asRegister(newValue), address.toAddress());\n                    break;\n                case QWORD:\n                    masm.cmpxchgq(asRegister(newValue), address.toAddress());\n                    break;\n                default:\n                    throw GraalError.shouldNotReachHereUnexpectedValue(accessKind); // ExcludeFromJacocoGeneratedReport\n            }\n        }\n    }\n\n    @Opcode(\"ATOMIC_READ_AND_ADD\")\n    public static final class AtomicReadAndAddOp extends AMD64LIRInstruction {\n        public static final LIRInstructionClass<AtomicReadAndAddOp> TYPE = LIRInstructionClass.create(AtomicReadAndAddOp.class);\n\n        private final AMD64Kind accessKind;\n\n        @Def protected AllocatableValue result;\n        @Alive({OperandFlag.COMPOSITE}) protected AMD64AddressValue address;\n        @Use protected AllocatableValue delta;\n\n        public AtomicReadAndAddOp(AMD64Kind accessKind, AllocatableValue result, AMD64AddressValue address, AllocatableValue delta) {\n            super(TYPE);\n            this.accessKind = accessKind;\n            this.result = result;\n            this.address = address;\n            this.delta = delta;\n        }\n\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            move(accessKind, crb, masm, result, delta);\n            if (crb.target.isMP) {\n                masm.lock();\n            }\n            switch (accessKind) {\n                case BYTE:\n                    masm.xaddb(address.toAddress(), asRegister(result));\n                    break;\n                case WORD:\n                    masm.xaddw(address.toAddress(), asRegister(result));\n                    break;\n                case DWORD:\n                    masm.xaddl(address.toAddress(), asRegister(result));\n                    break;\n                case QWORD:\n                    masm.xaddq(address.toAddress(), asRegister(result));\n                    break;\n                default:\n                    throw GraalError.shouldNotReachHereUnexpectedValue(accessKind); // ExcludeFromJacocoGeneratedReport\n            }\n        }\n    }\n\n    @Opcode(\"ATOMIC_READ_AND_WRITE\")\n    public static final class AtomicReadAndWriteOp extends AMD64LIRInstruction {\n        public static final LIRInstructionClass<AtomicReadAndWriteOp> TYPE = LIRInstructionClass.create(AtomicReadAndWriteOp.class);\n\n        private final AMD64Kind accessKind;\n\n        @Def protected AllocatableValue result;\n        @Alive({OperandFlag.COMPOSITE}) protected AMD64AddressValue address;\n        @Use protected AllocatableValue newValue;\n\n        public AtomicReadAndWriteOp(AMD64Kind accessKind, AllocatableValue result, AMD64AddressValue address, AllocatableValue newValue) {\n            super(TYPE);\n            this.accessKind = accessKind;\n            this.result = result;\n            this.address = address;\n            this.newValue = newValue;\n        }\n\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            move(accessKind, crb, masm, result, newValue);\n            switch (accessKind) {\n                case BYTE:\n                    masm.xchgb(asRegister(result), address.toAddress());\n                    break;\n                case WORD:\n                    masm.xchgw(asRegister(result), address.toAddress());\n                    break;\n                case DWORD:\n                    masm.xchgl(asRegister(result), address.toAddress());\n                    break;\n                case QWORD:\n                    masm.xchgq(asRegister(result), address.toAddress());\n                    break;\n                default:\n                    throw GraalError.shouldNotReachHereUnexpectedValue(accessKind); // ExcludeFromJacocoGeneratedReport\n            }\n        }\n    }\n\n    public static void move(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Value input) {\n        move((AMD64Kind) result.getPlatformKind(), crb, masm, result, input);\n    }\n\n    public static void move(AMD64Kind moveKind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Value input) {\n        if (isRegister(input)) {\n            if (isRegister(result)) {\n                reg2reg(moveKind, masm, result, input);\n                return;\n            } else if (isStackSlot(result)) {\n                reg2stack(moveKind, crb, masm, result, asRegister(input));\n                return;\n            }\n        } else if (isStackSlot(input)) {\n            if (isRegister(result)) {\n                stack2reg(moveKind, crb, masm, asRegister(result), input);\n                return;\n            }\n        } else if (LIRValueUtil.isJavaConstant(input)) {\n            if (isRegister(result)) {\n                const2reg(crb, masm, asRegister(result), LIRValueUtil.asJavaConstant(input), moveKind);\n                return;\n            } else if (isStackSlot(result)) {\n                const2stack(crb, masm, result, LIRValueUtil.asJavaConstant(input));\n                return;\n            }\n        }\n        throw GraalError.shouldNotReachHere(\"input=\" + input + \" input.class=\" + input.getClass().getName() + \" \" + \"result=\" + result + \" result.class=\" + result.getClass().getName()); // ExcludeFromJacocoGeneratedReport\n    }\n\n    private static void reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input) {\n        if (asRegister(input).equals(asRegister(result))) {\n            return;\n        }\n        if (!kind.isMask()) {\n            /*\n             * Non-mask moves are only allowed within a category. Mask moves are also allowed\n             * between a mask register and a CPU register (but not between two CPU registers). The\n             * definitions of the kmov[bwdq] instructions check all those constraints on mask moves.\n             */\n            assert asRegister(result).getRegisterCategory().equals(asRegister(input).getRegisterCategory());\n        }\n        switch (kind) {\n            case BYTE:\n            case WORD:\n            case DWORD:\n                masm.movl(asRegister(result), asRegister(input));\n                break;\n            case QWORD:\n                masm.movq(asRegister(result), asRegister(input));\n                break;\n            case SINGLE:\n                masm.movflt(asRegister(result, AMD64Kind.SINGLE), asRegister(input, AMD64Kind.SINGLE));\n                break;\n            case DOUBLE:\n                masm.movdbl(asRegister(result, AMD64Kind.DOUBLE), asRegister(input, AMD64Kind.DOUBLE));\n                break;\n            case MASK8:\n                masm.kmovb(asRegister(result), asRegister(input));\n                break;\n            case MASK16:\n                masm.kmovw(asRegister(result), asRegister(input));\n                break;\n            case MASK32:\n                masm.kmovd(asRegister(result), asRegister(input));\n                break;\n            case MASK64:\n                masm.kmovq(asRegister(result), asRegister(input));\n                break;\n            default:\n                throw GraalError.shouldNotReachHere(\"kind=\" + kind + \" input=\" + input + \" result=\" + result); // ExcludeFromJacocoGeneratedReport\n        }\n    }\n\n    public static void reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input) {\n        AMD64Address dest = (AMD64Address) crb.asAddress(result);\n        switch (kind) {\n            case BYTE:\n                masm.movb(dest, input);\n                break;\n            case WORD:\n                masm.movw(dest, input);\n                break;\n            case DWORD:\n                masm.movl(dest, input);\n                break;\n            case QWORD:\n                masm.movq(dest, input);\n                break;\n            case SINGLE:\n                masm.movflt(dest, input);\n                break;\n            case DOUBLE:\n                masm.movsd(dest, input);\n                break;\n            case V128_QWORD:\n                masm.movdqu(dest, input);\n                break;\n            case V256_QWORD:\n                masm.vmovdqu(dest, input);\n                break;\n            case V512_QWORD:\n                masm.evmovdqu64(dest, input);\n                break;\n            case MASK8:\n                masm.kmovb(dest, input);\n                break;\n            case MASK16:\n                masm.kmovw(dest, input);\n                break;\n            case MASK32:\n                masm.kmovd(dest, input);\n                break;\n            case MASK64:\n                masm.kmovq(dest, input);\n                break;\n            default:\n                throw GraalError.shouldNotReachHere(\"kind=\" + kind + \" input=\" + input + \" result=\" + result); // ExcludeFromJacocoGeneratedReport\n        }\n    }\n\n    public static void stack2reg(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, Value input) {\n        AMD64Address src = (AMD64Address) crb.asAddress(input);\n        /*\n         * Mask moves from memory can't target CPU registers directly. If such a move is needed, use\n         * a general purpose move instead. Note that mask moves have zero extending semantics.\n         */\n        boolean isMaskToCPU = kind.isMask() && !result.getRegisterCategory().equals(AMD64.MASK);\n        switch (kind) {\n            case BYTE:\n                masm.movsbl(result, src);\n                break;\n            case WORD:\n                masm.movswl(result, src);\n                break;\n            case DWORD:\n                masm.movl(result, src);\n                break;\n            case QWORD:\n                masm.movq(result, src);\n                break;\n            case SINGLE:\n                masm.movflt(result, src);\n                break;\n            case DOUBLE:\n                masm.movdbl(result, src);\n                break;\n            case V128_QWORD:\n                masm.movdqu(result, src);\n                break;\n            case V256_QWORD:\n                masm.vmovdqu(result, src);\n                break;\n            case V512_QWORD:\n                masm.evmovdqu64(result, src);\n                break;\n            case MASK8:\n                if (isMaskToCPU) {\n                    masm.movzbl(result, src);\n                } else {\n                    masm.kmovb(result, src);\n                }\n                break;\n            case MASK16:\n                if (isMaskToCPU) {\n                    masm.movzwl(result, src);\n                } else {\n                    masm.kmovw(result, src);\n                }\n                break;\n            case MASK32:\n                if (isMaskToCPU) {\n                    masm.movl(result, src);\n                } else {\n                    masm.kmovd(result, src);\n                }\n                break;\n            case MASK64:\n                if (isMaskToCPU) {\n                    masm.movq(result, src);\n                } else {\n                    masm.kmovq(result, src);\n                }\n                break;\n            default:\n                throw GraalError.shouldNotReachHere(\"kind=\" + kind + \" input=\" + input + \" result=\" + result); // ExcludeFromJacocoGeneratedReport\n        }\n    }\n\n    public static void const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind) {\n        /*\n         * Note: we use the kind of the input operand (and not the kind of the result operand)\n         * because they don't match in all cases. For example, an object constant can be loaded to a\n         * long register when unsafe casts occurred (e.g., for a write barrier where arithmetic\n         * operations are then performed on the pointer).\n         */\n        assert !result.getRegisterCategory().equals(AMD64.MASK) : \"no general const-to-mask moves supported\";\n        switch (input.getJavaKind().getStackKind()) {\n            case Int:\n                // Do not optimize with an XOR as this instruction may be between\n                // a CMP and a Jcc in which case the XOR will modify the condition\n                // flags and interfere with the Jcc.\n                masm.movl(result, input.asInt());\n\n                break;\n            case Long:\n                // Do not optimize with an XOR as this instruction may be between\n                // a CMP and a Jcc in which case the XOR will modify the condition\n                // flags and interfere with the Jcc.\n                if (input.asLong() == (int) input.asLong()) {\n                    // Sign extended to long\n                    boolean finished = false;\n                    int imm = (int) input.asLong();\n                    if (imm == 0) {\n                        Register zeroValueRegister = masm.getZeroValueRegister();\n                        if (!Register.None.equals(zeroValueRegister)) {\n                            masm.movl(result, zeroValueRegister);\n                            finished = true;\n                        }\n                    }\n                    if (!finished) {\n                        masm.movslq(result, imm);\n                    }\n                } else if ((input.asLong() & 0xFFFFFFFFL) == input.asLong()) {\n                    // Zero extended to long\n                    masm.movl(result, (int) input.asLong());\n                } else {\n                    masm.movq(result, input.asLong());\n                }\n                break;\n            case Float:\n                // This is *not* the same as 'constant == 0.0f' in the case where constant is -0.0f\n                if (Float.floatToRawIntBits(input.asFloat()) == Float.floatToRawIntBits(0.0f)) {\n                    masm.xorps(result, result);\n                } else {\n                    masm.movflt(result, (AMD64Address) crb.asFloatConstRef(input));\n                }\n                break;\n            case Double:\n                // This is *not* the same as 'constant == 0.0d' in the case where constant is -0.0d\n                if (Double.doubleToRawLongBits(input.asDouble()) == Double.doubleToRawLongBits(0.0d)) {\n                    masm.xorpd(result, result);\n                } else {\n                    masm.movdbl(result, (AMD64Address) crb.asDoubleConstRef(input));\n                }\n                break;\n            case Object:\n                assert moveKind != null : \"a nun-null moveKind is required for loading an object constant\";\n                // Do not optimize with an XOR as this instruction may be between\n                // a CMP and a Jcc in which case the XOR will modify the condition\n                // flags and interfere with the Jcc.\n                if (input.isNull()) {\n                    if (moveKind == AMD64Kind.QWORD && crb.mustReplaceWithUncompressedNullRegister(input)) {\n                        masm.movq(result, crb.uncompressedNullRegister);\n                    } else {\n                        // Upper bits will be zeroed so this also works for narrow oops\n                        boolean finished = false;\n                        if (0 == 0) {\n                            Register zeroValueRegister = masm.getZeroValueRegister();\n                            if (!Register.None.equals(zeroValueRegister)) {\n                                masm.movl(result, zeroValueRegister);\n                                finished = true;\n                            }\n                        }\n                        if (!finished) {\n                            masm.movslq(result, 0);\n                        }\n                    }\n                } else {\n                    if (crb.target.inlineObjects) {\n                        crb.recordInlineDataInCode(input);\n                        if (moveKind == AMD64Kind.DWORD) {\n                            // Support for narrow oops\n                            masm.movl(result, 0xDEADDEAD, true);\n                        } else {\n                            masm.movq(result, 0xDEADDEADDEADDEADL, true);\n                        }\n                    } else {\n                        if (moveKind == AMD64Kind.DWORD) {\n                            // Support for narrow oops\n                            masm.movl(result, (AMD64Address) crb.recordDataReferenceInCode(input, 0));\n                        } else {\n                            masm.movq(result, (AMD64Address) crb.recordDataReferenceInCode(input, 0));\n                        }\n                    }\n                }\n                break;\n            default:\n                throw GraalError.shouldNotReachHereUnexpectedValue(input.getJavaKind().getStackKind()); // ExcludeFromJacocoGeneratedReport\n        }\n    }\n\n    private void moveIntSignExtend(AMD64MacroAssembler masm, Register result, int imm) {\n        if (imm == 0) {\n            Register zeroValueRegister = masm.getZeroValueRegister();\n            if (!Register.None.equals(zeroValueRegister)) {\n                masm.movl(result, zeroValueRegister);\n                return;\n            }\n        }\n        masm.movslq(result, imm);\n    }\n\n    public static boolean canMoveConst2Stack(JavaConstant input) {\n        switch (input.getJavaKind().getStackKind()) {\n            case Int:\n                break;\n            case Long:\n                break;\n            case Float:\n                break;\n            case Double:\n                break;\n            case Object:\n                if (input.isNull()) {\n                    return true;\n                } else {\n                    return false;\n                }\n            default:\n                return false;\n        }\n        return true;\n    }\n\n    public static void const2stack(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, JavaConstant input) {\n        AMD64Address dest = (AMD64Address) crb.asAddress(result);\n        final long imm;\n        switch (input.getJavaKind().getStackKind()) {\n            case Int:\n                imm = input.asInt();\n                break;\n            case Long:\n                imm = input.asLong();\n                break;\n            case Float:\n                imm = floatToRawIntBits(input.asFloat());\n                break;\n            case Double:\n                imm = doubleToRawLongBits(input.asDouble());\n                break;\n            case Object:\n                if (input.isNull()) {\n                    if (crb.mustReplaceWithUncompressedNullRegister(input)) {\n                        masm.movq(dest, crb.uncompressedNullRegister);\n                        return;\n                    }\n                    imm = 0;\n                } else {\n                    throw GraalError.shouldNotReachHere(\"Non-null object constants must be in a register\"); // ExcludeFromJacocoGeneratedReport\n                }\n                break;\n            default:\n                throw GraalError.shouldNotReachHereUnexpectedValue(input.getJavaKind().getStackKind()); // ExcludeFromJacocoGeneratedReport\n        }\n\n        switch ((AMD64Kind) result.getPlatformKind()) {\n            case BYTE:\n                assert NumUtil.isByte(imm) : \"Is not in byte range: \" + imm;\n                AMD64MIOp.MOVB.emit(masm, OperandSize.BYTE, dest, (int) imm);\n                break;\n            case WORD:\n                assert NumUtil.isShort(imm) : \"Is not in short range: \" + imm;\n                AMD64MIOp.MOV.emit(masm, OperandSize.WORD, dest, (int) imm);\n                break;\n            case DWORD:\n            case SINGLE:\n                assert NumUtil.isInt(imm) : \"Is not in int range: \" + imm;\n                masm.movl(dest, (int) imm);\n                break;\n            case QWORD:\n            case DOUBLE:\n                masm.movlong(dest, imm);\n                break;\n            default:\n                throw GraalError.shouldNotReachHere(\"Unknown result Kind: \" + result.getPlatformKind()); // ExcludeFromJacocoGeneratedReport\n        }\n    }\n\n    public abstract static class PointerCompressionOp extends AMD64LIRInstruction {\n        protected final LIRKindTool lirKindTool;\n        protected final CompressEncoding encoding;\n        protected final boolean nonNull;\n\n        @Def({OperandFlag.REG, OperandFlag.HINT}) private AllocatableValue result;\n        @Use({OperandFlag.REG, OperandFlag.CONST}) private Value input;\n        @Alive({OperandFlag.REG, OperandFlag.ILLEGAL, OperandFlag.UNINITIALIZED}) private AllocatableValue baseRegister;\n\n        protected PointerCompressionOp(LIRInstructionClass<? extends PointerCompressionOp> type,\n                        AllocatableValue result,\n                        Value input,\n                        AllocatableValue baseRegister,\n                        CompressEncoding encoding,\n                        boolean nonNull,\n                        LIRKindTool lirKindTool) {\n\n            super(type);\n            this.result = result;\n            this.input = input;\n            this.baseRegister = baseRegister;\n            this.encoding = encoding;\n            this.nonNull = nonNull;\n            this.lirKindTool = lirKindTool;\n        }\n\n        public static boolean hasBase(CompressEncoding encoding) {\n            return encoding.hasBase();\n        }\n\n        public final Value getInput() {\n            return input;\n        }\n\n        public final AllocatableValue getResult() {\n            return result;\n        }\n\n        protected final Register getResultRegister() {\n            return asRegister(result);\n        }\n\n        protected final Register getBaseRegister() {\n            return hasBase(encoding) ? asRegister(baseRegister) : Register.None;\n        }\n\n        protected final int getShift() {\n            return encoding.getShift();\n        }\n\n        /**\n         * Emits code to move {@linkplain #getInput input} to {@link #getResult result}.\n         */\n        protected final void move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            AMD64Move.move((AMD64Kind) kind.getPlatformKind(), crb, masm, result, input);\n        }\n\n        /**\n         * Emits code to uncompress the compressed oop in {@code inputAndResultReg} by left shifting\n         * it {@code shift} bits, adding it to {@code baseReg} and storing the result back in\n         * {@code inputAndResultReg}.\n         */\n        public static void emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register inputAndResultReg, Register baseReg, int shift, boolean preserveFlagsRegister) {\n            emitUncompressWithBaseRegister(masm, inputAndResultReg, baseReg, inputAndResultReg, shift, preserveFlagsRegister);\n        }\n\n        /**\n         * Emits code to uncompress the compressed oop in {@code inputReg} by left shifting it\n         * {@code shift} bits, adding it to {@code baseReg} and storing the result in\n         * {@code resultReg}.\n         */\n        public static void emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register resultReg, Register baseReg, Register inputReg, int shift, boolean preserveFlagsRegister) {\n            assert !baseReg.equals(Register.None) || shift != 0 : \"compression not enabled\";\n            if (AMD64Address.isScaleShiftSupported(shift)) {\n                Stride stride = Stride.fromLog2(shift);\n                masm.leaq(resultReg, new AMD64Address(baseReg, inputReg, stride));\n            } else {\n                if (preserveFlagsRegister) {\n                    throw GraalError.shouldNotReachHere(\"No valid flag-effect-free instruction available to uncompress oop\"); // ExcludeFromJacocoGeneratedReport\n                }\n                if (!resultReg.equals(inputReg)) {\n                    masm.movq(resultReg, inputReg);\n                }\n                masm.shlq(resultReg, shift);\n                masm.addq(resultReg, baseReg);\n            }\n        }\n    }\n\n    public static class CompressPointerOp extends PointerCompressionOp {\n        public static final LIRInstructionClass<CompressPointerOp> TYPE = LIRInstructionClass.create(CompressPointerOp.class);\n\n        public CompressPointerOp(AllocatableValue result, Value input, AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {\n            this(TYPE, result, input, baseRegister, encoding, nonNull, lirKindTool);\n        }\n\n        private CompressPointerOp(LIRInstructionClass<? extends PointerCompressionOp> type, AllocatableValue result, Value input,\n                        AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {\n\n            super(type, result, input, baseRegister, encoding, nonNull, lirKindTool);\n        }\n\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            move(lirKindTool.getObjectKind(), crb, masm);\n\n            final Register resReg = getResultRegister();\n            final Register baseReg = getBaseRegister();\n            if (!baseReg.equals(Register.None)) {\n                if (!nonNull) {\n                    masm.testq(resReg, resReg);\n                    masm.cmovq(Equal, resReg, baseReg);\n                }\n                masm.subq(resReg, baseReg);\n            }\n\n            int shift = getShift();\n            if (shift != 0) {\n                masm.shrq(resReg, shift);\n            }\n        }\n    }\n\n    public static class UncompressPointerOp extends PointerCompressionOp {\n        public static final LIRInstructionClass<UncompressPointerOp> TYPE = LIRInstructionClass.create(UncompressPointerOp.class);\n\n        public UncompressPointerOp(AllocatableValue result, Value input, AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {\n            this(TYPE, result, input, baseRegister, encoding, nonNull, lirKindTool);\n        }\n\n        private UncompressPointerOp(LIRInstructionClass<? extends PointerCompressionOp> type, AllocatableValue result, Value input,\n                        AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {\n            super(type, result, input, baseRegister, encoding, nonNull, lirKindTool);\n        }\n\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            Register baseReg = getBaseRegister();\n            int shift = getShift();\n            Register resReg = getResultRegister();\n            if (nonNull && !baseReg.equals(Register.None) && getInput() instanceof RegisterValue) {\n                Register inputReg = ((RegisterValue) getInput()).getRegister();\n                if (!inputReg.equals(resReg)) {\n                    emitUncompressWithBaseRegister(masm, resReg, baseReg, inputReg, shift, false);\n                    return;\n                }\n            }\n            move(lirKindTool.getNarrowOopKind(), crb, masm);\n            emitUncompressCode(masm, resReg, shift, baseReg, nonNull);\n        }\n\n        public static void emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull) {\n            if (nonNull) {\n                if (!baseReg.equals(Register.None)) {\n                    emitUncompressWithBaseRegister(masm, resReg, baseReg, shift, false);\n                } else if (shift != 0) {\n                    masm.shlq(resReg, shift);\n                }\n            } else {\n                if (shift != 0) {\n                    masm.shlq(resReg, shift);\n                }\n\n                if (!baseReg.equals(Register.None)) {\n                    if (shift == 0) {\n                        // if encoding.shift != 0, the flags are already set by the shlq\n                        masm.testq(resReg, resReg);\n                    }\n\n                    Label done = new Label();\n                    masm.jccb(Equal, done);\n                    masm.addq(resReg, baseReg);\n                    masm.bind(done);\n                }\n            }\n        }\n    }\n\n    private abstract static class ZeroNullConversionOp extends AMD64LIRInstruction {\n        @Def({OperandFlag.REG, OperandFlag.HINT}) protected AllocatableValue result;\n        @Use({OperandFlag.REG}) protected AllocatableValue input;\n\n        protected ZeroNullConversionOp(LIRInstructionClass<? extends ZeroNullConversionOp> type, AllocatableValue result, AllocatableValue input) {\n            super(type);\n            this.result = result;\n            this.input = input;\n        }\n\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            Register nullRegister = crb.uncompressedNullRegister;\n            if (!nullRegister.equals(Register.None)) {\n                emitConversion(asRegister(result), asRegister(input), nullRegister, masm);\n            }\n        }\n\n        protected abstract void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AMD64MacroAssembler masm);\n    }\n\n    public static class ConvertNullToZeroOp extends ZeroNullConversionOp {\n        public static final LIRInstructionClass<ConvertNullToZeroOp> TYPE = LIRInstructionClass.create(ConvertNullToZeroOp.class);\n\n        public ConvertNullToZeroOp(AllocatableValue result, AllocatableValue input) {\n            super(TYPE, result, input);\n        }\n\n        @Override\n        protected final void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AMD64MacroAssembler masm) {\n            if (inputRegister.equals(resultRegister)) {\n                Label done = new Label();\n                masm.subqAndJcc(inputRegister, nullRegister, Equal, done, true);\n                masm.addq(inputRegister, nullRegister);\n                masm.bind(done);\n            } else {\n                masm.subq(resultRegister, resultRegister);\n                masm.cmpq(inputRegister, nullRegister);\n                masm.cmovq(NotEqual, resultRegister, inputRegister);\n            }\n        }\n    }\n\n    public static class ConvertZeroToNullOp extends ZeroNullConversionOp {\n        public static final LIRInstructionClass<ConvertZeroToNullOp> TYPE = LIRInstructionClass.create(ConvertZeroToNullOp.class);\n\n        public ConvertZeroToNullOp(AllocatableValue result, AllocatableValue input) {\n            super(TYPE, result, input);\n        }\n\n        @Override\n        protected final void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AMD64MacroAssembler masm) {\n            if (!inputRegister.equals(resultRegister)) {\n                masm.movq(resultRegister, inputRegister);\n            }\n            masm.testq(inputRegister, inputRegister);\n            masm.cmovq(Equal, resultRegister, nullRegister);\n        }\n    }\n}",
                "methodCount": 71
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 5,
                "candidates": [
                    {
                        "lineStart": 923,
                        "lineEnd": 928,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method move to class LIRKindTool",
                        "description": "Move method move to jdk.graal.compiler.core.common.spi.LIRKindTool\nRationale: The move method interacts directly with the LIRKind and could encapsulate the functionality of generating or dealing with specific LIR kinds. The method seems closely tied to the operations and behaviors expected from LIRKindTool, making it a logical fit within this interface. In particular, the method call `kind.getPlatformKind()` and the overall purpose of moving LIR kinds align well with the methods outlined in the LIRKindTool interface such as getting platform-specific kinds. By moving the method to this interface, we centralize LIR kind-related operations and enhance cohesion.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 899,
                        "lineEnd": 901,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method hasBase to class HotSpotReplacementsUtil",
                        "description": "move method hasBase to PsiClass:HotSpotReplacementsUtil\nRationale: The method hasBase() directly interacts with encoding-related logic. Among the provided classes, HotSpotReplacementsUtil is the most directly involved with low-level and runtime optimizations, focusing heavily on memory and location identity adjustments, interactions which may include encoding optimizations. This context makes it suitable for placing methods related to encoding verifications.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 939,
                        "lineEnd": 959,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method emitUncompressWithBaseRegister to class GraphUtil",
                        "description": "move method emitUncompressWithBaseRegister to PsiClass:GraphUtil\nRationale: The method emitUncompressWithBaseRegister relates to machine-level code emission, typically part of a lower-level utility focusing on graph manipulations within compiled code. GraphUtil already contains extensive code related to node processing and code transformations, making it a more appropriate choice. CollectionsUtil and InliningUtil focus on broader utilities and specific optimization processes, which do not align with the machine-level specifics of the emitUncompressWithBaseRegister method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 786,
                        "lineEnd": 795,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method moveIntSignExtend to class AMD64MacroAssembler",
                        "description": "Move method moveIntSignExtend to jdk.graal.compiler.asm.amd64.AMD64MacroAssembler\nRationale: The 'moveIntSignExtend' method should be moved to the 'AMD64MacroAssembler' class because this class contains numerous methods that directly manipulate registers and perform various assembly-level operations. The 'moveIntSignExtend' method fits well in this context because it primarily relies on operations relevant to macro assembly, such as 'movl' and 'movslq', which are already well-integrated within the 'AMD64MacroAssembler' class. Moreover, this class is equipped to handle the intricacies of working with the AMD64 architecture and the associated registers.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1024,
                        "lineEnd": 1048,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method emitUncompressCode to class GraphUtil",
                        "description": "move method emitUncompressCode to PsiClass:GraphUtil\nRationale: The method emitUncompressCode(AMD64MacroAssembler, Register, int, Register, boolean) is heavily focused on manipulating registers and low-level assembly code, which is more aligned with the broader functionality in the GraphUtil class. The GraphUtil class contains methods dealing with various graph operations for nodes, paths, reading values, and general low-level operations, which makes it a fitting home for the emitUncompressCode method. Additionally, methods within GraphUtil handle the structured graphs and nodes that are more related to the type of operations occurring within emitUncompressCode. FileUtils primarily focuses on filesystem operations and VirtualUtil is more catered towards utility functions linked to node structures and virtual graphs, which are less related to the emitUncompressCode method's functionality.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "move",
                            "method_signature": "public static void move(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Value input)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "The `move` method is focused on moving values and interacts directly with `AMD64MacroAssembler` and its instructions. It involves low-level operations suitable for assembler-level instructions, making `AMD64MacroAssembler` a more appropriate home for it."
                        },
                        {
                            "method_name": "move",
                            "method_signature": "public static void move(AMD64Kind moveKind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Value input)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "Similar to the above method, this `move` variant is deeply tied to the assembler-level operations. It manipulates different kinds of values directly and interacts with `AMD64MacroAssembler`, making it fit better in the `AMD64MacroAssembler` class."
                        },
                        {
                            "method_name": "reg2reg",
                            "method_signature": "public static void reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "The `reg2reg` method deals with low-level register-to-register move operations, primarily involving assembler operations. This aligns well with the responsibilities of `AMD64MacroAssembler` and should be moved there."
                        },
                        {
                            "method_name": "reg2stack",
                            "method_signature": "public static void reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "The `reg2stack` method is centered on moving data from registers to stack memory slots. These operations are closely tied to `AMD64MacroAssembler` functionalities and will find a better place there."
                        },
                        {
                            "method_name": "stack2reg",
                            "method_signature": "public static void stack2reg(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, Value input)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "The `stack2reg` method handles stack-to-register data moving, which involves assembler-level operations. Thus, it should be situated in the `AMD64MacroAssembler` class, where such operations are handled."
                        },
                        {
                            "method_name": "const2reg",
                            "method_signature": "public static void const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "The `const2reg` method focuses on moving constants to registers, which aligns well with the functionality provided by `AMD64MacroAssembler`. This move will improve cohesion within that class."
                        },
                        {
                            "method_name": "canMoveConst2Stack",
                            "method_signature": "public static boolean canMoveConst2Stack(JavaConstant input)",
                            "target_class": "AMD64Kind",
                            "rationale": "The `canMoveConst2Stack` method determines if a constant can be moved to the stack, based on the kind of constant. Since it deals purely with constants and their kinds, it would be more relevant to be within the `AMD64Kind` class."
                        },
                        {
                            "method_name": "const2stack",
                            "method_signature": "public static void const2stack(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, JavaConstant input)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "The `const2stack` method handles moving constants to the stack. Given its assembler-specific logic, it fits better within the `AMD64MacroAssembler` class."
                        },
                        {
                            "method_name": "emitUncompressWithBaseRegister",
                            "method_signature": "public static void emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register resultReg, Register baseReg, Register inputReg, int shift, boolean preserveFlagsRegister)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "The `emitUncompressWithBaseRegister` method involves specific operations related to decompression using base registers, entailing multiple assembler-level instructions. These make it highly appropriate for relocation to `AMD64MacroAssembler`."
                        }
                    ],
                    "llm_response_time": 11463
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "move",
                            "method_signature": "public static void move(AMD64Kind moveKind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Value input)",
                            "target_class": "AMD64MoveUtils",
                            "rationale": "The move method is a utility function that performs a value move operation based on the type of the values involved. It does not directly depend on the state of the AMD64Move class, making it more suitable to be placed in a utility class for better cohesion and reusability."
                        },
                        {
                            "method_name": "move",
                            "method_signature": "public static void move(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Value input)",
                            "target_class": "AMD64MoveUtils",
                            "rationale": "Similar to the previous move method, this version is also a utility function relying only on its parameters. Moving it to a utility class enhances modularity and maintains the Single Responsibility Principle."
                        },
                        {
                            "method_name": "reg2reg",
                            "method_signature": "public static void reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input)",
                            "target_class": "AMD64MoveUtils",
                            "rationale": "The reg2reg method deals specifically with register-to-register moves, and it operates solely based on its parameters. This makes it a good candidate for a utility class that handles move operations."
                        },
                        {
                            "method_name": "reg2stack",
                            "method_signature": "public static void reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input)",
                            "target_class": "AMD64MoveUtils",
                            "rationale": "The reg2stack method performs register-to-stack moves and does not depend on the state of the AMD64Move class, fitting well in a utility class for better organization."
                        },
                        {
                            "method_name": "stack2reg",
                            "method_signature": "public static void stack2reg(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, Value input)",
                            "target_class": "AMD64MoveUtils",
                            "rationale": "The stack2reg method handles stack-to-register moves and relies only on its parameters, making it suitable for a utility class to improve code organization."
                        },
                        {
                            "method_name": "const2reg",
                            "method_signature": "public static void const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind)",
                            "target_class": "AMD64MoveUtils",
                            "rationale": "The const2reg method is responsible for moving constants to registers and operates entirely based on its input parameters, warranting a relocation to a utility class for better modularity."
                        },
                        {
                            "method_name": "const2stack",
                            "method_signature": "public static void const2stack(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, JavaConstant input)",
                            "target_class": "AMD64MoveUtils",
                            "rationale": "Similar to the const2reg method, const2stack deals with moving constants to the stack and only uses its parameters, making it suitable to be placed in a utility class."
                        },
                        {
                            "method_name": "canMoveConst2Stack",
                            "method_signature": "public static boolean canMoveConst2Stack(JavaConstant input)",
                            "target_class": "AMD64MoveUtils",
                            "rationale": "The canMoveConst2Stack method determines if a constant can be moved to the stack and only depends on its input parameter. It fits well in a utility class dedicated to move operations."
                        }
                    ],
                    "llm_response_time": 9407
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "move",
                            "method_signature": "public static void move(AMD64Kind moveKind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Value input)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "The method 'move' performs low-level assembly movements and it fits better in a class directly related to assembly operations, such as AMD64MacroAssembler."
                        },
                        {
                            "method_name": "reg2reg",
                            "method_signature": "private static void reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "The method 'reg2reg' deals specifically with register-to-register movements, aligning closely with operations in an assembler class."
                        },
                        {
                            "method_name": "reg2stack",
                            "method_signature": "public static void reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "This method deals with moving data from a register to the stack, which is a low-level operation more appropriate for an assembler-specific class."
                        },
                        {
                            "method_name": "stack2reg",
                            "method_signature": "public static void stack2reg(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, Value input)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "This method involves moving data from the stack to a register, fitting the responsibilities of an assembler class."
                        },
                        {
                            "method_name": "const2reg",
                            "method_signature": "public static void const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "Since 'const2reg' involves moving a constant to a register, this operation is more suitable for an assembler class."
                        },
                        {
                            "method_name": "const2stack",
                            "method_signature": "public static void const2stack(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, JavaConstant input)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "This method deals with moving constants to the stack, an operation that is more appropriate for the assembler class."
                        },
                        {
                            "method_name": "emitUncompressWithBaseRegister",
                            "method_signature": "public static void emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register resultReg, Register baseReg, Register inputReg, int shift, boolean preserveFlagsRegister)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "The method performs the uncompression involving registers and base registers, which is better suited in an assembler class focusing on low-level operations."
                        },
                        {
                            "method_name": "emitUncompressCode",
                            "method_signature": "public static void emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull)",
                            "target_class": "AMD64MacroAssembler",
                            "rationale": "This method directly deals with uncompressing pointers using low-level assembly instructions, well-aligned with the responsibilities of an assembler class."
                        }
                    ],
                    "llm_response_time": 9266
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "reg2reg",
                            "method_signature": "private static reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "reg2stack",
                            "method_signature": "public static reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "stack2reg",
                            "method_signature": "public static stack2reg(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, Value input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "const2reg",
                            "method_signature": "public static const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "moveIntSignExtend",
                            "method_signature": "private moveIntSignExtend(AMD64MacroAssembler masm, Register result, int imm)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "const2stack",
                            "method_signature": "public static const2stack(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, JavaConstant input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "hasBase",
                            "method_signature": "public static hasBase(CompressEncoding encoding)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "move",
                            "method_signature": "protected final move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "emitUncompressWithBaseRegister",
                            "method_signature": "public static emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register resultReg, Register baseReg, Register inputReg, int shift, boolean preserveFlagsRegister)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "emitUncompressCode",
                            "method_signature": "public static emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "move",
                            "method_signature": "protected final move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "reg2stack",
                            "method_signature": "public static reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "reg2reg",
                            "method_signature": "private static reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "hasBase",
                            "method_signature": "public static hasBase(CompressEncoding encoding)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "emitUncompressWithBaseRegister",
                            "method_signature": "public static emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register resultReg, Register baseReg, Register inputReg, int shift, boolean preserveFlagsRegister)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "stack2reg",
                            "method_signature": "public static stack2reg(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, Value input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "const2stack",
                            "method_signature": "public static const2stack(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, JavaConstant input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "const2reg",
                            "method_signature": "public static const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "moveIntSignExtend",
                            "method_signature": "private moveIntSignExtend(AMD64MacroAssembler masm, Register result, int imm)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "emitUncompressCode",
                            "method_signature": "public static emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "protected final move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm)": {
                        "first": {
                            "method_name": "move",
                            "method_signature": "protected final move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3365189459137526
                    },
                    "public static reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input)": {
                        "first": {
                            "method_name": "reg2stack",
                            "method_signature": "public static reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.35186502742930487
                    },
                    "private static reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input)": {
                        "first": {
                            "method_name": "reg2reg",
                            "method_signature": "private static reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.48292139499302894
                    },
                    "public static hasBase(CompressEncoding encoding)": {
                        "first": {
                            "method_name": "hasBase",
                            "method_signature": "public static hasBase(CompressEncoding encoding)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4916958466571498
                    },
                    "public static emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register resultReg, Register baseReg, Register inputReg, int shift, boolean preserveFlagsRegister)": {
                        "first": {
                            "method_name": "emitUncompressWithBaseRegister",
                            "method_signature": "public static emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register resultReg, Register baseReg, Register inputReg, int shift, boolean preserveFlagsRegister)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5345581226846242
                    },
                    "public static stack2reg(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, Value input)": {
                        "first": {
                            "method_name": "stack2reg",
                            "method_signature": "public static stack2reg(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, Value input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.562007067509276
                    },
                    "public static const2stack(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, JavaConstant input)": {
                        "first": {
                            "method_name": "const2stack",
                            "method_signature": "public static const2stack(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, JavaConstant input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5877420801688553
                    },
                    "public static const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind)": {
                        "first": {
                            "method_name": "const2reg",
                            "method_signature": "public static const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6155434887035524
                    },
                    "private moveIntSignExtend(AMD64MacroAssembler masm, Register result, int imm)": {
                        "first": {
                            "method_name": "moveIntSignExtend",
                            "method_signature": "private moveIntSignExtend(AMD64MacroAssembler masm, Register result, int imm)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6351960485087619
                    },
                    "public static emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull)": {
                        "first": {
                            "method_name": "emitUncompressCode",
                            "method_signature": "public static emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6405428698267728
                    }
                },
                "voyage": {
                    "public static hasBase(CompressEncoding encoding)": {
                        "first": {
                            "method_name": "hasBase",
                            "method_signature": "public static hasBase(CompressEncoding encoding)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.18430917093809338
                    },
                    "public static emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull)": {
                        "first": {
                            "method_name": "emitUncompressCode",
                            "method_signature": "public static emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5548060236989564
                    },
                    "private moveIntSignExtend(AMD64MacroAssembler masm, Register result, int imm)": {
                        "first": {
                            "method_name": "moveIntSignExtend",
                            "method_signature": "private moveIntSignExtend(AMD64MacroAssembler masm, Register result, int imm)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5961467936461915
                    },
                    "public static emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register resultReg, Register baseReg, Register inputReg, int shift, boolean preserveFlagsRegister)": {
                        "first": {
                            "method_name": "emitUncompressWithBaseRegister",
                            "method_signature": "public static emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register resultReg, Register baseReg, Register inputReg, int shift, boolean preserveFlagsRegister)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6415644321980268
                    },
                    "protected final move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm)": {
                        "first": {
                            "method_name": "move",
                            "method_signature": "protected final move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6469743375705268
                    },
                    "public static const2stack(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, JavaConstant input)": {
                        "first": {
                            "method_name": "const2stack",
                            "method_signature": "public static const2stack(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, JavaConstant input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6865982511711871
                    },
                    "private static reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input)": {
                        "first": {
                            "method_name": "reg2reg",
                            "method_signature": "private static reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7112000216522648
                    },
                    "public static reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input)": {
                        "first": {
                            "method_name": "reg2stack",
                            "method_signature": "public static reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7169654774961439
                    },
                    "public static stack2reg(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, Value input)": {
                        "first": {
                            "method_name": "stack2reg",
                            "method_signature": "public static stack2reg(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, Value input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7385180301245613
                    },
                    "public static const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind)": {
                        "first": {
                            "method_name": "const2reg",
                            "method_signature": "public static const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7475162045974787
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "protected final move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm)",
                        "private static reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input)",
                        "public static reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input)",
                        "public static stack2reg(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, Value input)",
                        "public static const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind)",
                        "public static const2stack(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, JavaConstant input)",
                        "public static emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register resultReg, Register baseReg, Register inputReg, int shift, boolean preserveFlagsRegister)",
                        "public static emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull)",
                        "public static hasBase(CompressEncoding encoding)",
                        "private moveIntSignExtend(AMD64MacroAssembler masm, Register result, int imm)"
                    ],
                    "llm_response_time": 4861
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "protected final move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm)",
                        "public static reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input)",
                        "private static reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input)",
                        "public static emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register resultReg, Register baseReg, Register inputReg, int shift, boolean preserveFlagsRegister)",
                        "public static hasBase(CompressEncoding encoding)"
                    ],
                    "llm_response_time": 5944
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private static reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input)",
                        "public static reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input)",
                        "protected final move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm)"
                    ],
                    "llm_response_time": 5194
                },
                "voyage": {
                    "priority_method_names": [
                        "public static const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind)",
                        "public static stack2reg(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, Value input)",
                        "public static reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input)",
                        "private static reg2reg(AMD64Kind kind, AMD64MacroAssembler masm, Value result, Value input)",
                        "public static const2stack(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, JavaConstant input)",
                        "public static emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register resultReg, Register baseReg, Register inputReg, int shift, boolean preserveFlagsRegister)",
                        "public static emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull)",
                        "protected final move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm)",
                        "public static hasBase(CompressEncoding encoding)",
                        "private moveIntSignExtend(AMD64MacroAssembler masm, Register result, int imm)"
                    ],
                    "llm_response_time": 3846
                },
                "voyage-5": {
                    "priority_method_names": [
                        "protected final move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm)",
                        "public static emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register resultReg, Register baseReg, Register inputReg, int shift, boolean preserveFlagsRegister)",
                        "public static emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull)",
                        "private moveIntSignExtend(AMD64MacroAssembler masm, Register result, int imm)",
                        "public static hasBase(CompressEncoding encoding)"
                    ],
                    "llm_response_time": 5473
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public static emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull)",
                        "public static hasBase(CompressEncoding encoding)",
                        "private moveIntSignExtend(AMD64MacroAssembler masm, Register result, int imm)"
                    ],
                    "llm_response_time": 3776
                }
            },
            "targetClassMap": {
                "move": {
                    "target_classes": [
                        {
                            "class_name": "LIRKindTool",
                            "similarity_score": 0.25037480058850287
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "LIRKindTool"
                    ],
                    "llm_response_time": 3171,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "reg2stack": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4318,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "reg2reg": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2631,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "hasBase": {
                    "target_classes": [
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.320679878949858
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.6039633668465983
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.2537447437381125
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.5088377290670487
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.3314380440072565
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.4280641887460458
                        },
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.46199355191104263
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.3389298314738677
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.47909733383241476
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.6309814116871441
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.29967430845896653
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.2183106187024373
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.48827892505343207
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.5932533817052542
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.2843702269802164
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.426014322842305
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.3781141322797959
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.295797592217399
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.5618920594516136
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.60811828548933
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.19360754046727016
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.31305680826550364
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.3090977212369663
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.44946657497549475
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.5089865985592876
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.3137164414475283
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.32219930873259794
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.5375872022286245
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.4919340740301557
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.3332041379389101
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.47177323771935575
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.3373495424699933
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.5202659817144719
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.3044713810352108
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.5172935265326569
                        },
                        {
                            "class_name": "GlobUtils",
                            "similarity_score": 0.3928371006591931
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.46525042788159493
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.4689766702080085
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.3075795186313125
                        },
                        {
                            "class_name": "ArrayUtil",
                            "similarity_score": 0.31750031750047625
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.45580509496975774
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.5899936045039905
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.5159684955941697
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.5773845282176453
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.43965772767239164
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.3592106040535498
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.4587727063914838
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.4743416490252569
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.5393308788692646
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.4304926610840718
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.4541796195437749
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.34653584413003674
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.4406533039975109
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.4797390928809167
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.4450495313120098
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.536774032210737
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.5333333333333333
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.4368658089342457
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.3826293621223676
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.6128938256886679
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.5107082318038357
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.5509847814510679
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.3246205779715083
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.5462522410478494
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.3880752628531664
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.3732419383342079
                        },
                        {
                            "class_name": "MissingJNIRegistrationUtils",
                            "similarity_score": 0.25931372673457387
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.3600180013501125
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.4781997747616619
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.388850360242746
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.3840122885898554
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.44940353176388287
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.3565202904017712
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.4547710167731553
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.6104913953275068
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.2551639406200618
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.4400197238426775
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.5605686157400976
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.24489169769281907
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.31215881314245886
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.24633537007722536
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.47573936622140944
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.6313358105322217
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.437658634593183
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.48666426339228763
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.22808577638091168
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.4465164577487581
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.5465943944999485
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.412264884772609
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.2253744679276044
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.4841548820830999
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.30638167667268595
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.46028730894916164
                        },
                        {
                            "class_name": "Target_java_util_concurrent_locks_AbstractOwnableSynchronizer",
                            "similarity_score": 0.31189143077590264
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.3703148146160889
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.36620480644702175
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.5345342355750909
                        },
                        {
                            "class_name": "AMD64VectorMove",
                            "similarity_score": 0.5136273851532674
                        },
                        {
                            "class_name": "CInterfaceLocationIdentityBuiltIn",
                            "similarity_score": 0.423999152002544
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.3305381464740952
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HotSpotReplacementsUtil",
                        "NativeUtils",
                        "NativeImageResourceFileSystemUtil"
                    ],
                    "llm_response_time": 4212,
                    "similarity_computation_time": 60,
                    "similarity_metric": "cosine"
                },
                "emitUncompressWithBaseRegister": {
                    "target_classes": [
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.47567084666473863
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.5223790521296431
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.44924164031931385
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.5120879935110896
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.6148897968665739
                        },
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.621280052347591
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.5247104704636192
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.3210483730327423
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.4858068769667717
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.49442467243987415
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.4751375070463224
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.5677078184350168
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.476943760464212
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.4155548896238311
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.3400651667569976
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.5110881014272701
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.5630102630961149
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.39447686730980236
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.5659112125500639
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.537747638383584
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.43710238597121276
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.5498848852737958
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.4744425084031829
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.47091041701314257
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.38033541954541317
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.5816421934812214
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.4510703612139926
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.5368328172571145
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.5301323549640481
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.5366443484989923
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.5198077993431504
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.5252477200941617
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.41518467482142096
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.4227315498533755
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.39073704533418796
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.5357371650058166
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.4510603269081621
                        },
                        {
                            "class_name": "GlobUtils",
                            "similarity_score": 0.4616902584383194
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.3962695549772586
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.30428404880084603
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.5358850929666541
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.5394997854190683
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.41732568908983325
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.4414428557263045
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.5358486809606596
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.3972100041395162
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.4804789674900865
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.30971124072525835
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.4706043051928251
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.40632065678486523
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.4296985116682685
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.34085847647897544
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.5696178844564495
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.5150981908389506
                        },
                        {
                            "class_name": "ArrayUtil",
                            "similarity_score": 0.37775586118833315
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.4983247140256549
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.5070947333129553
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.49538117088992384
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.5107828227827365
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.5272543261220076
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.312769442168126
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.32846070591659865
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.41062054459583824
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.4594612448554004
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.26690990235211487
                        },
                        {
                            "class_name": "MissingJNIRegistrationUtils",
                            "similarity_score": 0.2387752443239954
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.41680694655656425
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.5459765183961328
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.40564279103993794
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.4248524875615562
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.3447786167168204
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.33371907505060533
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.3809512291741397
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.5049025893555563
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.576838439150155
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.5030489666162677
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.43338696820591643
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.42342483210551785
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.4238290165511274
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.44263380106761196
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.3867804967684679
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.5053800738884603
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.47915848114131554
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.4554297618102969
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.32167995465786453
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.4247084219641198
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.4575611330992139
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.3352576036702426
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.3249638499270319
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.5466217138324966
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.4391876776908752
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.3810387941055741
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.3472846113044529
                        },
                        {
                            "class_name": "Target_java_util_concurrent_locks_AbstractOwnableSynchronizer",
                            "similarity_score": 0.46159044430712626
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.5188392021748129
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.3010959417205744
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.448341854986507
                        },
                        {
                            "class_name": "CInterfaceLocationIdentityBuiltIn",
                            "similarity_score": 0.33836144632909354
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.5199661341940115
                        },
                        {
                            "class_name": "StackElement",
                            "similarity_score": 0.3442049442890272
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "GraphUtil",
                        "InliningUtil",
                        "CollectionsUtil"
                    ],
                    "llm_response_time": 6451,
                    "similarity_computation_time": 59,
                    "similarity_metric": "cosine"
                },
                "stack2reg": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3538,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "const2stack": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3496,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "const2reg": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2759,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "moveIntSignExtend": {
                    "target_classes": [
                        {
                            "class_name": "AMD64MacroAssembler",
                            "similarity_score": 0.6469601937213161
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "AMD64MacroAssembler"
                    ],
                    "llm_response_time": 3369,
                    "similarity_computation_time": 6,
                    "similarity_metric": "cosine"
                },
                "emitUncompressCode": {
                    "target_classes": [
                        {
                            "class_name": "SSAUtil",
                            "similarity_score": 0.3753291614385915
                        },
                        {
                            "class_name": "LIRValueUtil",
                            "similarity_score": 0.6131023196684436
                        },
                        {
                            "class_name": "HotSpotReplacementsUtil",
                            "similarity_score": 0.48446727539875234
                        },
                        {
                            "class_name": "ReinterpretUtils",
                            "similarity_score": 0.6190653010745412
                        },
                        {
                            "class_name": "InliningUtil",
                            "similarity_score": 0.6615229999401774
                        },
                        {
                            "class_name": "GraphUtil",
                            "similarity_score": 0.7011761904634739
                        },
                        {
                            "class_name": "Util",
                            "similarity_score": 0.38412620641841283
                        },
                        {
                            "class_name": "ValueMergeUtil",
                            "similarity_score": 0.6018653709443041
                        },
                        {
                            "class_name": "Escape",
                            "similarity_score": 0.40861876706488043
                        },
                        {
                            "class_name": "BridgeMethodUtils",
                            "similarity_score": 0.5016000880819121
                        },
                        {
                            "class_name": "BasicBlockOrderUtils",
                            "similarity_score": 0.3876789533209896
                        },
                        {
                            "class_name": "ConditionalEliminationUtil",
                            "similarity_score": 0.6772515037202076
                        },
                        {
                            "class_name": "PatcherUtil",
                            "similarity_score": 0.2430791461117111
                        },
                        {
                            "class_name": "PathUtilities",
                            "similarity_score": 0.42184611195180394
                        },
                        {
                            "class_name": "ConstantFoldUtil",
                            "similarity_score": 0.6309079070885428
                        },
                        {
                            "class_name": "TypeCheckSnippetUtils",
                            "similarity_score": 0.42166629255727406
                        },
                        {
                            "class_name": "LoopUtility",
                            "similarity_score": 0.6093514620808401
                        },
                        {
                            "class_name": "StubUtil",
                            "similarity_score": 0.2679000934560462
                        },
                        {
                            "class_name": "StrideUtil",
                            "similarity_score": 0.24923905362991639
                        },
                        {
                            "class_name": "NodeCostUtil",
                            "similarity_score": 0.5070725267844602
                        },
                        {
                            "class_name": "NodeStrideUtil",
                            "similarity_score": 0.37753180950705034
                        },
                        {
                            "class_name": "CSVUtil",
                            "similarity_score": 0.4124832444093471
                        },
                        {
                            "class_name": "MathUtil",
                            "similarity_score": 0.5878877853119692
                        },
                        {
                            "class_name": "NumUtil",
                            "similarity_score": 0.5264537389331495
                        },
                        {
                            "class_name": "OptimizationUtility",
                            "similarity_score": 0.37890482494525435
                        },
                        {
                            "class_name": "CollectionsUtil",
                            "similarity_score": 0.36369717819949693
                        },
                        {
                            "class_name": "LambdaUtils",
                            "similarity_score": 0.3446825562007916
                        },
                        {
                            "class_name": "ReplacementsUtil",
                            "similarity_score": 0.5320635066339123
                        },
                        {
                            "class_name": "VirtualUtil",
                            "similarity_score": 0.7024163800409603
                        },
                        {
                            "class_name": "ConstantReflectionUtil",
                            "similarity_score": 0.4432369437560278
                        },
                        {
                            "class_name": "SignatureUtil",
                            "similarity_score": 0.5899766779007851
                        },
                        {
                            "class_name": "IsolateUtil",
                            "similarity_score": 0.4264079406199325
                        },
                        {
                            "class_name": "OopHandleLocationIdentity",
                            "similarity_score": 0.3935991205557027
                        },
                        {
                            "class_name": "JDKUtils",
                            "similarity_score": 0.3030997197024864
                        },
                        {
                            "class_name": "RecordUtils",
                            "similarity_score": 0.48067031949555206
                        },
                        {
                            "class_name": "FileUtils",
                            "similarity_score": 0.6872970527629854
                        },
                        {
                            "class_name": "InliningUtilities",
                            "similarity_score": 0.5964426533617507
                        },
                        {
                            "class_name": "GlobUtils",
                            "similarity_score": 0.5634813151393688
                        },
                        {
                            "class_name": "ClasspathUtils",
                            "similarity_score": 0.5109076673806026
                        },
                        {
                            "class_name": "Integer",
                            "similarity_score": 0.39600371636000736
                        },
                        {
                            "class_name": "IdentityHashCodeUtil",
                            "similarity_score": 0.544659285354403
                        },
                        {
                            "class_name": "ResourcesUtils",
                            "similarity_score": 0.6564094280166357
                        },
                        {
                            "class_name": "JavaSpinLockUtils",
                            "similarity_score": 0.48755402749411936
                        },
                        {
                            "class_name": "InteropUtils",
                            "similarity_score": 0.545261730402182
                        },
                        {
                            "class_name": "CodeUtil",
                            "similarity_score": 0.5944056669546822
                        },
                        {
                            "class_name": "JDKArgsUtils",
                            "similarity_score": 0.5781215368125281
                        },
                        {
                            "class_name": "TimeUtils",
                            "similarity_score": 0.40201094938824544
                        },
                        {
                            "class_name": "OutOfMemoryUtil",
                            "similarity_score": 0.5683946778599337
                        },
                        {
                            "class_name": "CompressionUtils",
                            "similarity_score": 0.40663580177654074
                        },
                        {
                            "class_name": "BundleSerializationUtils",
                            "similarity_score": 0.523128730162019
                        },
                        {
                            "class_name": "Byte",
                            "similarity_score": 0.37321001364608947
                        },
                        {
                            "class_name": "ByteFormattingUtil",
                            "similarity_score": 0.5046922870702961
                        },
                        {
                            "class_name": "ConfigurationParserUtils",
                            "similarity_score": 0.5603780234925373
                        },
                        {
                            "class_name": "ArrayUtil",
                            "similarity_score": 0.35741747683521685
                        },
                        {
                            "class_name": "NativeSpinLockUtils",
                            "similarity_score": 0.355742508327253
                        },
                        {
                            "class_name": "NativeUtils",
                            "similarity_score": 0.5784901017398086
                        },
                        {
                            "class_name": "SubstrateUtil",
                            "similarity_score": 0.5201909429875005
                        },
                        {
                            "class_name": "StringUtil",
                            "similarity_score": 0.5085139389053998
                        },
                        {
                            "class_name": "String",
                            "similarity_score": 0.5256203831165508
                        },
                        {
                            "class_name": "Math",
                            "similarity_score": 0.2987363280252939
                        },
                        {
                            "class_name": "StackTraceUtils",
                            "similarity_score": 0.5637337857910031
                        },
                        {
                            "class_name": "Long",
                            "similarity_score": 0.5092484553022893
                        },
                        {
                            "class_name": "DiagnosticUtils",
                            "similarity_score": 0.4025568286432295
                        },
                        {
                            "class_name": "DirectByteBufferUtil",
                            "similarity_score": 0.42365927286816174
                        },
                        {
                            "class_name": "MetaUtil",
                            "similarity_score": 0.5069617310030821
                        },
                        {
                            "class_name": "DeoptimizationUtils",
                            "similarity_score": 0.5223301086070116
                        },
                        {
                            "class_name": "MethodArgsUtils",
                            "similarity_score": 0.5588729721086798
                        },
                        {
                            "class_name": "OptionUtils",
                            "similarity_score": 0.6318214035554185
                        },
                        {
                            "class_name": "MetricsLogUtils",
                            "similarity_score": 0.4997250390508777
                        },
                        {
                            "class_name": "MethodHandleUtils",
                            "similarity_score": 0.3512061639643076
                        },
                        {
                            "class_name": "MissingResourceRegistrationUtils",
                            "similarity_score": 0.39440231322774755
                        },
                        {
                            "class_name": "MissingReflectionRegistrationUtils",
                            "similarity_score": 0.3994701455680507
                        },
                        {
                            "class_name": "MissingSerializationRegistrationUtils",
                            "similarity_score": 0.4386829537574811
                        },
                        {
                            "class_name": "MissingRegistrationUtils",
                            "similarity_score": 0.6519059447666272
                        },
                        {
                            "class_name": "MissingJNIRegistrationUtils",
                            "similarity_score": 0.24990283117595904
                        },
                        {
                            "class_name": "JavaMemoryUtil",
                            "similarity_score": 0.4462607034911731
                        },
                        {
                            "class_name": "Target_java_util_regex_Matcher",
                            "similarity_score": 0.5346101595532509
                        },
                        {
                            "class_name": "JNIRegistrationUtil",
                            "similarity_score": 0.4864555458691863
                        },
                        {
                            "class_name": "UnmanagedMemoryUtil",
                            "similarity_score": 0.3941954207433883
                        },
                        {
                            "class_name": "UnsignedUtils",
                            "similarity_score": 0.32031732449126815
                        },
                        {
                            "class_name": "PointerUtils",
                            "similarity_score": 0.2534512120095223
                        },
                        {
                            "class_name": "Target_java_util_regex_Pattern",
                            "similarity_score": 0.6745801757300424
                        },
                        {
                            "class_name": "NativeImageResourceFileSystemUtil",
                            "similarity_score": 0.640755351129729
                        },
                        {
                            "class_name": "ForeignArrayUtils",
                            "similarity_score": 0.5214885156456199
                        },
                        {
                            "class_name": "InfoElement",
                            "similarity_score": 0.40581426455559233
                        },
                        {
                            "class_name": "InlineeReturnAction",
                            "similarity_score": 0.21626860695885888
                        },
                        {
                            "class_name": "InputFilter",
                            "similarity_score": 0.5776466654662418
                        },
                        {
                            "class_name": "GuardedCondition",
                            "similarity_score": 0.4150211708365879
                        },
                        {
                            "class_name": "JavaVersionUtil",
                            "similarity_score": 0.30993404669460345
                        },
                        {
                            "class_name": "Hints",
                            "similarity_score": 0.24552509967066272
                        },
                        {
                            "class_name": "BlockOrderComparator",
                            "similarity_score": 0.5515573936163368
                        },
                        {
                            "class_name": "Marks",
                            "similarity_score": 0.4234393995173772
                        },
                        {
                            "class_name": "StandardPathUtilitiesProvider",
                            "similarity_score": 0.578460504356965
                        },
                        {
                            "class_name": "Target_java_util_concurrent_locks_AbstractOwnableSynchronizer",
                            "similarity_score": 0.532318092727499
                        },
                        {
                            "class_name": "InlineBeforeAnalysisPolicyUtils",
                            "similarity_score": 0.46001599100354296
                        },
                        {
                            "class_name": "Target_sun_util_locale_provider_LocaleServiceProviderPool_OptimizedLocaleMode",
                            "similarity_score": 0.3866338370978868
                        },
                        {
                            "class_name": "SVMImageLayerSnapshotUtil",
                            "similarity_score": 0.5488400823137207
                        },
                        {
                            "class_name": "CInterfaceLocationIdentityBuiltIn",
                            "similarity_score": 0.43624713305427926
                        },
                        {
                            "class_name": "UnsafeMemoryUtil",
                            "similarity_score": 0.5351782057853505
                        },
                        {
                            "class_name": "AccumulativeInlineScope",
                            "similarity_score": 0.4975946786675335
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "GraphUtil",
                        "VirtualUtil",
                        "FileUtils"
                    ],
                    "llm_response_time": 4412,
                    "similarity_computation_time": 43,
                    "similarity_metric": "cosine"
                }
            }
        }
    }
]