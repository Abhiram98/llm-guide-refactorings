[
    {
        "repository": "https://github.com/elastic/elasticsearch.git",
        "sha1": "1d525752af4f4c768d3a13604f13e5d3005d284a",
        "url": "https://github.com/elastic/elasticsearch/commit/1d525752af4f4c768d3a13604f13e5d3005d284a",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public moveToUnsuccessful(newStage Stage, failure String, endTime long) : SnapshotsInProgress.ShardState extracted from private newShardSnapshotTask(shardId ShardId, snapshot Snapshot, indexId IndexId, snapshotStatus IndexShardSnapshotStatus, entryVersion IndexVersion, entryStartTime long) : Runnable in class org.elasticsearch.snapshots.SnapshotShardsService & moved to class org.elasticsearch.index.snapshots.IndexShardSnapshotStatus",
            "leftSideLocations": [
                {
                    "filePath": "server/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java",
                    "startLine": 306,
                    "endLine": 349,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "private newShardSnapshotTask(shardId ShardId, snapshot Snapshot, indexId IndexId, snapshotStatus IndexShardSnapshotStatus, entryVersion IndexVersion, entryStartTime long) : Runnable"
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java",
                    "startLine": 345,
                    "endLine": 345,
                    "startColumn": 17,
                    "endColumn": 89,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/snapshots/IndexShardSnapshotStatus.java",
                    "startLine": 213,
                    "endLine": 223,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public moveToUnsuccessful(newStage Stage, failure String, endTime long) : SnapshotsInProgress.ShardState"
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/snapshots/IndexShardSnapshotStatus.java",
                    "startLine": 221,
                    "endLine": 221,
                    "startColumn": 9,
                    "endColumn": 40,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java",
                    "startLine": 355,
                    "endLine": 405,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "private newShardSnapshotTask(shardId ShardId, snapshot Snapshot, indexId IndexId, snapshotStatus IndexShardSnapshotStatus, entryVersion IndexVersion, entryStartTime long) : Runnable"
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java",
                    "startLine": 401,
                    "endLine": 401,
                    "startColumn": 40,
                    "endColumn": 128,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "snapshotStatus.moveToUnsuccessful(nextStage,failure,threadPool.absoluteTimeInMillis())"
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/snapshots/IndexShardSnapshotStatus.java",
                    "startLine": 214,
                    "endLine": 214,
                    "startColumn": 9,
                    "endColumn": 81,
                    "codeElementType": "ASSERT_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/snapshots/IndexShardSnapshotStatus.java",
                    "startLine": 216,
                    "endLine": 216,
                    "startColumn": 13,
                    "endColumn": 64,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/snapshots/IndexShardSnapshotStatus.java",
                    "startLine": 217,
                    "endLine": 217,
                    "startColumn": 13,
                    "endColumn": 36,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/snapshots/IndexShardSnapshotStatus.java",
                    "startLine": 218,
                    "endLine": 218,
                    "startColumn": 13,
                    "endColumn": 75,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/snapshots/IndexShardSnapshotStatus.java",
                    "startLine": 222,
                    "endLine": 222,
                    "startColumn": 9,
                    "endColumn": 54,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/snapshots/IndexShardSnapshotStatus.java",
                    "startLine": 215,
                    "endLine": 219,
                    "startColumn": 91,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/snapshots/IndexShardSnapshotStatus.java",
                    "startLine": 215,
                    "endLine": 219,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                }
            ],
            "isStatic": false
        },
        "extraction_results": {
            "newCommitHash": "1aec232406423149488c458c766593aac8284642",
            "newBranchName": "extract-moveToUnsuccessful-newShardSnapshotTask-06b0f4e",
            "success": true
        },
        "ref_id": 66,
        "telemetry": {
            "id": "4c286a94-87cb-4792-b6e8-ba878ce147a8",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 562,
                "lineStart": 66,
                "lineEnd": 627,
                "bodyLineStart": 66,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/elasticsearch/server/src/main/java/org/elasticsearch/snapshots/SnapshotShardsService.java",
                "sourceCode": "/**\n * This service runs on data nodes and controls currently running shard snapshots on these nodes. It is responsible for\n * starting and stopping shard level snapshots.\n * See package level documentation of {@link org.elasticsearch.snapshots} for details.\n */\npublic final class SnapshotShardsService extends AbstractLifecycleComponent implements ClusterStateListener, IndexEventListener {\n    private static final Logger logger = LogManager.getLogger(SnapshotShardsService.class);\n\n    private final ClusterService clusterService;\n\n    private final IndicesService indicesService;\n\n    private final RepositoriesService repositoriesService;\n\n    private final TransportService transportService;\n\n    public ThreadPool getThreadPool() {\n        return threadPool;\n    }\n\n    private final ThreadPool threadPool;\n\n    private final Map<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> shardSnapshots = new HashMap<>();\n\n    // A map of snapshots to the shardIds that we already reported to the master as failed\n    private final ResultDeduplicator<UpdateIndexShardSnapshotStatusRequest, Void> remoteFailedRequestDeduplicator;\n\n    // Runs the tasks that promptly notify shards of aborted snapshots so that resources can be released ASAP\n    private final ThrottledTaskRunner notifyOnAbortTaskRunner;\n\n    public SnapshotShardsService(\n        Settings settings,\n        ClusterService clusterService,\n        RepositoriesService repositoriesService,\n        TransportService transportService,\n        IndicesService indicesService\n    ) {\n        this.indicesService = indicesService;\n        this.repositoriesService = repositoriesService;\n        this.transportService = transportService;\n        this.clusterService = clusterService;\n        this.threadPool = transportService.getThreadPool();\n        this.remoteFailedRequestDeduplicator = new ResultDeduplicator<>(threadPool.getThreadContext());\n        if (DiscoveryNode.canContainData(settings)) {\n            // this is only useful on the nodes that can hold data\n            clusterService.addListener(this);\n        }\n\n        // Abort notification may release the last store ref, closing the shard, so we do them in the background on a generic thread.\n        this.notifyOnAbortTaskRunner = new ThrottledTaskRunner(\n            \"notify-on-abort\",\n            threadPool.info(ThreadPool.Names.SNAPSHOT).getMax(),\n            threadPool.generic()\n        );\n    }\n\n    @Override\n    protected void doStart() {}\n\n    @Override\n    protected void doStop() {}\n\n    @Override\n    protected void doClose() {\n        clusterService.removeListener(this);\n    }\n\n    @Override\n    public void clusterChanged(ClusterChangedEvent event) {\n        try {\n            final var currentSnapshots = SnapshotsInProgress.get(event.state());\n            if (SnapshotsInProgress.get(event.previousState()).equals(currentSnapshots) == false) {\n                final var localNodeId = clusterService.localNode().getId();\n                synchronized (shardSnapshots) {\n                    cancelRemoved(currentSnapshots);\n                    for (final var oneRepoSnapshotsInProgress : currentSnapshots.entriesByRepo()) {\n                        for (final var snapshotsInProgressEntry : oneRepoSnapshotsInProgress) {\n                            handleUpdatedSnapshotsInProgressEntry(localNodeId, snapshotsInProgressEntry);\n                        }\n                    }\n                }\n            }\n\n            String previousMasterNodeId = event.previousState().nodes().getMasterNodeId();\n            String currentMasterNodeId = event.state().nodes().getMasterNodeId();\n            if (currentMasterNodeId != null && currentMasterNodeId.equals(previousMasterNodeId) == false) {\n                // Clear request deduplicator since we need to send all requests that were potentially not handled by the previous\n                // master again\n                remoteFailedRequestDeduplicator.clear();\n                for (List<SnapshotsInProgress.Entry> snapshots : currentSnapshots.entriesByRepo()) {\n                    syncShardStatsOnNewMaster(snapshots);\n                }\n            }\n\n        } catch (Exception e) {\n            assert false : new AssertionError(e);\n            logger.warn(\"failed to update snapshot state\", e);\n        }\n    }\n\n    @Override\n    public void beforeIndexShardClosed(ShardId shardId, @Nullable IndexShard indexShard, Settings indexSettings) {\n        // abort any snapshots occurring on the soon-to-be closed shard\n        synchronized (shardSnapshots) {\n            for (Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> snapshotShards : shardSnapshots.entrySet()) {\n                final var indexShardSnapshotStatus = snapshotShards.getValue().get(shardId);\n                if (indexShardSnapshotStatus != null) {\n                    logger.debug(\n                        \"[{}] shard closing, abort snapshotting for snapshot [{}]\",\n                        shardId,\n                        snapshotShards.getKey().getSnapshotId()\n                    );\n                    indexShardSnapshotStatus.abortIfNotCompleted(\"shard is closing, aborting\", notifyOnAbortTaskRunner::enqueueTask);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns status of shards that are snapshotted on the node and belong to the given snapshot\n     * <p>\n     * This method is executed on data node\n     * </p>\n     *\n     * @param snapshot  snapshot\n     * @return map of shard id to snapshot status\n     */\n    public Map<ShardId, IndexShardSnapshotStatus.Copy> currentSnapshotShards(Snapshot snapshot) {\n        synchronized (shardSnapshots) {\n            final var current = shardSnapshots.get(snapshot);\n            if (current == null) {\n                return null;\n            }\n\n            final Map<ShardId, IndexShardSnapshotStatus.Copy> result = Maps.newMapWithExpectedSize(current.size());\n            for (final var entry : current.entrySet()) {\n                result.put(entry.getKey(), entry.getValue().asCopy());\n            }\n            return result;\n        }\n    }\n\n    private void cancelRemoved(SnapshotsInProgress snapshotsInProgress) {\n        // First, remove snapshots that are no longer there\n        Iterator<Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>>> it = shardSnapshots.entrySet().iterator();\n        while (it.hasNext()) {\n            final Map.Entry<Snapshot, Map<ShardId, IndexShardSnapshotStatus>> entry = it.next();\n            final Snapshot snapshot = entry.getKey();\n            if (snapshotsInProgress.snapshot(snapshot) == null) {\n                // abort any running snapshots of shards for the removed entry;\n                // this could happen if for some reason the cluster state update for aborting\n                // running shards is missed, then the snapshot is removed is a subsequent cluster\n                // state update, which is being processed here\n                it.remove();\n                for (IndexShardSnapshotStatus snapshotStatus : entry.getValue().values()) {\n                    snapshotStatus.abortIfNotCompleted(\n                        \"snapshot has been removed in cluster state, aborting\",\n                        notifyOnAbortTaskRunner::enqueueTask\n                    );\n                }\n            }\n        }\n    }\n\n    private void handleUpdatedSnapshotsInProgressEntry(String localNodeId, SnapshotsInProgress.Entry entry) {\n        if (entry.isClone()) {\n            // This is a snapshot clone, it will be executed on the current master\n            return;\n        }\n\n        switch (entry.state()) {\n            case STARTED -> {\n                if (entry.hasShardsInInitState() == false) {\n                    // Snapshot is running but has no running shards yet, nothing to do\n                    return;\n                }\n\n                startNewShardSnapshots(localNodeId, entry);\n            }\n            case ABORTED -> {\n                // Abort all running shards for this snapshot\n                final Snapshot snapshot = entry.snapshot();\n                Map<ShardId, IndexShardSnapshotStatus> snapshotShards = shardSnapshots.getOrDefault(snapshot, emptyMap());\n                for (Map.Entry<RepositoryShardId, ShardSnapshotStatus> shard : entry.shardsByRepoShardId().entrySet()) {\n                    final ShardId sid = entry.shardId(shard.getKey());\n                    final IndexShardSnapshotStatus snapshotStatus = snapshotShards.get(sid);\n                    if (snapshotStatus == null) {\n                        // due to CS batching we might have missed the INIT state and straight went into ABORTED\n                        // notify master that abort has completed by moving to FAILED\n                        if (shard.getValue().state() == ShardState.ABORTED && localNodeId.equals(shard.getValue().nodeId())) {\n                            notifyUnsuccessfulSnapshotShard(snapshot, sid, shard.getValue().reason(), shard.getValue().generation());\n                        }\n                    } else {\n                        snapshotStatus.abortIfNotCompleted(\"snapshot has been aborted\", notifyOnAbortTaskRunner::enqueueTask);\n                    }\n                }\n            }\n            // otherwise snapshot is not running, nothing to do\n        }\n    }\n\n    private void startNewShardSnapshots(String localNodeId, SnapshotsInProgress.Entry entry) {\n        Map<ShardId, ShardGeneration> shardsToStart = null;\n        final Snapshot snapshot = entry.snapshot();\n        final var runningShardsForSnapshot = shardSnapshots.getOrDefault(snapshot, emptyMap()).keySet();\n        for (var scheduledShard : entry.shards().entrySet()) {\n            // Add all new shards to start processing on\n            final var shardId = scheduledShard.getKey();\n            final var shardSnapshotStatus = scheduledShard.getValue();\n            if (shardSnapshotStatus.state() == ShardState.INIT\n                && localNodeId.equals(shardSnapshotStatus.nodeId())\n                && runningShardsForSnapshot.contains(shardId) == false) {\n                logger.trace(\"[{}] adding shard to the queue\", shardId);\n                if (shardsToStart == null) {\n                    shardsToStart = new HashMap<>();\n                }\n                shardsToStart.put(shardId, shardSnapshotStatus.generation());\n            }\n        }\n        if (shardsToStart == null) {\n            return;\n        }\n        assert shardsToStart.isEmpty() == false;\n\n        final var newSnapshotShards = shardSnapshots.computeIfAbsent(snapshot, s -> new HashMap<>());\n\n        final List<Runnable> shardSnapshotTasks = new ArrayList<>(shardsToStart.size());\n        for (final Map.Entry<ShardId, ShardGeneration> shardEntry : shardsToStart.entrySet()) {\n            final ShardId shardId = shardEntry.getKey();\n            final IndexShardSnapshotStatus snapshotStatus = IndexShardSnapshotStatus.newInitializing(shardEntry.getValue());\n            newSnapshotShards.put(shardId, snapshotStatus);\n            final IndexId indexId = entry.indices().get(shardId.getIndexName());\n            assert indexId != null;\n            assert SnapshotsService.useShardGenerations(entry.version())\n                || ShardGenerations.fixShardGeneration(snapshotStatus.generation()) == null\n                : \"Found non-null, non-numeric shard generation [\"\n                    + snapshotStatus.generation()\n                    + \"] for snapshot with old-format compatibility\";\n            shardSnapshotTasks.add(newShardSnapshotTask(shardId, snapshot, indexId, snapshotStatus, entry.version(), entry.startTime()));\n        }\n\n        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> shardSnapshotTasks.forEach(Runnable::run));\n    }\n\n    private Runnable newShardSnapshotTask(\n        final ShardId shardId,\n        final Snapshot snapshot,\n        final IndexId indexId,\n        final IndexShardSnapshotStatus snapshotStatus,\n        final IndexVersion entryVersion,\n        final long entryStartTime\n    ) {\n        // separate method to make sure this lambda doesn't capture any heavy local objects like a SnapshotsInProgress.Entry\n        return () -> snapshot(shardId, snapshot, indexId, snapshotStatus, entryVersion, entryStartTime, new ActionListener<>() {\n            @Override\n            public void onResponse(ShardSnapshotResult shardSnapshotResult) {\n                final ShardGeneration newGeneration = shardSnapshotResult.getGeneration();\n                assert newGeneration != null;\n                assert newGeneration.equals(snapshotStatus.generation());\n                if (logger.isDebugEnabled()) {\n                    final IndexShardSnapshotStatus.Copy lastSnapshotStatus = snapshotStatus.asCopy();\n                    logger.debug(\n                        \"[{}][{}] completed snapshot to [{}] with status [{}] at generation [{}]\",\n                        shardId,\n                        snapshot,\n                        snapshot.getRepository(),\n                        lastSnapshotStatus,\n                        snapshotStatus.generation()\n                    );\n                }\n                notifySuccessfulSnapshotShard(snapshot, shardId, shardSnapshotResult);\n            }\n\n            @Override\n            public void onFailure(Exception e) {\n                final String failure;\n                final Stage nextStage;\n\n                if (e instanceof AbortedSnapshotException) {\n                    nextStage = Stage.FAILURE;\n                    failure = \"aborted\";\n                    logger.debug(() -> format(\"[%s][%s] aborted shard snapshot\", shardId, snapshot), e);\n                } else {\n                    nextStage = Stage.FAILURE;\n                    failure = summarizeFailure(e);\n                    logger.warn(() -> format(\"[%s][%s] failed to snapshot shard\", shardId, snapshot), e);\n                }\n                moveToUnsuccessful(nextStage, failure, threadPool.absoluteTimeInMillis(), snapshotStatus);\n                notifyUnsuccessfulSnapshotShard(snapshot, shardId, failure, snapshotStatus.generation());\n            }\n\n\n        });\n    }\n    private void moveToUnsuccessful(Stage newStage, String failure, long endTime, IndexShardSnapshotStatus snapshotStatus) {\n        assert newStage == Stage.PAUSED || newStage == Stage.FAILURE : newStage;\n        if (newStage == Stage.PAUSED && snapshotStatus.getStage().compareAndSet(Stage.PAUSING, Stage.PAUSED)) {\n            snapshotStatus.setTotalTime(Math.max(0L, endTime - snapshotStatus.getStartTime()));\n            snapshotStatus.setFailure(failure);\n        }\n        snapshotStatus.moveToFailed(getThreadPool().absoluteTimeInMillis(), failure);\n    }\n\n    // package private for testing\n    static String summarizeFailure(Throwable t) {\n        if (t.getCause() == null) {\n            return t.getClass().getSimpleName() + \"[\" + t.getMessage() + \"]\";\n        } else {\n            StringBuilder sb = new StringBuilder();\n            while (t != null) {\n                sb.append(t.getClass().getSimpleName());\n                if (t.getMessage() != null) {\n                    sb.append(\"[\");\n                    sb.append(t.getMessage());\n                    sb.append(\"]\");\n                }\n                t = t.getCause();\n                if (t != null) {\n                    sb.append(\"; nested: \");\n                }\n            }\n            return sb.toString();\n        }\n    }\n\n    /**\n     * Creates shard snapshot\n     *\n     * @param snapshot       snapshot\n     * @param snapshotStatus snapshot status\n     */\n    private void snapshot(\n        final ShardId shardId,\n        final Snapshot snapshot,\n        final IndexId indexId,\n        final IndexShardSnapshotStatus snapshotStatus,\n        IndexVersion version,\n        final long entryStartTime,\n        ActionListener<ShardSnapshotResult> resultListener\n    ) {\n        ActionListener.run(resultListener, listener -> {\n            snapshotStatus.ensureNotAborted();\n            final IndexShard indexShard = indicesService.indexServiceSafe(shardId.getIndex()).getShard(shardId.id());\n            if (indexShard.routingEntry().primary() == false) {\n                throw new IndexShardSnapshotFailedException(shardId, \"snapshot should be performed only on primary\");\n            }\n            if (indexShard.routingEntry().relocating()) {\n                // do not snapshot when in the process of relocation of primaries so we won't get conflicts\n                throw new IndexShardSnapshotFailedException(shardId, \"cannot snapshot while relocating\");\n            }\n\n            final IndexShardState indexShardState = indexShard.state();\n            if (indexShardState == IndexShardState.CREATED || indexShardState == IndexShardState.RECOVERING) {\n                // shard has just been created, or still recovering\n                throw new IndexShardSnapshotFailedException(shardId, \"shard didn't fully recover yet\");\n            }\n\n            final Repository repository = repositoriesService.repository(snapshot.getRepository());\n            SnapshotIndexCommit snapshotIndexCommit = null;\n            try {\n                snapshotIndexCommit = new SnapshotIndexCommit(indexShard.acquireIndexCommitForSnapshot());\n                final var shardStateId = getShardStateId(indexShard, snapshotIndexCommit.indexCommit()); // not aborted so indexCommit() ok\n                snapshotStatus.addAbortListener(makeAbortListener(indexShard.shardId(), snapshot, snapshotIndexCommit));\n                snapshotStatus.ensureNotAborted();\n                repository.snapshotShard(\n                    new SnapshotShardContext(\n                        indexShard.store(),\n                        indexShard.mapperService(),\n                        snapshot.getSnapshotId(),\n                        indexId,\n                        snapshotIndexCommit,\n                        shardStateId,\n                        snapshotStatus,\n                        version,\n                        entryStartTime,\n                        listener\n                    )\n                );\n                snapshotIndexCommit = null; // success\n            } finally {\n                if (snapshotIndexCommit != null) {\n                    snapshotIndexCommit.closingBefore(new ActionListener<Void>() {\n                        @Override\n                        public void onResponse(Void unused) {}\n\n                        @Override\n                        public void onFailure(Exception e) {\n                            // we're already failing exceptionally, and prefer to propagate the original exception instead of this one\n                            logger.warn(Strings.format(\"exception closing commit for [%s] in [%s]\", indexShard.shardId(), snapshot), e);\n                        }\n                    }).onResponse(null);\n                }\n            }\n        });\n    }\n\n    private static ActionListener<IndexShardSnapshotStatus.AbortStatus> makeAbortListener(\n        ShardId shardId,\n        Snapshot snapshot,\n        SnapshotIndexCommit snapshotIndexCommit\n    ) {\n        return new ActionListener<>() {\n            @Override\n            public void onResponse(IndexShardSnapshotStatus.AbortStatus abortStatus) {\n                if (abortStatus == IndexShardSnapshotStatus.AbortStatus.ABORTED) {\n                    assert ThreadPool.assertCurrentThreadPool(ThreadPool.Names.GENERIC, ThreadPool.Names.SNAPSHOT);\n                    snapshotIndexCommit.onAbort();\n                }\n            }\n\n            @Override\n            public void onFailure(Exception e) {\n                logger.error(() -> Strings.format(\"unexpected failure in %s\", description()), e);\n                assert false : e;\n            }\n\n            @Override\n            public String toString() {\n                return description();\n            }\n\n            private String description() {\n                return Strings.format(\"abort listener for [%s] in [%s]\", shardId, snapshot);\n            }\n        };\n    }\n\n    /**\n     * Generates an identifier from the current state of a shard that can be used to detect whether a shard's contents\n     * have changed between two snapshots.\n     * A shard is assumed to have unchanged contents if its global- and local checkpoint are equal, its maximum\n     * sequence number has not changed and its history- and force-merge-uuid have not changed.\n     * The method returns {@code null} if global and local checkpoint are different for a shard since no safe unique\n     * shard state id can be used in this case because of the possibility of a primary failover leading to different\n     * shard content for the same sequence number on a subsequent snapshot.\n     *\n     * @param indexShard          Shard\n     * @param snapshotIndexCommit IndexCommit for shard\n     * @return shard state id or {@code null} if none can be used\n     */\n    @Nullable\n    public static String getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit) throws IOException {\n        final Map<String, String> userCommitData = snapshotIndexCommit.getUserData();\n        final SequenceNumbers.CommitInfo seqNumInfo = SequenceNumbers.loadSeqNoInfoFromLuceneCommit(userCommitData.entrySet());\n        final long maxSeqNo = seqNumInfo.maxSeqNo;\n        if (maxSeqNo != seqNumInfo.localCheckpoint || maxSeqNo != indexShard.getLastSyncedGlobalCheckpoint()) {\n            return null;\n        }\n        return userCommitData.get(Engine.HISTORY_UUID_KEY)\n            + \"-\"\n            + userCommitData.getOrDefault(Engine.FORCE_MERGE_UUID_KEY, \"na\")\n            + \"-\"\n            + maxSeqNo;\n    }\n\n    /**\n     * Checks if any shards were processed that the new master doesn't know about\n     */\n    private void syncShardStatsOnNewMaster(List<SnapshotsInProgress.Entry> entries) {\n        for (SnapshotsInProgress.Entry snapshot : entries) {\n            if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {\n                final Map<ShardId, IndexShardSnapshotStatus> localShards;\n                synchronized (shardSnapshots) {\n                    final var currentLocalShards = shardSnapshots.get(snapshot.snapshot());\n                    if (currentLocalShards == null) {\n                        continue;\n                    }\n                    localShards = Map.copyOf(currentLocalShards);\n                }\n                Map<ShardId, ShardSnapshotStatus> masterShards = snapshot.shards();\n                for (Map.Entry<ShardId, IndexShardSnapshotStatus> localShard : localShards.entrySet()) {\n                    ShardId shardId = localShard.getKey();\n                    ShardSnapshotStatus masterShard = masterShards.get(shardId);\n                    if (masterShard != null && masterShard.state().completed() == false) {\n                        final IndexShardSnapshotStatus.Copy indexShardSnapshotStatus = localShard.getValue().asCopy();\n                        final Stage stage = indexShardSnapshotStatus.getStage();\n                        // Master knows about the shard and thinks it has not completed\n                        if (stage == Stage.DONE) {\n                            // but we think the shard is done - we need to make new master know that the shard is done\n                            logger.debug(\n                                \"[{}] new master thinks the shard [{}] is not completed but the shard is done locally, \"\n                                    + \"updating status on the master\",\n                                snapshot.snapshot(),\n                                shardId\n                            );\n                            notifySuccessfulSnapshotShard(snapshot.snapshot(), shardId, localShard.getValue().getShardSnapshotResult());\n\n                        } else if (stage == Stage.FAILURE) {\n                            // but we think the shard failed - we need to make new master know that the shard failed\n                            logger.debug(\n                                \"[{}] new master thinks the shard [{}] is not completed but the shard failed locally, \"\n                                    + \"updating status on master\",\n                                snapshot.snapshot(),\n                                shardId\n                            );\n                            notifyUnsuccessfulSnapshotShard(\n                                snapshot.snapshot(),\n                                shardId,\n                                indexShardSnapshotStatus.getFailure(),\n                                localShard.getValue().generation()\n                            );\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n\n    /**\n     * Notify the master node that the given shard snapshot completed successfully.\n     */\n    private void notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, ShardSnapshotResult shardSnapshotResult) {\n        assert shardSnapshotResult != null;\n        assert shardSnapshotResult.getGeneration() != null;\n        sendSnapshotShardUpdate(snapshot, shardId, ShardSnapshotStatus.success(clusterService.localNode().getId(), shardSnapshotResult));\n    }\n\n    /**\n     * Notify the master node that the given shard snapshot has completed but did not succeed\n     */\n    private void notifyUnsuccessfulSnapshotShard(\n        final Snapshot snapshot,\n        final ShardId shardId,\n        final String failure,\n        final ShardGeneration generation\n    ) {\n        sendSnapshotShardUpdate(\n            snapshot,\n            shardId,\n            new ShardSnapshotStatus(clusterService.localNode().getId(), ShardState.FAILED, generation, failure)\n        );\n    }\n\n    /** Updates the shard snapshot status by sending a {@link UpdateIndexShardSnapshotStatusRequest} to the master node */\n    private void sendSnapshotShardUpdate(final Snapshot snapshot, final ShardId shardId, final ShardSnapshotStatus status) {\n        remoteFailedRequestDeduplicator.executeOnce(\n            new UpdateIndexShardSnapshotStatusRequest(snapshot, shardId, status),\n            new ActionListener<>() {\n                @Override\n                public void onResponse(Void aVoid) {\n                    logger.trace(\"[{}][{}] updated snapshot state to [{}]\", shardId, snapshot, status);\n                }\n\n                @Override\n                public void onFailure(Exception e) {\n                    logger.warn(() -> format(\"[%s][%s] failed to update snapshot state to [%s]\", shardId, snapshot, status), e);\n                }\n            },\n            (req, reqListener) -> transportService.sendRequest(\n                transportService.getLocalNode(),\n                SnapshotsService.UPDATE_SNAPSHOT_STATUS_ACTION_NAME,\n                req,\n                new ActionListenerResponseHandler<>(\n                    reqListener.map(res -> null),\n                    in -> ActionResponse.Empty.INSTANCE,\n                    TransportResponseHandler.TRANSPORT_WORKER\n                )\n            )\n        );\n    }\n}",
                "methodCount": 31
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 2,
                "candidates": [
                    {
                        "lineStart": 359,
                        "lineEnd": 366,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method moveToUnsuccessful to class RepositoriesService",
                        "description": "Move method moveToUnsuccessful to org.elasticsearch.repositories.RepositoriesService\nRationale: moveToUnsuccessful() operates on IndexShardSnapshotStatus, which is related to repositories and snapshots. Hence, it fits better in the RepositoriesService class rather than TransportService or IndicesService.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 492,
                        "lineEnd": 518,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method getShardStateId to class RestUtils",
                        "description": "move method getShardStateId to PsiClass:RestUtils\nRationale: The method `getShardStateId` is primarily involved in decoding and extracting specific elements from objects related to shard states. This task is aligned with RestUtils' responsibility of decoding and processing strings and components from URLs. RestUtils handles similar responsibilities, such as extracting and decoding parameters, which makes it a suitable place for methods dealing with extraction and identification processes from given components.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "elapsedTime": [
                {
                    "candidateIndex": 0,
                    "elapsedTime": 8721
                }
            ],
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 164863
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "summarizeFailure",
                            "method_signature": "static String summarizeFailure(Throwable t)",
                            "target_class": "UtilityClass",
                            "rationale": "The summarizeFailure method provides a generic utility function to create a summary of an exception message. This utility does not depend on the state or behavior of the SnapshotShardsService and can be used broadly for other purposes in the codebase."
                        },
                        {
                            "method_name": "getShardStateId",
                            "method_signature": "public static String getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit)",
                            "target_class": "ShardStateUtil",
                            "rationale": "The getShardStateId method is specific to generating shard state IDs and does not rely on the internal state or services of SnapshotShardsService. Moving it to a dedicated utility class like ShardStateUtil makes it more accessible and reusable."
                        }
                    ],
                    "llm_response_time": 4939
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "getThreadPool",
                            "method_signature": "public ThreadPool getThreadPool()",
                            "target_class": "TransportService",
                            "rationale": "The getThreadPool() method is related to transportService and retrieves its thread pool. It fits better within the TransportService class, as that's where the thread pool is initialized and managed."
                        },
                        {
                            "method_name": "summarizeFailure",
                            "method_signature": "static String summarizeFailure(Throwable t)",
                            "target_class": "ExceptionUtils",
                            "rationale": "The summarizeFailure method operates on a Throwable to return a string summarizing the failure. It does not rely on any instance variables of SnapshotShardsService, making it more appropriate for a utility class like ExceptionUtils."
                        },
                        {
                            "method_name": "getShardStateId",
                            "method_signature": "public static String getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit) throws IOException",
                            "target_class": "IndexShardUtils",
                            "rationale": "The getShardStateId method is specifically concerned with the state of an IndexShard and its IndexCommit. It should belong to a class focused on IndexShard operations, like IndexShardUtils."
                        }
                    ],
                    "llm_response_time": 4236
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "summarizeFailure",
                            "method_signature": "static String summarizeFailure(Throwable t)",
                            "target_class": "StringUtils",
                            "rationale": "The method summarizeFailure(Throwable t) deals with extracting and formatting messages from exceptions, which is a utility function with no direct dependency on the state of the SnapshotShardsService class. It could be more universally useful in a utility class dedicated to string manipulations and formatting tasks, such as a StringUtils class."
                        },
                        {
                            "method_name": "getShardStateId",
                            "method_signature": "public static String getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit) throws IOException",
                            "target_class": "SnapshotUtils",
                            "rationale": "The method getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit) computes a state identifier for a shard based on its commit data and snapshot state. This functionality, although related to snapshots, does not rely specifically on the state or instance variables of SnapshotShardsService. It can be moved to a utility class like SnapshotUtils where it can serve other snapshot-related operations as well."
                        }
                    ],
                    "llm_response_time": 4717
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "cancelRemoved",
                            "method_signature": "private cancelRemoved(SnapshotsInProgress snapshotsInProgress)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleUpdatedSnapshotsInProgressEntry",
                            "method_signature": "private handleUpdatedSnapshotsInProgressEntry(String localNodeId, SnapshotsInProgress.Entry entry)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "startNewShardSnapshots",
                            "method_signature": "private startNewShardSnapshots(String localNodeId, SnapshotsInProgress.Entry entry)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "moveToUnsuccessful",
                            "method_signature": "private moveToUnsuccessful(Stage newStage, String failure, long endTime, IndexShardSnapshotStatus snapshotStatus)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getShardStateId",
                            "method_signature": "@Nullable\n    public static getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "syncShardStatsOnNewMaster",
                            "method_signature": "private syncShardStatsOnNewMaster(List<SnapshotsInProgress.Entry> entries)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "notifySuccessfulSnapshotShard",
                            "method_signature": "private notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, ShardSnapshotResult shardSnapshotResult)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "notifyUnsuccessfulSnapshotShard",
                            "method_signature": "private notifyUnsuccessfulSnapshotShard(\n        final Snapshot snapshot,\n        final ShardId shardId,\n        final String failure,\n        final ShardGeneration generation\n    )",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "moveToUnsuccessful",
                            "method_signature": "private moveToUnsuccessful(Stage newStage, String failure, long endTime, IndexShardSnapshotStatus snapshotStatus)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "getShardStateId",
                            "method_signature": "@Nullable\n    public static getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "notifySuccessfulSnapshotShard",
                            "method_signature": "private notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, ShardSnapshotResult shardSnapshotResult)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "notifyUnsuccessfulSnapshotShard",
                            "method_signature": "private notifyUnsuccessfulSnapshotShard(\n        final Snapshot snapshot,\n        final ShardId shardId,\n        final String failure,\n        final ShardGeneration generation\n    )",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "cancelRemoved",
                            "method_signature": "private cancelRemoved(SnapshotsInProgress snapshotsInProgress)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "syncShardStatsOnNewMaster",
                            "method_signature": "private syncShardStatsOnNewMaster(List<SnapshotsInProgress.Entry> entries)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "startNewShardSnapshots",
                            "method_signature": "private startNewShardSnapshots(String localNodeId, SnapshotsInProgress.Entry entry)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "handleUpdatedSnapshotsInProgressEntry",
                            "method_signature": "private handleUpdatedSnapshotsInProgressEntry(String localNodeId, SnapshotsInProgress.Entry entry)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "private moveToUnsuccessful(Stage newStage, String failure, long endTime, IndexShardSnapshotStatus snapshotStatus)": {
                        "first": {
                            "method_name": "moveToUnsuccessful",
                            "method_signature": "private moveToUnsuccessful(Stage newStage, String failure, long endTime, IndexShardSnapshotStatus snapshotStatus)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3831714136767742
                    },
                    "@Nullable\n    public static getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit)": {
                        "first": {
                            "method_name": "getShardStateId",
                            "method_signature": "@Nullable\n    public static getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.41094971808108965
                    },
                    "private notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, ShardSnapshotResult shardSnapshotResult)": {
                        "first": {
                            "method_name": "notifySuccessfulSnapshotShard",
                            "method_signature": "private notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, ShardSnapshotResult shardSnapshotResult)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4583859494287511
                    },
                    "private notifyUnsuccessfulSnapshotShard(\n        final Snapshot snapshot,\n        final ShardId shardId,\n        final String failure,\n        final ShardGeneration generation\n    )": {
                        "first": {
                            "method_name": "notifyUnsuccessfulSnapshotShard",
                            "method_signature": "private notifyUnsuccessfulSnapshotShard(\n        final Snapshot snapshot,\n        final ShardId shardId,\n        final String failure,\n        final ShardGeneration generation\n    )",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.539304720281405
                    },
                    "private cancelRemoved(SnapshotsInProgress snapshotsInProgress)": {
                        "first": {
                            "method_name": "cancelRemoved",
                            "method_signature": "private cancelRemoved(SnapshotsInProgress snapshotsInProgress)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6134894919394052
                    },
                    "private syncShardStatsOnNewMaster(List<SnapshotsInProgress.Entry> entries)": {
                        "first": {
                            "method_name": "syncShardStatsOnNewMaster",
                            "method_signature": "private syncShardStatsOnNewMaster(List<SnapshotsInProgress.Entry> entries)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7040360014538102
                    },
                    "private startNewShardSnapshots(String localNodeId, SnapshotsInProgress.Entry entry)": {
                        "first": {
                            "method_name": "startNewShardSnapshots",
                            "method_signature": "private startNewShardSnapshots(String localNodeId, SnapshotsInProgress.Entry entry)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7091053204805525
                    },
                    "private handleUpdatedSnapshotsInProgressEntry(String localNodeId, SnapshotsInProgress.Entry entry)": {
                        "first": {
                            "method_name": "handleUpdatedSnapshotsInProgressEntry",
                            "method_signature": "private handleUpdatedSnapshotsInProgressEntry(String localNodeId, SnapshotsInProgress.Entry entry)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7635110085180933
                    }
                },
                "voyage": {
                    "@Nullable\n    public static getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit)": {
                        "first": {
                            "method_name": "getShardStateId",
                            "method_signature": "@Nullable\n    public static getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5260879532862104
                    },
                    "private moveToUnsuccessful(Stage newStage, String failure, long endTime, IndexShardSnapshotStatus snapshotStatus)": {
                        "first": {
                            "method_name": "moveToUnsuccessful",
                            "method_signature": "private moveToUnsuccessful(Stage newStage, String failure, long endTime, IndexShardSnapshotStatus snapshotStatus)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5837949920530882
                    },
                    "private cancelRemoved(SnapshotsInProgress snapshotsInProgress)": {
                        "first": {
                            "method_name": "cancelRemoved",
                            "method_signature": "private cancelRemoved(SnapshotsInProgress snapshotsInProgress)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6750510277746473
                    },
                    "private syncShardStatsOnNewMaster(List<SnapshotsInProgress.Entry> entries)": {
                        "first": {
                            "method_name": "syncShardStatsOnNewMaster",
                            "method_signature": "private syncShardStatsOnNewMaster(List<SnapshotsInProgress.Entry> entries)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7140465668533295
                    },
                    "private notifyUnsuccessfulSnapshotShard(\n        final Snapshot snapshot,\n        final ShardId shardId,\n        final String failure,\n        final ShardGeneration generation\n    )": {
                        "first": {
                            "method_name": "notifyUnsuccessfulSnapshotShard",
                            "method_signature": "private notifyUnsuccessfulSnapshotShard(\n        final Snapshot snapshot,\n        final ShardId shardId,\n        final String failure,\n        final ShardGeneration generation\n    )",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7365868228279483
                    },
                    "private notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, ShardSnapshotResult shardSnapshotResult)": {
                        "first": {
                            "method_name": "notifySuccessfulSnapshotShard",
                            "method_signature": "private notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, ShardSnapshotResult shardSnapshotResult)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7409541445955071
                    },
                    "private startNewShardSnapshots(String localNodeId, SnapshotsInProgress.Entry entry)": {
                        "first": {
                            "method_name": "startNewShardSnapshots",
                            "method_signature": "private startNewShardSnapshots(String localNodeId, SnapshotsInProgress.Entry entry)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7472821036756696
                    },
                    "private handleUpdatedSnapshotsInProgressEntry(String localNodeId, SnapshotsInProgress.Entry entry)": {
                        "first": {
                            "method_name": "handleUpdatedSnapshotsInProgressEntry",
                            "method_signature": "private handleUpdatedSnapshotsInProgressEntry(String localNodeId, SnapshotsInProgress.Entry entry)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7478675576402685
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private handleUpdatedSnapshotsInProgressEntry(String localNodeId, SnapshotsInProgress.Entry entry)",
                        "private startNewShardSnapshots(String localNodeId, SnapshotsInProgress.Entry entry)",
                        "private syncShardStatsOnNewMaster(List<SnapshotsInProgress.Entry> entries)",
                        "private cancelRemoved(SnapshotsInProgress snapshotsInProgress)",
                        "private moveToUnsuccessful(Stage newStage, String failure, long endTime, IndexShardSnapshotStatus snapshotStatus)",
                        "@Nullable\n    public static getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit)",
                        "private notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, ShardSnapshotResult shardSnapshotResult)",
                        "private notifyUnsuccessfulSnapshotShard(\n        final Snapshot snapshot,\n        final ShardId shardId,\n        final String failure,\n        final ShardGeneration generation\n    )"
                    ],
                    "llm_response_time": 8880
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "@Nullable\n    public static getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit)",
                        "private moveToUnsuccessful(Stage newStage, String failure, long endTime, IndexShardSnapshotStatus snapshotStatus)",
                        "private cancelRemoved(SnapshotsInProgress snapshotsInProgress)",
                        "private notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, ShardSnapshotResult shardSnapshotResult)",
                        "private notifyUnsuccessfulSnapshotShard(\n        final Snapshot snapshot,\n        final ShardId shardId,\n        final String failure,\n        final ShardGeneration generation\n    )"
                    ],
                    "llm_response_time": 5552
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "@Nullable\n    public static getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit)",
                        "private notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, ShardSnapshotResult shardSnapshotResult)",
                        "private moveToUnsuccessful(Stage newStage, String failure, long endTime, IndexShardSnapshotStatus snapshotStatus)"
                    ],
                    "llm_response_time": 4753
                },
                "voyage": {
                    "priority_method_names": [
                        "private handleUpdatedSnapshotsInProgressEntry(String localNodeId, SnapshotsInProgress.Entry entry)",
                        "private startNewShardSnapshots(String localNodeId, SnapshotsInProgress.Entry entry)",
                        "private cancelRemoved(SnapshotsInProgress snapshotsInProgress)",
                        "private syncShardStatsOnNewMaster(List<SnapshotsInProgress.Entry> entries)",
                        "private notifySuccessfulSnapshotShard(final Snapshot snapshot, final ShardId shardId, ShardSnapshotResult shardSnapshotResult)",
                        "@Nullable\n    public static getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit)",
                        "private moveToUnsuccessful(Stage newStage, String failure, long endTime, IndexShardSnapshotStatus snapshotStatus)"
                    ],
                    "llm_response_time": 6026
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private moveToUnsuccessful(Stage newStage, String failure, long endTime, IndexShardSnapshotStatus snapshotStatus)",
                        "@Nullable\n    public static getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit)",
                        "private syncShardStatsOnNewMaster(List<SnapshotsInProgress.Entry> entries)",
                        "private notifyUnsuccessfulSnapshotShard(\n        final Snapshot snapshot,\n        final ShardId shardId,\n        final String failure,\n        final ShardGeneration generation\n    )",
                        "private cancelRemoved(SnapshotsInProgress snapshotsInProgress)"
                    ],
                    "llm_response_time": 6794
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private moveToUnsuccessful(Stage newStage, String failure, long endTime, IndexShardSnapshotStatus snapshotStatus)",
                        "private cancelRemoved(SnapshotsInProgress snapshotsInProgress)",
                        "@Nullable\n    public static getShardStateId(IndexShard indexShard, IndexCommit snapshotIndexCommit)"
                    ],
                    "llm_response_time": 4130
                }
            },
            "targetClassMap": {
                "moveToUnsuccessful": {
                    "target_classes": [
                        {
                            "class_name": "Stage",
                            "similarity_score": 0.0365949457965579
                        },
                        {
                            "class_name": "IndexShardSnapshotStatus",
                            "similarity_score": 0.32121586551882864
                        },
                        {
                            "class_name": "ClusterService",
                            "similarity_score": 0.23817471473342247
                        },
                        {
                            "class_name": "IndicesService",
                            "similarity_score": 0.33965472060535723
                        },
                        {
                            "class_name": "RepositoriesService",
                            "similarity_score": 0.3619085880009532
                        },
                        {
                            "class_name": "TransportService",
                            "similarity_score": 0.38308495657868097
                        },
                        {
                            "class_name": "ThreadPool",
                            "similarity_score": 0.3225888788147553
                        },
                        {
                            "class_name": "ThrottledTaskRunner",
                            "similarity_score": 0.16357216402190614
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "RepositoriesService",
                        "IndicesService",
                        "TransportService"
                    ],
                    "llm_response_time": 9304,
                    "similarity_computation_time": 33,
                    "similarity_metric": "cosine"
                },
                "getShardStateId": {
                    "target_classes": [
                        {
                            "class_name": "SnapshotUtils",
                            "similarity_score": 0.3088835214729065
                        },
                        {
                            "class_name": "FutureUtils",
                            "similarity_score": 0.4584746503080889
                        },
                        {
                            "class_name": "RestUtils",
                            "similarity_score": 0.5863290753139262
                        },
                        {
                            "class_name": "CollectionUtils",
                            "similarity_score": 0.4491079888292783
                        },
                        {
                            "class_name": "ScoreScriptUtils",
                            "similarity_score": 0.2663903184753756
                        },
                        {
                            "class_name": "LocaleUtils",
                            "similarity_score": 0.4301340378531763
                        },
                        {
                            "class_name": "HttpUtils",
                            "similarity_score": 0.2713595430291532
                        },
                        {
                            "class_name": "PolicyUtil",
                            "similarity_score": 0.38086539857463875
                        },
                        {
                            "class_name": "DateUtils",
                            "similarity_score": 0.5541738697973801
                        },
                        {
                            "class_name": "IpPrefixAutomatonUtil",
                            "similarity_score": 0.3846276342045532
                        },
                        {
                            "class_name": "GeoUtils",
                            "similarity_score": 0.5976998842612924
                        },
                        {
                            "class_name": "ConfigurationUtils",
                            "similarity_score": 0.3724079825662969
                        },
                        {
                            "class_name": "GeoTileUtils",
                            "similarity_score": 0.5748036717491987
                        },
                        {
                            "class_name": "DiffableUtils",
                            "similarity_score": 0.4173343167369754
                        },
                        {
                            "class_name": "PluginsUtils",
                            "similarity_score": 0.47680149852328724
                        },
                        {
                            "class_name": "FileSystemUtils",
                            "similarity_score": 0.4787136480821427
                        },
                        {
                            "class_name": "XContentParserUtils",
                            "similarity_score": 0.5715157168983251
                        },
                        {
                            "class_name": "ArrayUtils",
                            "similarity_score": 0.43147471605320614
                        },
                        {
                            "class_name": "CIDRUtils",
                            "similarity_score": 0.2855573581591249
                        },
                        {
                            "class_name": "SphericalMercatorUtils",
                            "similarity_score": 0.38154079843117505
                        },
                        {
                            "class_name": "BlobContainerUtils",
                            "similarity_score": 0.45026775370557304
                        },
                        {
                            "class_name": "SearchUtils",
                            "similarity_score": 0.31696376597783243
                        },
                        {
                            "class_name": "ShardUtils",
                            "similarity_score": 0.48091436706733287
                        },
                        {
                            "class_name": "FilePermissionUtils",
                            "similarity_score": 0.44160090139978453
                        },
                        {
                            "class_name": "LevelUtil",
                            "similarity_score": 0.08433738561749833
                        },
                        {
                            "class_name": "BootstrapUtil",
                            "similarity_score": 0.19725600791847295
                        },
                        {
                            "class_name": "BucketUtils",
                            "similarity_score": 0.548675948231055
                        },
                        {
                            "class_name": "HighlightUtils",
                            "similarity_score": 0.2522006892918054
                        },
                        {
                            "class_name": "NestedUtils",
                            "similarity_score": 0.4726378902890986
                        },
                        {
                            "class_name": "SpanQueryBuilderUtil",
                            "similarity_score": 0.4527300950976113
                        },
                        {
                            "class_name": "DocValuesForUtil",
                            "similarity_score": 0.30264030576591416
                        },
                        {
                            "class_name": "StringSetValueSerializer",
                            "similarity_score": 0.3022472224167604
                        },
                        {
                            "class_name": "MapDiff",
                            "similarity_score": 0.44453321635072646
                        },
                        {
                            "class_name": "DiffableValueReader",
                            "similarity_score": 0.3228353977363871
                        },
                        {
                            "class_name": "L1Norm",
                            "similarity_score": 0.15876322406928006
                        },
                        {
                            "class_name": "L2Norm",
                            "similarity_score": 0.15876322406928006
                        },
                        {
                            "class_name": "DotProduct",
                            "similarity_score": 0.15876322406928006
                        },
                        {
                            "class_name": "ByteCosineSimilarity",
                            "similarity_score": 0.10846522890932807
                        },
                        {
                            "class_name": "ByteDenseVectorFunction",
                            "similarity_score": 0.41378841269435007
                        },
                        {
                            "class_name": "ByteDotProduct",
                            "similarity_score": 0.10954451150103323
                        },
                        {
                            "class_name": "ByteL1Norm",
                            "similarity_score": 0.10954451150103323
                        },
                        {
                            "class_name": "ByteL2Norm",
                            "similarity_score": 0.10954451150103323
                        },
                        {
                            "class_name": "CosineSimilarity",
                            "similarity_score": 0.15876322406928006
                        },
                        {
                            "class_name": "DenseVectorFunction",
                            "similarity_score": 0.22509378340810754
                        },
                        {
                            "class_name": "RandomScoreDoc",
                            "similarity_score": 0.217123252428559
                        },
                        {
                            "class_name": "RandomScoreField",
                            "similarity_score": 0.23992167101619055
                        },
                        {
                            "class_name": "DecayDateExp",
                            "similarity_score": 0.20738401597350942
                        },
                        {
                            "class_name": "DecayDateGauss",
                            "similarity_score": 0.23370243646649733
                        },
                        {
                            "class_name": "DecayDateLinear",
                            "similarity_score": 0.19958463091196568
                        },
                        {
                            "class_name": "DecayGeoExp",
                            "similarity_score": 0.1702205085562873
                        },
                        {
                            "class_name": "DecayGeoGauss",
                            "similarity_score": 0.1970785154775851
                        },
                        {
                            "class_name": "DecayGeoLinear",
                            "similarity_score": 0.1314304154907051
                        },
                        {
                            "class_name": "DecayNumericExp",
                            "similarity_score": 0.1556413319919366
                        },
                        {
                            "class_name": "DecayNumericGauss",
                            "similarity_score": 0.1871137997959372
                        },
                        {
                            "class_name": "DecayNumericLinear",
                            "similarity_score": 0.11055415967851331
                        },
                        {
                            "class_name": "FloatCosineSimilarity",
                            "similarity_score": 0.10741723110591495
                        },
                        {
                            "class_name": "FloatDenseVectorFunction",
                            "similarity_score": 0.4354183280138427
                        },
                        {
                            "class_name": "FloatDotProduct",
                            "similarity_score": 0.10846522890932807
                        },
                        {
                            "class_name": "FloatL1Norm",
                            "similarity_score": 0.10846522890932807
                        },
                        {
                            "class_name": "FloatL2Norm",
                            "similarity_score": 0.10846522890932807
                        },
                        {
                            "class_name": "SearchableSnapshotsSettings",
                            "similarity_score": 0.2884966431018901
                        },
                        {
                            "class_name": "MapperErrors",
                            "similarity_score": 0.20776743064366648
                        },
                        {
                            "class_name": "Maps",
                            "similarity_score": 0.5590433339487609
                        },
                        {
                            "class_name": "AutomatonQueries",
                            "similarity_score": 0.31329612776366234
                        },
                        {
                            "class_name": "GcNames",
                            "similarity_score": 0.21287565892676363
                        },
                        {
                            "class_name": "TcpHeader",
                            "similarity_score": 0.25931806821073794
                        },
                        {
                            "class_name": "RestTable",
                            "similarity_score": 0.27863488354122623
                        },
                        {
                            "class_name": "GeometryFormatterFactory",
                            "similarity_score": 0.23663615706001376
                        },
                        {
                            "class_name": "GeometryIO",
                            "similarity_score": 0.2252525252525253
                        },
                        {
                            "class_name": "ObjectParserHelper",
                            "similarity_score": 0.29919906995802215
                        },
                        {
                            "class_name": "MessageDigests",
                            "similarity_score": 0.5809849204061991
                        },
                        {
                            "class_name": "MetricInspectionHelper",
                            "similarity_score": 0.23881838399151645
                        },
                        {
                            "class_name": "ClusterNameExpressionResolver",
                            "similarity_score": 0.41071312731720155
                        },
                        {
                            "class_name": "ClusterStateUpdaters",
                            "similarity_score": 0.2225536500308801
                        },
                        {
                            "class_name": "AggregationInspectionHelper",
                            "similarity_score": 0.2242411764024352
                        },
                        {
                            "class_name": "Analysis",
                            "similarity_score": 0.43496560844617616
                        },
                        {
                            "class_name": "ParsedBucket",
                            "similarity_score": 0.13693063937629155
                        },
                        {
                            "class_name": "HeaderWarning",
                            "similarity_score": 0.6115348314971428
                        },
                        {
                            "class_name": "MovingFunctions",
                            "similarity_score": 0.5629186588437777
                        },
                        {
                            "class_name": "HealthIndicatorDisplayValues",
                            "similarity_score": 0.5230599060581665
                        },
                        {
                            "class_name": "Parser",
                            "similarity_score": 0.3905906702802922
                        },
                        {
                            "class_name": "ScoreFunctionBuilders",
                            "similarity_score": 0.1166812527349448
                        },
                        {
                            "class_name": "BucketHelpers",
                            "similarity_score": 0.5594942109132613
                        },
                        {
                            "class_name": "CompositeValuesSourceParserHelper",
                            "similarity_score": 0.1846113388271761
                        },
                        {
                            "class_name": "ListenerTimeouts",
                            "similarity_score": 0.5065699019100045
                        },
                        {
                            "class_name": "ECSJsonLayout",
                            "similarity_score": 0.25622025824194017
                        },
                        {
                            "class_name": "Annotations",
                            "similarity_score": 0.3821212603528045
                        },
                        {
                            "class_name": "CompressorFactory",
                            "similarity_score": 0.31418314061644
                        },
                        {
                            "class_name": "MultiValuesSourceParseHelper",
                            "similarity_score": 0.3793002222178903
                        },
                        {
                            "class_name": "ElasticsearchProcess",
                            "similarity_score": 0.24895967608079353
                        },
                        {
                            "class_name": "Elements",
                            "similarity_score": 0.3249941504594819
                        },
                        {
                            "class_name": "ConsoleLoader",
                            "similarity_score": 0.3215666320777134
                        },
                        {
                            "class_name": "BytesRefs",
                            "similarity_score": 0.4759537651200865
                        },
                        {
                            "class_name": "LogConfigurator",
                            "similarity_score": 0.5657182451085229
                        },
                        {
                            "class_name": "LoggerMessageFormat",
                            "similarity_score": 0.2567912019476508
                        },
                        {
                            "class_name": "Loggers",
                            "similarity_score": 0.3211300590522324
                        },
                        {
                            "class_name": "TransportActions",
                            "similarity_score": 0.20095923811712513
                        },
                        {
                            "class_name": "SequenceNumbers",
                            "similarity_score": 0.5553973523988169
                        },
                        {
                            "class_name": "NetworkExceptionHelper",
                            "similarity_score": 0.3150793650793651
                        },
                        {
                            "class_name": "TransportLogger",
                            "similarity_score": 0.2506790013801528
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "RestUtils",
                        "GeoUtils",
                        "HeaderWarning"
                    ],
                    "llm_response_time": 5098,
                    "similarity_computation_time": 87,
                    "similarity_metric": "cosine"
                },
                "notifySuccessfulSnapshotShard": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3746,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "notifyUnsuccessfulSnapshotShard": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 2913,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "cancelRemoved": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3118,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "syncShardStatsOnNewMaster": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 5040,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "startNewShardSnapshots": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 3305,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "handleUpdatedSnapshotsInProgressEntry": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4177,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/elastic/elasticsearch.git",
        "sha1": "5ca63c5b501a8c9d16eda6a3ff57c9ed0597cb3a",
        "url": "https://github.com/elastic/elasticsearch/commit/5ca63c5b501a8c9d16eda6a3ff57c9ed0597cb3a",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public countSource(context LocalExecutionPlannerContext, queryBuilder QueryBuilder, limit Expression) : LuceneCountOperator.Factory extracted from private planEsStats(statsQuery EsStatsQueryExec, context LocalExecutionPlannerContext) : PhysicalOperation in class org.elasticsearch.xpack.esql.planner.LocalExecutionPlanner & moved to class org.elasticsearch.xpack.esql.planner.EsPhysicalOperationProviders",
            "leftSideLocations": [
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/LocalExecutionPlanner.java",
                    "startLine": 244,
                    "endLine": 273,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "private planEsStats(statsQuery EsStatsQueryExec, context LocalExecutionPlannerContext) : PhysicalOperation"
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/LocalExecutionPlanner.java",
                    "startLine": 259,
                    "endLine": 259,
                    "startColumn": 9,
                    "endColumn": 77,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/LocalExecutionPlanner.java",
                    "startLine": 259,
                    "endLine": 259,
                    "startColumn": 68,
                    "endColumn": 76,
                    "codeElementType": "SIMPLE_NAME",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/EsPhysicalOperationProviders.java",
                    "startLine": 158,
                    "endLine": 169,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public countSource(context LocalExecutionPlannerContext, queryBuilder QueryBuilder, limit Expression) : LuceneCountOperator.Factory"
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/EsPhysicalOperationProviders.java",
                    "startLine": 162,
                    "endLine": 168,
                    "startColumn": 9,
                    "endColumn": 11,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/EsPhysicalOperationProviders.java",
                    "startLine": 167,
                    "endLine": 167,
                    "startColumn": 29,
                    "endColumn": 37,
                    "codeElementType": "SIMPLE_NAME",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/LocalExecutionPlanner.java",
                    "startLine": 240,
                    "endLine": 259,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "private planEsStats(statsQuery EsStatsQueryExec, context LocalExecutionPlannerContext) : PhysicalOperation"
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/LocalExecutionPlanner.java",
                    "startLine": 252,
                    "endLine": 252,
                    "startColumn": 54,
                    "endColumn": 138,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "esProvider.countSource(context,stat.filter(statsQuery.query()),statsQuery.limit())"
                }
            ],
            "isStatic": false
        },
        "ref_id": 93,
        "extraction_results": {
            "success": true,
            "newCommitHash": "928fa5f2bc4968785389740ffb5ab4988fafe33e",
            "newBranchName": "extract-countSource-planEsStats-063fc26"
        },
        "telemetry": {
            "id": "a9fdb41d-721f-4c64-8440-3b85d655dd36",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 692,
                "lineStart": 109,
                "lineEnd": 800,
                "bodyLineStart": 109,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/elasticsearch/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/LocalExecutionPlanner.java",
                "sourceCode": "/**\n * The local execution planner takes a plan (represented as PlanNode tree / digraph) as input and creates the corresponding\n * drivers that are used to execute the given plan.\n */\npublic class LocalExecutionPlanner {\n    private static final Logger logger = LogManager.getLogger(LocalExecutionPlanner.class);\n\n    private final String sessionId;\n    private final CancellableTask parentTask;\n    private final BigArrays bigArrays;\n    private final BlockFactory blockFactory;\n    private final Settings settings;\n    private final EsqlConfiguration configuration;\n    private final ExchangeSourceHandler exchangeSourceHandler;\n    private final ExchangeSinkHandler exchangeSinkHandler;\n    private final EnrichLookupService enrichLookupService;\n    private final PhysicalOperationProviders physicalOperationProviders;\n\n    public LocalExecutionPlanner(\n        String sessionId,\n        CancellableTask parentTask,\n        BigArrays bigArrays,\n        BlockFactory blockFactory,\n        Settings settings,\n        EsqlConfiguration configuration,\n        ExchangeSourceHandler exchangeSourceHandler,\n        ExchangeSinkHandler exchangeSinkHandler,\n        EnrichLookupService enrichLookupService,\n        PhysicalOperationProviders physicalOperationProviders\n    ) {\n        this.sessionId = sessionId;\n        this.parentTask = parentTask;\n        this.bigArrays = bigArrays;\n        this.blockFactory = blockFactory;\n        this.settings = settings;\n        this.exchangeSourceHandler = exchangeSourceHandler;\n        this.exchangeSinkHandler = exchangeSinkHandler;\n        this.enrichLookupService = enrichLookupService;\n        this.physicalOperationProviders = physicalOperationProviders;\n        this.configuration = configuration;\n    }\n\n    /**\n     * turn the given plan into a list of drivers to execute\n     */\n    public LocalExecutionPlan plan(PhysicalPlan node) {\n        var context = new LocalExecutionPlannerContext(\n            new ArrayList<>(),\n            new Holder<>(DriverParallelism.SINGLE),\n            configuration.pragmas(),\n            bigArrays,\n            blockFactory,\n            settings\n        );\n\n        // workaround for https://github.com/elastic/elasticsearch/issues/99782\n        node = node.transformUp(\n            AggregateExec.class,\n            a -> a.getMode() == AggregateExec.Mode.FINAL ? new ProjectExec(a.source(), a, Expressions.asAttributes(a.aggregates())) : a\n        );\n\n        PhysicalOperation physicalOperation = plan(node, context);\n\n        final TimeValue statusInterval = configuration.pragmas().statusInterval();\n        context.addDriverFactory(\n            new DriverFactory(\n                new DriverSupplier(context.bigArrays, context.blockFactory, physicalOperation, statusInterval, settings),\n                context.driverParallelism().get()\n            )\n        );\n\n        return new LocalExecutionPlan(context.driverFactories);\n    }\n\n    private PhysicalOperation plan(PhysicalPlan node, LocalExecutionPlannerContext context) {\n        if (node instanceof AggregateExec aggregate) {\n            return planAggregation(aggregate, context);\n        } else if (node instanceof FieldExtractExec fieldExtractExec) {\n            return planFieldExtractNode(context, fieldExtractExec);\n        } else if (node instanceof ExchangeExec exchangeExec) {\n            return planExchange(exchangeExec, context);\n        } else if (node instanceof TopNExec topNExec) {\n            return planTopN(topNExec, context);\n        } else if (node instanceof EvalExec eval) {\n            return planEval(eval, context);\n        } else if (node instanceof DissectExec dissect) {\n            return planDissect(dissect, context);\n        } else if (node instanceof GrokExec grok) {\n            return planGrok(grok, context);\n        } else if (node instanceof ProjectExec project) {\n            return planProject(project, context);\n        } else if (node instanceof FilterExec filter) {\n            return planFilter(filter, context);\n        } else if (node instanceof LimitExec limit) {\n            return planLimit(limit, context);\n        } else if (node instanceof MvExpandExec mvExpand) {\n            return planMvExpand(mvExpand, context);\n        }\n        // source nodes\n        else if (node instanceof EsQueryExec esQuery) {\n            return planEsQueryNode(esQuery, context);\n        } else if (node instanceof EsStatsQueryExec statsQuery) {\n            return planEsStats(statsQuery, context);\n        } else if (node instanceof RowExec row) {\n            return planRow(row, context);\n        } else if (node instanceof LocalSourceExec localSource) {\n            return planLocal(localSource, context);\n        } else if (node instanceof ShowExec show) {\n            return planShow(show);\n        } else if (node instanceof ExchangeSourceExec exchangeSource) {\n            return planExchangeSource(exchangeSource, context);\n        }\n        // lookups and joins\n        else if (node instanceof EnrichExec enrich) {\n            return planEnrich(enrich, context);\n        }\n        // output\n        else if (node instanceof OutputExec outputExec) {\n            return planOutput(outputExec, context);\n        } else if (node instanceof ExchangeSinkExec exchangeSink) {\n            return planExchangeSink(exchangeSink, context);\n        }\n\n        throw new EsqlIllegalArgumentException(\"unknown physical plan node [\" + node.nodeName() + \"]\");\n    }\n\n    private PhysicalOperation planAggregation(AggregateExec aggregate, LocalExecutionPlannerContext context) {\n        var source = plan(aggregate.child(), context);\n        return physicalOperationProviders.groupingPhysicalOperation(aggregate, source, context);\n    }\n\n    private PhysicalOperation planEsQueryNode(EsQueryExec esQueryExec, LocalExecutionPlannerContext context) {\n        return physicalOperationProviders.sourcePhysicalOperation(esQueryExec, context);\n    }\n\n    private PhysicalOperation planEsStats(EsStatsQueryExec statsQuery, LocalExecutionPlannerContext context) {\n        if (physicalOperationProviders instanceof EsPhysicalOperationProviders == false) {\n            throw new EsqlIllegalArgumentException(\"EsStatsQuery should only occur against a Lucene backend\");\n        }\n        if (statsQuery.stats().size() > 1) {\n            throw new EsqlIllegalArgumentException(\"EsStatsQuery currently supports only one field statistic\");\n        }\n\n        // for now only one stat is supported\n        EsStatsQueryExec.Stat stat = statsQuery.stats().get(0);\n\n        EsPhysicalOperationProviders esProvider = (EsPhysicalOperationProviders) physicalOperationProviders;\n        Function<SearchContext, Query> querySupplier = EsPhysicalOperationProviders.querySupplier(stat.filter(statsQuery.query()));\n\n        Expression limitExp = statsQuery.limit();\n        final LuceneOperator.Factory luceneFactory = countSource(context, limitExp, esProvider, querySupplier);\n\n        Layout.Builder layout = new Layout.Builder();\n        layout.append(statsQuery.outputSet());\n        int instanceCount = Math.max(1, luceneFactory.taskConcurrency());\n        context.driverParallelism(new DriverParallelism(DriverParallelism.Type.DATA_PARALLELISM, instanceCount));\n        return PhysicalOperation.fromSource(luceneFactory, layout.build());\n    }\n\n    private LuceneOperator.Factory countSource(LocalExecutionPlannerContext context, Expression limitExp, EsPhysicalOperationProviders esProvider, Function<SearchContext, Query> querySupplier) {\n        int limit = limitExp != null ? (Integer) limitExp.fold() : NO_LIMIT;\n        final LuceneOperator.Factory luceneFactory = new LuceneCountOperator.Factory(\n            esProvider.searchContexts(),\n            querySupplier,\n            context.queryPragmas().dataPartitioning(),\n            context.queryPragmas().taskConcurrency(),\n            limit\n        );\n        return luceneFactory;\n    }\n\n    private PhysicalOperation planFieldExtractNode(LocalExecutionPlannerContext context, FieldExtractExec fieldExtractExec) {\n        return physicalOperationProviders.fieldExtractPhysicalOperation(fieldExtractExec, plan(fieldExtractExec.child(), context));\n    }\n\n    private PhysicalOperation planOutput(OutputExec outputExec, LocalExecutionPlannerContext context) {\n        PhysicalOperation source = plan(outputExec.child(), context);\n        var output = outputExec.output();\n\n        return source.withSink(\n            new OutputOperatorFactory(\n                Expressions.names(output),\n                alignPageToAttributes(output, source.layout),\n                outputExec.getPageConsumer()\n            ),\n            source.layout\n        );\n    }\n\n    private static Function<Page, Page> alignPageToAttributes(List<Attribute> attrs, Layout layout) {\n        // align the page layout with the operator output\n        // extraction order - the list ordinal is the same as the column one\n        // while the value represents the position in the original page\n        final int[] mappedPosition = new int[attrs.size()];\n        int index = -1;\n        boolean transformRequired = false;\n        for (var attribute : attrs) {\n            mappedPosition[++index] = layout.get(attribute.id()).channel();\n            transformRequired |= mappedPosition[index] != index;\n        }\n        Function<Page, Page> transformer = transformRequired ? p -> {\n            var blocks = new Block[mappedPosition.length];\n            for (int i = 0; i < blocks.length; i++) {\n                blocks[i] = p.getBlock(mappedPosition[i]);\n                blocks[i].incRef();\n            }\n            p.releaseBlocks();\n            return new Page(blocks);\n        } : Function.identity();\n\n        return transformer;\n    }\n\n    private PhysicalOperation planExchange(ExchangeExec exchangeExec, LocalExecutionPlannerContext context) {\n        throw new UnsupportedOperationException(\"Exchange needs to be replaced with a sink/source\");\n    }\n\n    private PhysicalOperation planExchangeSink(ExchangeSinkExec exchangeSink, LocalExecutionPlannerContext context) {\n        Objects.requireNonNull(exchangeSinkHandler, \"ExchangeSinkHandler wasn't provided\");\n        var child = exchangeSink.child();\n\n        PhysicalOperation source = plan(child, context);\n\n        Function<Page, Page> transformer = exchangeSink.isIntermediateAgg()\n            ? Function.identity()\n            : alignPageToAttributes(exchangeSink.output(), source.layout);\n\n        return source.withSink(new ExchangeSinkOperatorFactory(exchangeSinkHandler::createExchangeSink, transformer), source.layout);\n    }\n\n    private PhysicalOperation planExchangeSource(ExchangeSourceExec exchangeSource, LocalExecutionPlannerContext context) {\n        Objects.requireNonNull(exchangeSourceHandler, \"ExchangeSourceHandler wasn't provided\");\n\n        var builder = new Layout.Builder();\n        builder.append(exchangeSource.output());\n        // decorate the layout\n        var l = builder.build();\n        var layout = exchangeSource.isIntermediateAgg() ? new ExchangeLayout(l) : l;\n\n        return PhysicalOperation.fromSource(new ExchangeSourceOperatorFactory(exchangeSourceHandler::createExchangeSource), layout);\n    }\n\n    private PhysicalOperation planTopN(TopNExec topNExec, LocalExecutionPlannerContext context) {\n        PhysicalOperation source = plan(topNExec.child(), context);\n\n        ElementType[] elementTypes = new ElementType[source.layout.numberOfChannels()];\n        TopNEncoder[] encoders = new TopNEncoder[source.layout.numberOfChannels()];\n        List<Layout.ChannelSet> inverse = source.layout.inverse();\n        for (int channel = 0; channel < inverse.size(); channel++) {\n            elementTypes[channel] = PlannerUtils.toElementType(inverse.get(channel).type());\n            encoders[channel] = switch (inverse.get(channel).type().typeName()) {\n                case \"ip\" -> TopNEncoder.IP;\n                case \"text\", \"keyword\" -> TopNEncoder.UTF8;\n                case \"version\" -> TopNEncoder.VERSION;\n                case \"boolean\", \"null\", \"byte\", \"short\", \"integer\", \"long\", \"double\", \"float\", \"half_float\", \"datetime\", \"date_period\",\n                    \"time_duration\", \"object\", \"nested\", \"scaled_float\", \"unsigned_long\", \"_doc\" -> TopNEncoder.DEFAULT_SORTABLE;\n                case \"geo_point\", \"cartesian_point\" -> TopNEncoder.DEFAULT_UNSORTABLE;\n                // unsupported fields are encoded as BytesRef, we'll use the same encoder; all values should be null at this point\n                case \"unsupported\" -> TopNEncoder.UNSUPPORTED;\n                default -> throw new EsqlIllegalArgumentException(\"No TopN sorting encoder for type \" + inverse.get(channel).type());\n            };\n        }\n        List<TopNOperator.SortOrder> orders = topNExec.order().stream().map(order -> {\n            int sortByChannel;\n            if (order.child() instanceof Attribute a) {\n                sortByChannel = source.layout.get(a.id()).channel();\n            } else {\n                throw new EsqlIllegalArgumentException(\"order by expression must be an attribute\");\n            }\n\n            return new TopNOperator.SortOrder(\n                sortByChannel,\n                order.direction().equals(Order.OrderDirection.ASC),\n                order.nullsPosition().equals(Order.NullsPosition.FIRST)\n            );\n        }).toList();\n\n        int limit;\n        if (topNExec.limit() instanceof Literal literal) {\n            limit = Integer.parseInt(literal.value().toString());\n        } else {\n            throw new EsqlIllegalArgumentException(\"limit only supported with literal values\");\n        }\n\n        // TODO Replace page size with passing estimatedRowSize down\n        /*\n         * The 2000 below is a hack to account for incoming size and to make\n         * sure the estimated row size is never 0 which'd cause a divide by 0.\n         * But we should replace this with passing the estimate into the real\n         * topn and letting it actually measure the size of rows it produces.\n         * That'll be more accurate. And we don't have a path for estimating\n         * incoming rows. And we don't need one because we can estimate.\n         */\n        return source.with(\n            new TopNOperatorFactory(\n                limit,\n                asList(elementTypes),\n                asList(encoders),\n                orders,\n                context.pageSize(2000 + topNExec.estimatedRowSize())\n            ),\n            source.layout\n        );\n    }\n\n    private PhysicalOperation planEval(EvalExec eval, LocalExecutionPlannerContext context) {\n        PhysicalOperation source = plan(eval.child(), context);\n\n        for (Alias field : eval.fields()) {\n            var evaluatorSupplier = EvalMapper.toEvaluator(field.child(), source.layout);\n            Layout.Builder layout = source.layout.builder();\n            layout.append(field.toAttribute());\n            source = source.with(new EvalOperatorFactory(evaluatorSupplier), layout.build());\n        }\n        return source;\n    }\n\n    private PhysicalOperation planDissect(DissectExec dissect, LocalExecutionPlannerContext context) {\n        PhysicalOperation source = plan(dissect.child(), context);\n        Layout.Builder layoutBuilder = source.layout.builder();\n        layoutBuilder.append(dissect.extractedFields());\n        final Expression expr = dissect.inputExpression();\n        String[] attributeNames = Expressions.names(dissect.extractedFields()).toArray(new String[0]);\n\n        Layout layout = layoutBuilder.build();\n        source = source.with(\n            new StringExtractOperator.StringExtractOperatorFactory(\n                attributeNames,\n                EvalMapper.toEvaluator(expr, layout),\n                () -> (input) -> dissect.parser().parser().parse(input)\n            ),\n            layout\n        );\n        return source;\n    }\n\n    private PhysicalOperation planGrok(GrokExec grok, LocalExecutionPlannerContext context) {\n        PhysicalOperation source = plan(grok.child(), context);\n        Layout.Builder layoutBuilder = source.layout.builder();\n        List<Attribute> extractedFields = grok.extractedFields();\n        layoutBuilder.append(extractedFields);\n        Map<String, Integer> fieldToPos = new HashMap<>(extractedFields.size());\n        Map<String, ElementType> fieldToType = new HashMap<>(extractedFields.size());\n        ElementType[] types = new ElementType[extractedFields.size()];\n        for (int i = 0; i < extractedFields.size(); i++) {\n            Attribute extractedField = extractedFields.get(i);\n            ElementType type = PlannerUtils.toElementType(extractedField.dataType());\n            fieldToPos.put(extractedField.name(), i);\n            fieldToType.put(extractedField.name(), type);\n            types[i] = type;\n        }\n\n        Layout layout = layoutBuilder.build();\n        source = source.with(\n            new ColumnExtractOperator.Factory(\n                types,\n                EvalMapper.toEvaluator(grok.inputExpression(), layout),\n                () -> new GrokEvaluatorExtracter(grok.pattern().grok(), grok.pattern().pattern(), fieldToPos, fieldToType)\n            ),\n            layout\n        );\n        return source;\n    }\n\n    private PhysicalOperation planEnrich(EnrichExec enrich, LocalExecutionPlannerContext context) {\n        PhysicalOperation source = plan(enrich.child(), context);\n        Layout.Builder layoutBuilder = source.layout.builder();\n        layoutBuilder.append(enrich.enrichFields());\n        Layout layout = layoutBuilder.build();\n        Set<String> indices = enrich.enrichIndex().concreteIndices();\n        if (indices.size() != 1) {\n            throw new EsqlIllegalArgumentException(\"Resolved enrich should have one concrete index; got \" + indices);\n        }\n        String enrichIndex = Iterables.get(indices, 0);\n        return source.with(\n            new EnrichLookupOperator.Factory(\n                sessionId,\n                parentTask,\n                context.queryPragmas().enrichMaxWorkers(),\n                source.layout.get(enrich.matchField().id()).channel(),\n                enrichLookupService,\n                enrichIndex,\n                \"match\", // TODO: enrich should also resolve the match_type\n                enrich.policyMatchField(),\n                enrich.enrichFields()\n            ),\n            layout\n        );\n    }\n\n    private ExpressionEvaluator.Factory toEvaluator(Expression exp, Layout layout) {\n        return EvalMapper.toEvaluator(exp, layout);\n    }\n\n    private PhysicalOperation planRow(RowExec row, LocalExecutionPlannerContext context) {\n        List<Object> obj = row.fields().stream().map(f -> f.child().fold()).toList();\n        Layout.Builder layout = new Layout.Builder();\n        layout.append(row.output());\n        return PhysicalOperation.fromSource(new RowOperatorFactory(obj), layout.build());\n    }\n\n    private PhysicalOperation planLocal(LocalSourceExec localSourceExec, LocalExecutionPlannerContext context) {\n        Layout.Builder layout = new Layout.Builder();\n        layout.append(localSourceExec.output());\n        LocalSourceOperator.BlockSupplier supplier = () -> localSourceExec.supplier().get();\n        var operator = new LocalSourceOperator(supplier);\n        return PhysicalOperation.fromSource(new LocalSourceFactory(() -> operator), layout.build());\n    }\n\n    private PhysicalOperation planShow(ShowExec showExec) {\n        Layout.Builder layout = new Layout.Builder();\n        layout.append(showExec.output());\n        return PhysicalOperation.fromSource(new ShowOperator.ShowOperatorFactory(showExec.values()), layout.build());\n    }\n\n    private PhysicalOperation planProject(ProjectExec project, LocalExecutionPlannerContext context) {\n        var source = plan(project.child(), context);\n        List<? extends NamedExpression> projections = project.projections();\n        List<Integer> projectionList = new ArrayList<>(projections.size());\n\n        Layout.Builder layout = new Layout.Builder();\n        Map<Integer, Layout.ChannelSet> inputChannelToOutputIds = new HashMap<>();\n        for (int index = 0, size = projections.size(); index < size; index++) {\n            NamedExpression ne = projections.get(index);\n\n            NameId inputId;\n            if (ne instanceof Alias a) {\n                inputId = ((NamedExpression) a.child()).id();\n            } else {\n                inputId = ne.id();\n            }\n            Layout.ChannelAndType input = source.layout.get(inputId);\n            Layout.ChannelSet channelSet = inputChannelToOutputIds.get(input.channel());\n            if (channelSet == null) {\n                channelSet = new Layout.ChannelSet(new HashSet<>(), input.type());\n                channelSet.nameIds().add(ne.id());\n                layout.append(channelSet);\n            } else {\n                channelSet.nameIds().add(ne.id());\n            }\n            if (channelSet.type() != input.type()) {\n                throw new IllegalArgumentException(\"type mismatch for aliases\");\n            }\n            projectionList.add(input.channel());\n        }\n\n        return source.with(new ProjectOperatorFactory(projectionList), layout.build());\n    }\n\n    private PhysicalOperation planFilter(FilterExec filter, LocalExecutionPlannerContext context) {\n        PhysicalOperation source = plan(filter.child(), context);\n        // TODO: should this be extracted into a separate eval block?\n        return source.with(new FilterOperatorFactory(toEvaluator(filter.condition(), source.layout)), source.layout);\n    }\n\n    private PhysicalOperation planLimit(LimitExec limit, LocalExecutionPlannerContext context) {\n        PhysicalOperation source = plan(limit.child(), context);\n        return source.with(new Factory((Integer) limit.limit().fold()), source.layout);\n    }\n\n    private PhysicalOperation planMvExpand(MvExpandExec mvExpandExec, LocalExecutionPlannerContext context) {\n        PhysicalOperation source = plan(mvExpandExec.child(), context);\n        int blockSize = 5000;// TODO estimate row size and use context.pageSize()\n        Layout.Builder layout = source.layout.builder();\n        layout.replace(mvExpandExec.target().id(), mvExpandExec.expanded().id());\n        return source.with(\n            new MvExpandOperator.Factory(source.layout.get(mvExpandExec.target().id()).channel(), blockSize),\n            layout.build()\n        );\n    }\n\n    /**\n     * Immutable physical operation.\n     */\n    public static class PhysicalOperation implements Describable {\n        final SourceOperatorFactory sourceOperatorFactory;\n        final List<OperatorFactory> intermediateOperatorFactories;\n        final SinkOperatorFactory sinkOperatorFactory;\n\n        final Layout layout; // maps field names to channels\n\n        /** Creates a new physical operation with the given source and layout. */\n        static PhysicalOperation fromSource(SourceOperatorFactory sourceOperatorFactory, Layout layout) {\n            return new PhysicalOperation(sourceOperatorFactory, layout);\n        }\n\n        /** Creates a new physical operation from this operation with the given layout. */\n        PhysicalOperation with(Layout layout) {\n            return new PhysicalOperation(this, Optional.empty(), Optional.empty(), layout);\n        }\n\n        /** Creates a new physical operation from this operation with the given intermediate operator and layout. */\n        PhysicalOperation with(OperatorFactory operatorFactory, Layout layout) {\n            return new PhysicalOperation(this, Optional.of(operatorFactory), Optional.empty(), layout);\n        }\n\n        /** Creates a new physical operation from this operation with the given sink and layout. */\n        PhysicalOperation withSink(SinkOperatorFactory sink, Layout layout) {\n            return new PhysicalOperation(this, Optional.empty(), Optional.of(sink), layout);\n        }\n\n        private PhysicalOperation(SourceOperatorFactory sourceOperatorFactory, Layout layout) {\n            this.sourceOperatorFactory = sourceOperatorFactory;\n            this.intermediateOperatorFactories = List.of();\n            this.sinkOperatorFactory = null;\n            this.layout = layout;\n        }\n\n        private PhysicalOperation(\n            PhysicalOperation physicalOperation,\n            Optional<OperatorFactory> intermediateOperatorFactory,\n            Optional<SinkOperatorFactory> sinkOperatorFactory,\n            Layout layout\n        ) {\n            sourceOperatorFactory = physicalOperation.sourceOperatorFactory;\n            intermediateOperatorFactories = new ArrayList<>();\n            intermediateOperatorFactories.addAll(physicalOperation.intermediateOperatorFactories);\n            intermediateOperatorFactory.ifPresent(intermediateOperatorFactories::add);\n            this.sinkOperatorFactory = sinkOperatorFactory.isPresent() ? sinkOperatorFactory.get() : null;\n            this.layout = layout;\n        }\n\n        public SourceOperator source(DriverContext driverContext) {\n            return sourceOperatorFactory.get(driverContext);\n        }\n\n        public void operators(List<Operator> operators, DriverContext driverContext) {\n            intermediateOperatorFactories.stream().map(opFactory -> opFactory.get(driverContext)).forEach(operators::add);\n        }\n\n        public SinkOperator sink(DriverContext driverContext) {\n            return sinkOperatorFactory.get(driverContext);\n        }\n\n        @Override\n        public String describe() {\n            return Stream.concat(\n                Stream.concat(Stream.of(sourceOperatorFactory), intermediateOperatorFactories.stream()),\n                Stream.of(sinkOperatorFactory)\n            ).map(Describable::describe).collect(joining(\"\\n\\\\_\", \"\\\\_\", \"\"));\n        }\n    }\n\n    /**\n     * The count and type of driver parallelism.\n     */\n    record DriverParallelism(Type type, int instanceCount) {\n\n        DriverParallelism {\n            if (instanceCount <= 0) {\n                throw new IllegalArgumentException(\"instance count must be greater than zero; got: \" + instanceCount);\n            }\n        }\n\n        static final DriverParallelism SINGLE = new DriverParallelism(Type.SINGLETON, 1);\n\n        enum Type {\n            SINGLETON,\n            DATA_PARALLELISM,\n            TASK_LEVEL_PARALLELISM\n        }\n    }\n\n    /**\n     * Context object used while generating a local plan. Currently only collects the driver factories as well as\n     * maintains information how many driver instances should be created for a given driver.\n     */\n    public record LocalExecutionPlannerContext(\n        List<DriverFactory> driverFactories,\n        Holder<DriverParallelism> driverParallelism,\n        QueryPragmas queryPragmas,\n        BigArrays bigArrays,\n        BlockFactory blockFactory,\n        Settings settings\n    ) {\n        void addDriverFactory(DriverFactory driverFactory) {\n            driverFactories.add(driverFactory);\n        }\n\n        void driverParallelism(DriverParallelism parallelism) {\n            driverParallelism.set(parallelism);\n        }\n\n        int pageSize(Integer estimatedRowSize) {\n            if (estimatedRowSize == null) {\n                throw new IllegalStateException(\"estimated row size hasn't been set\");\n            }\n            if (estimatedRowSize == 0) {\n                throw new IllegalStateException(\"estimated row size can't be 0\");\n            }\n            if (queryPragmas.pageSize() != 0) {\n                return queryPragmas.pageSize();\n            }\n            return Math.max(SourceOperator.MIN_TARGET_PAGE_SIZE, SourceOperator.TARGET_PAGE_SIZE / estimatedRowSize);\n        }\n    }\n\n    record DriverSupplier(\n        BigArrays bigArrays,\n        BlockFactory blockFactory,\n        PhysicalOperation physicalOperation,\n        TimeValue statusInterval,\n        Settings settings\n    ) implements Function<String, Driver>, Describable {\n        @Override\n        public Driver apply(String sessionId) {\n            SourceOperator source = null;\n            List<Operator> operators = new ArrayList<>();\n            SinkOperator sink = null;\n            boolean success = false;\n            var localBreakerSettings = new LocalCircuitBreaker.SizeSettings(settings);\n            final var localBreaker = new LocalCircuitBreaker(\n                blockFactory.breaker(),\n                localBreakerSettings.overReservedBytes(),\n                localBreakerSettings.maxOverReservedBytes()\n            );\n            var driverContext = new DriverContext(bigArrays, blockFactory.newChildFactory(localBreaker));\n            try {\n                source = physicalOperation.source(driverContext);\n                physicalOperation.operators(operators, driverContext);\n                sink = physicalOperation.sink(driverContext);\n                success = true;\n                return new Driver(\n                    sessionId,\n                    driverContext,\n                    physicalOperation::describe,\n                    source,\n                    operators,\n                    sink,\n                    statusInterval,\n                    localBreaker\n                );\n            } finally {\n                if (false == success) {\n                    Releasables.close(source, () -> Releasables.close(operators), sink, localBreaker);\n                }\n            }\n        }\n\n        @Override\n        public String describe() {\n            return physicalOperation.describe();\n        }\n    }\n\n    record DriverFactory(DriverSupplier driverSupplier, DriverParallelism driverParallelism) implements Describable {\n        @Override\n        public String describe() {\n            return \"DriverFactory(instances = \"\n                + driverParallelism.instanceCount()\n                + \", type = \"\n                + driverParallelism.type()\n                + \")\\n\"\n                + driverSupplier.describe();\n        }\n    }\n\n    /**\n     * Plan representation that is geared towards execution on a single node\n     */\n    public static class LocalExecutionPlan implements Describable {\n        final List<DriverFactory> driverFactories;\n\n        LocalExecutionPlan(List<DriverFactory> driverFactories) {\n            this.driverFactories = driverFactories;\n        }\n\n        public List<Driver> createDrivers(String sessionId) {\n            List<Driver> drivers = new ArrayList<>();\n            boolean success = false;\n            try {\n                for (DriverFactory df : driverFactories) {\n                    for (int i = 0; i < df.driverParallelism.instanceCount; i++) {\n                        logger.trace(\"building {} {}\", i, df);\n                        drivers.add(df.driverSupplier.apply(sessionId));\n                    }\n                }\n                success = true;\n                return drivers;\n            } finally {\n                if (success == false) {\n                    Releasables.close(Releasables.wrap(drivers));\n                }\n            }\n        }\n\n        @Override\n        public String describe() {\n            return driverFactories.stream().map(DriverFactory::describe).collect(joining(\"\\n\"));\n        }\n    }\n}",
                "methodCount": 46
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 15,
                "candidates": [
                    {
                        "lineStart": 634,
                        "lineEnd": 636,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method operators to class SinkOperatorFactory",
                        "description": "Move method operators to org.elasticsearch.compute.operator.SinkOperator.SinkOperatorFactory\nRationale: The method 'operators' deals with creating and adding operators using operator factories. Since SinkOperatorFactory is specifically designed for creating sink operators, it is appropriate to place this method in this class. The method's reliance on 'intermediateOperatorFactories' and 'get(driverContext)' aligns well with the responsibilities of a factory class that creates operators, making SinkOperatorFactory a suitable target.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 279,
                        "lineEnd": 281,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method planFieldExtractNode to class PhysicalOperationProviders",
                        "description": "Move method planFieldExtractNode to org.elasticsearch.xpack.esql.planner.PhysicalOperationProviders\nRationale: The method 'planFieldExtractNode' relates directly to the 'fieldExtractPhysicalOperation' method, which is a part of 'PhysicalOperationProviders'. Moving it here maintains consistency and makes the codebase more coherent. The 'PhysicalOperationProviders' class already manages the creation of physical operations, which includes handling field extraction operations, making it a suitable location for this method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 630,
                        "lineEnd": 632,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method source to class SourceOperatorFactory",
                        "description": "Move method source to org.elasticsearch.compute.operator.SourceOperator.SourceOperatorFactory\nRationale: The method 'source' is directly calling 'sourceOperatorFactory.get(driverContext)'. This means that the responsibility of creating or retrieving a 'SourceOperator' lies with the 'SourceOperatorFactory'. Moving this method to the 'SourceOperatorFactory' class would be the most appropriate choice because it maintains the single responsibility principle and encapsulates the factory logic within the factory class itself.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 638,
                        "lineEnd": 640,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method sink to class SinkOperatorFactory",
                        "description": "Move method sink to org.elasticsearch.compute.operator.SinkOperator.SinkOperatorFactory\nRationale: The method `sink(DriverContext driverContext)` is responsible for returning a `SinkOperator` by utilizing the `SinkOperatorFactory`. This indicates a strong conceptual relationship with the `SinkOperatorFactory` class. Moving the method to this class will enhance cohesion as it logically fits into the responsibility of a factory creating sink operators. Additionally, aligning this method with its associated operations inside the `SinkOperatorFactory` will make the codebase easier to understand and maintain.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 267,
                        "lineEnd": 277,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method countSource to class EsPhysicalOperationProviders",
                        "description": "Move method countSource to org.elasticsearch.xpack.esql.planner.EsPhysicalOperationProviders\nRationale: The method countSource() is directly concerned with the creation of LuceneOperator.Factory based on the given context and esProvider. This type of operation falls under the responsibility of EsPhysicalOperationProviders, which is already involved in similar operations. Additionally, this class already has access to search contexts and similar configurations, making it the most appropriate place for the countSource() method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 182,
                        "lineEnd": 232,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method plan to class PhysicalOperationProviders",
                        "description": "Move method plan to org.elasticsearch.xpack.esql.planner.PhysicalOperationProviders\nRationale: The method `plan` handles different types of PhysicalPlan nodes to generate PhysicalOperations, a task closely related to the responsibilities of the PhysicalOperationProviders interface. Since this class already provides methods for generating different types of PhysicalOperations, consolidating the planning logic here improves cohesion and adheres to the Single Responsibility Principle.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 557,
                        "lineEnd": 561,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method planFilter to class PhysicalOperationProviders",
                        "description": "Move method planFilter to org.elasticsearch.xpack.esql.planner.PhysicalOperationProviders\nRationale: The method planFilter() is responsible for planning the physical operation for a FilterExec. This type of logic aligns more closely with the responsibilities of the PhysicalOperationProviders interface, which already includes methods for planning different types of physical operations. By moving this method to PhysicalOperationProviders, we can better encapsulate the planning logic within a single interface dedicated to handling various physical operations.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 239,
                        "lineEnd": 241,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method planEsQueryNode to class PhysicalOperationProviders",
                        "description": "Move method planEsQueryNode to org.elasticsearch.xpack.esql.planner.PhysicalOperationProviders\nRationale: The method planEsQueryNode() relies directly on physicalOperationProviders.sourcePhysicalOperation(esQueryExec, context) and is conceptually part of creating PhysicalOperation instances. Placing this method in PhysicalOperationProviders maintains logical consistency and encapsulates all the sourcePhysicalOperation functionality within one class, making the code more cohesive and easier to maintain.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 691,
                        "lineEnd": 702,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method pageSize to class QueryPragmas",
                        "description": "Move method pageSize to org.elasticsearch.xpack.esql.plugin.QueryPragmas\nRationale: The method 'pageSize' relies heavily on the QueryPragmas class. Specifically, it references the pageSize method of QueryPragmas directly, which indicates that it is concerned with the settings encapsulated by QueryPragmas. Therefore, it is more appropriate for this method to reside within the QueryPragmas class itself. This ensures that all logic related to page size and related query settings are encapsulated within the same class, following the principle of cohesion.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 325,
                        "lineEnd": 336,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method planExchangeSink to class PhysicalOperationProviders",
                        "description": "Move method planExchangeSink to org.elasticsearch.xpack.esql.planner.PhysicalOperationProviders\nRationale: The method 'planExchangeSink' is responsible for converting an 'ExchangeSinkExec' into a 'PhysicalOperation'. This aligns with the responsibilities of 'PhysicalOperationProviders', which already provides physical operations for various executables. Moreover, 'PhysicalOperationProviders' interacts with 'LocalExecutionPlannerContext' in a similar manner as the method in question, making it a natural fit.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 563,
                        "lineEnd": 566,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method planLimit to class PhysicalOperationProviders",
                        "description": "Move method planLimit to org.elasticsearch.xpack.esql.planner.PhysicalOperationProviders\nRationale: The method 'planLimit' deals with planning and returning a 'PhysicalOperation', which aligns closely with the responsibilities of the 'PhysicalOperationProviders' interface. This interface already includes methods for generating 'PhysicalOperation' instances based on various execution strategies, making it a suitable candidate for hosting the 'planLimit' method. This method does not fit well with 'LocalExecutionPlannerContext' as that class is meant for managing context-related data and configurations, not for planning physical operations. The 'Logger' class is irrelevant as it is specifically for logging functionalities.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 234,
                        "lineEnd": 237,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method planAggregation to class PhysicalOperationProviders",
                        "description": "Move method planAggregation to org.elasticsearch.xpack.esql.planner.PhysicalOperationProviders\nRationale: The 'planAggregation' method utilizes the 'groupingPhysicalOperation' method from the 'PhysicalOperationProviders' interface. Given that 'PhysicalOperationProviders' already defines various physical operations, including grouping physical operations, 'planAggregation' is conceptually aligned with its responsibilities. This class encapsulates the logic related to physical operations, making it the most appropriate place for the method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 150,
                        "lineEnd": 180,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method plan to class PhysicalOperationProviders",
                        "description": "Move method plan to org.elasticsearch.xpack.esql.planner.PhysicalOperationProviders\nRationale: The 'plan' method is responsible for turning a physical plan into a local execution plan, which aligns well with the responsibilities of the 'PhysicalOperationProviders' interface. This interface already provides methods associated with transforming various execution operations into physical operations, and the 'plan' method fits the overarching goal of planning and execution. Moving the 'plan' method to the 'PhysicalOperationProviders' class retains cohesion and keeps related functionality together, promoting better organization and maintenance.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 338,
                        "lineEnd": 348,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method planExchangeSource to class PhysicalOperationProviders",
                        "description": "Move method planExchangeSource to org.elasticsearch.xpack.esql.planner.PhysicalOperationProviders\nRationale: The method `planExchangeSource` is involved in planning and creating a `PhysicalOperation`, which fits directly into the responsibilities of the `PhysicalOperationProviders` interface. Moving the method there will align it with the other methods that also create various `PhysicalOperation` instances based on different execution contexts. Additionally, it ensures that all physical operation planning logic is consolidated, enhancing maintainability and coherence.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 283,
                        "lineEnd": 295,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method planOutput to class PhysicalOperationProviders",
                        "description": "Move method planOutput to org.elasticsearch.xpack.esql.planner.PhysicalOperationProviders\nRationale: The method planOutput aligns closely with the operations defined in the PhysicalOperationProviders interface, which include methods that plan and return PhysicalOperation instances. This interface already handles similar responsibilities, such as generating physical operations for different execution contexts. Moving the method here consolidates the planning logic in one place, making the code more cohesive and manageable.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "planAggregation",
                            "method_signature": "private PhysicalOperation planAggregation(AggregateExec aggregate, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The planAggregation method deals with the details of creating a PhysicalOperation for aggregation, which is closely tied to the PhysicalOperationProviders class."
                        },
                        {
                            "method_name": "planEsQueryNode",
                            "method_signature": "private PhysicalOperation planEsQueryNode(EsQueryExec esQueryExec, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The planEsQueryNode method is highly specific to creating operations for ES queries, suggesting that it belongs in the PhysicalOperationProviders class."
                        },
                        {
                            "method_name": "planEsStats",
                            "method_signature": "private PhysicalOperation planEsStats(EsStatsQueryExec statsQuery, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The method deals with creating PhysicalOperations specific to statistics queries, which aligns better with the general purpose of the PhysicalOperationProviders class."
                        },
                        {
                            "method_name": "countSource",
                            "method_signature": "private LuceneOperator.Factory countSource(LocalExecutionPlannerContext context, Expression limitExp, EsPhysicalOperationProviders esProvider, Function<SearchContext, Query> querySupplier)",
                            "target_class": "EsPhysicalOperationProviders",
                            "rationale": "The countSource method handles details specific to ES operations and it would be more appropriately placed within the EsPhysicalOperationProviders class."
                        },
                        {
                            "method_name": "planFieldExtractNode",
                            "method_signature": "private PhysicalOperation planFieldExtractNode(LocalExecutionPlannerContext context, FieldExtractExec fieldExtractExec)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "This method primarily focuses on planning a field extraction execution, which it is tightly coupled with PhysicalOperationProviders."
                        },
                        {
                            "method_name": "planOutput",
                            "method_signature": "private PhysicalOperation planOutput(OutputExec outputExec, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "This method is responsible for creating and configuring a PhysicalOperation specific to output, fitting the role played by PhysicalOperationProviders."
                        },
                        {
                            "method_name": "alignPageToAttributes",
                            "method_signature": "private static Function<Page, Page> alignPageToAttributes(List<Attribute> attrs, Layout layout)",
                            "target_class": "Layout",
                            "rationale": "The function operates on aligning pages to attributes which closely pertains to the responsibilities managed by the Layout class."
                        },
                        {
                            "method_name": "planGrok",
                            "method_signature": "private PhysicalOperation planGrok(GrokExec grok, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The planning of grok operations should be managed by the PhysicalOperationProviders class, as it deals with how the physical operation is constructed."
                        },
                        {
                            "method_name": "planEnrich",
                            "method_signature": "private PhysicalOperation planEnrich(EnrichExec enrich, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The planning of enriched exec is logically part of the operation provider, which should handle all types of operation specifics."
                        },
                        {
                            "method_name": "planRow",
                            "method_signature": "private PhysicalOperation planRow(RowExec row, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The method involves construction of row-based physical operations, thus should belong to PhysicalOperationProviders."
                        },
                        {
                            "method_name": "planShow",
                            "method_signature": "private PhysicalOperation planShow(ShowExec showExec)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "This method is responsible for creating a PhysicalOperation for the 'show' execution, so it should be part of PhysicalOperationProviders."
                        },
                        {
                            "method_name": "planProject",
                            "method_signature": "private PhysicalOperation planProject(ProjectExec project, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The planning and configuration of project execution should logically be handled by PhysicalOperationProviders, which deals with all operation specifics."
                        },
                        {
                            "method_name": "planFilter",
                            "method_signature": "private PhysicalOperation planFilter(FilterExec filter, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "Filtering is a specific physical operation that fits well within the scope of PhysicalOperationProviders."
                        },
                        {
                            "method_name": "planLimit",
                            "method_signature": "private PhysicalOperation planLimit(LimitExec limit, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The limit operation is another form of physical operation planning that should belong to PhysicalOperationProviders."
                        },
                        {
                            "method_name": "planMvExpand",
                            "method_signature": "private PhysicalOperation planMvExpand(MvExpandExec mvExpandExec, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "This method deals with multi-value expansion operations, indicating it fits within the domain of PhysicalOperationProviders."
                        }
                    ],
                    "llm_response_time": 13658
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "planAggregation",
                            "method_signature": "private PhysicalOperation planAggregation(AggregateExec aggregate, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The method planAggregation deals specifically with the planning of aggregation operations. These operations are contextually tied to the logic within PhysicalOperationProviders."
                        },
                        {
                            "method_name": "planEsQueryNode",
                            "method_signature": "private PhysicalOperation planEsQueryNode(EsQueryExec esQueryExec, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The method planEsQueryNode handles the planning of ES query nodes, which should be a responsibility of PhysicalOperationProviders that consolidates various physical planning operations."
                        },
                        {
                            "method_name": "planEsStats",
                            "method_signature": "private PhysicalOperation planEsStats(EsStatsQueryExec statsQuery, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The method planEsStats involves the planning logic of ES statistics queries, which logically belongs in PhysicalOperationProviders."
                        },
                        {
                            "method_name": "planFieldExtractNode",
                            "method_signature": "private PhysicalOperation planFieldExtractNode(LocalExecutionPlannerContext context, FieldExtractExec fieldExtractExec)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The method planFieldExtractNode manages field extraction node planning, which aligns with the responsibilities of PhysicalOperationProviders."
                        },
                        {
                            "method_name": "planOutput",
                            "method_signature": "private PhysicalOperation planOutput(OutputExec outputExec, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The method planOutput involves the planning of output operations, making it more appropriate for placement within PhysicalOperationProviders."
                        },
                        {
                            "method_name": "planDissect",
                            "method_signature": "private PhysicalOperation planDissect(DissectExec dissect, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The method planDissect involves the planning logic for dissect operations, making it suitable to be moved to PhysicalOperationProviders."
                        },
                        {
                            "method_name": "planGrok",
                            "method_signature": "private PhysicalOperation planGrok(GrokExec grok, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The method planGrok is responsible for planning Grok operations which should be a concern of PhysicalOperationProviders."
                        },
                        {
                            "method_name": "planEnrich",
                            "method_signature": "private PhysicalOperation planEnrich(EnrichExec enrich, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The method planEnrich deals with planning enrich operations, making it more logically placed within PhysicalOperationProviders."
                        }
                    ],
                    "llm_response_time": 8593
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "planAggregation",
                            "method_signature": "private PhysicalOperation planAggregation(AggregateExec aggregate, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The method `planAggregation` uses primarily `physicalOperationProviders` and deals with planning physical operations, suggesting that it would be more logically placed within the `PhysicalOperationProviders` class."
                        },
                        {
                            "method_name": "planEsQueryNode",
                            "method_signature": "private PhysicalOperation planEsQueryNode(EsQueryExec esQueryExec, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The method `planEsQueryNode` directly utilizes `physicalOperationProviders` to plan a query node, which makes it more suitable to be located in the `PhysicalOperationProviders` class."
                        },
                        {
                            "method_name": "planEsStats",
                            "method_signature": "private PhysicalOperation planEsStats(EsStatsQueryExec statsQuery, LocalExecutionPlannerContext context)",
                            "target_class": "EsPhysicalOperationProviders",
                            "rationale": "The method `planEsStats` involves multiple type checks and operations related to `EsPhysicalOperationProviders`, making it a better fit within the `EsPhysicalOperationProviders` class."
                        },
                        {
                            "method_name": "countSource",
                            "method_signature": "private LuceneOperator.Factory countSource(LocalExecutionPlannerContext context, Expression limitExp, EsPhysicalOperationProviders esProvider, Function<SearchContext, Query> querySupplier)",
                            "target_class": "EsPhysicalOperationProviders",
                            "rationale": "The `countSource` method is specifically tied to the `EsPhysicalOperationProviders` functionality, involving creation of Lucene operators. Hence, it should be moved to the `EsPhysicalOperationProviders` class."
                        },
                        {
                            "method_name": "planFieldExtractNode",
                            "method_signature": "private PhysicalOperation planFieldExtractNode(LocalExecutionPlannerContext context, FieldExtractExec fieldExtractExec)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The method `planFieldExtractNode` interacts heavily with `physicalOperationProviders` for planning field extraction, indicating it should reside within the `PhysicalOperationProviders` class."
                        },
                        {
                            "method_name": "planOutput",
                            "method_signature": "private PhysicalOperation planOutput(OutputExec outputExec, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The `planOutput` method is focused on planning output operations, a responsibility of the `PhysicalOperationProviders` class, suggesting it should be moved there."
                        },
                        {
                            "method_name": "planExchange",
                            "method_signature": "private PhysicalOperation planExchange(ExchangeExec exchangeExec, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The `planExchange` method's function is to plan exchange nodes, making it appropriate to relocate it to the `PhysicalOperationProviders` class."
                        },
                        {
                            "method_name": "planExchangeSink",
                            "method_signature": "private PhysicalOperation planExchangeSink(ExchangeSinkExec exchangeSink, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The `planExchangeSink` method is responsible for planning the exchange sink operation and should be moved to the `PhysicalOperationProviders` for logical consistency."
                        },
                        {
                            "method_name": "planExchangeSource",
                            "method_signature": "private PhysicalOperation planExchangeSource(ExchangeSourceExec exchangeSource, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "As `planExchangeSource` deals with sourcing exchange operations, it aligns more with the `PhysicalOperationProviders` class responsibilities."
                        },
                        {
                            "method_name": "planTopN",
                            "method_signature": "private PhysicalOperation planTopN(TopNExec topNExec, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The `planTopN` method orchestrates planning for Top-N execution and should be moved to `PhysicalOperationProviders` to centralize planning methods."
                        },
                        {
                            "method_name": "planEval",
                            "method_signature": "private PhysicalOperation planEval(EvalExec eval, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "Given that `planEval` is about planning evaluation operations, it should be under `PhysicalOperationProviders` for better cohesion."
                        },
                        {
                            "method_name": "planDissect",
                            "method_signature": "private PhysicalOperation planDissect(DissectExec dissect, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The `planDissect` method involves planning for dissection operations and belongs in `PhysicalOperationProviders` which house similar planning methods."
                        },
                        {
                            "method_name": "planGrok",
                            "method_signature": "private PhysicalOperation planGrok(GrokExec grok, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "As `planGrok` plans Grok execution, moving it to `PhysicalOperationProviders` would keep operation planning methods together."
                        },
                        {
                            "method_name": "planEnrich",
                            "method_signature": "private PhysicalOperation planEnrich(EnrichExec enrich, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The `planEnrich` method is intended for planning enrichment operations, making `PhysicalOperationProviders` a more appropriate class."
                        },
                        {
                            "method_name": "planRow",
                            "method_signature": "private PhysicalOperation planRow(RowExec row, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "Being focused on planning row operations, `planRow` should be moved to the `PhysicalOperationProviders` class."
                        },
                        {
                            "method_name": "planLocal",
                            "method_signature": "private PhysicalOperation planLocal(LocalSourceExec localSourceExec, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The `planLocal` method plans local execution sources and thus should be moved to the `PhysicalOperationProviders` class."
                        },
                        {
                            "method_name": "planShow",
                            "method_signature": "private PhysicalOperation planShow(ShowExec showExec)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The `planShow` method is related to planning Show operations and should be relocated to the `PhysicalOperationProviders` class."
                        },
                        {
                            "method_name": "planProject",
                            "method_signature": "private PhysicalOperation planProject(ProjectExec project, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "Given its intention to handle project operation planning, `planProject` would fit better within the `PhysicalOperationProviders` class."
                        },
                        {
                            "method_name": "planFilter",
                            "method_signature": "private PhysicalOperation planFilter(FilterExec filter, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The `planFilter` method's primary function is to process filter operations, making `PhysicalOperationProviders` a more logical home."
                        },
                        {
                            "method_name": "planLimit",
                            "method_signature": "private PhysicalOperation planLimit(LimitExec limit, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The `planLimit` method involves handling limit operations planning and should be moved to the `PhysicalOperationProviders` class."
                        },
                        {
                            "method_name": "planMvExpand",
                            "method_signature": "private PhysicalOperation planMvExpand(MvExpandExec mvExpandExec, LocalExecutionPlannerContext context)",
                            "target_class": "PhysicalOperationProviders",
                            "rationale": "The method `planMvExpand` handles multi-valued expand operations and should be part of the `PhysicalOperationProviders` class for better cohesion."
                        }
                    ],
                    "llm_response_time": 26108
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "plan",
                            "method_signature": "public plan(PhysicalPlan node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "plan",
                            "method_signature": "private plan(PhysicalPlan node, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planAggregation",
                            "method_signature": "private planAggregation(AggregateExec aggregate, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planEsQueryNode",
                            "method_signature": "private planEsQueryNode(EsQueryExec esQueryExec, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planEsStats",
                            "method_signature": "private planEsStats(EsStatsQueryExec statsQuery, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "countSource",
                            "method_signature": "private countSource(LocalExecutionPlannerContext context, Expression limitExp, EsPhysicalOperationProviders esProvider, Function<SearchContext, Query> querySupplier)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planFieldExtractNode",
                            "method_signature": "private planFieldExtractNode(LocalExecutionPlannerContext context, FieldExtractExec fieldExtractExec)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planOutput",
                            "method_signature": "private planOutput(OutputExec outputExec, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "alignPageToAttributes",
                            "method_signature": "private static alignPageToAttributes(List<Attribute> attrs, Layout layout)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planExchangeSink",
                            "method_signature": "private planExchangeSink(ExchangeSinkExec exchangeSink, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planExchangeSource",
                            "method_signature": "private planExchangeSource(ExchangeSourceExec exchangeSource, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planTopN",
                            "method_signature": "private planTopN(TopNExec topNExec, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planEval",
                            "method_signature": "private planEval(EvalExec eval, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planDissect",
                            "method_signature": "private planDissect(DissectExec dissect, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planGrok",
                            "method_signature": "private planGrok(GrokExec grok, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planEnrich",
                            "method_signature": "private planEnrich(EnrichExec enrich, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planRow",
                            "method_signature": "private planRow(RowExec row, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planLocal",
                            "method_signature": "private planLocal(LocalSourceExec localSourceExec, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planShow",
                            "method_signature": "private planShow(ShowExec showExec)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planProject",
                            "method_signature": "private planProject(ProjectExec project, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planFilter",
                            "method_signature": "private planFilter(FilterExec filter, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planLimit",
                            "method_signature": "private planLimit(LimitExec limit, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planMvExpand",
                            "method_signature": "private planMvExpand(MvExpandExec mvExpandExec, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "source",
                            "method_signature": "public source(DriverContext driverContext)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "operators",
                            "method_signature": "public operators(List<Operator> operators, DriverContext driverContext)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "sink",
                            "method_signature": "public sink(DriverContext driverContext)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "pageSize",
                            "method_signature": " pageSize(Integer estimatedRowSize)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createDrivers",
                            "method_signature": "public createDrivers(String sessionId)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "operators",
                            "method_signature": "public operators(List<Operator> operators, DriverContext driverContext)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planFieldExtractNode",
                            "method_signature": "private planFieldExtractNode(LocalExecutionPlannerContext context, FieldExtractExec fieldExtractExec)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "source",
                            "method_signature": "public source(DriverContext driverContext)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "sink",
                            "method_signature": "public sink(DriverContext driverContext)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "countSource",
                            "method_signature": "private countSource(LocalExecutionPlannerContext context, Expression limitExp, EsPhysicalOperationProviders esProvider, Function<SearchContext, Query> querySupplier)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "plan",
                            "method_signature": "private plan(PhysicalPlan node, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planFilter",
                            "method_signature": "private planFilter(FilterExec filter, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planEsQueryNode",
                            "method_signature": "private planEsQueryNode(EsQueryExec esQueryExec, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "pageSize",
                            "method_signature": " pageSize(Integer estimatedRowSize)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planExchangeSink",
                            "method_signature": "private planExchangeSink(ExchangeSinkExec exchangeSink, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planLimit",
                            "method_signature": "private planLimit(LimitExec limit, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planAggregation",
                            "method_signature": "private planAggregation(AggregateExec aggregate, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "plan",
                            "method_signature": "public plan(PhysicalPlan node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planExchangeSource",
                            "method_signature": "private planExchangeSource(ExchangeSourceExec exchangeSource, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "planOutput",
                            "method_signature": "private planOutput(OutputExec outputExec, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public operators(List<Operator> operators, DriverContext driverContext)": {
                        "first": {
                            "method_name": "operators",
                            "method_signature": "public operators(List<Operator> operators, DriverContext driverContext)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.30060119754692494
                    },
                    "private planFieldExtractNode(LocalExecutionPlannerContext context, FieldExtractExec fieldExtractExec)": {
                        "first": {
                            "method_name": "planFieldExtractNode",
                            "method_signature": "private planFieldExtractNode(LocalExecutionPlannerContext context, FieldExtractExec fieldExtractExec)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.40381341220338457
                    },
                    "public source(DriverContext driverContext)": {
                        "first": {
                            "method_name": "source",
                            "method_signature": "public source(DriverContext driverContext)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.40695686222353794
                    },
                    "public sink(DriverContext driverContext)": {
                        "first": {
                            "method_name": "sink",
                            "method_signature": "public sink(DriverContext driverContext)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.40695686222353794
                    },
                    "private countSource(LocalExecutionPlannerContext context, Expression limitExp, EsPhysicalOperationProviders esProvider, Function<SearchContext, Query> querySupplier)": {
                        "first": {
                            "method_name": "countSource",
                            "method_signature": "private countSource(LocalExecutionPlannerContext context, Expression limitExp, EsPhysicalOperationProviders esProvider, Function<SearchContext, Query> querySupplier)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4249074791432509
                    },
                    "private plan(PhysicalPlan node, LocalExecutionPlannerContext context)": {
                        "first": {
                            "method_name": "plan",
                            "method_signature": "private plan(PhysicalPlan node, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.43295353729849767
                    },
                    "private planFilter(FilterExec filter, LocalExecutionPlannerContext context)": {
                        "first": {
                            "method_name": "planFilter",
                            "method_signature": "private planFilter(FilterExec filter, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4744218443238918
                    },
                    "private planEsQueryNode(EsQueryExec esQueryExec, LocalExecutionPlannerContext context)": {
                        "first": {
                            "method_name": "planEsQueryNode",
                            "method_signature": "private planEsQueryNode(EsQueryExec esQueryExec, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5015325082668591
                    },
                    " pageSize(Integer estimatedRowSize)": {
                        "first": {
                            "method_name": "pageSize",
                            "method_signature": " pageSize(Integer estimatedRowSize)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5134939083418405
                    },
                    "private planExchangeSink(ExchangeSinkExec exchangeSink, LocalExecutionPlannerContext context)": {
                        "first": {
                            "method_name": "planExchangeSink",
                            "method_signature": "private planExchangeSink(ExchangeSinkExec exchangeSink, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5293537853702531
                    },
                    "private planLimit(LimitExec limit, LocalExecutionPlannerContext context)": {
                        "first": {
                            "method_name": "planLimit",
                            "method_signature": "private planLimit(LimitExec limit, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5456336070124781
                    },
                    "private planAggregation(AggregateExec aggregate, LocalExecutionPlannerContext context)": {
                        "first": {
                            "method_name": "planAggregation",
                            "method_signature": "private planAggregation(AggregateExec aggregate, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5588629886858217
                    },
                    "public plan(PhysicalPlan node)": {
                        "first": {
                            "method_name": "plan",
                            "method_signature": "public plan(PhysicalPlan node)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5660558803749349
                    },
                    "private planExchangeSource(ExchangeSourceExec exchangeSource, LocalExecutionPlannerContext context)": {
                        "first": {
                            "method_name": "planExchangeSource",
                            "method_signature": "private planExchangeSource(ExchangeSourceExec exchangeSource, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5664079057257285
                    },
                    "private planOutput(OutputExec outputExec, LocalExecutionPlannerContext context)": {
                        "first": {
                            "method_name": "planOutput",
                            "method_signature": "private planOutput(OutputExec outputExec, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5849002664650035
                    }
                },
                "voyage": {
                    "public createDrivers(String sessionId)": {
                        "first": {
                            "method_name": "createDrivers",
                            "method_signature": "public createDrivers(String sessionId)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.30090824008977396
                    },
                    "private static alignPageToAttributes(List<Attribute> attrs, Layout layout)": {
                        "first": {
                            "method_name": "alignPageToAttributes",
                            "method_signature": "private static alignPageToAttributes(List<Attribute> attrs, Layout layout)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3051255427828717
                    },
                    "public operators(List<Operator> operators, DriverContext driverContext)": {
                        "first": {
                            "method_name": "operators",
                            "method_signature": "public operators(List<Operator> operators, DriverContext driverContext)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3785212594223457
                    },
                    " pageSize(Integer estimatedRowSize)": {
                        "first": {
                            "method_name": "pageSize",
                            "method_signature": " pageSize(Integer estimatedRowSize)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.38982729918177617
                    },
                    "public sink(DriverContext driverContext)": {
                        "first": {
                            "method_name": "sink",
                            "method_signature": "public sink(DriverContext driverContext)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3972398225333208
                    },
                    "public source(DriverContext driverContext)": {
                        "first": {
                            "method_name": "source",
                            "method_signature": "public source(DriverContext driverContext)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3979754726050155
                    },
                    "private planShow(ShowExec showExec)": {
                        "first": {
                            "method_name": "planShow",
                            "method_signature": "private planShow(ShowExec showExec)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5156056260381332
                    },
                    "private planDissect(DissectExec dissect, LocalExecutionPlannerContext context)": {
                        "first": {
                            "method_name": "planDissect",
                            "method_signature": "private planDissect(DissectExec dissect, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5805354868518182
                    },
                    "private planMvExpand(MvExpandExec mvExpandExec, LocalExecutionPlannerContext context)": {
                        "first": {
                            "method_name": "planMvExpand",
                            "method_signature": "private planMvExpand(MvExpandExec mvExpandExec, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5827662775052972
                    },
                    "private countSource(LocalExecutionPlannerContext context, Expression limitExp, EsPhysicalOperationProviders esProvider, Function<SearchContext, Query> querySupplier)": {
                        "first": {
                            "method_name": "countSource",
                            "method_signature": "private countSource(LocalExecutionPlannerContext context, Expression limitExp, EsPhysicalOperationProviders esProvider, Function<SearchContext, Query> querySupplier)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5917188991003316
                    },
                    "private planEnrich(EnrichExec enrich, LocalExecutionPlannerContext context)": {
                        "first": {
                            "method_name": "planEnrich",
                            "method_signature": "private planEnrich(EnrichExec enrich, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6054878817201228
                    },
                    "private planProject(ProjectExec project, LocalExecutionPlannerContext context)": {
                        "first": {
                            "method_name": "planProject",
                            "method_signature": "private planProject(ProjectExec project, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6068738219378882
                    },
                    "private planLimit(LimitExec limit, LocalExecutionPlannerContext context)": {
                        "first": {
                            "method_name": "planLimit",
                            "method_signature": "private planLimit(LimitExec limit, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6105453424511821
                    },
                    "private planExchangeSource(ExchangeSourceExec exchangeSource, LocalExecutionPlannerContext context)": {
                        "first": {
                            "method_name": "planExchangeSource",
                            "method_signature": "private planExchangeSource(ExchangeSourceExec exchangeSource, LocalExecutionPlannerContext context)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6264080284858499
                    },
                    "private planFieldExtractNode(LocalExecutionPlannerContext context, FieldExtractExec fieldExtractExec)": {
                        "first": {
                            "method_name": "planFieldExtractNode",
                            "method_signature": "private planFieldExtractNode(LocalExecutionPlannerContext context, FieldExtractExec fieldExtractExec)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6291881073569776
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private planOutput(OutputExec outputExec, LocalExecutionPlannerContext context)",
                        "private planFilter(FilterExec filter, LocalExecutionPlannerContext context)",
                        "private planLimit(LimitExec limit, LocalExecutionPlannerContext context)",
                        "private planAggregation(AggregateExec aggregate, LocalExecutionPlannerContext context)",
                        "private planExchangeSink(ExchangeSinkExec exchangeSink, LocalExecutionPlannerContext context)",
                        "private planExchangeSource(ExchangeSourceExec exchangeSource, LocalExecutionPlannerContext context)",
                        "private planFieldExtractNode(LocalExecutionPlannerContext context, FieldExtractExec fieldExtractExec)",
                        "private planEsQueryNode(EsQueryExec esQueryExec, LocalExecutionPlannerContext context)",
                        "private countSource(LocalExecutionPlannerContext context, Expression limitExp, EsPhysicalOperationProviders esProvider, Function<SearchContext, Query> querySupplier)",
                        " pageSize(Integer estimatedRowSize)",
                        "public operators(List<Operator> operators, DriverContext driverContext)",
                        "public source(DriverContext driverContext)",
                        "public sink(DriverContext driverContext)",
                        "public plan(PhysicalPlan node)"
                    ],
                    "llm_response_time": 4103
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "private planFieldExtractNode(LocalExecutionPlannerContext context, FieldExtractExec fieldExtractExec)",
                        "private countSource(LocalExecutionPlannerContext context, Expression limitExp, EsPhysicalOperationProviders esProvider, Function<SearchContext, Query> querySupplier)",
                        "public operators(List<Operator> operators, DriverContext driverContext)",
                        "public source(DriverContext driverContext)",
                        "public sink(DriverContext driverContext)"
                    ],
                    "llm_response_time": 4861
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private planFieldExtractNode(LocalExecutionPlannerContext context, FieldExtractExec fieldExtractExec)",
                        "public operators(List<Operator> operators, DriverContext driverContext)",
                        "public source(DriverContext driverContext)"
                    ],
                    "llm_response_time": 3761
                },
                "voyage": {
                    "priority_method_names": [
                        "public createDrivers(String sessionId)",
                        "private static alignPageToAttributes(List<Attribute> attrs, Layout layout)",
                        "public operators(List<Operator> operators, DriverContext driverContext)",
                        "public sink(DriverContext driverContext)",
                        "public source(DriverContext driverContext)",
                        "private planFieldExtractNode(LocalExecutionPlannerContext context, FieldExtractExec fieldExtractExec)",
                        "private planProject(ProjectExec project, LocalExecutionPlannerContext context)",
                        "private planEnrich(EnrichExec enrich, LocalExecutionPlannerContext context)",
                        "private planLimit(LimitExec limit, LocalExecutionPlannerContext context)",
                        "private planMvExpand(MvExpandExec mvExpandExec, LocalExecutionPlannerContext context)",
                        "private planDissect(DissectExec dissect, LocalExecutionPlannerContext context)",
                        "private planExchangeSource(ExchangeSourceExec exchangeSource, LocalExecutionPlannerContext context)",
                        "private countSource(LocalExecutionPlannerContext context, Expression limitExp, EsPhysicalOperationProviders esProvider, Function<SearchContext, Query> querySupplier)",
                        " pageSize(Integer estimatedRowSize)",
                        "private planShow(ShowExec showExec)"
                    ],
                    "llm_response_time": 5918
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public createDrivers(String sessionId)",
                        " pageSize(Integer estimatedRowSize)",
                        "private static alignPageToAttributes(List<Attribute> attrs, Layout layout)",
                        "public operators(List<Operator> operators, DriverContext driverContext)",
                        "public sink(DriverContext driverContext)"
                    ],
                    "llm_response_time": 5206
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private static alignPageToAttributes(List<Attribute> attrs, Layout layout)",
                        "public createDrivers(String sessionId)",
                        "public operators(List<Operator> operators, DriverContext driverContext)"
                    ],
                    "llm_response_time": 5088
                }
            },
            "targetClassMap": {
                "operators": {
                    "target_classes": [
                        {
                            "class_name": "SourceOperatorFactory",
                            "similarity_score": 0.15075567228888181
                        },
                        {
                            "class_name": "SinkOperatorFactory",
                            "similarity_score": 0.15289415743128767
                        },
                        {
                            "class_name": "Layout",
                            "similarity_score": 0.21626361299795166
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SinkOperatorFactory",
                        "SourceOperatorFactory",
                        "Layout"
                    ],
                    "llm_response_time": 3075,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "planFieldExtractNode": {
                    "target_classes": [
                        {
                            "class_name": "LocalExecutionPlannerContext",
                            "similarity_score": 0.30323921743156135
                        },
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.0019554462622001067
                        },
                        {
                            "class_name": "PhysicalOperationProviders",
                            "similarity_score": 0.30123203803835463
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PhysicalOperationProviders",
                        "LocalExecutionPlannerContext",
                        "Logger"
                    ],
                    "llm_response_time": 3566,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "source": {
                    "target_classes": [
                        {
                            "class_name": "SourceOperatorFactory",
                            "similarity_score": 0.2357022603955158
                        },
                        {
                            "class_name": "SinkOperatorFactory",
                            "similarity_score": 0.17928429140015903
                        },
                        {
                            "class_name": "Layout",
                            "similarity_score": 0.27261093202077336
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SourceOperatorFactory",
                        "SinkOperatorFactory",
                        "Layout"
                    ],
                    "llm_response_time": 4657,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "sink": {
                    "target_classes": [
                        {
                            "class_name": "SourceOperatorFactory",
                            "similarity_score": 0.17677669529663687
                        },
                        {
                            "class_name": "SinkOperatorFactory",
                            "similarity_score": 0.23904572186687872
                        },
                        {
                            "class_name": "Layout",
                            "similarity_score": 0.27261093202077336
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SinkOperatorFactory",
                        "SourceOperatorFactory",
                        "Layout"
                    ],
                    "llm_response_time": 3680,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "countSource": {
                    "target_classes": [
                        {
                            "class_name": "LocalExecutionPlannerContext",
                            "similarity_score": 0.19795189561622395
                        },
                        {
                            "class_name": "EsPhysicalOperationProviders",
                            "similarity_score": 0.5068432561308877
                        },
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.0010211985050133765
                        },
                        {
                            "class_name": "CancellableTask",
                            "similarity_score": 0.20307388540270588
                        },
                        {
                            "class_name": "BigArrays",
                            "similarity_score": 0.30115145845154406
                        },
                        {
                            "class_name": "BlockFactory",
                            "similarity_score": 0.33349914898585614
                        },
                        {
                            "class_name": "Settings",
                            "similarity_score": 0.29745050043760274
                        },
                        {
                            "class_name": "EsqlConfiguration",
                            "similarity_score": 0.37262794315783476
                        },
                        {
                            "class_name": "ExchangeSourceHandler",
                            "similarity_score": 0.33860977979282614
                        },
                        {
                            "class_name": "ExchangeSinkHandler",
                            "similarity_score": 0.2728804472817397
                        },
                        {
                            "class_name": "EnrichLookupService",
                            "similarity_score": 0.4149515417422062
                        },
                        {
                            "class_name": "PhysicalOperationProviders",
                            "similarity_score": 0.06741998624632421
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "EsPhysicalOperationProviders",
                        "EnrichLookupService",
                        "EsqlConfiguration"
                    ],
                    "llm_response_time": 8409,
                    "similarity_computation_time": 30,
                    "similarity_metric": "cosine"
                },
                "plan": {
                    "target_classes": [
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.19321245806878634
                        },
                        {
                            "class_name": "PhysicalOperationProviders",
                            "similarity_score": 0.20831080959324552
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PhysicalOperationProviders",
                        "Logger"
                    ],
                    "llm_response_time": 4591,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "planFilter": {
                    "target_classes": [
                        {
                            "class_name": "LocalExecutionPlannerContext",
                            "similarity_score": 0.24762498108420358
                        },
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.06934745339155952
                        },
                        {
                            "class_name": "PhysicalOperationProviders",
                            "similarity_score": 0.4016096644512494
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PhysicalOperationProviders",
                        "LocalExecutionPlannerContext",
                        "Logger"
                    ],
                    "llm_response_time": 3686,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "planEsQueryNode": {
                    "target_classes": [
                        {
                            "class_name": "LocalExecutionPlannerContext",
                            "similarity_score": 0.31672303298595833
                        },
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.002042397010026753
                        },
                        {
                            "class_name": "PhysicalOperationProviders",
                            "similarity_score": 0.44946657497549475
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PhysicalOperationProviders",
                        "LocalExecutionPlannerContext",
                        "Logger"
                    ],
                    "llm_response_time": 3392,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "pageSize": {
                    "target_classes": [
                        {
                            "class_name": "QueryPragmas",
                            "similarity_score": 0.3752596724532138
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "QueryPragmas"
                    ],
                    "llm_response_time": 2084,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "planExchangeSink": {
                    "target_classes": [
                        {
                            "class_name": "LocalExecutionPlannerContext",
                            "similarity_score": 0.15488061853247326
                        },
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.000998751840747375
                        },
                        {
                            "class_name": "PhysicalOperationProviders",
                            "similarity_score": 0.3296902366978935
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PhysicalOperationProviders",
                        "LocalExecutionPlannerContext",
                        "Logger"
                    ],
                    "llm_response_time": 2962,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "planLimit": {
                    "target_classes": [
                        {
                            "class_name": "LocalExecutionPlannerContext",
                            "similarity_score": 0.23488808780588138
                        },
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.0015146821615809108
                        },
                        {
                            "class_name": "PhysicalOperationProviders",
                            "similarity_score": 0.49999999999999994
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PhysicalOperationProviders",
                        "LocalExecutionPlannerContext",
                        "Logger"
                    ],
                    "llm_response_time": 3667,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "planAggregation": {
                    "target_classes": [
                        {
                            "class_name": "LocalExecutionPlannerContext",
                            "similarity_score": 0.24099009325151113
                        },
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.001554031108071562
                        },
                        {
                            "class_name": "PhysicalOperationProviders",
                            "similarity_score": 0.4103913408340616
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PhysicalOperationProviders",
                        "LocalExecutionPlannerContext",
                        "Logger"
                    ],
                    "llm_response_time": 3330,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "planExchangeSource": {
                    "target_classes": [
                        {
                            "class_name": "LocalExecutionPlannerContext",
                            "similarity_score": 0.18590623584658414
                        },
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.06028358887930023
                        },
                        {
                            "class_name": "PhysicalOperationProviders",
                            "similarity_score": 0.18090680674665818
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PhysicalOperationProviders",
                        "LocalExecutionPlannerContext",
                        "Logger"
                    ],
                    "llm_response_time": 4205,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "planOutput": {
                    "target_classes": [
                        {
                            "class_name": "LocalExecutionPlannerContext",
                            "similarity_score": 0.20890725544918332
                        },
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.0011974613904557165
                        },
                        {
                            "class_name": "PhysicalOperationProviders",
                            "similarity_score": 0.42163702135578385
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PhysicalOperationProviders",
                        "LocalExecutionPlannerContext",
                        "Logger"
                    ],
                    "llm_response_time": 3691,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/elastic/elasticsearch.git",
        "sha1": "876e70159c01ae306251281ae2fdbabca8732ed9",
        "url": "https://github.com/elastic/elasticsearch/commit/876e70159c01ae306251281ae2fdbabca8732ed9",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public resolvePolicy(policyNames Collection<String>, listener ActionListener<EnrichResolution>) : void extracted from private preAnalyze(parsed LogicalPlan, action BiFunction<IndexResolution,EnrichResolution,T>, listener ActionListener<T>) : void in class org.elasticsearch.xpack.esql.session.EsqlSession & moved to class org.elasticsearch.xpack.esql.enrich.EnrichPolicyResolver",
            "leftSideLocations": [
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/session/EsqlSession.java",
                    "startLine": 151,
                    "endLine": 179,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "private preAnalyze(parsed LogicalPlan, action BiFunction<IndexResolution,EnrichResolution,T>, listener ActionListener<T>) : void"
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/session/EsqlSession.java",
                    "startLine": 154,
                    "endLine": 154,
                    "startColumn": 9,
                    "endColumn": 141,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/session/EsqlSession.java",
                    "startLine": 175,
                    "endLine": 177,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "ENHANCED_FOR_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/session/EsqlSession.java",
                    "startLine": 174,
                    "endLine": 178,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "TRY_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/session/EsqlSession.java",
                    "startLine": 175,
                    "endLine": 177,
                    "startColumn": 51,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java",
                    "startLine": 64,
                    "endLine": 83,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public resolvePolicy(policyNames Collection<String>, listener ActionListener<EnrichResolution>) : void"
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java",
                    "startLine": 74,
                    "endLine": 74,
                    "startColumn": 17,
                    "endColumn": 76,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java",
                    "startLine": 77,
                    "endLine": 79,
                    "startColumn": 21,
                    "endColumn": 22,
                    "codeElementType": "ENHANCED_FOR_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java",
                    "startLine": 76,
                    "endLine": 80,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "TRY_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java",
                    "startLine": 77,
                    "endLine": 79,
                    "startColumn": 90,
                    "endColumn": 22,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/session/EsqlSession.java",
                    "startLine": 149,
                    "endLine": 163,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "private preAnalyze(parsed LogicalPlan, action BiFunction<IndexResolution,EnrichResolution,T>, listener ActionListener<T>) : void"
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/session/EsqlSession.java",
                    "startLine": 151,
                    "endLine": 162,
                    "startColumn": 9,
                    "endColumn": 12,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "enrichPolicyResolver.resolvePolicy(preAnalysis.policyNames,listener.delegateFailureAndWrap((l,enrichResolution) -> {\n  var matchFields=enrichResolution.resolvedEnrichPolicies().stream().map(EnrichPolicy::getMatchField).collect(Collectors.toSet());\n  preAnalyzeIndices(parsed,l.delegateFailureAndWrap((ll,indexResolution) -> ll.onResponse(action.apply(indexResolution,enrichResolution))),matchFields);\n}\n))"
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java",
                    "startLine": 66,
                    "endLine": 66,
                    "startColumn": 13,
                    "endColumn": 57,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java",
                    "startLine": 67,
                    "endLine": 67,
                    "startColumn": 13,
                    "endColumn": 20,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java",
                    "startLine": 69,
                    "endLine": 82,
                    "startColumn": 9,
                    "endColumn": 11,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java",
                    "startLine": 65,
                    "endLine": 68,
                    "startColumn": 36,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/enrich/EnrichPolicyResolver.java",
                    "startLine": 65,
                    "endLine": 68,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                }
            ],
            "isStatic": false
        },
        "ref_id": 94,
        "extraction_results": {
            "success": true,
            "newCommitHash": "0c0d11395e67bba589d3dee04684812b9f4835df",
            "newBranchName": "extract-resolvePolicy-preAnalyze-32ace95"
        },
        "telemetry": {
            "id": "91a9ad35-b160-4e3f-b58b-af35db3de214",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 292,
                "lineStart": 67,
                "lineEnd": 358,
                "bodyLineStart": 67,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/elasticsearch/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/session/EsqlSession.java",
                "sourceCode": "public class EsqlSession {\n\n    private static final Logger LOGGER = LogManager.getLogger(EsqlSession.class);\n\n    private final String sessionId;\n    private final EsqlConfiguration configuration;\n    private final IndexResolver indexResolver;\n    private final EnrichPolicyResolver enrichPolicyResolver;\n\n    private final PreAnalyzer preAnalyzer;\n    private final Verifier verifier;\n    private final FunctionRegistry functionRegistry;\n    private final LogicalPlanOptimizer logicalPlanOptimizer;\n\n    private final Mapper mapper;\n    private final PhysicalPlanOptimizer physicalPlanOptimizer;\n\n    public EsqlSession(\n        String sessionId,\n        EsqlConfiguration configuration,\n        IndexResolver indexResolver,\n        EnrichPolicyResolver enrichPolicyResolver,\n        PreAnalyzer preAnalyzer,\n        FunctionRegistry functionRegistry,\n        LogicalPlanOptimizer logicalPlanOptimizer,\n        Mapper mapper,\n        Verifier verifier\n    ) {\n        this.sessionId = sessionId;\n        this.configuration = configuration;\n        this.indexResolver = indexResolver;\n        this.enrichPolicyResolver = enrichPolicyResolver;\n        this.preAnalyzer = preAnalyzer;\n        this.verifier = verifier;\n        this.functionRegistry = functionRegistry;\n        this.mapper = mapper;\n        this.logicalPlanOptimizer = logicalPlanOptimizer;\n        this.physicalPlanOptimizer = new PhysicalPlanOptimizer(new PhysicalOptimizerContext(configuration));\n    }\n\n    public String sessionId() {\n        return sessionId;\n    }\n\n    public void execute(EsqlQueryRequest request, ActionListener<PhysicalPlan> listener) {\n        LOGGER.debug(\"ESQL query:\\n{}\", request.query());\n        optimizedPhysicalPlan(\n            parse(request.query(), request.params()),\n            listener.map(plan -> EstimatesRowSize.estimateRowSize(0, plan.transformUp(FragmentExec.class, f -> {\n                QueryBuilder filter = request.filter();\n                if (filter != null) {\n                    var fragmentFilter = f.esFilter();\n                    // TODO: have an ESFilter and push down to EsQueryExec / EsSource\n                    // This is an ugly hack to push the filter parameter to Lucene\n                    // TODO: filter integration testing\n                    filter = fragmentFilter != null ? boolQuery().filter(fragmentFilter).must(filter) : filter;\n                    LOGGER.debug(\"Fold filter {} to EsQueryExec\", filter);\n                    f = new FragmentExec(f.source(), f.fragment(), filter, f.estimatedRowSize());\n                }\n                return f;\n            })))\n        );\n    }\n\n    private LogicalPlan parse(String query, List<TypedParamValue> params) {\n        var parsed = new EsqlParser().createStatement(query, params);\n        LOGGER.debug(\"Parsed logical plan:\\n{}\", parsed);\n        return parsed;\n    }\n\n    public void analyzedPlan(LogicalPlan parsed, ActionListener<LogicalPlan> listener) {\n        if (parsed.analyzed()) {\n            listener.onResponse(parsed);\n            return;\n        }\n\n        preAnalyze(parsed, (indices, policies) -> {\n            Analyzer analyzer = new Analyzer(new AnalyzerContext(configuration, functionRegistry, indices, policies), verifier);\n            var plan = analyzer.analyze(parsed);\n            LOGGER.debug(\"Analyzed plan:\\n{}\", plan);\n            return plan;\n        }, listener);\n    }\n\n    private <T> void preAnalyze(LogicalPlan parsed, BiFunction<IndexResolution, EnrichResolution, T> action, ActionListener<T> listener) {\n        PreAnalyzer.PreAnalysis preAnalysis = preAnalyzer.preAnalyze(parsed);\n        Set<String> policyNames = new HashSet<>(preAnalysis.policyNames);\n        EnrichResolution resolution = new EnrichResolution(ConcurrentCollections.newConcurrentSet(), enrichPolicyResolver.allPolicyNames());\n\n        ActionListener<Void> groupedListener = listener.delegateFailureAndWrap((l, unused) -> {\n            assert resolution.resolvedPolicies().size() == policyNames.size()\n                : resolution.resolvedPolicies().size() + \" != \" + policyNames.size();\n\n            // first we need the match_fields names from enrich policies and THEN, with an updated list of fields, we call field_caps API\n            var matchFields = resolution.resolvedPolicies()\n                .stream()\n                .filter(p -> p.index().isValid()) // only if the policy by the specified name was found; later the Verifier will be\n                                                  // triggered\n                .map(p -> p.policy().getMatchField())\n                .collect(Collectors.toSet());\n\n            preAnalyzeIndices(\n                parsed,\n                l.delegateFailureAndWrap((ll, indexResolution) -> ll.onResponse(action.apply(indexResolution, resolution))),\n                matchFields\n            );\n        });\n        resolvePolicy(groupedListener, policyNames, resolution);\n    }\n\n    private void resolvePolicy(ActionListener<Void> groupedListener, Set<String> policyNames, EnrichResolution resolution) {\n        try (RefCountingListener refs = new RefCountingListener(groupedListener)) {\n            for (String policyName : policyNames) {\n                enrichPolicyResolver.resolvePolicy(policyName, refs.acquire(resolution.resolvedPolicies()::add));\n            }\n        }\n    }\n\n    private <T> void preAnalyzeIndices(LogicalPlan parsed, ActionListener<IndexResolution> listener, Set<String> enrichPolicyMatchFields) {\n        PreAnalyzer.PreAnalysis preAnalysis = new PreAnalyzer().preAnalyze(parsed);\n        // TODO we plan to support joins in the future when possible, but for now we'll just fail early if we see one\n        if (preAnalysis.indices.size() > 1) {\n            // Note: JOINs are not supported but we detect them when\n            listener.onFailure(new MappingException(\"Queries with multiple indices are not supported\"));\n        } else if (preAnalysis.indices.size() == 1) {\n            TableInfo tableInfo = preAnalysis.indices.get(0);\n            TableIdentifier table = tableInfo.id();\n            var fieldNames = fieldNames(parsed, enrichPolicyMatchFields);\n\n            indexResolver.resolveAsMergedMapping(\n                table.index(),\n                fieldNames,\n                false,\n                Map.of(),\n                listener,\n                EsqlSession::specificValidity,\n                IndexResolver.PRESERVE_PROPERTIES,\n                // TODO no matter what metadata fields are asked in a query, the \"allowedMetadataFields\" is always _index, does it make\n                // sense to reflect the actual list of metadata fields instead?\n                IndexResolver.INDEX_METADATA_FIELD\n            );\n        } else {\n            try {\n                // occurs when dealing with local relations (row a = 1)\n                listener.onResponse(IndexResolution.invalid(\"[none specified]\"));\n            } catch (Exception ex) {\n                listener.onFailure(ex);\n            }\n        }\n    }\n\n    static Set<String> fieldNames(LogicalPlan parsed, Set<String> enrichPolicyMatchFields) {\n        if (false == parsed.anyMatch(plan -> plan instanceof Aggregate || plan instanceof Project)) {\n            // no explicit columns selection, for example \"from employees\"\n            return IndexResolver.ALL_FIELDS;\n        }\n\n        Holder<Boolean> projectAll = new Holder<>(false);\n        parsed.forEachExpressionDown(UnresolvedStar.class, us -> {// explicit \"*\" fields selection\n            if (projectAll.get()) {\n                return;\n            }\n            projectAll.set(true);\n        });\n        if (projectAll.get()) {\n            return IndexResolver.ALL_FIELDS;\n        }\n\n        AttributeSet references = new AttributeSet();\n        // \"keep\" attributes are special whenever a wildcard is used in their name\n        // ie \"from test | eval lang = languages + 1 | keep *l\" should consider both \"languages\" and \"*l\" as valid fields to ask for\n        AttributeSet keepCommandReferences = new AttributeSet();\n\n        parsed.forEachDown(p -> {// go over each plan top-down\n            if (p instanceof RegexExtract re) { // for Grok and Dissect\n                AttributeSet dissectRefs = p.references();\n                // don't add to the list of fields the extracted ones (they are not real fields in mappings)\n                dissectRefs.removeAll(re.extractedFields());\n                references.addAll(dissectRefs);\n                // also remove other down-the-tree references to the extracted fields\n                for (Attribute extracted : re.extractedFields()) {\n                    references.removeIf(attr -> matchByName(attr, extracted.qualifiedName(), false));\n                }\n            } else if (p instanceof Enrich) {\n                AttributeSet enrichRefs = p.references();\n                // Enrich adds an EmptyAttribute if no match field is specified\n                // The exact name of the field will be added later as part of enrichPolicyMatchFields Set\n                enrichRefs.removeIf(attr -> attr instanceof EmptyAttribute);\n                references.addAll(enrichRefs);\n            } else {\n                references.addAll(p.references());\n                if (p instanceof Keep) {\n                    keepCommandReferences.addAll(p.references());\n                }\n            }\n\n            // remove any already discovered UnresolvedAttributes that are in fact aliases defined later down in the tree\n            // for example \"from test | eval x = salary | stats max = max(x) by gender\"\n            // remove the UnresolvedAttribute \"x\", since that is an Alias defined in \"eval\"\n            p.forEachExpressionDown(Alias.class, alias -> {\n                // do not remove the UnresolvedAttribute that has the same name as its alias, ie \"rename id = id\"\n                // or the UnresolvedAttributes that are used in Functions that have aliases \"STATS id = MAX(id)\"\n                if (p.references().names().contains(alias.qualifiedName())) {\n                    return;\n                }\n                references.removeIf(attr -> matchByName(attr, alias.qualifiedName(), keepCommandReferences.contains(attr)));\n            });\n        });\n\n        // remove valid metadata attributes because they will be filtered out by the IndexResolver anyway\n        // otherwise, in some edge cases, we will fail to ask for \"*\" (all fields) instead\n        references.removeIf(a -> a instanceof MetadataAttribute || MetadataAttribute.isSupported(a.qualifiedName()));\n        Set<String> fieldNames = references.names();\n        if (fieldNames.isEmpty() && enrichPolicyMatchFields.isEmpty()) {\n            // there cannot be an empty list of fields, we'll ask the simplest and lightest one instead: _index\n            return IndexResolver.INDEX_METADATA_FIELD;\n        } else {\n            fieldNames.addAll(subfields(fieldNames));\n            fieldNames.addAll(enrichPolicyMatchFields);\n            fieldNames.addAll(subfields(enrichPolicyMatchFields));\n            return fieldNames;\n        }\n    }\n\n    private static boolean matchByName(Attribute attr, String other, boolean skipIfPattern) {\n        boolean isPattern = Regex.isSimpleMatchPattern(attr.qualifiedName());\n        if (skipIfPattern && isPattern) {\n            return false;\n        }\n        return isPattern ? Regex.simpleMatch(attr.qualifiedName(), other) : attr.qualifiedName().equals(other);\n    }\n\n    private static Set<String> subfields(Set<String> names) {\n        return names.stream().filter(name -> name.endsWith(WILDCARD) == false).map(name -> name + \".*\").collect(Collectors.toSet());\n    }\n\n    public void optimizedPlan(LogicalPlan logicalPlan, ActionListener<LogicalPlan> listener) {\n        analyzedPlan(logicalPlan, map(listener, p -> {\n            var plan = logicalPlanOptimizer.optimize(p);\n            LOGGER.debug(\"Optimized logicalPlan plan:\\n{}\", plan);\n            return plan;\n        }));\n    }\n\n    public void physicalPlan(LogicalPlan optimized, ActionListener<PhysicalPlan> listener) {\n        optimizedPlan(optimized, map(listener, p -> {\n            var plan = mapper.map(p);\n            LOGGER.debug(\"Physical plan:\\n{}\", plan);\n            return plan;\n        }));\n    }\n\n    public void optimizedPhysicalPlan(LogicalPlan logicalPlan, ActionListener<PhysicalPlan> listener) {\n        physicalPlan(logicalPlan, map(listener, p -> {\n            var plan = physicalPlanOptimizer.optimize(p);\n            LOGGER.debug(\"Optimized physical plan:\\n{}\", plan);\n            return plan;\n        }));\n    }\n\n    public static InvalidMappedField specificValidity(String fieldName, Map<String, FieldCapabilities> types) {\n        boolean hasUnmapped = types.containsKey(UNMAPPED);\n        boolean hasTypeConflicts = types.size() > (hasUnmapped ? 2 : 1);\n        String metricConflictsTypeName = null;\n        boolean hasMetricConflicts = false;\n\n        if (hasTypeConflicts == false) {\n            for (Map.Entry<String, FieldCapabilities> type : types.entrySet()) {\n                if (UNMAPPED.equals(type.getKey())) {\n                    continue;\n                }\n                if (type.getValue().metricConflictsIndices() != null && type.getValue().metricConflictsIndices().length > 0) {\n                    hasMetricConflicts = true;\n                    metricConflictsTypeName = type.getKey();\n                    break;\n                }\n            }\n        }\n\n        InvalidMappedField result = null;\n        if (hasMetricConflicts) {\n            StringBuilder errorMessage = new StringBuilder();\n            errorMessage.append(\n                \"mapped as different metric types in indices: [\"\n                    + String.join(\", \", types.get(metricConflictsTypeName).metricConflictsIndices())\n                    + \"]\"\n            );\n            result = new InvalidMappedField(fieldName, errorMessage.toString());\n        }\n        return result;\n    };\n}",
                "methodCount": 15
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 6,
                "candidates": [
                    {
                        "lineStart": 130,
                        "lineEnd": 134,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method parse to class Logger",
                        "description": "Move method parse to org.elasticsearch.logging.Logger\nRationale: The method `parse` includes a logging operation using the LOGGER instance, which indicates that its primary purpose is closely tied to logging functionality, especially given the usage of `LOGGER.debug`. This method doesn't perform a fundamental parsing operation that belongs in a core parsing class based on the limited context. By moving this method to the Logger class, it centralizes all logging-related logic in one place, which improves maintainability and cohesion. The Logger interface already provides methods for various log levels, and housing the parse method here would ensure that logging operations remain encapsulated within the Logger's domain.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 302,
                        "lineEnd": 308,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method optimizedPlan to class Logger",
                        "description": "Move method optimizedPlan to org.elasticsearch.logging.Logger\nRationale: The method optimizedPlan() currently performs the optimization of a LogicalPlan and logs the output. Given that the primary action involves logging (indicated by the LOGGER.debug call), it aligns with the responsibilities of the Logger class, which is designed to handle logging at various levels including DEBUG. Furthermore, moving this method to the Logger class centralizes logging responsibilities, adhering to the Single Responsibility Principle and ensuring the current class remains focused on its main domain logic.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 318,
                        "lineEnd": 324,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method optimizedPhysicalPlan to class Logger",
                        "description": "Move method optimizedPhysicalPlan to org.elasticsearch.logging.Logger\nRationale: The provided method `optimizedPhysicalPlan` makes extensive use of logging, particularly through the LOGGER.debug statements. However, this method's primary functionalities revolve around physical plan optimization and the use of logical plans, which are likely part of a data processing module. The LOGGER interface focuses solely on logging functionalities, so while it utilizes logging, it doesn't belong in the Logger class because its primary responsibility is not logging itself. Therefore, a more appropriate class for this method would be one related to plan or query optimization in your application. Since the Logger class doesn't have methods relevant to the primary function of this method, it's not suitable for this relocation.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 310,
                        "lineEnd": 316,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method physicalPlan to class Logger",
                        "description": "Move method physicalPlan to org.elasticsearch.logging.Logger\nRationale: The `physicalPlan` method involves the use of logging functionality (LOGGER.debug), which strongly indicates that it should be a part of the `Logger` class. By moving this method to the `Logger` class, it centralizes the logging behavior, making it easier to manage and ensuring that logging is encapsulated within the appropriate class. Furthermore, this aligns with the single responsibility principle, as the method deals not only with the transformation of the plan but also with logging, which should be the `Logger` class's responsibility.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 176,
                        "lineEnd": 182,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method resolvePolicy to class EnrichPolicyResolver",
                        "description": "Move method resolvePolicy to org.elasticsearch.xpack.esql.enrich.EnrichPolicyResolver\nRationale: The method `resolvePolicy` involves resolving enrich policies, which aligns closely with the core purpose of the `EnrichPolicyResolver` class. This class already contains similar functionality, such as the `resolvePolicy(String policyName, ActionListener<EnrichPolicyResolution> listener)` method. Including this method in `EnrichPolicyResolver` promotes better cohesion and ensures that policy resolution logic is centralized and easily maintained within one class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 136,
                        "lineEnd": 148,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method analyzedPlan to class Logger",
                        "description": "Move method analyzedPlan to org.elasticsearch.logging.Logger\nRationale: The analyzedPlan() method does not align with the functionalities and purposes typically associated with a class dealing with parsing and analyzing logical plans. It heavily utilizes logging as evidenced by its dependency on the LOGGER instance and debug logging statements. Therefore, the logger class, which is responsible for all logging-related activities, is a more appropriate place to house this method. This provides better separation of concerns and maintains the readability and manageability of the code.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "specificValidity",
                            "method_signature": "public static InvalidMappedField specificValidity(String fieldName, Map<String, FieldCapabilities> types)",
                            "target_class": "FieldValidator",
                            "rationale": "The method specificValidity() deals with field validity checks which are more relevant to a class that handles field validation rather than session management."
                        },
                        {
                            "method_name": "fieldNames",
                            "method_signature": "static Set<String> fieldNames(LogicalPlan parsed, Set<String> enrichPolicyMatchFields)",
                            "target_class": "IndexResolver",
                            "rationale": "The method fieldNames() is responsible for resolving field names from a logical plan, which aligns better with the responsibilities of the IndexResolver class."
                        },
                        {
                            "method_name": "matchByName",
                            "method_signature": "private static boolean matchByName(Attribute attr, String other, boolean skipIfPattern)",
                            "target_class": "IndexResolver",
                            "rationale": "The method matchByName() deals with matching attribute names which is closely related to the index resolving processes and should be part of the IndexResolver class."
                        },
                        {
                            "method_name": "subfields",
                            "method_signature": "private static Set<String> subfields(Set<String> names)",
                            "target_class": "IndexResolver",
                            "rationale": "The method subfields() processes and appends subfields to the provided field names, which is a task more related to index resolving, thus it belongs in the IndexResolver class."
                        }
                    ],
                    "llm_response_time": 7082
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "preAnalyzeIndices",
                            "method_signature": "private <T> void preAnalyzeIndices(LogicalPlan parsed, ActionListener<IndexResolution> listener, Set<String> enrichPolicyMatchFields)",
                            "target_class": "IndexResolver",
                            "rationale": "The preAnalyzeIndices method directly uses methods and operations related to resolving indices, which makes it a better fit for the IndexResolver class."
                        },
                        {
                            "method_name": "resolvePolicy",
                            "method_signature": "private void resolvePolicy(ActionListener<Void> groupedListener, Set<String> policyNames, EnrichResolution resolution)",
                            "target_class": "EnrichPolicyResolver",
                            "rationale": "resolvePolicy method focuses on resolving enrich policies, making it more suited to be placed within the EnrichPolicyResolver class."
                        },
                        {
                            "method_name": "fieldNames",
                            "method_signature": "static Set<String> fieldNames(LogicalPlan parsed, Set<String> enrichPolicyMatchFields)",
                            "target_class": "IndexResolver",
                            "rationale": "The fieldNames method determines field names that should be resolved for indices, which aligns with the responsibilities of the IndexResolver class."
                        },
                        {
                            "method_name": "matchByName",
                            "method_signature": "private static boolean matchByName(Attribute attr, String other, boolean skipIfPattern)",
                            "target_class": "Attribute",
                            "rationale": "matchByName is a utility method for comparing attribute names and patterns, which fits naturally within the Attribute class."
                        },
                        {
                            "method_name": "subfields",
                            "method_signature": "private static Set<String> subfields(Set<String> names)",
                            "target_class": "IndexResolver",
                            "rationale": "The subfields method processes and retrieves subfields for given field names, making it a better fit within the IndexResolver class."
                        },
                        {
                            "method_name": "specificValidity",
                            "method_signature": "public static InvalidMappedField specificValidity(String fieldName, Map<String, FieldCapabilities> types)",
                            "target_class": "IndexResolver",
                            "rationale": "The specificValidity method deals with validity checks for fields that are specifically related to index resolutions, making it more appropriate for the IndexResolver class."
                        }
                    ],
                    "llm_response_time": 5580
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "specificValidity",
                            "method_signature": "public static InvalidMappedField specificValidity(String fieldName, Map<String, FieldCapabilities> types)",
                            "target_class": "IndexResolver",
                            "rationale": "The method `specificValidity` is specifically validating fields and handling mappings, which is more aligned with the functionality of `IndexResolver`. Moving it there would follow the Single Responsibility Principle more closely."
                        },
                        {
                            "method_name": "fieldNames",
                            "method_signature": "static Set<String> fieldNames(LogicalPlan parsed, Set<String> enrichPolicyMatchFields)",
                            "target_class": "IndexResolver",
                            "rationale": "The `fieldNames` method involves resolving field names within the provided logical plan, which aligns more closely with the `IndexResolver` class responsibilities. Moving it would help maintain separation of concerns."
                        },
                        {
                            "method_name": "subfields",
                            "method_signature": "private static Set<String> subfields(Set<String> names)",
                            "target_class": "IndexResolver",
                            "rationale": "The `subfields` method is a private helper that is used to generate sub-field names, which is closely related to the indexing and field resolution handled by the `IndexResolver` class. Moving it would keep related responsibilities together."
                        },
                        {
                            "method_name": "matchByName",
                            "method_signature": "private static boolean matchByName(Attribute attr, String other, boolean skipIfPattern)",
                            "target_class": "IndexResolver",
                            "rationale": "The `matchByName` method checks for a match between attribute names, which is part of the field resolving functionality. It fits better within the `IndexResolver` class where such matching should be managed."
                        }
                    ],
                    "llm_response_time": 4879
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "execute",
                            "method_signature": "public execute(EsqlQueryRequest request, ActionListener<PhysicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "parse",
                            "method_signature": "private parse(String query, List<TypedParamValue> params)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "analyzedPlan",
                            "method_signature": "public analyzedPlan(LogicalPlan parsed, ActionListener<LogicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "preAnalyze",
                            "method_signature": "private preAnalyze(LogicalPlan parsed, BiFunction<IndexResolution, EnrichResolution, T> action, ActionListener<T> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "resolvePolicy",
                            "method_signature": "private resolvePolicy(ActionListener<Void> groupedListener, Set<String> policyNames, EnrichResolution resolution)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "preAnalyzeIndices",
                            "method_signature": "private preAnalyzeIndices(LogicalPlan parsed, ActionListener<IndexResolution> listener, Set<String> enrichPolicyMatchFields)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "fieldNames",
                            "method_signature": "static fieldNames(LogicalPlan parsed, Set<String> enrichPolicyMatchFields)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "optimizedPlan",
                            "method_signature": "public optimizedPlan(LogicalPlan logicalPlan, ActionListener<LogicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "physicalPlan",
                            "method_signature": "public physicalPlan(LogicalPlan optimized, ActionListener<PhysicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "optimizedPhysicalPlan",
                            "method_signature": "public optimizedPhysicalPlan(LogicalPlan logicalPlan, ActionListener<PhysicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "parse",
                            "method_signature": "private parse(String query, List<TypedParamValue> params)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "optimizedPlan",
                            "method_signature": "public optimizedPlan(LogicalPlan logicalPlan, ActionListener<LogicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "optimizedPhysicalPlan",
                            "method_signature": "public optimizedPhysicalPlan(LogicalPlan logicalPlan, ActionListener<PhysicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "physicalPlan",
                            "method_signature": "public physicalPlan(LogicalPlan optimized, ActionListener<PhysicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "execute",
                            "method_signature": "public execute(EsqlQueryRequest request, ActionListener<PhysicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "preAnalyze",
                            "method_signature": "private preAnalyze(LogicalPlan parsed, BiFunction<IndexResolution, EnrichResolution, T> action, ActionListener<T> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "resolvePolicy",
                            "method_signature": "private resolvePolicy(ActionListener<Void> groupedListener, Set<String> policyNames, EnrichResolution resolution)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "analyzedPlan",
                            "method_signature": "public analyzedPlan(LogicalPlan parsed, ActionListener<LogicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "fieldNames",
                            "method_signature": "static fieldNames(LogicalPlan parsed, Set<String> enrichPolicyMatchFields)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "preAnalyzeIndices",
                            "method_signature": "private preAnalyzeIndices(LogicalPlan parsed, ActionListener<IndexResolution> listener, Set<String> enrichPolicyMatchFields)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "private parse(String query, List<TypedParamValue> params)": {
                        "first": {
                            "method_name": "parse",
                            "method_signature": "private parse(String query, List<TypedParamValue> params)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4032335308778096
                    },
                    "public optimizedPlan(LogicalPlan logicalPlan, ActionListener<LogicalPlan> listener)": {
                        "first": {
                            "method_name": "optimizedPlan",
                            "method_signature": "public optimizedPlan(LogicalPlan logicalPlan, ActionListener<LogicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.49858876376742556
                    },
                    "public optimizedPhysicalPlan(LogicalPlan logicalPlan, ActionListener<PhysicalPlan> listener)": {
                        "first": {
                            "method_name": "optimizedPhysicalPlan",
                            "method_signature": "public optimizedPhysicalPlan(LogicalPlan logicalPlan, ActionListener<PhysicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.49858876376742556
                    },
                    "public physicalPlan(LogicalPlan optimized, ActionListener<PhysicalPlan> listener)": {
                        "first": {
                            "method_name": "physicalPlan",
                            "method_signature": "public physicalPlan(LogicalPlan optimized, ActionListener<PhysicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5046283701454143
                    },
                    "public execute(EsqlQueryRequest request, ActionListener<PhysicalPlan> listener)": {
                        "first": {
                            "method_name": "execute",
                            "method_signature": "public execute(EsqlQueryRequest request, ActionListener<PhysicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5105247018646978
                    },
                    "private preAnalyze(LogicalPlan parsed, BiFunction<IndexResolution, EnrichResolution, T> action, ActionListener<T> listener)": {
                        "first": {
                            "method_name": "preAnalyze",
                            "method_signature": "private preAnalyze(LogicalPlan parsed, BiFunction<IndexResolution, EnrichResolution, T> action, ActionListener<T> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5434950184818057
                    },
                    "private resolvePolicy(ActionListener<Void> groupedListener, Set<String> policyNames, EnrichResolution resolution)": {
                        "first": {
                            "method_name": "resolvePolicy",
                            "method_signature": "private resolvePolicy(ActionListener<Void> groupedListener, Set<String> policyNames, EnrichResolution resolution)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5443393617494376
                    },
                    "public analyzedPlan(LogicalPlan parsed, ActionListener<LogicalPlan> listener)": {
                        "first": {
                            "method_name": "analyzedPlan",
                            "method_signature": "public analyzedPlan(LogicalPlan parsed, ActionListener<LogicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5691266143952339
                    },
                    "static fieldNames(LogicalPlan parsed, Set<String> enrichPolicyMatchFields)": {
                        "first": {
                            "method_name": "fieldNames",
                            "method_signature": "static fieldNames(LogicalPlan parsed, Set<String> enrichPolicyMatchFields)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6245150618656801
                    },
                    "private preAnalyzeIndices(LogicalPlan parsed, ActionListener<IndexResolution> listener, Set<String> enrichPolicyMatchFields)": {
                        "first": {
                            "method_name": "preAnalyzeIndices",
                            "method_signature": "private preAnalyzeIndices(LogicalPlan parsed, ActionListener<IndexResolution> listener, Set<String> enrichPolicyMatchFields)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6345723301794884
                    }
                },
                "voyage": {
                    "private resolvePolicy(ActionListener<Void> groupedListener, Set<String> policyNames, EnrichResolution resolution)": {
                        "first": {
                            "method_name": "resolvePolicy",
                            "method_signature": "private resolvePolicy(ActionListener<Void> groupedListener, Set<String> policyNames, EnrichResolution resolution)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.38490096839034843
                    },
                    "public optimizedPhysicalPlan(LogicalPlan logicalPlan, ActionListener<PhysicalPlan> listener)": {
                        "first": {
                            "method_name": "optimizedPhysicalPlan",
                            "method_signature": "public optimizedPhysicalPlan(LogicalPlan logicalPlan, ActionListener<PhysicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4013143335555034
                    },
                    "public optimizedPlan(LogicalPlan logicalPlan, ActionListener<LogicalPlan> listener)": {
                        "first": {
                            "method_name": "optimizedPlan",
                            "method_signature": "public optimizedPlan(LogicalPlan logicalPlan, ActionListener<LogicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4099148607545707
                    },
                    "public physicalPlan(LogicalPlan optimized, ActionListener<PhysicalPlan> listener)": {
                        "first": {
                            "method_name": "physicalPlan",
                            "method_signature": "public physicalPlan(LogicalPlan optimized, ActionListener<PhysicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4394882914578671
                    },
                    "public analyzedPlan(LogicalPlan parsed, ActionListener<LogicalPlan> listener)": {
                        "first": {
                            "method_name": "analyzedPlan",
                            "method_signature": "public analyzedPlan(LogicalPlan parsed, ActionListener<LogicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.45955763984605197
                    },
                    "private parse(String query, List<TypedParamValue> params)": {
                        "first": {
                            "method_name": "parse",
                            "method_signature": "private parse(String query, List<TypedParamValue> params)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.46951897133491516
                    },
                    "static fieldNames(LogicalPlan parsed, Set<String> enrichPolicyMatchFields)": {
                        "first": {
                            "method_name": "fieldNames",
                            "method_signature": "static fieldNames(LogicalPlan parsed, Set<String> enrichPolicyMatchFields)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5377380796104073
                    },
                    "public execute(EsqlQueryRequest request, ActionListener<PhysicalPlan> listener)": {
                        "first": {
                            "method_name": "execute",
                            "method_signature": "public execute(EsqlQueryRequest request, ActionListener<PhysicalPlan> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5427819488887121
                    },
                    "private preAnalyze(LogicalPlan parsed, BiFunction<IndexResolution, EnrichResolution, T> action, ActionListener<T> listener)": {
                        "first": {
                            "method_name": "preAnalyze",
                            "method_signature": "private preAnalyze(LogicalPlan parsed, BiFunction<IndexResolution, EnrichResolution, T> action, ActionListener<T> listener)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5634925462929047
                    },
                    "private preAnalyzeIndices(LogicalPlan parsed, ActionListener<IndexResolution> listener, Set<String> enrichPolicyMatchFields)": {
                        "first": {
                            "method_name": "preAnalyzeIndices",
                            "method_signature": "private preAnalyzeIndices(LogicalPlan parsed, ActionListener<IndexResolution> listener, Set<String> enrichPolicyMatchFields)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7028380077264932
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private parse(String query, List<TypedParamValue> params)",
                        "private preAnalyze(LogicalPlan parsed, BiFunction<IndexResolution, EnrichResolution, T> action, ActionListener<T> listener)",
                        "private preAnalyzeIndices(LogicalPlan parsed, ActionListener<IndexResolution> listener, Set<String> enrichPolicyMatchFields)",
                        "private resolvePolicy(ActionListener<Void> groupedListener, Set<String> policyNames, EnrichResolution resolution)",
                        "static fieldNames(LogicalPlan parsed, Set<String> enrichPolicyMatchFields)",
                        "public analyzedPlan(LogicalPlan parsed, ActionListener<LogicalPlan> listener)",
                        "public optimizedPlan(LogicalPlan logicalPlan, ActionListener<LogicalPlan> listener)",
                        "public physicalPlan(LogicalPlan optimized, ActionListener<PhysicalPlan> listener)",
                        "public optimizedPhysicalPlan(LogicalPlan logicalPlan, ActionListener<PhysicalPlan> listener)",
                        "public execute(EsqlQueryRequest request, ActionListener<PhysicalPlan> listener)"
                    ],
                    "llm_response_time": 13003
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public execute(EsqlQueryRequest request, ActionListener<PhysicalPlan> listener)",
                        "public optimizedPhysicalPlan(LogicalPlan logicalPlan, ActionListener<PhysicalPlan> listener)",
                        "public physicalPlan(LogicalPlan optimized, ActionListener<PhysicalPlan> listener)",
                        "public optimizedPlan(LogicalPlan logicalPlan, ActionListener<LogicalPlan> listener)",
                        "private parse(String query, List<TypedParamValue> params)"
                    ],
                    "llm_response_time": 6279
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private parse(String query, List<TypedParamValue> params)",
                        "public optimizedPlan(LogicalPlan logicalPlan, ActionListener<LogicalPlan> listener)",
                        "public optimizedPhysicalPlan(LogicalPlan logicalPlan, ActionListener<PhysicalPlan> listener)"
                    ],
                    "llm_response_time": 4287
                },
                "voyage": {
                    "priority_method_names": [
                        "public execute(EsqlQueryRequest request, ActionListener<PhysicalPlan> listener)",
                        "private parse(String query, List<TypedParamValue> params)",
                        "public analyzedPlan(LogicalPlan parsed, ActionListener<LogicalPlan> listener)",
                        "public optimizedPlan(LogicalPlan logicalPlan, ActionListener<LogicalPlan> listener)",
                        "public physicalPlan(LogicalPlan optimized, ActionListener<PhysicalPlan> listener)",
                        "public optimizedPhysicalPlan(LogicalPlan logicalPlan, ActionListener<PhysicalPlan> listener)",
                        "private preAnalyze(LogicalPlan parsed, BiFunction<IndexResolution, EnrichResolution, T> action, ActionListener<T> listener)",
                        "private preAnalyzeIndices(LogicalPlan parsed, ActionListener<IndexResolution> listener, Set<String> enrichPolicyMatchFields)",
                        "private resolvePolicy(ActionListener<Void> groupedListener, Set<String> policyNames, EnrichResolution resolution)",
                        "static fieldNames(LogicalPlan parsed, Set<String> enrichPolicyMatchFields)"
                    ],
                    "llm_response_time": 6903
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private resolvePolicy(ActionListener<Void> groupedListener, Set<String> policyNames, EnrichResolution resolution)",
                        "public analyzedPlan(LogicalPlan parsed, ActionListener<LogicalPlan> listener)",
                        "public optimizedPlan(LogicalPlan logicalPlan, ActionListener<LogicalPlan> listener)",
                        "public physicalPlan(LogicalPlan optimized, ActionListener<PhysicalPlan> listener)",
                        "public optimizedPhysicalPlan(LogicalPlan logicalPlan, ActionListener<PhysicalPlan> listener)"
                    ],
                    "llm_response_time": 5966
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public optimizedPhysicalPlan(LogicalPlan logicalPlan, ActionListener<PhysicalPlan> listener)",
                        "public optimizedPlan(LogicalPlan logicalPlan, ActionListener<LogicalPlan> listener)",
                        "private resolvePolicy(ActionListener<Void> groupedListener, Set<String> policyNames, EnrichResolution resolution)"
                    ],
                    "llm_response_time": 4154
                }
            },
            "targetClassMap": {
                "parse": {
                    "target_classes": [
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.006058728646323643
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Logger"
                    ],
                    "llm_response_time": 3252,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "optimizedPlan": {
                    "target_classes": [
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.02391235445728518
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Logger"
                    ],
                    "llm_response_time": 2135,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "optimizedPhysicalPlan": {
                    "target_classes": [
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.02391235445728518
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Logger"
                    ],
                    "llm_response_time": 2246,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "physicalPlan": {
                    "target_classes": [
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.024385912398728907
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Logger"
                    ],
                    "llm_response_time": 2516,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "execute": {
                    "target_classes": [
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.10001244876369213
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Logger"
                    ],
                    "llm_response_time": 2620,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "preAnalyze": {
                    "target_classes": [
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.15891717821612045
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Logger"
                    ],
                    "llm_response_time": 2446,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "resolvePolicy": {
                    "target_classes": [
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.035794652036559564
                        },
                        {
                            "class_name": "EnrichPolicyResolver",
                            "similarity_score": 0.628088438679442
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "EnrichPolicyResolver",
                        "Logger"
                    ],
                    "llm_response_time": 3758,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "analyzedPlan": {
                    "target_classes": [
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.027241613985311046
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Logger"
                    ],
                    "llm_response_time": 2165,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "fieldNames": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 4164,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "preAnalyzeIndices": {
                    "target_classes": [
                        {
                            "class_name": "Logger",
                            "similarity_score": 0.17202208146823253
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Logger"
                    ],
                    "llm_response_time": 2694,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/elastic/elasticsearch.git",
        "sha1": "04d3b9989fe03d3591d9eb637dc54f7813e174ea",
        "url": "https://github.com/elastic/elasticsearch/commit/04d3b9989fe03d3591d9eb637dc54f7813e174ea",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public getBooleanLookup(positions IntBlock, targetBlockSize ByteSizeValue) : ReleasableIterator<BooleanBlock> extracted from public lookup(positions IntBlock, targetBlockSize ByteSizeValue) : ReleasableIterator<BooleanBlock> in class org.elasticsearch.compute.data.BooleanVectorBlock & moved to class org.elasticsearch.compute.data.BooleanVector",
            "leftSideLocations": [
                {
                    "filePath": "x-pack/plugin/esql/compute/src/main/generated-src/org/elasticsearch/compute/data/BooleanVectorBlock.java",
                    "startLine": 54,
                    "endLine": 58,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "public lookup(positions IntBlock, targetBlockSize ByteSizeValue) : ReleasableIterator<BooleanBlock>"
                },
                {
                    "filePath": "x-pack/plugin/esql/compute/src/main/generated-src/org/elasticsearch/compute/data/BooleanVectorBlock.java",
                    "startLine": 57,
                    "endLine": 57,
                    "startColumn": 9,
                    "endColumn": 68,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "x-pack/plugin/esql/compute/src/main/generated-src/org/elasticsearch/compute/data/BooleanArrayVector.java",
                    "startLine": 96,
                    "endLine": 99,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public lookup(positions IntBlock, targetBlockSize ByteSizeValue) : ReleasableIterator<BooleanBlock>"
                },
                {
                    "filePath": "x-pack/plugin/esql/compute/src/main/generated-src/org/elasticsearch/compute/data/BooleanArrayVector.java",
                    "startLine": 98,
                    "endLine": 98,
                    "startColumn": 9,
                    "endColumn": 73,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/compute/src/main/generated-src/org/elasticsearch/compute/data/BooleanVectorBlock.java",
                    "startLine": 54,
                    "endLine": 57,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "public lookup(positions IntBlock, targetBlockSize ByteSizeValue) : ReleasableIterator<? extends BooleanBlock>"
                },
                {
                    "filePath": "x-pack/plugin/esql/compute/src/main/generated-src/org/elasticsearch/compute/data/BooleanVectorBlock.java",
                    "startLine": 56,
                    "endLine": 56,
                    "startColumn": 16,
                    "endColumn": 57,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "vector.lookup(positions,targetBlockSize)"
                }
            ],
            "isStatic": false
        },
        "ref_id": 278,
        "extraction_results": {
            "success": true,
            "newCommitHash": "e296af65645e6eaef82d41df52289cc487a8f414",
            "newBranchName": "extract-lookup-lookup-2d14095-1"
        },
        "telemetry": {
            "id": "ab621748-f307-4f84-8c96-0c8880ddd223",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 95,
                "lineStart": 14,
                "lineEnd": 108,
                "bodyLineStart": 14,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/elasticsearch/x-pack/plugin/esql/compute/src/main/generated-src/org/elasticsearch/compute/data/BooleanVectorBlock.java",
                "sourceCode": "/**\n * Block view of a {@link BooleanVector}. Cannot represent multi-values or nulls.\n * This class is generated. Do not edit it.\n */\npublic final class BooleanVectorBlock extends AbstractVectorBlock implements BooleanBlock {\n\n    private final BooleanVector vector;\n\n    /**\n     * @param vector considered owned by the current block; must not be used in any other {@code Block}\n     */\n    BooleanVectorBlock(BooleanVector vector) {\n        this.vector = vector;\n    }\n\n    @Override\n    public BooleanVector asVector() {\n        return vector;\n    }\n\n    @Override\n    public boolean getBoolean(int valueIndex) {\n        return vector.getBoolean(valueIndex);\n    }\n\n    @Override\n    public int getPositionCount() {\n        return vector.getPositionCount();\n    }\n\n    @Override\n    public ElementType elementType() {\n        return vector.elementType();\n    }\n\n    @Override\n    public BooleanBlock filter(int... positions) {\n        return vector.filter(positions).asBlock();\n    }\n\n    @Override\n    public ReleasableIterator<BooleanBlock> lookup(IntBlock positions, ByteSizeValue targetBlockSize) {\n        // TODO optimizations\n        return getBooleanLookup(positions, targetBlockSize);\n    }\n\n    private BooleanLookup getBooleanLookup(IntBlock positions, ByteSizeValue targetBlockSize) {\n        return new BooleanLookup(this.vector.asBlock(), positions, targetBlockSize);\n    }\n\n    @Override\n    public BooleanBlock expand() {\n        incRef();\n        return this;\n    }\n\n    @Override\n    public long ramBytesUsed() {\n        return vector.ramBytesUsed();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof BooleanBlock that) {\n            return BooleanBlock.equals(this, that);\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return BooleanBlock.hash(this);\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + \"[vector=\" + vector + \"]\";\n    }\n\n    @Override\n    public void closeInternal() {\n        assert (vector.isReleased() == false) : \"can't release block [\" + this + \"] containing already released vector\";\n        Releasables.closeExpectNoException(vector);\n    }\n\n    @Override\n    public void allowPassingToDifferentDriver() {\n        vector.allowPassingToDifferentDriver();\n    }\n\n    @Override\n    public BlockFactory blockFactory() {\n        return vector.blockFactory();\n    }\n}",
                "methodCount": 16
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 59,
                        "lineEnd": 61,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getBooleanLookup to class BooleanVector",
                        "description": "Move method getBooleanLookup to org.elasticsearch.compute.data.BooleanVector\nRationale: The getBooleanLookup() method creates a BooleanLookup object using the current instance's 'vector' attribute and some IntBlock positions. Based on the class bodies provided, 'BooleanVector' already provides functionality closely related to dealing with boolean values and blocks. The method relies on transforming an input of IntBlock type and wrapping the 'vector' attribute, which is significantly more aligned with the responsibilities of the BooleanVector class. By moving this method to the BooleanVector class, we improve cohesion and ensure the BooleanVector class manages behavior directly related to its BooleanBlock transformations and lookup operations.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "elapsedTime": [
                {
                    "candidateIndex": 0,
                    "elapsedTime": 6097
                }
            ],
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 14726
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getBooleanLookup",
                            "method_signature": "private BooleanLookup getBooleanLookup(IntBlock positions, ByteSizeValue targetBlockSize)",
                            "target_class": "BooleanLookup",
                            "rationale": "The method getBooleanLookup() is specifically creating an instance of BooleanLookup based on the vector and positions. It would be more appropriate for the functionality to be encapsulated within the BooleanLookup class or a factory associated with it."
                        },
                        {
                            "method_name": "equals",
                            "method_signature": "public boolean equals(Object obj)",
                            "target_class": "BooleanBlock",
                            "rationale": "The method equals() is comparing instances of BooleanBlock. This logic should be in the BooleanBlock class to ensure consistent and centralized equality checks."
                        },
                        {
                            "method_name": "hashCode",
                            "method_signature": "public int hashCode()",
                            "target_class": "BooleanBlock",
                            "rationale": "The hashCode() method should be in the BooleanBlock class to ensure that hash codes for BooleanBlock instances are generated consistently and centrally."
                        }
                    ],
                    "llm_response_time": 3979
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [],
                    "llm_response_time": 884
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "allowPassingToDifferentDriver",
                            "method_signature": "public void allowPassingToDifferentDriver()",
                            "target_class": "BooleanVector",
                            "rationale": "This method calls the same method on the BooleanVector instance, indicating that the operation is more closely related to the BooleanVector class and can be handled internally there."
                        }
                    ],
                    "llm_response_time": 1728
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getBooleanLookup",
                            "method_signature": "private getBooleanLookup(IntBlock positions, ByteSizeValue targetBlockSize)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "getBooleanLookup",
                            "method_signature": "private getBooleanLookup(IntBlock positions, ByteSizeValue targetBlockSize)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "private getBooleanLookup(IntBlock positions, ByteSizeValue targetBlockSize)": {
                        "first": {
                            "method_name": "getBooleanLookup",
                            "method_signature": "private getBooleanLookup(IntBlock positions, ByteSizeValue targetBlockSize)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.36864269407847466
                    }
                },
                "voyage": {
                    "private getBooleanLookup(IntBlock positions, ByteSizeValue targetBlockSize)": {
                        "first": {
                            "method_name": "getBooleanLookup",
                            "method_signature": "private getBooleanLookup(IntBlock positions, ByteSizeValue targetBlockSize)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6404287763896864
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private getBooleanLookup(IntBlock positions, ByteSizeValue targetBlockSize)"
                    ],
                    "llm_response_time": 1740
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "private getBooleanLookup(IntBlock positions, ByteSizeValue targetBlockSize)"
                    ],
                    "llm_response_time": 0
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private getBooleanLookup(IntBlock positions, ByteSizeValue targetBlockSize)"
                    ],
                    "llm_response_time": 1
                },
                "voyage": {
                    "priority_method_names": [
                        "private getBooleanLookup(IntBlock positions, ByteSizeValue targetBlockSize)"
                    ],
                    "llm_response_time": 0
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private getBooleanLookup(IntBlock positions, ByteSizeValue targetBlockSize)"
                    ],
                    "llm_response_time": 0
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private getBooleanLookup(IntBlock positions, ByteSizeValue targetBlockSize)"
                    ],
                    "llm_response_time": 0
                }
            },
            "targetClassMap": {
                "getBooleanLookup": {
                    "target_classes": [
                        {
                            "class_name": "IntBlock",
                            "similarity_score": 0.273541324019986
                        },
                        {
                            "class_name": "BooleanVector",
                            "similarity_score": 0.2571310020228169
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BooleanVector",
                        "IntBlock"
                    ],
                    "llm_response_time": 5831,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/elastic/elasticsearch.git",
        "sha1": "04d3b9989fe03d3591d9eb637dc54f7813e174ea",
        "url": "https://github.com/elastic/elasticsearch/commit/04d3b9989fe03d3591d9eb637dc54f7813e174ea",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public getBytesRefLookup(positions IntBlock, targetBlockSize ByteSizeValue) : ReleasableIterator<BooleanBlock> extracted from public lookup(positions IntBlock, targetBlockSize ByteSizeValue) : ReleasableIterator<BytesRefBlock> in class org.elasticsearch.compute.data.BytesRefVectorBlock & moved to class org.elasticsearch.compute.data.BytesRefVector",
            "leftSideLocations": [
                {
                    "filePath": "x-pack/plugin/esql/compute/src/main/generated-src/org/elasticsearch/compute/data/BytesRefVectorBlock.java",
                    "startLine": 65,
                    "endLine": 69,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "public lookup(positions IntBlock, targetBlockSize ByteSizeValue) : ReleasableIterator<BytesRefBlock>"
                },
                {
                    "filePath": "x-pack/plugin/esql/compute/src/main/generated-src/org/elasticsearch/compute/data/BytesRefVectorBlock.java",
                    "startLine": 68,
                    "endLine": 68,
                    "startColumn": 9,
                    "endColumn": 69,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "x-pack/plugin/esql/compute/src/main/generated-src/org/elasticsearch/compute/data/BooleanArrayVector.java",
                    "startLine": 96,
                    "endLine": 99,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public lookup(positions IntBlock, targetBlockSize ByteSizeValue) : ReleasableIterator<BooleanBlock>"
                },
                {
                    "filePath": "x-pack/plugin/esql/compute/src/main/generated-src/org/elasticsearch/compute/data/BooleanArrayVector.java",
                    "startLine": 98,
                    "endLine": 98,
                    "startColumn": 9,
                    "endColumn": 73,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/compute/src/main/generated-src/org/elasticsearch/compute/data/BytesRefVectorBlock.java",
                    "startLine": 65,
                    "endLine": 68,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "public lookup(positions IntBlock, targetBlockSize ByteSizeValue) : ReleasableIterator<? extends BytesRefBlock>"
                },
                {
                    "filePath": "x-pack/plugin/esql/compute/src/main/generated-src/org/elasticsearch/compute/data/BytesRefVectorBlock.java",
                    "startLine": 67,
                    "endLine": 67,
                    "startColumn": 16,
                    "endColumn": 57,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "vector.lookup(positions,targetBlockSize)"
                }
            ],
            "isStatic": false
        },
        "ref_id": 279,
        "extraction_results": {
            "success": true,
            "newCommitHash": "dde3bba3af25da551460a5f8f96080e5e84717e3",
            "newBranchName": "extract-lookup-lookup-2d14095-2"
        },
        "telemetry": {
            "id": "40fcd561-625b-49bb-a07e-4f978efb5600",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 105,
                "lineStart": 15,
                "lineEnd": 119,
                "bodyLineStart": 15,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/elasticsearch/x-pack/plugin/esql/compute/src/main/generated-src/org/elasticsearch/compute/data/BytesRefVectorBlock.java",
                "sourceCode": "/**\n * Block view of a {@link BytesRefVector}. Cannot represent multi-values or nulls.\n * This class is generated. Do not edit it.\n */\npublic final class BytesRefVectorBlock extends AbstractVectorBlock implements BytesRefBlock {\n\n    private final BytesRefVector vector;\n\n    /**\n     * @param vector considered owned by the current block; must not be used in any other {@code Block}\n     */\n    BytesRefVectorBlock(BytesRefVector vector) {\n        this.vector = vector;\n    }\n\n    @Override\n    public BytesRefVector asVector() {\n        return vector;\n    }\n\n    @Override\n    public OrdinalBytesRefBlock asOrdinals() {\n        var ordinals = vector.asOrdinals();\n        if (ordinals != null) {\n            return ordinals.asBlock();\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public BytesRef getBytesRef(int valueIndex, BytesRef dest) {\n        return vector.getBytesRef(valueIndex, dest);\n    }\n\n    @Override\n    public int getPositionCount() {\n        return vector.getPositionCount();\n    }\n\n    @Override\n    public ElementType elementType() {\n        return vector.elementType();\n    }\n\n    @Override\n    public BytesRefBlock filter(int... positions) {\n        return vector.filter(positions).asBlock();\n    }\n\n    @Override\n    public ReleasableIterator<BytesRefBlock> lookup(IntBlock positions, ByteSizeValue targetBlockSize) {\n        // TODO optimizations\n        return getBytesRefLookup(positions, targetBlockSize);\n    }\n\n    private BytesRefLookup getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize) {\n        return new BytesRefLookup(this.vector.asBlock(), positions, targetBlockSize);\n    }\n\n    @Override\n    public BytesRefBlock expand() {\n        incRef();\n        return this;\n    }\n\n    @Override\n    public long ramBytesUsed() {\n        return vector.ramBytesUsed();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof BytesRefBlock that) {\n            return BytesRefBlock.equals(this, that);\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return BytesRefBlock.hash(this);\n    }\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + \"[vector=\" + vector + \"]\";\n    }\n\n    @Override\n    public void closeInternal() {\n        assert (vector.isReleased() == false) : \"can't release block [\" + this + \"] containing already released vector\";\n        Releasables.closeExpectNoException(vector);\n    }\n\n    @Override\n    public void allowPassingToDifferentDriver() {\n        vector.allowPassingToDifferentDriver();\n    }\n\n    @Override\n    public BlockFactory blockFactory() {\n        return vector.blockFactory();\n    }\n}",
                "methodCount": 17
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 70,
                        "lineEnd": 72,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method getBytesRefLookup to class IntBlock",
                        "description": "Move method getBytesRefLookup to org.elasticsearch.compute.data.IntBlock\nRationale: The getBytesRefLookup method utilizes the IntBlock type parameters (positions) and is closely associated with handling blocks of integer values, which fall within the responsibilities of the IntBlock class. The IntBlock class also has the lookup method, implying it deals with mappings and lookups relevant to its contained data, making it the most appropriate class to house the getBytesRefLookup method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "elapsedTime": [
                {
                    "candidateIndex": 0,
                    "elapsedTime": 2625
                }
            ],
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 17761
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getBytesRefLookup",
                            "method_signature": "private BytesRefLookup getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize)",
                            "target_class": "BytesRefVector",
                            "rationale": "The getBytesRefLookup method is directly related to the BytesRefVector and uses its instance. It makes sense to move it to BytesRefVector to encapsulate the behavior within the class it is acting upon."
                        },
                        {
                            "method_name": "equals",
                            "method_signature": "public boolean equals(Object obj)",
                            "target_class": "BytesRefBlock",
                            "rationale": "The equals method implementation is related to the equality of BytesRefBlock instances. It should ideally be part of the BytesRefBlock interface or an abstract class implementing BytesRefBlock to maintain consistency and avoid redundancy."
                        },
                        {
                            "method_name": "hashCode",
                            "method_signature": "public int hashCode()",
                            "target_class": "BytesRefBlock",
                            "rationale": "Similar to equals, the hashCode method is essential for the consistency and correctness of instances that implement BytesRefBlock. It would be appropriate to include this in the BytesRefBlock or an abstract class implementing BytesRefBlock."
                        }
                    ],
                    "llm_response_time": 5174
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "hashCode",
                            "method_signature": "public int hashCode()",
                            "target_class": "BytesRefBlock",
                            "rationale": "The hashCode method uses the BytesRefBlock class and is better suited to it, as it is part of the functionality related to equality and hashing for BytesRefBlock instances."
                        },
                        {
                            "method_name": "equals",
                            "method_signature": "public boolean equals(Object obj)",
                            "target_class": "BytesRefBlock",
                            "rationale": "The equals method is related to comparing instances of BytesRefBlock and should reside in the BytesRefBlock class where it can be more coherently managed."
                        },
                        {
                            "method_name": "getBytesRefLookup",
                            "method_signature": "private BytesRefLookup getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize)",
                            "target_class": "BytesRefVector",
                            "rationale": "The getBytesRefLookup method is closely related to the inner workings of BytesRefVector, and moving it there will unify the responsibility of managing BytesRef lookups."
                        }
                    ],
                    "llm_response_time": 3568
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "getBytesRefLookup",
                            "method_signature": "private BytesRefLookup getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize)",
                            "target_class": "BytesRefVector",
                            "rationale": "The getBytesRefLookup method relies heavily on the vector object of BytesRefVector class, accessing its methods to create an instance of BytesRefLookup. Therefore, it would be more appropriate for this functionality to reside within the BytesRefVector class."
                        },
                        {
                            "method_name": "allowPassingToDifferentDriver",
                            "method_signature": "public void allowPassingToDifferentDriver()",
                            "target_class": "BytesRefVector",
                            "rationale": "The allowPassingToDifferentDriver method calls vector.allowPassingToDifferentDriver() directly. This behavior is tightly coupled with the BytesRefVector class and should be moved there for clearer responsibility and cohesion."
                        }
                    ],
                    "llm_response_time": 2853
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "getBytesRefLookup",
                            "method_signature": "private getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "getBytesRefLookup",
                            "method_signature": "private getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize)",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "private getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize)": {
                        "first": {
                            "method_name": "getBytesRefLookup",
                            "method_signature": "private getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3780152712720746
                    }
                },
                "voyage": {
                    "private getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize)": {
                        "first": {
                            "method_name": "getBytesRefLookup",
                            "method_signature": "private getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.669441805631407
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize)"
                    ],
                    "llm_response_time": 1316
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "private getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize)"
                    ],
                    "llm_response_time": 0
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize)"
                    ],
                    "llm_response_time": 0
                },
                "voyage": {
                    "priority_method_names": [
                        "private getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize)"
                    ],
                    "llm_response_time": 0
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize)"
                    ],
                    "llm_response_time": 0
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private getBytesRefLookup(IntBlock positions, ByteSizeValue targetBlockSize)"
                    ],
                    "llm_response_time": 0
                }
            },
            "targetClassMap": {
                "getBytesRefLookup": {
                    "target_classes": [
                        {
                            "class_name": "IntBlock",
                            "similarity_score": 0.273541324019986
                        },
                        {
                            "class_name": "BytesRefVector",
                            "similarity_score": 0.26995379041977813
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "IntBlock",
                        "BytesRefVector"
                    ],
                    "llm_response_time": 4343,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/elastic/elasticsearch.git",
        "sha1": "5add44d7d1d24fd77fd50d98d321e0ef733ea0cc",
        "url": "https://github.com/elastic/elasticsearch/commit/5add44d7d1d24fd77fd50d98d321e0ef733ea0cc",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public checkDimensions(dvDims int, qvDims int) : void extracted from private createExactKnnByteQuery(queryVector byte[]) : Query in class org.elasticsearch.index.mapper.vectors.DenseVectorFieldMapper.DenseVectorFieldType & moved to class org.elasticsearch.index.mapper.vectors.DenseVectorFieldMapper.ElementType",
            "leftSideLocations": [
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/mapper/vectors/DenseVectorFieldMapper.java",
                    "startLine": 1469,
                    "endLine": 1480,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "private createExactKnnByteQuery(queryVector byte[]) : Query"
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/mapper/vectors/DenseVectorFieldMapper.java",
                    "startLine": 1471,
                    "endLine": 1473,
                    "startColumn": 17,
                    "endColumn": 19,
                    "codeElementType": "THROW_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/mapper/vectors/DenseVectorFieldMapper.java",
                    "startLine": 1470,
                    "endLine": 1474,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/mapper/vectors/DenseVectorFieldMapper.java",
                    "startLine": 1470,
                    "endLine": 1474,
                    "startColumn": 45,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/mapper/vectors/DenseVectorFieldMapper.java",
                    "startLine": 964,
                    "endLine": 970,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public checkDimensions(dvDims int, qvDims int) : void"
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/mapper/vectors/DenseVectorFieldMapper.java",
                    "startLine": 966,
                    "endLine": 968,
                    "startColumn": 17,
                    "endColumn": 19,
                    "codeElementType": "THROW_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/mapper/vectors/DenseVectorFieldMapper.java",
                    "startLine": 965,
                    "endLine": 969,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/mapper/vectors/DenseVectorFieldMapper.java",
                    "startLine": 965,
                    "endLine": 969,
                    "startColumn": 35,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/mapper/vectors/DenseVectorFieldMapper.java",
                    "startLine": 1724,
                    "endLine": 1731,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "private createExactKnnByteQuery(queryVector byte[]) : Query"
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/index/mapper/vectors/DenseVectorFieldMapper.java",
                    "startLine": 1725,
                    "endLine": 1725,
                    "startColumn": 13,
                    "endColumn": 66,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "elementType.checkDimensions(dims,queryVector.length)"
                }
            ],
            "isStatic": false
        },
        "ref_id": 363,
        "extraction_results": {
            "success": true,
            "newCommitHash": "64736f155724aa07422d18aca0b1d06faa829904",
            "newBranchName": "extract-checkDimensions-createExactKnnByteQuery-97651df"
        },
        "telemetry": {
            "id": "c162f995-b249-42ef-a28c-9560d47d6d65",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 257,
                "lineStart": 1343,
                "lineEnd": 1599,
                "bodyLineStart": 1343,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/elasticsearch/server/src/main/java/org/elasticsearch/index/mapper/vectors/DenseVectorFieldMapper.java",
                "sourceCode": "public static final class DenseVectorFieldType extends SimpleMappedFieldType {\n        private final ElementType elementType;\n        private final Integer dims;\n        private final boolean indexed;\n        private final VectorSimilarity similarity;\n        private final IndexVersion indexVersionCreated;\n        private final IndexOptions indexOptions;\n\n        public DenseVectorFieldType(\n            String name,\n            IndexVersion indexVersionCreated,\n            ElementType elementType,\n            Integer dims,\n            boolean indexed,\n            VectorSimilarity similarity,\n            IndexOptions indexOptions,\n            Map<String, String> meta\n        ) {\n            super(name, indexed, false, indexed == false, TextSearchInfo.NONE, meta);\n            this.elementType = elementType;\n            this.dims = dims;\n            this.indexed = indexed;\n            this.similarity = similarity;\n            this.indexVersionCreated = indexVersionCreated;\n            this.indexOptions = indexOptions;\n        }\n\n        @Override\n        public String typeName() {\n            return CONTENT_TYPE;\n        }\n\n        @Override\n        public ValueFetcher valueFetcher(SearchExecutionContext context, String format) {\n            if (format != null) {\n                throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] doesn't support formats.\");\n            }\n            return new ArraySourceValueFetcher(name(), context) {\n                @Override\n                protected Object parseSourceValue(Object value) {\n                    return value;\n                }\n            };\n        }\n\n        @Override\n        public DocValueFormat docValueFormat(String format, ZoneId timeZone) {\n            throw new IllegalArgumentException(\n                \"Field [\" + name() + \"] of type [\" + typeName() + \"] doesn't support docvalue_fields or aggregations\"\n            );\n        }\n\n        @Override\n        public boolean isAggregatable() {\n            return false;\n        }\n\n        @Override\n        public IndexFieldData.Builder fielddataBuilder(FieldDataContext fieldDataContext) {\n            return elementType.fielddataBuilder(this, fieldDataContext);\n        }\n\n        @Override\n        public Query existsQuery(SearchExecutionContext context) {\n            return new FieldExistsQuery(name());\n        }\n\n        @Override\n        public Query termQuery(Object value, SearchExecutionContext context) {\n            throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] doesn't support term queries\");\n        }\n\n        public Query createKnnQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        ) {\n            if (isIndexed() == false) {\n                throw new IllegalArgumentException(\n                    \"to perform knn search on field [\" + name() + \"], its mapping must have [index] set to [true]\"\n                );\n            }\n\n            checkDimensions(queryVector.length, dims);\n\n            if (elementType != ElementType.BYTE) {\n                throw new IllegalArgumentException(\n                    \"only [\" + ElementType.BYTE + \"] elements are supported when querying field [\" + name() + \"]\"\n                );\n            }\n\n            if (similarity == VectorSimilarity.DOT_PRODUCT || similarity == VectorSimilarity.COSINE) {\n                float squaredMagnitude = VectorUtil.dotProduct(queryVector, queryVector);\n                elementType.checkVectorMagnitude(similarity, ElementType.errorByteElementsAppender(queryVector), squaredMagnitude);\n            }\n            Query knnQuery = parentFilter != null\n                ? new ESDiversifyingChildrenByteKnnVectorQuery(name(), queryVector, filter, numCands, parentFilter)\n                : new ESKnnByteVectorQuery(name(), queryVector, numCands, filter);\n            if (similarityThreshold != null) {\n                knnQuery = new VectorSimilarityQuery(\n                    knnQuery,\n                    similarityThreshold,\n                    similarity.score(similarityThreshold, elementType, dims)\n                );\n            }\n            return knnQuery;\n        }\n\n        public Query createExactKnnQuery(VectorData queryVector) {\n            if (isIndexed() == false) {\n                throw new IllegalArgumentException(\n                    \"to perform knn search on field [\" + name() + \"], its mapping must have [index] set to [true]\"\n                );\n            }\n            return switch (elementType) {\n                case BYTE -> createExactKnnByteQuery(queryVector.asByteVector());\n                case FLOAT -> createExactKnnFloatQuery(queryVector.asFloatVector());\n            };\n        }\n\n        private Query createExactKnnByteQuery(byte[] queryVector) {\n            checkDimensions(queryVector.length, dims);\n            if (similarity == VectorSimilarity.DOT_PRODUCT || similarity == VectorSimilarity.COSINE) {\n                float squaredMagnitude = VectorUtil.dotProduct(queryVector, queryVector);\n                elementType.checkVectorMagnitude(similarity, ElementType.errorByteElementsAppender(queryVector), squaredMagnitude);\n            }\n            return new DenseVectorQuery.Bytes(queryVector, name());\n        }\n\n        private void checkDimensions(int length, Integer dims) {\n            if (length != dims) {\n                throw new IllegalArgumentException(\n                    \"the query vector has a different dimension [\" + length + \"] than the index vectors [\" + dims + \"]\"\n                );\n            }\n        }\n\n        private Query createExactKnnFloatQuery(float[] queryVector) {\n            checkDimensions(queryVector.length, dims);\n            elementType.checkVectorBounds(queryVector);\n            if (similarity == VectorSimilarity.DOT_PRODUCT || similarity == VectorSimilarity.COSINE) {\n                float squaredMagnitude = VectorUtil.dotProduct(queryVector, queryVector);\n                elementType.checkVectorMagnitude(similarity, ElementType.errorFloatElementsAppender(queryVector), squaredMagnitude);\n                if (similarity == VectorSimilarity.COSINE\n                    && indexVersionCreated.onOrAfter(NORMALIZE_COSINE)\n                    && isNotUnitVector(squaredMagnitude)) {\n                    float length = (float) Math.sqrt(squaredMagnitude);\n                    queryVector = Arrays.copyOf(queryVector, queryVector.length);\n                    for (int i = 0; i < queryVector.length; i++) {\n                        queryVector[i] /= length;\n                    }\n                }\n            }\n            return new DenseVectorQuery.Floats(queryVector, name());\n        }\n\n        Query createKnnQuery(float[] queryVector, int numCands, Query filter, Float similarityThreshold, BitSetProducer parentFilter) {\n            return createKnnQuery(VectorData.fromFloats(queryVector), numCands, filter, similarityThreshold, parentFilter);\n        }\n\n        public Query createKnnQuery(\n            VectorData queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        ) {\n            if (isIndexed() == false) {\n                throw new IllegalArgumentException(\n                    \"to perform knn search on field [\" + name() + \"], its mapping must have [index] set to [true]\"\n                );\n            }\n            return switch (getElementType()) {\n                case BYTE -> createKnnByteQuery(queryVector.asByteVector(), numCands, filter, similarityThreshold, parentFilter);\n                case FLOAT -> createKnnFloatQuery(queryVector.asFloatVector(), numCands, filter, similarityThreshold, parentFilter);\n            };\n        }\n\n        private Query createKnnByteQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        ) {\n            checkDimensions(queryVector.length, dims);\n\n            if (similarity == VectorSimilarity.DOT_PRODUCT || similarity == VectorSimilarity.COSINE) {\n                float squaredMagnitude = VectorUtil.dotProduct(queryVector, queryVector);\n                elementType.checkVectorMagnitude(similarity, ElementType.errorByteElementsAppender(queryVector), squaredMagnitude);\n            }\n            Query knnQuery = parentFilter != null\n                ? new ESDiversifyingChildrenByteKnnVectorQuery(name(), queryVector, filter, numCands, parentFilter)\n                : new ESKnnByteVectorQuery(name(), queryVector, numCands, filter);\n            if (similarityThreshold != null) {\n                knnQuery = new VectorSimilarityQuery(\n                    knnQuery,\n                    similarityThreshold,\n                    similarity.score(similarityThreshold, elementType, dims)\n                );\n            }\n            return knnQuery;\n        }\n\n        private Query createKnnFloatQuery(\n            float[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        ) {\n            checkDimensions(queryVector.length, dims);\n            elementType.checkVectorBounds(queryVector);\n            if (similarity == VectorSimilarity.DOT_PRODUCT || similarity == VectorSimilarity.COSINE) {\n                float squaredMagnitude = VectorUtil.dotProduct(queryVector, queryVector);\n                elementType.checkVectorMagnitude(similarity, ElementType.errorFloatElementsAppender(queryVector), squaredMagnitude);\n                if (similarity == VectorSimilarity.COSINE\n                    && indexVersionCreated.onOrAfter(NORMALIZE_COSINE)\n                    && isNotUnitVector(squaredMagnitude)) {\n                    float length = (float) Math.sqrt(squaredMagnitude);\n                    queryVector = Arrays.copyOf(queryVector, queryVector.length);\n                    for (int i = 0; i < queryVector.length; i++) {\n                        queryVector[i] /= length;\n                    }\n                }\n            }\n            Query knnQuery = parentFilter != null\n                ? new ESDiversifyingChildrenFloatKnnVectorQuery(name(), queryVector, filter, numCands, parentFilter)\n                : new ESKnnFloatVectorQuery(name(), queryVector, numCands, filter);\n            if (similarityThreshold != null) {\n                knnQuery = new VectorSimilarityQuery(\n                    knnQuery,\n                    similarityThreshold,\n                    similarity.score(similarityThreshold, elementType, dims)\n                );\n            }\n            return knnQuery;\n        }\n\n        VectorSimilarity getSimilarity() {\n            return similarity;\n        }\n\n        int getVectorDimensions() {\n            return dims;\n        }\n\n        ElementType getElementType() {\n            return elementType;\n        }\n\n        IndexOptions getIndexOptions() {\n            return indexOptions;\n        }\n    }",
                "methodCount": 22
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 7,
                "candidates": [
                    {
                        "lineStart": 1504,
                        "lineEnd": 1520,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method createKnnQuery to class ElementType",
                        "description": "Move method createKnnQuery to org.elasticsearch.index.mapper.vectors.DenseVectorFieldMapper.ElementType\nRationale: The method createKnnQuery() switches behavior based on the ElementType, which suggests that it operates closely with the elements' types and their specific vector data handling. The method uses ElementType-specific functions like createKnnByteQuery() and createKnnFloatQuery(), indicating that this logic is inherently tied to the ElementType. Additionally, the ElementType class already contains various methods focused on creating and parsing KNN vectors, which makes it a cohesive place to manage KNN-related query creation.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1452,
                        "lineEnd": 1462,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method createExactKnnQuery to class ElementType",
                        "description": "Move method createExactKnnQuery to org.elasticsearch.index.mapper.vectors.DenseVectorFieldMapper.ElementType\nRationale: The method createExactKnnQuery() directly depends on the ElementType and its BYTE and FLOAT cases to dispatch to specific query creation methods, making it a better fit within the ElementType class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1464,
                        "lineEnd": 1471,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method createExactKnnByteQuery to class ElementType",
                        "description": "Move method createExactKnnByteQuery to org.elasticsearch.index.mapper.vectors.DenseVectorFieldMapper.ElementType\nRationale: The method `createExactKnnByteQuery` is tightly coupled with the `ElementType` class. It uses the `checkVectorMagnitude` method from `ElementType` to ensure the magnitudes are valid, relies on the error formatting utilities of `ElementType`, and deals specifically with byte vectors. Moving it to `ElementType` would centralize vector-related operations and validations within a single class, promoting better cohesion and encapsulation.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1481,
                        "lineEnd": 1498,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method createExactKnnFloatQuery to class ElementType",
                        "description": "Move method createExactKnnFloatQuery to org.elasticsearch.index.mapper.vectors.DenseVectorFieldMapper.ElementType\nRationale: The method `createExactKnnFloatQuery` heavily depends on the `ElementType` class for checking vector bounds and magnitudes. Additionally, the method interacts closely with the `VectorUtil` and `ElementType` methods for normalizing vectors, making `ElementType` the most logical place to move the method, maintaining high cohesion within the class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1522,
                        "lineEnd": 1546,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method createKnnByteQuery to class VectorSimilarity",
                        "description": "Move method createKnnByteQuery to org.elasticsearch.index.mapper.vectors.DenseVectorFieldMapper.VectorSimilarity\nRationale: The createKnnByteQuery() method utilizes the VectorSimilarity class to check vector magnitude compatibility and applies similarities like DOT_PRODUCT or COSINE during the search query, making VectorSimilarity the most relevant target.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1548,
                        "lineEnd": 1581,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method createKnnFloatQuery to class VectorSimilarity",
                        "description": "Move method createKnnFloatQuery to org.elasticsearch.index.mapper.vectors.DenseVectorFieldMapper.VectorSimilarity\nRationale: The createKnnFloatQuery method relies significantly on vector similarity calculations, which is managed by VectorSimilarity. Therefore, moving this method to the VectorSimilarity class is logical, as the method deals with creating and handling vector similarities often using the VectorSimilarity enumeration.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1414,
                        "lineEnd": 1450,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method createKnnQuery to class ElementType",
                        "description": "Move method createKnnQuery to org.elasticsearch.index.mapper.vectors.DenseVectorFieldMapper.ElementType\nRationale: The 'createKnnQuery' method involves various checks and operations tied to 'ElementType', such as 'checkDimensions', 'elementType.checkVectorMagnitude', and validating the type of elements in the vectors. Moving the method to the 'ElementType' class would encapsulate these responsibilities within a more closely related context, ensuring the operations are directly associated with element-related validations and operations.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "createKnnQuery",
                            "method_signature": "public Query createKnnQuery(byte[] queryVector, int numCands, Query filter, Float similarityThreshold, BitSetProducer parentFilter)",
                            "target_class": "KnnQueryUtil",
                            "rationale": "The method contains complex logic related to creating KNN queries and heavily relies on vector and query parameters. Moving it to a utility class focused on query creation will improve the Single Responsibility Principle for DenseVectorFieldType."
                        },
                        {
                            "method_name": "createExactKnnQuery",
                            "method_signature": "public Query createExactKnnQuery(VectorData queryVector)",
                            "target_class": "KnnQueryUtil",
                            "rationale": "This method focuses on creating exact KNN queries and can be logically grouped with other similar query creation methods in a dedicated utility class, enhancing cohesion and maintainability."
                        },
                        {
                            "method_name": "createExactKnnByteQuery",
                            "method_signature": "private Query createExactKnnByteQuery(byte[] queryVector)",
                            "target_class": "KnnQueryUtil",
                            "rationale": "Similar to the createExactKnnQuery, this method should be grouped with other exact KNN query methods in a separate utility class for better cohesion and separation of concerns."
                        },
                        {
                            "method_name": "createExactKnnFloatQuery",
                            "method_signature": "private Query createExactKnnFloatQuery(float[] queryVector)",
                            "target_class": "KnnQueryUtil",
                            "rationale": "This method is focused on exact KNN query creation for float vectors and belongs to a utility class responsible for such operations."
                        },
                        {
                            "method_name": "createKnnQuery",
                            "method_signature": "public Query createKnnQuery(VectorData queryVector, int numCands, Query filter, Float similarityThreshold, BitSetProducer parentFilter)",
                            "target_class": "KnnQueryUtil",
                            "rationale": "This overloaded createKnnQuery method handles vector data and shares the same reasoning as other createKnnQuery methods to be moved to a utility class dedicated to query operations."
                        },
                        {
                            "method_name": "createKnnByteQuery",
                            "method_signature": "private Query createKnnByteQuery(byte[] queryVector, int numCands, Query filter, Float similarityThreshold, BitSetProducer parentFilter)",
                            "target_class": "KnnQueryUtil",
                            "rationale": "Handles byte-based KNN query creation, better suited within a query-focused utility class for better modularity and maintainability."
                        },
                        {
                            "method_name": "createKnnFloatQuery",
                            "method_signature": "private Query createKnnFloatQuery(float[] queryVector, int numCands, Query filter, Float similarityThreshold, BitSetProducer parentFilter)",
                            "target_class": "KnnQueryUtil",
                            "rationale": "Handles float-based KNN query creation, better suited within a query-focused utility class for better modularity and maintainability."
                        },
                        {
                            "method_name": "checkDimensions",
                            "method_signature": "private void checkDimensions(int length, Integer dims)",
                            "target_class": "KnnQueryUtil",
                            "rationale": "This method is a supportive utility that ensures the dimensions match requirements for KNN queries and complements other query creation methods. It should be moved to maintain logical grouping of related functionality."
                        }
                    ],
                    "llm_response_time": 8780
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "createKnnQuery",
                            "method_signature": "public Query createKnnQuery(byte[] queryVector, int numCands, Query filter, Float similarityThreshold, BitSetProducer parentFilter)",
                            "target_class": "KnnQuery",
                            "rationale": "The createKnnQuery method along with its various overloads are more related to the operation of creating KNN queries rather than the specifics of the vector field type. These methods should be in a class specifically responsible for KNN query creation, such as KnnQuery."
                        },
                        {
                            "method_name": "createExactKnnQuery",
                            "method_signature": "public Query createExactKnnQuery(VectorData queryVector)",
                            "target_class": "ExactKnnQuery",
                            "rationale": "The createExactKnnQuery method and its helpers focus on the specifics of forming exact KNN queries. Moving them to a dedicated ExactKnnQuery class would segregate responsibilities better and enhance readability and maintainability."
                        },
                        {
                            "method_name": "createExactKnnByteQuery",
                            "method_signature": "private Query createExactKnnByteQuery(byte[] queryVector)",
                            "target_class": "ExactKnnQuery",
                            "rationale": "This method is specialized for creating exact KNN byte queries. As it deals specifically with the concept of exact KNN query creation, it should be moved to the ExactKnnQuery class."
                        },
                        {
                            "method_name": "createExactKnnFloatQuery",
                            "method_signature": "private Query createExactKnnFloatQuery(float[] queryVector)",
                            "target_class": "ExactKnnQuery",
                            "rationale": "Similar to createExactKnnByteQuery, this method deals with creation of exact KNN float queries, and should be part of the ExactKnnQuery class to maintain coherence."
                        },
                        {
                            "method_name": "checkDimensions",
                            "method_signature": "private void checkDimensions(int length, Integer dims)",
                            "target_class": "VectorUtils",
                            "rationale": "The checkDimensions method is a utility function used to ensure the dimension of the vector is correct. Moving it to a utility class like VectorUtils will make it reusable across different classes that need dimension checks."
                        },
                        {
                            "method_name": "createKnnByteQuery",
                            "method_signature": "private Query createKnnByteQuery(byte[] queryVector, int numCands, Query filter, Float similarityThreshold, BitSetProducer parentFilter)",
                            "target_class": "KnnQuery",
                            "rationale": "This method is highly relevant to creating KNN byte queries and should be placed in the KnnQuery class where similar query-specific logic can be consolidated."
                        },
                        {
                            "method_name": "createKnnFloatQuery",
                            "method_signature": "private Query createKnnFloatQuery(float[] queryVector, int numCands, Query filter, Float similarityThreshold, BitSetProducer parentFilter)",
                            "target_class": "KnnQuery",
                            "rationale": "This method focuses on creating KNN float queries and should be part of the KnnQuery class to keep all query-related logic in one place."
                        }
                    ],
                    "llm_response_time": 7285
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "createKnnQuery",
                            "method_signature": "public Query createKnnQuery(byte[] queryVector, int numCands, Query filter, Float similarityThreshold, BitSetProducer parentFilter)",
                            "target_class": "KnnQueryManager",
                            "rationale": "The method is solely responsible for creating KNN (K-Nearest Neighbor) queries, which isn't directly related to the field type's main responsibility. Moving it to a dedicated class such as `KnnQueryManager` will enhance modularity and separation of concerns."
                        },
                        {
                            "method_name": "createExactKnnQuery",
                            "method_signature": "public Query createExactKnnQuery(VectorData queryVector)",
                            "target_class": "KnnQueryManager",
                            "rationale": "This method follows the same reasoning as `createKnnQuery` \u2013 it is concerned with KNN query logic rather than field type properties."
                        },
                        {
                            "method_name": "createExactKnnByteQuery",
                            "method_signature": "private Query createExactKnnByteQuery(byte[] queryVector)",
                            "target_class": "KnnQueryManager",
                            "rationale": "This method is also related to KNN query logic rather than the field type, making it more appropriate to place in a dedicated class managing KNN functionality."
                        },
                        {
                            "method_name": "createExactKnnFloatQuery",
                            "method_signature": "private Query createExactKnnFloatQuery(float[] queryVector)",
                            "target_class": "KnnQueryManager",
                            "rationale": "Similarly, this method deals with creating KNN queries specific to float vectors. It belongs in a specialized class such as `KnnQueryManager`."
                        },
                        {
                            "method_name": "createKnnQuery",
                            "method_signature": "public Query createKnnQuery(VectorData queryVector, int numCands, Query filter, Float similarityThreshold, BitSetProducer parentFilter)",
                            "target_class": "KnnQueryManager",
                            "rationale": "This overloaded method for KNN query creation should also be moved to ensure that all KNN related query mechanisms are centralized in the `KnnQueryManager` class."
                        },
                        {
                            "method_name": "createKnnByteQuery",
                            "method_signature": "private Query createKnnByteQuery(byte[] queryVector, int numCands, Query filter, Float similarityThreshold, BitSetProducer parentFilter)",
                            "target_class": "KnnQueryManager",
                            "rationale": "Specific to byte type KNN queries, it aligns more with the responsibilities of a K-NN query management class rather than a field type class."
                        },
                        {
                            "method_name": "createKnnFloatQuery",
                            "method_signature": "private Query createKnnFloatQuery(float[] queryVector, int numCands, Query filter, Float similarityThreshold, BitSetProducer parentFilter)",
                            "target_class": "KnnQueryManager",
                            "rationale": "It handles float type KNN queries and thus belongs in a specific manager class like `KnnQueryManager` rather than the main field type class."
                        }
                    ],
                    "llm_response_time": 7148
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "createKnnQuery",
                            "method_signature": "public createKnnQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createExactKnnQuery",
                            "method_signature": "public createExactKnnQuery(VectorData queryVector)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createExactKnnByteQuery",
                            "method_signature": "private createExactKnnByteQuery(byte[] queryVector)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createExactKnnFloatQuery",
                            "method_signature": "private createExactKnnFloatQuery(float[] queryVector)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createKnnQuery",
                            "method_signature": "public createKnnQuery(\n            VectorData queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createKnnByteQuery",
                            "method_signature": "private createKnnByteQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createKnnFloatQuery",
                            "method_signature": "private createKnnFloatQuery(\n            float[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "createKnnQuery",
                            "method_signature": "public createKnnQuery(\n            VectorData queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createExactKnnQuery",
                            "method_signature": "public createExactKnnQuery(VectorData queryVector)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createExactKnnByteQuery",
                            "method_signature": "private createExactKnnByteQuery(byte[] queryVector)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createExactKnnFloatQuery",
                            "method_signature": "private createExactKnnFloatQuery(float[] queryVector)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createKnnByteQuery",
                            "method_signature": "private createKnnByteQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createKnnFloatQuery",
                            "method_signature": "private createKnnFloatQuery(\n            float[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "createKnnQuery",
                            "method_signature": "public createKnnQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public createKnnQuery(\n            VectorData queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )": {
                        "first": {
                            "method_name": "createKnnQuery",
                            "method_signature": "public createKnnQuery(\n            VectorData queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5680562635517408
                    },
                    "public createExactKnnQuery(VectorData queryVector)": {
                        "first": {
                            "method_name": "createExactKnnQuery",
                            "method_signature": "public createExactKnnQuery(VectorData queryVector)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6132444185901494
                    },
                    "private createExactKnnByteQuery(byte[] queryVector)": {
                        "first": {
                            "method_name": "createExactKnnByteQuery",
                            "method_signature": "private createExactKnnByteQuery(byte[] queryVector)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6436745703137872
                    },
                    "private createExactKnnFloatQuery(float[] queryVector)": {
                        "first": {
                            "method_name": "createExactKnnFloatQuery",
                            "method_signature": "private createExactKnnFloatQuery(float[] queryVector)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6467259644626219
                    },
                    "private createKnnByteQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )": {
                        "first": {
                            "method_name": "createKnnByteQuery",
                            "method_signature": "private createKnnByteQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7283130376905671
                    },
                    "private createKnnFloatQuery(\n            float[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )": {
                        "first": {
                            "method_name": "createKnnFloatQuery",
                            "method_signature": "private createKnnFloatQuery(\n            float[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7481901658295564
                    },
                    "public createKnnQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )": {
                        "first": {
                            "method_name": "createKnnQuery",
                            "method_signature": "public createKnnQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7974645167404346
                    }
                },
                "voyage": {
                    "private createKnnByteQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )": {
                        "first": {
                            "method_name": "createKnnByteQuery",
                            "method_signature": "private createKnnByteQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.658453580829543
                    },
                    "private createExactKnnByteQuery(byte[] queryVector)": {
                        "first": {
                            "method_name": "createExactKnnByteQuery",
                            "method_signature": "private createExactKnnByteQuery(byte[] queryVector)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.665320628296746
                    },
                    "private createKnnFloatQuery(\n            float[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )": {
                        "first": {
                            "method_name": "createKnnFloatQuery",
                            "method_signature": "private createKnnFloatQuery(\n            float[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6680323950744128
                    },
                    "private createExactKnnFloatQuery(float[] queryVector)": {
                        "first": {
                            "method_name": "createExactKnnFloatQuery",
                            "method_signature": "private createExactKnnFloatQuery(float[] queryVector)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6781422878474475
                    },
                    "public createExactKnnQuery(VectorData queryVector)": {
                        "first": {
                            "method_name": "createExactKnnQuery",
                            "method_signature": "public createExactKnnQuery(VectorData queryVector)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7127721101793976
                    },
                    "public createKnnQuery(\n            VectorData queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )": {
                        "first": {
                            "method_name": "createKnnQuery",
                            "method_signature": "public createKnnQuery(\n            VectorData queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7222207244608735
                    },
                    "public createKnnQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )": {
                        "first": {
                            "method_name": "createKnnQuery",
                            "method_signature": "public createKnnQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7397735833452534
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public createKnnQuery(\n            VectorData queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                        "public createExactKnnQuery(VectorData queryVector)",
                        "public createKnnQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                        "private createKnnByteQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                        "private createKnnFloatQuery(\n            float[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                        "private createExactKnnByteQuery(byte[] queryVector)",
                        "private createExactKnnFloatQuery(float[] queryVector)"
                    ],
                    "llm_response_time": 2962
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public createKnnQuery(\n            VectorData queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                        "private createKnnByteQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                        "private createExactKnnFloatQuery(float[] queryVector)",
                        "public createExactKnnQuery(VectorData queryVector)",
                        "private createExactKnnByteQuery(byte[] queryVector)"
                    ],
                    "llm_response_time": 6956
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "private createExactKnnByteQuery(byte[] queryVector)",
                        "public createExactKnnQuery(VectorData queryVector)"
                    ],
                    "llm_response_time": 5102
                },
                "voyage": {
                    "priority_method_names": [
                        "public createExactKnnQuery(VectorData queryVector)",
                        "public createKnnQuery(\n            VectorData queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                        "public createKnnQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                        "private createKnnByteQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                        "private createExactKnnByteQuery(byte[] queryVector)",
                        "private createKnnFloatQuery(\n            float[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                        "private createExactKnnFloatQuery(float[] queryVector)"
                    ],
                    "llm_response_time": 7818
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public createExactKnnQuery(VectorData queryVector)",
                        "private createExactKnnByteQuery(byte[] queryVector)",
                        "private createExactKnnFloatQuery(float[] queryVector)"
                    ],
                    "llm_response_time": 6295
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private createKnnByteQuery(\n            byte[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                        "private createKnnFloatQuery(\n            float[] queryVector,\n            int numCands,\n            Query filter,\n            Float similarityThreshold,\n            BitSetProducer parentFilter\n        )",
                        "private createExactKnnByteQuery(byte[] queryVector)"
                    ],
                    "llm_response_time": 4215
                }
            },
            "targetClassMap": {
                "createKnnQuery": {
                    "target_classes": [
                        {
                            "class_name": "ElementType",
                            "similarity_score": 0.6473408015308224
                        },
                        {
                            "class_name": "VectorSimilarity",
                            "similarity_score": 0.3656678675081564
                        },
                        {
                            "class_name": "IndexOptions",
                            "similarity_score": 0.298822312129267
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ElementType",
                        "VectorSimilarity",
                        "IndexOptions"
                    ],
                    "llm_response_time": 3549,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "createExactKnnQuery": {
                    "target_classes": [
                        {
                            "class_name": "ElementType",
                            "similarity_score": 0.5322259657522435
                        },
                        {
                            "class_name": "VectorSimilarity",
                            "similarity_score": 0.5089818948737259
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ElementType",
                        "VectorSimilarity"
                    ],
                    "llm_response_time": 2571,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "createExactKnnByteQuery": {
                    "target_classes": [
                        {
                            "class_name": "ElementType",
                            "similarity_score": 0.5028901734104047
                        },
                        {
                            "class_name": "VectorSimilarity",
                            "similarity_score": 0.3593134953348084
                        },
                        {
                            "class_name": "IndexOptions",
                            "similarity_score": 0.35112344158839176
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ElementType",
                        "VectorSimilarity",
                        "IndexOptions"
                    ],
                    "llm_response_time": 3269,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "createExactKnnFloatQuery": {
                    "target_classes": [
                        {
                            "class_name": "ElementType",
                            "similarity_score": 0.6214890219914049
                        },
                        {
                            "class_name": "VectorSimilarity",
                            "similarity_score": 0.37724067811857853
                        },
                        {
                            "class_name": "IndexOptions",
                            "similarity_score": 0.4020789150704881
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ElementType",
                        "VectorSimilarity",
                        "IndexOptions"
                    ],
                    "llm_response_time": 3470,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "createKnnByteQuery": {
                    "target_classes": [
                        {
                            "class_name": "ElementType",
                            "similarity_score": 0.4989708716653789
                        },
                        {
                            "class_name": "VectorSimilarity",
                            "similarity_score": 0.3115187841910245
                        },
                        {
                            "class_name": "IndexOptions",
                            "similarity_score": 0.28632611028425864
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "VectorSimilarity",
                        "ElementType",
                        "IndexOptions"
                    ],
                    "llm_response_time": 2599,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "createKnnFloatQuery": {
                    "target_classes": [
                        {
                            "class_name": "ElementType",
                            "similarity_score": 0.611981770269212
                        },
                        {
                            "class_name": "VectorSimilarity",
                            "similarity_score": 0.35699442651309854
                        },
                        {
                            "class_name": "IndexOptions",
                            "similarity_score": 0.35884136228655594
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "VectorSimilarity",
                        "ElementType",
                        "IndexOptions"
                    ],
                    "llm_response_time": 3457,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/elastic/elasticsearch.git",
        "sha1": "5409aa7dcf1de1db3938dc30c942935c4b959149",
        "url": "https://github.com/elastic/elasticsearch/commit/5409aa7dcf1de1db3938dc30c942935c4b959149",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public inputExpressions() : List<Expression> extracted from private aggregatesToFactory(aggregates List<? extends NamedExpression>, mode AggregatorMode, layout Layout, grouping boolean, consumer Consumer<AggFunctionSupplierContext>) : void in class org.elasticsearch.xpack.esql.planner.AbstractPhysicalOperationProviders & moved to class org.elasticsearch.xpack.esql.expression.function.aggregate.AggregateFunction",
            "leftSideLocations": [
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/AbstractPhysicalOperationProviders.java",
                    "startLine": 233,
                    "endLine": 300,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "private aggregatesToFactory(aggregates List<? extends NamedExpression>, mode AggregatorMode, layout Layout, grouping boolean, consumer Consumer<AggFunctionSupplierContext>) : void"
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/AbstractPhysicalOperationProviders.java",
                    "startLine": 261,
                    "endLine": 261,
                    "startColumn": 50,
                    "endColumn": 55,
                    "codeElementType": "SIMPLE_NAME",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/AbstractPhysicalOperationProviders.java",
                    "startLine": 260,
                    "endLine": 260,
                    "startColumn": 29,
                    "endColumn": 83,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/aggregate/AggregateFunction.java",
                    "startLine": 84,
                    "endLine": 90,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public inputExpressions() : List<Expression>"
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/aggregate/AggregateFunction.java",
                    "startLine": 89,
                    "endLine": 89,
                    "startColumn": 24,
                    "endColumn": 29,
                    "codeElementType": "SIMPLE_NAME",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/expression/function/aggregate/AggregateFunction.java",
                    "startLine": 89,
                    "endLine": 89,
                    "startColumn": 9,
                    "endColumn": 31,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/AbstractPhysicalOperationProviders.java",
                    "startLine": 233,
                    "endLine": 291,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "private aggregatesToFactory(aggregates List<? extends NamedExpression>, mode AggregatorMode, layout Layout, grouping boolean, consumer Consumer<AggFunctionSupplierContext>) : void"
                },
                {
                    "filePath": "x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/AbstractPhysicalOperationProviders.java",
                    "startLine": 260,
                    "endLine": 260,
                    "startColumn": 42,
                    "endColumn": 78,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "aggregateFunction.inputExpressions()"
                }
            ],
            "isStatic": false
        },
        "ref_id": 368,
        "extraction_results": {
            "success": true,
            "newCommitHash": "e6f8548aa9f31bf4392e92f4deb37b363c12eca7",
            "newBranchName": "extract-inputExpressions-aggregatesToFactory-9b6cca1"
        },
        "telemetry": {
            "id": "f1be4ff1-35ad-4cf3-a076-bbef81bab194",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 291,
                "lineStart": 42,
                "lineEnd": 332,
                "bodyLineStart": 42,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/elasticsearch/x-pack/plugin/esql/src/main/java/org/elasticsearch/xpack/esql/planner/AbstractPhysicalOperationProviders.java",
                "sourceCode": "public abstract class AbstractPhysicalOperationProviders implements PhysicalOperationProviders {\n\n    private final AggregateMapper aggregateMapper = new AggregateMapper();\n\n    @Override\n    public final PhysicalOperation groupingPhysicalOperation(\n        AggregateExec aggregateExec,\n        PhysicalOperation source,\n        LocalExecutionPlannerContext context\n    ) {\n        Layout.Builder layout = new Layout.Builder();\n        Operator.OperatorFactory operatorFactory = null;\n        AggregateExec.Mode mode = aggregateExec.getMode();\n        var aggregates = aggregateExec.aggregates();\n\n        var sourceLayout = source.layout;\n        AggregatorMode aggregatorMode;\n\n        if (mode == AggregateExec.Mode.FINAL) {\n            aggregatorMode = AggregatorMode.FINAL;\n        } else if (mode == AggregateExec.Mode.PARTIAL) {\n            if (aggregateExec.child() instanceof ExchangeSourceExec) {// the reducer step at data node (local) level\n                aggregatorMode = AggregatorMode.INTERMEDIATE;\n            } else {\n                aggregatorMode = AggregatorMode.INITIAL;\n            }\n        } else {\n            assert false : \"Invalid aggregator mode [\" + mode + \"]\";\n            aggregatorMode = AggregatorMode.SINGLE;\n        }\n\n        if (aggregateExec.groupings().isEmpty()) {\n            // not grouping\n            List<Aggregator.Factory> aggregatorFactories = new ArrayList<>();\n\n            // append channels to the layout\n            if (mode == AggregateExec.Mode.FINAL) {\n                layout.append(aggregates);\n            } else {\n                layout.append(aggregateMapper.mapNonGrouping(aggregates));\n            }\n\n            // create the agg factories\n            aggregatesToFactory(\n                aggregates,\n                aggregatorMode,\n                sourceLayout,\n                false, // non-grouping\n                s -> aggregatorFactories.add(s.supplier.aggregatorFactory(s.mode))\n            );\n\n            if (aggregatorFactories.isEmpty() == false) {\n                operatorFactory = new AggregationOperator.AggregationOperatorFactory(aggregatorFactories, aggregatorMode);\n            }\n        } else {\n            // grouping\n            List<GroupingAggregator.Factory> aggregatorFactories = new ArrayList<>();\n            List<GroupSpec> groupSpecs = new ArrayList<>(aggregateExec.groupings().size());\n            for (Expression group : aggregateExec.groupings()) {\n                var groupAttribute = Expressions.attribute(group);\n                if (groupAttribute == null) {\n                    throw new EsqlIllegalArgumentException(\"Unexpected non-named expression[{}] as grouping in [{}]\", group, aggregateExec);\n                }\n                Layout.ChannelSet groupAttributeLayout = new Layout.ChannelSet(new HashSet<>(), groupAttribute.dataType());\n                groupAttributeLayout.nameIds().add(groupAttribute.id());\n\n                /*\n                 * Check for aliasing in aggregates which occurs in two cases (due to combining project + stats):\n                 *  - before stats (keep x = a | stats by x) which requires the partial input to use a's channel\n                 *  - after  stats (stats by a | keep x = a) which causes the output layout to refer to the follow-up alias\n                 */\n                for (NamedExpression agg : aggregates) {\n                    if (agg instanceof Alias a) {\n                        if (a.child() instanceof Attribute attr) {\n                            if (groupAttribute.id().equals(attr.id())) {\n                                groupAttributeLayout.nameIds().add(a.id());\n                                // TODO: investigate whether a break could be used since it shouldn't be possible to have multiple\n                                // attributes pointing to the same attribute\n                            }\n                            // partial mode only\n                            // check if there's any alias used in grouping - no need for the final reduction since the intermediate data\n                            // is in the output form\n                            // if the group points to an alias declared in the aggregate, use the alias child as source\n                            else if (mode == AggregateExec.Mode.PARTIAL) {\n                                if (groupAttribute.semanticEquals(a.toAttribute())) {\n                                    groupAttribute = attr;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                layout.append(groupAttributeLayout);\n                Layout.ChannelAndType groupInput = source.layout.get(groupAttribute.id());\n                groupSpecs.add(new GroupSpec(groupInput == null ? null : groupInput.channel(), groupAttribute));\n            }\n\n            if (mode == AggregateExec.Mode.FINAL) {\n                for (var agg : aggregates) {\n                    if (Alias.unwrap(agg) instanceof AggregateFunction) {\n                        layout.append(agg);\n                    }\n                }\n            } else {\n                layout.append(aggregateMapper.mapGrouping(aggregates));\n            }\n\n            // create the agg factories\n            aggregatesToFactory(\n                aggregates,\n                aggregatorMode,\n                sourceLayout,\n                true, // grouping\n                s -> aggregatorFactories.add(s.supplier.groupingAggregatorFactory(s.mode))\n            );\n\n            if (groupSpecs.size() == 1 && groupSpecs.get(0).channel == null) {\n                operatorFactory = ordinalGroupingOperatorFactory(\n                    source,\n                    aggregateExec,\n                    aggregatorFactories,\n                    groupSpecs.get(0).attribute,\n                    groupSpecs.get(0).elementType(),\n                    context\n                );\n            } else {\n                operatorFactory = new HashAggregationOperatorFactory(\n                    groupSpecs.stream().map(GroupSpec::toHashGroupSpec).toList(),\n                    aggregatorFactories,\n                    context.pageSize(aggregateExec.estimatedRowSize())\n                );\n            }\n        }\n        if (operatorFactory != null) {\n            return source.with(operatorFactory, layout.build());\n        }\n        throw new EsqlIllegalArgumentException(\"no operator factory\");\n    }\n\n    /***\n     * Creates a standard layout for intermediate aggregations, typically used across exchanges.\n     * Puts the group first, followed by each aggregation.\n     *\n     * It's similar to the code above (groupingPhysicalOperation) but ignores the factory creation.\n     */\n    public static List<Attribute> intermediateAttributes(List<? extends NamedExpression> aggregates, List<? extends Expression> groupings) {\n        var aggregateMapper = new AggregateMapper();\n\n        List<Attribute> attrs = new ArrayList<>();\n\n        // no groups\n        if (groupings.isEmpty()) {\n            attrs = Expressions.asAttributes(aggregateMapper.mapNonGrouping(aggregates));\n        }\n        // groups\n        else {\n            for (Expression group : groupings) {\n                var groupAttribute = Expressions.attribute(group);\n                if (groupAttribute == null) {\n                    throw new EsqlIllegalArgumentException(\"Unexpected non-named expression[{}] as grouping\", group);\n                }\n                Set<NameId> grpAttribIds = new HashSet<>();\n                grpAttribIds.add(groupAttribute.id());\n\n                /*\n                 * Check for aliasing in aggregates which occurs in two cases (due to combining project + stats):\n                 *  - before stats (keep x = a | stats by x) which requires the partial input to use a's channel\n                 *  - after  stats (stats by a | keep x = a) which causes the output layout to refer to the follow-up alias\n                 */\n                for (NamedExpression agg : aggregates) {\n                    if (agg instanceof Alias a) {\n                        if (a.child() instanceof Attribute attr) {\n                            if (groupAttribute.id().equals(attr.id())) {\n                                grpAttribIds.add(a.id());\n                                // TODO: investigate whether a break could be used since it shouldn't be possible to have multiple\n                                // attributes\n                                // pointing to the same attribute\n                            }\n                        }\n                    }\n                }\n                attrs.add(groupAttribute);\n            }\n\n            attrs.addAll(Expressions.asAttributes(aggregateMapper.mapGrouping(aggregates)));\n        }\n        return attrs;\n    }\n\n    private record AggFunctionSupplierContext(AggregatorFunctionSupplier supplier, AggregatorMode mode) {}\n\n    private void aggregatesToFactory(\n        List<? extends NamedExpression> aggregates,\n        AggregatorMode mode,\n        Layout layout,\n        boolean grouping,\n        Consumer<AggFunctionSupplierContext> consumer\n    ) {\n        for (NamedExpression ne : aggregates) {\n            if (ne instanceof Alias alias) {\n                var child = alias.child();\n                if (child instanceof AggregateFunction aggregateFunction) {\n                    List<? extends NamedExpression> sourceAttr;\n\n                    if (mode == AggregatorMode.INITIAL) {\n                        // TODO: this needs to be made more reliable - use casting to blow up when dealing with expressions (e+1)\n                        Expression field = aggregateFunction.field();\n                        // Only count can now support literals - all the other aggs should be optimized away\n                        if (field.foldable()) {\n                            if (aggregateFunction instanceof Count) {\n                                sourceAttr = emptyList();\n                            } else {\n                                throw new InvalidArgumentException(\n                                    \"Does not support yet aggregations over constants - [{}]\",\n                                    aggregateFunction.sourceText()\n                                );\n                            }\n                        } else {\n                            List<Expression> inputExpressions = inputExpressions(field, aggregateFunction);\n\n                            sourceAttr = inputExpressions.stream().map(e -> {\n                                Attribute attr = Expressions.attribute(e);\n                                if (attr == null) {\n                                    throw new EsqlIllegalArgumentException(\n                                        \"Cannot work with target field [{}] for agg [{}]\",\n                                        e.sourceText(),\n                                        aggregateFunction.sourceText()\n                                    );\n                                }\n                                return attr;\n                            }).toList();\n                        }\n                    } else if (mode == AggregatorMode.FINAL || mode == AggregatorMode.INTERMEDIATE) {\n                        if (grouping) {\n                            sourceAttr = aggregateMapper.mapGrouping(aggregateFunction);\n                        } else {\n                            sourceAttr = aggregateMapper.mapNonGrouping(aggregateFunction);\n                        }\n                    } else {\n                        throw new EsqlIllegalArgumentException(\"illegal aggregation mode\");\n                    }\n                    List<Integer> inputChannels = sourceAttr.stream().map(attr -> layout.get(attr.id()).channel()).toList();\n                    assert inputChannels.stream().allMatch(i -> i >= 0) : inputChannels;\n                    if (aggregateFunction instanceof ToAggregator agg) {\n                        consumer.accept(new AggFunctionSupplierContext(agg.supplier(inputChannels), mode));\n                    } else {\n                        throw new EsqlIllegalArgumentException(\"aggregate functions must extend ToAggregator\");\n                    }\n                }\n            }\n        }\n    }\n\n    private List<Expression> inputExpressions(Expression field, AggregateFunction aggregateFunction) {\n        List<Expression> inputExpressions = new ArrayList<>();\n        inputExpressions.add(field);\n        for (Expression param : aggregateFunction.parameters()) {\n            if (param.foldable() == false) {\n                inputExpressions.add(param);\n            } else {\n                Object ignored = param.fold();\n            }\n        }\n        return inputExpressions;\n    }\n\n    private record GroupSpec(Integer channel, Attribute attribute) {\n        BlockHash.GroupSpec toHashGroupSpec() {\n            if (channel == null) {\n                throw new EsqlIllegalArgumentException(\"planned to use ordinals but tried to use the hash instead\");\n            }\n            return new BlockHash.GroupSpec(channel, elementType());\n        }\n\n        ElementType elementType() {\n            return PlannerUtils.toElementType(attribute.dataType());\n        }\n    }\n\n    /**\n     * Build a grouping operator that operates on ordinals if possible.\n     */\n    public abstract Operator.OperatorFactory ordinalGroupingOperatorFactory(\n        PhysicalOperation source,\n        AggregateExec aggregateExec,\n        List<GroupingAggregator.Factory> aggregatorFactories,\n        Attribute attrSource,\n        ElementType groupType,\n        LocalExecutionPlannerContext context\n    );\n}",
                "methodCount": 7
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 4,
                "candidates": [
                    {
                        "lineStart": 315,
                        "lineEnd": 317,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method elementType to class Attribute",
                        "description": "Move method elementType to org.elasticsearch.xpack.esql.core.expression.Attribute\nRationale: The method `elementType()` relies directly on an attribute's data type. The `Attribute` class encapsulates the properties and behaviors of attributes, including their data types. Since `elementType()` is converting the data type of an attribute to an element type, it naturally fits within the `Attribute` class. This improves cohesion because the operations related to attribute data types are centralized in the `Attribute` class. Furthermore, placing `elementType()` in `Attribute` reduces dependencies and provides a clear context for this method's functionality, aligning with the Single Responsibility Principle.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 294,
                        "lineEnd": 305,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method inputExpressions to class AggregateFunction",
                        "description": "Move method inputExpressions to org.elasticsearch.xpack.esql.expression.function.aggregate.AggregateFunction\nRationale: The method inputExpressions relies directly on the field and parameters properties of AggregateFunction. It processes AggregateFunction instances, and its logic revolves around the characteristics of an AggregateFunction (such as foldable parameters). Therefore, it is most appropriate and contextually relevant to move this method to the AggregateFunction class. Additionally, embedding this method within AggregateFunction can improve cohesion by keeping the method closely associated with the data it operates on.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 180,
                        "lineEnd": 228,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method intermediateAttributes to class PlannerUtils",
                        "description": "move method intermediateAttributes to PsiClass:PlannerUtils\nRationale: The method 'intermediateAttributes' is tightly related to manipulation and transformation of attributes in logical and physical plans, similar to the utility methods found in 'PlannerUtils'. This method focuses on arranging attributes for intermediate aggregations\u2014a typical planning task\u2014making 'PlannerUtils' a suitable place. Additionally, it utilizes 'Expressions' for attribute operations, which aligns with other functionalities within 'PlannerUtils'.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 232,
                        "lineEnd": 292,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method aggregatesToFactory to class Layout",
                        "description": "Move method aggregatesToFactory to org.elasticsearch.xpack.esql.planner.Layout\nRationale: The method aggregatesToFactory heavily relies on the layout of attributes and channels, which is precisely managed by the Layout class. Specifically, it uses Layout to fetch channels for given attribute IDs and validates channel indices. Thus, relocating the method to Layout ensures better coherence and encapsulation of functionality related to attribute-channel mapping and aggregation processing within a single class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "intermediateAttributes",
                            "method_signature": "public static List<Attribute> intermediateAttributes(List<? extends NamedExpression> aggregates, List<? extends Expression> groupings)",
                            "target_class": "AggregateMapper",
                            "rationale": "The method `intermediateAttributes` uses `AggregateMapper` extensively and its purpose aligns closely with the responsibilities of `AggregateMapper`. Therefore, moving it to the `AggregateMapper` class improves cohesion and reusability within similar context."
                        }
                    ],
                    "llm_response_time": 2266
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "intermediateAttributes",
                            "method_signature": "public static List<Attribute> intermediateAttributes(List<? extends NamedExpression> aggregates, List<? extends Expression> groupings)",
                            "target_class": "AggregateMapper",
                            "rationale": "The method intermediateAttributes() heavily relies on the AggregateMapper and Expression's attributes. Moving this method to the AggregateMapper class would make the dependencies clearer and enhance cohesion."
                        },
                        {
                            "method_name": "aggregatesToFactory",
                            "method_signature": "private void aggregatesToFactory(List<? extends NamedExpression> aggregates, AggregatorMode mode, Layout layout, boolean grouping, Consumer<AggFunctionSupplierContext> consumer)",
                            "target_class": "AggregateMapper",
                            "rationale": "The method aggregatesToFactory() strongly interacts with aggregateMapper, AggregateFunction, and layout transformations. Moving this method to the AggregateMapper class would encapsulate the logic of aggregate transformations better and maintain single responsibility."
                        }
                    ],
                    "llm_response_time": 3198
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "intermediateAttributes",
                            "method_signature": "public static List<Attribute> intermediateAttributes(List<? extends NamedExpression> aggregates, List<? extends Expression> groupings)",
                            "target_class": "AggregateMapper",
                            "rationale": "The `intermediateAttributes` method uses an `AggregateMapper` instance internally to map aggregates and groupings. It makes more sense for this method to reside in the `AggregateMapper` class to keep related functionalities together, promoting cohesion."
                        }
                    ],
                    "llm_response_time": 2001
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "intermediateAttributes",
                            "method_signature": "public static intermediateAttributes(List<? extends NamedExpression> aggregates, List<? extends Expression> groupings)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "aggregatesToFactory",
                            "method_signature": "private aggregatesToFactory(\n        List<? extends NamedExpression> aggregates,\n        AggregatorMode mode,\n        Layout layout,\n        boolean grouping,\n        Consumer<AggFunctionSupplierContext> consumer\n    )",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "inputExpressions",
                            "method_signature": "private inputExpressions(Expression field, AggregateFunction aggregateFunction)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "elementType",
                            "method_signature": " elementType()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "elementType",
                            "method_signature": " elementType()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "inputExpressions",
                            "method_signature": "private inputExpressions(Expression field, AggregateFunction aggregateFunction)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "intermediateAttributes",
                            "method_signature": "public static intermediateAttributes(List<? extends NamedExpression> aggregates, List<? extends Expression> groupings)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "aggregatesToFactory",
                            "method_signature": "private aggregatesToFactory(\n        List<? extends NamedExpression> aggregates,\n        AggregatorMode mode,\n        Layout layout,\n        boolean grouping,\n        Consumer<AggFunctionSupplierContext> consumer\n    )",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    " elementType()": {
                        "first": {
                            "method_name": "elementType",
                            "method_signature": " elementType()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.42003742695847707
                    },
                    "private inputExpressions(Expression field, AggregateFunction aggregateFunction)": {
                        "first": {
                            "method_name": "inputExpressions",
                            "method_signature": "private inputExpressions(Expression field, AggregateFunction aggregateFunction)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6961094464331372
                    },
                    "public static intermediateAttributes(List<? extends NamedExpression> aggregates, List<? extends Expression> groupings)": {
                        "first": {
                            "method_name": "intermediateAttributes",
                            "method_signature": "public static intermediateAttributes(List<? extends NamedExpression> aggregates, List<? extends Expression> groupings)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7749438883019644
                    },
                    "private aggregatesToFactory(\n        List<? extends NamedExpression> aggregates,\n        AggregatorMode mode,\n        Layout layout,\n        boolean grouping,\n        Consumer<AggFunctionSupplierContext> consumer\n    )": {
                        "first": {
                            "method_name": "aggregatesToFactory",
                            "method_signature": "private aggregatesToFactory(\n        List<? extends NamedExpression> aggregates,\n        AggregatorMode mode,\n        Layout layout,\n        boolean grouping,\n        Consumer<AggFunctionSupplierContext> consumer\n    )",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.8090951688700178
                    }
                },
                "voyage": {
                    " elementType()": {
                        "first": {
                            "method_name": "elementType",
                            "method_signature": " elementType()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.31082077534843966
                    },
                    "private inputExpressions(Expression field, AggregateFunction aggregateFunction)": {
                        "first": {
                            "method_name": "inputExpressions",
                            "method_signature": "private inputExpressions(Expression field, AggregateFunction aggregateFunction)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.39184688051550537
                    },
                    "private aggregatesToFactory(\n        List<? extends NamedExpression> aggregates,\n        AggregatorMode mode,\n        Layout layout,\n        boolean grouping,\n        Consumer<AggFunctionSupplierContext> consumer\n    )": {
                        "first": {
                            "method_name": "aggregatesToFactory",
                            "method_signature": "private aggregatesToFactory(\n        List<? extends NamedExpression> aggregates,\n        AggregatorMode mode,\n        Layout layout,\n        boolean grouping,\n        Consumer<AggFunctionSupplierContext> consumer\n    )",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6189253640982084
                    },
                    "public static intermediateAttributes(List<? extends NamedExpression> aggregates, List<? extends Expression> groupings)": {
                        "first": {
                            "method_name": "intermediateAttributes",
                            "method_signature": "public static intermediateAttributes(List<? extends NamedExpression> aggregates, List<? extends Expression> groupings)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6645100405398978
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "public static intermediateAttributes(List<? extends NamedExpression> aggregates, List<? extends Expression> groupings)",
                        "private inputExpressions(Expression field, AggregateFunction aggregateFunction)"
                    ],
                    "llm_response_time": 5902
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "public static intermediateAttributes(List<? extends NamedExpression> aggregates, List<? extends Expression> groupings)",
                        "private inputExpressions(Expression field, AggregateFunction aggregateFunction)"
                    ],
                    "llm_response_time": 0
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public static intermediateAttributes(List<? extends NamedExpression> aggregates, List<? extends Expression> groupings)",
                        "private inputExpressions(Expression field, AggregateFunction aggregateFunction)"
                    ],
                    "llm_response_time": 2689
                },
                "voyage": {
                    "priority_method_names": [
                        "private aggregatesToFactory(\n        List<? extends NamedExpression> aggregates,\n        AggregatorMode mode,\n        Layout layout,\n        boolean grouping,\n        Consumer<AggFunctionSupplierContext> consumer\n    )",
                        "public static intermediateAttributes(List<? extends NamedExpression> aggregates, List<? extends Expression> groupings)",
                        "private inputExpressions(Expression field, AggregateFunction aggregateFunction)"
                    ],
                    "llm_response_time": 3647
                },
                "voyage-5": {
                    "priority_method_names": [
                        "private aggregatesToFactory(\n        List<? extends NamedExpression> aggregates,\n        AggregatorMode mode,\n        Layout layout,\n        boolean grouping,\n        Consumer<AggFunctionSupplierContext> consumer\n    )",
                        "public static intermediateAttributes(List<? extends NamedExpression> aggregates, List<? extends Expression> groupings)",
                        "private inputExpressions(Expression field, AggregateFunction aggregateFunction)"
                    ],
                    "llm_response_time": 1
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private aggregatesToFactory(\n        List<? extends NamedExpression> aggregates,\n        AggregatorMode mode,\n        Layout layout,\n        boolean grouping,\n        Consumer<AggFunctionSupplierContext> consumer\n    )",
                        "private inputExpressions(Expression field, AggregateFunction aggregateFunction)"
                    ],
                    "llm_response_time": 4290
                }
            },
            "targetClassMap": {
                "elementType": {
                    "target_classes": [
                        {
                            "class_name": "Attribute",
                            "similarity_score": 0.44816396437814604
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Attribute"
                    ],
                    "llm_response_time": 2232,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "inputExpressions": {
                    "target_classes": [
                        {
                            "class_name": "Expression",
                            "similarity_score": 0.4955715108870913
                        },
                        {
                            "class_name": "AggregateFunction",
                            "similarity_score": 0.5684189719080588
                        },
                        {
                            "class_name": "AggregateMapper",
                            "similarity_score": 0.672623887949948
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "AggregateFunction",
                        "Expression",
                        "AggregateMapper"
                    ],
                    "llm_response_time": 3430,
                    "similarity_computation_time": 6,
                    "similarity_metric": "cosine"
                },
                "intermediateAttributes": {
                    "target_classes": [
                        {
                            "class_name": "PlannerUtils",
                            "similarity_score": 0.6743414599523081
                        },
                        {
                            "class_name": "EsqlExpressionTranslators",
                            "similarity_score": 0.6813435823909465
                        },
                        {
                            "class_name": "BinaryComparisons",
                            "similarity_score": 0.6787942114027972
                        },
                        {
                            "class_name": "EqualsIgnoreCaseTranslator",
                            "similarity_score": 0.39410880717925656
                        },
                        {
                            "class_name": "SpatialRelatesTranslator",
                            "similarity_score": 0.4517963400471266
                        },
                        {
                            "class_name": "Scalars",
                            "similarity_score": 0.4877081863710152
                        },
                        {
                            "class_name": "Mapper",
                            "similarity_score": 0.6068084250360165
                        },
                        {
                            "class_name": "PhysicalOperation",
                            "similarity_score": 0.49325190356928994
                        },
                        {
                            "class_name": "LocalExecutionPlanner",
                            "similarity_score": 0.6490463962530041
                        },
                        {
                            "class_name": "ChannelAndType",
                            "similarity_score": 0.2439172509718563
                        },
                        {
                            "class_name": "ChannelSet",
                            "similarity_score": 0.1333770265910402
                        },
                        {
                            "class_name": "DefaultShardContext",
                            "similarity_score": 0.4877317199422808
                        },
                        {
                            "class_name": "LocalExecutionPlan",
                            "similarity_score": 0.5462076578969097
                        },
                        {
                            "class_name": "LocalExecutionPlannerContext",
                            "similarity_score": 0.5072810065017075
                        },
                        {
                            "class_name": "EsPhysicalOperationProviders",
                            "similarity_score": 0.5801482331996852
                        },
                        {
                            "class_name": "EsqlTranslatorHandler",
                            "similarity_score": 0.5122160711332738
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "PlannerUtils",
                        "EsqlExpressionTranslators",
                        "BinaryComparisons"
                    ],
                    "llm_response_time": 5620,
                    "similarity_computation_time": 12,
                    "similarity_metric": "cosine"
                },
                "aggregatesToFactory": {
                    "target_classes": [
                        {
                            "class_name": "Layout",
                            "similarity_score": 0.446361623232679
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Layout"
                    ],
                    "llm_response_time": 2121,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/elastic/elasticsearch.git",
        "sha1": "248b045d7029c548d6c5aa149b728c314582c88b",
        "url": "https://github.com/elastic/elasticsearch/commit/248b045d7029c548d6c5aa149b728c314582c88b",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public validateTrainedModelInput(input TrainedModelInput, forCreation boolean, validationException ActionRequestValidationException) : ActionRequestValidationException extracted from public validate(forCreation boolean) : Builder in class org.elasticsearch.xpack.core.ml.inference.TrainedModelConfig.Builder & moved to class org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfig",
            "leftSideLocations": [
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/TrainedModelConfig.java",
                    "startLine": 869,
                    "endLine": 1007,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "public validate(forCreation boolean) : Builder"
                },
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/TrainedModelConfig.java",
                    "startLine": 975,
                    "endLine": 978,
                    "startColumn": 17,
                    "endColumn": 19,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/TrainedModelConfig.java",
                    "startLine": 967,
                    "endLine": 967,
                    "startColumn": 17,
                    "endColumn": 120,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/TrainedModelConfig.java",
                    "startLine": 969,
                    "endLine": 979,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/TrainedModelConfig.java",
                    "startLine": 966,
                    "endLine": 968,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/TrainedModelConfig.java",
                    "startLine": 974,
                    "endLine": 979,
                    "startColumn": 49,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/TrainedModelConfig.java",
                    "startLine": 966,
                    "endLine": 968,
                    "startColumn": 67,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceConfig.java",
                    "startLine": 85,
                    "endLine": 108,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public validateTrainedModelInput(input TrainedModelInput, forCreation boolean, validationException ActionRequestValidationException) : ActionRequestValidationException"
                },
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceConfig.java",
                    "startLine": 101,
                    "endLine": 104,
                    "startColumn": 13,
                    "endColumn": 15,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceConfig.java",
                    "startLine": 92,
                    "endLine": 92,
                    "startColumn": 13,
                    "endColumn": 116,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceConfig.java",
                    "startLine": 95,
                    "endLine": 105,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceConfig.java",
                    "startLine": 91,
                    "endLine": 93,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceConfig.java",
                    "startLine": 100,
                    "endLine": 105,
                    "startColumn": 45,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceConfig.java",
                    "startLine": 91,
                    "endLine": 93,
                    "startColumn": 63,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/TrainedModelConfig.java",
                    "startLine": 869,
                    "endLine": 999,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "public validate(forCreation boolean) : Builder"
                },
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/TrainedModelConfig.java",
                    "startLine": 969,
                    "endLine": 969,
                    "startColumn": 39,
                    "endColumn": 121,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "inferenceConfig.validateTrainedModelInput(input,forCreation,validationException)"
                },
                {
                    "filePath": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/trainedmodel/InferenceConfig.java",
                    "startLine": 107,
                    "endLine": 107,
                    "startColumn": 9,
                    "endColumn": 36,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                }
            ],
            "isStatic": false
        },
        "ref_id": 373,
        "extraction_results": {
            "success": true,
            "newCommitHash": "78985c1236ba8d4425eee46135dc4e583bd95afb",
            "newBranchName": "extract-validateTrainedModelInput-validate-81b8495"
        },
        "telemetry": {
            "id": "7e33b173-6a96-4034-8365-639a23f3b559",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 476,
                "lineStart": 620,
                "lineEnd": 1095,
                "bodyLineStart": 620,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/elasticsearch/x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/inference/TrainedModelConfig.java",
                "sourceCode": "public static class Builder {\n\n        private String modelId;\n        private TrainedModelType modelType;\n        private String createdBy;\n        private MlConfigVersion version;\n        private String description;\n        private Instant createTime;\n        private List<String> tags = Collections.emptyList();\n        private Map<String, Object> metadata;\n        private TrainedModelInput input;\n        private Long modelSize;\n        private Long estimatedOperations;\n        private LazyModelDefinition definition;\n        private String licenseLevel;\n        private Map<String, String> defaultFieldMap;\n        private InferenceConfig inferenceConfig;\n        private TrainedModelLocation location;\n        private ModelPackageConfig modelPackageConfig;\n        private String platformArchitecture;\n        private TrainedModelPrefixStrings prefixStrings;\n\n        public Builder() {}\n\n        public Builder(TrainedModelConfig config) {\n            this.modelId = config.getModelId();\n            this.modelType = config.modelType;\n            this.createdBy = config.getCreatedBy();\n            this.version = config.getVersion();\n            this.createTime = config.getCreateTime();\n            this.definition = config.definition == null ? null : new LazyModelDefinition(config.definition);\n            this.description = config.getDescription();\n            this.tags = config.getTags();\n            this.metadata = config.getMetadata() == null ? null : new HashMap<>(config.getMetadata());\n            this.input = config.getInput();\n            this.estimatedOperations = config.estimatedOperations;\n            this.modelSize = config.modelSize;\n            this.licenseLevel = config.licenseLevel.description();\n            this.defaultFieldMap = config.defaultFieldMap == null ? null : new HashMap<>(config.defaultFieldMap);\n            this.inferenceConfig = config.inferenceConfig;\n            this.location = config.location;\n            this.modelPackageConfig = config.modelPackageConfig;\n            this.platformArchitecture = config.platformArchitecture;\n            this.prefixStrings = config.prefixStrings;\n        }\n\n        public Builder setModelId(String modelId) {\n            this.modelId = modelId;\n            return this;\n        }\n\n        public TrainedModelType getModelType() {\n            return modelType;\n        }\n\n        private Builder setModelType(String modelType) {\n            this.modelType = TrainedModelType.fromString(modelType);\n            return this;\n        }\n\n        public Builder setModelType(TrainedModelType modelType) {\n            this.modelType = modelType;\n            return this;\n        }\n\n        public String getModelId() {\n            return this.modelId;\n        }\n\n        public Builder setModelPackageConfig(ModelPackageConfig modelPackageConfig) {\n            this.modelPackageConfig = modelPackageConfig;\n            return this;\n        }\n\n        public Builder setCreatedBy(String createdBy) {\n            this.createdBy = createdBy;\n            return this;\n        }\n\n        public MlConfigVersion getVersion() {\n            return version;\n        }\n\n        public Builder setVersion(MlConfigVersion version) {\n            this.version = version;\n            return this;\n        }\n\n        private Builder setVersion(String version) {\n            return this.setVersion(MlConfigVersion.fromString(version));\n        }\n\n        public Builder setDescription(String description) {\n            this.description = description;\n            return this;\n        }\n\n        public Builder setCreateTime(Instant createTime) {\n            this.createTime = createTime;\n            return this;\n        }\n\n        public Builder setTags(List<String> tags) {\n            this.tags = ExceptionsHelper.requireNonNull(tags, TAGS);\n            return this;\n        }\n\n        public Builder setMetadata(Map<String, Object> metadata) {\n            this.metadata = metadata;\n            return this;\n        }\n\n        public Builder setFeatureImportance(List<TotalFeatureImportance> totalFeatureImportance) {\n            if (totalFeatureImportance == null) {\n                return this;\n            }\n            return addToMetadata(\n                TOTAL_FEATURE_IMPORTANCE,\n                totalFeatureImportance.stream().map(TotalFeatureImportance::asMap).collect(Collectors.toList())\n            );\n        }\n\n        public Builder setBaselineFeatureImportance(FeatureImportanceBaseline featureImportanceBaseline) {\n            if (featureImportanceBaseline == null) {\n                return this;\n            }\n            return addToMetadata(FEATURE_IMPORTANCE_BASELINE, featureImportanceBaseline.asMap());\n        }\n\n        public Builder setHyperparameters(List<Hyperparameters> hyperparameters) {\n            if (hyperparameters == null) {\n                return this;\n            }\n            return addToMetadata(HYPERPARAMETERS, hyperparameters.stream().map(Hyperparameters::asMap).collect(Collectors.toList()));\n        }\n\n        public Builder setPlatformArchitecture(String platformArchitecture) {\n            this.platformArchitecture = platformArchitecture;\n            return this;\n        }\n\n        public Builder setPrefixStrings(TrainedModelPrefixStrings prefixStrings) {\n            this.prefixStrings = prefixStrings;\n            return this;\n        }\n\n        public Builder setModelAliases(Set<String> modelAliases) {\n            if (modelAliases == null || modelAliases.isEmpty()) {\n                return this;\n            }\n            return addToMetadata(MODEL_ALIASES, modelAliases.stream().sorted().collect(Collectors.toList()));\n        }\n\n        private Builder addToMetadata(String fieldName, Object value) {\n            if (this.metadata == null) {\n                this.metadata = new HashMap<>();\n            }\n            this.metadata.put(fieldName, value);\n            return this;\n        }\n\n        public Builder setParsedDefinition(TrainedModelDefinition.Builder definitionRef) {\n            if (definitionRef == null) {\n                return this;\n            }\n            this.definition = LazyModelDefinition.fromParsedDefinition(definitionRef.build());\n            return this;\n        }\n\n        public Builder setDefinitionFromBytes(BytesReference definitionRef) {\n            if (definitionRef == null) {\n                return this;\n            }\n            this.definition = LazyModelDefinition.fromCompressedData(definitionRef);\n            return this;\n        }\n\n        public Builder clearDefinition() {\n            this.definition = null;\n            return this;\n        }\n\n        private Builder setLazyDefinition(TrainedModelDefinition.Builder parsedTrainedModel) {\n            if (parsedTrainedModel == null) {\n                return this;\n            }\n\n            if (this.definition != null) {\n                throw new IllegalArgumentException(\n                    format(\"both [%s] and [%s] cannot be set.\", COMPRESSED_DEFINITION.getPreferredName(), DEFINITION.getPreferredName())\n                );\n            }\n            this.definition = LazyModelDefinition.fromParsedDefinition(parsedTrainedModel.build());\n            return this;\n        }\n\n        private Builder setLazyDefinition(String compressedString) {\n            if (compressedString == null) {\n                return this;\n            }\n\n            if (this.definition != null) {\n                throw new IllegalArgumentException(\n                    format(\"both [%s] and [%s] cannot be set.\", COMPRESSED_DEFINITION.getPreferredName(), DEFINITION.getPreferredName())\n                );\n            }\n            this.definition = LazyModelDefinition.fromBase64String(compressedString);\n            return this;\n        }\n\n        public Builder setLocation(TrainedModelLocation location) {\n            this.location = location;\n            return this;\n        }\n\n        public Builder setInput(TrainedModelInput input) {\n            this.input = input;\n            return this;\n        }\n\n        public Builder setModelSize(long modelSize) {\n            this.modelSize = modelSize;\n            return this;\n        }\n\n        public Builder setEstimatedOperations(long estimatedOperations) {\n            this.estimatedOperations = estimatedOperations;\n            return this;\n        }\n\n        public Builder setLicenseLevel(String licenseLevel) {\n            this.licenseLevel = licenseLevel;\n            return this;\n        }\n\n        public Builder setDefaultFieldMap(Map<String, String> defaultFieldMap) {\n            this.defaultFieldMap = defaultFieldMap;\n            return this;\n        }\n\n        public Builder setInferenceConfig(InferenceConfig inferenceConfig) {\n            this.inferenceConfig = inferenceConfig;\n            return this;\n        }\n\n        public Builder validate() {\n            return validate(false);\n        }\n\n        /**\n         * Runs validations against the builder.\n         * @param forCreation indicates if we should validate for model creation or for a model read from storage\n         * @return The current builder object if validations are successful\n         * @throws ActionRequestValidationException when there are validation failures.\n         */\n        public Builder validate(boolean forCreation) {\n            // We require a definition to be available here even though it will be stored in a different doc\n            ActionRequestValidationException validationException = null;\n            boolean packagedModel = modelId != null && modelId.startsWith(\".\");\n\n            if (modelId == null) {\n                validationException = addValidationError(\"[\" + MODEL_ID.getPreferredName() + \"] must not be null.\", validationException);\n            }\n\n            if (packagedModel == false) {\n                if (definition != null && location != null) {\n                    validationException = addValidationError(\n                        \"[\"\n                            + DEFINITION.getPreferredName()\n                            + \"] \"\n                            + \"and [\"\n                            + LOCATION.getPreferredName()\n                            + \"] are both defined but only one can be used.\",\n                        validationException\n                    );\n                }\n                if (definition == null && modelType == null) {\n                    validationException = addValidationError(\n                        \"[\"\n                            + MODEL_TYPE.getPreferredName()\n                            + \"] must be set if \"\n                            + \"[\"\n                            + DEFINITION.getPreferredName()\n                            + \"] is not defined.\",\n                        validationException\n                    );\n                }\n\n                if (inferenceConfig == null && forCreation) {\n                    validationException = addValidationError(\n                        \"[\" + INFERENCE_CONFIG.getPreferredName() + \"] must not be null.\",\n                        validationException\n                    );\n                }\n            }\n\n            if (modelId != null) {\n                if (packagedModel) {\n                    String idToValidate = modelId.substring(1);\n                    if (idToValidate.endsWith(\"_SNAPSHOT\")) {\n                        idToValidate = idToValidate.substring(0, idToValidate.length() - 9);\n                    }\n\n                    if (MlStrings.isValidId(idToValidate) == false) {\n                        validationException = addValidationError(\n                            Messages.getMessage(Messages.INVALID_MODEL_PACKAGE_ID, TrainedModelConfig.MODEL_ID.getPreferredName(), modelId),\n                            validationException\n                        );\n                    }\n                } else {\n                    if (MlStrings.isValidId(modelId) == false) {\n                        validationException = addValidationError(\n                            Messages.getMessage(Messages.INVALID_ID, TrainedModelConfig.MODEL_ID.getPreferredName(), modelId),\n                            validationException\n                        );\n                    }\n                }\n            }\n\n            if (modelId != null && MlStrings.hasValidLengthForId(modelId) == false) {\n                validationException = addValidationError(\n                    Messages.getMessage(\n                        Messages.ID_TOO_LONG,\n                        TrainedModelConfig.MODEL_ID.getPreferredName(),\n                        modelId,\n                        MlStrings.ID_LENGTH_LIMIT\n                    ),\n                    validationException\n                );\n            }\n            List<String> badTags = tags.stream()\n                .filter(tag -> (MlStrings.isValidId(tag) && MlStrings.hasValidLengthForId(tag)) == false)\n                .collect(Collectors.toList());\n            if (badTags.isEmpty() == false) {\n                validationException = addValidationError(\n                    Messages.getMessage(Messages.INFERENCE_INVALID_TAGS, badTags, MlStrings.ID_LENGTH_LIMIT),\n                    validationException\n                );\n            }\n\n            for (String tag : tags) {\n                if (tag.equals(modelId)) {\n                    validationException = addValidationError(\"none of the tags must equal the model_id\", validationException);\n                    break;\n                }\n            }\n            if (input != null && input.getFieldNames().isEmpty()) {\n                validationException = addValidationError(\"[input.field_names] must not be empty\", validationException);\n            }\n            validationException = validateTrainedModelInput(validationException, input);\n            if (forCreation) {\n                validationException = checkIllegalSetting(version, VERSION.getPreferredName(), validationException);\n                validationException = checkIllegalSetting(createdBy, CREATED_BY.getPreferredName(), validationException);\n                validationException = checkIllegalSetting(createTime, CREATE_TIME.getPreferredName(), validationException);\n                validationException = checkIllegalSetting(licenseLevel, LICENSE_LEVEL.getPreferredName(), validationException);\n                validationException = checkIllegalSetting(location, LOCATION.getPreferredName(), validationException);\n                if (metadata != null) {\n                    validationException = checkIllegalSetting(\n                        metadata.get(TOTAL_FEATURE_IMPORTANCE),\n                        METADATA.getPreferredName() + \".\" + TOTAL_FEATURE_IMPORTANCE,\n                        validationException\n                    );\n                    validationException = checkIllegalSetting(\n                        metadata.get(MODEL_ALIASES),\n                        METADATA.getPreferredName() + \".\" + MODEL_ALIASES,\n                        validationException\n                    );\n                }\n\n                // packaged model validation\n                validationException = checkIllegalSetting(modelPackageConfig, MODEL_PACKAGE.getPreferredName(), validationException);\n            }\n            if (validationException != null) {\n                throw validationException;\n            }\n\n            return this;\n        }\n\n        private ActionRequestValidationException validateTrainedModelInput(ActionRequestValidationException validationException, TrainedModelInput input) {\n            if (input != null\n                && input.getFieldNames()\n                    .stream()\n                    .filter(s -> s.contains(\".\"))\n                    .flatMap(s -> Arrays.stream(Strings.delimitedListToStringArray(s, \".\")))\n                    .anyMatch(String::isEmpty)) {\n                validationException = addValidationError(\n                    \"[input.field_names] must only contain valid dot delimited field names\",\n                    validationException\n                );\n            }\n            return validationException;\n        }\n\n        /**\n         * Validate that fields defined by the package aren't defined in the request.\n         *\n         * To be called by the transport after checking that the package exists.\n         */\n        public Builder validateNoPackageOverrides() {\n            ActionRequestValidationException validationException = null;\n            validationException = checkIllegalPackagedModelSetting(description, DESCRIPTION.getPreferredName(), validationException);\n            validationException = checkIllegalPackagedModelSetting(definition, DEFINITION.getPreferredName(), validationException);\n            validationException = checkIllegalPackagedModelSetting(modelType, MODEL_TYPE.getPreferredName(), validationException);\n            validationException = checkIllegalPackagedModelSetting(metadata, METADATA.getPreferredName(), validationException);\n            if (modelSize != null && modelSize > 0) {\n                validationException = checkIllegalPackagedModelSetting(modelSize, MODEL_SIZE_BYTES.getPreferredName(), validationException);\n            }\n            validationException = checkIllegalPackagedModelSetting(\n                inferenceConfig,\n                INFERENCE_CONFIG.getPreferredName(),\n                validationException\n            );\n            if (tags != null && tags.isEmpty() == false) {\n                validationException = addValidationError(\n                    \"illegal to set [tags] at inference model creation for packaged model\",\n                    validationException\n                );\n            }\n\n            if (validationException != null) {\n                throw validationException;\n            }\n\n            return this;\n        }\n\n        private static ActionRequestValidationException checkIllegalSetting(\n            Object value,\n            String setting,\n            ActionRequestValidationException validationException\n        ) {\n            if (value != null) {\n                return addValidationError(\"illegal to set [\" + setting + \"] at inference model creation\", validationException);\n            }\n            return validationException;\n        }\n\n        private static ActionRequestValidationException checkIllegalPackagedModelSetting(\n            Object value,\n            String setting,\n            ActionRequestValidationException validationException\n        ) {\n            if (value != null) {\n                return addValidationError(\n                    \"illegal to set [\" + setting + \"] at inference model creation for packaged model\",\n                    validationException\n                );\n            }\n            return validationException;\n        }\n\n        public TrainedModelConfig build() {\n            return new TrainedModelConfig(\n                modelId,\n                modelType,\n                createdBy == null ? \"user\" : createdBy,\n                version == null ? MlConfigVersion.CURRENT : version,\n                description,\n                createTime == null ? Instant.now() : createTime,\n                definition,\n                tags,\n                metadata,\n                input,\n                modelSize == null ? 0 : modelSize,\n                estimatedOperations == null ? 0 : estimatedOperations,\n                licenseLevel == null ? License.OperationMode.PLATINUM.description() : licenseLevel,\n                defaultFieldMap,\n                inferenceConfig,\n                location,\n                modelPackageConfig,\n                platformArchitecture,\n                prefixStrings\n            );\n        }\n    }",
                "methodCount": 42
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 4,
                "candidates": [
                    {
                        "lineStart": 1071,
                        "lineEnd": 1093,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method build to class TrainedModelLocation",
                        "description": "Move method build to org.elasticsearch.xpack.core.ml.inference.trainedmodel.TrainedModelLocation\nRationale: The build() method is responsible for constructing a TrainedModelConfig object with various parameters such as modelId, modelType, and location, which directly relates to TrainedModelLocation. TrainedModelLocation is more suitable because it signifies where the model resides, and building a TrainedModelConfig can logically be associated with defining its location details. InferenceConfig, on the other hand, deals primarily with settings and the context for inference, which doesn't align directly with the construction of a TrainedModelConfig object.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 998,
                        "lineEnd": 1011,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method validateTrainedModelInput to class TrainedModelType",
                        "description": "Move method validateTrainedModelInput to org.elasticsearch.xpack.core.ml.inference.TrainedModelType\nRationale: The `validateTrainedModelInput` method deals specifically with a `TrainedModelInput` object and its validation. Given that `TrainedModelType` already references `TrainedModelInput` in its default input, it makes the most sense to move the method here. This ensures that validation logic for `TrainedModelInput` is centralized within the class that defines and manages different types of trained models.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 868,
                        "lineEnd": 996,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method validate to class InferenceConfig",
                        "description": "Move method validate to org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfig\nRationale: The validate() method involves a variety of validation checks for model settings, inference configuration, and tags that are more aligned with the responsibilities of the InferenceConfig interface. Since InferenceConfig deals with configuration updates and support checks related to machine learning inference, it is the most appropriate class for this validate() method. Additionally, the validate() method has checks related to INFERENCE_CONFIG, making it a natural fit for this class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1013,
                        "lineEnd": 1044,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method validateNoPackageOverrides to class InferenceConfig",
                        "description": "Move method validateNoPackageOverrides to org.elasticsearch.xpack.core.ml.inference.trainedmodel.InferenceConfig\nRationale: The method `validateNoPackageOverrides()` involves validation related to the inference configuration and checks illegal model settings, which are part of the InferenceConfig's responsibility. Since InferenceConfig already deals with fields like `results_field`, it makes sense to centralize all logic around model configuration validation within this class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "validateTrainedModelInput",
                            "method_signature": "private ActionRequestValidationException validateTrainedModelInput(ActionRequestValidationException validationException, TrainedModelInput input)",
                            "target_class": "TrainedModelConfig",
                            "rationale": "The method validateTrainedModelInput specifically focuses on validating properties of a TrainedModelInput, which suggests it is more appropriate to be moved to the TrainedModelConfig class. This can increase cohesion by grouping related validation logic together."
                        },
                        {
                            "method_name": "checkIllegalSetting",
                            "method_signature": "private static ActionRequestValidationException checkIllegalSetting(Object value, String setting, ActionRequestValidationException validationException)",
                            "target_class": "TrainedModelConfig",
                            "rationale": "The checkIllegalSetting method is a generic validation function that checks for illegal settings. This validation seems more broadly useful and applicable to any configuration, so moving it to TrainedModelConfig would centralize this utility method and make it reusable for other configuration-related validation tasks."
                        },
                        {
                            "method_name": "checkIllegalPackagedModelSetting",
                            "method_signature": "private static ActionRequestValidationException checkIllegalPackagedModelSetting(Object value, String setting, ActionRequestValidationException validationException)",
                            "target_class": "TrainedModelConfig",
                            "rationale": "Similar to checkIllegalSetting, checkIllegalPackagedModelSetting focuses on validation logic that is central to TrainedModelConfig. Moving it to TrainedModelConfig would make this validation method universally available and increase the design's cohesion."
                        }
                    ],
                    "llm_response_time": 4410
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "validateTrainedModelInput",
                            "method_signature": "private ActionRequestValidationException validateTrainedModelInput(ActionRequestValidationException validationException, TrainedModelInput input)",
                            "target_class": "TrainedModelInput",
                            "rationale": "The method validateTrainedModelInput() is tightly coupled with the TrainedModelInput class and is responsible for validating its state. Therefore, it would be more appropriate to move it to the TrainedModelInput class."
                        },
                        {
                            "method_name": "checkIllegalSetting",
                            "method_signature": "private static ActionRequestValidationException checkIllegalSetting(Object value, String setting, ActionRequestValidationException validationException)",
                            "target_class": "TrainedModelConfig",
                            "rationale": "The method checkIllegalSetting() is a utility for validating settings in the TrainedModelConfig. It would be more appropriate for this method to reside in the TrainedModelConfig class as it's more specific to that context."
                        },
                        {
                            "method_name": "checkIllegalPackagedModelSetting",
                            "method_signature": "private static ActionRequestValidationException checkIllegalPackagedModelSetting(Object value, String setting, ActionRequestValidationException validationException)",
                            "target_class": "TrainedModelConfig",
                            "rationale": "Similar to checkIllegalSetting(), this method is responsible for validating package model settings and would be best placed in the TrainedModelConfig class for better cohesion."
                        }
                    ],
                    "llm_response_time": 4951
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "setFeatureImportance",
                            "method_signature": "public Builder setFeatureImportance(List<TotalFeatureImportance> totalFeatureImportance)",
                            "target_class": "TotalFeatureImportance",
                            "rationale": "The method setFeatureImportance deals specifically with feature importance, which is directly related to the TotalFeatureImportance class. It makes sense to have this method in the TotalFeatureImportance class to follow the principle of single responsibility."
                        },
                        {
                            "method_name": "setBaselineFeatureImportance",
                            "method_signature": "public Builder setBaselineFeatureImportance(FeatureImportanceBaseline featureImportanceBaseline)",
                            "target_class": "FeatureImportanceBaseline",
                            "rationale": "The method setBaselineFeatureImportance pertains to baseline feature importance, which logically falls under the domain of the FeatureImportanceBaseline class. Moving it there would make the code more cohesive and focused."
                        },
                        {
                            "method_name": "setHyperparameters",
                            "method_signature": "public Builder setHyperparameters(List<Hyperparameters> hyperparameters)",
                            "target_class": "Hyperparameters",
                            "rationale": "The method setHyperparameters is concerned with setting hyperparameters, a responsibility that should reside within the Hyperparameters class. Moving it aligns the method with the correct context and enhances code organization."
                        }
                    ],
                    "llm_response_time": 3859
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "validate",
                            "method_signature": "public validate(boolean forCreation)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "validateTrainedModelInput",
                            "method_signature": "private validateTrainedModelInput(ActionRequestValidationException validationException, TrainedModelInput input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "validateNoPackageOverrides",
                            "method_signature": "public validateNoPackageOverrides()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "build",
                            "method_signature": "public build()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "build",
                            "method_signature": "public build()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "validateTrainedModelInput",
                            "method_signature": "private validateTrainedModelInput(ActionRequestValidationException validationException, TrainedModelInput input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "validate",
                            "method_signature": "public validate(boolean forCreation)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "validateNoPackageOverrides",
                            "method_signature": "public validateNoPackageOverrides()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public build()": {
                        "first": {
                            "method_name": "build",
                            "method_signature": "public build()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.22002693237806734
                    },
                    "private validateTrainedModelInput(ActionRequestValidationException validationException, TrainedModelInput input)": {
                        "first": {
                            "method_name": "validateTrainedModelInput",
                            "method_signature": "private validateTrainedModelInput(ActionRequestValidationException validationException, TrainedModelInput input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.533286975685079
                    },
                    "public validate(boolean forCreation)": {
                        "first": {
                            "method_name": "validate",
                            "method_signature": "public validate(boolean forCreation)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6350346832800157
                    },
                    "public validateNoPackageOverrides()": {
                        "first": {
                            "method_name": "validateNoPackageOverrides",
                            "method_signature": "public validateNoPackageOverrides()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6495227594935793
                    }
                },
                "voyage": {
                    "private validateTrainedModelInput(ActionRequestValidationException validationException, TrainedModelInput input)": {
                        "first": {
                            "method_name": "validateTrainedModelInput",
                            "method_signature": "private validateTrainedModelInput(ActionRequestValidationException validationException, TrainedModelInput input)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4652491629734094
                    },
                    "public build()": {
                        "first": {
                            "method_name": "build",
                            "method_signature": "public build()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5937261684051269
                    },
                    "public validateNoPackageOverrides()": {
                        "first": {
                            "method_name": "validateNoPackageOverrides",
                            "method_signature": "public validateNoPackageOverrides()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.6786591981431725
                    },
                    "public validate(boolean forCreation)": {
                        "first": {
                            "method_name": "validate",
                            "method_signature": "public validate(boolean forCreation)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.7060630937728305
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private validateTrainedModelInput(ActionRequestValidationException validationException, TrainedModelInput input)",
                        "public validate(boolean forCreation)",
                        "public validateNoPackageOverrides()",
                        "public build()"
                    ],
                    "llm_response_time": 3584
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "private validateTrainedModelInput(ActionRequestValidationException validationException, TrainedModelInput input)",
                        "public validate(boolean forCreation)",
                        "public validateNoPackageOverrides()",
                        "public build()"
                    ],
                    "llm_response_time": 0
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public build()",
                        "public validate(boolean forCreation)",
                        "private validateTrainedModelInput(ActionRequestValidationException validationException, TrainedModelInput input)"
                    ],
                    "llm_response_time": 3382
                },
                "voyage": {
                    "priority_method_names": [
                        "public validate(boolean forCreation)",
                        "public validateNoPackageOverrides()",
                        "private validateTrainedModelInput(ActionRequestValidationException validationException, TrainedModelInput input)",
                        "public build()"
                    ],
                    "llm_response_time": 3704
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public validate(boolean forCreation)",
                        "public validateNoPackageOverrides()",
                        "private validateTrainedModelInput(ActionRequestValidationException validationException, TrainedModelInput input)",
                        "public build()"
                    ],
                    "llm_response_time": 0
                },
                "voyage-3": {
                    "priority_method_names": [
                        "private validateTrainedModelInput(ActionRequestValidationException validationException, TrainedModelInput input)",
                        "public validateNoPackageOverrides()",
                        "public build()"
                    ],
                    "llm_response_time": 4675
                }
            },
            "targetClassMap": {
                "build": {
                    "target_classes": [
                        {
                            "class_name": "InferenceConfig",
                            "similarity_score": 0.08464418256021293
                        },
                        {
                            "class_name": "TrainedModelLocation",
                            "similarity_score": 0.06956083436402524
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "TrainedModelLocation",
                        "InferenceConfig"
                    ],
                    "llm_response_time": 2617,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                },
                "validateTrainedModelInput": {
                    "target_classes": [
                        {
                            "class_name": "ActionRequestValidationException",
                            "similarity_score": 0.17496355305594133
                        },
                        {
                            "class_name": "TrainedModelInput",
                            "similarity_score": 0.35076252741314345
                        },
                        {
                            "class_name": "TrainedModelType",
                            "similarity_score": 0.39891798646014265
                        },
                        {
                            "class_name": "MlConfigVersion",
                            "similarity_score": 0.19748725632633554
                        },
                        {
                            "class_name": "TrainedModelInput",
                            "similarity_score": 0.35076252741314345
                        },
                        {
                            "class_name": "LazyModelDefinition",
                            "similarity_score": 0.47055191440298616
                        },
                        {
                            "class_name": "InferenceConfig",
                            "similarity_score": 0.26386119802263436
                        },
                        {
                            "class_name": "TrainedModelLocation",
                            "similarity_score": 0.18070158058105024
                        },
                        {
                            "class_name": "ModelPackageConfig",
                            "similarity_score": 0.4250083010244448
                        },
                        {
                            "class_name": "TrainedModelPrefixStrings",
                            "similarity_score": 0.3329178274769567
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "TrainedModelType",
                        "ModelPackageConfig",
                        "LazyModelDefinition"
                    ],
                    "llm_response_time": 4366,
                    "similarity_computation_time": 46,
                    "similarity_metric": "cosine"
                },
                "validate": {
                    "target_classes": [
                        {
                            "class_name": "InferenceConfig",
                            "similarity_score": 0.3459963015792612
                        },
                        {
                            "class_name": "TrainedModelLocation",
                            "similarity_score": 0.21264800627003985
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "InferenceConfig",
                        "TrainedModelLocation"
                    ],
                    "llm_response_time": 2897,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "validateNoPackageOverrides": {
                    "target_classes": [
                        {
                            "class_name": "InferenceConfig",
                            "similarity_score": 0.3568701711464272
                        },
                        {
                            "class_name": "TrainedModelLocation",
                            "similarity_score": 0.15169496905422944
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "InferenceConfig",
                        "TrainedModelLocation"
                    ],
                    "llm_response_time": 2176,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "repository": "https://github.com/elastic/elasticsearch.git",
        "sha1": "20071da49365b13a9b5bf7713da05cd71b6853dd",
        "url": "https://github.com/elastic/elasticsearch/commit/20071da49365b13a9b5bf7713da05cd71b6853dd",
        "move_method_refactoring": {
            "type": "Extract And Move Method",
            "description": "Extract And Move Method public validate(validationException ActionRequestValidationException, isScroll boolean) : ActionRequestValidationException extracted from public validate() : ActionRequestValidationException in class org.elasticsearch.action.search.SearchRequest & moved to class org.elasticsearch.search.builder.SearchSourceBuilder",
            "leftSideLocations": [
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 323,
                    "endLine": 488,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration before extraction",
                    "codeElement": "public validate() : ActionRequestValidationException"
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 330,
                    "endLine": 333,
                    "startColumn": 21,
                    "endColumn": 23,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 336,
                    "endLine": 336,
                    "startColumn": 21,
                    "endColumn": 134,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 339,
                    "endLine": 339,
                    "startColumn": 21,
                    "endColumn": 127,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 342,
                    "endLine": 342,
                    "startColumn": 21,
                    "endColumn": 137,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 345,
                    "endLine": 345,
                    "startColumn": 21,
                    "endColumn": 136,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 348,
                    "endLine": 348,
                    "startColumn": 21,
                    "endColumn": 128,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 358,
                    "endLine": 361,
                    "startColumn": 21,
                    "endColumn": 23,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 365,
                    "endLine": 368,
                    "startColumn": 17,
                    "endColumn": 19,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 373,
                    "endLine": 376,
                    "startColumn": 25,
                    "endColumn": 27,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 379,
                    "endLine": 382,
                    "startColumn": 25,
                    "endColumn": 27,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 388,
                    "endLine": 388,
                    "startColumn": 17,
                    "endColumn": 113,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 396,
                    "endLine": 396,
                    "startColumn": 21,
                    "endColumn": 126,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 409,
                    "endLine": 409,
                    "startColumn": 17,
                    "endColumn": 90,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 411,
                    "endLine": 414,
                    "startColumn": 21,
                    "endColumn": 23,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 417,
                    "endLine": 417,
                    "startColumn": 21,
                    "endColumn": 128,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 420,
                    "endLine": 420,
                    "startColumn": 21,
                    "endColumn": 123,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 423,
                    "endLine": 423,
                    "startColumn": 21,
                    "endColumn": 120,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 426,
                    "endLine": 426,
                    "startColumn": 21,
                    "endColumn": 124,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 429,
                    "endLine": 429,
                    "startColumn": 21,
                    "endColumn": 123,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 432,
                    "endLine": 432,
                    "startColumn": 21,
                    "endColumn": 127,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 435,
                    "endLine": 435,
                    "startColumn": 21,
                    "endColumn": 129,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 468,
                    "endLine": 471,
                    "startColumn": 21,
                    "endColumn": 23,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 391,
                    "endLine": 391,
                    "startColumn": 17,
                    "endColumn": 91,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 394,
                    "endLine": 394,
                    "startColumn": 17,
                    "endColumn": 93,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 399,
                    "endLine": 407,
                    "startColumn": 21,
                    "endColumn": 23,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 441,
                    "endLine": 441,
                    "startColumn": 21,
                    "endColumn": 94,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 329,
                    "endLine": 334,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 335,
                    "endLine": 337,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 338,
                    "endLine": 340,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 341,
                    "endLine": 343,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 344,
                    "endLine": 346,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 347,
                    "endLine": 349,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 357,
                    "endLine": 362,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 356,
                    "endLine": 363,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 364,
                    "endLine": 369,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 372,
                    "endLine": 377,
                    "startColumn": 21,
                    "endColumn": 22,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 378,
                    "endLine": 383,
                    "startColumn": 21,
                    "endColumn": 22,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 371,
                    "endLine": 385,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 370,
                    "endLine": 386,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 387,
                    "endLine": 389,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 390,
                    "endLine": 392,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 410,
                    "endLine": 415,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 419,
                    "endLine": 421,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 422,
                    "endLine": 424,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 425,
                    "endLine": 427,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 428,
                    "endLine": 430,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 431,
                    "endLine": 433,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 434,
                    "endLine": 436,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 393,
                    "endLine": 437,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 438,
                    "endLine": 443,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 465,
                    "endLine": 473,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "ENHANCED_FOR_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 416,
                    "endLine": 418,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 328,
                    "endLine": 350,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 395,
                    "endLine": 397,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 398,
                    "endLine": 408,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 439,
                    "endLine": 442,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "ENHANCED_FOR_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 466,
                    "endLine": 472,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 329,
                    "endLine": 334,
                    "startColumn": 132,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 335,
                    "endLine": 337,
                    "startColumn": 40,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 338,
                    "endLine": 340,
                    "startColumn": 41,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 341,
                    "endLine": 343,
                    "startColumn": 88,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 344,
                    "endLine": 346,
                    "startColumn": 77,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 347,
                    "endLine": 349,
                    "startColumn": 48,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 357,
                    "endLine": 362,
                    "startColumn": 79,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 356,
                    "endLine": 363,
                    "startColumn": 41,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 364,
                    "endLine": 369,
                    "startColumn": 94,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 372,
                    "endLine": 377,
                    "startColumn": 93,
                    "endColumn": 22,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 378,
                    "endLine": 383,
                    "startColumn": 55,
                    "endColumn": 22,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 371,
                    "endLine": 385,
                    "startColumn": 67,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 370,
                    "endLine": 386,
                    "startColumn": 48,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 387,
                    "endLine": 389,
                    "startColumn": 83,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 390,
                    "endLine": 392,
                    "startColumn": 48,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 410,
                    "endLine": 415,
                    "startColumn": 81,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 419,
                    "endLine": 421,
                    "startColumn": 88,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 422,
                    "endLine": 424,
                    "startColumn": 82,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 425,
                    "endLine": 427,
                    "startColumn": 48,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 428,
                    "endLine": 430,
                    "startColumn": 103,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 431,
                    "endLine": 433,
                    "startColumn": 51,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 434,
                    "endLine": 436,
                    "startColumn": 58,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 393,
                    "endLine": 437,
                    "startColumn": 47,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 438,
                    "endLine": 443,
                    "startColumn": 44,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 465,
                    "endLine": 473,
                    "startColumn": 63,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 416,
                    "endLine": 418,
                    "startColumn": 29,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 328,
                    "endLine": 350,
                    "startColumn": 33,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 395,
                    "endLine": 397,
                    "startColumn": 32,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 398,
                    "endLine": 408,
                    "startColumn": 67,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 440,
                    "endLine": 442,
                    "startColumn": 69,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 467,
                    "endLine": 472,
                    "startColumn": 104,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code from source method declaration",
                    "codeElement": null
                }
            ],
            "rightSideLocations": [
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2203,
                    "endLine": 2359,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "extracted method declaration",
                    "codeElement": "public validate(validationException ActionRequestValidationException, isScroll boolean) : ActionRequestValidationException"
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2239,
                    "endLine": 2242,
                    "startColumn": 17,
                    "endColumn": 19,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2245,
                    "endLine": 2245,
                    "startColumn": 17,
                    "endColumn": 130,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2248,
                    "endLine": 2248,
                    "startColumn": 17,
                    "endColumn": 123,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2251,
                    "endLine": 2251,
                    "startColumn": 17,
                    "endColumn": 133,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2254,
                    "endLine": 2254,
                    "startColumn": 17,
                    "endColumn": 132,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2257,
                    "endLine": 2257,
                    "startColumn": 17,
                    "endColumn": 124,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2262,
                    "endLine": 2265,
                    "startColumn": 17,
                    "endColumn": 19,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2269,
                    "endLine": 2269,
                    "startColumn": 13,
                    "endColumn": 140,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2274,
                    "endLine": 2277,
                    "startColumn": 21,
                    "endColumn": 23,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2280,
                    "endLine": 2283,
                    "startColumn": 21,
                    "endColumn": 23,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2288,
                    "endLine": 2288,
                    "startColumn": 13,
                    "endColumn": 109,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2297,
                    "endLine": 2297,
                    "startColumn": 17,
                    "endColumn": 122,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2310,
                    "endLine": 2310,
                    "startColumn": 13,
                    "endColumn": 72,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2312,
                    "endLine": 2315,
                    "startColumn": 17,
                    "endColumn": 19,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2318,
                    "endLine": 2318,
                    "startColumn": 17,
                    "endColumn": 124,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2321,
                    "endLine": 2321,
                    "startColumn": 17,
                    "endColumn": 119,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2324,
                    "endLine": 2324,
                    "startColumn": 17,
                    "endColumn": 116,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2327,
                    "endLine": 2327,
                    "startColumn": 17,
                    "endColumn": 120,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2330,
                    "endLine": 2330,
                    "startColumn": 17,
                    "endColumn": 119,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2333,
                    "endLine": 2333,
                    "startColumn": 17,
                    "endColumn": 123,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2336,
                    "endLine": 2336,
                    "startColumn": 17,
                    "endColumn": 125,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2351,
                    "endLine": 2354,
                    "startColumn": 21,
                    "endColumn": 23,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2291,
                    "endLine": 2291,
                    "startColumn": 13,
                    "endColumn": 80,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2295,
                    "endLine": 2295,
                    "startColumn": 13,
                    "endColumn": 72,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2300,
                    "endLine": 2308,
                    "startColumn": 17,
                    "endColumn": 19,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2343,
                    "endLine": 2343,
                    "startColumn": 17,
                    "endColumn": 84,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2238,
                    "endLine": 2243,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2244,
                    "endLine": 2246,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2247,
                    "endLine": 2249,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2250,
                    "endLine": 2252,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2253,
                    "endLine": 2255,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2256,
                    "endLine": 2258,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2261,
                    "endLine": 2266,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2260,
                    "endLine": 2267,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2268,
                    "endLine": 2270,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2273,
                    "endLine": 2278,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2279,
                    "endLine": 2284,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2272,
                    "endLine": 2285,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2271,
                    "endLine": 2286,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2287,
                    "endLine": 2289,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2290,
                    "endLine": 2292,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2311,
                    "endLine": 2316,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2320,
                    "endLine": 2322,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2323,
                    "endLine": 2325,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2326,
                    "endLine": 2328,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2329,
                    "endLine": 2331,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2332,
                    "endLine": 2334,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2335,
                    "endLine": 2337,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2294,
                    "endLine": 2338,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2340,
                    "endLine": 2345,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2348,
                    "endLine": 2356,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "ENHANCED_FOR_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2317,
                    "endLine": 2319,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2347,
                    "endLine": 2357,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2296,
                    "endLine": 2298,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2299,
                    "endLine": 2309,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2341,
                    "endLine": 2344,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "ENHANCED_FOR_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2349,
                    "endLine": 2355,
                    "startColumn": 17,
                    "endColumn": 18,
                    "codeElementType": "IF_STATEMENT",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2238,
                    "endLine": 2243,
                    "startColumn": 114,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2244,
                    "endLine": 2246,
                    "startColumn": 29,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2247,
                    "endLine": 2249,
                    "startColumn": 30,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2250,
                    "endLine": 2252,
                    "startColumn": 70,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2253,
                    "endLine": 2255,
                    "startColumn": 66,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2256,
                    "endLine": 2258,
                    "startColumn": 37,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2261,
                    "endLine": 2266,
                    "startColumn": 70,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2260,
                    "endLine": 2267,
                    "startColumn": 30,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2268,
                    "endLine": 2270,
                    "startColumn": 76,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2273,
                    "endLine": 2278,
                    "startColumn": 75,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2279,
                    "endLine": 2284,
                    "startColumn": 44,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2272,
                    "endLine": 2285,
                    "startColumn": 56,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2271,
                    "endLine": 2286,
                    "startColumn": 37,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2287,
                    "endLine": 2289,
                    "startColumn": 65,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2290,
                    "endLine": 2292,
                    "startColumn": 37,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2311,
                    "endLine": 2316,
                    "startColumn": 70,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2320,
                    "endLine": 2322,
                    "startColumn": 70,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2323,
                    "endLine": 2325,
                    "startColumn": 64,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2326,
                    "endLine": 2328,
                    "startColumn": 37,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2329,
                    "endLine": 2331,
                    "startColumn": 85,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2332,
                    "endLine": 2334,
                    "startColumn": 40,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2335,
                    "endLine": 2337,
                    "startColumn": 47,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2294,
                    "endLine": 2338,
                    "startColumn": 36,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2340,
                    "endLine": 2345,
                    "startColumn": 33,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2348,
                    "endLine": 2356,
                    "startColumn": 45,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2317,
                    "endLine": 2319,
                    "startColumn": 27,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2347,
                    "endLine": 2357,
                    "startColumn": 62,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2296,
                    "endLine": 2298,
                    "startColumn": 25,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2299,
                    "endLine": 2309,
                    "startColumn": 53,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2342,
                    "endLine": 2344,
                    "startColumn": 40,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2350,
                    "endLine": 2355,
                    "startColumn": 88,
                    "endColumn": 18,
                    "codeElementType": "BLOCK",
                    "description": "extracted code to extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 319,
                    "endLine": 365,
                    "startColumn": 5,
                    "endColumn": 6,
                    "codeElementType": "METHOD_DECLARATION",
                    "description": "source method declaration after extraction",
                    "codeElement": "public validate() : ActionRequestValidationException"
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                    "startLine": 325,
                    "endLine": 325,
                    "startColumn": 35,
                    "endColumn": 79,
                    "codeElementType": "METHOD_INVOCATION",
                    "description": "extracted method invocation",
                    "codeElement": "source.validate(validationException,scroll)"
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2205,
                    "endLine": 2205,
                    "startColumn": 13,
                    "endColumn": 56,
                    "codeElementType": "VARIABLE_DECLARATION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2207,
                    "endLine": 2207,
                    "startColumn": 17,
                    "endColumn": 63,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2210,
                    "endLine": 2210,
                    "startColumn": 17,
                    "endColumn": 61,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2213,
                    "endLine": 2213,
                    "startColumn": 17,
                    "endColumn": 64,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2216,
                    "endLine": 2216,
                    "startColumn": 17,
                    "endColumn": 73,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2219,
                    "endLine": 2219,
                    "startColumn": 17,
                    "endColumn": 62,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2222,
                    "endLine": 2222,
                    "startColumn": 17,
                    "endColumn": 65,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2225,
                    "endLine": 2225,
                    "startColumn": 17,
                    "endColumn": 67,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2228,
                    "endLine": 2228,
                    "startColumn": 17,
                    "endColumn": 62,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2231,
                    "endLine": 2234,
                    "startColumn": 17,
                    "endColumn": 19,
                    "codeElementType": "EXPRESSION_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2358,
                    "endLine": 2358,
                    "startColumn": 9,
                    "endColumn": 36,
                    "codeElementType": "RETURN_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2206,
                    "endLine": 2208,
                    "startColumn": 51,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2206,
                    "endLine": 2208,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2209,
                    "endLine": 2211,
                    "startColumn": 49,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2209,
                    "endLine": 2211,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2212,
                    "endLine": 2214,
                    "startColumn": 40,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2212,
                    "endLine": 2214,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2215,
                    "endLine": 2217,
                    "startColumn": 62,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2215,
                    "endLine": 2217,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2218,
                    "endLine": 2220,
                    "startColumn": 34,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2218,
                    "endLine": 2220,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2221,
                    "endLine": 2223,
                    "startColumn": 37,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2221,
                    "endLine": 2223,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2224,
                    "endLine": 2226,
                    "startColumn": 37,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2224,
                    "endLine": 2226,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2227,
                    "endLine": 2229,
                    "startColumn": 40,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2227,
                    "endLine": 2229,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2230,
                    "endLine": 2235,
                    "startColumn": 47,
                    "endColumn": 14,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2230,
                    "endLine": 2235,
                    "startColumn": 13,
                    "endColumn": 14,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2204,
                    "endLine": 2236,
                    "startColumn": 34,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2204,
                    "endLine": 2236,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2237,
                    "endLine": 2259,
                    "startColumn": 9,
                    "endColumn": 10,
                    "codeElementType": "IF_STATEMENT",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                },
                {
                    "filePath": "server/src/main/java/org/elasticsearch/search/builder/SearchSourceBuilder.java",
                    "startLine": 2237,
                    "endLine": 2259,
                    "startColumn": 23,
                    "endColumn": 10,
                    "codeElementType": "BLOCK",
                    "description": "added statement in extracted method declaration",
                    "codeElement": null
                }
            ],
            "isStatic": false
        },
        "ref_id": 376,
        "extraction_results": {
            "success": true,
            "newCommitHash": "07e02bc7654448f5067d359bfdc664b3c6e97666",
            "newBranchName": "extract-validate-validate-4a77e06"
        },
        "telemetry": {
            "id": "7586aa09-44c3-459b-9fab-5e3c7cbbe59f",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 963,
                "lineStart": 49,
                "lineEnd": 1011,
                "bodyLineStart": 49,
                "language": "java",
                "filePath": "/Users/abhiram/Documents/TBE/evaluation_projects/elasticsearch/server/src/main/java/org/elasticsearch/action/search/SearchRequest.java",
                "sourceCode": "/**\n * A request to execute search against one or more indices (or all).\n * <p>\n * Note, the search {@link #source(org.elasticsearch.search.builder.SearchSourceBuilder)}\n * is required. The search source is the different search options, including aggregations and such.\n * </p>\n *\n * @see org.elasticsearch.client.internal.Client#search(SearchRequest)\n * @see SearchResponse\n */\npublic class SearchRequest extends ActionRequest implements IndicesRequest.Replaceable, Rewriteable<SearchRequest> {\n\n    public static final ToXContent.Params FORMAT_PARAMS = new ToXContent.MapParams(Collections.singletonMap(\"pretty\", \"false\"));\n\n    public static final int DEFAULT_PRE_FILTER_SHARD_SIZE = 128;\n    public static final int DEFAULT_BATCHED_REDUCE_SIZE = 512;\n\n    private static final long DEFAULT_ABSOLUTE_START_MILLIS = -1;\n\n    private final String localClusterAlias;\n    private final long absoluteStartMillis;\n    private final boolean finalReduce;\n\n    private SearchType searchType = SearchType.DEFAULT;\n\n    private String[] indices = Strings.EMPTY_ARRAY;\n\n    @Nullable\n    private String routing;\n    @Nullable\n    private String preference;\n\n    private SearchSourceBuilder source;\n\n    private Boolean requestCache;\n\n    private Boolean allowPartialSearchResults;\n\n    private Scroll scroll;\n\n    private int batchedReduceSize = DEFAULT_BATCHED_REDUCE_SIZE;\n\n    private int maxConcurrentShardRequests = 0;\n    public static final int DEFAULT_MAX_CONCURRENT_SHARD_REQUESTS = 5;\n\n    private Integer preFilterShardSize;\n\n    private boolean ccsMinimizeRoundtrips;\n\n    @Nullable\n    private final Version minCompatibleShardNode;\n\n    public static final IndicesOptions DEFAULT_INDICES_OPTIONS = IndicesOptions.strictExpandOpenAndForbidClosedIgnoreThrottled();\n\n    private IndicesOptions indicesOptions = DEFAULT_INDICES_OPTIONS;\n\n    private Map<String, long[]> waitForCheckpoints = Collections.emptyMap();\n\n    private TimeValue waitForCheckpointsTimeout = TimeValue.timeValueSeconds(30);\n\n    /**\n     * Should this request force {@link SourceLoader.Synthetic synthetic source}?\n     * Use this to test if the mapping supports synthetic _source and to get a sense\n     * of the worst case performance. Fetches with this enabled will be slower the\n     * enabling synthetic source natively in the index.\n     */\n    private boolean forceSyntheticSource = false;\n\n    public SearchRequest() {\n        this((Version) null);\n    }\n\n    public SearchRequest(Version minCompatibleShardNode) {\n        this.localClusterAlias = null;\n        this.absoluteStartMillis = DEFAULT_ABSOLUTE_START_MILLIS;\n        this.finalReduce = true;\n        this.minCompatibleShardNode = minCompatibleShardNode;\n        this.ccsMinimizeRoundtrips = minCompatibleShardNode == null;\n    }\n\n    /**\n     * Constructs a new search request from the provided search request\n     */\n    public SearchRequest(SearchRequest searchRequest) {\n        this(\n            searchRequest,\n            searchRequest.indices,\n            searchRequest.localClusterAlias,\n            searchRequest.absoluteStartMillis,\n            searchRequest.finalReduce\n        );\n    }\n\n    /**\n     * Constructs a new search request against the indices. No indices provided here means that search\n     * will run against all indices.\n     */\n    public SearchRequest(String... indices) {\n        this(indices, new SearchSourceBuilder());\n    }\n\n    /**\n     * Constructs a new search request against the provided indices with the given search source.\n     */\n    @SuppressWarnings(\"this-escape\")\n    public SearchRequest(String[] indices, SearchSourceBuilder source) {\n        this();\n        if (source == null) {\n            throw new IllegalArgumentException(\"source must not be null\");\n        }\n        indices(indices);\n        this.source = source;\n    }\n\n    @Override\n    public boolean allowsRemoteIndices() {\n        return true;\n    }\n\n    /**\n     * Creates a new sub-search request starting from the original search request that is provided.\n     * For internal use only, allows to fork a search request into multiple search requests that will be executed independently.\n     * Such requests will not be finally reduced, so that their results can be merged together in one response at completion.\n     * Used when a {@link SearchRequest} is created and executed as part of a cross-cluster search request\n     * performing reduction on each cluster in order to minimize network round-trips between the coordinating node and the remote clusters.\n     *\n     * @param parentTaskId the parent taskId of the original search request\n     * @param originalSearchRequest the original search request\n     * @param indices the indices to search against\n     * @param clusterAlias the alias to prefix index names with in the returned search results\n     * @param absoluteStartMillis the absolute start time to be used on the remote clusters to ensure that the same value is used\n     * @param finalReduce whether the reduction should be final or not\n     */\n    static SearchRequest subSearchRequest(\n        TaskId parentTaskId,\n        SearchRequest originalSearchRequest,\n        String[] indices,\n        String clusterAlias,\n        long absoluteStartMillis,\n        boolean finalReduce\n    ) {\n        Objects.requireNonNull(parentTaskId, \"parentTaskId must be specified\");\n        Objects.requireNonNull(originalSearchRequest, \"search request must not be null\");\n        validateIndices(indices);\n        Objects.requireNonNull(clusterAlias, \"cluster alias must not be null\");\n        if (absoluteStartMillis < 0) {\n            throw new IllegalArgumentException(\"absoluteStartMillis must not be negative but was [\" + absoluteStartMillis + \"]\");\n        }\n        final SearchRequest request = new SearchRequest(originalSearchRequest, indices, clusterAlias, absoluteStartMillis, finalReduce);\n        request.setParentTask(parentTaskId);\n        return request;\n    }\n\n    private SearchRequest(\n        SearchRequest searchRequest,\n        String[] indices,\n        String localClusterAlias,\n        long absoluteStartMillis,\n        boolean finalReduce\n    ) {\n        this.allowPartialSearchResults = searchRequest.allowPartialSearchResults;\n        this.batchedReduceSize = searchRequest.batchedReduceSize;\n        this.ccsMinimizeRoundtrips = searchRequest.ccsMinimizeRoundtrips;\n        this.indices = indices;\n        this.indicesOptions = searchRequest.indicesOptions;\n        this.maxConcurrentShardRequests = searchRequest.maxConcurrentShardRequests;\n        this.preference = searchRequest.preference;\n        this.preFilterShardSize = searchRequest.preFilterShardSize;\n        this.requestCache = searchRequest.requestCache;\n        this.routing = searchRequest.routing;\n        this.scroll = searchRequest.scroll;\n        this.searchType = searchRequest.searchType;\n        this.source = searchRequest.source;\n        this.localClusterAlias = localClusterAlias;\n        this.absoluteStartMillis = absoluteStartMillis;\n        this.finalReduce = finalReduce;\n        this.minCompatibleShardNode = searchRequest.minCompatibleShardNode;\n        this.waitForCheckpoints = searchRequest.waitForCheckpoints;\n        this.waitForCheckpointsTimeout = searchRequest.waitForCheckpointsTimeout;\n        this.forceSyntheticSource = searchRequest.forceSyntheticSource;\n    }\n\n    /**\n     * Constructs a new search request from reading the specified stream.\n     *\n     * @param in The stream the request is read from\n     * @throws IOException if there is an issue reading the stream\n     */\n    public SearchRequest(StreamInput in) throws IOException {\n        super(in);\n        searchType = SearchType.fromId(in.readByte());\n        indices = in.readStringArray();\n        routing = in.readOptionalString();\n        preference = in.readOptionalString();\n        scroll = in.readOptionalWriteable(Scroll::new);\n        source = in.readOptionalWriteable(SearchSourceBuilder::new);\n        if (in.getTransportVersion().before(TransportVersions.V_8_0_0)) {\n            // types no longer relevant so ignore\n            String[] types = in.readStringArray();\n            if (types.length > 0) {\n                throw new IllegalStateException(\n                    \"types are no longer supported in search requests but found [\" + Arrays.toString(types) + \"]\"\n                );\n            }\n        }\n        indicesOptions = IndicesOptions.readIndicesOptions(in);\n        requestCache = in.readOptionalBoolean();\n        batchedReduceSize = in.readVInt();\n        maxConcurrentShardRequests = in.readVInt();\n        preFilterShardSize = in.readOptionalVInt();\n        allowPartialSearchResults = in.readOptionalBoolean();\n        localClusterAlias = in.readOptionalString();\n        if (localClusterAlias != null) {\n            absoluteStartMillis = in.readVLong();\n            finalReduce = in.readBoolean();\n        } else {\n            absoluteStartMillis = DEFAULT_ABSOLUTE_START_MILLIS;\n            finalReduce = true;\n        }\n        ccsMinimizeRoundtrips = in.readBoolean();\n        if (in.readBoolean()) {\n            minCompatibleShardNode = Version.readVersion(in);\n        } else {\n            minCompatibleShardNode = null;\n        }\n        waitForCheckpoints = in.readMap(StreamInput::readLongArray);\n        waitForCheckpointsTimeout = in.readTimeValue();\n        if (in.getTransportVersion().onOrAfter(TransportVersions.V_8_4_0)) {\n            forceSyntheticSource = in.readBoolean();\n        } else {\n            forceSyntheticSource = false;\n        }\n    }\n\n    @Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeByte(searchType.id());\n        out.writeStringArray(indices);\n        out.writeOptionalString(routing);\n        out.writeOptionalString(preference);\n        out.writeOptionalWriteable(scroll);\n        out.writeOptionalWriteable(source);\n        if (out.getTransportVersion().before(TransportVersions.V_8_0_0)) {\n            // types not supported so send an empty array to previous versions\n            out.writeStringArray(Strings.EMPTY_ARRAY);\n        }\n        indicesOptions.writeIndicesOptions(out);\n        out.writeOptionalBoolean(requestCache);\n        out.writeVInt(batchedReduceSize);\n        out.writeVInt(maxConcurrentShardRequests);\n        out.writeOptionalVInt(preFilterShardSize);\n        out.writeOptionalBoolean(allowPartialSearchResults);\n        out.writeOptionalString(localClusterAlias);\n        if (localClusterAlias != null) {\n            out.writeVLong(absoluteStartMillis);\n            out.writeBoolean(finalReduce);\n        }\n        out.writeBoolean(ccsMinimizeRoundtrips);\n        out.writeBoolean(minCompatibleShardNode != null);\n        if (minCompatibleShardNode != null) {\n            Version.writeVersion(minCompatibleShardNode, out);\n        }\n        out.writeMap(waitForCheckpoints, StreamOutput::writeLongArray);\n        out.writeTimeValue(waitForCheckpointsTimeout);\n        if (out.getTransportVersion().onOrAfter(TransportVersions.V_8_4_0)) {\n            out.writeBoolean(forceSyntheticSource);\n        } else {\n            if (forceSyntheticSource) {\n                throw new IllegalArgumentException(\"force_synthetic_source is not supported before 8.4.0\");\n            }\n        }\n    }\n\n    @Override\n    public ActionRequestValidationException validate() {\n        ActionRequestValidationException validationException = null;\n        boolean scroll = scroll() != null;\n        if (scroll) {\n            if (source != null) {\n                if (source.trackTotalHitsUpTo() != null && source.trackTotalHitsUpTo() != SearchContext.TRACK_TOTAL_HITS_ACCURATE) {\n                    validationException = addValidationError(\n                        \"disabling [track_total_hits] is not allowed in a scroll context\",\n                        validationException\n                    );\n                }\n                if (source.from() > 0) {\n                    validationException = addValidationError(\"using [from] is not allowed in a scroll context\", validationException);\n                }\n                if (source.size() == 0) {\n                    validationException = addValidationError(\"[size] cannot be [0] in a scroll context\", validationException);\n                }\n                if (source.rescores() != null && source.rescores().isEmpty() == false) {\n                    validationException = addValidationError(\"using [rescore] is not allowed in a scroll context\", validationException);\n                }\n                if (CollectionUtils.isEmpty(source.searchAfter()) == false) {\n                    validationException = addValidationError(\"[search_after] cannot be used in a scroll context\", validationException);\n                }\n                if (source.collapse() != null) {\n                    validationException = addValidationError(\"cannot use `collapse` in a scroll context\", validationException);\n                }\n            }\n            if (requestCache != null && requestCache) {\n                validationException = addValidationError(\"[request_cache] cannot be used in a scroll context\", validationException);\n            }\n        }\n        if (source != null) {\n            if (source.slice() != null) {\n                if (source.pointInTimeBuilder() == null && (scroll == false)) {\n                    validationException = addValidationError(\n                        \"[slice] can only be used with [scroll] or [point-in-time] requests\",\n                        validationException\n                    );\n                }\n            }\n            if (source.from() > 0 && CollectionUtils.isEmpty(source.searchAfter()) == false) {\n                validationException = addValidationError(\n                    \"[from] parameter must be set to 0 when [search_after] is used\",\n                    validationException\n                );\n            }\n            if (source.storedFields() != null) {\n                if (source.storedFields().fetchFields() == false) {\n                    if (source.fetchSource() != null && source.fetchSource().fetchSource()) {\n                        validationException = addValidationError(\n                            \"[stored_fields] cannot be disabled if [_source] is requested\",\n                            validationException\n                        );\n                    }\n                    if (source.fetchFields() != null) {\n                        validationException = addValidationError(\n                            \"[stored_fields] cannot be disabled when using the [fields] option\",\n                            validationException\n                        );\n                    }\n\n                }\n            }\n            if (source.subSearches().size() >= 2 && source.rankBuilder() == null) {\n                validationException = addValidationError(\"[sub_searches] requires [rank]\", validationException);\n            }\n            if (source.aggregations() != null) {\n                validationException = source.aggregations().validate(validationException);\n            }\n            validationException = validate(validationException, scroll);\n            if (source.rescores() != null) {\n                for (@SuppressWarnings(\"rawtypes\")\n                RescorerBuilder rescoreBuilder : source.rescores()) {\n                    validationException = rescoreBuilder.validate(this, validationException);\n                }\n            }\n        }\n        if (pointInTimeBuilder() != null) {\n            if (scroll) {\n                validationException = addValidationError(\"using [point in time] is not allowed in a scroll context\", validationException);\n            }\n            if (indices().length > 0) {\n                validationException = addValidationError(\n                    \"[indices] cannot be used with point in time. Do not specify any index with point in time.\",\n                    validationException\n                );\n            }\n            if (indicesOptions().equals(DEFAULT_INDICES_OPTIONS) == false) {\n                validationException = addValidationError(\"[indicesOptions] cannot be used with point in time\", validationException);\n            }\n            if (routing() != null) {\n                validationException = addValidationError(\"[routing] cannot be used with point in time\", validationException);\n            }\n            if (preference() != null) {\n                validationException = addValidationError(\"[preference] cannot be used with point in time\", validationException);\n            }\n        } else if (source != null && source.sorts() != null) {\n            for (SortBuilder<?> sortBuilder : source.sorts()) {\n                if (sortBuilder instanceof FieldSortBuilder\n                    && ShardDocSortField.NAME.equals(((FieldSortBuilder) sortBuilder).getFieldName())) {\n                    validationException = addValidationError(\n                        \"[\" + FieldSortBuilder.SHARD_DOC_FIELD_NAME + \"] sort field cannot be used without [point in time]\",\n                        validationException\n                    );\n                }\n            }\n        }\n        if (minCompatibleShardNode() != null) {\n            if (isCcsMinimizeRoundtrips()) {\n                validationException = addValidationError(\n                    \"[ccs_minimize_roundtrips] cannot be [true] when setting a minimum compatible \" + \"shard version\",\n                    validationException\n                );\n            }\n        }\n        if (pointInTimeBuilder() != null && waitForCheckpoints.isEmpty() == false) {\n            validationException = addValidationError(\"using [point in time] is not allowed with wait_for_checkpoints\", validationException);\n\n        }\n        return validationException;\n    }\n\n    private ActionRequestValidationException validate(ActionRequestValidationException validationException, boolean scroll) {\n        if (source.rankBuilder() != null) {\n            int size = source.size() == -1 ? SearchService.DEFAULT_SIZE : source.size();\n            if (size == 0) {\n                validationException = addValidationError(\"[rank] requires [size] greater than [0]\", validationException);\n            }\n            if (size > source.rankBuilder().rankWindowSize()) {\n                validationException = addValidationError(\n                    \"[rank] requires [rank_window_size: \"\n                        + source.rankBuilder().rankWindowSize()\n                        + \"]\"\n                        + \" be greater than or equal to [size: \"\n                        + size\n                        + \"]\",\n                    validationException\n                );\n            }\n            int queryCount = source.subSearches().size() + source.knnSearch().size();\n            if (source.rankBuilder().isCompoundBuilder() && queryCount < 2) {\n                validationException = addValidationError(\n                    \"[rank] requires a minimum of [2] result sets using a combination of sub searches and/or knn searches\",\n                    validationException\n                );\n            }\n            if (scroll) {\n                validationException = addValidationError(\"[rank] cannot be used in a scroll context\", validationException);\n            }\n            if (source.rescores() != null && source.rescores().isEmpty() == false) {\n                validationException = addValidationError(\"[rank] cannot be used with [rescore]\", validationException);\n            }\n            if (source.sorts() != null && source.sorts().isEmpty() == false) {\n                validationException = addValidationError(\"[rank] cannot be used with [sort]\", validationException);\n            }\n            if (source.collapse() != null) {\n                validationException = addValidationError(\"[rank] cannot be used with [collapse]\", validationException);\n            }\n            if (source.suggest() != null && source.suggest().getSuggestions().isEmpty() == false) {\n                validationException = addValidationError(\"[rank] cannot be used with [suggest]\", validationException);\n            }\n            if (source.highlighter() != null) {\n                validationException = addValidationError(\"[rank] cannot be used with [highlighter]\", validationException);\n            }\n            if (source.pointInTimeBuilder() != null) {\n                validationException = addValidationError(\"[rank] cannot be used with [point in time]\", validationException);\n            }\n        }\n        return validationException;\n    }\n\n    /**\n     * Returns the alias of the cluster that this search request is being executed on. A non-null value indicates that this search request\n     * is being executed as part of a locally reduced cross-cluster search request. The cluster alias is used to prefix index names\n     * returned as part of search hits with the alias of the cluster they came from.\n     */\n    @Nullable\n    String getLocalClusterAlias() {\n        return localClusterAlias;\n    }\n\n    /**\n     * Returns whether the reduction phase that will be performed needs to be final or not.\n     */\n    boolean isFinalReduce() {\n        return finalReduce;\n    }\n\n    /**\n     * Returns the current time in milliseconds from the time epoch, to be used for the execution of this search request. Used to\n     * ensure that the same value, determined by the coordinating node, is used on all nodes involved in the execution of the search\n     * request. When created through {@link #subSearchRequest(TaskId, SearchRequest, String[], String, long, boolean)}, this method returns\n     * the provided current time, otherwise it will return {@link System#currentTimeMillis()}.\n     */\n    long getOrCreateAbsoluteStartMillis() {\n        return absoluteStartMillis == DEFAULT_ABSOLUTE_START_MILLIS ? System.currentTimeMillis() : absoluteStartMillis;\n    }\n\n    /**\n     * Returns the provided <code>absoluteStartMillis</code> when created through {@link #subSearchRequest} and\n     * -1 otherwise.\n     */\n    long getAbsoluteStartMillis() {\n        return absoluteStartMillis;\n    }\n\n    /**\n     * Returns the minimum compatible shard version the search request needs to run on. If the version is null, then there are no\n     * restrictions imposed on shards versions part of this search.\n     */\n    @Nullable\n    public Version minCompatibleShardNode() {\n        return minCompatibleShardNode;\n    }\n\n    /**\n     * Sets the indices the search will be executed on.\n     */\n    @Override\n    public SearchRequest indices(String... indices) {\n        validateIndices(indices);\n        this.indices = indices;\n        return this;\n    }\n\n    private static void validateIndices(String... indices) {\n        Objects.requireNonNull(indices, \"indices must not be null\");\n        for (String index : indices) {\n            Objects.requireNonNull(index, \"index must not be null\");\n        }\n    }\n\n    @Override\n    public IndicesOptions indicesOptions() {\n        return indicesOptions;\n    }\n\n    public SearchRequest indicesOptions(IndicesOptions indicesOptions) {\n        this.indicesOptions = Objects.requireNonNull(indicesOptions, \"indicesOptions must not be null\");\n        return this;\n    }\n\n    @Override\n    public boolean includeDataStreams() {\n        return true;\n    }\n\n    /**\n     * Returns whether network round-trips should be minimized when executing cross-cluster search requests.\n     * Defaults to <code>true</code>, unless <code>minCompatibleShardNode</code> is set in which case it's set to <code>false</code>.\n     */\n    public boolean isCcsMinimizeRoundtrips() {\n        return ccsMinimizeRoundtrips;\n    }\n\n    /**\n     * Sets whether network round-trips should be minimized when executing cross-cluster search requests. Defaults to <code>true</code>.\n     */\n    public void setCcsMinimizeRoundtrips(boolean ccsMinimizeRoundtrips) {\n        this.ccsMinimizeRoundtrips = ccsMinimizeRoundtrips;\n    }\n\n    /**\n     * A comma separated list of routing values to control the shards the search will be executed on.\n     */\n    public String routing() {\n        return this.routing;\n    }\n\n    /**\n     * A comma separated list of routing values to control the shards the search will be executed on.\n     */\n    public SearchRequest routing(String routing) {\n        this.routing = routing;\n        return this;\n    }\n\n    /**\n     * The routing values to control the shards that the search will be executed on.\n     */\n    public SearchRequest routing(String... routings) {\n        this.routing = Strings.arrayToCommaDelimitedString(routings);\n        return this;\n    }\n\n    /**\n     * Sets the preference to execute the search. Defaults to randomize across shards. Can be set to\n     * {@code _local} to prefer local shards or a custom value, which guarantees that the same order\n     * will be used across different requests.\n     */\n    public SearchRequest preference(String preference) {\n        this.preference = preference;\n        return this;\n    }\n\n    public String preference() {\n        return this.preference;\n    }\n\n    /**\n     * The search type to execute, defaults to {@link SearchType#DEFAULT}.\n     */\n    public SearchRequest searchType(SearchType searchType) {\n        this.searchType = Objects.requireNonNull(searchType, \"searchType must not be null\");\n        return this;\n    }\n\n    /**\n     * The a string representation search type to execute, defaults to {@link SearchType#DEFAULT}. Can be\n     * one of \"dfs_query_then_fetch\" or \"query_then_fetch\".\n     */\n    public SearchRequest searchType(String searchType) {\n        return searchType(SearchType.fromString(searchType));\n    }\n\n    /**\n     * The source of the search request.\n     */\n    public SearchRequest source(SearchSourceBuilder sourceBuilder) {\n        this.source = Objects.requireNonNull(sourceBuilder, \"source must not be null\");\n        return this;\n    }\n\n    /**\n     * The search source to execute.\n     */\n    public SearchSourceBuilder source() {\n        return source;\n    }\n\n    public PointInTimeBuilder pointInTimeBuilder() {\n        if (source != null) {\n            return source.pointInTimeBuilder();\n        }\n        return null;\n    }\n\n    /**\n     * The tye of search to execute.\n     */\n    public SearchType searchType() {\n        return searchType;\n    }\n\n    /**\n     * The indices\n     */\n    @Override\n    public String[] indices() {\n        return indices;\n    }\n\n    /**\n     * If set, will enable scrolling of the search request.\n     */\n    public Scroll scroll() {\n        return scroll;\n    }\n\n    /**\n     * If set, will enable scrolling of the search request.\n     */\n    public SearchRequest scroll(Scroll scroll) {\n        this.scroll = scroll;\n        return this;\n    }\n\n    /**\n     * If set, will enable scrolling of the search request for the specified timeout.\n     */\n    public SearchRequest scroll(TimeValue keepAlive) {\n        return scroll(new Scroll(keepAlive));\n    }\n\n    /**\n     * Sets if this request should use the request cache or not, assuming that it can (for\n     * example, if \"now\" is used, it will never be cached). By default (not set, or null,\n     * will default to the index level setting if request cache is enabled or not).\n     */\n    public SearchRequest requestCache(Boolean requestCache) {\n        this.requestCache = requestCache;\n        return this;\n    }\n\n    public Boolean requestCache() {\n        return this.requestCache;\n    }\n\n    /**\n     * Sets if this request should allow partial results. (If method is not called,\n     * will default to the cluster level setting).\n     */\n    public SearchRequest allowPartialSearchResults(boolean allowPartialSearchResults) {\n        this.allowPartialSearchResults = allowPartialSearchResults;\n        return this;\n    }\n\n    public Boolean allowPartialSearchResults() {\n        return this.allowPartialSearchResults;\n    }\n\n    /**\n     * Sets the number of shard results that should be reduced at once on the coordinating node. This value should be used as a protection\n     * mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n     */\n    public void setBatchedReduceSize(int batchedReduceSize) {\n        if (batchedReduceSize <= 1) {\n            throw new IllegalArgumentException(\"batchedReduceSize must be >= 2\");\n        }\n        this.batchedReduceSize = batchedReduceSize;\n    }\n\n    /**\n     * Returns the number of shard results that should be reduced at once on the coordinating node. This value should be used as a\n     * protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.\n     */\n    public int getBatchedReduceSize() {\n        return batchedReduceSize;\n    }\n\n    /**\n     * Returns the number of shard requests that should be executed concurrently on a single node. This value should be used as a\n     * protection mechanism to reduce the number of shard requests fired per high level search request. Searches that hit the entire\n     * cluster can be throttled with this number to reduce the cluster load. The default is {@code 5}\n     */\n    public int getMaxConcurrentShardRequests() {\n        return maxConcurrentShardRequests == 0 ? DEFAULT_MAX_CONCURRENT_SHARD_REQUESTS : maxConcurrentShardRequests;\n    }\n\n    /**\n     * Sets the number of shard requests that should be executed concurrently on a single node. This value should be used as a\n     * protection mechanism to reduce the number of shard requests fired per high level search request. Searches that hit the entire\n     * cluster can be throttled with this number to reduce the cluster load. The default is {@code 5}\n     */\n    public void setMaxConcurrentShardRequests(int maxConcurrentShardRequests) {\n        if (maxConcurrentShardRequests < 1) {\n            throw new IllegalArgumentException(\"maxConcurrentShardRequests must be >= 1\");\n        }\n        this.maxConcurrentShardRequests = maxConcurrentShardRequests;\n    }\n\n    public Map<String, long[]> getWaitForCheckpoints() {\n        return waitForCheckpoints;\n    }\n\n    public void setWaitForCheckpoints(Map<String, long[]> afterCheckpointsRefreshed) {\n        this.waitForCheckpoints = afterCheckpointsRefreshed;\n    }\n\n    public TimeValue getWaitForCheckpointsTimeout() {\n        return waitForCheckpointsTimeout;\n    }\n\n    public void setWaitForCheckpointsTimeout(final TimeValue waitForCheckpointsTimeout) {\n        this.waitForCheckpointsTimeout = waitForCheckpointsTimeout;\n    }\n\n    /**\n     * Sets a threshold that enforces a pre-filter roundtrip to pre-filter search shards based on query rewriting if the number of shards\n     * the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for\n     * instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard\n     * bounds and the query are disjoint.\n     *\n     * When unspecified, the pre-filter phase is executed if any of these conditions is met:\n     * <ul>\n     * <li>The request targets more than 128 shards</li>\n     * <li>The request targets one or more read-only index</li>\n     * <li>The primary sort of the query targets an indexed field</li>\n     * </ul>\n     */\n    public void setPreFilterShardSize(int preFilterShardSize) {\n        if (preFilterShardSize < 1) {\n            throw new IllegalArgumentException(\"preFilterShardSize must be >= 1\");\n        }\n        this.preFilterShardSize = preFilterShardSize;\n    }\n\n    /**\n     * Returns a threshold that enforces a pre-filter roundtrip to pre-filter search shards based on query rewriting if the number of shards\n     * the search request expands to exceeds the threshold, or <code>null</code> if the threshold is unspecified.\n     * This filter roundtrip can limit the number of shards significantly if for\n     * instance a shard can not match any documents based on its rewrite method ie. if date filters are mandatory to match but the shard\n     * bounds and the query are disjoint.\n     *\n     * When unspecified, the pre-filter phase is executed if any of these conditions is met:\n     * <ul>\n     * <li>The request targets more than 128 shards</li>\n     * <li>The request targets one or more read-only index</li>\n     * <li>The primary sort of the query targets an indexed field</li>\n     * </ul>\n     */\n    @Nullable\n    public Integer getPreFilterShardSize() {\n        return preFilterShardSize;\n    }\n\n    /**\n     * @return true if the request only has suggest\n     */\n    public boolean isSuggestOnly() {\n        return source != null && source.isSuggestOnly();\n    }\n\n    /**\n     * @return true if the request contains kNN search\n     */\n    public boolean hasKnnSearch() {\n        return source != null && source.knnSearch().isEmpty() == false;\n    }\n\n    public int resolveTrackTotalHitsUpTo() {\n        return resolveTrackTotalHitsUpTo(scroll, source);\n    }\n\n    /**\n     * Should this request force {@link SourceLoader.Synthetic synthetic source}?\n     * Use this to test if the mapping supports synthetic _source and to get a sense\n     * of the worst case performance. Fetches with this enabled will be slower the\n     * enabling synthetic source natively in the index.\n     */\n    public boolean isForceSyntheticSource() {\n        return forceSyntheticSource;\n    }\n\n    /**\n     * Should this request force {@link SourceLoader.Synthetic synthetic source}?\n     * Use this to test if the mapping supports synthetic _source and to get a sense\n     * of the worst case performance. Fetches with this enabled will be slower the\n     * enabling synthetic source natively in the index.\n     */\n    public void setForceSyntheticSource(boolean forceSyntheticSource) {\n        this.forceSyntheticSource = forceSyntheticSource;\n    }\n\n    @Override\n    public SearchRequest rewrite(QueryRewriteContext ctx) throws IOException {\n        if (source == null) {\n            return this;\n        }\n\n        SearchSourceBuilder source = this.source.rewrite(ctx);\n        boolean hasChanged = source != this.source;\n\n        // add a sort tiebreaker for PIT search requests if not explicitly set\n        Object[] searchAfter = source.searchAfter();\n        if (source.pointInTimeBuilder() != null && source.sorts() != null && source.sorts().isEmpty() == false\n        // skip the tiebreaker if it is not provided in the search after values\n            && (searchAfter == null || searchAfter.length == source.sorts().size() + 1)) {\n            SortBuilder<?> lastSort = source.sorts().get(source.sorts().size() - 1);\n            if (lastSort instanceof FieldSortBuilder == false\n                || FieldSortBuilder.SHARD_DOC_FIELD_NAME.equals(((FieldSortBuilder) lastSort).getFieldName()) == false) {\n                List<SortBuilder<?>> newSorts = new ArrayList<>(source.sorts());\n                newSorts.add(SortBuilders.pitTiebreaker().unmappedType(\"long\"));\n                source = source.shallowCopy().sort(newSorts);\n                hasChanged = true;\n            }\n        }\n\n        return hasChanged ? new SearchRequest(this).source(source) : this;\n    }\n\n    public static int resolveTrackTotalHitsUpTo(Scroll scroll, SearchSourceBuilder source) {\n        if (scroll != null) {\n            // no matter what the value of track_total_hits is\n            return SearchContext.TRACK_TOTAL_HITS_ACCURATE;\n        }\n        return source == null ? SearchContext.DEFAULT_TRACK_TOTAL_HITS_UP_TO\n            : source.trackTotalHitsUpTo() == null ? SearchContext.DEFAULT_TRACK_TOTAL_HITS_UP_TO\n            : source.trackTotalHitsUpTo();\n    }\n\n    @Override\n    public SearchTask createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {\n        return new SearchTask(id, type, action, this::buildDescription, parentTaskId, headers);\n    }\n\n    public final String buildDescription() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"indices[\");\n        Strings.arrayToDelimitedString(indices, \",\", sb);\n        sb.append(\"]\");\n        sb.append(\", search_type[\").append(searchType).append(\"]\");\n        if (scroll != null) {\n            sb.append(\", scroll[\").append(scroll.keepAlive()).append(\"]\");\n        }\n        if (source != null) {\n            sb.append(\", source[\").append(source.toString(FORMAT_PARAMS)).append(\"]\");\n        } else {\n            sb.append(\", source[]\");\n        }\n        if (routing != null) {\n            sb.append(\", routing[\").append(routing).append(\"]\");\n        }\n        if (preference != null) {\n            sb.append(\", preference[\").append(preference).append(\"]\");\n        }\n        return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        SearchRequest that = (SearchRequest) o;\n        return searchType == that.searchType\n            && Arrays.equals(indices, that.indices)\n            && Objects.equals(routing, that.routing)\n            && Objects.equals(preference, that.preference)\n            && Objects.equals(source, that.source)\n            && Objects.equals(requestCache, that.requestCache)\n            && Objects.equals(scroll, that.scroll)\n            && Objects.equals(batchedReduceSize, that.batchedReduceSize)\n            && Objects.equals(maxConcurrentShardRequests, that.maxConcurrentShardRequests)\n            && Objects.equals(preFilterShardSize, that.preFilterShardSize)\n            && Objects.equals(indicesOptions, that.indicesOptions)\n            && Objects.equals(allowPartialSearchResults, that.allowPartialSearchResults)\n            && Objects.equals(localClusterAlias, that.localClusterAlias)\n            && absoluteStartMillis == that.absoluteStartMillis\n            && ccsMinimizeRoundtrips == that.ccsMinimizeRoundtrips\n            && Objects.equals(minCompatibleShardNode, that.minCompatibleShardNode)\n            && forceSyntheticSource == that.forceSyntheticSource;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(\n            searchType,\n            Arrays.hashCode(indices),\n            routing,\n            preference,\n            source,\n            requestCache,\n            scroll,\n            indicesOptions,\n            batchedReduceSize,\n            maxConcurrentShardRequests,\n            preFilterShardSize,\n            allowPartialSearchResults,\n            localClusterAlias,\n            absoluteStartMillis,\n            ccsMinimizeRoundtrips,\n            minCompatibleShardNode,\n            forceSyntheticSource\n        );\n    }\n\n    @Override\n    public String toString() {\n        return \"SearchRequest{\"\n            + \"searchType=\"\n            + searchType\n            + \", indices=\"\n            + Arrays.toString(indices)\n            + \", indicesOptions=\"\n            + indicesOptions\n            + \", routing='\"\n            + routing\n            + '\\''\n            + \", preference='\"\n            + preference\n            + '\\''\n            + \", requestCache=\"\n            + requestCache\n            + \", scroll=\"\n            + scroll\n            + \", maxConcurrentShardRequests=\"\n            + maxConcurrentShardRequests\n            + \", batchedReduceSize=\"\n            + batchedReduceSize\n            + \", preFilterShardSize=\"\n            + preFilterShardSize\n            + \", allowPartialSearchResults=\"\n            + allowPartialSearchResults\n            + \", localClusterAlias=\"\n            + localClusterAlias\n            + \", getOrCreateAbsoluteStartMillis=\"\n            + absoluteStartMillis\n            + \", ccsMinimizeRoundtrips=\"\n            + ccsMinimizeRoundtrips\n            + \", source=\"\n            + source\n            + '}';\n    }\n}",
                "methodCount": 65
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 6,
                "candidates": [
                    {
                        "lineStart": 884,
                        "lineEnd": 892,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "refactoringInfo": "Move Static method resolveTrackTotalHitsUpTo to class SearchPhaseController",
                        "description": "move method resolveTrackTotalHitsUpTo to PsiClass:SearchPhaseController\nRationale: The `resolveTrackTotalHitsUpTo` method involves the `Scroll` and `SearchSourceBuilder` classes and makes extensive use of search-related constants from `SearchContext`. It is primarily concerned with determining total hits tracking for a search phase, closely aligning it with the responsibilities of the `SearchPhaseController` class. This class handles various aspects of the search phase, including aggregations and rankings, making it the most appropriate place for this method. Keeping the method in `SearchPhaseController` ensures that search-related logic remains encapsulated within a class dedicated to such tasks, leading to better cohesion and maintainability.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 445,
                        "lineEnd": 492,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method validate to class SearchSourceBuilder",
                        "description": "Move method validate to org.elasticsearch.search.builder.SearchSourceBuilder\nRationale: The 'validate' method is intricately linked to the state and functionality of the 'SearchSourceBuilder' class. The method uses several properties of 'source' to perform validation checks specific to search source configurations, such as rank, size, sub searches, and other query components. Therefore, it would be logical to move the 'validate' method to the 'SearchSourceBuilder' class, where it will have direct access to these properties and maintain relevant validation logic closely tied to the search source configurations it checks.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 899,
                        "lineEnd": 920,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method buildDescription to class Params",
                        "description": "Move method buildDescription to org.elasticsearch.xcontent.ToXContent.Params\nRationale: The buildDescription() method is used to construct a descriptive string likely involving parameters that would naturally align with the Params interface's responsibilities. The Params interface seems designed to handle parameter retrieval and holding key-value pairs which are relevant to building a complex string description. Moving the method to Params better encapsulates functionality related to parameter processing and description building, enhancing cohesion and reducing the scattering of related functionalities across multiple classes.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 653,
                        "lineEnd": 658,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method pointInTimeBuilder to class SearchSourceBuilder",
                        "description": "Move method pointInTimeBuilder to org.elasticsearch.search.builder.SearchSourceBuilder\nRationale: The method 'pointInTimeBuilder()' interacts directly with the 'pointInTimeBuilder' field, which is already present in the 'SearchSourceBuilder' class. This method checks the existence of a 'source' object and delegates the call to its 'pointInTimeBuilder()' method. Given that 'SearchSourceBuilder' already handles an internal 'pointInTimeBuilder' field, it makes sense for this method to be part of the same class, ensuring encapsulation and cohesion within the class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 819,
                        "lineEnd": 824,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method isSuggestOnly to class SearchSourceBuilder",
                        "description": "Move method isSuggestOnly to org.elasticsearch.search.builder.SearchSourceBuilder\nRationale: The method isSuggestOnly() directly interacts with members and fields of the SearchSourceBuilder class, such as suggestBuilder, query(), knnSearch, and aggregations. This indicates a strong cohesion with SearchSourceBuilder. Keeping the method within the same class will help maintain encapsulation and ensure easier maintenance of the related functionality. Moreover, SearchSourceBuilder is the class containing the relevant context for determining if the source has only suggest, making it the natural home for the method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    },
                    {
                        "lineStart": 826,
                        "lineEnd": 831,
                        "refactoringType": "MyMoveInstanceMethodRefactoring",
                        "refactoringInfo": "Move method hasKnnSearch to class SearchSourceBuilder",
                        "description": "Move method hasKnnSearch to org.elasticsearch.search.builder.SearchSourceBuilder\nRationale: The `hasKnnSearch()` method relies on the `knnSearch()` method from the `SearchSourceBuilder` class, which directly deals with the kNN search functionality. By moving the method to `SearchSourceBuilder`, you keep related functionalities together, ensuring easier maintenance and improved cohesion. Additionally, the `SearchSourceBuilder` has context and state related to search sources, making it the most suitable target class for this method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "startedRefactoringFlow": false,
                        "undone": false
                    }
                ]
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "searchType",
                            "method_signature": "public SearchRequest searchType(SearchType searchType)",
                            "target_class": "SearchSourceBuilder",
                            "rationale": "The setting of searchType should be a part of the SearchSourceBuilder because it is more related to how the search operation is built and executed."
                        },
                        {
                            "method_name": "searchType",
                            "method_signature": "public SearchRequest searchType(String searchType)",
                            "target_class": "SearchSourceBuilder",
                            "rationale": "Similarly, this method belongs to SearchSourceBuilder as it sets the type of search operation to be executed, which is a configuration detail tied to the search logic."
                        }
                    ],
                    "llm_response_time": 4583
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "resolveTrackTotalHitsUpTo",
                            "method_signature": "public static int resolveTrackTotalHitsUpTo(Scroll scroll, SearchSourceBuilder source): int",
                            "target_class": "SearchSourceBuilder",
                            "rationale": "The method `resolveTrackTotalHitsUpTo` operates directly on the `SearchSourceBuilder` and utilizes its fields. Therefore, it is more appropriate to reside in `SearchSourceBuilder`."
                        },
                        {
                            "method_name": "validate",
                            "method_signature": "private static void validateIndices(String... indices)",
                            "target_class": "IndicesOptions",
                            "rationale": "The method `validateIndices` is directly related to the validation of indices, which is part of `IndicesOptions` functionality. Moving it to `IndicesOptions` will keep the validation logic encapsulated within the appropriate class."
                        }
                    ],
                    "llm_response_time": 3793
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "resolveTrackTotalHitsUpTo",
                            "method_signature": "public static int resolveTrackTotalHitsUpTo(Scroll scroll, SearchSourceBuilder source): int",
                            "target_class": "SearchSourceBuilder",
                            "rationale": "'resolveTrackTotalHitsUpTo' operates on 'SearchSourceBuilder' and can be more appropriately placed in that class to maintain single responsibility."
                        },
                        {
                            "method_name": "validateIndices",
                            "method_signature": "private static void validateIndices(String... indices)",
                            "target_class": "IndicesOptions",
                            "rationale": "'validateIndices' is concerned with indices validation, which is more relevant to 'IndicesOptions' class, making it a better place for this functionality."
                        }
                    ],
                    "llm_response_time": 3401
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "validate",
                            "method_signature": "private validate(ActionRequestValidationException validationException, boolean scroll)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "pointInTimeBuilder",
                            "method_signature": "public pointInTimeBuilder()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isSuggestOnly",
                            "method_signature": "public isSuggestOnly()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "hasKnnSearch",
                            "method_signature": "public hasKnnSearch()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "resolveTrackTotalHitsUpTo",
                            "method_signature": "public static resolveTrackTotalHitsUpTo(Scroll scroll, SearchSourceBuilder source)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "buildDescription",
                            "method_signature": "public final buildDescription()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                },
                {
                    "iteration_num": -2,
                    "suggested_move_methods": [
                        {
                            "method_name": "resolveTrackTotalHitsUpTo",
                            "method_signature": "public static resolveTrackTotalHitsUpTo(Scroll scroll, SearchSourceBuilder source)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "validate",
                            "method_signature": "private validate(ActionRequestValidationException validationException, boolean scroll)",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "buildDescription",
                            "method_signature": "public final buildDescription()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "pointInTimeBuilder",
                            "method_signature": "public pointInTimeBuilder()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "isSuggestOnly",
                            "method_signature": "public isSuggestOnly()",
                            "target_class": "",
                            "rationale": ""
                        },
                        {
                            "method_name": "hasKnnSearch",
                            "method_signature": "public hasKnnSearch()",
                            "target_class": "",
                            "rationale": ""
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "methodCompatibilityScores": {
                "tf-idf": {
                    "public static resolveTrackTotalHitsUpTo(Scroll scroll, SearchSourceBuilder source)": {
                        "first": {
                            "method_name": "resolveTrackTotalHitsUpTo",
                            "method_signature": "public static resolveTrackTotalHitsUpTo(Scroll scroll, SearchSourceBuilder source)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.44472568760489944
                    },
                    "private validate(ActionRequestValidationException validationException, boolean scroll)": {
                        "first": {
                            "method_name": "validate",
                            "method_signature": "private validate(ActionRequestValidationException validationException, boolean scroll)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.4991435399153726
                    },
                    "public final buildDescription()": {
                        "first": {
                            "method_name": "buildDescription",
                            "method_signature": "public final buildDescription()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5068887265467392
                    },
                    "public pointInTimeBuilder()": {
                        "first": {
                            "method_name": "pointInTimeBuilder",
                            "method_signature": "public pointInTimeBuilder()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5225095700603068
                    },
                    "public isSuggestOnly()": {
                        "first": {
                            "method_name": "isSuggestOnly",
                            "method_signature": "public isSuggestOnly()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5474127800832513
                    },
                    "public hasKnnSearch()": {
                        "first": {
                            "method_name": "hasKnnSearch",
                            "method_signature": "public hasKnnSearch()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.5714679109672199
                    }
                },
                "voyage": {
                    "public pointInTimeBuilder()": {
                        "first": {
                            "method_name": "pointInTimeBuilder",
                            "method_signature": "public pointInTimeBuilder()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.14951269200995881
                    },
                    "public final buildDescription()": {
                        "first": {
                            "method_name": "buildDescription",
                            "method_signature": "public final buildDescription()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.3356445796097322
                    },
                    "public static resolveTrackTotalHitsUpTo(Scroll scroll, SearchSourceBuilder source)": {
                        "first": {
                            "method_name": "resolveTrackTotalHitsUpTo",
                            "method_signature": "public static resolveTrackTotalHitsUpTo(Scroll scroll, SearchSourceBuilder source)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.33728093593494335
                    },
                    "public isSuggestOnly()": {
                        "first": {
                            "method_name": "isSuggestOnly",
                            "method_signature": "public isSuggestOnly()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.35518937656548966
                    },
                    "public hasKnnSearch()": {
                        "first": {
                            "method_name": "hasKnnSearch",
                            "method_signature": "public hasKnnSearch()",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.37195439588764734
                    },
                    "private validate(ActionRequestValidationException validationException, boolean scroll)": {
                        "first": {
                            "method_name": "validate",
                            "method_signature": "private validate(ActionRequestValidationException validationException, boolean scroll)",
                            "target_class": "",
                            "rationale": ""
                        },
                        "second": 0.37470634150717086
                    }
                }
            },
            "llmMethodPriority": {
                "tf-idf": {
                    "priority_method_names": [
                        "private validate(ActionRequestValidationException validationException, boolean scroll)",
                        "public final buildDescription()",
                        "public static resolveTrackTotalHitsUpTo(Scroll scroll, SearchSourceBuilder source)",
                        "public pointInTimeBuilder()",
                        "public isSuggestOnly()",
                        "public hasKnnSearch()"
                    ],
                    "llm_response_time": 7408
                },
                "tf-idf-5": {
                    "priority_method_names": [
                        "private validate(ActionRequestValidationException validationException, boolean scroll)",
                        "public final buildDescription()",
                        "public static resolveTrackTotalHitsUpTo(Scroll scroll, SearchSourceBuilder source)",
                        "public pointInTimeBuilder()",
                        "public isSuggestOnly()"
                    ],
                    "llm_response_time": 4509
                },
                "tf-df-3": {
                    "priority_method_names": [
                        "public static resolveTrackTotalHitsUpTo(Scroll scroll, SearchSourceBuilder source)",
                        "private validate(ActionRequestValidationException validationException, boolean scroll)",
                        "public final buildDescription()"
                    ],
                    "llm_response_time": 4558
                },
                "voyage": {
                    "priority_method_names": [],
                    "llm_response_time": 5534
                },
                "voyage-5": {
                    "priority_method_names": [
                        "public static resolveTrackTotalHitsUpTo(Scroll scroll, SearchSourceBuilder source)",
                        "public pointInTimeBuilder()",
                        "public isSuggestOnly()",
                        "public hasKnnSearch()",
                        "public final buildDescription()"
                    ],
                    "llm_response_time": 1974
                },
                "voyage-3": {
                    "priority_method_names": [
                        "public static resolveTrackTotalHitsUpTo(Scroll scroll, SearchSourceBuilder source)",
                        "public pointInTimeBuilder()",
                        "public final buildDescription()"
                    ],
                    "llm_response_time": 4036
                }
            },
            "targetClassMap": {
                "resolveTrackTotalHitsUpTo": {
                    "target_classes": [
                        {
                            "class_name": "DataStreamsActionUtil",
                            "similarity_score": 0.33442220851236554
                        },
                        {
                            "class_name": "RestUtils",
                            "similarity_score": 0.4114529951750017
                        },
                        {
                            "class_name": "LocaleUtils",
                            "similarity_score": 0.3764225965141416
                        },
                        {
                            "class_name": "DateUtils",
                            "similarity_score": 0.3150535090988054
                        },
                        {
                            "class_name": "CollectionUtils",
                            "similarity_score": 0.4962147898645087
                        },
                        {
                            "class_name": "ScoreScriptUtils",
                            "similarity_score": 0.26334002624828345
                        },
                        {
                            "class_name": "PolicyUtil",
                            "similarity_score": 0.3817068062201059
                        },
                        {
                            "class_name": "SnapshotUtils",
                            "similarity_score": 0.46406120518817584
                        },
                        {
                            "class_name": "FutureUtils",
                            "similarity_score": 0.37600256883394134
                        },
                        {
                            "class_name": "IpPrefixAutomatonUtil",
                            "similarity_score": 0.4103399230125438
                        },
                        {
                            "class_name": "HttpUtils",
                            "similarity_score": 0.3723343557930697
                        },
                        {
                            "class_name": "ForUtil",
                            "similarity_score": 0.09691517173900695
                        },
                        {
                            "class_name": "GeoUtils",
                            "similarity_score": 0.36971289873464513
                        },
                        {
                            "class_name": "ConfigurationUtils",
                            "similarity_score": 0.43057374011287236
                        },
                        {
                            "class_name": "GeoTileUtils",
                            "similarity_score": 0.3624711932548902
                        },
                        {
                            "class_name": "LuceneGeometriesUtils",
                            "similarity_score": 0.48651983899248735
                        },
                        {
                            "class_name": "DiffableUtils",
                            "similarity_score": 0.4277098934599937
                        },
                        {
                            "class_name": "PluginsUtils",
                            "similarity_score": 0.3633355694255316
                        },
                        {
                            "class_name": "FileSystemUtils",
                            "similarity_score": 0.47748564508227526
                        },
                        {
                            "class_name": "XContentParserUtils",
                            "similarity_score": 0.3330520496349075
                        },
                        {
                            "class_name": "ArrayUtils",
                            "similarity_score": 0.35457361026192125
                        },
                        {
                            "class_name": "CIDRUtils",
                            "similarity_score": 0.39890586348690144
                        },
                        {
                            "class_name": "ESVectorUtil",
                            "similarity_score": 0.31702489688892305
                        },
                        {
                            "class_name": "SphericalMercatorUtils",
                            "similarity_score": 0.2369593480332035
                        },
                        {
                            "class_name": "BlobContainerUtils",
                            "similarity_score": 0.3663443349998194
                        },
                        {
                            "class_name": "SearchUtils",
                            "similarity_score": 0.36141017300350825
                        },
                        {
                            "class_name": "ShardUtils",
                            "similarity_score": 0.3812887628112561
                        },
                        {
                            "class_name": "FilePermissionUtils",
                            "similarity_score": 0.25546722449989834
                        },
                        {
                            "class_name": "LevelUtil",
                            "similarity_score": 0.1510918057547588
                        },
                        {
                            "class_name": "BootstrapUtil",
                            "similarity_score": 0.35612680143636855
                        },
                        {
                            "class_name": "CloseUtils",
                            "similarity_score": 0.37060591577531193
                        },
                        {
                            "class_name": "BucketUtils",
                            "similarity_score": 0.24452695059430307
                        },
                        {
                            "class_name": "NestedUtils",
                            "similarity_score": 0.3796104883002142
                        },
                        {
                            "class_name": "SpanQueryBuilderUtil",
                            "similarity_score": 0.2549845039692367
                        },
                        {
                            "class_name": "HighlightUtils",
                            "similarity_score": 0.3721936841593883
                        },
                        {
                            "class_name": "DocValuesForUtil",
                            "similarity_score": 0.37083935631929893
                        },
                        {
                            "class_name": "StringSetValueSerializer",
                            "similarity_score": 0.3360300866280081
                        },
                        {
                            "class_name": "MapDiff",
                            "similarity_score": 0.3699582664369686
                        },
                        {
                            "class_name": "DiffableValueReader",
                            "similarity_score": 0.3199465378452514
                        },
                        {
                            "class_name": "L1Norm",
                            "similarity_score": 0.31026113868389327
                        },
                        {
                            "class_name": "L2Norm",
                            "similarity_score": 0.31026113868389327
                        },
                        {
                            "class_name": "DotProduct",
                            "similarity_score": 0.31026113868389327
                        },
                        {
                            "class_name": "DecayDateExp",
                            "similarity_score": 0.20532968306030328
                        },
                        {
                            "class_name": "DecayDateGauss",
                            "similarity_score": 0.19957162814315652
                        },
                        {
                            "class_name": "DecayDateLinear",
                            "similarity_score": 0.20658971994960434
                        },
                        {
                            "class_name": "DecayGeoExp",
                            "similarity_score": 0.16404358872971006
                        },
                        {
                            "class_name": "DecayGeoGauss",
                            "similarity_score": 0.159648764889992
                        },
                        {
                            "class_name": "DecayGeoLinear",
                            "similarity_score": 0.17005425596285895
                        },
                        {
                            "class_name": "DecayNumericExp",
                            "similarity_score": 0.1977186488236861
                        },
                        {
                            "class_name": "DecayNumericGauss",
                            "similarity_score": 0.19015970731391624
                        },
                        {
                            "class_name": "DecayNumericLinear",
                            "similarity_score": 0.18725633517970777
                        },
                        {
                            "class_name": "ByteCosineSimilarity",
                            "similarity_score": 0.3028413755610909
                        },
                        {
                            "class_name": "ByteDenseVectorFunction",
                            "similarity_score": 0.18555751005341534
                        },
                        {
                            "class_name": "ByteDotProduct",
                            "similarity_score": 0.30432227131435385
                        },
                        {
                            "class_name": "ByteHammingDistance",
                            "similarity_score": 0.31755367441497795
                        },
                        {
                            "class_name": "ByteL1Norm",
                            "similarity_score": 0.30432227131435385
                        },
                        {
                            "class_name": "ByteL2Norm",
                            "similarity_score": 0.30432227131435385
                        },
                        {
                            "class_name": "DenseVectorFunction",
                            "similarity_score": 0.33230320517272655
                        },
                        {
                            "class_name": "CosineSimilarity",
                            "similarity_score": 0.31026113868389327
                        },
                        {
                            "class_name": "RandomScoreDoc",
                            "similarity_score": 0.2827423483887312
                        },
                        {
                            "class_name": "RandomScoreField",
                            "similarity_score": 0.319297529779984
                        },
                        {
                            "class_name": "FloatL1Norm",
                            "similarity_score": 0.3368165348543039
                        },
                        {
                            "class_name": "FloatL2Norm",
                            "similarity_score": 0.3368165348543039
                        },
                        {
                            "class_name": "Hamming",
                            "similarity_score": 0.3450327796711771
                        },
                        {
                            "class_name": "FloatDotProduct",
                            "similarity_score": 0.3368165348543039
                        },
                        {
                            "class_name": "FloatCosineSimilarity",
                            "similarity_score": 0.3335621924974956
                        },
                        {
                            "class_name": "FloatDenseVectorFunction",
                            "similarity_score": 0.2241053642501988
                        },
                        {
                            "class_name": "TransportSearchHelper",
                            "similarity_score": 0.39436531143593134
                        },
                        {
                            "class_name": "SearchPhaseController",
                            "similarity_score": 0.49202726453110074
                        },
                        {
                            "class_name": "ListenerTimeouts",
                            "similarity_score": 0.22908480468697273
                        },
                        {
                            "class_name": "ValidateActions",
                            "similarity_score": 0.42794805161809174
                        },
                        {
                            "class_name": "TransportActions",
                            "similarity_score": 0.24763401617197728
                        },
                        {
                            "class_name": "TransportSearchAction",
                            "similarity_score": 0.45993593779856234
                        },
                        {
                            "class_name": "QueryParserHelper",
                            "similarity_score": 0.36382404090544634
                        },
                        {
                            "class_name": "MapperErrors",
                            "similarity_score": 0.18610937511954945
                        },
                        {
                            "class_name": "MappingVisitor",
                            "similarity_score": 0.28576872303700784
                        },
                        {
                            "class_name": "Maps",
                            "similarity_score": 0.33660019668517144
                        },
                        {
                            "class_name": "TcpHeader",
                            "similarity_score": 0.312243326445399
                        },
                        {
                            "class_name": "RestTable",
                            "similarity_score": 0.5144474263346335
                        },
                        {
                            "class_name": "LogConfigurator",
                            "similarity_score": 0.3428527017340035
                        },
                        {
                            "class_name": "LoggerMessageFormat",
                            "similarity_score": 0.44214069638502546
                        },
                        {
                            "class_name": "ObjectParserHelper",
                            "similarity_score": 0.24114081645412283
                        },
                        {
                            "class_name": "MessageDigests",
                            "similarity_score": 0.2635627564924881
                        },
                        {
                            "class_name": "MacAddressProvider",
                            "similarity_score": 0.4726101712680076
                        },
                        {
                            "class_name": "UUIDs",
                            "similarity_score": 0.2712947065220114
                        },
                        {
                            "class_name": "MetricInspectionHelper",
                            "similarity_score": 0.44084091412866727
                        },
                        {
                            "class_name": "DataStreamFailureStoreDefinition",
                            "similarity_score": 0.23810384379169564
                        },
                        {
                            "class_name": "BucketHelpers",
                            "similarity_score": 0.4059452447446136
                        },
                        {
                            "class_name": "AutomatonQueries",
                            "similarity_score": 0.35724220300746506
                        },
                        {
                            "class_name": "ClusterNameExpressionResolver",
                            "similarity_score": 0.40730050755301694
                        },
                        {
                            "class_name": "DataTier",
                            "similarity_score": 0.4682682710765538
                        },
                        {
                            "class_name": "ClusterStateUpdaters",
                            "similarity_score": 0.38565554713453576
                        },
                        {
                            "class_name": "DateFormatters",
                            "similarity_score": 0.25988355163260857
                        },
                        {
                            "class_name": "AggregationInspectionHelper",
                            "similarity_score": 0.42476435469565976
                        },
                        {
                            "class_name": "ECSJsonLayout",
                            "similarity_score": 0.3682298471593293
                        },
                        {
                            "class_name": "ElasticsearchProcess",
                            "similarity_score": 0.36187343222787294
                        },
                        {
                            "class_name": "Parser",
                            "similarity_score": 0.39511112326764614
                        },
                        {
                            "class_name": "Elements",
                            "similarity_score": 0.46110550135503964
                        },
                        {
                            "class_name": "BytesRefs",
                            "similarity_score": 0.43744717265062855
                        },
                        {
                            "class_name": "ScoreFunctionBuilders",
                            "similarity_score": 0.3079802557948965
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SearchPhaseController",
                        "RestTable",
                        "CollectionUtils"
                    ],
                    "llm_response_time": 5717,
                    "similarity_computation_time": 85,
                    "similarity_metric": "cosine"
                },
                "validate": {
                    "target_classes": [
                        {
                            "class_name": "Params",
                            "similarity_score": 0.10310295920786355
                        },
                        {
                            "class_name": "SearchSourceBuilder",
                            "similarity_score": 0.6332991411255569
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SearchSourceBuilder",
                        "Params"
                    ],
                    "llm_response_time": 4877,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                },
                "buildDescription": {
                    "target_classes": [
                        {
                            "class_name": "Params",
                            "similarity_score": 0.14817389619254992
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Params"
                    ],
                    "llm_response_time": 2076,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                },
                "pointInTimeBuilder": {
                    "target_classes": [
                        {
                            "class_name": "Params",
                            "similarity_score": 0.11664236870396087
                        },
                        {
                            "class_name": "SearchSourceBuilder",
                            "similarity_score": 0.6415374070391345
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SearchSourceBuilder",
                        "Params"
                    ],
                    "llm_response_time": 5032,
                    "similarity_computation_time": 6,
                    "similarity_metric": "cosine"
                },
                "isSuggestOnly": {
                    "target_classes": [
                        {
                            "class_name": "Params",
                            "similarity_score": 0.1709408646894569
                        },
                        {
                            "class_name": "SearchSourceBuilder",
                            "similarity_score": 0.5336947340193908
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SearchSourceBuilder",
                        "Params"
                    ],
                    "llm_response_time": 5516,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                },
                "hasKnnSearch": {
                    "target_classes": [
                        {
                            "class_name": "Params",
                            "similarity_score": 0.1636634176769943
                        },
                        {
                            "class_name": "SearchSourceBuilder",
                            "similarity_score": 0.5379506835532735
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SearchSourceBuilder",
                        "Params"
                    ],
                    "llm_response_time": 5143,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                }
            }
        }
    }
]