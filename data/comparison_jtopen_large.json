[
    {
        "oracle": "method com.ibm.as400.access.FTPThread::readObject(java.io.ObjectInputStream):void need move com.ibm.as400.access.FTP",
        "class_name": "com.ibm.as400.access.FTPThread",
        "telemetry": {
            "id": "40b39bbd-5f3f-4e0d-be9b-20d4044673b8",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 214,
                "lineStart": 20,
                "lineEnd": 233,
                "bodyLineStart": 20,
                "language": "java",
                "sourceCode": "class FTPThread implements Runnable\n{\n  private FTP ftp_;\n  \n  private int port_;\n  private Socket socket_;\n  private boolean running_ = false;\n  private final Object runLock_ = new Object();\n\n  private InetAddress localAddress_;\n\n  FTPThread(FTP ftp)\n  {\n    ftp_ = ftp;\n  }\n\n  // This must be called before the thread is started.\n  public void setLocalAddress(InetAddress localAddress)\n  {\n    localAddress_ = localAddress;\n    if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"FTP thread's local address set to: \"+localAddress_.toString());\n  }\n\n  public void waitUntilStarted()\n  {\n    try\n    {\n      while (!running_)\n      {\n        synchronized (runLock_)\n        {\n          if (!running_) runLock_.wait();\n        }\n      }\n    }\n    catch (Exception e)\n    {\n      Trace.log(Trace.ERROR, \"Error while waiting for FTP thread to start.\", e);\n    }\n  }\n\n  public int getLocalPort()\n  {\n    return port_;\n  }\n\n  public Socket getSocket()\n  {\n    if (socket_ == null)\n    {\n      try\n      {\n        synchronized(this)\n        {\n          if (socket_ == null) wait(60000); // Wait 60 seconds to prevent hanging.\n        }\n      }\n      catch (Exception e)\n      {\n        Trace.log(Trace.ERROR, \"Error while getting socket from FTP thread.\", e);\n        return null;\n      }\n    }\n    Socket s = socket_;\n    socket_ = null;\n    if (Trace.traceOn_)\n    {\n      Trace.log(Trace.DIAGNOSTIC, \"FTP thread returned previously accepted socket.\");\n      if (s == null) Trace.log(Trace.DIAGNOSTIC, \"FTPThread.getSocket() is returning null.\");\n    }\n    return s;\n  }\n\n  public void issuePortCommand() throws IOException\n  {\n      String addr = localAddress_.getHostAddress();\n      // Try the extended port command.\n      String response = ftp_.issueCommand(\"EPRT |\" + (addr.indexOf(':') == -1 ? \"1\" : \"2\") + \"|\" + addr + \"|\" + port_ + \"|\");\n      if (response.startsWith(\"200\")) return;\n\n      // System may not support EPRT, fallback to the port command.\n    StringTokenizer st = new StringTokenizer(addr, \".\");\n    StringBuffer cmd = new StringBuffer(\"PORT \");\n    while (st.hasMoreTokens())\n    {\n      cmd.append(st.nextToken());\n      cmd.append(\",\");\n    }\n    cmd.append(port_/256);\n    cmd.append(\",\");\n    cmd.append(port_ % 256);\n    response = ftp_.issueCommand(cmd.toString());\n    // A \"successful\" response will begin with 200.\n    if (!response.startsWith(\"200\"))\n    {\n      Trace.log(Trace.ERROR, \"Unexpected response to \" + cmd + \": \" + response);\n    }\n  }\n\n  public void run()\n  {\n    ServerSocket ss = null;\n    try\n    {\n      if (ftp_.isReuseSocket())\n      {\n        if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"FTP thread will reuse socket if multiple transfers.\");\n        ss = new ServerSocket(0, 50, localAddress_);\n        port_ = ss.getLocalPort();\n        while (true)\n        {\n          if (Trace.traceOn_)\n          {\n            Trace.log(Trace.DIAGNOSTIC, \"FTP thread waiting for new active mode socket.\");\n          }\n          if (!running_)\n          {\n            running_ = true;\n            synchronized (runLock_)\n            {\n              runLock_.notifyAll();\n            }\n          }\n          socket_ = ss.accept();\n          if (Trace.traceOn_)\n          {\n            Trace.log(Trace.DIAGNOSTIC, \"FTP thread accepted active mode socket: \"+socket_);\n          }\n          synchronized (this)\n          {\n            notifyAll();\n          }\n        }\n      }\n      else  // don't reuse socket\n      {\n        if (Trace.traceOn_) Trace.log(Trace.DIAGNOSTIC, \"FTP thread create new socket if multiple transfers.\");\n        while (true)\n        {\n          if (ss == null)\n          {\n            ss = new ServerSocket(0, 1, localAddress_);\n            port_ = ss.getLocalPort();\n          }\n          if (!running_)\n          {\n            running_ = true;\n            synchronized (runLock_)\n            {\n              runLock_.notifyAll();\n            }\n          }\n          if (Trace.traceOn_)\n          {\n            Trace.log(Trace.DIAGNOSTIC, \"FTP thread waiting for new active mode socket.\");\n          }\n          socket_ = ss.accept();\n          if (Trace.traceOn_)\n          {\n            Trace.log(Trace.DIAGNOSTIC, \"FTP thread accepted active mode socket: \"+socket_);\n          }\n          synchronized (this)\n          {\n            notifyAll();\n          }\n          // Get a new server socket each time to avoid bug on AIX.\n          // We create the server socket with only 1 connection in the backlog\n          // so any other incoming requests will have to wait until we can get them\n          // a new server socket.  This bottlenecks a multi-threaded client that is\n          // sharing an FTP object across threads, but they shouldn't be doing that anyway.\n          ss.close();\n          ss = null;\n        }\n      }\n    }\n    catch (Throwable e)\n    {\n      Trace.log(Trace.ERROR, \"Exception in FTP thread.\", e);\n    }\n    finally\n    {\n      if (socket_ != null) {\n        try { socket_.close(); }\n        catch (Throwable e) { Trace.log(Trace.ERROR, e); }\n      }\n      if (ss != null) {\n        try { ss.close(); }\n        catch (Throwable e) { Trace.log(Trace.ERROR, e); }\n      }\n    }\n  }\n\n/**\n    * During object deserialization, this method is called.  When it is called\n    * we need to initialize transient data.\n * @param ftp TODO\n * @param in TODO\n   **/\n\n    void readObject2(FTP ftp, ObjectInputStream in)\n        throws IOException, ClassNotFoundException\n    {\n        in.defaultReadObject();\n\n        ftp.connectionState_     = FTP.PARKED;\n        ftp.inConnect_           = false;\n        ftp.lastMessage_         = \"\";\n        ftp.changes_             = null;\n        ftp.vetos_               = null;\n        ftp.listeners_           = null;\n        ftp.listenerLock_        = new Object();\n        ftp.externallyConnected_ = false;                              // @D2a\n    }\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 211,
                        "lineEnd": 231,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to com.ibm.as400.access.FTP\nRationale: The method readObject2 directly manipulates the internal state of the FTP class, initializing its transient fields during deserialization, making it logical for this method to reside within the FTP class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 9073
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "issuePortCommand",
                            "method_signature": "public void issuePortCommand() throws IOException",
                            "target_class": "FTP",
                            "rationale": "The issuePortCommand() method directly interacts with the FTP class to issue commands and handle responses. It would be more appropriate for this method to reside within the FTP class, where it can manage its own command issuing logic."
                        },
                        {
                            "method_name": "getSocket",
                            "method_signature": "public Socket getSocket()",
                            "target_class": "SocketManager",
                            "rationale": "The getSocket() method is responsible for managing socket connections and should be moved to a dedicated SocketManager class that handles socket lifecycle and management, separating concerns from the FTPThread class."
                        },
                        {
                            "method_name": "waitUntilStarted",
                            "method_signature": "public void waitUntilStarted()",
                            "target_class": "ThreadManager",
                            "rationale": "The waitUntilStarted() method is related to thread management and synchronization. It would be better suited in a ThreadManager class that handles thread states and synchronization logic."
                        }
                    ],
                    "llm_response_time": 2539
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "issuePortCommand",
                            "method_signature": "public void issuePortCommand() throws IOException",
                            "target_class": "FTP",
                            "rationale": "The issuePortCommand method is primarily concerned with issuing commands to the FTP server and manipulating FTP-specific data. It should be moved to the FTP class to encapsulate FTP command logic within the FTP class."
                        },
                        {
                            "method_name": "getSocket",
                            "method_signature": "public Socket getSocket()",
                            "target_class": "SocketManager",
                            "rationale": "The getSocket method is responsible for managing socket connections and should be moved to a dedicated SocketManager class to separate socket management logic from the FTPThread class."
                        },
                        {
                            "method_name": "waitUntilStarted",
                            "method_signature": "public void waitUntilStarted()",
                            "target_class": "ThreadManager",
                            "rationale": "The waitUntilStarted method is related to thread management and synchronization. It should be moved to a ThreadManager class to better encapsulate thread-related functionality."
                        },
                        {
                            "method_name": "setLocalAddress",
                            "method_signature": "public void setLocalAddress(InetAddress localAddress)",
                            "target_class": "NetworkConfiguration",
                            "rationale": "The setLocalAddress method is responsible for configuring network settings. It should be moved to a NetworkConfiguration class to separate network configuration logic from the FTPThread class."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(FTP ftp, ObjectInputStream in) throws IOException, ClassNotFoundException",
                            "target_class": "FTP",
                            "rationale": "The readObject2 method is related to the deserialization of FTP objects and should be moved to the FTP class to keep serialization logic within the FTP context."
                        }
                    ],
                    "llm_response_time": 3384
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "issuePortCommand",
                            "method_signature": "public void issuePortCommand() throws IOException",
                            "target_class": "FTP",
                            "rationale": "The issuePortCommand() method directly interacts with the FTP instance to issue commands and handle responses. It should be moved to the FTP class to encapsulate FTP command handling logic."
                        },
                        {
                            "method_name": "getSocket",
                            "method_signature": "public Socket getSocket()",
                            "target_class": "SocketManager",
                            "rationale": "The getSocket() method is responsible for managing socket connections and should be moved to a dedicated SocketManager class to separate concerns related to socket handling from the FTPThread class."
                        },
                        {
                            "method_name": "waitUntilStarted",
                            "method_signature": "public void waitUntilStarted()",
                            "target_class": "ThreadManager",
                            "rationale": "The waitUntilStarted() method is related to thread management and synchronization. It should be moved to a ThreadManager class to better organize thread-related functionality."
                        }
                    ],
                    "llm_response_time": 2450
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "issuePortCommand",
                            "method_signature": "public void issuePortCommand() throws IOException",
                            "target_class": "FTP",
                            "rationale": "The issuePortCommand() method directly interacts with the FTP class to issue commands and handle responses. It would be more appropriate for this method to reside within the FTP class, where it can manage its own command issuing logic."
                        },
                        {
                            "method_name": "getSocket",
                            "method_signature": "public Socket getSocket()",
                            "target_class": "SocketManager",
                            "rationale": "The getSocket() method is responsible for managing socket connections and should be moved to a dedicated SocketManager class that handles socket lifecycle and management, separating concerns from the FTPThread class."
                        },
                        {
                            "method_name": "waitUntilStarted",
                            "method_signature": "public void waitUntilStarted()",
                            "target_class": "ThreadManager",
                            "rationale": "The waitUntilStarted() method is related to thread management and synchronization. It would be better suited in a ThreadManager class that handles thread states and synchronization logic."
                        },
                        {
                            "method_name": "setLocalAddress",
                            "method_signature": "public void setLocalAddress(InetAddress localAddress)",
                            "target_class": "NetworkConfiguration",
                            "rationale": "The setLocalAddress method is responsible for configuring network settings. It should be moved to a NetworkConfiguration class to separate network configuration logic from the FTPThread class."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(FTP ftp, ObjectInputStream in) throws IOException, ClassNotFoundException",
                            "target_class": "FTP",
                            "rationale": "The readObject2 method is related to the deserialization of FTP objects and should be moved to the FTP class to keep serialization logic within the FTP context."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "issuePortCommand",
                    "setLocalAddress",
                    "waitUntilStarted",
                    "getSocket",
                    "readObject2"
                ],
                "llm_response_time": 619
            },
            "targetClassMap": {
                "issuePortCommand": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1283,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "setLocalAddress": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1145,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "waitUntilStarted": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1185,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "getSocket": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1450,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "readObject2": {
                    "target_classes": [
                        {
                            "class_name": "FTP",
                            "similarity_score": 0.44652579790737035
                        },
                        {
                            "class_name": "FTP",
                            "similarity_score": 0.44652579790737035
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "FTP",
                        "FTP"
                    ],
                    "llm_response_time": 804,
                    "similarity_computation_time": 5,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.vaccess.SQLMetaDataTableModel::readObject(java.io.ObjectInputStream):void need move com.ibm.as400.vaccess.SQLMetaDataTablePane",
        "class_name": "com.ibm.as400.vaccess.SQLMetaDataTableModel",
        "telemetry": {
            "id": "4039dbcb-f6a7-4615-834c-a27ece279e01",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 545,
                "lineStart": 34,
                "lineEnd": 578,
                "bodyLineStart": 34,
                "language": "java",
                "sourceCode": "/**\nThe SQLMetaDataTableModel class represents the meta data\nabout the columns of a set of database files.  This model\nis used to create a SQLMetaDataTablePane.\nThe rows of this table are the fields of the database files,\nand the columns are the field attributes (field name, length, etc).\nRows can be removed from the table so the table only shows a subset\nof the available database fields.\nThis class is used by SQLQueryBuilderPane and its coworkers.\n\n<p>The data in the model is retrieved from the system only\nwhen <i>load()</i> is called.\n\n<p>SQLMetaDataTableModel objects generate the following events:\n<ul>\n  <li>ErrorEvent\n  <li>TableModelEvent\n  <li>WorkingEvent\n</ul>\n**/\nclass SQLMetaDataTableModel\nextends AbstractTableModel\nimplements Cloneable\n{\n  private static final String copyright = \"Copyright (C) 1997-2000 International Business Machines Corporation and others.\";\n\n\n// Note that none of the JDBC resources are ever explicitly closed,\n// but rather garbage collection is relied upon to close them.\n\n// This class is not meant to be serialized, it should be transient.\n// This class has items marked transient even though it is not\n// serializable because otherwise errors were received when\n// serializing objects that contained this class (even though they\n// were transient instances.  readObject() was added to be safe.\n\n// Number of columns in model.\nstatic private int NUM_COLUMNS_ = 6;\n\n// The columns of the table contains these meta data.\npublic static int FIELD_NAME_ = 0;\npublic static int FIELD_TYPE_ = 1;\npublic static int FIELD_LENGTH_ = 2;\npublic static int FIELD_DECIMALS_ = 3;\npublic static int FIELD_NULLS_ = 4;\npublic static int FIELD_DESC_ = 5;\n\n// What this table represents\ntransient private Connection connection_ = null;\nprivate String[] tables_ = null;  // The DB tables for which this model contains data.\n\n// The table data\ntransient private String[][] data_ = new String[0][NUM_COLUMNS_]; // table data\ntransient private int[] types_ = new int[0];            // sql types\n// Row information\ntransient private int numRows_ = 0;          // Number of rows in the table.\n\n// Flag for if an error event was sent.\ntransient private boolean error_;\n\n// Event support.\ntransient private ErrorEventSupport errorListeners_\n    = new ErrorEventSupport (this);\ntransient private WorkingEventSupport workingListeners_\n    = new WorkingEventSupport (this);\n\n\n\n/**\nConstructs a SQLMetaDataTableModel object.  The query is not done\nuntil <i>load</i> is done.\n\n@param       connection  The SQL connection.\n@param       tables      The database files to retrieve info about.\n                        Tables should be in the form of <library>.<file>.\n**/\npublic SQLMetaDataTableModel (Connection connection,\n                         String[] tables)\n{\n    super();\n    connection_ = connection;\n    tables_ = tables;\n}\n\n\n/**\nAdds a listener to be notified when an error occurs.\nThe listener's errorOccurred method will be called.\n\n@param  listener  The listener.\n**/\npublic void addErrorListener (ErrorListener listener)\n{\n    errorListeners_.addErrorListener (listener);\n}\n\n\n\n/**\nAdds a listener to be notified when work starts and stops\non potentially long-running operations.\n\n@param  listener  The listener.\n**/\npublic void addWorkingListener (WorkingListener listener)\n{\n    workingListeners_.addWorkingListener (listener);\n}\n\n\n\n/**\nMakes a clone (copy) of this table.  No data (references) is shared\nbetween this original and the new object.  Listeners are not copied\nto the new object.\n**/\nsynchronized public Object clone ()\n{\n    // create new object\n    SQLMetaDataTableModel clone =\n        new SQLMetaDataTableModel(connection_, tables_);\n    // copy table data\n    clone.data_ = new String[data_.length][NUM_COLUMNS_];\n    System.arraycopy(data_, 0, clone.data_, 0 , data_.length);\n    clone.numRows_ = numRows_;\n    clone.types_ = new int[types_.length];\n    System.arraycopy(types_, 0, clone.types_, 0 , types_.length);\n\n    return clone;\n}\n\n\n/**\nReturns the number of columns in the table.\n\n@return The number of columns in the table.\n**/\npublic int getColumnCount()\n{\n    return NUM_COLUMNS_;\n}\n\n\n/**\nReturns the number of rows in the table.\n\n@return The number of rows in the result set.\n**/\nsynchronized public int getRowCount()\n{\n    return numRows_;\n}\n\n\n/**\nReturn the SQL type of the field.  Note this is not the same as\nthe data in FIELD_TYPE_, which is the database-dependent type name.\n@see java.sql.Types\n\n@param index The row for which to get the type.\n@return The SQL type of the field.\n**/\nsynchronized int getSQLType(int index)\n{\n    return types_[index];\n}\n\n\n/**\nReturns the database file names this table contains data for.\n\n@return The database file names this table contains data for.\n**/\npublic String[] getTables ()\n{\n    return tables_;\n}\n\n\n/**\nReturns the value at the specifed column and row.\n\n@param  rowIndex            The row index.  Indices start at 0.\n@param  columnIndex    The column index.  Indices start at 0.\n\n@return The value at the specified column and row.\n**/\nsynchronized public Object getValueAt (int rowIndex,\n                          int columnIndex)\n{\n    error_ = false;\n\n    // return the value\n    return data_[rowIndex][columnIndex];\n}\n\n\n\n\n/**\nLoads the table based on the state of the system.\n**/\npublic void load ()\n{\n    synchronized (this)\n    {\n        // Set back fields in case there is an error.\n        data_ = new String[0][0];\n        types_ = new int[0];\n        numRows_ = 0;\n    }\n    // notify listeners that we've changed number of rows.\n    TableModelEvent event = new TableModelEvent(this, -1);\n    fireTableChanged(event);\n    Trace.log(Trace.DIAGNOSTIC, \"Starting load, changed number of rows to:\", numRows_);\n\n    if (tables_ == null || tables_.length == 0 ||\n        connection_ == null)\n    {\n        //If no tables, the panel will be disabled, don't throw\n        //error, just leave table empty.\n        return;\n    }\n\n    synchronized (this)\n    {\n        workingListeners_.fireStartWorking ();\n\n        // Number of rows we create our table with and number of\n        // rows we bump our capacity by each time we run out of room.\n        int ROW_INCREMENT = 50;\n\n        ResultSet resultSet = null;\n        try\n        {\n            // Get database meta data\n            DatabaseMetaData metaData = connection_.getMetaData();\n\n            // Create new array to hold table values.\n            data_ = new String[ROW_INCREMENT][NUM_COLUMNS_];\n            types_ = new int[ROW_INCREMENT];\n\n            // Loop through each database file.\n            String library, table, tprefix;\n            int sepIndex;\n            int curRow;\n            for (int i=0; i<tables_.length; ++i)\n            {\n                // Get meta data.\n                sepIndex = tables_[i].indexOf(\".\");\n                if (sepIndex == -1)\n                {\n                    // Incorrect table specification, send error\n                    // and continue to next table.\n                    // Create generic exception to hold error message\n                    Exception e = new Exception(ResourceLoader.getText(\"EXC_TABLE_SPEC_NOT_VALID\"));\n                    errorListeners_.fireError(e);\n                }\n                else\n                {\n                    library = tables_[i].substring(0, sepIndex);\n                    table = tables_[i].substring(sepIndex+1);\n                    if (tables_.length > 1)\n                        tprefix = table + \".\"; // need to qualify field names\n                    else\n                        tprefix = \"\";  // only 1 table, can just use field names\n                    resultSet = metaData.getColumns(null, library, table, null);\n\n                    // Loop through fields for this database file.\n                    while (resultSet.next())\n                    {\n                        curRow = numRows_; // current row in table\n\n                        // make sure we have room in table for this row.\n                        if (curRow >= data_.length)                         // @D1C\n                        {\n                            String[][] newData =\n                                new String[data_.length + ROW_INCREMENT][NUM_COLUMNS_];\n                            System.arraycopy(data_, 0, newData, 0, data_.length);\n                            data_ = newData;\n                            int[] newTypes =\n                                new int[types_.length + ROW_INCREMENT];\n                            System.arraycopy(types_, 0, newTypes, 0, types_.length);\n                            types_ = newTypes;\n                        }\n\n                        // Store SQL type for use by getSQLType,\n                        // although this is not externalized in the table.\n                        types_[curRow] = resultSet.getInt(5);\n\n                        // Add field info to table\n                        data_[curRow][FIELD_NAME_] = tprefix + resultSet.getString(4).trim();\n                        data_[curRow][FIELD_TYPE_] = resultSet.getString(6);\n                        // The following code should not be necessary when using\n                        // most drivers, but makes the length values correct\n                        // when using the i5/OS JDBC driver.\n                        // These values came from the ODBC description of precision\n                        // (in 2.0 ref, Appendix D page 624).\n                        switch (types_[curRow])\n                        {\n                            case Types.SMALLINT:\n                                data_[curRow][FIELD_LENGTH_] = \"5\";\n                                break;\n                            case Types.INTEGER:\n                                data_[curRow][FIELD_LENGTH_] = \"10\";\n                                break;\n                            case Types.TIME:\n                                data_[curRow][FIELD_LENGTH_] = \"8\";\n                                break;\n                            case Types.TIMESTAMP:\n                                // We always give length = 23, even though\n                                // we should give 19 if there is no decimals.\n                                // In order to not mess up 'correct' values,\n                                // only change it if we know the value is bad.\n                                if (resultSet.getInt(7) == 10)\n                                    data_[curRow][FIELD_LENGTH_] = \"23\";\n                                break;\n                            case Types.DATE:\n                                data_[curRow][FIELD_LENGTH_] = \"10\";\n                                break;\n                            case Types.DOUBLE:\n                                if (resultSet.getInt(7) == 4)\n                                    // single precision (type REAL)\n                                    data_[curRow][FIELD_LENGTH_] = \"7\";\n                                else\n                                    // double precison (type FLOAT)\n                                    data_[curRow][FIELD_LENGTH_] = \"15\";\n                                break;\n                            default:\n                                // Other types are correct.\n                                data_[curRow][FIELD_LENGTH_] = resultSet.getString(7);\n                        }\n                        data_[curRow][FIELD_DECIMALS_] = resultSet.getString(9);\n                        data_[curRow][FIELD_NULLS_] = resultSet.getString(18);\n                        data_[curRow][FIELD_DESC_] = resultSet.getString(12);\n\n                        numRows_++;\n                    }\n                }\n            }\n        }\n        catch (SQLException e)\n        {\n            // In case of error, set fields to init state\n            data_ = new String[0][0];\n            types_ = new int[0];\n            numRows_ = 0;\n            errorListeners_.fireError(e);\n            error_ = true;\n        }\n        finally\n        {\n            if (resultSet != null)\n            {\n                try\n                {\n                    resultSet.close();\n                }\n                catch(SQLException e)\n                {\n                    errorListeners_.fireError(e);\n                }\n            }\n        }\n    }  // end of synchronized block\n\n    // notify listeners that we've changed\n    event = new TableModelEvent(this, -1);\n    fireTableChanged(event);\n    Trace.log(Trace.DIAGNOSTIC, \"Did load, changed number of rows to:\", numRows_);\n\n    workingListeners_.fireStopWorking ();\n}\n\n\n/**\nRestores the state of this object from an object input stream.\nIt is used when deserializing an object.\n@param in The input stream of the object being deserialized.\n@exception IOException\n@exception ClassNotFoundException\n**/\nprivate void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException\n{\n    // Restore the non-static and non-transient fields.\n    in.defaultReadObject();\n    // Initialize the transient fields.\n    connection_ = null;\n    data_ = new String[0][NUM_COLUMNS_];\n    types_ = new int[0];\n    numRows_ = 0;\n    errorListeners_ = new ErrorEventSupport (this);\n    workingListeners_ = new WorkingEventSupport (this);\n}\n\n\n/**\nRemoves a row from the table.\n\n@param  rowIndex  The row index.  Indices start at 0.\n**/\npublic void removeRow (int rowIndex)\n{\n    synchronized (this)\n    {\n        Trace.log(Trace.DIAGNOSTIC, \"Removing row \", rowIndex);\n\n        // array to hold new data\n        String[][] newData = new String[data_.length -1][NUM_COLUMNS_];\n        int[] newTypes = new int[types_.length -1];\n\n        // copy table data to new table less row being removed\n        if (rowIndex == 0)\n        {\n            // remove first row\n            System.arraycopy(data_, 1, newData, 0, newData.length);\n            System.arraycopy(types_, 1, newTypes, 0, newTypes.length);\n        }\n        else if (rowIndex == data_.length - 1)\n        {\n            // remove last row\n            System.arraycopy(data_, 0, newData, 0, newData.length);\n            System.arraycopy(types_, 0, newTypes, 0, newTypes.length);\n        }\n        else\n        {\n            // remove row in middle\n            System.arraycopy(data_, 0, newData, 0, rowIndex);\n            System.arraycopy(data_, rowIndex+1, newData, rowIndex,\n                                newData.length-rowIndex);\n            System.arraycopy(types_, 0, newTypes, 0, rowIndex);\n            System.arraycopy(types_, rowIndex+1, newTypes, rowIndex,\n                                newTypes.length-rowIndex);\n        }\n\n        data_ = newData;\n        numRows_--;\n    }\n\n    // notify listeners that we've changed\n    fireTableRowsDeleted(rowIndex, rowIndex);\n}\n\n\n/**\nRemoves a listener from being notified when an error occurs.\n\n@param  listener  The listener.\n**/\npublic void removeErrorListener (ErrorListener listener)\n{\n    errorListeners_.removeErrorListener (listener);\n}\n\n\n/**\nRemoves a listener from being notified when work starts and stops.\n\n@param  listener  The listener.\n**/\npublic void removeWorkingListener (WorkingListener listener)\n{\n    workingListeners_.removeWorkingListener (listener);\n}\n\n\n/**\nSets the database files this table contains data for.\nThe new value will not be in effect until a <i>load()</i> is done.\n\n@param tables The database files this table will contain data for.\n                        Tables should be in the form of <library>.<file>.\n**/\npublic void setTables (String[] tables)\n{\n    tables_ = tables;\n}\n\n\n/**\nSets the SQL connection this table contains data for.\nThe new value will not be in effect until a <i>load()</i> is done.\n\n@param       connection  The SQL connection.\n**/\npublic void setConnection (Connection connection)\n{\n    connection_ = connection;\n}\n\n\n/**\nRestores the state of this object from an object input stream.\nIt is used when deserializing an object.\n@param sqlMetaDataTablePane TODO\n * @param in The input stream of the object being deserialized.\n * @exception IOException\n@exception ClassNotFoundException\n**/\nvoid readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)\n     throws java.io.IOException, ClassNotFoundException\n{\n    in.defaultReadObject();\n    sqlMetaDataTablePane.addFocusListener(new SerializationListener(sqlMetaDataTablePane)); //@B0A - for safe serialization next time\n\n    //@B0A: The following code is copied from the constructor since\n    // table_ is now transient.\n    sqlMetaDataTablePane.table_ = new JTable();\n    sqlMetaDataTablePane.table_.setAutoCreateColumnsFromModel(false);\n    sqlMetaDataTablePane.table_.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN); //@B0C\n    sqlMetaDataTablePane.table_.setModel(this);\n    sqlMetaDataTablePane.table_.setShowGrid(false);\n    // set up table columns\n    TableColumn column = new TableColumn(SQLMetaDataTableModel.FIELD_NAME_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_NAME\"));\n    column.setPreferredWidth(150); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_TYPE_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_TYPE\"));\n    column.setPreferredWidth(70); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_LENGTH_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_LENGTH\"));\n    column.setPreferredWidth(60); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_DECIMALS_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_DECIMALS\"));\n    column.setPreferredWidth(65); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_NULLS_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_NULL\"));\n    column.setPreferredWidth(80); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    column = new TableColumn(SQLMetaDataTableModel.FIELD_DESC_);\n    column.setHeaderValue(ResourceLoader.getQueryText(\"DBQUERY_COLUMN_DESCRIPTION\"));\n    column.setPreferredWidth(180); //@B0C\n    sqlMetaDataTablePane.table_.addColumn(column);\n    // build panel with table and headings\n    sqlMetaDataTablePane.setupPane();\n}\n\n\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 525,
                        "lineEnd": 573,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to com.ibm.as400.vaccess.SQLMetaDataTablePane\nRationale: The method readObject2 directly manipulates the SQLMetaDataTablePane instance, setting up its JTable and adding columns, which indicates that it is closely related to the functionality of SQLMetaDataTablePane.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 6064
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)",
                            "target_class": "SQLMetaDataTablePane",
                            "rationale": "The readObject2 method is responsible for setting up the SQLMetaDataTablePane with the table model and its columns, which is directly related to the UI representation of the data. It should be moved to the SQLMetaDataTablePane class to maintain separation of concerns."
                        }
                    ],
                    "llm_response_time": 1965
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)",
                            "target_class": "SQLMetaDataTablePane",
                            "rationale": "The readObject2 method is responsible for setting up the SQLMetaDataTablePane with the table model and its columns, which is directly related to the UI representation of the data. It should be moved to the SQLMetaDataTablePane class to maintain separation of concerns."
                        }
                    ],
                    "llm_response_time": 1886
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)",
                            "target_class": "SQLMetaDataTablePane",
                            "rationale": "The readObject2 method is responsible for setting up the SQLMetaDataTablePane with the SQLMetaDataTableModel, which indicates that it is closely related to the UI component. Moving it to SQLMetaDataTablePane would improve cohesion and maintainability."
                        }
                    ],
                    "llm_response_time": 1535
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLMetaDataTablePane sqlMetaDataTablePane, ObjectInputStream in)",
                            "target_class": "SQLMetaDataTablePane",
                            "rationale": "The readObject2 method is responsible for setting up the SQLMetaDataTablePane with the table model and its columns, which is directly related to the UI representation of the data. It should be moved to the SQLMetaDataTablePane class to maintain separation of concerns."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "readObject2"
                ],
                "llm_response_time": 612
            },
            "targetClassMap": {
                "readObject2": {
                    "target_classes": [
                        {
                            "class_name": "SQLMetaDataTablePane",
                            "similarity_score": 0.6896865432884054
                        },
                        {
                            "class_name": "ErrorEventSupport",
                            "similarity_score": 0.3310278493971974
                        },
                        {
                            "class_name": "WorkingEventSupport",
                            "similarity_score": 0.3088104758037342
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SQLMetaDataTablePane",
                        "ErrorEventSupport",
                        "WorkingEventSupport"
                    ],
                    "llm_response_time": 2290,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.data.ProgramCallDocument::endInternal(int):void need move com.ibm.as400.resource.RJob",
        "class_name": "com.ibm.as400.data.ProgramCallDocument",
        "telemetry": {
            "id": "fae3827f-f0d1-45f7-a379-b281649fcbf3",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1977,
                "lineStart": 56,
                "lineEnd": 2032,
                "bodyLineStart": 56,
                "language": "java",
                "sourceCode": "/**\n * XML Document based program call.\n *\n * The ProgramCallDocument class uses a Program Call Markup Language (PCML) document to\n * call IBM i system programs.\n * PCML is an XML language for describing the input and output parameters\n * to the IBM i system program.\n *\n * This class parses a PCML document and allows the application to call\n * IBM i system programs described in the PCML document.\n *\n * <h3>Command Line Interface</h3>\n * The command line interface may be used to serialize\n * PCML document definitions. Note that XPCML documents cannot\n * be serialized.\n * <pre>\n * <kbd>java com.ibm.as400.data.ProgramCallDocument\n *     -serialize\n *     <i>PCML document name</i></kbd>\n * </pre>\n * Options:\n * <dl>\n * <dt><kbd>-serialize</kbd>\n * <dd>Parses the PCML document and creates a serialized version of the document.\n * The name of the serialized file will match the document name, and the file extension will be\n * <code><strong>.pcml.ser</code></strong> (lowercase).\n * <p><dt><kbd><i>PCML document name</i></kbd>\n * <dd>The fully-qualified resource name of the PCML document\n * which defines the program interface.\n * </dl>\n */\npublic class ProgramCallDocument implements Serializable, Cloneable\n{                                                                   // @C1C @C3C\n    static final long serialVersionUID = -1836686444079106483L;\t    // @C1A\n\n    /**\n     * Constant indicating a serialized PCML or XPCML document is being streamed.\n     * @see #ProgramCallDocument(AS400,String,InputStream,ClassLoader,InputStream,int)\n    **/\n    public static final int SERIALIZED = 0;\n\n    /**\n     * Constant indicating a source PCML document is being streamed.\n    * @see #ProgramCallDocument(AS400,String,InputStream,ClassLoader,InputStream,int)\n    **/\n    public static final int SOURCE_PCML = 1;\n\n    /**\n     * Constant indicating a source XPCML document is being streamed.\n    * @see #ProgramCallDocument(AS400,String,InputStream,ClassLoader,InputStream,int)\n    **/\n    public static final int SOURCE_XPCML = 2;\n\n    private AS400 m_as400;\n    private PcmlDocument m_pcmlDoc;\n    static boolean exceptionIfParseError_;\n    static\n    {\n      String property = null;\n      try {\n        property = SystemProperties.getProperty(SystemProperties.THROW_SAX_EXCEPTION_IF_PARSE_ERROR);\n      }\n      catch (Throwable t) {}\n      if (property == null) { // Property not set.\n        exceptionIfParseError_ = false;\n      }\n      else if (property.trim().equalsIgnoreCase(\"true\")) {\n        exceptionIfParseError_ = true;\n      }\n      else {\n        exceptionIfParseError_ = false;\n      }\n    }\n\n    /**\n     Constructs a ProgramCallDocument object.\n    The PCML or XPCML document resource will be loaded from the classpath.\n    If the document is a PCML document, the classpath will first be searched for a serialized resource.\n    XPCML documents cannot be serialized.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML or XPCML source file.\n\n    @param sys The system on which to run the program.\n    @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public ProgramCallDocument(AS400 sys, String docName)\n    \tthrows PcmlException\n   \t{\n        if (sys == null)     warnNull(\"sys\");\n        if (docName == null) warnNull(\"docName\");\n\n        m_as400 = sys;\n\n        m_pcmlDoc = loadPcmlDocument(docName, null,null);        // @C8C @E1C\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);\n    }\n\n  /**\n    Constructs a ProgramCallDocument object.\n    The XPCML document resource will be loaded from the classpath and parsed using\n    the XML schema definitions provided in the input XSD stream.\n\n    @param sys The system on which to run the program.\n    @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n\n    public ProgramCallDocument(AS400 sys, String docName, InputStream xsdStream)\n    \tthrows PcmlException\n   \t{\n        if (sys == null)     warnNull(\"sys\");\n        if (docName == null) warnNull(\"docName\");\n\n        m_as400 = sys;\n\n        m_pcmlDoc = loadPcmlDocument(docName, null,xsdStream);        // @C8C\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);\n\n    }\n\n    /**\n     Constructs a ProgramCallDocument object.\n    The PCML or XPCML document resource will be loaded from the classpath.\n    If the document is a PCML document, the classpath will first be searched for a serialized resource.\n    XPCML documents cannot be serialized.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML or XPCML source file.\n\n     @param sys The system on which to run the program.\n    @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public ProgramCallDocument(AS400 sys, String docName, ClassLoader loader)       // @C8A\n    \tthrows PcmlException\n   \t{\n        if (sys == null)     warnNull(\"sys\");\n        if (docName == null) warnNull(\"docName\");\n\n        m_as400 = sys;                                      // @C8A\n\n        m_pcmlDoc = loadPcmlDocument(docName, loader,null);      // @C8A\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);                        // @C8A\n    }\n\n\n  /**\n    Constructs a ProgramCallDocument object.\n    The PCML or XPCML document resource will be loaded from the classpath and parsed using\n    the XML schema definitions provided in the input XSD stream.\n    @param sys The system on which to run the program.\n    @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML.  This parameter can be null.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n    @exception PcmlException when the specified PCML document cannot be found\n    */\n     public ProgramCallDocument(AS400 sys, String docName, ClassLoader loader, InputStream xsdStream)       // @C8A\n    \tthrows PcmlException\n   \t{\n        if (sys == null)     warnNull(\"sys\");\n        if (docName == null) warnNull(\"docName\");\n\n        m_as400 = sys;                                      // @C8A\n\n        m_pcmlDoc = loadPcmlDocument(docName, loader,xsdStream);      // @C8A\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);                        // @C8A\n    }\n\n  /**\n    Constructs a ProgramCallDocument object.\n    The PCML or XPCML document resource will be read from the specified input stream, and parsed using\n    the XML schema definitions provided in the input XSD stream.\n    @param sys The system on which to run the program.\n    @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n    @param docStream The InputStream from which to read the contents of the document.\n    @param loader The ClassLoader that will be used when loading the DTD for PCML. This parameter can be null.\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\".  This parameter can be null.\n    @param type The type of data contained in docStream. Possible values are:\n    <UL>\n    <LI>{@link #SERIALIZED SERIALIZED} - The docStream contains a serialized PCML or XPCML document.\n    <LI>{@link #SOURCE_PCML SOURCE_PCML} - The docStream contains a PCML document.\n    <LI>{@link #SOURCE_XPCML SOURCE_XPCML} - The docStream contains an XPCML document.\n    </UL>\n    @exception PcmlException when the specified PCML document cannot be found\n    */\n     public ProgramCallDocument(AS400 sys, String docName, InputStream docStream, ClassLoader loader, InputStream xsdStream, int type)\n    \tthrows PcmlException\n   \t{\n        if (sys == null)     warnNull(\"sys\");\n        if (docName == null) warnNull(\"docName\");\n\n        if (type == ProgramCallDocument.SERIALIZED)\n        {\n          m_pcmlDoc = loadSerializedPcmlDocumentFromStream(docStream);\n        }\n        else if (type == ProgramCallDocument.SOURCE_PCML)\n        {\n          m_pcmlDoc = loadSourcePcmlDocumentFromStream(docName, docStream, loader, xsdStream, false);\n        }\n        else if (type == ProgramCallDocument.SOURCE_XPCML)\n        {\n          m_pcmlDoc = loadSourcePcmlDocumentFromStream(docName, docStream, loader, xsdStream, true);\n        }\n        else {\n          throw new ExtendedIllegalArgumentException(\"type (\" + type + \")\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        m_as400 = sys;\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);\n    }\n\n     /**\n    Constructs a ProgramCallDocument object.\n    {@link #setSystem setSystem()} and {@link #setDocument setDocument()} must be called prior to using the object.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public ProgramCallDocument()\n    \tthrows PcmlException                                        // @C1A\n   \t{                                                               // @C1A\n        m_as400 = null;                                             // @C1A\n        m_pcmlDoc = null;                                           // @C1A\n    }                                                               // @C1A\n\n    /**\n     Constructs a ProgramCallDocument object.\n     {@link #setSystem setSystem()} must be called prior to using the object.\n     The PCML or XPCML document resource will be loaded from the classpath.\n     If the document is a PCML document, the classpath will first be searched for a serialized resource.\n     XPCML documents cannot be serialized.\n     If a serialized resource is not found, the classpath will be\n     searched for a PCML or XPCML source file.\n\n     @param docName The document resource name of the PCML document for the programs to be called.\n     All PCML-related file extensions are assumed to be lowercase (for example, <tt>.pcml</tt> or <tt>.pcml.ser</tt>).\n     The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n     @exception PcmlException when the specified PCML document cannot be found\n     */\n    public ProgramCallDocument(String docName)\n      throws PcmlException\n    {\n      if (docName == null) {\n        throw new NullPointerException(\"docName\");\n      }\n\n      m_pcmlDoc = loadPcmlDocument(docName, null,null);\n    }\n\n    /**\n     Constructs a ProgramCallDocument object.\n     {@link #setSystem setSystem()} must be called prior to using the object.\n     The PCML or XPCML document resource will be loaded from the classpath of the specified ClassLoader.\n     If the document is a PCML document, the classpath will first be searched for a serialized resource.\n     XPCML documents cannot be serialized.\n     If a serialized resource is not found, the classpath will be\n     searched for a PCML or XPCML source file.\n\n     @param docName The document resource name of the PCML document for the programs to be called.\n     @param loader The ClassLoader that will be used when loading the specified document resource.\n\n     @exception PcmlException when the specified PCML document cannot be found\n     */\n    public ProgramCallDocument(String docName, ClassLoader loader)\n    \tthrows XmlException\n    {\n      if (docName == null) {\n        throw new NullPointerException(\"docName\");\n      }\n      if (loader == null) {\n        throw new NullPointerException(\"loader\");\n      }\n\n      m_pcmlDoc = loadPcmlDocument(docName, loader, null);\n    }\n\n    /**\n    Clones the ProgramCallDocument and the objects contained in it.\n    {@link #setSystem setSystem()} and {@link #setDocument setDocument()} must be called prior to using the object.\n    */\n    public Object clone()\n   \t{                                                               // @C3A\n   \t    ProgramCallDocument newPcml = null;                         // @C3A\n        try                                                         // @C3A\n        {                                                           // @C3A\n            newPcml = (ProgramCallDocument) super.clone();          // @C3A\n            if (m_pcmlDoc != null)                                  // @C3A\n                newPcml.m_pcmlDoc = (PcmlDocument) m_pcmlDoc.clone();   // @C3A\n        }                                                           // @C3A\n        catch (CloneNotSupportedException e)                        // @C3A\n        {}                                                          // @C3A\n\n        return newPcml;                                             // @C3A\n    }                                                               // @C3A\n\n    // Custom serialization\n    private void writeObject(ObjectOutputStream out)\n        throws IOException                                          // @C1A\n    {                                                               // @C1A\n\t\tsynchronized (this)                                         // @C1A\n\t\t{                                                           // @C1A\n            if (m_pcmlDoc != null)                                  // @C1A\n            {                                                       // @C1A\n                m_pcmlDoc.setSerializingWithData(true);             // @C1A\n            }                                                       // @C1A\n\n\t\t\t// Perform default serialization\n\t\t\tout.defaultWriteObject();                               // @C1A\n\n\t\t} // end of synchronized code                               // @C1A\n    }                                                               // @C1A\n\n    /**\n\t * Provides a command line interface to ProgramCallDocument.  See the class description.\n    * Note that XPCML documents cannot be serialized.\n\t *\n     */\n    public static void main(String[] args)\n    {\n\t\tPcmlDocument pd = null;\n\n        System.setErr(System.out);\n        final String errMsg = SystemResourceFinder.format(DAMRI.PCD_ARGUMENTS);\n\n\t\tif (args.length == 2)\n        {\n        \tif (!args[0].equalsIgnoreCase(\"-SERIALIZE\"))\n        \t{\n        \t\tSystem.out.println(errMsg);\n        \t\tSystem.exit(-1);\n        \t}\n\n            // Load the document from source (previously serialized documents are ignored)\n            try\n            {\n\t\t\t\tpd = loadSourcePcmlDocument(args[1], null,null);         // @C8C\n            }\n\t\t\tcatch (PcmlException e)\n\t\t\t{\n\t\t\t\tSystem.out.println(e.getLocalizedMessage());\n\t\t\t\tSystem.exit(-1);\n\t\t\t}\n\n            // Save the document as a serialized file\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsavePcmlDocument(pd);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tSystem.out.println(e.getLocalizedMessage());\n\t\t\t\tSystem.exit(-1);\n\t\t\t}\n\n        }\n\t\telse\n\t\t{\n    \t\tSystem.out.println(errMsg);\n    \t\tSystem.exit(-1);\n\t\t}\n\n    }\n\n\n\n    /**\n     Calls the named program.\n\n     @param name The name of the &lt;program&gt; element in the PCML document.\n     @exception PcmlException\n                If an error occurs.\n    */\n    public boolean callProgram(String name)\n        throws PcmlException\n    {\n        try\n        {\n            return m_pcmlDoc.callProgram(name);\n        }\n        catch (AS400SecurityException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            PcmlException pe = new PcmlException(e);\n            throw pe;\n        }\n        catch (ObjectDoesNotExistException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            PcmlException pe = new PcmlException(e);\n            throw pe;\n        }\n        catch (InterruptedException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            PcmlException pe = new PcmlException(e);\n            throw pe;\n        }\n        catch (ErrorCompletingRequestException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            PcmlException pe = new PcmlException(e);\n            throw pe;\n        }\n        catch (IOException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            throw new PcmlException(e);\n        }\n\n    }\n\n    /**\n    Returns an \"errno\" value for the named service program element.\n    <p>\n    The named program element must be defined as a service program <code>entrypoint</code>.\n    The value returned is the \"errno\" value resulting from the most recent\n    call to the program. If the program has not been called, zero is returned.\n\n    @return The integer \"errno\" value for the named service program element.\n\n    @param name The name of the &lt;program&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getErrno(String name)\n        throws PcmlException                                        // @B1A\n    {                                                               // @B1A\n        return m_pcmlDoc.getErrno(name);                            // @B1A\n    }                                                               // @B1A\n\n    /**\n    Returns a Descriptor for the specified PCML document.\n    The PCML document resource will be loaded from the classpath.\n    The classpath will first be searched for a serialized resource.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML source file.\n\n    @param docName The document resource name of the PCML document for which the Descriptor is returned.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n    @return The Descriptor for the &lt;pcml&gt; element of the named PCML file.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public static Descriptor getDescriptor(String docName)\n        throws PcmlException                                        // @C5A\n    {\n        PcmlDocument pd = null;\n\n        pd = loadPcmlDocument(docName, null,null);                       // @C8C\n\n        return new PcmlDescriptor(pd);\n    }                                                               // @C5A\n\n     /**\n    Returns a Descriptor for the specified XPCML document.\n    The XPCML document resource will be loaded from the classpath.\n\n    @param docName The document resource name of the XPCML document for which the Descriptor is returned.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML\n\n    @return The Descriptor for the &lt;pcml&gt; element of the named PCML file.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public static Descriptor getDescriptor(String docName, InputStream xsdStream)\n        throws PcmlException                                        // @C5A\n    {\n        PcmlDocument pd = null;\n\n        pd = loadPcmlDocument(docName, null, xsdStream);                       // @C8C\n\n        return new PcmlDescriptor(pd);\n    }                                                               // @C5A\n\n    /**\n    Returns a Descriptor for the specified PCML document.\n    The PCML document resource will be loaded from the classpath.\n    The classpath will first be searched for a serialized resource.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML source file.\n\n    @param docName The document resource name of the PCML document for which the Descriptor is returned.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n    @return The Descriptor for the &lt;pcml&gt; element of the named PCML file.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public static Descriptor getDescriptor(String docName, ClassLoader loader)\n        throws PcmlException                                        // @C8A\n    {\n        PcmlDocument pd = null;                                     // @C8A\n\n        pd = loadPcmlDocument(docName, loader,null);                             // @C8A\n\n        return new PcmlDescriptor(pd);                              // @C8A\n    }\n\n    /**\n    Returns a Descriptor for the specified XPCML document.\n    The XPCML document resource will be loaded from the classpath.\n\n    @param docName The document resource name of the PCML document for which the Descriptor is returned.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML.\n\n    @return The Descriptor for the &lt;pcml&gt; element of the named PCML file.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    */\n    public static Descriptor getDescriptor(String docName, ClassLoader loader, InputStream xsdStream)\n        throws PcmlException                                        // @C8A\n    {\n        PcmlDocument pd = null;                                     // @C8A\n\n        pd = loadPcmlDocument(docName, loader,xsdStream);                             // @C8A\n\n        return new PcmlDescriptor(pd);                              // @C8A\n    }\n\n\n    /**\n    Returns a Descriptor for the current PCML document.\n\n    @return The Descriptor for the &lt;pcml&gt; element of the current PCML file or\n            null if the PCML document has not be set.\n    */\n    public Descriptor getDescriptor()                               // @C5A\n    {\n\n        if (m_pcmlDoc == null)\n            return null;\n        else\n            return new PcmlDescriptor(m_pcmlDoc);\n    }                                                               // @C5A\n\n    /**\n    Returns an int return value for the named service program element.\n    <p>\n    The named program element must be defined as a service program <code>entrypoint</code>.\n    The value returned is the integer return value from the most recent\n    call to the program. If the program has not been called, zero is returned.\n\n    @return The integer return value for the named service program element.\n\n    @param name The name of the &lt;program&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getIntReturnValue(String name) throws PcmlException  // @B1A\n    {                                                               // @B1A\n        return m_pcmlDoc.getIntReturnValue(name);                   // @B1A\n    }                                                               // @B1A\n\n    /**\n    Returns an int value for the named element.\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to an int.\n\n    @return The integer value for the named element.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getIntValue(String name)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getIntValue(name);\n    }\n\n    /**\n    Returns an int value for the named element given indices to the data element.\n    If the data element is an array or is an element in a structure array, an index\n    must be specified for each dimension of the data.\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to an int.\n\n    @return The integer value for the named element.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getIntValue(String name, int[] indices)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getIntValue(name, new PcmlDimensions(indices));\n    }\n\n\n    /**\n     Returns the ProgramCall object that was used in the most recent invocation of {@link #callProgram(String) callProgram()}.\n     @return The ProgramCall object; null if callProgram() has not been called.\n     **/\n    public ProgramCall getProgramCall()\n    {\n      return ( m_pcmlDoc == null ? null : m_pcmlDoc.getProgramCall() );\n    }\n\n\n    /**\n    Returns a String value for the named element.\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to a String.\n    The default bidi string type is assumed ({@link com.ibm.as400.access.BidiStringType#DEFAULT BidiStringType.DEFAULT}).\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @exception PcmlException If an error occurs.\n    */\n    public String getStringValue(String name)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getStringValue(name, BidiStringType.DEFAULT);\n    }\n\n    /**\n    Returns a String value for the named element.\n    <p>\n    This method is used when the string type cannot be determined until\n    run-time.  In those cases, the PCML document cannot be used to indicate\n    the string type so this method is used to get the value using the\n    string type that is specified.\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to a String.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param type The bidi string type, as defined by the CDRA (Character\n                Data Representation Architecture).\n    @exception PcmlException\n               If an error occurs.\n    @see com.ibm.as400.access.BidiStringType\n    */\n    public String getStringValue(String name, int type)\n        throws PcmlException                                            // @C9A\n    {\n        return m_pcmlDoc.getStringValue(name, type);                    // @C9A\n    }\n\n\n    /**\n    Returns a String value for the named element given indices to the data element.\n    If the data element is an array or is an element in a structure array, an index\n    must be specified for each dimension of the data.\n    The default bidi string type is assumed ({@link com.ibm.as400.access.BidiStringType#DEFAULT BidiStringType.DEFAULT}).\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to a String.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for setting the value of an element in an array.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public String getStringValue(String name, int[] indices)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getStringValue(name, new PcmlDimensions(indices), BidiStringType.DEFAULT);\n    }\n\n    /**\n    Returns a String value for the named element given indices to the data element.\n    If the data element is an array or is an element in a structure array, an index\n    must be specified for each dimension of the data.\n    <p>\n    This method is used when the string type cannot be determined until\n    run-time.  In those cases, the PCML document cannot be used to indicate\n    the string type so this method is used to get the value using the\n    string type that is specified.\n    <p>\n    If the named element is String or a Number output value of a program, the value will\n    be converted to a String.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for setting the value of an element in an array.\n    @param type The bidi string type, as defined by the CDRA (Character\n                Data Representation Architecture).\n    @exception PcmlException\n               If an error occurs.\n    @see com.ibm.as400.access.BidiStringType\n    */\n    public String getStringValue(String name, int[] indices, int type)\n        throws PcmlException                                            // @C9A\n    {\n        return m_pcmlDoc.getStringValue(name, new PcmlDimensions(indices), type);           // @C9A\n    }\n\n    /**\n    Returns the list of IBM i system messages returned from running the\n    program. An empty list is returned if the program has not been run yet.\n\n    @param name The name of the &lt;program&gt; element in the PCML document.\n    @return The array of messages returned by the system for the program.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public AS400Message[] getMessageList(String name)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getMessageList(name);\n    }\n\n    /**\n    Returns the number of bytes reserved for output for the named element.\n\n    @return The number of bytes reserved for output for the named element.\n    @param name The name of the &lt;data&gt; or &lt;struct&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getOutputsize(String name)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getOutputsize(name);\n    }\n\n    /**\n    Returns the number of bytes reserved for output for the named element and indices.\n\n    @return The number of bytes reserved for output for the named element.\n    @param name The name of the &lt;data&gt; or &lt;struct&gt; element in the PCML document.\n    @param indices An array of indices for accessing the output size of an element in an array.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public int getOutputsize(String name, int[] indices)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getOutputsize(name, new PcmlDimensions(indices));\n    }\n\n    /**\n    Returns the Java object value for the named element.\n    <p>\n    If the named element is an output value of a program, the value will\n    be converted from IBM i system data to a Java Object.\n    <p>\n    The type of object returned depends on the description in the PCML document.\n    <table border=1>\n    <tr valign=top><th>PCML Description</th><th>Object Returned</th></tr>\n    <tr valign=top><td><code>type=char</td><td><code>String</code></td></tr>\n    <tr valign=top><td><code>type=byte</td><td><code>byte[]</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=2<br>\n                             precision=15</td><td><code>Short</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=2<br>\n                             precision=16</td><td><code>Integer</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=4<br>\n                             precision=31</td><td><code>Integer</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=4<br>\n                             precision=32</td><td><code>Long</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=8<br>\n                             precision=63</td><td><code>Long</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=8<br>\n                             precision=64</td><td><code>BigInteger</code></td></tr>\n    <tr valign=top><td><code>type=packed</td><td><code>BigDecimal</code></td></tr>\n    <tr valign=top><td><code>type=zoned</td><td><code>BigDecimal</code></td></tr>\n    <tr valign=top><td><code>type=float<br>\n                             length=4</td><td><code>Float</code></td></tr>\n    <tr valign=top><td><code>type=float<br>\n                             length=8</td><td><code>Double</code></td></tr>\n    <tr valign=top><td><code>type=date</td><td><code>java.sql.Date</code></td></tr>\n    <tr valign=top><td><code>type=time</td><td><code>java.sql.Time</code></td></tr>\n    <tr valign=top><td><code>type=timestamp</td><td><code>java.sql.Timestamp</code></td></tr>\n    </table>\n\n    @return The Java object value for the named &lt;data&gt; element in the PCML document.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public Object getValue(String name)\n        throws PcmlException\n    {\n      if (Trace.isTraceOn()) Trace.log(Trace.PCML, \"Entered method ProgramCallDocument.getValue(\"+name+\")\");\n\n      Object val = m_pcmlDoc.getValue(name);\n\n      if (Trace.isTraceOn()) Trace.log(Trace.PCML, \"Exiting method ProgramCallDocument.getValue(\"+name+\")\");\n\n      return val;\n    }\n\n    /**\n    Returns the Java object value for the named element given indices to the data element.\n    If the data element is an array or is an element in a structure array, an index\n    must be specified for each dimension of the data.\n    <p>\n    If the named element is an output value of a program, the value will\n    be converted from IBM i system data to a Java Object.\n    <p>\n    The type of object returned depends on the description in the PCML document.\n    <table border=1>\n    <tr valign=top><th>PCML Description</th><th>Object Returned</th></tr>\n    <tr valign=top><td><code>type=char</td><td><code>String</code></td></tr>\n    <tr valign=top><td><code>type=byte</td><td><code>byte[]</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=2<br>\n                             precision=15</td><td><code>Short</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=2<br>\n                             precision=16</td><td><code>Integer</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=4<br>\n                             precision=31</td><td><code>Integer</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=4<br>\n                             precision=32</td><td><code>Long</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=8<br>\n                             precision=63</td><td><code>Long</code></td></tr>\n    <tr valign=top><td><code>type=int<br>\n                             length=8<br>\n                             precision=64</td><td><code>BigInteger</code></td></tr>\n    <tr valign=top><td><code>type=packed</td><td><code>BigDecimal</code></td></tr>\n    <tr valign=top><td><code>type=zoned</td><td><code>BigDecimal</code></td></tr>\n    <tr valign=top><td><code>type=float<br>\n                             length=4</td><td><code>Float</code></td></tr>\n    <tr valign=top><td><code>type=float<br>\n                             length=8</td><td><code>Double</code></td></tr>\n    <tr valign=top><td><code>type=date</td><td><code>java.sql.Date</code></td></tr>\n    <tr valign=top><td><code>type=time</td><td><code>java.sql.Time</code></td></tr>\n    <tr valign=top><td><code>type=timestamp</td><td><code>java.sql.Timestamp</code></td></tr>\n    </table>\n\n    @return The Java object value for the named &lt;data&gt; element in the PCML document.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for accessing the value of an element in an array.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public Object getValue(String name, int[] indices)\n        throws PcmlException\n    {\n      if (Trace.isTraceOn()) Trace.log(Trace.PCML, \"Entered method ProgramCallDocument.getValue(\"+name+\", indices)\");\n\n      Object val = m_pcmlDoc.getValue(name, new PcmlDimensions(indices));\n\n      if (Trace.isTraceOn()) Trace.log(Trace.PCML, \"Exiting method ProgramCallDocument.getValue(\"+name+\", indices)\");\n\n      return val;\n    }\n\n    /**\n    Gets the system on which programs are to be called.\n\n    @return The current system for this ProgramCallDocument.\n\n    @see #setSystem\n    **/\n    public AS400 getSystem()                                        // @C4A\n    {                                                               // @C4A\n        return m_as400;                                             // @C4A\n    }                                                               // @C4A\n\n\n    /**\n     Serializes the ProgramCallDocument. Note that XPCML documents\n     cannot be serialized.\n\n     The filename of the serialized file will be of the form\n     <pre>\n     <kbd><i>docName</i>.pcml.ser</kbd>\n     </pre>\n     where <kbd><i>docName</i>.pcml.ser</kbd> (lowercase) is the name of the document used to\n\t construct this object.\n\n     @exception PcmlException If an error occurs.\n     @deprecated Use {@link #serialize(File) serialize(File)} instead.\n     */\n    public void serialize()\n        throws PcmlException\n    {\n      if (m_pcmlDoc == null) {\n        throw new PcmlException(DAMRI.DOCUMENT_NOT_SET);\n      }\n      try {\n        savePcmlDocument(m_pcmlDoc);\n      }\n      catch (IOException e) {\n        if (Trace.isTraceErrorOn())\n          e.printStackTrace(Trace.getPrintWriter());\n        throw new PcmlException(e);\n      }\n    }\n\n\n    /**\n     Serializes the ProgramCallDocument to a stream.\n\n     @param outputStream The output stream to which to serialize the object.\n     @exception IOException  If an error occurs while writing to the stream.\n     @exception PcmlException  If an error occurs while processing PCML.\n     **/\n    public void serialize(OutputStream outputStream)\n      throws IOException, PcmlException\n    {\n      if (outputStream == null) {\n        throw new NullPointerException(\"outputStream\");\n      }\n      if (m_pcmlDoc == null) {\n        throw new PcmlException(DAMRI.DOCUMENT_NOT_SET);\n      }\n      savePcmlDocument(m_pcmlDoc, outputStream);\n    }\n\n    /**\n     Serializes the ProgramCallDocument to a file.\n\n     @param file The file to which to serialize the object.\n     @exception IOException  If an error occurs while writing to the file.\n     @exception XmlException  If an error occurs while processing RFML.\n     **/\n    public void serialize(File file)\n      throws IOException, XmlException\n    {\n      FileOutputStream fos = null;\n      try\n      {\n        fos = new FileOutputStream(file);\n        serialize(fos);\n      }\n      finally\n      {\n        if (fos != null) fos.close();\n      }\n    }\n\n    /**\n    Sets the Java object value for the named element using a int input.\n    <p>\n    The named element must be able to be set using a Integer object.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param value The int value for the named element.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public void setIntValue(String name, int value)\n        throws PcmlException\n    {\n        setValue(name, new Integer(value));\n    }\n\n    /**\n    Sets the Java object value for the named element using an int input value\n    given indices to the data element.\n    <p>\n    The named element must be able to be set using a Integer object.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for setting the value of an element in an array.\n    @param value The int value for the named element.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public void setIntValue(String name, int[] indices, int value)\n        throws PcmlException\n    {\n        setValue(name, indices, new Integer(value));\n    }\n\n\n    /**\n    Sets the Java object value for the named element using a String input.\n    The default bidi string type is assumed ({@link com.ibm.as400.access.BidiStringType#DEFAULT BidiStringType.DEFAULT}).\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param value The string value for the named element.\n    @exception PcmlException If an error occurs.\n    */\n    public void setStringValue(String name, String value)\n        throws PcmlException\n    {\n        setStringValue(name, value, BidiStringType.DEFAULT);\n    }\n\n    /**\n    Sets the Java object value for the named element using a String input.\n    <p>\n    This method is used when the string type cannot be determined until\n    run-time.  In those cases, the PCML document cannot be used to indicate\n    the string type so this method is used to set the value and the\n    string type of the input value.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param value The string value for the named element.\n    @param type The bidi string type, as defined by the CDRA (Character\n                Data Representation Architecture).\n    @exception PcmlException\n               If an error occurs.\n    @see com.ibm.as400.access.BidiStringType\n    */\n    public void setStringValue(String name, String value, int type)\n        throws PcmlException                                            // @C9A\n    {\n        m_pcmlDoc.setStringValue(name, value, type);                    // @C9A\n    }\n\n    /**\n    Sets the Java object value for the named element using a String input value\n    given indices to the data element.\n    <p>\n    This method is used when the string type cannot be determined until\n    run-time.  In those cases, the PCML document cannot be used to indicate\n    the string type so this method is used to set the value and the\n    string type of the input value.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for setting the value of an element in an array.\n    @param value The string value for the named element.\n    @param type The bidi string type, as defined by the CDRA (Character\n                Data Representation Architecture).\n    @exception PcmlException\n               If an error occurs.\n    @see com.ibm.as400.access.BidiStringType\n    */\n    public void setStringValue(String name, int[] indices, String value, int type)\n        throws PcmlException                                            // @C9A\n    {\n        m_pcmlDoc.setStringValue(name, value, new PcmlDimensions(indices), type);           // @C9A\n    }\n\n    /**\n    Sets the PCML or XPCML document resource.\n    The PCML or XPCML document resource will be loaded from the classpath.\n    The classpath will first be searched for a serialized resource.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML or XPCML source file.\n\n    @param docName The document resource name of the PCML document for the programs to be called.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    **/\n    public void setDocument(String docName)\n        throws PcmlException                                        // @C1A\n    {                                                               // @C1A\n        if (m_pcmlDoc != null)                                      // @C1A\n            throw new PcmlException(DAMRI.DOCUMENT_ALREADY_SET );   // @C1A\n\n        if (docName == null)                                        // @C1A\n            throw new NullPointerException(\"docName\");              // @C1A\n\n        m_pcmlDoc = loadPcmlDocument(docName, null,null);           // @C1A @C8C\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);                                // @C1A\n    }                                                               // @C1A\n\n\n    /**\n    Sets the XPCML document resource.\n    The XPCML document resource will be loaded from the classpath.\n\n    @param docName The document resource name of the PCML document for the programs to be called.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    **/\n    public void setDocument(String docName, InputStream xsdStream)\n        throws PcmlException                                        // @C1A\n    {                                                               // @C1A\n        if (m_pcmlDoc != null)                                      // @C1A\n            throw new PcmlException(DAMRI.DOCUMENT_ALREADY_SET );   // @C1A\n\n        if (docName == null)                                        // @C1A\n            throw new NullPointerException(\"docName\");              // @C1A\n\n        m_pcmlDoc = loadPcmlDocument(docName, null,xsdStream);      // @C1A @C8C\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);                                // @C1A\n    }                                                               // @C1A\n\n\n    /**\n    Sets the PCML or XPCML document resource.\n    The PCML or XPCML document resource will be loaded from the classpath.\n    The classpath will first be searched for a serialized resource.\n    If a serialized resource is not found, the classpath will be\n    searched for a PCML or XPCML source file.\n\n    @param docName The document resource name of the PCML document for the programs to be called.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    **/\n    public void setDocument(String docName, ClassLoader loader)     // @C8A\n        throws PcmlException                                        // @C8A\n    {                                                               // @C8A\n        if (m_pcmlDoc != null)                                      // @C8A\n            throw new PcmlException(DAMRI.DOCUMENT_ALREADY_SET );   // @C8A\n\n        if (docName == null)                                        // @C8A\n            throw new NullPointerException(\"docName\");              // @C8A\n\n        m_pcmlDoc = loadPcmlDocument(docName, loader,null);         // @C8A\n        if (m_as400 != null) m_pcmlDoc.setAs400(m_as400);                                // @C8A\n    }                                                               // @C8A\n\n    /**\n    Sets the PCML or XPCML document resource.\n    The document resource will be loaded from the classpath.\n\n    @param docName The document resource name of the PCML or XPCML document for the programs to be called.\n    The resource name can be a package qualified name. For example, \"com.myCompany.myPackage.myPcml\"\n    @param loader The ClassLoader that will be used when loading the specified document resource.\n    @param xsdStream An input stream that contains XML schema definitions that extend XPCML\n\n\t@exception PcmlException when the specified PCML document cannot be found\n    **/\n    public void setDocument(String docName, ClassLoader loader,InputStream xsdStream)     // @C8A\n        throws PcmlException                                        // @C8A\n    {                                                               // @C8A\n        if (m_pcmlDoc != null)                                      // @C8A\n            throw new PcmlException(DAMRI.DOCUMENT_ALREADY_SET );   // @C8A\n\n        if (docName == null)                                        // @C8A\n            throw new NullPointerException(\"docName\");              // @C8A\n\n        m_pcmlDoc = loadPcmlDocument(docName, loader, xsdStream);   // @C8A\n        m_pcmlDoc.setAs400(m_as400);                                // @C8A\n    }                                                               // @C8A\n\n\n    /**\n    Sets the system on which to call programs.\n\n    @param system  The system on which to call programs.\n\n    **/\n    public void setSystem(AS400 system)                             // @C1A\n    {                                                               // @C1A\n        if (system == null)                                         // @C1A\n            throw new NullPointerException(\"system\");               // @C1A\n\n        m_as400 = system;                                           // @C1A\n        m_pcmlDoc.setAs400(m_as400);                                // @C1A\n    }                                                               // @C1A\n\n    /**\n    Sets the Java object value for the named element.\n    <p>\n    If the input value provided is not an instance of the\n    correct Java class for the defined data type, it will be converted\n    to the correct Java class. For example, an element defined as \"<code>type=int length=2 precision=15</code>\",\n    will be converted to a Java Short object. In this case the value specified must be an instance of Number or String.\n    <p>\n    If the named element is an input value to a program, the value will\n    be converted to IBM i system data when {@link #callProgram(String) callProgram()} is called.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param value The java object value for the named element. The type of Object passed must be\n    the correct type for the element definition or a String that can be converted to the correct type.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public void setValue(String name, Object value)\n        throws PcmlException\n    {\n        m_pcmlDoc.setValue(name, value);\n    }\n\n    /**\n    Sets the Java object value for the named element\n    given indices to the data element.\n    If the data element is an array or is an element in a structure array, an index\n    must be specified for each dimension of the data.\n    <p>\n    If the input value provided is not an instance of the\n    correct Java class for the defined data type, it will be converted\n    to the correct Java class. For example, an element defined as \"<code>type=int length=2 precision=15</code>\",\n    will be converted to a Java Short object. In this case the value specified must be an instance of Number or String.\n    <p>\n    If the named element is an input value to a program, the value will\n    be converted to IBM i system data when {@link #callProgram(String) callProgram()} is called.\n\n    @param name The name of the &lt;data&gt; element in the PCML document.\n    @param indices An array of indices for setting the value of an element in an array.\n    @param value The java object value for the named element. The type of Object passed must be\n    the correct type for the element definition or a String that can be converted to the correct type.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public void setValue(String name, int[] indices, Object value)\n        throws PcmlException\n    {\n        m_pcmlDoc.setValue(name, value, new PcmlDimensions(indices));\n    }\n\n    /**\n    Allows for dynamically specifying the program path of the program to be called.\n\n    @param program The name of the &lt;program&gt; element in the PCML document.\n    @param path A String containing the path to the program object to be run on the system.\n    @exception PcmlException\n               If an error occurs.\n    @see #setDocument(String)\n    @see #ProgramCallDocument(AS400,String,InputStream,ClassLoader,InputStream,int)\n    */\n    public void setPath(String program, String path)                    // @D1A\n        throws PcmlException                                            // @D1A\n    {\n        m_pcmlDoc.setPath(program, path);                               // @D1A\n    }\n\n    /**\n    Allows the overriding of the threadsafe attribute of a program element.\n\n    @param program The name of the &lt;program&gt; element in the PCML document.\n    @param threadsafe A boolean indicating whether the named program element should be considered\n    thread safe (true) or not (false).\n    @exception PcmlException\n               If an error occurs.\n    */\n    public void setThreadsafeOverride(String program, boolean threadsafe)\n        throws PcmlException\n    {\n        m_pcmlDoc.setThreadsafeOverride(program, threadsafe);           // @C6A\n    }\n\n    /**\n    Gets the value of the override of the threadsafe attribute of a program element.\n\n    @param program The name of the &lt;program&gt; element in the PCML document.\n    @exception PcmlException\n               If an error occurs.\n    */\n    public boolean getThreadsafeOverride(String program)\n        throws PcmlException\n    {\n        return m_pcmlDoc.getThreadsafeOverride(program);           // @C6A\n    }\n\n\n    /**\n      Saves a PcmlDocument as a serialized resource.\n    **/\n    private static void savePcmlDocument(PcmlDocument pd)\n        throws PcmlException, IOException\n    {\n      String outFileName = pd.getDocName() + SystemResourceFinder.m_pcmlSerializedExtension;\n      BufferedOutputStream fos = null;\n      try\n      {\n        fos = new BufferedOutputStream(new FileOutputStream(outFileName));\n\n        savePcmlDocument(pd, fos);\n      }\n      finally\n      {\n        if (fos != null) fos.close();\n      }\n    }\n\n\n    /**\n      Saves a PcmlDocument as a serialized resource.\n    **/\n    private static void savePcmlDocument(PcmlDocument pd, OutputStream outStream)\n        throws PcmlException, IOException\n    {\n        pd.setSerializingWithData(false);\n        ObjectOutputStream out = null;\n\n        try\n        {\n          out = new ObjectOutputStream(outStream);\n          out.writeObject(pd);\n\n          String outFileName = pd.getDocName() + SystemResourceFinder.m_pcmlSerializedExtension;\n          Trace.log(Trace.PCML, SystemResourceFinder.format(DAMRI.PCML_SERIALIZED, new Object[] {outFileName} )); // @D2C\n        }\n        finally\n        {\n          if (out != null) out.close();\n        }\n    }\n\n\n    /**\n      Loads a serialized PcmlDocument or constructs the document from\n      a PCML source file.\n    **/\n    private static PcmlDocument loadPcmlDocument(String docName, ClassLoader loader, InputStream xsdStream)        // @C8C\n        throws PcmlException\n    {\n        PcmlDocument pd = null;\n\n\t\tpd = loadSerializedPcmlDocument(docName, loader);               // @C8C\n\n        // If a PcmlDocument was successfully loaded from a serialized file\n        // return the document loaded.\n        if (pd != null)\n            return pd;\n\n\t\tpd = loadZippedSerializedPcmlDocument(docName, loader);         // @C7A @C8C\n\n        // If a PcmlDocument was successfully loaded from a zipped serialized file\n        // return the document loaded.\n        if (pd != null)                                         // @C7A\n            return pd;                                          // @C7A\n\n\t\tpd = loadSourcePcmlDocument(docName, loader, xsdStream);                   // @C8C\n\n        return pd;\n    }\n\n    private static PcmlDocument loadSerializedPcmlDocumentFromStream(InputStream docStream)\n        throws PcmlException\n    {\n        PcmlDocument pd = null;\n        ObjectInputStream in = null;\n\n        try\n        {\n            // Try to open the serialized PCML document\n            in = new ObjectInputStream(docStream);\n            pd = (PcmlDocument)in.readObject();\n        }\n        catch (Exception e)\n        {\n          if (Trace.isTraceErrorOn())\n             e.printStackTrace(Trace.getPrintWriter());\n          throw new PcmlException(e);\n        }\n        finally\n        {\n          if (in != null) try { in.close(); } catch (Exception e) {}\n        }\n\n        return pd;\n    }\n\n    private static PcmlDocument loadSourcePcmlDocumentFromStream(String docName, InputStream docStream, ClassLoader loader, InputStream xsdStream, boolean isXPCML) throws PcmlException\n    {\n      PcmlDocument pd = null;\n\n      // Construct the PCML document from a source file\n      try\n      {\n          PcmlSAXParser psp = new PcmlSAXParser(docName, docStream, xsdStream, isXPCML, exceptionIfParseError_);\n          pd = psp.getPcmlDocument();\n      }\n      catch (ParseException pe)\n      {\n          if (Trace.isTraceErrorOn())                         \n            pe.printStackTrace(Trace.getPrintWriter());       \n          pe.reportErrors();\n          throw new PcmlException(pe);\n      }\n      catch (PcmlSpecificationException pse)\n      {\n        if (Trace.isTraceErrorOn())                         \n          pse.printStackTrace(Trace.getPrintWriter());       \n          pse.reportErrors();\n          throw new PcmlException(pse);\n      }\n      catch (RuntimeException e)\n      {\n        if (Trace.isTraceErrorOn())                         \n          e.printStackTrace(Trace.getPrintWriter());       \n        Throwable cause = e.getCause();\n        if (cause instanceof PcmlSpecificationException)\n        {\n          PcmlSpecificationException pse = (PcmlSpecificationException)cause;\n          pse.reportErrors();\n          throw new PcmlException(pse);\n        }\n        else\n        {\n          if (Trace.isTraceErrorOn()) //@E0A\n            e.printStackTrace(Trace.getPrintWriter()); //@E0A\n          throw new PcmlException(e);\n        }\n      }\n      catch (Exception e)\n      {\n        if (Trace.isTraceErrorOn())\n           e.printStackTrace(Trace.getPrintWriter());\n        throw new PcmlException(e);\n      }\n\n      return pd;\n    }\n\n    /**\n      Loads a serialized PcmlDocument from a serialized file.\n    **/\n    private static PcmlDocument loadSerializedPcmlDocument(String docName, ClassLoader loader)  // @C8C\n        throws PcmlException\n    {\n        PcmlDocument pd = null;\n        InputStream is = null;\n        ObjectInputStream in = null;\n\n        // First try to find a serialized PCML document\n        try\n        {\n            // Try to open the serialized PCML document\n            is = SystemResourceFinder.getSerializedPCMLDocument(docName, loader);   // @C8C\n\n            in = new ObjectInputStream(is);\n            pd = (PcmlDocument)in.readObject();\n        }\n        catch (MissingResourceException e)\n        {\n            // Ignore exception and try looking for PCML source (below)\n        }\n        catch (StreamCorruptedException e)\n        {\n            // Ignore exception and try looking for zipped serialized PCML (below)\n        }\n        catch (IOException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            throw new PcmlException(e);\n        }\n        catch (ClassNotFoundException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            throw new PcmlException(e);\n        }\n        finally\n        {\n          if (in != null) try { in.close(); } catch (Exception e) {\n            if (Trace.isTraceErrorOn())                        \n              e.printStackTrace(Trace.getPrintWriter());      \n          }\n          if (is != null) try { is.close(); } catch (Exception e) {\n            if (Trace.isTraceErrorOn())                        \n              e.printStackTrace(Trace.getPrintWriter());      \n            \n          }\n        }\n\n        return pd;\n    }\n\n    /**\n      Loads a serialized PcmlDocument from a serialized file.\n    **/\n    private static PcmlDocument loadZippedSerializedPcmlDocument(String docName, ClassLoader loader)    // @C8C\n        throws PcmlException\n    {\n        PcmlDocument pd = null;\n        InputStream is = null;\n        GZIPInputStream gzis = null;\n        ObjectInputStream in = null;\n\n        // First try to find a serialized PCML document\n        try\n        {\n            // Try to open the serialized PCML document\n            is = SystemResourceFinder.getSerializedPCMLDocument(docName, loader);       // @C8C\n\n            gzis = new GZIPInputStream(is);\n            in = new ObjectInputStream(gzis);\n            pd = (PcmlDocument)in.readObject();\n        }\n        catch (MissingResourceException e)\n        {\n            // Ignore exception and try looking for PCML source (below)\n        }\n        catch (IOException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            throw new PcmlException(e);\n        }\n        catch (ClassNotFoundException e)\n        {\n            if (Trace.isTraceErrorOn())                         // @C4A\n               e.printStackTrace(Trace.getPrintWriter());       // @C4C\n            throw new PcmlException(e);\n        }\n        finally\n        {\n          if (in != null)   try { in.close(); } catch (Exception e) { \n            if (Trace.isTraceErrorOn())                        \n              e.printStackTrace(Trace.getPrintWriter());      \n\n          }\n          if (gzis != null) try { gzis.close(); } catch (Exception e) {\n            if (Trace.isTraceErrorOn())                        \n              e.printStackTrace(Trace.getPrintWriter());      \n\n          }\n          if (is != null)   try { is.close(); } catch (Exception e) {\n            if (Trace.isTraceErrorOn())                        \n              e.printStackTrace(Trace.getPrintWriter());      \n\n          }\n        }\n\n        return pd;\n    }\n\n    /**\n      Loads a PcmlDocument from a PCML source file.\n    **/\n    private static PcmlDocument loadSourcePcmlDocument(String docName, ClassLoader loader, InputStream xsdStream)      // @C8C\n        throws PcmlException\n    {\n\n        PcmlDocument pd = null;\n\n        // Construct the PCML document from a source file\n        try\n        {\n            InputStream docStream = SystemResourceFinder.getPCMLDocument(docName, loader);\n            boolean isXPCML = SystemResourceFinder.isXPCML(docName,loader);\n            PcmlSAXParser psp = new PcmlSAXParser(docName, docStream, xsdStream, isXPCML, exceptionIfParseError_);         // @C2A @C8C\n            pd = psp.getPcmlDocument();                             // @C2A\n        }\n        catch (ParseException pe)\n        {\n            pe.reportErrors();\n            throw new PcmlException(pe);\n        }\n        catch (PcmlSpecificationException pse)\n        {\n            pse.reportErrors();\n            throw new PcmlException(pse);\n        }\n        catch (RuntimeException e)\n        {\n          Throwable cause = e.getCause();\n          if (cause instanceof PcmlSpecificationException)\n          {\n            PcmlSpecificationException pse = (PcmlSpecificationException)cause;\n            pse.reportErrors();\n            throw new PcmlException(pse);\n          }\n          else\n          {\n            if (Trace.isTraceErrorOn()) //@E0A\n              e.printStackTrace(Trace.getPrintWriter()); //@E0A\n            throw new PcmlException(e);\n          }\n        }\n        catch (Exception e) //@E0A\n        {\n          if (Trace.isTraceErrorOn()) //@E0A\n             e.printStackTrace(Trace.getPrintWriter()); //@E0A\n          throw new PcmlException(e);\n        }\n\n        return pd;\n    }\n\n\n    // @E1A -- ALL NEW XPCML methods....\n    /**\n     Generates XPCML representing the data associated with the passed-in program name.\n     Note: XPCML cannot be generated from a serialized PCML file.\n     XPCML is XML based on the XML schema defined in xpcml.xsd.   XPCML is similar\n     to PCML but allows for better validation of parameters and allows parameter\n     data to be input and output within an XML document.  PCML is data-less in\n     that only parameter formats are input via PCML.  In PCML, data values are set using\n     the setValue methods of the ProgramCallDocument class, and data values are\n     gotten using the getValue methods of ProgramCallDocument.  In XPCML, data values\n     can be specified directly within the XPCML source document, and data values can be output\n     as XML using the generateXPCML method.\n     Throws an XmlException if this object contains no data.\n     @param pgmName The program to generate XPCML for\n     @param outputStream The output stream to which to write the text.\n     @exception IOException  If an error occurs while writing the data.\n     @exception XmlException  If an error occurs while processing XPCML.\n     **/\n    public void generateXPCML(String pgmName, OutputStream outputStream)\n      throws IOException, XmlException\n    {\n      if (outputStream == null) {\n        throw new NullPointerException(\"outputStream\");\n      }\n      if (m_pcmlDoc == null) {\n        throw new XmlException(DAMRI.DOCUMENT_NOT_SET );\n      }\n      m_pcmlDoc.generateXPCML(pgmName, outputStream);\n    }\n\n\n    // @E2C -- Added more info on XPCML.  Changed all RFML references to XPCML.\n    /**\n     Generates XPCML representing the data contained in the entire PCML node tree.\n     Note: XPCML cannot be generated from a serialized PCML file.\n     XPCML is XML based on the XML schema defined in xpcml.xsd.   XPCML is similar\n     to PCML but allows for better validation of parameters and allows parameter\n     data to be input and output within an XML document.  PCML is data-less in\n     that only parameter formats are input via PCML.  In PCML, data values are set using\n     the setValue methods of the ProgramCallDocument class and data values are\n     gotten using the getValue methods of ProgramCallDocument.  In XPCML, data values\n     can be specified directly within the XPCML document, and data values can be output\n     as XML using the generateXPCML method.\n\n     Throws an XmlException if this object contains no data.\n\n     @param outputStream The output stream to which to write the text.\n     @exception IOException  If an error occurs while writing the data.\n     @exception XmlException  If an error occurs while processing XPCML.\n     **/\n    public void generateXPCML(OutputStream outputStream)\n      throws IOException, XmlException\n    {\n      if (outputStream == null) {\n        throw new NullPointerException(\"outputStream\");\n      }\n      if (m_pcmlDoc == null) {\n        throw new XmlException(DAMRI.DOCUMENT_NOT_SET );\n      }\n      m_pcmlDoc.generateXPCML(null, outputStream);\n    }\n\n\n    /**\n     Generates XPCML representing the data contained in the entire PCML node tree.\n     Note: XPCML cannot be generated from a serialized PCML file.\n     XPCML is XML based on the XML schema defined in xpcml.xsd.   XPCML is similar\n     to PCML but allows for better validation of parameters and allows parameter\n     data to be input and output within an XML document.  PCML is data-less in\n     that only parameter formats are input via PCML.  In PCML, data values are set using\n     the setValue methods of the ProgramCallDocument class and data values are\n     gotten using the getValue methods of ProgramCallDocument.  In XPCML, data values\n     can be specified directly within the XPCML document, and data values can be output\n     as XML using the generateXPCML method.\n     Throws an XmlException if this object contains no data.\n\n     @param fileName The pathname of the file to which to write the text.\n     @exception IOException  If an error occurs while writing the data.\n     @exception XmlException  If an error occurs while processing XPCML.\n     **/\n    public void generateXPCML(String fileName)\n      throws IOException, XmlException\n    {\n      if (fileName == null) {\n        throw new NullPointerException(\"fileName\");\n      }\n      FileOutputStream fos = null;\n      try\n      {\n        fos = new FileOutputStream(fileName);\n        generateXPCML(null, fos);\n      }\n      finally {\n        if (fos != null) fos.close();\n      }\n    }\n\n    /**\n     Generates XPCML representing the data contained for the passed in program name.\n     Note: XPCML cannot be generated from a serialized PCML file.\n     XPCML is XML based on the XML schema defined in xpcml.xsd.   XPCML is similar\n     to PCML but allows for better validation of parameters and allows parameter\n     data to be input and output within an XML document.  PCML is data-less in\n     that only parameter formats are input via PCML.  In PCML, data values are set using\n     the setValue methods of the ProgramCallDocument class and data values are\n     gotten using the getValue methods of ProgramCallDocument.  In XPCML, data values\n     can be specified directly within the XPCML document, and data values can be output\n     as XML using the generateXPCML method.\n     Throws an XmlException if this object contains no data.\n\n     @param pgmName  The program name to generate XPCML for.\n     @param fileName The pathname of the file to which to write the text.\n     @exception IOException  If an error occurs while writing the data.\n     @exception XmlException  If an error occurs while processing XPCML.\n     **/\n    public void generateXPCML(String pgmName,String fileName)\n      throws IOException, XmlException\n    {\n      if (fileName == null) {\n        throw new NullPointerException(\"fileName\");\n      }\n      if (pgmName == null) {\n        throw new NullPointerException(\"pgmName\");\n      }\n      FileOutputStream fos = null;\n      try\n      {\n        fos = new FileOutputStream(fileName);\n        generateXPCML(pgmName, fos);\n      }\n      finally {\n        if (fos != null) fos.close();\n      }\n    }\n\n     // ******************************\n     // @E0A -- New method           *\n     // ******************************\n     /**\n      Sets the XSD name that will appear in the generated &lt;xpcml&gt; tag from the <tt>generateXPCML()</tt> methods.\n      If name is not set then \"xpcml.xsd\" will appear in &lt;xpcml&gt; tag.  This allows the user\n                     to override the default and put in the name of their own xsd that was\n                     used in condensing the XPCML output.\n\n     @param xsdName  The XSD name to appear in the &lt;xpcml&gt; tag when XPCML is output using the\n                     generateXPCML method.\n    **/\n\n    public void setXsdName(String xsdName)\n    {\n        m_pcmlDoc.setXsdName(xsdName);\n    }\n\n\n     // ******************************\n     // @E0A -- New method           *\n     // ******************************\n     /**\n      Returns the value of the XSD name to be used on the &lt;xpcml&gt; tag when\n                     generating XPCML.\n\n     @return The String \"xsdName\" value for this program object.\n     **/\n\n    public String getXsdName()\n    {\n        return m_pcmlDoc.getXsdName();\n    }\n\n\n    public void endInternal2(RJob rJob, int delayTime)\n\tthrows ResourceException\n\t{\n\t    // Validate the properties.\n\t    if (rJob.name_ == null)\n\t        throw new ExtendedIllegalStateException(\"name\", ExtendedIllegalStateException.PROPERTY_NOT_SET);\n\t    if (rJob.number_ == null)\n\t        throw new ExtendedIllegalStateException(\"number\", ExtendedIllegalStateException.PROPERTY_NOT_SET);\n\t    if (rJob.user_ == null)\n\t        throw new ExtendedIllegalStateException(\"user\", ExtendedIllegalStateException.PROPERTY_NOT_SET);\n\t\n\t    // Establish the connection if needed.\n\t    if (!rJob.isConnectionEstablished())\n\t        rJob.establishConnection();\n\t\n\t    // Issue the ENDJOB CL command.\n\t    AS400 sys = null;\n\t    try {\n\t        StringBuffer buffer = new StringBuffer();\n\t        buffer.append(\"ENDJOB JOB(\");\n\t        buffer.append(rJob.number_);\n\t        buffer.append('/');\n\t        buffer.append(rJob.user_);\n\t        buffer.append('/');\n\t        buffer.append(rJob.name_);\n\t        buffer.append(\") OPTION(\");\n\t        if (delayTime == 0) {\n\t            buffer.append(\"*IMMED)\");\n\t        }\n\t        else {\n\t            buffer.append(\"*CNTRLD)\");\n\t            if (delayTime > 0) {\n\t                buffer.append(\" DELAY(\");\n\t                buffer.append(delayTime);\n\t                buffer.append(\")\");\n\t            }\n\t        }\n\t        String endJob = buffer.toString();\n\t\n\t        if (Trace.isTraceOn())\n\t            Trace.log(Trace.INFORMATION, \"Ending the job:\" + endJob);\n\t\n\t        // Use a separate connection, in case the job we're trying to\n\t        // end is the Remote Command Call host server.             @A1a\n\t        sys = new AS400(rJob.getSystem());                            //@A1a\n\t        CommandCall commandCall = new CommandCall(sys, endJob);  //@A1c\n\t        boolean success = commandCall.run();\n\t        if (!success)\n\t            throw new ResourceException(commandCall.getMessageList());\n\t    }\n\t    catch(Exception e) {\n\t        throw new ResourceException(e);\n\t    }\n\t    finally {\n\t        if (sys != null)  sys.disconnectAllServices();\n\t    }\n\t}\n\n\t/**\n     Transforms a PCML stream to its equivalent XPCML stream.\n     Throws an XmlException if this object contains no data.\n\n     @param pcmlStream The PCML input stream.\n     @param xpcmlStream  The output XPCML stream.\n     @exception IOException  If an error occurs while writing the data.\n     @exception PcmlException  If an error occurs while processing XPCML.\n\n     **/\n\n    public static void transformPCMLToXPCML(InputStream pcmlStream, OutputStream xpcmlStream)\n           throws IOException, PcmlException, TransformerException, SAXException\t\n    \t{\n\n           if (pcmlStream == null) {\n             throw new NullPointerException(\"pcmlStream\");\n           }\n\n           if (xpcmlStream == null) {\n             throw new NullPointerException(\"xpcmlStream\");\n           }\n\n           // Transform the PCML document to its equivalent XPCML document\n           XPCMLHelper.doTransform(\"pcml_xpcml.xsl\",pcmlStream, xpcmlStream); //@CRS\n      }\n\n    /**\n     Transforms a fully specified XPCML stream to a more condensed XPCML stream\n     and an XSD stream representing the new type definitions created while condensing.\n     Throws an XmlException if this object contains no data.\n\n     @param fullStream The full XPCML input stream.\n     @param xsdStream  The output xsd stream.\n     @param condensedStream  The output condensed XPCML stream.\n     @param xsdStreamName  The name of the xsd stream (\"name.xsd\") that will be created\n     @exception IOException  If an error occurs while writing the data.\n     @exception PcmlException  If an error occurs while processing XPCML.\n\n     **/\n\n    public static void condenseXPCML(InputStream fullStream, OutputStream xsdStream, OutputStream condensedStream, String xsdStreamName)\n           throws IOException, PcmlException, TransformerException, SAXException\t\n    \t{\n           String xpcmlName=\"\";\n\n           if (fullStream == null) {\n             throw new NullPointerException(\"fullStream\");\n           }\n\n           if (xsdStream == null) {\n             throw new NullPointerException(\"xsdStream\");\n           }\n\n           if (condensedStream == null) {\n             throw new NullPointerException(\"condensedStream\");\n           }\n\n           if (xsdStreamName == null) {\n             throw new NullPointerException(\"xsdStreamName\");\n           }\n\n           // Copy input stream fullStream into twoOutputStream\n           ByteArrayOutputStream outStream1 = new ByteArrayOutputStream();\n\n           byte[] bytesIn = new byte[1000];\n           int bytesRead = 0;\n           bytesRead = fullStream.read(bytesIn);\n\n           while (bytesRead != -1)\n           {\n              outStream1.write(bytesIn,0,bytesRead);\n              bytesRead = fullStream.read(bytesIn);\n           }\n\n           outStream1.flush();\n           outStream1.close();\n\n           // Cache the line count of the header\n           ByteArrayInputStream inStreamFull = new ByteArrayInputStream(outStream1.toByteArray());\n           LineNumberReader lnr = new LineNumberReader(new InputStreamReader(inStreamFull));\n           try\n           {\n             String line = lnr.readLine();\n             boolean found=false;\n             while (line != null && !found)\n             {\n               // Look for xpcml tag\n               if (line.indexOf(\"xsi:noNamespaceSchemaLocation=\") != -1)\n               {\n                  found = true;\n                  int index1 = line.indexOf(\"xsi:noNamespaceSchemaLocation=\");\n                  int index2=0;\n                  index2 = line.indexOf(\"'\", index1);\n                  int index3=0;\n                  if (index2 == -1)\n                  {\n                     index2 = line.indexOf(\"\\\"\",index1);\n                     if (index2 != -1)\n                       index3 = line.indexOf(\"\\\"\", index2+1);\n                  }\n                  else\n                  {\n                     index3 = line.indexOf(\"'\",index2+1);\n                  }\n                  xpcmlName = line.substring(index2+1,index3);\n                  continue;\n               }\n               if (line.indexOf(\"xsi:noNamespaceSchemaLocation =\") != -1)\n               {\n                  found = true;\n                  int index1 = line.indexOf(\"xsi:noNamespaceSchemaLocation =\");\n                  int index2=0;\n                  index2 = line.indexOf(\"'\", index1);\n                  int index3=0;\n                  if (index2 == -1)\n                  {\n                     index2 = line.indexOf(\"\\\"\",index1);\n                     if (index2 != -1)\n                       index3 = line.indexOf(\"\\\"\", index2+1);\n                  }\n                  else\n                  {\n                     index3 = line.indexOf(\"'\",index2+1);\n                  }\n                  xpcmlName = line.substring(index2+1,index3);\n                  continue;\n               }\n               line = lnr.readLine();\n             }\n           }\n           catch (IOException e)\n           {\n             Trace.log(Trace.PCML, \"Error when reading input stream in condenseXPCML\");\n             if (Trace.isTraceErrorOn())\n               e.printStackTrace(Trace.getPrintWriter());\n             throw new PcmlException(e);\n           }\n           if (xpcmlName == \"\")\n              xpcmlName=\"xpcml.xsd\";\n\n           // Write contents of ByteArrayOutputStream to ByteArrayInputStream\n           ByteArrayInputStream inStream1 = new ByteArrayInputStream(outStream1.toByteArray());  // no need to close byte-array stream\n           ByteArrayInputStream inStream2 = new ByteArrayInputStream(outStream1.toByteArray());  // no need to close byte-array stream\n\n           // Create new XSD type definitions based on full XPCML stream\n           XPCMLHelper.doCondenseTransform(\"xpcml_xsd.xsl\",inStream1, xsdStream, xpcmlName); //@CRS\n           // Create condensed XPCML using XSD and full XPCML stream\n           XPCMLHelper.doCondenseTransform(\"xpcml_basic.xsl\",inStream2, condensedStream, xsdStreamName); //@CRS\n\n      }\n\n\n    // Traces a warning message about a null-valued parameter.\n    private static final void warnNull(String parmName)\n    {\n      if (Trace.isTraceOn()) Trace.log(Trace.WARNING, \"Null value specified for '\" + parmName + \"' parameter on ProgramCallDocument constructor.\");\n    }\n\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 3,
                "candidates": [
                    {
                        "lineStart": 1898,
                        "lineEnd": 2021,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "description": "move method to com.ibm.as400.data.XPCMLHelper\nRationale: The method condenseXPCML is responsible for transforming XPCML streams and creating XSD definitions, which aligns with the functionality typically associated with a helper class like XPCMLHelper that deals with XPCML processing.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1871,
                        "lineEnd": 1896,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "description": "move method to com.ibm.as400.data.XPCMLHelper\nRationale: The method transformPCMLToXPCML directly calls XPCMLHelper.doTransform, indicating that it is closely related to the functionality provided by the XPCMLHelper class, making it a suitable candidate for relocation.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 1813,
                        "lineEnd": 1869,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to com.ibm.as400.resource.RJob\nRationale: The method endInternal2 operates directly on the properties of the RJob instance, validating its state and establishing a connection if needed. It is closely tied to the job's attributes and behavior, making RJob the most appropriate class for this method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 20057
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "endInternal2",
                            "method_signature": "public void endInternal2(RJob rJob, int delayTime) throws ResourceException",
                            "target_class": "JobManager",
                            "rationale": "The method endInternal2 is responsible for managing job termination, which is more aligned with job management responsibilities than with the ProgramCallDocument class."
                        },
                        {
                            "method_name": "transformPCMLToXPCML",
                            "method_signature": "public static void transformPCMLToXPCML(InputStream pcmlStream, OutputStream xpcmlStream) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLTransformer",
                            "rationale": "This method is focused on transforming PCML to XPCML, which is a transformation concern and should be handled by a dedicated transformer class."
                        },
                        {
                            "method_name": "condenseXPCML",
                            "method_signature": "public static void condenseXPCML(InputStream fullStream, OutputStream xsdStream, OutputStream condensedStream, String xsdStreamName) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLCondensor",
                            "rationale": "The condenseXPCML method is specifically about condensing XPCML, which should be the responsibility of a dedicated class that handles XPCML processing."
                        }
                    ],
                    "llm_response_time": 6176
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "endInternal2",
                            "method_signature": "public void endInternal2(RJob rJob, int delayTime) throws ResourceException",
                            "target_class": "JobManager",
                            "rationale": "The method endInternal2 is responsible for managing job termination, which is more aligned with job management functionality rather than the responsibilities of the ProgramCallDocument class."
                        },
                        {
                            "method_name": "transformPCMLToXPCML",
                            "method_signature": "public static void transformPCMLToXPCML(InputStream pcmlStream, OutputStream xpcmlStream) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLTransformer",
                            "rationale": "The method transformPCMLToXPCML is focused on transforming PCML to XPCML, which is a transformation concern and should be handled by a dedicated transformer class."
                        },
                        {
                            "method_name": "condenseXPCML",
                            "method_signature": "public static void condenseXPCML(InputStream fullStream, OutputStream xsdStream, OutputStream condensedStream, String xsdStreamName) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLCondensor",
                            "rationale": "The method condenseXPCML is responsible for condensing XPCML streams, which is a specific transformation task that should be encapsulated in a dedicated class."
                        }
                    ],
                    "llm_response_time": 5616
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "endInternal2",
                            "method_signature": "public void endInternal2(RJob rJob, int delayTime) throws ResourceException",
                            "target_class": "JobManager",
                            "rationale": "The method endInternal2 is responsible for managing job termination, which is more aligned with job management functionality than with the purpose of the ProgramCallDocument class."
                        },
                        {
                            "method_name": "transformPCMLToXPCML",
                            "method_signature": "public static void transformPCMLToXPCML(InputStream pcmlStream, OutputStream xpcmlStream) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLTransformer",
                            "rationale": "The method transformPCMLToXPCML is focused on transforming PCML to XPCML, which is a transformation concern and should be handled by a dedicated transformer class."
                        },
                        {
                            "method_name": "condenseXPCML",
                            "method_signature": "public static void condenseXPCML(InputStream fullStream, OutputStream xsdStream, OutputStream condensedStream, String xsdStreamName) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLCondensor",
                            "rationale": "The method condenseXPCML is responsible for condensing XPCML streams, which is a specific transformation task that should be encapsulated in a dedicated class."
                        }
                    ],
                    "llm_response_time": 5842
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "endInternal2",
                            "method_signature": "public void endInternal2(RJob rJob, int delayTime) throws ResourceException",
                            "target_class": "JobManager",
                            "rationale": "The method endInternal2 is responsible for managing job termination, which is more aligned with job management responsibilities than with the ProgramCallDocument class."
                        },
                        {
                            "method_name": "transformPCMLToXPCML",
                            "method_signature": "public static void transformPCMLToXPCML(InputStream pcmlStream, OutputStream xpcmlStream) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLTransformer",
                            "rationale": "This method is focused on transforming PCML to XPCML, which is a transformation concern and should be handled by a dedicated transformer class."
                        },
                        {
                            "method_name": "condenseXPCML",
                            "method_signature": "public static void condenseXPCML(InputStream fullStream, OutputStream xsdStream, OutputStream condensedStream, String xsdStreamName) throws IOException, PcmlException, TransformerException, SAXException",
                            "target_class": "XPCMLCondensor",
                            "rationale": "The condenseXPCML method is specifically about condensing XPCML, which should be the responsibility of a dedicated class that handles XPCML processing."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "condenseXPCML",
                    "transformPCMLToXPCML",
                    "endInternal2"
                ],
                "llm_response_time": 2346
            },
            "targetClassMap": {
                "condenseXPCML": {
                    "target_classes": [
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.3765672909746007
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.6172580559706903
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.6271049581116438
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.38067818673885007
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.19367285212982108
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.628744623002583
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.40972800660333825
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.6105358687552762
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.45105752222311163
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.4734928388898259
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.5186220097597671
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.6536583705843837
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.33383037620596717
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.7015697590450435
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.3783904412449756
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.414738970188735
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.23465270060995655
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.6898516386024158
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.6880670131809189
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.4582813556480455
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.6251201956855112
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.6728291356274912
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.5248462387194186
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.316511470546188
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.5413232647944841
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.49896583177960724
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.36537224179341954
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.322495931123742
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.46745000271225334
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.7445309154299529
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.504514783857638
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.48243499106011617
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.5066390806343564
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.40244886693777915
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.29970353721825804
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.5895171262998592
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.7553509600554871
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.407144427919143
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.4556894178449329
                        },
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.2717443762988976
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.6947767207118349
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.6197416191570789
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.3534724183404498
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.14054782482444636
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.6901218682333052
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.4100313965054079
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.6592743056955005
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.4971845101816648
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.7456412901555219
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.5670731609771889
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.643948183783359
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.35089652829916407
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.6540522949672394
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.5034698542618196
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.4219131521474504
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.3547964997610225
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.7323943646032743
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.7005012341783255
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.48838137089892986
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.6129218271545027
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.7153348878337686
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.6126779391097601
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.3217984950428556
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.5527329517452261
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.5946673917782455
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.470188926272963
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.30975237299504105
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.5667098431495033
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.7527823320710303
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.518728384865005
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.5899508871404848
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.5159236077594765
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.45967364147002276
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.32774830213475725
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.6682636753154775
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.677521808473057
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.44662848687336815
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.5527585943448606
                        },
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.2716802354522363
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.6966347991669658
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.586462789926043
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.37614690276728696
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.14054782482444636
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.6902801623120879
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.4046311907097656
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.6583512365879538
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.5130034750969357
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.745820947034839
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.5694817678446785
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.6527944809470644
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.3528268312182898
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.6572564909478467
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.5116733534331043
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.4204467174999459
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.3890689522115828
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.7305171149187962
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.7005182918761156
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.5065957537636652
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.619508140996124
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.7234651346165792
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.6166755895391479
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.35492653911236266
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.5599976182596097
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.6111650292898236
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.48432049714111974
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.342250141659371
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.5700947775271181
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.7433363283271502
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.5273267990410989
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.5974256129808101
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.4956360939871625
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.47681093917305933
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.3638312766005801
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.6698405905262299
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.6830110789019732
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.4664958567887974
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.5621517557020906
                        },
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.2717443762988976
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.6947767207118349
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.6197416191570789
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.3534724183404498
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.14054782482444636
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.6901218682333052
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.4100313965054079
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.6592743056955005
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.4971845101816648
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.7456412901555219
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.5670731609771889
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.643948183783359
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.35089652829916407
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.6540522949672394
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.5034698542618196
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.4219131521474504
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.3547964997610225
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.7323943646032743
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.7005012341783255
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.48838137089892986
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.6129218271545027
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.7153348878337686
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.6126779391097601
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.3217984950428556
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.5527329517452261
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.5946673917782455
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.470188926272963
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.30975237299504105
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.5667098431495033
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.7527823320710303
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.518728384865005
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.5899508871404848
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.5159236077594765
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.45967364147002276
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.32774830213475725
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.6682636753154775
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.677521808473057
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.44662848687336815
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.5527585943448606
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "XPCMLHelper",
                        "SystemResourceFinder",
                        "RfmlRecordFormat",
                        "PcmlProgram",
                        "PcmlSAXParser",
                        "PcmlDataValues",
                        "RfmlDocument",
                        "RfmlSAXParser",
                        "PcmlData",
                        "PcmlStruct",
                        "RecordFormatDocument",
                        "PcmlDocNode",
                        "PcmlDocument",
                        "PcmlNode",
                        "ParseException",
                        "PcmlDataVector",
                        "PcmlMessageLog",
                        "DocNodeDescriptor",
                        "XMLErrorHandler",
                        "PcmlSpecificationException",
                        "PcmlDimensions",
                        "StructDescriptor",
                        "PcmlAttributeList",
                        "PcmlDocRoot",
                        "XmlException",
                        "DataDescriptor",
                        "ResourceLoader",
                        "ProgramDescriptor",
                        "RecordFormatDescriptor",
                        "PcmlAttribute",
                        "RfmlStruct",
                        "PcmlException",
                        "RfmlData",
                        "DAMRI",
                        "SystemClassLoader",
                        "PcmlDescriptor",
                        "PcmlNodeType",
                        "RfmlDescriptor",
                        "Descriptor"
                    ],
                    "llm_response_time": 1299,
                    "similarity_computation_time": 5930,
                    "similarity_metric": "cosine"
                },
                "transformPCMLToXPCML": {
                    "target_classes": [
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.21179589015887929
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.4168172493733724
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.3088935890544522
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.31709818672283435
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.26772851592051233
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.42307303236086674
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.3014854404285189
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.3511839459315007
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.22459751605507472
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.2825533755885794
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.3430341221632166
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.4889516967646544
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.10153461651336192
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.6195815291269746
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.33682604570185554
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.1881034716665781
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.24711661107888894
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.47007911287727866
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.5369438872551562
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.3324017810063613
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.38290465686620706
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.4258122514306636
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.3067386515957241
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.3302607529641595
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.31469182370318033
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.3981630907896169
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.3509171039242196
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.34701310999857343
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.3223133756761372
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.4713255023362331
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.3580033815589712
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.40986142728527303
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.27909962285327905
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.3716247331497075
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.2917148778444757
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.6216072554433176
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.4919710452271076
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.37990774789048
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.3339079571763121
                        },
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.13062970971673757
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.40072349951857167
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.25104279302257243
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.20710018887451917
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.08047572011413082
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.38760498971549767
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.24974213505257487
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.312170007795351
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.24809106804563402
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.3444165228742817
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.2793968480157845
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.3950025402761049
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.1186632443173688
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.4099273068623479
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.2787760720267345
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.18747070998966744
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.2754211041653693
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.3700731671826021
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.4173220508220457
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.3587375953973916
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.35486262749945957
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.4028522474463793
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.3237641852291173
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.2333664145937279
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.29026730229985415
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.3609008432428234
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.33205735647907086
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.2164725297554095
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.2597670357064914
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.3783277482131607
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.33596468182426004
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.372537975699926
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.2836880022264773
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.3523848455463737
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.2587516028631446
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.4720524695661405
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.39872916841090117
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.3174619397427218
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.3003749930442465
                        },
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.1285398626524534
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.39765488677586724
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.2204461592667235
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.1861467969411635
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.08047572011413082
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.38664192329988367
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.20804471908288188
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.31062521327445675
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.23952739961867842
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.3403828379826318
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.2700304541283765
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.3981845667060667
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.11193324221211003
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.4095774904807194
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.2690359146090172
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.1712054070549991
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.2587516028631446
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.36793162446212374
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.4139255190973813
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.3616726978772017
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.3483873867950317
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.4002252242170566
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.3197708261460665
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.21677437400579747
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.2876676498426658
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.34029332315067345
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.3297146518383836
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.1930427573587431
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.25443688194419717
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.3661138501066452
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.33483898145921054
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.3699271880721806
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.2485239779830632
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.3490862036288189
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.24640556370331668
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.47510256894966
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.38479105002790337
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.3070118225813345
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.2950568851507872
                        },
                        {
                            "class_name": "DAMRI",
                            "similarity_score": 0.13062970971673757
                        },
                        {
                            "class_name": "PcmlData",
                            "similarity_score": 0.40072349951857167
                        },
                        {
                            "class_name": "PcmlNode",
                            "similarity_score": 0.25104279302257243
                        },
                        {
                            "class_name": "RfmlData",
                            "similarity_score": 0.20710018887451917
                        },
                        {
                            "class_name": "Descriptor",
                            "similarity_score": 0.08047572011413082
                        },
                        {
                            "class_name": "PcmlStruct",
                            "similarity_score": 0.38760498971549767
                        },
                        {
                            "class_name": "RfmlStruct",
                            "similarity_score": 0.24974213505257487
                        },
                        {
                            "class_name": "PcmlDocNode",
                            "similarity_score": 0.312170007795351
                        },
                        {
                            "class_name": "PcmlDocRoot",
                            "similarity_score": 0.24809106804563402
                        },
                        {
                            "class_name": "PcmlProgram",
                            "similarity_score": 0.3444165228742817
                        },
                        {
                            "class_name": "XPCMLHelper",
                            "similarity_score": 0.2793968480157845
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.3950025402761049
                        },
                        {
                            "class_name": "PcmlNodeType",
                            "similarity_score": 0.1186632443173688
                        },
                        {
                            "class_name": "RfmlDocument",
                            "similarity_score": 0.4099273068623479
                        },
                        {
                            "class_name": "XmlException",
                            "similarity_score": 0.2787760720267345
                        },
                        {
                            "class_name": "PcmlAttribute",
                            "similarity_score": 0.18747070998966744
                        },
                        {
                            "class_name": "PcmlException",
                            "similarity_score": 0.2754211041653693
                        },
                        {
                            "class_name": "PcmlSAXParser",
                            "similarity_score": 0.3700731671826021
                        },
                        {
                            "class_name": "RfmlSAXParser",
                            "similarity_score": 0.4173220508220457
                        },
                        {
                            "class_name": "DataDescriptor",
                            "similarity_score": 0.3587375953973916
                        },
                        {
                            "class_name": "ParseException",
                            "similarity_score": 0.35486262749945957
                        },
                        {
                            "class_name": "PcmlDataValues",
                            "similarity_score": 0.4028522474463793
                        },
                        {
                            "class_name": "PcmlDataVector",
                            "similarity_score": 0.3237641852291173
                        },
                        {
                            "class_name": "PcmlDescriptor",
                            "similarity_score": 0.2333664145937279
                        },
                        {
                            "class_name": "PcmlDimensions",
                            "similarity_score": 0.29026730229985415
                        },
                        {
                            "class_name": "PcmlMessageLog",
                            "similarity_score": 0.3609008432428234
                        },
                        {
                            "class_name": "ResourceLoader",
                            "similarity_score": 0.33205735647907086
                        },
                        {
                            "class_name": "RfmlDescriptor",
                            "similarity_score": 0.2164725297554095
                        },
                        {
                            "class_name": "XMLErrorHandler",
                            "similarity_score": 0.2597670357064914
                        },
                        {
                            "class_name": "RfmlRecordFormat",
                            "similarity_score": 0.3783277482131607
                        },
                        {
                            "class_name": "StructDescriptor",
                            "similarity_score": 0.33596468182426004
                        },
                        {
                            "class_name": "DocNodeDescriptor",
                            "similarity_score": 0.372537975699926
                        },
                        {
                            "class_name": "PcmlAttributeList",
                            "similarity_score": 0.2836880022264773
                        },
                        {
                            "class_name": "ProgramDescriptor",
                            "similarity_score": 0.3523848455463737
                        },
                        {
                            "class_name": "SystemClassLoader",
                            "similarity_score": 0.2587516028631446
                        },
                        {
                            "class_name": "RecordFormatDocument",
                            "similarity_score": 0.4720524695661405
                        },
                        {
                            "class_name": "SystemResourceFinder",
                            "similarity_score": 0.39872916841090117
                        },
                        {
                            "class_name": "RecordFormatDescriptor",
                            "similarity_score": 0.3174619397427218
                        },
                        {
                            "class_name": "PcmlSpecificationException",
                            "similarity_score": 0.3003749930442465
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "XPCMLHelper",
                        "PcmlDocument",
                        "RecordFormatDocument",
                        "RfmlDocument",
                        "RfmlSAXParser",
                        "SystemResourceFinder",
                        "RfmlRecordFormat",
                        "PcmlSAXParser",
                        "PcmlDataValues",
                        "PcmlStruct",
                        "PcmlData",
                        "DocNodeDescriptor",
                        "PcmlMessageLog",
                        "ParseException",
                        "RecordFormatDescriptor",
                        "ProgramDescriptor",
                        "DataDescriptor",
                        "StructDescriptor",
                        "PcmlDocNode",
                        "ResourceLoader",
                        "RfmlDescriptor",
                        "PcmlProgram",
                        "XmlException",
                        "PcmlSpecificationException",
                        "PcmlDescriptor",
                        "PcmlDataVector",
                        "XMLErrorHandler",
                        "RfmlData",
                        "PcmlDimensions",
                        "PcmlNode",
                        "RfmlStruct",
                        "SystemClassLoader",
                        "PcmlAttributeList",
                        "PcmlException",
                        "Descriptor",
                        "PcmlDocRoot",
                        "DAMRI",
                        "PcmlAttribute",
                        "PcmlNodeType"
                    ],
                    "llm_response_time": 1241,
                    "similarity_computation_time": 91,
                    "similarity_metric": "cosine"
                },
                "endInternal2": {
                    "target_classes": [
                        {
                            "class_name": "RJob",
                            "similarity_score": 0.3999268311197287
                        },
                        {
                            "class_name": "AS400",
                            "similarity_score": 0.7158544931636377
                        },
                        {
                            "class_name": "PcmlDocument",
                            "similarity_score": 0.7026322118373899
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "RJob",
                        "AS400",
                        "PcmlDocument"
                    ],
                    "llm_response_time": 2204,
                    "similarity_computation_time": 14,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.util.html.HTMLVector::readObject(java.io.ObjectInputStream):void need move com.ibm.as400.util.html.HTMLTree",
        "class_name": "com.ibm.as400.util.html.HTMLVector",
        "telemetry": {
            "id": "13a9ce5f-a42a-4c1d-9421-db60b9487408",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 57,
                "lineStart": 20,
                "lineEnd": 76,
                "bodyLineStart": 20,
                "language": "java",
                "sourceCode": "/**\n * This Vector is used internally by the HTML classes for performance reasons.\n**/\npublic class HTMLVector extends Vector\n{\n  /**\n   * This returns the superclass's element data array, which may be longer\n   * than the actual number of elements. Therefore, the objects at the end\n   * of the array could be null. Care should be taken to avoid these when\n   * looping, by using the elementCount returned by getCount().\n  **/\n  public Object[] getData()\n  {\n    return elementData;\n  }\n  \n  /**\n   * This returns the superclass's element count, which is the actual number\n   * of elements that are populated in the array returned by getData().\n   * Use this number for the maximum element count when looping through the\n   * element data, to avoid grabbing the null elements at the end of the\n   * element data array.\n  **/\n  public int getCount()\n  {\n    return elementCount;\n  }\n\n/**\n*  Deserializes and initializes transient data.\n * @param htmlTree TODO\n * @param in TODO\n**/\nvoid readObject(HTMLTree htmlTree, ObjectInputStream in)\nthrows java.io.IOException, ClassNotFoundException\n{\n    // @B2A\n    // If the locale is Korean, then this throws\n    // an ArrayIndexOutOfBoundsException.  This is\n    // a bug in the JDK.  The workarond in that case\n    // is just to use String.compareTo().\n    try                                                                            // @B2A\n    {\n        htmlTree.collator_ = Collator.getInstance ();                           // @B2A\n        htmlTree.collator_.setStrength (Collator.PRIMARY);                // @B2A\n    }\n    catch (Exception e)                                                    // @B2A\n    {\n        htmlTree.collator_ = null;                                                      // @B2A\n    }\n\n    in.defaultReadObject();\n\n    //@P2D changes_ = new PropertyChangeSupport(this);\n    //@P2D elementListeners = new Vector();\n}\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 47,
                        "lineEnd": 74,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to com.ibm.as400.util.html.HTMLTree\nRationale: The method readObject() directly manipulates the properties of the HTMLTree instance, specifically initializing the collator_ field. It is responsible for deserializing and initializing transient data related to the HTMLTree, making it logical for this method to reside within the HTMLTree class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 5097
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject",
                            "method_signature": "void readObject(HTMLTree htmlTree, ObjectInputStream in) throws java.io.IOException, ClassNotFoundException",
                            "target_class": "HTMLTree",
                            "rationale": "The readObject method is responsible for deserializing and initializing transient data related to HTMLTree. It should be moved to the HTMLTree class to encapsulate the logic that directly pertains to its state."
                        }
                    ],
                    "llm_response_time": 1531
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject",
                            "method_signature": "void readObject(HTMLTree htmlTree, ObjectInputStream in) throws java.io.IOException, ClassNotFoundException",
                            "target_class": "HTMLTree",
                            "rationale": "The readObject method is responsible for deserializing and initializing transient data related to HTMLTree. It should be moved to the HTMLTree class to encapsulate the deserialization logic within the class that it primarily affects."
                        }
                    ],
                    "llm_response_time": 1211
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject",
                            "method_signature": "void readObject(HTMLTree htmlTree, ObjectInputStream in) throws java.io.IOException, ClassNotFoundException",
                            "target_class": "HTMLTree",
                            "rationale": "The readObject method is responsible for deserializing and initializing transient data related to HTMLTree. It should be moved to the HTMLTree class to encapsulate the deserialization logic within the class that it primarily affects."
                        }
                    ],
                    "llm_response_time": 1740
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "readObject",
                            "method_signature": "void readObject(HTMLTree htmlTree, ObjectInputStream in) throws java.io.IOException, ClassNotFoundException",
                            "target_class": "HTMLTree",
                            "rationale": "The readObject method is responsible for deserializing and initializing transient data related to HTMLTree. It should be moved to the HTMLTree class to encapsulate the logic that directly pertains to its state."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "readObject"
                ],
                "llm_response_time": 504
            },
            "targetClassMap": {
                "readObject": {
                    "target_classes": [
                        {
                            "class_name": "HTMLTree",
                            "similarity_score": 0.5086590975474009
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "HTMLTree"
                    ],
                    "llm_response_time": 885,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.resource.IntegerValueMap::start():void need move com.ibm.as400.access.NetServer",
        "class_name": "com.ibm.as400.resource.IntegerValueMap",
        "telemetry": {
            "id": "9d38007b-2871-4cdd-a655-2d160fac4361",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 113,
                "lineStart": 27,
                "lineEnd": 139,
                "bodyLineStart": 27,
                "language": "java",
                "sourceCode": "/**\nThe IntegerValueMap class maps between a logical Integer value\nand a physical String value.\n@deprecated Use packages <tt>com.ibm.as400.access</tt> and <tt>com.ibm.as400.access.list</tt> instead. \n**/\npublic class IntegerValueMap\nimplements ValueMap, Serializable\n{\n  private static final String copyright = \"Copyright (C) 1997-2000 International Business Machines Corporation and others.\";\n\n\n\n\n    static final long serialVersionUID = 4L;\n\n\n\n/**\nMaps from a logical value to a physical value.\n\n@param logicalValue     The logical value.\n@param system           The system.\n@return                 The physical value.\n**/\n    public Object ltop(Object logicalValue, AS400 system)\n    {\n        if (logicalValue == null)\n            throw new NullPointerException(\"logicalValue\");\n        if (!(logicalValue instanceof Integer))\n            throw new ExtendedIllegalArgumentException(\"logicalValue\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n\n        return logicalValue.toString();\n    }\n\n\n\n/**\nMaps from a physical value to a logical value.\n\n@param physicalValue    The physical value.\n@param system           The system.\n@return                 The logical value.\n**/\n    public Object ptol(Object physicalValue, AS400 system)\n    {\n        if (physicalValue == null)\n            throw new NullPointerException(\"physicalValue\");\n        if (!(physicalValue instanceof String))\n            throw new ExtendedIllegalArgumentException(\"physicalValue\", ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n\n        String asString = (String)physicalValue;\n        if (asString.length() == 0)\n            return new Integer(0);\n        else\n            return new Integer(asString.trim());\n    }\n\n\n\n/**\n   Starts the NetServer job on the IBM i system, and (optionally) resets it.\n   If the NetServer is already started, this method does nothing.\n   This method requires *IOSYSCFG special authority on the system.\n   If the QSERVER subsystem is not running, this method will attempt to start it. \n   <p>Note: Reset is used when the NetServer fails to start normally on the system.  It is on the NetServer context menu so an administrator can use it.  The reset does some under-the-covers cleanup, and is used infrequently.  The times it would be used is if the system ended abnormally and there may be jobs or objects hanging around that need to be cleaned up before the system can start again.  The reset does that.\n\n   @param netServer TODO\n * @param reset  Whether or not the system is to be reset when started.\n * @exception ResourceException  If an error occurs.\n   **/\n  public void start2(NetServer netServer, boolean reset)\n    throws ResourceException\n  {\n    if (! netServer.isConnectionEstablished()) {\n      netServer.establishConnection();\n    }\n    if (netServer.isStarted()) return;\n\n    // @A3a\n    // See if the QSERVER subsystem is running.  If it's not running, start it.\n    if (!netServer.isQserverStarted()) {\n      // Attempt to start the QSERVER subsystem.\n      CommandCall cmd = new CommandCall(netServer.getSystem(), \"STRSBS SBSD(QSERVER)\");\n      boolean started = false;\n      try { started = cmd.run(); }\n      catch (Exception e) { throw new ResourceException(e); }\n      if (!started) {\n        Trace.log(Trace.ERROR, \"Error when starting QSERVER subsystem.\");\n        throw new ResourceException(cmd.getMessageList());\n      }\n    }\n\n\n    // Start the NetServer job (QZLSSERVER) on the IBM i system.\n    try {\n      ProgramCallDocument document = (ProgramCallDocument)NetServer.staticDocument_.clone();\n      document.setSystem(netServer.getSystem());\n      document.setValue(\"qzlsstrs.resetQualifier\", (reset ? \"1\" : \"0\"));\n\n      if (document.callProgram(\"qzlsstrs\") == false) {\n        throw new ResourceException(document.getMessageList(\"qzlsstrs\"));\n      }\n\n      // Note: Here is where we would do a fireServerStarted();\n    }\n    catch (PcmlException e) {\n      Trace.log(Trace.ERROR, \"PcmlException when starting the NetServer.\", e);\n      throw new ResourceException(e);\n    }\n  }\n\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 85,
                        "lineEnd": 135,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to com.ibm.as400.access.NetServer\nRationale: The method 'start2' directly interacts with the NetServer instance, checking its connection and state, and is responsible for starting the NetServer job. It logically belongs to the NetServer class as it operates on its properties and methods.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 4822
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "start2",
                            "method_signature": "public void start2(NetServer netServer, boolean reset) throws ResourceException",
                            "target_class": "NetServerManager",
                            "rationale": "The start2() method is responsible for starting the NetServer job and managing its state, which is more aligned with the responsibilities of a NetServerManager class rather than the IntegerValueMap class."
                        }
                    ],
                    "llm_response_time": 1672
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "start2",
                            "method_signature": "public void start2(NetServer netServer, boolean reset) throws ResourceException",
                            "target_class": "NetServerManager",
                            "rationale": "The start2() method is responsible for starting the NetServer job and managing its state, which is more aligned with the responsibilities of a NetServerManager class rather than the IntegerValueMap class."
                        }
                    ],
                    "llm_response_time": 1260
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "start2",
                            "method_signature": "public void start2(NetServer netServer, boolean reset) throws ResourceException",
                            "target_class": "NetServerManager",
                            "rationale": "The start2() method is responsible for starting the NetServer job and managing its state, which is more aligned with the responsibilities of a NetServerManager class rather than the IntegerValueMap class."
                        }
                    ],
                    "llm_response_time": 1144
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "start2",
                            "method_signature": "public void start2(NetServer netServer, boolean reset) throws ResourceException",
                            "target_class": "NetServerManager",
                            "rationale": "The start2() method is responsible for starting the NetServer job and managing its state, which is more aligned with the responsibilities of a NetServerManager class rather than the IntegerValueMap class."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "start2"
                ],
                "llm_response_time": 652
            },
            "targetClassMap": {
                "start2": {
                    "target_classes": [
                        {
                            "class_name": "NetServer",
                            "similarity_score": 0.7241166673457953
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "NetServer"
                    ],
                    "llm_response_time": 1577,
                    "similarity_computation_time": 3,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.vaccess.SQLResultSetTableModel::readObject(java.io.ObjectInputStream):void need move com.ibm.as400.vaccess.SQLResultSetTablePane",
        "class_name": "com.ibm.as400.vaccess.SQLResultSetTableModel",
        "telemetry": {
            "id": "bb3181f8-e21b-4fb4-b198-0995bd1f6ecc",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1299,
                "lineStart": 38,
                "lineEnd": 1336,
                "bodyLineStart": 38,
                "language": "java",
                "sourceCode": "/**\nThe SQLResultSetTableModel class represents the data in a JDBC\nresult set generated by an SQL query.  This class implements the\nunderlying model for a table in a graphical user interface.\nUse this class if you want to customize the graphical user interface\nthat presents a table.  If you do not need to customize the graphical user\ninterface, then use <a href=\"SQLResultSetTablePane.html\">\nSQLResultSetTablePane</a> instead.\n\n<p>You must specify an <a href=\"SQLConnection.html\">\nSQLConnection</a> object and SQL query string to use for generating\nthe data.  Alternately, you can specify a ResultSet object directly.\nIf you specify a ResultSet object, it will override any SQLConnection\nor SQL query previously set.  In addition, if you specify a ResultSet,\nthis class will use memory more efficiently if you create the ResultSet as scrollable.\n\n<p>You must explicitly call <a href=\"#load()\">load()</a> to load the information\nfrom the result set.  The model will be empty until load() is called.\nIf the query or result set includes updatable columns, then the respective\ncolumns will be editable.\n\n<p>This class assumes that the necessary JDBC driver(s) are already registered.\n\n<p>Call <a href=\"#close()\">close()</a> to ensure that the result set\nis closed when this table is no longer needed.\n\n<p>Most errors are reported as <a href=\"ErrorEvent.html\">ErrorEvent</a>s\nrather than throwing exceptions.  Listen for ErrorEvents in order to diagnose and recover\nfrom error conditions.\n\n<p>SQLResultSetTableModel objects generate the following events:\n<ul>\n  <li>ErrorEvent\n  <li>PropertyChangeEvent\n  <li>TableModelEvent\n  <li>WorkingEvent\n</ul>\n\n<p>This example creates an SQLResultSetTableModel using an SQLConnection\nand query and displays it using a JTable:\n\n<pre>\n// Register the IBM Toolbox for Java JDBC driver.\nDriverManager.registerDriver(new com.ibm.as400.access.AS400JDBCDriver());\n<br>\n// Create the SQLResultSetTableModel object.\nSQLConnection connection = new SQLConnection(\"jdbc:as400://MySystem\", \"Userid\", \"Password\");\nString query = \"SELECT * FROM MYLIB.MYTABLE\";\nSQLResultSetTableModel model = new SQLResultSetTableModel(connection, query);\n<br>\n// Create the enclosing JTable and put it in a JFrame.\nJTable table = new JTable(model);\nJFrame frame = new JFrame(\"My Window\");\nframe.getContentPane().add(new JScrollPane(table));\n<br>\n// Set up the error dialog adapter.\nmodel.addErrorListener(new ErrorDialogAdapter(frame));\n<br>\n// Display the JFrame.\nframe.pack();\nframe.show();\n<br>\n// Load the contents of the model.\nmodel.load();\n</pre>\n\n<p>This example creates an SQLResultSetTableModel using a ResultSet\nand displays it using a JTable:\n\n<pre>\n// Register the IBM Toolbox for Java JDBC driver.\nDriverManager.registerDriver(new com.ibm.as400.access.AS400JDBCDriver());\n<br>\n// Use JDBC to execute the SQL query directly.\nConnection connection = DriverManager.getConnection(\"MySystem\", \"Userid\", \"Password\");\nStatement statement = connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);\nResultSet rs = statement.executeQuery(\"SELECT * FROM MYLIB.MYTABLE\");\n<br>\n// Create the SQLResultSetTableModel object.\nSQLResultSetTableModel model = new SQLResultSetTableModel(rs);\n<br>\n// Create the enclosing JTable and put it in a JFrame.\nJTable table = new JTable(model);\nJFrame frame = new JFrame(\"My Window\");\nframe.getContentPane().add(new JScrollPane(table));\n<br>\n// Set up the error dialog adapter.\nmodel.addErrorListener(new ErrorDialogAdapter(frame));\n<br>\n// Display the JFrame.\nframe.pack();\nframe.show();\n<br>\n// Load the contents of the model.\nmodel.load();\n</pre>\n@deprecated Use Java Swing instead, along with the classes in package <tt>com.ibm.as400.access</tt>\n**/\n//\n// Implementation notes:\n//\n// *  Note that this class throws error and working events from within\n//    synchronized blocks, which could cause hangs if the listeners for\n//    these events do operations from a different thread an attempt to\n//    access another synchronized piece of code.\n//\n//    At this time this seems to be an acceptable risk, since the\n//    events thrown are not likely to need enough processing to\n//    require another thread, and getting having the events thrown\n//    from outside a sychronized block would be nearly impossible.\n//    The other option is to have the firing of the events be done\n//    from another thread, but the overhead of creating another thread\n//    not only takes resources, but also delays the delivery of the event.\n//\n// *  We do two sets of synchronization.  The internalMonitor_\n//    synchronization prevents data corrruption when multiple threads\n//    are accessing the same SQLResultSetTableModel object.\n//    The resultSet_ synchronization prevents data corruption when\n//    multiple SQLResultSetTableModels are accessing the same\n//    ResultSet object.\n//\n// *  The variables which have private commented out had to made\n//    package scope since currently Internet Explorer does not\n//    allow inner class to access private variables in their\n//    containing class.\n//\npublic class SQLResultSetTableModel\n    extends AbstractTableModel\n    implements Serializable\n{\n  private static final String copyright = \"Copyright (C) 1997-2001 International Business Machines Corporation and others.\";\n\n\n\n  // Private data.\n  private boolean                         cacheAll_               = false;\n  private SQLConnection                   sqlConnection_          = null;\n  private String                          query_                  = null;\n  private ResultSet                       explicitResultSet_      = null;\n\n  private transient Vector                cachedRows_;\n  private transient int                   cachedRowCount_;\n  private transient int                   columnCount_;\n  private transient boolean               error_;\n  private transient int                   firstCachedRow_;\n  private transient Object                internalMonitor_;\n  private transient int                   lastCachedRow_;\n  private transient ResultSet             resultSet_;\n  private transient ResultSetMetaData     resultSetMetaData_;\n  private transient int                   rowCount_;\n  private transient boolean               rowCountComplete_;\n  private transient boolean               scrollable_;\n  private transient Statement             statement_;\n  private transient boolean               updatable_;\n\n  private transient JTable                table_;    /* Keep a reference to the table so we can maintain selection information @B6A*/ \n  private static final int                CACHE_SIZE_             = 500;  // In rows.\n  private static final int                READ_INCREMENT_         = 50;   // In rows.\n\n\n\n  // Event support.\n  private transient PropertyChangeSupport     propertyChangeSupport_;\n  private transient VetoableChangeSupport     vetoableChangeSupport_;\n  private transient ErrorEventSupport         errorEventSupport_;\n  private transient WorkingEventSupport       workingEventSupport_;\n\n\n\n  /**\n  Constructs a SQLResultSetTableModel object.\n  **/\n  public SQLResultSetTableModel()\n  {\n    super();\n    initializeTransient();\n  }\n\n\n\n  /**\n  Constructs a SQLResultSetTableModel object.\n  \n  @param connection     The SQL connection.\n  @param query          The SQL query.\n  **/\n  public SQLResultSetTableModel(SQLConnection connection, String query)\n  {\n    super();\n    if(connection == null)\n      throw new NullPointerException(\"connection\");\n    if(query == null)\n      throw new NullPointerException(\"query\");\n\n    sqlConnection_ = connection;\n    query_ = query;\n\n    initializeTransient();\n  }\n\n\n\n  // @D0A\n  /**\n  Constructs a SQLResultSetTableModel object.\n  \n  @param resultSet  The SQL result set.\n  @param cacheAll   true to cache the entire result set when <a href=\"#load()\">load()</a>\n                    is called, false to cache parts of the result set as they are\n                    needed.  Passing true may result in slow initial presentation of\n                    the data.  However, it may be necessary to pass true if the result\n                    set is expected to close when the model is still needed.\n  **/\n  public SQLResultSetTableModel(ResultSet resultSet, boolean cacheAll)\n  {\n    super();\n    if(resultSet == null)\n      throw new NullPointerException(\"resultSet\");\n\n    explicitResultSet_ = resultSet;\n    cacheAll_ = cacheAll;\n\n    initializeTransient();\n  }\n\n\n\n  /**\n  Adds a listener to be notified when an error occurs.\n  \n  @param  listener    The listener.\n  **/\n  public void addErrorListener(ErrorListener listener)\n  {\n    errorEventSupport_.addErrorListener(listener);\n  }\n\n\n\n  /**\n  Adds a listener to be notified when the value of any\n  bound property changes.\n  \n  @param  listener  The listener.\n  **/\n  public void addPropertyChangeListener(PropertyChangeListener listener)\n  {\n    propertyChangeSupport_.addPropertyChangeListener(listener);\n  }\n\n\n\n  /**\n  Adds a listener to be notified when the value of any\n  constrained property changes.\n  \n  @param  listener  The listener.\n  **/\n  public void addVetoableChangeListener(VetoableChangeListener listener)\n  {\n    vetoableChangeSupport_.addVetoableChangeListener(listener);\n  }\n\n\n\n  /**\n  Adds a listener to be notified when work starts and stops\n  on potentially long-running operations.\n  \n  @param  listener  The listener.\n  **/\n  public void addWorkingListener(WorkingListener listener)\n  {\n    workingEventSupport_.addWorkingListener(listener);\n  }\n\n\n\n  /**\n  Clears all SQL warnings.\n  **/\n  public void clearWarnings()\n  {\n    try\n    {\n      if(resultSet_ != null)\n        resultSet_.clearWarnings();\n      if(statement_ != null)\n        statement_.clearWarnings();\n    }\n    catch(SQLException e)\n    {\n      markError(e);\n    }\n  }\n\n\n\n  /**\n  Closes the result set.\n  **/\n  public void close()\n  {\n    try\n    {\n      if(resultSet_ != null)\n      {\n        resultSet_.close();\n        resultSet_ = null;\n      }\n    }\n    catch(SQLException e)\n    {\n      markError(e);\n    }\n\n    try\n    {\n      if(statement_ != null)\n      {\n        statement_.close();\n        statement_ = null;\n      }\n    }\n    catch(SQLException e)\n    {\n      markError(e);\n    }\n  }\n\n\n\n  /**\n  Returns the class of the values in the column.\n  \n  @param columnIndex The column index (0-based).\n  @return            The class of the column values, or null\n                     if an error occurs.\n  **/\n  public Class getColumnClass(int columnIndex)\n  {\n    // Returning Object seems to be sufficient.\n    return Object.class;\n  }\n\n\n\n  /**\n  Returns the number of columns in the table.\n  \n  @return The number of columns in the table, or 0\n          if an error occurs.\n  **/\n  public int getColumnCount()\n  {\n    synchronized(internalMonitor_)\n    {\n      Trace.log(Trace.DIAGNOSTIC, \"SQLResultSetTableModel.getColumnCount() = \" + columnCount_);\n      return columnCount_;\n    }\n  }\n\n\n\n  /**\n  Returns the column identifier.  This corresponds to the\n  field name in the database.\n  \n  @param columnIndex  The column index (0-based).\n  @return             The column identifier, or null\n                      if an error occurs.\n  **/\n  public String getColumnID(int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return null;\n      if(resultSet_ == null)\n        return null;\n\n      try\n      {\n        return resultSetMetaData_.getColumnName(columnIndex+1);\n      }\n      catch(SQLException e)\n      {\n        markError(e);\n        return null;\n      }\n    }\n  }\n\n\n\n  /**\n  Returns the column name.  This corresponds to the column\n  label in the database.\n  \n  @param columnIndex  The column index (0-based).\n  @return             The column name, or null\n                      if an error occurs.\n  **/\n  public String getColumnName(int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return null;\n      if(resultSet_ == null)\n        return null;\n\n      try\n      {\n        String col = resultSetMetaData_.getColumnLabel(columnIndex+1);        //@pdc extended metadata\n        //columnLabel is a concatonation of up to three columns (each 20 length) with the 20 length padded with spaces\n        int colLength = col.length();          //@pda extended metadata\n        if( colLength > 20)                    //@pda  \n        {                                      //@pda  \n            \n            if( colLength > 40)                        //@pda  \n            {                                          //@pda  \n                //contains three column concats\n                String space1 = col.substring(19,20).equals(\" \") ? \" \" : \"\";  //column separator\n                String space2 = col.substring(39,40).equals(\" \") ? \" \" : \"\";  //column separator\n                col = col.substring(0, 20).trim() + space1 + col.substring(20, 40).trim() + space2 + col.substring(40).trim();    //@pda  \n            }                                          //@pda  \n            else                                       //@pda  \n            {                                          //@pda  \n                //contains two column concats\n                String space1 = col.substring(19,20).equals(\" \") ? \" \" : \"\";  //column separator\n                col = col.substring(0, 20).trim() + space1 + col.substring(20).trim();  //@pda  \n            }                                         //@pda  \n        }                                             //@pda  \n        return col;                                   //@pda  \n      }\n      catch(SQLException e)\n      {\n        markError(e);\n        return null;\n      }\n    }\n  }\n\n\n\n  /**\n  Returns the column type.\n  \n  @param columnIndex  The column index (0-based).\n  @return             The column type, or 0 if an error occurs.\n  **/\n  public int getColumnType(int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return 0;\n      if(resultSet_ == null)\n        return 0;\n\n      try\n      {\n        return resultSetMetaData_.getColumnType(columnIndex+1);\n      }\n      catch(SQLException e)\n      {\n        markError(e);\n        return 0;\n      }\n    }\n  }\n\n\n\n  /**\n  Returns the column width.\n  \n  @param columnIndex  The column index (0-based).\n  @return             The column width, in characters, or 0 if an error occurs.\n  **/\n  public int getColumnWidth(int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return 0;\n      if(resultSet_ == null)\n        return 0;\n\n      try\n      {\n        /* @D3D\n        // For most types, we just consult with JDBC.  However, for times, dates, and\n        // timestamps, JDBC reports the display size for the server format.  And these\n        // GUIs actually internationalize the Strings before displaying them.  So for\n        // these types, we need to compute our own display sizes.\n        switch(resultSetMetaData_.getColumnType(columnIndex+1)) {\n        case Types.TIME:\n            return DBDateCellRenderer.getDisplaySize(DBDateCellRenderer.FORMAT_TIME);\n        case Types.DATE:\n            return DBDateCellRenderer.getDisplaySize(DBDateCellRenderer.FORMAT_DATE);\n        case Types.TIMESTAMP:\n            return DBDateCellRenderer.getDisplaySize(DBDateCellRenderer.FORMAT_TIMESTAMP);\n        default:\n        */\n        return Math.min(resultSetMetaData_.getColumnDisplaySize(columnIndex+1), 50);\n        // @D3D }\n      }\n      catch(SQLException e)\n      {\n        markError(e);\n        return 0;\n      }\n    }\n  }\n\n\n\n  /**\n  Returns the SQL connection.\n  \n  @return The SQL connection.\n  **/\n  public SQLConnection getConnection()\n  {\n    return sqlConnection_;\n  }\n\n\n\n  /**\n  Returns the SQL query.\n  \n  @return The SQL query.\n  **/\n  public String getQuery()\n  {\n    return(query_ == null) ? \"\" : query_;\n  }\n\n\n\n  // @D0A\n  /**\n  Returns the SQL result set.\n  \n  @return The SQL result set.\n  **/\n  public ResultSet getResultSet()\n  {\n    return explicitResultSet_;\n  }\n\n\n\n  /**\n  Returns the number of rows in the table.\n  Because of incremental data retrieval, this value may\n  not be accurate.\n  \n  @return The number of rows in the table.\n  **/\n  public int getRowCount()\n  {\n    if(resultSet_ == null)\n      return 0;\n\n    // If we are not complete, report 2 more than actually here.\n    // This will trick JTable into continuing to ask for more.\n    int reportedRowCount = rowCount_;\n    if(!rowCountComplete_)\n      reportedRowCount += 2;\n\n    // This should not be in a synchronized block, otherwise\n    // a hang may occur.\n    Trace.log(Trace.DIAGNOSTIC, \"SQLResultSetTableModel.getRowCount() = \" + reportedRowCount + \"(actually \" + rowCount_ + \")\");\n    return reportedRowCount;\n  }\n\n\n\n  // @D4A\n  private Object getSingleValue(int columnIndex) throws SQLException\n  {\n    int type = resultSetMetaData_.getColumnType(columnIndex);\n    if(type == Types.BINARY\n       || type == Types.VARBINARY\n       || type == Types.LONGVARBINARY)\n    {\n      return resultSet_.getBytes(columnIndex);\n    }\n    else\n    {\n      // Use getString() so that dates and times get converted to strings\n      // by the JDBC driver so that their formats reflect the settings\n      // in the data source.\n      //@KKB return resultSet_.getString(columnIndex);\n      String s = resultSet_.getString(columnIndex);     //@KKB\n      if(checkDataMappingWarning(resultSet_, columnIndex))           //@KKB\n          s=\"++++++++++++++\";                           //@KKB\n      return s;                                         //@KKB\n    }\n  }\n\n\n\n  /**\n  Returns the value at the specifed row and column.\n  \n  @param rowIndex       The row index (0-based).\n  @param columnIndex    The column index (0-based).\n  \n  @return The value at the specified row and column.\n  **/\n  public Object getValueAt(int rowIndex, int columnIndex)\n  {\n    int oldRowCount;\n    int newRowCount;\n    Object[] row = null;\n\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return null;\n      if(rowIndex < 0)\n        return null;\n      if((rowCountComplete_) && (rowIndex >= rowCount_))\n        return null;\n      if(resultSet_ == null)\n        return null;\n\n      oldRowCount = rowCount_;\n\n      // Case 1: If this row is in the cache, just read it from there.\n      // If cacheAll_ is set, then this case should always occur.\n      if((rowIndex >= firstCachedRow_) && (rowIndex <= lastCachedRow_))\n      {\n        row = (Object[])cachedRows_.elementAt(rowIndex - firstCachedRow_);\n      }\n\n      // Case 2: If this row comes before whats in the cache, read the rows\n      // and move the cache window up in the result set.  This will only\n      // occur if the result set is scrollable - if it is not, then the\n      // cache always includes everything read so far.\n      else if((rowIndex < firstCachedRow_) && (error_ == false))\n      {\n        workingEventSupport_.fireStartWorking();\n        for(int i = firstCachedRow_ - 1; i >= rowIndex; --i)\n        {\n          try\n          {\n            row = new Object[columnCount_];\n            synchronized(resultSet_)\n            {\n\n              // If we are just reading the next row since the last\n              // time, it can be significantly faster to call next().\n              // This is especially true when using the Toolbox\n              // JDBC driver since it does record blocking only\n              // when using next().\n              //\n              // I tried keeping the last read row locally, but it\n              // messes things up when result sets are shared\n              // between multiple models.\n              //\n              if(i == resultSet_.getRow())\n                resultSet_.next();\n              else\n                resultSet_.absolute(i+1);\n\n              // Store the contents of the row.\n              for(int j = 0; j < columnCount_; ++j)\n                row[j] = getSingleValue(j+1); // @D4C\n            }\n            cachedRows_.insertElementAt(row, 0);\n            --firstCachedRow_;\n            if(++cachedRowCount_ > CACHE_SIZE_)\n            {\n              cachedRows_.removeElementAt(--cachedRowCount_);\n              --lastCachedRow_;\n            }\n          }\n          catch(SQLException e)\n          {\n            markError(e);\n          }\n        }\n        workingEventSupport_.fireStopWorking();\n      }\n\n      // Case 3: If this row comes after whats in the cache, read the rows\n      // and move the cache window down in the result set.  If we do not\n      // know the final row count, then jump a little bit ahead to discover\n      // this.\n      else if((rowIndex > lastCachedRow_) && (error_ == false))\n      {\n\n        // Determine how far to go.  If we are not complete yet, push it\n        // ahead to force the table to read even further.\n        int endPoint = rowIndex;\n        if(!rowCountComplete_)\n          endPoint = rowIndex + READ_INCREMENT_;\n\n        // Loop through the rows, quit if we get to the end.\n        workingEventSupport_.fireStartWorking();\n        boolean valid = true;\n        for(int i = lastCachedRow_ + 1; (i <= endPoint) && (valid); ++i)\n        {\n          try\n          {\n            synchronized(resultSet_)\n            {\n\n              // If we are just reading the next row since the last\n              // time, it can be significantly faster to call next().\n              // This is especially true when using the Toolbox\n              // JDBC driver since it does record blocking only\n              // when using next().   We also take this route if\n              // the result set is not scrollable.\n              if((i == resultSet_.getRow()) || (!scrollable_))\n                valid = resultSet_.next();\n              else\n                valid = resultSet_.absolute(i+1);\n\n              // If this is a valid row, then add it to the cache.\n              if(valid)\n              {\n                Object[] tempRow = new Object[columnCount_];\n                for(int j = 0; j < columnCount_; ++j)\n                  tempRow[j] = getSingleValue(j+1); // @D4C\n                if(i == rowIndex)\n                  row = tempRow;\n                cachedRows_.insertElementAt(tempRow, cachedRowCount_++);\n                ++lastCachedRow_;\n                if((scrollable_) && (cachedRowCount_ > CACHE_SIZE_))\n                {\n                  cachedRows_.removeElementAt(0);\n                  cachedRowCount_--;\n                  ++firstCachedRow_;\n                }\n\n                // If this is greater than our current count, add record it.\n                if((!rowCountComplete_) && (i >= rowCount_))\n                  rowCount_ = i;\n              }\n\n              // If this is not a valid row, then mark the row count as\n              // complete.\n              else if(!rowCountComplete_)\n              {\n                rowCountComplete_ = true;\n                rowCount_ = i;\n              }\n            }\n          }\n          catch(SQLException e)\n          {\n            markError(e);\n          }\n        }\n        workingEventSupport_.fireStopWorking();\n      }\n\n      // If the row count changed, record the change so we can fire the table\n      // model event (outside of the synchronized block).\n      newRowCount = rowCount_;\n    }\n\n    // If the row count changed, fire the table model event.  If we are\n    // not complete, then add 2 to keep the JTable asking for more.\n    if(oldRowCount != newRowCount)\n    {\n      // In JDK 1.5 and 1.6, there is a problem with the selection in the JTable being cleared. \n      // This causes problems if the user is using the page down key to scroll through the results.\n      //\n      // The call to fireTableRowsInserted may be the code that is clearing the selection.  \n      // For a similar problem see:  http://stackoverflow.com/questions/254212/preserve-jtable-selection-across-tablemodel-change\n      // I tried setting the first parameter to oldRowCount+1 to see if that fixes the problem.\t\n      // That did not fix the problem.  The row at the bottom retains it's highlight, but the next\n      // PageDown jumps to the top of the area. \n      // \n      // Instead we need to remember the selected rows and restore them after. \n      // For now, we'll only handle the simple case where a single cell is selected. \n      //\n      // We also only want to change the selection if the selected row has changed after  \n      // fireTableRowsInserted.  In the case where the use of the scroll bar causes new\n      // entries to be loaded, the selectedRow does not change, so we do not need to \n      // change the selection back to their original values. \n      //\n      // @B6A \n      \n      \n      int  selectedRow = -1; \n      if (table_ != null)   selectedRow = table_.getSelectedRow();\n      int selectedColumn = -1; \n      if (table_ != null)   selectedColumn = table_.getSelectedColumn(); \n      \n      fireTableRowsInserted(oldRowCount, getRowCount());\n      \n      \n      \n      // Restore the selected cell.  @B6A \n     int  afterSelectedRow = -1 ; \n     if (table_ != null)\tafterSelectedRow = table_.getSelectedRow();\n      if ((selectedRow >= 0 && selectedColumn >= 0 ) && \n    \t\t  ((afterSelectedRow != selectedRow) )) {\n      table_.changeSelection(selectedRow, selectedColumn, false /* toggle */ , false /* extend */); \n\t  \n      }\n    }\n\n    // Return the value.\n    if(row == null)\n      return null;\n    else\n      return row[columnIndex];\n  }\n\n\n\n  /**\n  Returns the SQL warnings.\n  \n  @return The SQL warnings.\n  **/\n  public SQLWarning getWarnings()\n  {\n    SQLWarning warnings = null;\n    try\n    {\n      if(resultSet_ != null)\n        warnings = resultSet_.getWarnings();\n      if(statement_ != null)\n      {\n        if(warnings == null)\n          warnings = statement_.getWarnings();\n        else\n          warnings.setNextWarning(statement_.getWarnings());\n      }\n    }\n    catch(SQLException e)\n    {\n      markError(e);\n    }\n    return warnings;\n  }\n\n\n\n  /**\n  Initializes the common data.\n  **/\n  private void initializeCommon()\n  {\n    synchronized(internalMonitor_)\n    {\n      cachedRows_             = new Vector(CACHE_SIZE_);\n      cachedRowCount_         = 0;\n      columnCount_            = 0;\n      error_                  = false;\n      firstCachedRow_         = 0;\n      lastCachedRow_          = -1;\n      rowCount_               = 0;\n      rowCountComplete_       = false;\n    }\n  }\n\n\n\n  /**\n  Initializes the transient data.\n  **/\n  private void initializeTransient()\n  {\n    internalMonitor_                = new Object();\n\n    initializeCommon();\n\n    // Event support.\n    propertyChangeSupport_          = new PropertyChangeSupport(this);\n    vetoableChangeSupport_          = new VetoableChangeSupport(this);\n    errorEventSupport_              = new ErrorEventSupport(this);\n    workingEventSupport_            = new WorkingEventSupport(this);\n  }\n\n\n  //@D6A\n  /**\n   * Used by SQLResultSetTablePane to determine whether or not the default\n   * cell editor should be replaced.\n  **/\n  boolean isUpdatable()\n  {\n    return updatable_;\n  }\n\n\n  // @D2A\n  /**\n  Indicates if the cell is editable.\n  \n  @param rowIndex         The row index (0-based).\n  @param columnIndex      The column index (0-based).\n  @return                 true if the cell is editable, false otherwise\n                          or if an error occurs.\n  **/\n  public boolean isCellEditable(int rowIndex, int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return false;\n      if(rowIndex < 0)\n        return false;\n      if((rowCountComplete_) && (rowIndex >= rowCount_))\n        return false;\n      if(resultSet_ == null)\n        return false;\n\n      //@D6D            try {\n      //@D6D                return (updatable_ && resultSetMetaData_.isWritable(columnIndex+1));\n      //@D6D            }\n      //@D6D            catch(SQLException e) {\n      //@D6D                markError(e);\n      //@D6D                return false;\n      //@D6D            }\n      return true; //@D6A\n    }\n  }\n\n\n\n  /**\n  Loads the data in the table.\n  **/\n  public void load()\n  {\n    Trace.log(Trace.DIAGNOSTIC, \"SQLResultSetTableModel.load()\");\n    workingEventSupport_.fireStartWorking();\n\n    // Make sure we have enough data to load.\n    if(explicitResultSet_ == null)\n    {\n      if(sqlConnection_ == null)\n        throw new IllegalStateException(\"connection\");\n      if(query_ == null)\n        throw new IllegalStateException(\"query\");\n    }\n\n    synchronized(internalMonitor_)\n    {\n\n      // Clear the old data.\n      initializeCommon();\n\n      // Load the new data.\n      try\n      {\n        if(explicitResultSet_ == null)\n        {\n          if(statement_ == null)\n          {\n            Connection connection = sqlConnection_.getConnection();\n            statement_ = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE);\n          }\n\n          resultSet_ = statement_.executeQuery(query_);\n        }\n        else\n          resultSet_ = explicitResultSet_;\n\n        scrollable_ = (resultSet_.getType() != ResultSet.TYPE_FORWARD_ONLY);\n        updatable_ = (resultSet_.getConcurrency() == ResultSet.CONCUR_UPDATABLE);  // @D2A\n        resultSetMetaData_ = resultSet_.getMetaData();\n        columnCount_ = resultSetMetaData_.getColumnCount();\n\n        if(Trace.isTraceOn())\n        {\n          Trace.log(Trace.DIAGNOSTIC, \"SQLResultSetTableModel-scrollable? \" + scrollable_);\n          Trace.log(Trace.DIAGNOSTIC, \"SQLResultSetTableModel-updatable? \" + updatable_); // @D2A\n        }\n\n        //@KBD removed since a stored procedure may or may not return a scrollable cursor\n        // if the user specified ResultSet.TYPE_SCROLL_SENSITIVE or ResultSet.TYPE_SCROLL_INSENSITVE\n        //@KBD if(scrollable_)\n        //@KBD {\n        //@KBD     resultSet_.beforeFirst();\n        //@KBD }\n      }\n      catch(SQLException e)\n      {\n        markError(e);\n        rowCountComplete_ = true;\n      }\n\n      // If we are supposed to, then cache all.\n      if(cacheAll_)\n      {\n        try\n        {\n          while(resultSet_.next())\n          {\n            Object[] tempRow = new Object[columnCount_];\n            for(int j = 0; j < columnCount_; ++j)\n              tempRow[j] = getSingleValue(j+1); // @D4C\n            cachedRows_.addElement(tempRow);\n          }\n        }\n        catch(SQLException e)\n        {\n          markError(e);\n        }\n        lastCachedRow_ = cachedRows_.size();\n        rowCount_ = lastCachedRow_;\n        rowCountComplete_ = true;\n      }\n\n      // Otherwise, try to read 1 row.  This will handle the case where there are no rows.\n      else\n      {\n        getValueAt(0, 0);\n      }\n    }\n\n    // Tell the JTable that we've changed.\n    fireTableStructureChanged();\n\n    workingEventSupport_.fireStopWorking();\n  }\n\n\n\n  /**\n  Marks that an error has occurred.\n  **/\n  private void markError(Exception e)\n  {\n    if(Trace.isTraceOn())\n      Trace.log(Trace.ERROR, \"Error gathering SQLResultSetTableModel data\", e);\n\n    // Only fire if this is the first error.  That way, we don't\n    // barrage the poor user.\n    if(!error_)\n    {\n      error_ = true;\n      errorEventSupport_.fireError(e);\n    }\n  }\n\n\n\n  /**\n  Restores the state of the object from an input stream.\n  This is used when deserializing an object.\n  \n  @param in   The input stream.\n  **/\n  private void readObject(ObjectInputStream in)\n  throws IOException, ClassNotFoundException\n  {\n    in.defaultReadObject();\n    initializeTransient();\n  }\n\n\n\n  /**\n  Removes an error listener.\n  \n  @param  listener    The listener.\n  **/\n  public void removeErrorListener(ErrorListener listener)\n  {\n    errorEventSupport_.removeErrorListener(listener);\n  }\n\n\n\n  /**\n  Removes a property change listener.\n  \n  @param  listener  The listener.\n  **/\n  public void removePropertyChangeListener(PropertyChangeListener listener)\n  {\n    propertyChangeSupport_.removePropertyChangeListener(listener);\n  }\n\n\n\n  /**\n  Removes a vetoable change listener.\n  \n  @param  listener  The listener.\n  **/\n  public void removeVetoableChangeListener(VetoableChangeListener listener)\n  {\n    vetoableChangeSupport_.removeVetoableChangeListener(listener);\n  }                                                    \n\n\n\n  /**\n  Removes a working listener.\n  \n  @param  listener  The listener.\n  **/\n  public void removeWorkingListener(WorkingListener listener)\n  {\n    workingEventSupport_.removeWorkingListener(listener);\n  }\n\n\n\n  /**\n  Sets the SQL connection.\n  The data will not change until <a href=\"#load()\">load()</a> is called.\n  \n  @param       connection              The SQL connection.\n  \n  @exception  PropertyVetoException   If the change is vetoed.\n  **/\n  public void setConnection(SQLConnection connection)\n  throws PropertyVetoException\n  {\n    if(connection == null)\n      throw new NullPointerException(\"connection\");\n\n    SQLConnection oldValue = sqlConnection_;\n    vetoableChangeSupport_.fireVetoableChange(\"connection\", oldValue, connection);\n    sqlConnection_ = connection;\n    statement_ = null;\n    propertyChangeSupport_.firePropertyChange(\"connection\", oldValue, connection);\n  }\n\n\n\n  /**\n  Sets the SQL query.\n  The data will not change until <a href=\"#load()\">load()</a> is called.\n  \n  @param       query                   The SQL query.\n  \n  @exception  PropertyVetoException   If the change is vetoed.\n  **/\n  public void setQuery(String query)\n  throws PropertyVetoException\n  {\n    if(query == null)\n      throw new NullPointerException(\"query\");\n\n    String oldValue = query_;\n    vetoableChangeSupport_.fireVetoableChange(\"query\", oldValue, query);\n    query_ = query;\n    propertyChangeSupport_.firePropertyChange(\"query\", oldValue, query);\n  }\n\n\n\n  // @D0A\n  /**\n  Sets the SQL result set used to build the table.  If this is set,\n  it is used instead of the SQL connection and SQL query.\n  The data will not change until <a href=\"#load()\">load()</a> is called.\n  \n  @param resultSet        The SQL result set.\n  **/\n  public void setResultSet(ResultSet resultSet)\n  {\n    if(resultSet == null)\n      throw new NullPointerException(\"resultSet\");\n\n    ResultSet oldValue = explicitResultSet_;\n    explicitResultSet_ = resultSet;\n    propertyChangeSupport_.firePropertyChange(\"resultSet\", oldValue, resultSet);\n  }\n\n\n\n  // @D2A\n  /**\n  Sets the value at the specifed row and column.\n  \n  @param value          The value.\n  @param rowIndex       The row index (0-based).\n  @param columnIndex    The column index (0-based).\n  **/\n  public void setValueAt(Object value, int rowIndex, int columnIndex)\n  {\n    synchronized(internalMonitor_)\n    {\n      if((columnIndex < 0) || (columnIndex >= columnCount_))\n        return;\n      if(rowIndex < 0)\n        return;\n      if((rowCountComplete_) && (rowIndex >= rowCount_))\n        return;\n      if(resultSet_ == null)\n        return;\n\n      if(!updatable_) return; //@D6A\n\n      if(scrollable_)\n      {\n        try\n        {\n          // Update the value in the result set.\n          synchronized(resultSet_)\n          {\n            resultSet_.absolute(rowIndex+1);\n            resultSet_.updateObject(columnIndex+1, value);\n            resultSet_.updateRow();\n          }\n\n          // Update the value in the cache.\n          ((Object[])cachedRows_.elementAt(rowIndex - firstCachedRow_))[columnIndex] = value;\n        }\n        catch(SQLException e)\n        {\n          // Don't set error_ to true, because that will ruin the whole\n          // model.  Just fire an event and do not update the cache.\n          errorEventSupport_.fireError(e);\n        }\n\n      }\n    }\n  }\n\n  //@KKB - Checks if a Data Mapping Warning was issued\n  private boolean checkDataMappingWarning(ResultSet rs, int columnIndex) throws SQLException{\n      boolean dataMapping = false;\n      SQLWarning w = rs.getWarnings();\n      if(w!=null){\n          do{\n              if(w.getSQLState().equals(\"01004\") && ((java.sql.DataTruncation)w).getDataSize() == -1 && ((java.sql.DataTruncation)w).getTransferSize() == -1 && ((java.sql.DataTruncation)w).getIndex() == columnIndex)\n                  dataMapping = true;\n\n              w=w.getNextWarning();\n          }while(w!=null);\n      }\n\n      return dataMapping;\n  }\n\n  \n  \n/**\n * Set a reference to the JTable so that the selected row can be updated after \n * fireTableRowsInserted. \n * \n * @param table\n */\npublic void setTable(JTable table) {\n\ttable_ = table; \n\t\n}\n\n\n\n/**\n  Restore the state of this object from an object input stream.\n  It is used when deserializing an object.\n  @param sqlResultSetTablePane TODO\n * @param in The input stream of the object being deserialized.\n * @exception IOException\n  @exception ClassNotFoundException\n  **/\n  void readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)\n  throws IOException, ClassNotFoundException\n  {\n    // Restore the non-static and non-transient fields.\n    in.defaultReadObject();\n\n    // Initialize the transient fields.\n    sqlResultSetTablePane.changeListeners_ = new PropertyChangeSupport(sqlResultSetTablePane);\n    addPropertyChangeListener(sqlResultSetTablePane.changeListeners_);\n    sqlResultSetTablePane.vetoListeners_ = new VetoableChangeSupport(sqlResultSetTablePane);\n    addVetoableChangeListener(sqlResultSetTablePane.vetoListeners_);\n    sqlResultSetTablePane.errorListeners_ = new ErrorEventSupport(sqlResultSetTablePane);\n    addErrorListener(sqlResultSetTablePane.errorListeners_);\n    sqlResultSetTablePane.worker_ = new WorkingCursorAdapter(sqlResultSetTablePane);\n    addWorkingListener(sqlResultSetTablePane.worker_);\n    sqlResultSetTablePane.selectionListeners_ = new ListSelectionEventSupport(sqlResultSetTablePane);\n\n    sqlResultSetTablePane.initializeTransient(); //@B0A\n    //@B0D table_.getSelectionModel().addListSelectionListener(selectionListeners_);\n\n    //@B0 - table_ is now transient, so we need to reset its attributes.\n    sqlResultSetTablePane.table_.setGridColor(sqlResultSetTablePane.tableColor_); //@B0A\n    sqlResultSetTablePane.table_.setShowHorizontalLines(sqlResultSetTablePane.tableShowHorizontalLines_); //@B0A\n    sqlResultSetTablePane.table_.setShowVerticalLines(sqlResultSetTablePane.tableShowVerticalLines_); //@B0A\n\n  }\n\n\n  \n  \n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 1297,
                        "lineEnd": 1330,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to com.ibm.as400.vaccess.SQLResultSetTablePane\nRationale: The method readObject2 directly manipulates the fields and properties of the SQLResultSetTablePane instance, indicating that it is closely tied to the state and behavior of this class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 8856
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setTable",
                            "method_signature": "public void setTable(JTable table)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The setTable() method is responsible for setting a reference to a JTable, which is more relevant to the SQLResultSetTablePane class that likely manages the UI components. Moving it there would improve cohesion."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The readObject2() method is specifically designed to restore the state of the SQLResultSetTablePane, making it more appropriate to reside within that class to maintain better encapsulation."
                        }
                    ],
                    "llm_response_time": 2929
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "setTable",
                            "method_signature": "public void setTable(JTable table)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The setTable() method is responsible for setting a reference to a JTable, which is more relevant to the SQLResultSetTablePane class that likely manages the UI components. Moving it there would improve cohesion."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The readObject2() method is specifically designed to restore the state of the SQLResultSetTablePane, making it more appropriate to reside within that class to maintain encapsulation and clarity."
                        }
                    ],
                    "llm_response_time": 2194
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "setTable",
                            "method_signature": "public void setTable(JTable table)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The setTable() method is responsible for setting a reference to a JTable, which is more relevant to the SQLResultSetTablePane class that likely manages the UI components. Moving it there would improve cohesion."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The readObject2() method is specifically designed to restore the state of the SQLResultSetTablePane, making it more appropriate to reside within that class for better encapsulation."
                        }
                    ],
                    "llm_response_time": 2707
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "setTable",
                            "method_signature": "public void setTable(JTable table)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The setTable() method is responsible for setting a reference to a JTable, which is more relevant to the SQLResultSetTablePane class that likely manages the UI components. Moving it there would improve cohesion."
                        },
                        {
                            "method_name": "readObject2",
                            "method_signature": "void readObject2(SQLResultSetTablePane sqlResultSetTablePane, ObjectInputStream in)",
                            "target_class": "SQLResultSetTablePane",
                            "rationale": "The readObject2() method is specifically designed to restore the state of the SQLResultSetTablePane, making it more appropriate to reside within that class to maintain better encapsulation."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "setTable",
                    "readObject2"
                ],
                "llm_response_time": 925
            },
            "targetClassMap": {
                "setTable": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1652,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "readObject2": {
                    "target_classes": [
                        {
                            "class_name": "SQLResultSetTablePane",
                            "similarity_score": 0.568061770869418
                        },
                        {
                            "class_name": "SQLConnection",
                            "similarity_score": 0.5398874302710917
                        },
                        {
                            "class_name": "PropertyChangeSupport",
                            "similarity_score": 0.31285654688986536
                        },
                        {
                            "class_name": "VetoableChangeSupport",
                            "similarity_score": 0.3301593230334562
                        },
                        {
                            "class_name": "ErrorEventSupport",
                            "similarity_score": 0.38034536781567435
                        },
                        {
                            "class_name": "WorkingEventSupport",
                            "similarity_score": 0.3487555464057905
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "SQLResultSetTablePane",
                        "PropertyChangeSupport",
                        "VetoableChangeSupport",
                        "ErrorEventSupport",
                        "WorkingEventSupport",
                        "SQLConnection"
                    ],
                    "llm_response_time": 3047,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.access.SpooledFile::applyChanges():void need move com.ibm.as400.vaccess.OutputPropertiesPane",
        "class_name": "com.ibm.as400.access.SpooledFile",
        "telemetry": {
            "id": "060fe944-28f7-407e-ae07-efa464266b0d",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 1306,
                "lineStart": 22,
                "lineEnd": 1327,
                "bodyLineStart": 22,
                "language": "java",
                "sourceCode": "/**\n * Represents a spooled file.\n * You can use an instance of this class to manipulate an individual\n * spooled file (hold, release, delete, send, read, and so on).\n * To create new spooled files on the system, use the\n * {@link SpooledFileOutputStream SpooledFileOutputStream} class.\n *\n * See <a href=\"{@docRoot}/com/ibm/as400/access/doc-files/SpooledFileAttrs.html\">Spooled File Attributes</a> for\n * valid attributes.\n *\n * @see PrintObjectInputStream\n * @see PrintObjectPageInputStream\n * @see PrintObjectTransformedInputStream\n **/\n\npublic class SpooledFile extends PrintObject\nimplements java.io.Serializable\n{\n    static final long serialVersionUID = 4L;\n\n    transient boolean fMsgRetrieved_  = false;\n\n    // constructor used internally (not externalized since it takes\n    // an ID code point\n    SpooledFile(AS400 system, NPCPIDSplF id, NPCPAttribute attrs)\n    {\n       super(system, id, attrs, NPConstants.SPOOLED_FILE);\n    }\n\n\n    // We have decide that spooled files are too transient to be JavaBeans.\n\n\n    /**\n     * Constructs a SpooledFile object. It uses the specified system and\n     * spooled file attributes that identify it on that system.\n     *\n     * @param system The system on which this spooled file exists.\n     * @param name The name of the spooled file.\n     * @param number The number of the spooled file.\n     * @param jobName The name of the job that created the spooled file.\n     * @param jobUser The user who created the spooled file.\n     * @param jobNumber The number of the job that created the spooled file.\n     *\n     **/\n    public SpooledFile(AS400 system,\n                       String name,\n                       int    number,\n                       String jobName,\n                       String jobUser,\n                       String jobNumber)\n    {\n        super(system,\n              new NPCPIDSplF(name,\n                             number,\n                             jobName,\n                             jobUser,\n                             jobNumber),\n              null,\n              NPConstants.SPOOLED_FILE);\n\n        // base class constructor checks for null system.\n        if (name == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'name' is null.\");\n            throw new NullPointerException(\"name\");\n        }\n\n        if (number < -1)    // (changed from 1 to -1 to allow 0(=*ONLY) and -1(=*LAST))\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'number' is less than -1.\");\n            throw new ExtendedIllegalArgumentException(\n                \"number(\" + number + \")\",\n                ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        if (jobName == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobName' is null.\");\n            throw new NullPointerException(\"jobName\");\n        }\n\n        if (jobUser == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobUser' is null.\");\n            throw new NullPointerException(\"jobUser\");\n        }\n\n        if (jobNumber == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobNumber' is null.\");\n            throw new NullPointerException(\"jobNumber\");\n        }\n    }\n    \n    // Alternate constructor for spooled files detached from jobs\n    /**\n     * Constructs a SpooledFile object. It uses the specified system and\n     * spooled file attributes that identify it on that system.\n     *\n     * @param system The system on which this spooled file exists.\n     * @param name The name of the spooled file.\n     * @param number The number of the spooled file.\n     * @param jobName The name of the job that created the spooled file.\n     * @param jobUser The user who created the spooled file.\n     * @param jobNumber The number of the job that created the spooled file.\n     * @param jobSysName The name of the system where the spooled file was created.\n     * @param createDate The date the spooled file was created on the system.\n     * <br>\n     * The date is encoded in a character string with the following format,\n     * CYYMMDD where:\n     * <ul>\n     * <li> C is the Century, where 0 indicates years 19xx and 1 indicates years 20xx\n     * <li> YY is the Year\n     * <li> MM is the Month\n     * <li> DD is the Day\n     * </ul>\n     * @param createTime The time the spooled file was created on the system.\n     * <br>\n     * The time is encoded in a character string with the following format,\n     * HHMMSS where:\n     * <ul>\n     * <li> HH - Hour \n     * <li> MM - Minutes \n     * <li> SS - Seconds \n     * </ul>\n     **/\n   \n    public SpooledFile(AS400 system,\n                       String name,\n                       int    number,\n                       String jobName,\n                       String jobUser,\n                       String jobNumber,\n                       String jobSysName,\n                       String createDate,\n                       String createTime)\n    {\n        super(system,\n              new NPCPIDSplF(name,\n                             number,\n                             jobName,\n                             jobUser,\n                             jobNumber,\n                             jobSysName,\n                             createDate,\n                             createTime),\n              null,\n              NPConstants.SPOOLED_FILE);\n\n        // base class constructor checks for null system.\n   \n        if (name == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'name' is null.\");\n            throw new NullPointerException(\"name\");\n        }\n\n        if (number < -1)    // (changed from 1 to -1 to allow 0(=*ONLY) and -1(=*LAST))\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'number' is less than -1.\");\n            throw new ExtendedIllegalArgumentException(\n                \"number(\" + number + \")\",\n                ExtendedIllegalArgumentException.PARAMETER_VALUE_NOT_VALID);\n        }\n\n        if (jobName == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobName' is null.\");\n            throw new NullPointerException(\"jobName\");\n        }\n\n        if (jobUser == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobUser' is null.\");\n            throw new NullPointerException(\"jobUser\");\n        }\n\n        if (jobNumber == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobNumber' is null.\");\n            throw new NullPointerException(\"jobNumber\");\n        }\n        \n        if (jobSysName == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'jobSysName' is null.\");\n            throw new NullPointerException(\"jobSysName\");\n        }\n        \n        if (createDate == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'createDate' is null.\");\n            throw new NullPointerException(\"createDate\");\n        }\n        \n        if (createTime == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'createTime' is null.\");\n            throw new NullPointerException(\"createTime\");\n        }\n    }\n\n\n\n    /** Replies to the message that caused the spooled file to wait.\n     *\n     * @param reply The string that contains the reply for the message.\n     *              The default reply can be obtained by calling\n     *              the getMessage() method, and then calling the\n     *              getDefaultReply() method on the message object that is returned.\n     *              Other possible replies are given in the message help,\n     *              which can also be retrieved from the message object returned\n     *              on the getMessage() method.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is\n     *                                            completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                          system is not at the correct level.\n     **/\n    public void answerMessage(String reply)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).answerMessage(reply);\n        // update the spooled file attributes\n        attrs = impl_.getAttrValue();\n        fMsgRetrieved_ = ((SpooledFileImpl) impl_).getFMsgRetrieved();\n    }\n\n\n\n    /**\n     * Chooses the implementation\n     **/\n    void chooseImpl()\n    throws IOException, AS400SecurityException\n    {\n        // We need to get the system to connect to...\n        AS400 system = getSystem();\n        if (system == null) {\n            Trace.log( Trace.ERROR, \"Attempt to use SpooledFile before setting system.\" );\n            throw new ExtendedIllegalStateException(\"system\",\n                                    ExtendedIllegalStateException.PROPERTY_NOT_SET);\n        }\n\n        impl_ = (SpooledFileImpl) system.loadImpl2(\"com.ibm.as400.access.SpooledFileImplRemote\",\n                                                   \"com.ibm.as400.access.SpooledFileImplProxy\");\n        // The connectService(AS400.PRINT) is done in setImpl()\n        // in the Printobject class.\n        super.setImpl();  \n    }\n    \n        \n    \n    /**\n     * Creates a copy of the spooled file this (SpooledFile) object represents.  The\n     * new spooled file is created on the same output queue and on the same system \n     * as the original spooled file. A reference to the new spooled file is returned.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system is not at the correct level.\n     **/\n    public SpooledFile copy()\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        String name = getStringAttribute(ATTR_OUTPUT_QUEUE);\n        OutputQueue outq = new OutputQueue(getSystem(), name);\n        SpooledFile sf = copy(outq);\n        return sf;\n    }\n\n\n\n    /**\n     * Creates a copy of the spooled file this object represents.  The\n     * new spooled file is created on the specified output queue.\n     * A reference to the new spooled file is returned.\n     *\n     * @param outputQueue The output queue location to create the new version of the\n     *       original spooled file.  The spooled file will be created to the first\n     *       position on this output queue.  The output queue and this spooled\n     *       file must reside on the same system.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system is not at the correct level.\n     **/\n    public SpooledFile copy(OutputQueue outputQueue)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        // choose implementations\n        if (impl_ == null) {\n            chooseImpl();\n        }\n        if (outputQueue.getImpl() == null) {     \n            outputQueue.chooseImpl();        \n        }                        \n        \n        NPCPIDSplF spID = \n        ((SpooledFileImpl) impl_).copy((OutputQueueImpl)outputQueue.getImpl()); \n    \t\n        try {\n            spID.setConverter((new Converter(getSystem().getCcsid(), getSystem())).impl);\n        }\n        catch (UnsupportedEncodingException e) {\n            if (Trace.isTraceErrorOn()) {\n                Trace.log(Trace.ERROR, \"Error initializing converter for spooled file.\");\n            }\n        }\n        SpooledFile sf = new SpooledFile(getSystem(), spID, null);\n        return sf;\n    }\n\n\n\n    /**\n      * Deletes the spooled file on the system.\n      *\n      * @exception AS400Exception If the system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      **/\n    public void delete()\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).delete();\n    }\n\n\n    /**\n      * Returns an input stream that can be used to read the contents of the\n      * spooled file.\n      * This method will fail with an AS400Exception if the spooled file is\n      * still being created (ATTR_SPLFSTATUS is *OPEN).\n      * Note that the bytes are returned untransformed, that is, as they are\n      * stored on the server.  To transform the bytes into other forms, use\n      * {@link #getPageInputStream getPageInputStream} or\n      * {@link #getTransformedInputStream getTransformedInputStream}.\n      *\n      * @return The input stream object that can be used to read the contents\n      *         of this spooled file.\n      * @exception AS400Exception If system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception RequestNotSupportedException If the requested function is not supported\n      *                                         because the system is not at the\n      *                                         correct level.\n      * @see #getPageInputStream\n      * @see #getTransformedInputStream\n      **/\n    public PrintObjectInputStream getInputStream()\n        throws AS400Exception,\n               AS400SecurityException,\n               ErrorCompletingRequestException,\n               IOException,\n               InterruptedException,\n               RequestNotSupportedException\n    {\n        PrintObjectInputStream is = new PrintObjectInputStream(this, null);\n        return is;\n    }\n\n\n    /**\n      * Returns an input stream that can be used to read the contents of the\n      * spooled file.\n      * This method will fail with an AS400Exception if the spooled file is\n      * still being created (ATTR_SPLFSTATUS is *OPEN).\n      * Note that the bytes are returned untransformed, that is, as they are\n      * stored on the server.  To transform the bytes into other forms, use\n      * {@link #getPageInputStream getPageInputStream} or\n      * {@link #getTransformedInputStream getTransformedInputStream}.\n      *\n      * @return The input stream object that can be used to read the contents\n      *         of this spooled file.\n      * @exception AS400Exception If system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      * @exception RequestNotSupportedException If the requested function is not supported\n      *                                         because the system is not at the\n      *                                         correct level.\n      * @see #getPageInputStream\n      * @see #getTransformedInputStream\n      **/\n    public PrintObjectInputStream getInputStream(PrintParameterList ppl)\n        throws AS400Exception,\n               AS400SecurityException,\n               ErrorCompletingRequestException,\n               IOException,\n               InterruptedException,\n               RequestNotSupportedException\n    {\n        PrintObjectInputStream is = new PrintObjectInputStream(this, ppl);\n        return(is);\n    }\n    \n    \n    /**\n      *  @deprecated Use getAFPInputStream() instead.\n      *  @see #getAFPInputStream\n      **/\n    public PrintObjectInputStream getInputACIFMergedStream(boolean acifB)\n        throws AS400Exception,\n               AS400SecurityException,\n               ErrorCompletingRequestException,\n               IOException,\n               InterruptedException,\n               RequestNotSupportedException\n    {\n        String acifS;\n        // possible open options that we could use -\n        // acifB == true then process ACIF merged data\n        // else normal processing\n        if (acifB){\n            acifS = \"Y\";\n            } else acifS = \"N\"; \n\n        PrintObjectInputStream is = new PrintObjectInputStream(this, null, acifS);\n        return is;\n    }\n\n    /**\n     * Returns an input stream that can be used to read the contents of an \n     * AFP spooled file. The external resources referenced by the original \n     * AFP spooled file will be included in this input stream. If you don't want \n     * the external resources included use \n     * {@link #getInputStream getInputStream} or\n     * {@link #getPageInputStream getPageInputStream}.\n     * This method will fail with an AS400Exception if the spooled file is\n     * still being created (ATTR_SPLFSTATUS is *OPEN) or if the spooled file\n     * doesn't contain AFDS data ie. ATTR_PRTDEVTYPE is not *AFPDS. \n     *\n     * @return The input stream object that can be used to read the contents\n     *         of this spooled file.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported\n     *                                         because the system operating system is not\n     *                                         at the correct level.\n     * @see #getInputStream\n     * @see #getPageInputStream\n     **/\n   public PrintObjectInputStream getAFPInputStream()\n       throws AS400Exception,\n              AS400SecurityException,\n              ErrorCompletingRequestException,\n              IOException,\n              InterruptedException,\n              RequestNotSupportedException\n   {\n       PrintObjectInputStream is = new PrintObjectInputStream(this, null, \"Y\");\n       return is;\n   }\n\n    /**\n      * Returns the name of the job that created the spooled file.\n      * @return The job name.\n      **/\n    public String getJobName()\n    {\n        NPCPID IDCodePoint = getIDCodePoint();\n\n        if( IDCodePoint == null ) {\n            return EMPTY_STRING; // \"\"\n        } else {\n            return IDCodePoint.getStringValue(ATTR_JOBNAME);\n        }\n    }\n\n\n\n    /**\n      * Returns the number of the job that created the spooled file.\n      * @return The job number.\n      **/\n    public String getJobNumber()\n    {\n        NPCPID IDCodePoint = getIDCodePoint();\n\n        if( IDCodePoint == null ) {\n            return EMPTY_STRING; // \"\"\n        } else {\n            return IDCodePoint.getStringValue(ATTR_JOBNUMBER);\n        }\n    }\n\n\n\n    /**\n     * Returns the ID of the user that created the spooled file.\n     * @return The user ID.\n     **/\n    public String getJobUser()\n    {\n        NPCPID IDCodePoint = getIDCodePoint();\n\n        if( IDCodePoint == null ) {\n            return EMPTY_STRING; // \"\"\n        } else {\n            return IDCodePoint.getStringValue(ATTR_JOBUSER);\n        }\n    }\n\n    // The next three attributes are added to provide the\n    // decoupled spooled file identity.\n   \n    /**\n    * Returns the name of the system where the spooled file was created.\n    * @return The name of the system where the spooled file was created.\n    **/\n    public String getJobSysName()\n    {\n        String jobSysName = EMPTY_STRING;\n        NPCPID IDCodePoint = getIDCodePoint();\n        if (IDCodePoint == null) {\n            return(jobSysName);\n        } else {\n            jobSysName = IDCodePoint.getStringValue(ATTR_JOBSYSTEM);\n            if (jobSysName == null) {\n                try {\n                    jobSysName = this.getStringAttribute(ATTR_JOBSYSTEM);\n                }\n                catch (Exception e) {\n                    // ignore exceptions, splf may not have this attr.\n                    jobSysName = EMPTY_STRING;\n                }\n            }\n            return(jobSysName);\n        }\n    }\n    \n    /**\n    * Returns the date of the spooled file creation. \n    * The date is encoded in the CYYMMDD format.\n    * @return The date (CYYMMDD) of the spooled file creation.\n    **/\n    public String getCreateDate()\n    {\n        String createDate = EMPTY_STRING;\n        NPCPID IDCodePoint = getIDCodePoint();\n        if (IDCodePoint == null) {\n            return(createDate);\n        } else {\n            createDate = IDCodePoint.getStringValue(ATTR_DATE);\n            if (createDate == null) {\n                try {\n                    createDate = this.getStringAttribute(ATTR_DATE);\n                }\n                catch (Exception e) {\n                    // ignore exceptions, splf may not have this attr.\n                    createDate = EMPTY_STRING;\n                }\n            }   \n            return(createDate);\n        }\n    }\n    \n    /**\n    * Returns the time of spooled file creation.\n    * The time is encoded in the HHMMSS format.\n    * @return The time (HHMMSS) of the spooled file creation.\n    **/\n    public String getCreateTime()\n    {\n        String createTime = EMPTY_STRING;\n        NPCPID IDCodePoint = getIDCodePoint();\n        if (IDCodePoint == null) {\n            return(createTime);\n        } else {\n            createTime = IDCodePoint.getStringValue(ATTR_TIME);\n            if (createTime == null) {\n                try {\n                    createTime = this.getStringAttribute(ATTR_TIME);\n                }\n                catch (Exception e) {\n                    // ignore exceptions, splf may not have this attr.\n                    createTime = EMPTY_STRING;\n                }\n            }   \n            return(createTime);\n        }\n    }\n    \n    /**\n      * Returns the message that is associated with this spooled file.\n      * A spooled file has a message associated with it if its\n      * ATTR_SPLFSTATUS attribute returns *MESSAGE.\n      *\n      * @return The AS400Message object that contains the message text,\n      *   type, severity, id, date, time, and default reply.\n      * @exception AS400Exception If the system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      **/\n    public AS400Message getMessage()\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        AS400Message msg = ((SpooledFileImpl) impl_).getMessage();\n        fMsgRetrieved_   = ((SpooledFileImpl) impl_).getFMsgRetrieved();\n        return msg;\n    }\n\n\n\n    /**\n     * Returns the name of the spooled file.\n     * @return The name of the spooled file.\n     **/\n    public String getName()\n    {\n        NPCPID IDCodePoint = getIDCodePoint();\n\n        if( IDCodePoint == null )\n        {\n            return EMPTY_STRING; // \"\"\n        } else {\n            return IDCodePoint.getStringValue(ATTR_SPOOLFILE);\n        }\n    }\n\n\n\n    /**\n      * Returns the number of the spooled file.\n      * @return The number of the spooled file.\n      **/\n    public int getNumber()\n    {\n        NPCPID IDCodePoint = getIDCodePoint();\n\n        if( IDCodePoint == null ) {\n            return 0;\n        } else {\n            return IDCodePoint.getIntValue(ATTR_SPLFNUM).intValue();\n        }\n    }\n\n\n\n    /**\n     * Returns a page input stream that can be used to read the contents of the\n     * spooled file, one page at a time.\n     * <br>\n     * See <a href=\"{@docRoot}/com/ibm/as400/access/doc-files/TransInStr.html\">Example using PrintObjectPageInputStream</a>\n     * <br>\n     * @param pageStreamOptions A print parameter list that contains\n     *  parameters for generating the page input stream. <br>\n     * The following attributes are optional:\n     * <UL>\n     *   <LI> ATTR_MFGTYPE                 - Specifies the manufacturer type and model.\n     *   <LI> ATTR_WORKSTATION_CUST_OBJECT - Specifies the integrated file system name of\n     *                                       the workstation customization object to be\n     *                                       used.  The workstation customizing object\n     *                                       associated with the manufacturer, type, and\n     *                                       model is the default.\n     *   <LI> ATTR_PAPER_SOURCE_1          - Specifies the paper size of drawer 1.\n     *   <LI> ATTR_PAPER_SOURCE_2          - Specifies the paper size of drawer 2.\n     *   <LI> ATTR_VIEWING_FIDELITY        - Specifies the fidelity used to process pages.\n     *\n     * </UL>\n     *\n     * @return A page input stream object that can be used to read the contents\n     *         of this spooled file, one page at a time.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed,\n                                                  or the spooled file format is not supported.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported\n     *                                         because the system operating system is not\n     *                                         at the correct level.\n     **/\n    public PrintObjectPageInputStream getPageInputStream(PrintParameterList pageStreamOptions)\n\t    throws AS400Exception,\n\t           AS400SecurityException,\n\t           ErrorCompletingRequestException,\n\t           IOException,\n\t           InterruptedException,\n\t           RequestNotSupportedException\n    {\n        PrintObjectPageInputStream is = new PrintObjectPageInputStream(this, pageStreamOptions);\n        return is;\n    }\n\n\n\n    /**\n     * Returns a transformed input stream that can be used to read the contents of the\n     * spooled file.\n     * <br>\n     * See <a href=\"{@docRoot}/com/ibm/as400/access/doc-files/TransInStr.html\">Example using PrintObjectTransformedInputStream</a>\n     * <br>\n     * @param transformOptions A print parameter list that contains\n     *  parameters for generating the transformed input stream. <br>\n     * The following attribute MUST be set:\n     * <UL>\n     *   <LI> ATTR_MFGTYPE  - Specifies the manufacturer, type, and model.\n     * </UL>\n     * The following attributes are optional:\n     * <UL>\n     *   <LI> ATTR_WORKSTATION_CUST_OBJECT - Specifies the integrated file system name of\n     *                                       the workstation customization object to be\n     *                                       used.  The workstation customizing object\n     *                                       associated with the manufacturer, type, and\n     *                                       model is the default.\n     *   <LI> ATTR_PAPER_SOURCE_1          - Specifies the paper size of drawer 1.\n     *   <LI> ATTR_PAPER_SOURCE_2          - Specifies the paper size of drawer 2.\n     *\n     * </UL>\n     *\n     * @return The transformed input stream object that can be used to read the contents\n     *         of the transformed spooled file.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed,\n     *                                            or the spooled file format is not supported.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported\n     *                                         because the system operating system is not\n     *                                         at the correct level.\n     **/\n    public PrintObjectTransformedInputStream getTransformedInputStream(PrintParameterList transformOptions)\n\t    throws AS400Exception,\n\t           AS400SecurityException,\n\t           ErrorCompletingRequestException,\n\t           IOException,\n\t           InterruptedException,\n\t           RequestNotSupportedException\n    {\n        PrintObjectTransformedInputStream is = new PrintObjectTransformedInputStream(this, transformOptions);\n        return is;\n    }\n\n\n\n    /**\n     * Holds the spooled file.\n     * @param holdType When to hold the spooled file.\n     *  May be any of the following values:\n     * <UL>\n     *   <LI> *IMMED - The spooled file is held immediately.\n     *   <LI> *PAGEEND - The spooled file is held at the end of the current page.\n     * </UL>\n     *  <i>holdType</i> may be null.  If <i>holdType</i> is not specified, the default is\n     * *IMMED.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported\n     *                                         because the system operating system is not\n     *                                         at the correct level.\n     **/\n    public void hold(String holdType)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).hold(holdType);\n        // update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\n    /**\n     * Moves the spooled file to another output queue or to another\n     * position on the same output queue.\n     *\n     * @param targetSpooledFile The spooled file to move this\n     *       spooled file after.  The targetSpooledFile and this spooled file\n     *       must reside on the same system.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system operating system is not at the correct level.\n     **/\n    public void move(SpooledFile targetSpooledFile)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        if (targetSpooledFile.getImpl() == null) {\n            targetSpooledFile.chooseImpl();\n        }\n        ((SpooledFileImpl) impl_).move((SpooledFileImpl)targetSpooledFile.getImpl());\n    \t//update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\n    /**\n     * Moves the spooled file to another output queue.\n     *\n     * @param targetOutputQueue The output queue to move the\n     *       spooled file to.  The spooled file will be moved to the first\n     *       position on this output queue.  The output queue and this spooled\n     *       file must reside on the same system.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system operating system is not at the correct level.\n     **/\n    public void move(OutputQueue targetOutputQueue)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        if (targetOutputQueue.getImpl() == null) {\n            targetOutputQueue.chooseImpl();\n        }\n        ((SpooledFileImpl) impl_).move((OutputQueueImpl)targetOutputQueue.getImpl());\n    \t// update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\n    /**\n     * Moves the spooled file to the first position on the output queue.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system operating system is not at the correct level.\n     **/\n    public void moveToTop()\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).moveToTop();\n    \t// update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\n    /**\n    Restores the state of the object from an input stream.\n    This is used when deserializing an object.\n\n    @param in   The input stream.\n\n    @exception IOException Thrown if an IO error occurs.\n    @exception ClassNotFoundException Thrown if class is not found.\n    **/\n    private void readObject(ObjectInputStream in)\n        throws IOException, ClassNotFoundException\n    {\n        in.defaultReadObject();\n        fMsgRetrieved_ = false;\n    }\n\n\n\n    /**\n     * Releases a held spooled file on the system.\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system.\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system operating system is not at the correct level.\n     **/\n    public void release()\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).release();\n    \t// update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\n    /**\n      * Sends the spooled file to another user on the same system or to\n      * a remote system on the network.  The equivalent of the system\n      * Send Network Spooled File\n      * (SNDNETSPLF) command will be issued against the spooled file.\n      *\n      * @param sendOptions A print parameter list that contains the\n      *  parameters for the send.  The following attributes MUST be set:\n      * <UL>\n      *   <LI> ATTR_TOUSERID  - Specifies the user ID to send the spooled file to.\n      *   <LI> ATTR_TOADDRESS - Specifies the remote system to send the spooled file to.\n      * </UL>\n      * The following attributes are optional:\n      * <UL>\n      *   <LI> ATTR_DATAFORMAT - Specifies the data format in which to transmit the\n      *                           spooled file.  May be either of *RCDDATA or\n      *                           *ALLDATA.  *RCDDATA is the default.\n      *   <LI> ATTR_VMMVSCLASS - Specifies the VM/MVS SYSOUT class for distributions\n      *                          sent to a VM host system or to an MVS host system.\n      *                          May be A to Z or 0 to 9.  A is the default.\n      *   <LI> ATTR_SENDPTY - Specifies the queueing priority used for this spooled file\n      *                        when it is being routed through a SNADS network.  May be\n      *                        *NORMAL or *HIGH.  *NORMAL is the default.\n      * </UL>\n      *\n      * @exception AS400Exception If the system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      **/\n    public void sendNet(PrintParameterList sendOptions)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).sendNet(sendOptions);\n    }\n\n\n\n    /**\n      * Sends a spooled file to be printed on a remote system.\n      * The equivalent of the Send TCP/IP Spooled File\n      * (SNDTCPSPLF) command will be issued against the spooled file.\n      * This is the system's version of the TCP/IP LPR command.\n      *\n      * @param sendOptions A print parameter list that contains the\n      *  parameters for the send.  The following attributes MUST be set:\n      * <UL>\n      *   <LI> ATTR_RMTSYSTEM - Specifies the remote system to which the print\n      *                          request will be sent.  May be a remote system\n      *                          name or the special value *INTNETADR.\n      *   <LI> ATTR_RMTPRTQ - Specifies the name of the destination print queue.\n      * </UL>\n      * The following attributes are optional:\n      * <UL>\n      *   <LI> ATTR_DELETESPLF - Specifies whether or not to delete the spooled file\n      *                           after it has been successfully sent.  May be *NO\n      *                           or *YES.   *NO is the default.\n      *   <LI> ATTR_DESTOPTION - Specifies a destination-dependant option.  These options will\n      *                          be sent to the remote system with the spooled file.\n      *   <LI> ATTR_DESTINATION - Specifies the type of system to which the spooled file is\n      *                           being sent.  When sending to other IBM i systems, this value\n      *                           should be *AS/400.  May also be *OTHER or *PSF/2.\n      *                           *OTHER is the default.\n      *   <LI> ATTR_INTERNETADDR - Specifies the Internet address of the receiving system.\n      *   <LI> ATTR_MFGTYPE  - Specifies the manufacturer, type, and model when transforming print\n      *                        data from SCS or AFP to ASCII.\n      *   <LI> ATTR_SCS2ASCII - Specifies whether the print data is to be transformed to\n      *                         ASCII.  May be *NO or *YES.  *NO is the default.\n      *   <LI> ATTR_SEPPAGE - Specifies whether to print the separator page.  May be\n      *                        *NO or *YES.  *YES is the default.\n      * </UL>\n      *\n      * @exception AS400Exception If the system returns an error message.\n      * @exception AS400SecurityException If a security or authority error occurs.\n      * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n      * @exception IOException If an error occurs while communicating with the system.\n      * @exception InterruptedException If this thread is interrupted.\n      **/\n    public void sendTCP(PrintParameterList sendOptions)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException\n    {\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).sendTCP(sendOptions);\n    }\n\n\n\n    /**\n     * Sets one or more attributes of the object.  See\n     * <a href=\"{@docRoot}/com/ibm/as400/access/doc-files/SpooledFileAttrs.html\">Spooled File Attributes</a> for\n     * a list of valid attributes that can be changed.\n     *\n     * @param attributes A print parameter list that contains the\n     *  attributes to be changed.\n     *\n     * @exception AS400Exception If the system returns an error message.\n     * @exception AS400SecurityException If a security or authority error occurs.\n     * @exception ErrorCompletingRequestException If an error occurs before the request is completed.\n     * @exception IOException If an error occurs while communicating with the system\n     * @exception InterruptedException If this thread is interrupted.\n     * @exception RequestNotSupportedException If the requested function is not supported because the\n     *                                         system operating system is not at the correct level.\n     **/\n    public void setAttributes(PrintParameterList attributes)\n      throws AS400Exception,\n             AS400SecurityException,\n             ErrorCompletingRequestException,\n             IOException,\n             InterruptedException,\n             RequestNotSupportedException\n    {\n        if (attributes == null)\n        {\n            Trace.log(Trace.ERROR, \"Parameter 'attributes' is null.\");\n            throw new NullPointerException(\"attributes\");\n        }\n\n        if (impl_ == null)\n            chooseImpl();\n        ((SpooledFileImpl) impl_).setAttributes(attributes);\n\n        // we changed the spooled file attributes on the system,\n        // merge those changed attributes into our current attributes\n        // here.\n        if (attrs == null)\n        {\n            attrs = new NPCPAttribute();\n        }\n    \t// update the spooled file attributes\n        attrs = impl_.getAttrValue();\n    }\n\n\n\t/**\n\tApplies the changes made by the user.\n\t\n\t@param outputPropertiesPane TODO\n\t * @throws Exception\n\t**/\n\t    public void applyChanges2 (OutputPropertiesPane outputPropertiesPane)\n\t      throws Exception\n\t    {\n\t        // create a print parameter list to hold the attributes that were updated\n\t        PrintParameterList pList_ = new PrintParameterList();\n\t\n\t        ////////////////\n\t        // user data ///\n\t        ////////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldUserData = getStringAttribute(PrintObject.ATTR_USERDATA).trim();\n\t\n\t        // get the new value from the textfield\n\t        String newUserData = (String)outputPropertiesPane.userData_.getText().trim();\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldUserData.equals(newUserData)) pList_.setParameter(PrintObject.ATTR_USERDATA,newUserData);\n\t\n\t        //////////////////////////\n\t        // save after printing ///\n\t        //////////////////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldSaveData = getStringAttribute(PrintObject.ATTR_SAVE);\n\t\n\t        // get the new value from the combo box\n\t        String newSaveData = (String)outputPropertiesPane.saveBox_.getSelectedItem();\n\t\n\t        // change new value if necessary\n\t        if (newSaveData.equals(OutputPropertiesPane.noText_)) newSaveData = \"*NO\";\n\t        else if (newSaveData.equals(OutputPropertiesPane.yesText_)) newSaveData = \"*YES\";\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldSaveData.equals(newSaveData)) pList_.setParameter(PrintObject.ATTR_SAVE,newSaveData);\n\t\n\t        if (outputPropertiesPane.functionSupported_ == true) // @A2A\n\t        {\n\t            //////////////\n\t            // printer ///\n\t            //////////////\n\t            // get the previous value from the spooled file\n\t            String oldPrinter = getStringAttribute(PrintObject.ATTR_PRINTER).trim();\n\t\n\t            // get the new value from the textfield\n\t            String newPrinter = (String)(outputPropertiesPane.printer_.getText().trim());\n\t\n\t            // compare the values to see if a change is needed, and set as necessary\n\t            if ((!newPrinter.equals(OutputPropertiesPane.notAssignedText_)) && (!oldPrinter.equals(newPrinter))) {\n\t                pList_.setParameter(PrintObject.ATTR_PRINTER,newPrinter);\n\t            }\n\t\n\t            ///////////////////\n\t            // output queue ///\n\t            ///////////////////\n\t\n\t            // extract the output queue path into an object that knows how to parse it.\n\t            QSYSObjectPathName outQPath = new QSYSObjectPathName(getStringAttribute(PrintObject.ATTR_OUTPUT_QUEUE));\n\t\n\t            // get the previous value from the spooled file\n\t            String oldOutQ = outQPath.getObjectName().trim();\n\t\n\t            // get the new value from the textfield\n\t            String newOutQ = (String)outputPropertiesPane.outQ_.getText().trim();\n\t\n\t            // flag to indicate a output queue change\n\t            boolean fNewOutQ = false;\n\t\n\t            // compare the values to see if a change is needed, and set as necessary\n\t            if (!oldOutQ.equals(newOutQ))\n\t                {\n\t                // create a QSYSObjectPathName object to represent the new output queue with the old outq library\n\t                QSYSObjectPathName newOutQPath = new QSYSObjectPathName(outQPath.getLibraryName(), newOutQ, \"OUTQ\");\n\t\n\t                // set the IFS output queue attribute\n\t                pList_.setParameter(PrintObject.ATTR_OUTPUT_QUEUE,newOutQPath.getPath());\n\t\n\t                // set the flag to say that we did have an output queuue change\n\t                fNewOutQ = true;\n\t                }\n\t\n\t            ///////////////////////////\n\t            // output queue library ///\n\t            ///////////////////////////\n\t\n\t            // get the previous value from the spooled file\n\t            String oldOutQLib = outQPath.getLibraryName().trim();\n\t\n\t            // get the new value from the textfield\n\t            String newOutQLib = (String)outputPropertiesPane.outQLib_.getText().trim();\n\t\n\t            // compare the values to see if a change is needed, and set as necessary\n\t            if (!oldOutQLib.equals(newOutQLib))\n\t                {\n\t                QSYSObjectPathName newOutQPath;\n\t\n\t                // check to see if we had a output queue name change also\n\t                if (fNewOutQ)\n\t                    // create a QSYSObjectPathName object to represent the new output queue library and new output queue name\n\t                    newOutQPath = new QSYSObjectPathName(newOutQLib, newOutQ, \"OUTQ\");\n\t                else\n\t                    // create a QSYSObjectPathName object to represent the new output queue library and old output queue name\n\t                    newOutQPath = new QSYSObjectPathName(newOutQLib, oldOutQ, \"OUTQ\");\n\t\n\t                // set the IFS output queue attribute\n\t                pList_.setParameter(PrintObject.ATTR_OUTPUT_QUEUE,newOutQPath.getPath());\n\t                }\n\t        }\n\t\n\t        ////////////////////////////\n\t        // output queue priority ///\n\t        ////////////////////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldOutQPty = getStringAttribute(PrintObject.ATTR_OUTPTY);\n\t\n\t        // get the new value from the combo box\n\t        String newOutQPty = (String)outputPropertiesPane.outQPtyBox_.getSelectedItem();\n\t\n\t        // check to see if user selected Job Value if so set priority to *JOB\n\t        if (newOutQPty.equals(OutputPropertiesPane.jobValueText_)) newOutQPty = \"*JOB\";\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldOutQPty.equals(newOutQPty)) pList_.setParameter(PrintObject.ATTR_OUTPTY,newOutQPty);\n\t\n\t        ///////////////////\n\t        // Total copies ///\n\t        ///////////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldTotalCopies = getIntegerAttribute(PrintObject.ATTR_COPIES).toString();\n\t\n\t        // get the new value from the textfield\n\t        String newTotalCopies = (String)outputPropertiesPane.totalCopies_.getText().trim();\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldTotalCopies.equals(newTotalCopies))\n\t            pList_.setParameter(PrintObject.ATTR_COPIES,Integer.parseInt(newTotalCopies));\n\t\n\t        //////////////////\n\t        // Copies left ///\n\t        //////////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldCopiesLeft = getIntegerAttribute(PrintObject.ATTR_COPIESLEFT).toString();\n\t\n\t        // get the new value from the textfield\n\t        String newCopiesLeft = (String)outputPropertiesPane.copiesLeft_.getText().trim();\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldCopiesLeft.equals(newCopiesLeft))\n\t            pList_.setParameter(PrintObject.ATTR_COPIESLEFT,Integer.parseInt(newCopiesLeft));\n\t\n\t        ///////////////\n\t        // Form type //\n\t        ///////////////\n\t\n\t        // get the previous value from the spooled file\n\t        String oldFormType = getStringAttribute(PrintObject.ATTR_FORMTYPE).trim();\n\t\n\t        // get the new value from the textfield\n\t        String newFormType = (String)outputPropertiesPane.formType_.getText().trim();\n\t        if (newFormType.equals(OutputPropertiesPane.standardText_)) newFormType = \"*STD\";\n\t\n\t        // compare the values to see if a change is needed, and set as necessary\n\t        if (!oldFormType.equals(newFormType)) pList_.setParameter(PrintObject.ATTR_FORMTYPE,newFormType);\n\t\n\t\n\t        // fire started working event\n\t        outputPropertiesPane.workingEventSupport_.fireStartWorking();\n\t\n\t        //////////////////////////////////////////////////////\n\t        // Set the requested attributes of the spooled file //\n\t        //////////////////////////////////////////////////////\n\t        setAttributes(pList_);\n\t\n\t        // fire stopped working event\n\t        outputPropertiesPane.workingEventSupport_.fireStopWorking();\n\t\n\t        // notify object that there have been changes\n\t        outputPropertiesPane.objectEventSupport_.fireObjectChanged(outputPropertiesPane.object_);\n\t     }\n\n} // SpooledFile class"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 1137,
                        "lineEnd": 1324,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to com.ibm.as400.vaccess.OutputPropertiesPane\nRationale: The method applyChanges2 directly interacts with the OutputPropertiesPane instance, accessing its fields and components to retrieve user input values. It is responsible for applying changes based on user interactions within the OutputPropertiesPane, making it logical for this method to reside within that class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 7450
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_move_methods": [
                        {
                            "method_name": "applyChanges2",
                            "method_signature": "public void applyChanges2(OutputPropertiesPane outputPropertiesPane) throws Exception",
                            "target_class": "OutputPropertiesPane",
                            "rationale": "The method applyChanges2() is heavily dependent on the OutputPropertiesPane class for its functionality. It should be moved to that class to maintain cohesion and encapsulate related functionality."
                        }
                    ],
                    "llm_response_time": 2051
                },
                {
                    "iteration_num": 2,
                    "suggested_move_methods": [
                        {
                            "method_name": "applyChanges2",
                            "method_signature": "public void applyChanges2(OutputPropertiesPane outputPropertiesPane) throws Exception",
                            "target_class": "OutputPropertiesPane",
                            "rationale": "The method applyChanges2() is heavily dependent on the OutputPropertiesPane class for its functionality. It should be moved to that class to maintain cohesion and encapsulate the logic related to output properties."
                        }
                    ],
                    "llm_response_time": 1630
                },
                {
                    "iteration_num": 3,
                    "suggested_move_methods": [
                        {
                            "method_name": "applyChanges2",
                            "method_signature": "public void applyChanges2(OutputPropertiesPane outputPropertiesPane) throws Exception",
                            "target_class": "OutputPropertiesPane",
                            "rationale": "The method applyChanges2() is heavily dependent on the OutputPropertiesPane class for its functionality. It should be moved to that class to maintain cohesion and encapsulate related functionality."
                        }
                    ],
                    "llm_response_time": 2542
                },
                {
                    "iteration_num": -1,
                    "suggested_move_methods": [
                        {
                            "method_name": "applyChanges2",
                            "method_signature": "public void applyChanges2(OutputPropertiesPane outputPropertiesPane) throws Exception",
                            "target_class": "OutputPropertiesPane",
                            "rationale": "The method applyChanges2() is heavily dependent on the OutputPropertiesPane class for its functionality. It should be moved to that class to maintain cohesion and encapsulate related functionality."
                        }
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "applyChanges2"
                ],
                "llm_response_time": 1089
            },
            "targetClassMap": {
                "applyChanges2": {
                    "target_classes": [
                        {
                            "class_name": "OutputPropertiesPane",
                            "similarity_score": 0.5562371558833118
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "OutputPropertiesPane"
                    ],
                    "llm_response_time": 1552,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method com.ibm.as400.access.AS400JDBCDataSource::applyChanges():boolean need move com.ibm.as400.vaccess.AS400JDBCDataSourcePane",
        "class_name": "com.ibm.as400.access.AS400JDBCDataSource",
        "telemetry": {}
    },
    {
        "oracle": "method com.ibm.as400.access.Permission::removeRow(int):void need move com.ibm.as400.vaccess.PermissionTableModelQSYS",
        "class_name": "com.ibm.as400.access.Permission",
        "telemetry": {}
    },
    {
        "oracle": "method com.ibm.as400.access.AS400ZonedDecimal::addToHashtable(PcmlDocNode):void need move com.ibm.as400.data.PcmlDocument",
        "class_name": "com.ibm.as400.access.AS400ZonedDecimal",
        "telemetry": {}
    }
]