[
    {
        "oracle": "method org.apache.derby.client.net.NetConnectionReply::getInputStream():java.io.InputStream need move to org.apache.derby.client.net.NetAgent",
        "class_name": "org.apache.derby.client.net.NetConnectionReply",
        "telemetry": {
            "id": "a8813be1-45ea-4da1-ad68-3162f946b6f1",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 3357,
                "lineStart": 44,
                "lineEnd": 3400,
                "bodyLineStart": 44,
                "language": "java",
                "sourceCode": "public class NetConnectionReply extends Reply\n        implements ConnectionReplyInterface {\n    private static MessageUtil msgutil_ = SqlException.getMessageUtil();\n    \n    NetConnectionReply(NetAgent netAgent, int bufferSize) {\n        super(netAgent, bufferSize);\n    }\n\n    // NET only entry point\n    void readExchangeServerAttributes(Connection connection) throws SqlException {\n        startSameIdChainParse();\n        parseEXCSATreply((NetConnection) connection);\n        endOfSameIdChainData();\n        agent_.checkForChainBreakingException_();\n    }\n\n    void verifyConnectReply(int codept) throws SqlException {\n        if (peekCodePoint() != codept) {\n            parseConnectError();\n            return;\n        }\n        readLengthAndCodePoint();\n        skipBytes();\n\n        if (codept == CodePoint.ACCRDBRM) {\n            int peekCP = peekCodePoint();\n            if (peekCP == Reply.END_OF_SAME_ID_CHAIN) {\n                return;\n            }\n\n            parseTypdefsOrMgrlvlovrs();\n            NetSqlca netSqlca = parseSQLCARD(null);\n            netAgent_.netConnection_.completeSqlca(netSqlca);\n        }\n    }\n\n    void parseConnectError() throws DisconnectException {\n        int peekCP = peekCodePoint();\n        switch (peekCP) {\n        case CodePoint.CMDCHKRM:\n            parseCMDCHKRM();\n            break;\n        case CodePoint.MGRLVLRM:\n            parseMGRLVLRM();\n            break;\n        default:\n            parseCommonError(peekCP);\n        }\n    }\n\n    void readDummyExchangeServerAttributes(Connection connection) throws SqlException {\n        startSameIdChainParse();\n        parseDummyEXCSATreply((NetConnection) connection);\n        endOfSameIdChainData();\n        agent_.checkForChainBreakingException_();\n    }\n\n    // NET only entry point\n    void readAccessSecurity(Connection connection,\n                            int securityMechanism) throws SqlException {\n        startSameIdChainParse();\n        parseACCSECreply((NetConnection) connection, securityMechanism);\n        endOfSameIdChainData();\n        agent_.checkForChainBreakingException_();\n    }\n\n    // NET only entry point\n    void readSecurityCheck(Connection connection) throws SqlException {\n        startSameIdChainParse();\n        parseSECCHKreply((NetConnection) connection);\n        endOfSameIdChainData();\n        agent_.checkForChainBreakingException_();\n    }\n\n    // NET only entry point\n    void readAccessDatabase(Connection connection) throws SqlException {\n        startSameIdChainParse();\n        parseACCRDBreply((NetConnection) connection);\n        endOfSameIdChainData();\n        agent_.checkForChainBreakingException_();\n    }\n\n\n    public void readCommitSubstitute(ConnectionCallbackInterface connection) throws DisconnectException {\n        startSameIdChainParse();\n        parseDummyEXCSATreply((NetConnection) connection);\n        endOfSameIdChainData();\n    }\n\n    public void readLocalCommit(ConnectionCallbackInterface connection) throws DisconnectException {\n        startSameIdChainParse();\n        parseRDBCMMreply(connection);\n        endOfSameIdChainData();\n    }\n\n    public void readLocalRollback(ConnectionCallbackInterface connection) throws DisconnectException {\n        startSameIdChainParse();\n        parseRDBRLLBCKreply(connection);\n        endOfSameIdChainData();\n    }\n\n\n    public void readLocalXAStart(ConnectionCallbackInterface connection) throws DisconnectException {\n    }\n\n    public void readLocalXACommit(ConnectionCallbackInterface connection) throws DisconnectException {\n    }\n\n    public void readLocalXARollback(ConnectionCallbackInterface connection) throws DisconnectException {\n    }\n\n\n    protected void readXaStartUnitOfWork(NetConnection conn) throws DisconnectException {\n    }\n\n    protected int readXaEndUnitOfWork(NetConnection conn) throws DisconnectException {\n        return 0;\n    }\n\n    protected int readXaPrepare(NetConnection conn) throws DisconnectException {\n        return 0;\n    }\n\n    protected void readXaCommit(NetConnection conn) throws DisconnectException {\n    }\n\n    protected int readXaRollback(NetConnection conn) throws DisconnectException {\n        return 0;\n    }\n\n    protected void readXaRecover(NetConnection conn) throws DisconnectException {\n    }\n\n    protected void readXaForget(NetConnection conn) throws DisconnectException {\n    }\n\n\n    //------------------parse reply for specific command--------------------------\n    // These methods are \"private protected\", which is not a recognized java privilege,\n    // but means that these methods are private to this class and to subclasses,\n    // and should not be used as package-wide friendly methods.\n\n    // Parse the reply for the RDB Commit Unit of Work Command.\n    // This method handles the parsing of all command replies and reply data\n    // for the rdbcmm command.\n    private void parseRDBCMMreply(ConnectionCallbackInterface connection) throws DisconnectException {\n        int peekCP = parseTypdefsOrMgrlvlovrs();\n\n        parseENDUOWRM(connection);\n        peekCP = parseTypdefsOrMgrlvlovrs();\n\n        if (peekCP == CodePoint.SQLCARD) {\n            NetSqlca netSqlca = parseSQLCARD(null);\n            connection.completeSqlca(netSqlca);\n        } else {\n            parseCommitError(connection);\n        }\n    }\n\n    // Parse the reply for the RDB Rollback Unit of Work Command.\n    // This method handles the parsing of all command replies and reply data\n    // for the rdbrllbck command.\n    private void parseRDBRLLBCKreply(ConnectionCallbackInterface connection) throws DisconnectException {\n        int peekCP = parseTypdefsOrMgrlvlovrs();\n\n        parseENDUOWRM(connection);\n        peekCP = parseTypdefsOrMgrlvlovrs();\n\n        if (peekCP == CodePoint.SQLCARD) {\n            NetSqlca netSqlca = parseSQLCARD(null);\n            connection.completeSqlca(netSqlca);\n        } else {\n            parseRollbackError();\n        }\n    }\n\n    // Parse the reply for the Exchange Server Attributes Command.\n    // This method handles the parsing of all command replies and reply data\n    // for the excsat command.\n    private void parseEXCSATreply(NetConnection netConnection) throws DisconnectException {\n        if (peekCodePoint() != CodePoint.EXCSATRD) {\n            parseExchangeServerAttributesError();\n            return;\n        }\n        parseEXCSATRD(netConnection);\n    }\n\n    // Parse the reply for the Exchange Server Attributes Command (Dummy)\n    // This method handles the parsing of all command replies and reply data\n    // for the excsat command.\n    private void parseDummyEXCSATreply(NetConnection netConnection) throws DisconnectException {\n        if (peekCodePoint() != CodePoint.EXCSATRD) {\n            parseExchangeServerAttributesError();\n            return;\n        }\n        parseDummyEXCSATRD(netConnection);\n    }\n\n    // Parse the reply for the Access Security Command.\n    // This method handles the parsing of all command replies and reply data\n    // for the accsec command.\n    private void parseACCSECreply(NetConnection netConnection, int securityMechanism) throws DisconnectException {\n        int peekCP = peekCodePoint();\n        if (peekCP != CodePoint.ACCSECRD) {\n            parseAccessSecurityError(netConnection);\n            return;\n        }\n        parseACCSECRD(netConnection, securityMechanism);\n        // if we didn't get a SYNTAXRM on parseACCSECRD. Reset the conversion exception\n        // if any.\n        netAgent_.exceptionConvertingRdbnam = null;\n\n        peekCP = peekCodePoint();\n        if (peekCP == Reply.END_OF_SAME_ID_CHAIN) {\n            return;\n        }\n\n    }\n\n    // Parse the reply for the Security Check Command.\n    // This method handles the parsing of all command replies and reply data\n    // for the secchk command.\n    private void parseSECCHKreply(NetConnection netConnection) throws DisconnectException {\n        if (peekCodePoint() != CodePoint.SECCHKRM) {\n            parseSecurityCheckError(netConnection);\n            return;\n        }\n\n        parseSECCHKRM(netConnection);\n        if (peekCodePoint() == CodePoint.SECTKN) {\n            // rpydta used only if the security mechanism returns\n            // a security token that must be sent back to the source system.\n            // this is only used for DCSSEC.  In the case of DCESEC,\n            // the sectkn must be returned as reply data if DCE is using\n            // mutual authentication.\n            // Need to double check what to map this to.  This is probably\n            // incorrect but consider it a conversation protocol error\n            // 0x03 - OBJDSS sent when not allowed.\n            //parseSECTKN (true);\n            boolean done = false;\n            byte[] bytes = parseSECTKN(false);\n        }\n    }\n\n    // Parse the reply for the Access RDB Command.\n    // This method handles the parsing of all command replies and reply data\n    // for the accrdb command.\n    private void parseACCRDBreply(NetConnection netConnection) throws DisconnectException {\n        int peekCP = peekCodePoint();\n        if (peekCP != CodePoint.ACCRDBRM) {\n            parseAccessRdbError(netConnection);\n            return;\n        }\n\n        parseACCRDBRM(netConnection);\n        parseInitialPBSD(netConnection);\n        peekCP = peekCodePoint();\n        if (peekCP == Reply.END_OF_SAME_ID_CHAIN) {\n            return;\n        }\n\n        parseTypdefsOrMgrlvlovrs();\n        NetSqlca netSqlca = parseSQLCARD(null);\n        netConnection.completeSqlca(netSqlca);\n    }\n\n\n    protected int parseTypdefsOrMgrlvlovrs() throws DisconnectException {\n        boolean targetTypedefCloned = false;\n        while (true) {\n            int peekCP = peekCodePoint();\n            if (peekCP == CodePoint.TYPDEFNAM) {\n                if (!targetTypedefCloned) {\n                    netAgent_.targetTypdef_ = (Typdef) netAgent_.targetTypdef_.clone();\n                    targetTypedefCloned = true;\n                }\n                parseTYPDEFNAM();\n            } else if (peekCP == CodePoint.TYPDEFOVR) {\n                if (!targetTypedefCloned) {\n                    netAgent_.targetTypdef_ = (Typdef) netAgent_.targetTypdef_.clone();\n                    targetTypedefCloned = true;\n                }\n                parseTYPDEFOVR();\n            } else {\n                return peekCP;\n            }\n        }\n    }\n\n\n    //-----------------------------parse DDM Reply Messages-----------------------\n\n    protected void parseCommitError(ConnectionCallbackInterface connection) throws DisconnectException {\n        int peekCP = peekCodePoint();\n        switch (peekCP) {\n        case CodePoint.ABNUOWRM:\n            NetSqlca sqlca = parseAbnormalEndUow(connection,null);\n            connection.completeSqlca(sqlca);\n            break;\n        case CodePoint.CMDCHKRM:\n            parseCMDCHKRM();\n            break;\n        case CodePoint.RDBNACRM:\n            parseRDBNACRM();\n            break;\n        default:\n            parseCommonError(peekCP);\n            break;\n        }\n    }\n\n    void parseRollbackError() throws DisconnectException {\n        int peekCP = peekCodePoint();\n        switch (peekCP) {\n        case CodePoint.CMDCHKRM:\n            parseCMDCHKRM();\n            break;\n        case CodePoint.RDBNACRM:\n            parseRDBNACRM();\n            break;\n        default:\n            parseCommonError(peekCP);\n            break;\n        }\n    }\n\n    void parseExchangeServerAttributesError() throws DisconnectException {\n        int peekCP = peekCodePoint();\n        switch (peekCP) {\n        case CodePoint.CMDCHKRM:\n            parseCMDCHKRM();\n            break;\n        case CodePoint.MGRLVLRM:\n            parseMGRLVLRM();\n            break;\n        default:\n            parseCommonError(peekCP);\n        }\n    }\n\n    void parseAccessSecurityError(NetConnection netConnection) throws DisconnectException {\n        int peekCP = peekCodePoint();\n        switch (peekCP) {\n        case CodePoint.CMDCHKRM:\n            parseCMDCHKRM();\n            break;\n        case CodePoint.RDBNFNRM:\n            parseRDBNFNRM(netConnection);\n            break;\n        case CodePoint.RDBAFLRM:\n            parseRdbAccessFailed(netConnection);\n            break;\n        default:\n            parseCommonError(peekCP);\n        }\n    }\n\n    void parseSecurityCheckError(NetConnection netConnection) throws DisconnectException {\n        int peekCP = peekCodePoint();\n        switch (peekCP) {\n        case CodePoint.CMDCHKRM:\n            parseCMDCHKRM();\n            break;\n        case CodePoint.OBJNSPRM:\n            parseOBJNSPRM();\n            break;\n        case CodePoint.RDBNFNRM:\n            parseRDBNFNRM(netConnection);\n            break;\n        case CodePoint.RDBAFLRM:\n            parseRdbAccessFailed(netConnection);\n            break;\n        default:\n            parseCommonError(peekCP);\n        }\n    }\n\n    void parseAccessRdbError(NetConnection netConnection) throws DisconnectException {\n        int peekCP = peekCodePoint();\n        switch (peekCP) {\n        case CodePoint.CMDCHKRM:\n            parseCMDCHKRM();\n            break;\n        case CodePoint.RDBACCRM:\n            parseRDBACCRM();\n            break;\n        case CodePoint.RDBAFLRM:\n            parseRdbAccessFailed(netConnection);\n            break;\n        case CodePoint.RDBATHRM:\n            parseRDBATHRM(netConnection);\n            break;\n        case CodePoint.RDBNFNRM:\n            parseRDBNFNRM(netConnection);\n            break;\n        default:\n            parseCommonError(peekCP);\n        }\n    }\n\n\n    // Called by all the NET*Reply classes.\n    void parseCommonError(int peekCP) throws DisconnectException {\n        switch (peekCP) {\n        case CodePoint.CMDNSPRM:\n            parseCMDNSPRM();\n            break;\n        case CodePoint.PRCCNVRM:\n            parsePRCCNVRM();\n            break;\n        case CodePoint.SYNTAXRM:\n            parseSYNTAXRM();\n            break;\n        case CodePoint.VALNSPRM:\n            parseVALNSPRM();\n            break;\n        default:\n            doObjnsprmSemantics(peekCP);\n        }\n    }\n    \n    /**\n     * Perform necessary actions for parsing of a ABNUOWRM message.\n     *\n     * @param connection an implementation of the ConnectionCallbackInterface\n     *\n     * @return an NetSqlca object obtained from parsing the ABNUOWRM\n     * @throws DisconnectException\n     *\n     */\n    NetSqlca parseAbnormalEndUow(ConnectionCallbackInterface connection,UnitOfWorkListener uwl) throws DisconnectException {\n        parseABNUOWRM();\n        if (peekCodePoint() != CodePoint.SQLCARD) {\n            parseTypdefsOrMgrlvlovrs();\n        }\n\n        NetSqlca netSqlca = parseSQLCARD(null);\n        \n        if(ExceptionUtil.getSeverityFromIdentifier(netSqlca.getSqlState()) > \n            ExceptionSeverity.STATEMENT_SEVERITY || uwl == null)\n            connection.completeAbnormalUnitOfWork();\n        else\n            connection.completeAbnormalUnitOfWork(uwl);\n        \n        return netSqlca;\n    }\n    \n    /**\n     * Perform necessary actions for parsing of a ABNUOWRM message.\n     *\n     * @param s an implementation of the StatementCallbackInterface\n     *\n     * @return an NetSqlca object obtained from parsing the ABNUOWRM\n     * @throws DisconnectException\n     *\n     */\n    NetSqlca parseAbnormalEndUow(StatementCallbackInterface s) throws DisconnectException {\n        return parseAbnormalEndUow(s.getConnectionCallbackInterface(),s);\n    }\n    \n    /**\n     * Perform necessary actions for parsing of a ABNUOWRM message.\n     *\n     * @param r an implementation of the ResultsetCallbackInterface\n     *\n     * @return an NetSqlca object obtained from parsing the ABNUOWRM\n     * @throws DisconnectException\n     *\n     */\n    NetSqlca parseAbnormalEndUow(ResultSetCallbackInterface r) throws DisconnectException {\n        return parseAbnormalEndUow(r.getConnectionCallbackInterface(),r);\n    }\n\n    void parseRdbAccessFailed(NetConnection netConnection) throws DisconnectException {\n        parseRDBAFLRM();\n\n        // an SQLCARD is returned if an RDBALFRM is returned.\n        // this SQLCARD always follows the RDBALFRM.\n        // TYPDEFNAM and TYPDEFOVR are MTLINC\n\n        if (peekCodePoint() == CodePoint.TYPDEFNAM) {\n            parseTYPDEFNAM();\n            parseTYPDEFOVR();\n        } else {\n            parseTYPDEFOVR();\n            parseTYPDEFNAM();\n        }\n\n        NetSqlca netSqlca = parseSQLCARD(null);\n        \n        //Check if the SQLCARD has null SQLException\n        if(netSqlca.getSqlErrmc() == null)\n        \tnetConnection.setConnectionNull(true);\n        else\n        \tnetConnection.completeSqlca(netSqlca);\n    }\n\n\n    // The Security Check (SECCHKRM) Reply Message indicates the acceptability\n    // of the security information.\n    // this method returns the security check code. it is up to the caller to check\n    // the value of this return code and take the appropriate action.\n    //\n    // Returned from Server:\n    // SVRCOD - required  (0 - INFO, 8 - ERROR, 16 -SEVERE)\n    // SECCHKCD - required\n    // SECTKN - optional, ignorable\n    // SVCERRNO - optional\n    private void parseSECCHKRM(NetConnection netConnection) throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean secchkcdReceived = false;\n        int secchkcd = CodePoint.SECCHKCD_00;\n        boolean sectknReceived = false;\n        byte[] sectkn = null;\n\n        parseLengthAndMatchCodePoint(CodePoint.SECCHKRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                // severity code.  it's value is dictated by the SECCHKCD.\n                // right now it will not be checked that it is the correct value\n                // for the SECCHKCD.  maybe this will be done in the future.\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_INFO, CodePoint.SVRCOD_SEVERE);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.SECCHKCD) {\n                // security check code. this specifies the state of the security information.\n                // there is a relationship between this value and the SVRCOD value.\n                // right now this driver will not check these values against each other.\n                foundInPass = true;\n                secchkcdReceived = checkAndGetReceivedFlag(secchkcdReceived);\n                secchkcd = parseSECCHKCD();\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.SECTKN) {\n                // security token.\n                // used when mutual authentication of the source and target servers\n                // is requested.  The architecture lists this as an instance variable\n                // and also says that the SECTKN flows as reply data to the secchk cmd and\n                // it must flow after the secchkrm message.  Right now this driver doesn't\n                // support ay mutual authentication so it will be ignored (it is listed\n                // as an ignorable instance variable in the ddm manual).\n                foundInPass = true;\n                sectknReceived = checkAndGetReceivedFlag(sectknReceived);\n                sectkn = parseSECTKN(true);\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        // check for the required instance variables.\n        checkRequiredObjects(svrcodReceived, secchkcdReceived);\n\n        netConnection.securityCheckComplete(svrcod, secchkcd);\n    }\n\n\n    // Access to RDB Completed (ACRDBRM) Reply Message specifies that an\n    // instance of the SQL application manager has been created and is bound\n    // to the specified relation database (RDB).\n    //\n    // Returned from Server:\n    // SVRCOD - required  (0 - INFO, 4 - WARNING)\n    // PRDID - required\n    // TYPDEFNAM - required (MINLVL 4) (QTDSQLJVM)\n    // TYPDEFOVR - required\n    // RDBINTTKN - optional\n    // CRRTKN - optional\n    // USRID - optional\n    // SRVLST - optional (MINLVL 5)\n    private void parseACCRDBRM(NetConnection netConnection) throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean prdidReceived = false;\n        String prdid = null;\n        boolean typdefnamReceived = false;\n        boolean typdefovrReceived = false;\n        boolean rdbinttknReceived = false;\n        boolean crrtknReceived = false;\n        byte[] crrtkn = null;\n        boolean usridReceived = false;\n        String usrid = null;\n\n        parseLengthAndMatchCodePoint(CodePoint.ACCRDBRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                // severity code.  If the target SQLAM cannot support the typdefovr\n                // parameter values specified for the double-byte and mixed-byte CCSIDs\n                // on the corresponding ACCRDB command, then the severity code WARNING\n                // is specified on the ACCRDBRM.\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_INFO, CodePoint.SVRCOD_WARNING);\n                peekCP = peekCodePoint();\n            }\n\n            // this is the product release level of the target RDB server.\n            if (peekCP == CodePoint.PRDID) {\n                foundInPass = true;\n                prdidReceived = checkAndGetReceivedFlag(prdidReceived);\n                prdid = parsePRDID(false); // false means do not skip the bytes\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.TYPDEFNAM) {\n                // this is the name of the data type to the data representation mapping\n                // definitions tha the target SQLAM uses when sending reply data objects.\n                foundInPass = true;\n                typdefnamReceived = checkAndGetReceivedFlag(typdefnamReceived);\n                parseTYPDEFNAM();\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.TYPDEFOVR) {\n                // this is the single-byte, double-byte, and mixed-byte CCSIDs of the\n                // scalar data arrays (SDA) in the identified data type to data representation\n                // mapping definitions.\n                foundInPass = true;\n                typdefovrReceived = checkAndGetReceivedFlag(typdefovrReceived);\n                parseTYPDEFOVR();\n                peekCP = peekCodePoint();\n            }\n\n\n            if (peekCP == CodePoint.USRID) {\n                // specifies the target defined user ID.  It is returned if the value of\n                // TRGDFTRT is TRUE in ACCRDB.  Right now this driver always sets this\n                // value to false so this should never get returned here.\n                // if it is returned, it could be considered an error but for now\n                // this driver will just skip the bytes.\n                foundInPass = true;\n                usridReceived = checkAndGetReceivedFlag(usridReceived);\n                usrid = parseUSRID(true);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.CRRTKN) {\n                // carries information to correlate with the work being done on bahalf\n                // of an application at the source and at the target server.\n                // defualt value is ''.\n                // this parameter is only retunred if an only if the CRRTKN parameter\n                // is not received on ACCRDB.  We will rely on server to send us this\n                // in ACCRDBRM\n                foundInPass = true;\n                crrtknReceived = checkAndGetReceivedFlag(crrtknReceived);\n                crrtkn = parseCRRTKN(false);\n                peekCP = peekCodePoint();\n            }\n\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n        }\n        popCollectionStack();\n        // check for the required instance variables.\n        checkRequiredObjects(svrcodReceived,\n                prdidReceived,\n                typdefnamReceived,\n                typdefovrReceived);\n\n        netConnection.rdbAccessed(svrcod,\n                prdid,\n                crrtknReceived,\n                crrtkn);\n    }\n\n\n    // The End Unit of Work Condition (ENDUOWRM) Reply Mesage specifies\n    // that the unit of work has ended as a result of the last command.\n    //\n    // Returned from Server:\n    //   SVRCOD - required  (4 WARNING)\n    //   UOWDSP - required\n    //   RDBNAM - optional\n    void parseENDUOWRM(ConnectionCallbackInterface connection) throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean uowdspReceived = false;\n        int uowdsp = 0;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n\n        parseLengthAndMatchCodePoint(CodePoint.ENDUOWRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_WARNING, CodePoint.SVRCOD_WARNING);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.UOWDSP) {\n                foundInPass = true;\n                uowdspReceived = checkAndGetReceivedFlag(uowdspReceived);\n                uowdsp = parseUOWDSP();\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived, uowdspReceived);\n\n        netAgent_.setSvrcod(svrcod);\n        if (uowdsp == CodePoint.UOWDSP_COMMIT) {\n            connection.completeLocalCommit();\n        } else {\n            connection.completeLocalRollback();\n        }\n    }\n\n    // Command Check Reply Message indicates that the requested\n    // command encountered an unarchitected and implementation-specific\n    // condition for which there is no architected message.  If the severity\n    // code value is ERROR or greater, the command has failed.  The\n    // message can be accompanied by other messages that help to identify\n    // the specific condition.\n    // The CMDCHKRM should not be used as a general catch-all in place of\n    // product-defined messages when using product extensions to DDM.\n    // PROTOCOL architects the SQLSTATE value depending on SVRCOD\n    // SVRCOD 0 -> SQLSTATE is not returned\n    // SVRCOD 8 -> SQLSTATE of 58008 or 58009\n    // SVRCOD 16,32,64,128 -> SQLSTATE of 58009\n    //\n    // Messages\n    //   SQLSTATE : 58009\n    //     Execution failed due to a distribution protocol error that caused deallocation of the conversation.\n    //     SQLCODE : -30020\n    //     Execution failed because of a Distributed Protocol\n    //       Error that will affect the successful execution of subsequent\n    //       commands and SQL statements: Reason Code <reason-code>.\n    //     Some possible reason codes include:\n    //       121C Indicates that the user is not authorized to perform the requested command.\n    //       1232 The command could not be completed because of a permanent error.\n    //         In most cases, the server will be in the process of an abend.\n    //       220A The target server has received an invalid data description.\n    //         If a user SQLDA is specified, ensure that the fields are\n    //         initialized correctly. Also, ensure that the length does not\n    //         exceed the maximum allowed length for the data type being used.\n    //\n    // The command or statement cannot be processed.  The current\n    // transaction is rolled back and the application is disconnected\n    //  from the remote database.\n    //\n    //\n    // Returned from Server:\n    //   SVRCOD - required  (0 - INFO, 4 - WARNING, 8 - ERROR, 16 - SEVERE,\n    //                       32 - ACCDMG, 64 - PRMDMG, 128 - SESDMG))\n    //   RDBNAM - optional (MINLVL 3)\n    //   RECCNT - optional (MINVAL 0, MINLVL 3)\n    //\n    // Called by all the Reply classesCMDCHKRM\n    protected void parseCMDCHKRM() throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n        parseLengthAndMatchCodePoint(CodePoint.CMDCHKRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_INFO, CodePoint.SVRCOD_SESDMG);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n            // skip over the RECCNT since it can't be found in the DDM book.\n\n            if (peekCP == 0x115C) {\n                foundInPass = true;\n                parseLengthAndMatchCodePoint(0x115C);\n                skipBytes();\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived);\n\n        netAgent_.setSvrcod(svrcod);\n        NetSqlca netSqlca = parseSQLCARD(null); \n        netAgent_.netConnection_.completeSqlca(netSqlca);\n\n        agent_.accumulateChainBreakingReadExceptionAndThrow(\n            new DisconnectException(\n                agent_,\n                new ClientMessageId(SQLState.DRDA_CONNECTION_TERMINATED),\n                msgutil_.getTextMessage(\n                    MessageId.CONN_DRDA_CMDCHKRM),\n                new SqlException(agent_.logWriter_,\n                                 netSqlca)));\n    }\n\n\n    // RDB Not Accessed Reply Message indicates that the access relational\n    // database command (ACCRDB) was not issued prior to a command\n    // requesting the RDB Services.\n    // PROTOCOL Architects an SQLSTATE of 58008 or 58009.\n    //\n    // Messages\n    // SQLSTATE : 58009\n    //     Execution failed due to a distribution protocol error that caused deallocation of the conversation.\n    //     SQLCODE : -30020\n    //     Execution failed because of a Distributed Protocol\n    //         Error that will affect the successful execution of subsequent\n    //         commands and SQL statements: Reason Code <reason-code>.\n    //      Some possible reason codes include:\n    //      121C Indicates that the user is not authorized to perform the requested command.\n    //      1232 The command could not be completed because of a permanent error.\n    //          In most cases, the server will be in the process of an abend.\n    //      220A The target server has received an invalid data description.\n    //          If a user SQLDA is specified, ensure that the fields are\n    //          initialized correctly. Also, ensure that the length does not\n    //          exceed the maximum allowed length for the data type being used.\n    //\n    //      The command or statement cannot be processed.  The current\n    //      transaction is rolled back and the application is disconnected\n    //      from the remote database.\n    //\n    //\n    // Returned from Server:\n    // SVRCOD - required  (8 - ERROR)\n    // RDBNAM - required\n    //\n    // Called by all the NET*Reply classes.\n    void parseRDBNACRM() throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n\n        parseLengthAndMatchCodePoint(CodePoint.RDBNACRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_ERROR);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived, rdbnamReceived);\n\n        netAgent_.setSvrcod(svrcod);\n        agent_.accumulateChainBreakingReadExceptionAndThrow(\n            new DisconnectException(agent_,\n                new ClientMessageId(SQLState.DRDA_CONNECTION_TERMINATED),\n                msgutil_.getTextMessage(MessageId.CONN_DRDA_RDBNACRM)));            \n    }\n\n    // RDB Not Found Reply Message indicates that the target\n    // server cannot find the specified relational database.\n    // PROTOCOL architects an SQLSTATE of 08004.\n    //\n    // Messages\n    // SQLSTATE : 8004\n    //     The application server rejected establishment of the connection.\n    //     SQLCODE : -30061\n    //     The database alias or database name <name> was not found at the remote node.\n    //     The statement cannot be processed.\n    //\n    //\n    // Returned from Server:\n    // SVRCOD - required  (8 - ERROR)\n    // RDBNAM - required\n    //\n    private void parseRDBNFNRM(NetConnection netConnection) throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n\n        parseLengthAndMatchCodePoint(CodePoint.RDBNFNRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_ERROR);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived, rdbnamReceived);\n\n        netAgent_.setSvrcod(svrcod);\n        agent_.accumulateChainBreakingReadExceptionAndThrow(new DisconnectException(agent_,\n            new ClientMessageId(SQLState.NET_DATABASE_NOT_FOUND),\n            netConnection.databaseName_));\n    }\n\n\n    // Not Authorized to RDB Reply Message specifies that\n    // the requester is not authorized to access the specified\n    // relational database.\n    // PROTOCOL architects an SQLSTATE of 08004\n    //\n    // Messages\n    // SQLSTATE : 8004\n    //     Authorization ID <authorization-ID> attempted to perform the specified\n    //     <operation> without having been granted the proper authorization to do so.\n    //     SQLCODE : -30060\n    //      <authorization-ID> does not have the privilege to perform operation <operation>.\n    //\n    //\n    // Returned from Server:\n    // SVRCOD - required  (8 - ERROR)\n    // RDBNAM - required\n    //\n    private void parseRDBATHRM(NetConnection netConnection) throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n\n        parseLengthAndMatchCodePoint(CodePoint.RDBATHRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_ERROR);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived, rdbnamReceived);\n\n        netAgent_.setSvrcod(svrcod);\n        netAgent_.accumulateReadException(new SqlException(agent_.logWriter_,\n            new ClientMessageId(SQLState.NET_CONNECT_AUTH_FAILED),\n            msgutil_.getTextMessage(MessageId.CONN_USER_NOT_AUTHORIZED_TO_DB)));\n    }\n\n    // Data Stream Syntax Error Reply Message indicates that the data\n    // sent to the target agent does not structurally conform to the requirements\n    // of the DDM architecture.  The target agent terminated paring of the DSS\n    // when the condition SYNERRCD specified was detected.\n    // PROTOCOL architects an SQLSTATE of 58008 or 58009.\n    //\n    // Messages\n    // SQLSTATE : 58009\n    //     Execution failed due to a distribution protocol error that caused deallocation of the conversation.\n    //     SQLCODE : -30020\n    //     Execution failed because of a Distributed Protocol\n    //         Error that will affect the successful execution of subsequent\n    //         commands and SQL statements: Reason Code <reason-code>.\n    //      Some possible reason codes include:\n    //      121C Indicates that the user is not authorized to perform the requested command.\n    //      1232 The command could not be completed because of a permanent error.\n    //          In most cases, the server will be in the process of an abend.\n    //      220A The target server has received an invalid data description.\n    //          If a user SQLDA is specified, ensure that the fields are\n    //          initialized correctly. Also, ensure that the length does not\n    //          exceed the maximum allowed length for the data type being used.\n    //\n    //      The command or statement cannot be processed.  The current\n    //          transaction is rolled back and the application is disconnected\n    //          from the remote database.\n    //\n    //\n    // Returned from Server:\n    // SVRCOD - required  (8 - ERROR)\n    // SYNERRCD - required\n    // RECCNT - optional (MINVAL 0, MINLVL 3) (will not be returned - should be ignored)\n    // CODPNT - optional (MINLVL 3)\n    // RDBNAM - optional (MINLVL 3)\n    //\n    protected void parseSYNTAXRM() throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean synerrcdReceived = false;\n        int synerrcd = 0;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n        boolean codpntReceived = false;\n        int codpnt = 0;\n\n        parseLengthAndMatchCodePoint(CodePoint.SYNTAXRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_ERROR);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.SYNERRCD) {\n                foundInPass = true;\n                synerrcdReceived = checkAndGetReceivedFlag(synerrcdReceived);\n                synerrcd = parseSYNERRCD();\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.CODPNT) {\n                foundInPass = true;\n                codpntReceived = checkAndGetReceivedFlag(codpntReceived);\n                codpnt = parseCODPNT();\n                peekCP = peekCodePoint();\n            }\n\n            // RECCNT will be skipped.\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived, synerrcdReceived);\n\n        netAgent_.setSvrcod(svrcod);\n        doSyntaxrmSemantics(codpnt);\n    }\n\n    // RDB Currently Accessed Reply Message inidcates that the\n    // ACCRDB command cannot be issued because the requester\n    // has access to a relational database.\n    // PROTOCOL architects an SQLSTATE of 58008 or 58009.\n    //\n    // Messages\n    // SQLSTATE : 58009\n    //     Execution failed due to a distribution protocol error that caused deallocation of the conversation.\n    //     SQLCODE : -30020\n    //     Execution failed because of a Distributed Protocol\n    //         Error that will affect the successful execution of subsequent\n    //         commands and SQL statements: Reason Code <reason-code>.\n    //      Some possible reason codes include:\n    //      121C Indicates that the user is not authorized to perform the requested command.\n    //      1232 The command could not be completed because of a permanent error.\n    //          In most cases, the server will be in the process of an abend.\n    //      220A The target server has received an invalid data description.\n    //          If a user SQLDA is specified, ensure that the fields are\n    //          initialized correctly. Also, ensure that the length does not\n    //          exceed the maximum allowed length for the data type being used.\n    //\n    //      The command or statement cannot be processed.  The current\n    //      transaction is rolled back and the application is disconnected\n    //      from the remote database.\n    //\n    //\n    // Returned from Server:\n    // SVRCOD - required  (8 - ERROR)\n    // RDBNAM - required\n    //\n    private void parseRDBACCRM() throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n\n        parseLengthAndMatchCodePoint(CodePoint.RDBACCRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_ERROR);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived, rdbnamReceived);\n\n        netAgent_.setSvrcod(svrcod);\n        agent_.accumulateChainBreakingReadExceptionAndThrow(new DisconnectException(agent_,\n            new ClientMessageId(SQLState.DRDA_CONNECTION_TERMINATED),\n            msgutil_.getTextMessage(MessageId.CONN_DRDA_RDBACCRM)));\n    }\n\n    // RDB Access Failed Reply Message specifies that the relational\n    // database failed the attempted connection.\n    // An SQLCARD object must also be returned, following the\n    // RDBAFLRM, to explain why the RDB failed the connection.\n    // In addition, the target SQLAM instance is destroyed.\n    // The SQLSTATE is returned in the SQLCARD.\n    //\n    // Messages\n    // SQLSTATE : 58009\n    //     Execution failed due to a distribution protocol error that caused deallocation of the conversation.\n    //     SQLCODE : -30020\n    //     Execution failed because of a Distributed Protocol\n    //         Error that will affect the successful execution of subsequent\n    //         commands and SQL statements: Reason Code <reason-code>.\n    //      Some possible reason codes include:\n    //      121C Indicates that the user is not authorized to perform the requested command.\n    //      1232 The command could not be completed because of a permanent error.\n    //          In most cases, the server will be in the process of an abend.\n    //      220A The target server has received an invalid data description.\n    //          If a user SQLDA is specified, ensure that the fields are\n    //          initialized correctly. Also, ensure that the length does not\n    //          exceed the maximum allowed length for the data type being used.\n    //\n    //      The command or statement cannot be processed.  The current\n    //      transaction is rolled back and the application is disconnected\n    //      from the remote database.\n    //\n    //\n    // Returned from Server:\n    // SVRCOD - required  (8 - ERROR)\n    // RDBNAM - required\n    //\n    private void parseRDBAFLRM() throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n\n        parseLengthAndMatchCodePoint(CodePoint.RDBAFLRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_ERROR);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived, rdbnamReceived);\n\n        netAgent_.setSvrcod(svrcod);\n    }\n\n\n    // Parameter Value Not Supported Reply Message indicates\n    // that the parameter value specified is either not recognized\n    // or not supported for the specified parameter.\n    // The VALNSPRM can only be specified in accordance with\n    // the rules specified for DDM subsetting.\n    // The code point of the command parameter in error is\n    // returned as a parameter in this message.\n    // PROTOCOL Architects an SQLSTATE of 58017.\n    //\n    // if codepoint is 0x119C,0x119D, or 0x119E then SQLSTATE 58017, SQLCODE -332\n    // else SQLSTATE 58017, SQLCODE -30073\n    //\n    // Messages\n    // SQLSTATE : 58017\n    //     The DDM parameter value is not supported.\n    //     SQLCODE : -332\n    //     There is no available conversion for the source code page\n    //         <code page> to the target code page <code page>.\n    //         Reason code <reason-code>.\n    //     The reason codes are as follows:\n    //     1 source and target code page combination is not supported\n    //         by the database manager.\n    //     2 source and target code page combination is either not\n    //         supported by the database manager or by the operating\n    //         system character conversion utility on the client node.\n    //     3 source and target code page combination is either not\n    //         supported by the database manager or by the operating\n    //         system character conversion utility on the server node.\n    //\n    // SQLSTATE : 58017\n    //     The DDM parameter value is not supported.\n    //     SQLCODE : -30073\n    //     <parameter-identifier> Parameter value <value> is not supported.\n    //     Some possible parameter identifiers include:\n    //     002F  The target server does not support the data type\n    //         requested by the application requester.\n    //         The target server does not support the CCSID\n    //         requested by the application requester. Ensure the CCSID\n    //         used by the requester is supported by the server.\n    //         119C - Verify the single-byte CCSID.\n    //         119D - Verify the double-byte CCSID.\n    //         119E - Verify the mixed-byte CCSID.\n    //\n    //     The current environment command or SQL statement\n    //         cannot be processed successfully, nor can any subsequent\n    //         commands or SQL statements.  The current transaction is\n    //         rolled back and the application is disconnected\n    //         from the remote database. The command cannot be processed.\n    //\n    // Returned from Server:\n    // SVRCOD - required  (8 - ERROR)\n    // CODPNT - required\n    // RECCNT - optional (MINLVL 3, MINVAL 0) (will not be returned - should be ignored)\n    // RDBNAM - optional (MINLVL 3)\n    //\n    protected void parseVALNSPRM() throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n        boolean codpntReceived = false;\n        int codpnt = 0;\n\n        parseLengthAndMatchCodePoint(CodePoint.VALNSPRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_ERROR);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.CODPNT) {\n                foundInPass = true;\n                codpntReceived = checkAndGetReceivedFlag(codpntReceived);\n                codpnt = parseCODPNT();\n                peekCP = peekCodePoint();\n            }\n\n            // RECCNT will be skipped\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived, codpntReceived);\n\n        netAgent_.setSvrcod(svrcod);\n        doValnsprmSemantics(codpnt, \"\\\"\\\"\");\n    }\n\n\n    // Conversational Protocol Error Reply Message\n    // indicates that a conversational protocol error occurred.\n    // PROTOCOL architects the SQLSTATE value depending on SVRCOD\n    // SVRCOD 8 -> SQLSTATE of 58008 or 58009\n    // SVRCOD 16,128 -> SQLSTATE of 58009\n    //\n    // Messages\n    // SQLSTATE : 58009\n    //     Execution failed due to a distribution protocol error that caused deallocation of the conversation.\n    //     SQLCODE : -30020\n    //     Execution failed because of a Distributed Protocol\n    //         Error that will affect the successful execution of subsequent\n    //         commands and SQL statements: Reason Code <reason-code>.\n    //      Some possible reason codes include:\n    //      121C Indicates that the user is not authorized to perform the requested command.\n    //      1232 The command could not be completed because of a permanent error.\n    //          In most cases, the server will be in the process of an abend.\n    //      220A The target server has received an invalid data description.\n    //          If a user SQLDA is specified, ensure that the fields are\n    //          initialized correctly. Also, ensure that the length does not\n    //          exceed the maximum allowed length for the data type being used.\n    //\n    //      The command or statement cannot be processed.  The current\n    //      transaction is rolled back and the application is disconnected\n    //      from the remote database.\n    //\n    //\n    // Returned from Server:\n    // SVRCOD - required  (8 - ERROR, 16 - SEVERE, 128 - SESDMG)\n    // PRCCNVCD - required\n    // RECCNT - optional (MINVAL 0, MINLVL 3)\n    // RDBNAM - optional (NINLVL 3)\n    //\n    protected void parsePRCCNVRM() throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n        boolean prccnvcdReceived = false;\n        int prccnvcd = 0;\n\n        parseLengthAndMatchCodePoint(CodePoint.PRCCNVRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_SESDMG);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.PRCCNVCD) {\n                foundInPass = true;\n                prccnvcdReceived = checkAndGetReceivedFlag(prccnvcdReceived);\n                prccnvcd = parsePRCCNVCD();\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived, prccnvcdReceived);\n\n        netAgent_.setSvrcod(svrcod);\n        doPrccnvrmSemantics(CodePoint.PRCCNVRM);\n    }\n\n    // Object Not Supported Reply Message indicates that the target\n    // server does not recognize or support the object\n    // specified as data in an OBJDSS for the command associated\n    // with the object.\n    // The OBJNSPRM is also returned if an object is found in a\n    // valid collection in an OBJDSS (such as RECAL collection)\n    // that that is not valid for that collection.\n    // PROTOCOL Architects an SQLSTATE of 58015.\n    //\n    // Messages\n    // SQLSTATE : 58015\n    //     The DDM object is not supported.\n    //     SQLCODE : -30071\n    //      <object-identifier> Object is not supported.\n    //     The current transaction is rolled back and the application\n    //     is disconnected from the remote database. The command\n    //     cannot be processed.\n    //\n    //\n    // Returned from Server:\n    // SVRCOD - required  (8 - ERROR, 16 - SEVERE)\n    // CODPNT - required\n    // RECCNT - optional (MINVAL 0)  (will not be returned - should be ignored)\n    // RDBNAM - optional (MINLVL 3)\n    //\n    // Also called by NetPackageReply and NetStatementReply\n    void parseOBJNSPRM() throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n        boolean codpntReceived = false;\n        int codpnt = 0;\n\n        parseLengthAndMatchCodePoint(CodePoint.OBJNSPRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_SEVERE);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.CODPNT) {\n                foundInPass = true;\n                codpntReceived = checkAndGetReceivedFlag(codpntReceived);\n                codpnt = parseCODPNT();\n                peekCP = peekCodePoint();\n            }\n\n            // skip the RECCNT\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived, codpntReceived);\n\n        netAgent_.setSvrcod(svrcod);\n        doObjnsprmSemantics(codpnt);\n    }\n\n\n    // Manager-Level Conflict (MGRLVLRM) Reply Message indicates that\n    // the manager levels specified in the MGRLVLLS conflict amoung\n    // themselves or with previously specified manager levels.\n    // - The manager-level dependencies of one specified manager violates another\n    //   specified maanger level.\n    // - The manager- level specified attempts to respecify a manager level that\n    //   previously EXCSAT command specified.\n    // PROTOCOL architects an SQLSTATE of 58010.\n    //\n    // Messages\n    // SQLSTATE : 58010\n    //     Execution failed due to a distributed protocol error that will affect\n    //     the successful execution of subsequent DDM commands or SQL statements.\n    //     SQLCODE : -30021\n    //     Execution failed due to a distribution protocol error\n    //     that will affect the successful execution of subsequent\n    //     commands and SQL statements: Manager <manager> at Level <level>\n    //     not supported.\n    //\n    //     A system error occurred that prevented successful connection\n    //     of the application to the remote database.\n    //\n    //\n    // Returned from Server:\n    // SVRCOD - required  (8 - ERROR)\n    // MGRLVLLS - required\n    //\n    private void parseMGRLVLRM() throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean mgrlvllsReceived = false;\n        int[] managerCodePoint = null;\n        int[] managerLevel = null;\n\n        parseLengthAndMatchCodePoint(CodePoint.MGRLVLRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_ERROR);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.MGRLVLLS) {\n                foundInPass = true;\n                mgrlvllsReceived = checkAndGetReceivedFlag(mgrlvllsReceived);\n\n                parseLengthAndMatchCodePoint(CodePoint.MGRLVLLS);\n                int managerListLength = getDdmLength();\n                if ((managerListLength == 0) || ((managerListLength % 7) != 0)) {\n                    doSyntaxrmSemantics(CodePoint.SYNERRCD_OBJ_LEN_NOT_ALLOWED);\n                }\n\n                int managerCount = managerListLength / 7;\n                managerCodePoint = new int[managerCount];\n                managerLevel = new int[managerCount];\n                for (int i = 0; i < managerCount; i++) {\n                    managerCodePoint[i] = parseCODPNTDR();\n                    managerLevel[i] = parseMGRLVLN();\n                }\n                peekCP = peekCodePoint();\n            }\n\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived, mgrlvllsReceived);\n\n        netAgent_.setSvrcod(svrcod);\n        doMgrlvlrmSemantics(managerCodePoint, managerLevel);\n    }\n\n\n    // Command Not Supported Reply Message indicates that the specified\n    // command is not recognized or not supported for the\n    // specified target.  The reply message can be returned\n    // only in accordance with the architected rules for DDM subsetting.\n    // PROTOCOL architects an SQLSTATE of 58014.\n    //\n    // Messages\n    // SQLSTATE : 58014\n    //     The DDM command is not supported.\n    //     SQLCODE : -30070\n    //      <command-identifier> Command is not supported.\n    //     The current transaction is rolled back and the application is\n    //     disconnected from the remote database. The statement cannot be processed.\n    //\n    //\n    // Returned from Server:\n    // SVRCOD - required  (4 - WARNING, 8 - ERROR) (MINLVL 2)\n    // CODPNT - required\n    // RDBNAM - optional (MINLVL 3)\n    //\n    protected void parseCMDNSPRM() throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n        boolean srvdgnReceived = false;\n        byte[] srvdgn = null;\n        boolean codpntReceived = false;\n        int codpnt = 0;\n\n        parseLengthAndMatchCodePoint(CodePoint.CMDNSPRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_WARNING, CodePoint.SVRCOD_ERROR);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n\n\n            if (peekCP == CodePoint.CODPNT) {\n                foundInPass = true;\n                codpntReceived = checkAndGetReceivedFlag(codpntReceived);\n                codpnt = parseCODPNT();\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived, codpntReceived);\n\n        netAgent_.setSvrcod(svrcod);\n        agent_.accumulateChainBreakingReadExceptionAndThrow(new DisconnectException(agent_,\n            new ClientMessageId(SQLState.DRDA_DDM_COMMAND_NOT_SUPPORTED),\n                Integer.toHexString(codpnt)));\n    }\n\n    // Abnormal End Unit of Work Condition Reply Message indicates\n    // that the current unit of work ended abnormally because\n    // of some action at the target server.  This can be caused by a\n    // deadlock resolution, operator intervention, or some similar\n    // situation that caused the relational database to rollback\n    // the current unit of work.  This reply message is returned only\n    // if an SQLAM issues the command.  Whenever an ABNUOWRM is returned\n    // in response to a command, an SQLCARD object must also be returned\n    // following the ABNUOWRM.  The SQLSTATE is returned in the SQLCARD.\n    //\n    // Returned from Server:\n    //   SVRCOD - required (8 - ERROR)\n    //   RDBNAM - required\n    //\n    // Called by all the NET*Reply classes.\n    void parseABNUOWRM() throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n\n        parseLengthAndMatchCodePoint(CodePoint.ABNUOWRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_ERROR);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                // skip the rbbnam since it doesn't tell us anything new.\n                // there is no way to return it to the application anyway.\n                // not having to convert this to a string is a time saver also.\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n        }\n\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived, rdbnamReceived);\n\n        // the abnuowrm has been received, do whatever state changes are necessary\n        netAgent_.setSvrcod(svrcod);\n    }\n\n    //--------------------- parse DDM Reply Data--------------------------------------\n\n    // The Server Attributes Reply Data (EXCSATRD) returns the following\n    // information in response to an EXCSAT command:\n    // - the target server's class name\n    // - the target server's support level for each class of manager\n    //   the source requests\n    // - the target server's product release level\n    // - the target server's external name\n    // - the target server's name\n    //\n    // Returned from Server:\n    // EXTNAM - optional\n    // MGRLVLLS - optional\n    // SRVCLSNM - optional\n    // SRVNAM - optional\n    // SRVRLSLV - optional\n    private void parseEXCSATRD(NetConnection netConnection) throws DisconnectException {\n        boolean extnamReceived = false;\n        String extnam = null;\n        boolean mgrlvllsReceived = false;\n        boolean srvclsnmReceived = false;\n        String srvclsnm = null;\n        boolean srvnamReceived = false;\n        String srvnam = null;\n        boolean srvrlslvReceived = false;\n        String srvrlslv = null;\n\n        parseLengthAndMatchCodePoint(CodePoint.EXCSATRD);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.EXTNAM) {\n                // External Name is the name of the job, task, or process\n                // on a system for which a DDM server is active.  For a target\n                // DDM server, the external name is the name of the job the system creates\n                // or activates to run the DDM server.\n                // No semantic meaning is assigned to external names in DDM.\n                // External names are transmitted to aid in problem determination.\n                // This driver will save the external name of the target (the\n                // driver may use it for logging purposes later).\n                foundInPass = true;\n                extnamReceived = checkAndGetReceivedFlag(extnamReceived);\n                extnam = parseEXTNAM();\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.MGRLVLLS) {\n                // Manager-Level List\n                // specifies a list of code points and support levels for the\n                // classes of managers a server supports\n                foundInPass = true;\n                mgrlvllsReceived = checkAndGetReceivedFlag(mgrlvllsReceived);\n                parseMGRLVLLS(netConnection);  // need to review this one, check input and output\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.SRVCLSNM) {\n                // Server Class Name\n                // specifies the name of a class of ddm servers.\n                foundInPass = true;\n                srvclsnmReceived = checkAndGetReceivedFlag(srvclsnmReceived);\n                srvclsnm = parseSRVCLSNM();\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.SRVNAM) {\n                // Server Name\n                // no semantic meaning is assigned to server names in DDM,\n                // it is recommended (by the DDM manual) that the server's\n                // physical or logical location identifier be used as a server name.\n                // server names are transmitted for problem determination purposes.\n                // this driver will save this name and in the future may use it\n                // for logging errors.\n                foundInPass = true;\n                srvnamReceived = checkAndGetReceivedFlag(srvnamReceived);\n                srvnam = parseSRVNAM();\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.SRVRLSLV) {\n                // Server Product Release Level\n                // specifies the procuct release level of a ddm server.\n                // the contents are unarchitected.\n                // this driver will save this information and in the future may\n                // use it for logging purposes.\n                foundInPass = true;\n                srvrlslvReceived = checkAndGetReceivedFlag(srvrlslvReceived);\n                srvrlslv = parseSRVRLSLV();\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        // according the the DDM book, all these instance variables are optional\n        netConnection.setServerAttributeData(extnam, srvclsnm, srvnam, srvrlslv);\n    }\n\n    // Must make a version that does not change state in the associated connection\n    private void parseDummyEXCSATRD(NetConnection netConnection) throws DisconnectException {\n        boolean extnamReceived = false;\n        String extnam = null;\n        boolean mgrlvllsReceived = false;\n        boolean srvclsnmReceived = false;\n        String srvclsnm = null;\n        boolean srvnamReceived = false;\n        String srvnam = null;\n        boolean srvrlslvReceived = false;\n        String srvrlslv = null;\n\n        parseLengthAndMatchCodePoint(CodePoint.EXCSATRD);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.EXTNAM) {\n                // External Name is the name of the job, task, or process\n                // on a system for which a DDM server is active.  For a target\n                // DDM server, the external name is the name of the job the system creates\n                // or activates to run the DDM server.\n                // No semantic meaning is assigned to external names in DDM.\n                // External names are transmitted to aid in problem determination.\n                // This driver will save the external name of the target (the\n                // driver may use it for logging purposes later).\n                foundInPass = true;\n                extnamReceived = checkAndGetReceivedFlag(extnamReceived);\n                extnam = parseEXTNAM();\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.MGRLVLLS) {\n                // Manager-Level List\n                // specifies a list of code points and support levels for the\n                // classes of managers a server supports\n                foundInPass = true;\n                mgrlvllsReceived = checkAndGetReceivedFlag(mgrlvllsReceived);\n                parseMGRLVLLS(netConnection);  // need to review this one, check input and output\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.SRVCLSNM) {\n                // Server Class Name\n                // specifies the name of a class of ddm servers.\n                foundInPass = true;\n                srvclsnmReceived = checkAndGetReceivedFlag(srvclsnmReceived);\n                srvclsnm = parseSRVCLSNM();\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.SRVNAM) {\n                // Server Name\n                // no semantic meaning is assigned to server names in DDM,\n                // it is recommended (by the DDM manual) that the server's\n                // physical or logical location identifier be used as a server name.\n                // server names are transmitted for problem determination purposes.\n                // this driver will save this name and in the future may use it\n                // for logging errors.\n                foundInPass = true;\n                srvnamReceived = checkAndGetReceivedFlag(srvnamReceived);\n                srvnam = parseSRVNAM();\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.SRVRLSLV) {\n                // Server Product Release Level\n                // specifies the procuct release level of a ddm server.\n                // the contents are unarchitected.\n                // this driver will save this information and in the future may\n                // use it for logging purposes.\n                foundInPass = true;\n                srvrlslvReceived = checkAndGetReceivedFlag(srvrlslvReceived);\n                srvrlslv = parseSRVRLSLV();\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        // according the the DDM book, all these instance variables are optional\n        // don't change state of netConnection because this is a DUMMY flow\n        //netConnection.setServerAttributeData (extnam, srvclsnm, srvnam, srvrlslv);\n    }\n\n    // The Access Security Reply Data (ACSECRD) Collection Object contains\n    // the security information from a target server's security manager.\n    // this method returns the security check code received from the server\n    // (if the server does not return a security check code, this method\n    // will return 0).  it is up to the caller to check\n    // the value of this return code and take the appropriate action.\n    //\n    // Returned from Server:\n    // SECMEC - required\n    // SECTKN - optional (MINLVL 6)\n    // SECCHKCD - optional\n    private void parseACCSECRD(NetConnection netConnection, int securityMechanism) throws DisconnectException {\n        boolean secmecReceived = false;\n        int[] secmecList = null;\n        boolean sectknReceived = false;\n        byte[] sectkn = null;\n        boolean secchkcdReceived = false;\n        int secchkcd = 0;\n\n        parseLengthAndMatchCodePoint(CodePoint.ACCSECRD);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SECMEC) {\n                // security mechanism.\n                // this value must either reflect the value sent in the ACCSEC command\n                // if the target server supports it; or the values the target server\n                // does support when it does not support or accept the value\n                // requested by the source server.\n                // the secmecs returned are treated as a list and stored in\n                // targetSecmec_List.\n                // if the target server supports the source's secmec, it\n                // will be saved in the variable targetSecmec_ (NOTE: so\n                // after calling this method, if targetSecmec_'s value is zero,\n                // then the target did NOT support the source secmec.  any alternate\n                // secmecs would be contained in targetSecmec_List).\n                foundInPass = true;\n                secmecReceived = checkAndGetReceivedFlag(secmecReceived);\n                secmecList = parseSECMEC();\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.SECTKN) {\n                // security token\n                foundInPass = true;\n                sectknReceived = checkAndGetReceivedFlag(sectknReceived);\n                sectkn = parseSECTKN(false);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.SECCHKCD) {\n                // security check code.\n                // included if and only if an error is detected when processing\n                // the ACCSEC command.  this has an implied severity code\n                // of ERROR.\n                foundInPass = true;\n                secchkcdReceived = checkAndGetReceivedFlag(secchkcdReceived);\n                secchkcd = parseSECCHKCD();\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n        }\n        popCollectionStack();\n        checkRequiredObjects(secmecReceived);\n\n        netConnection.setAccessSecurityData(secchkcd,\n                securityMechanism,\n                secmecList,\n                sectknReceived,\n                sectkn);\n        \n        /* Switch to UTF-8 or EBCDIC managers depending on what's supported */\n        if (netConnection.serverSupportsUtf8Ccsid()) {\n            netConnection.netAgent_.switchToUtf8CcsidMgr();\n        } else {\n            netConnection.netAgent_.switchToEbcdicMgr();\n        }\n    }\n\n    // Called by all the NET*Reply classes.\n    void parseTYPDEFNAM() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.TYPDEFNAM);\n        netAgent_.targetTypdef_.setTypdefnam(readString());\n    }\n\n    // Called by all the NET*Reply classes.\n    void parseTYPDEFOVR() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.TYPDEFOVR);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.CCSIDSBC) {\n                foundInPass = true;\n                netAgent_.targetTypdef_.setCcsidSbc(parseCCSIDSBC());\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.CCSIDDBC) {\n                foundInPass = true;\n                netAgent_.targetTypdef_.setCcsidDbc(parseCCSIDDBC());\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.CCSIDMBC) {\n                foundInPass = true;\n                netAgent_.targetTypdef_.setCcsidMbc(parseCCSIDMBC());\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n    }\n\n\n    // The SYNCCRD Reply Mesage\n    //\n    // Returned from Server:\n    //   XARETVAL - required\n    int parseSYNCCRD(ConnectionCallbackInterface connection) throws DisconnectException {\n        return 0;\n    }\n\n    // Process XA return value\n    protected int parseXARETVAL() throws DisconnectException {\n        return 0;\n    }\n\n    // Process XA return value\n    protected byte parseSYNCTYPE() throws DisconnectException {\n        return 0;\n    }\n\n    // This method handles the parsing of all command replies and reply data\n    // for the SYNCCTL command.\n    protected int parseSYNCCTLreply(ConnectionCallbackInterface connection) \n        throws DisconnectException {\n        if (peekCodePoint() == CodePoint.PBSD) {\n            parsePBSD();\n        }\n        return 0;\n    }\n\n    // Called by the XA commit and rollback parse reply methods.\n    void parseSYNCCTLError(int peekCP) throws DisconnectException {\n        switch (peekCP) {\n        case CodePoint.CMDCHKRM:\n            parseCMDCHKRM();\n            break;\n        case CodePoint.PRCCNVRM:\n            parsePRCCNVRM();\n            break;\n        case CodePoint.SYNTAXRM:\n            parseSYNTAXRM();\n            break;\n        case CodePoint.VALNSPRM:\n            parseVALNSPRM();\n            break;\n        default:\n            doObjnsprmSemantics(peekCP);\n        }\n    }\n\n\n    // Manager-Level List.\n    // Specifies a list of code points and support levels for the\n    // classes of managers a server supports.\n    // The target server must not provide information for any target\n    // managers unless the source explicitly requests it.\n    // For each manager class, if the target server's support level\n    // is greater than or equal to the source server's level, then the source\n    // server's level is returned for that class if the target server can operate\n    // at the source's level; otherwise a level 0 is returned.  If the target\n    // server's support level is less than the source server's level, the\n    // target server's level is returned for that class.  If the target server\n    // does not recognize the code point of a manager class or does not support\n    // that class, it returns a level of 0.  The target server then waits\n    // for the next command or for the source server to terminate communications.\n    // When the source server receives EXCSATRD, it must compare each of the entries\n    // in the mgrlvlls parameter it received to the corresponding entries in the mgrlvlls\n    // parameter it sent.  If any level mismatches, the source server must decide\n    // whether it can use or adjust to the lower level of target support for that manager\n    // class.  There are no architectural criteria for making this decision.\n    // The source server can terminate communications or continue at the target\n    // servers level of support.  It can also attempt to use whatever\n    // commands its user requests while receiving eror reply messages for real\n    // functional mismatches.\n    // The manager levels the source server specifies or the target server\n    // returns must be compatible with the manager-level dependencies of the specified\n    // manangers.  Incompatible manager levels cannot be specified.\n    // After this method successfully returns, the targetXXXX values (where XXXX\n    // represents a manager name.  example targetAgent) contain the negotiated\n    // manager levels for this particular connection.\n    private void parseMGRLVLLS(NetConnection netConnection) throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.MGRLVLLS);\n\n        // each manager class and level is 4 bytes long.\n        // get the length of the mgrlvls bytes, make sure it contains\n        // the correct number of bytes for a mgrlvlls object, and calculate\n        // the number of manager's returned from the server.\n        int managerListLength = getDdmLength();\n        if ((managerListLength == 0) || ((managerListLength % 4) != 0)) {\n            doSyntaxrmSemantics(CodePoint.SYNERRCD_OBJ_LEN_NOT_ALLOWED);\n        }\n        int managerCount = managerListLength / 4;\n\n        // the managerCount should be equal to the same number of\n        // managers sent on the excsat.\n\n        // read each of the manager levels returned from the server.\n        for (int i = 0; i < managerCount; i++) {\n\n            // first two byte are the manager's codepoint, next two bytes are the level.\n            int managerCodePoint = parseCODPNTDR();\n            int managerLevel = parseMGRLVLN();\n\n            // check each manager to make sure levels are within proper limits\n            // for this driver.  Also make sure unexpected managers are not returned.\n            switch (managerCodePoint) {\n\n            case CodePoint.AGENT:\n                if ((managerLevel < NetConfiguration.MIN_AGENT_MGRLVL) ||\n                        (managerLevel > netConnection.targetAgent_)) {\n                    doMgrlvlrmSemantics(managerCodePoint, managerLevel);\n                }\n                netConnection.targetAgent_ = managerLevel;\n                break;\n\n            case CodePoint.CMNTCPIP:\n                if ((managerLevel < NetConfiguration.MIN_CMNTCPIP_MGRLVL) ||\n                        (managerLevel > netConnection.targetCmntcpip_)) {\n                    doMgrlvlrmSemantics(managerCodePoint, managerLevel);\n                }\n                netConnection.targetCmntcpip_ = managerLevel;\n                break;\n\n            case CodePoint.RDB:\n                if ((managerLevel < NetConfiguration.MIN_RDB_MGRLVL) ||\n                        (managerLevel > netConnection.targetRdb_)) {\n                    doMgrlvlrmSemantics(managerCodePoint, managerLevel);\n                }\n                netConnection.targetRdb_ = managerLevel;\n                break;\n\n            case CodePoint.SECMGR:\n                if ((managerLevel < NetConfiguration.MIN_SECMGR_MGRLVL) ||\n                        (managerLevel > netConnection.targetSecmgr_)) {\n                    doMgrlvlrmSemantics(managerCodePoint, managerLevel);\n                }\n                netConnection.targetSecmgr_ = managerLevel;\n                break;\n\n            case CodePoint.SQLAM:\n                if ((managerLevel < NetConfiguration.MIN_SQLAM_MGRLVL) ||\n                        (managerLevel > netAgent_.targetSqlam_)) {\n                    doMgrlvlrmSemantics(managerCodePoint, managerLevel);\n                }\n                netAgent_.orignalTargetSqlam_ = managerLevel;\n                break;\n\n            case CodePoint.CMNAPPC:\n                if ((managerLevel < NetConfiguration.MIN_CMNAPPC_MGRLVL) ||\n                        (managerLevel > netConnection.targetCmnappc_)) {\n                    doMgrlvlrmSemantics(managerCodePoint, managerLevel);\n                }\n                netConnection.targetCmnappc_ = managerLevel;\n                break;\n\n            case CodePoint.XAMGR:\n                if ((managerLevel != 0) &&\n                        (managerLevel < NetConfiguration.MIN_XAMGR_MGRLVL) ||\n                        (managerLevel > netConnection.targetXamgr_)) {\n                    doMgrlvlrmSemantics(managerCodePoint, managerLevel);\n                }\n                netConnection.targetXamgr_ = managerLevel;\n                break;\n\n            case CodePoint.SYNCPTMGR:\n                if ((managerLevel != 0) &&\n                        (managerLevel < NetConfiguration.MIN_SYNCPTMGR_MGRLVL) ||\n                        (managerLevel > netConnection.targetSyncptmgr_)) {\n                    doMgrlvlrmSemantics(managerCodePoint, managerLevel);\n                }\n                netConnection.targetSyncptmgr_ = managerLevel;\n                break;\n            case CodePoint.UNICODEMGR:\n                if ((managerLevel < NetConfiguration.MIN_UNICODE_MGRLVL) ||\n                        (managerLevel > netConnection.targetUnicodemgr_)) {\n                    doMgrlvlrmSemantics(managerCodePoint, managerLevel);\n                }\n                netConnection.targetUnicodemgr_ = managerLevel;\n                break;\n            case CodePoint.RSYNCMGR:\n                if ((managerLevel != 0) &&\n                        (managerLevel < NetConfiguration.MIN_RSYNCMGR_MGRLVL) ||\n                        (managerLevel > netConnection.targetRsyncmgr_)) {\n                    doMgrlvlrmSemantics(managerCodePoint, managerLevel);\n                }\n                netConnection.targetRsyncmgr_ = managerLevel;\n                break;\n                // The target server must not provide information for any target managers\n                // unless the source explicitly requests.  The following managers are never requested.\n            default:\n                doMgrlvlrmSemantics(managerCodePoint, managerLevel);\n                break;\n            }\n        }\n    }\n\n    // The External Name is the name of the job, task, or process on a\n    // system for which a DDM server is active.  On a source DDM server,\n    // the external name is the name of the job that is requesting\n    // access to remote resources.  For a target DDM server,\n    // the external name is the name of the job the system\n    // creates or activates to run the DDM server.\n    // No semantic meaning is assigned to external names in DDM.\n    // External names are transmitted to aid in problem determination.\n    protected String parseEXTNAM() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.EXTNAM);\n        return readString();\n    }\n\n    // Server Class name specifies the name of a class of DDM servers.\n    // Server class names are assigned for each product involved in PROTOCOL.\n    protected String parseSRVCLSNM() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.SRVCLSNM);\n        return readString();\n    }\n\n    // Server Name is the name of the DDM server.\n    // No semantic meaning is assigned to server names in DDM,\n    // but it is recommended that the server names are transmitted\n    // for problem determination.\n    protected String parseSRVNAM() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.SRVNAM);\n        return readString();\n    }\n\n    // Server Product Release Level String specifies the product\n    // release level of a DDM server.  The contents of the\n    // parameter are unarchitected.  Up to 255 bytes can be sent.\n    // SRVRLSLV should not be used in place of product-defined\n    // extensions to carry information not related to the products\n    // release level.\n    protected String parseSRVRLSLV() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.SRVRLSLV);\n        return readString();\n    }\n\n    // Manager-Level Number Attribute Binary Integer Number specifies\n    // the level of a defined DDM manager.\n    protected int parseMGRLVLN() throws DisconnectException {\n        return readUnsignedShort();\n    }\n\n    // Security Mechanims.\n    protected int[] parseSECMEC() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.SECMEC);\n        return readUnsignedShortList();\n    }\n\n    // The Security Token Byte String is information provided and used\n    // by the various security mechanisms.\n    protected byte[] parseSECTKN(boolean skip) throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.SECTKN);\n        if (skip) {\n            skipBytes();\n            return null;\n        }\n        return readBytes();\n    }\n\n\n    // The Security Check Code String codifies the security information\n    // and condition for the SECCHKRM.\n    protected int parseSECCHKCD() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.SECCHKCD);\n        int secchkcd = readUnsignedByte();\n        if ((secchkcd < CodePoint.SECCHKCD_00) || (secchkcd > CodePoint.SECCHKCD_15)) {\n            doValnsprmSemantics(CodePoint.SECCHKCD, secchkcd);\n        }\n        return secchkcd;\n    }\n\n    // Product specific Identifier specifies the product release level\n    // of a DDM server.\n    protected String parsePRDID(boolean skip) throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.PRDID);\n        if (skip) {\n            skipBytes();\n            return null;\n        } else {\n            return readString();\n        }\n    }\n\n    // The User Id specifies an end-user name.\n    protected String parseUSRID(boolean skip) throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.USRID);\n        if (skip) {\n            skipBytes();\n            return null;\n        }\n        return readString();\n    };\n\n    // Code Point Data Representation specifies the data representation\n    // of a dictionary codepoint.  Code points are hexadecimal aliases for DDM\n    // named terms.\n    protected int parseCODPNTDR() throws DisconnectException {\n        return readUnsignedShort();\n    }\n\n    // Correlation Token specifies a token that is conveyed between source\n    // and target servers for correlating the processing between servers.\n    protected byte[] parseCRRTKN(boolean skip) throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.CRRTKN);\n        if (skip) {\n            skipBytes();\n            return null;\n        }\n        return readBytes();\n    }\n\n    // Unit of Work Disposition Scalar Object specifies the disposition of the\n    // last unit of work.\n    protected int parseUOWDSP() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.UOWDSP);\n        int uowdsp = readUnsignedByte();\n        if ((uowdsp != CodePoint.UOWDSP_COMMIT) && (uowdsp != CodePoint.UOWDSP_ROLLBACK)) {\n            doValnsprmSemantics(CodePoint.UOWDSP, uowdsp);\n        }\n        return uowdsp;\n    }\n\n\n    // Relational Database Name specifies the name of a relational\n    // database of the server.  A server can have more than one RDB.\n    protected String parseRDBNAM(boolean skip) throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.RDBNAM);\n        if (skip) {\n            skipBytes();\n            return null;\n        }\n        return readString();\n    };\n\n\n\n    protected int parseXIDCNT() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.XIDCNT);\n        return readUnsignedShort();\n    }\n\n    protected Xid parseXID() throws DisconnectException {\n        return null;\n    }\n\n    protected java.util.Hashtable parseIndoubtList() throws DisconnectException {\n        return null;\n    }\n\n\n    // Syntax Error Code String specifies the condition that caused termination\n    // of data stream parsing.\n    protected int parseSYNERRCD() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.SYNERRCD);\n        int synerrcd = readUnsignedByte();\n        if ((synerrcd < 0x01) || (synerrcd > 0x1D)) {\n            doValnsprmSemantics(CodePoint.SYNERRCD, synerrcd);\n        }\n        return synerrcd;\n    }\n\n    // The Code Point Data specifies a scalar value that is an architected code point.\n    protected int parseCODPNT() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.CODPNT);\n        return parseCODPNTDR();\n    }\n\n    // Conversational Protocol Error Code specifies the condition\n    // for which the PRCCNVRm was returned.\n    protected int parsePRCCNVCD() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.PRCCNVCD);\n        int prccnvcd = readUnsignedByte();\n        if ((prccnvcd != 0x01) && (prccnvcd != 0x02) && (prccnvcd != 0x03) &&\n                (prccnvcd != 0x04) && (prccnvcd != 0x05) && (prccnvcd != 0x06) &&\n                (prccnvcd != 0x10) && (prccnvcd != 0x11) && (prccnvcd != 0x12) &&\n                (prccnvcd != 0x13) && (prccnvcd != 0x15)) {\n            doValnsprmSemantics(CodePoint.PRCCNVCD, prccnvcd);\n        }\n        return prccnvcd;\n    }\n\n    // CCSID for Single-Byte Characters specifies a coded character\n    // set identifier for single-byte characters.\n    protected int parseCCSIDSBC() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.CCSIDSBC);\n        return readUnsignedShort();\n    }\n\n    // CCSID for Mixed-Byte Characters specifies a coded character\n    // set identifier for mixed-byte characters.\n    protected int parseCCSIDMBC() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.CCSIDMBC);\n        return readUnsignedShort();\n    }\n\n    // CCSID for Double-Byte Characters specifies a coded character\n    // set identifier for double-byte characters.\n    protected int parseCCSIDDBC() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.CCSIDDBC);\n        return readUnsignedShort();\n    }\n\n    // Severity Code is an indicator of the severity of a condition\n    // detected during the execution of a command.\n    protected int parseSVRCOD(int minSvrcod, int maxSvrcod) throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.SVRCOD);\n\n        int svrcod = readUnsignedShort();\n        if ((svrcod != CodePoint.SVRCOD_INFO) &&\n                (svrcod != CodePoint.SVRCOD_WARNING) &&\n                (svrcod != CodePoint.SVRCOD_ERROR) &&\n                (svrcod != CodePoint.SVRCOD_SEVERE) &&\n                (svrcod != CodePoint.SVRCOD_ACCDMG) &&\n                (svrcod != CodePoint.SVRCOD_PRMDMG) &&\n                (svrcod != CodePoint.SVRCOD_SESDMG)) {\n            doValnsprmSemantics(CodePoint.SVRCOD, svrcod);\n        }\n\n        if (svrcod < minSvrcod || svrcod > maxSvrcod) {\n            doValnsprmSemantics(CodePoint.SVRCOD, svrcod);\n        }\n\n        return svrcod;\n    }\n\n    protected int parseFastSVRCOD(int minSvrcod, int maxSvrcod) throws DisconnectException {\n        matchCodePoint(CodePoint.SVRCOD);\n\n        int svrcod = readFastUnsignedShort();\n        if ((svrcod != CodePoint.SVRCOD_INFO) &&\n                (svrcod != CodePoint.SVRCOD_WARNING) &&\n                (svrcod != CodePoint.SVRCOD_ERROR) &&\n                (svrcod != CodePoint.SVRCOD_SEVERE) &&\n                (svrcod != CodePoint.SVRCOD_ACCDMG) &&\n                (svrcod != CodePoint.SVRCOD_PRMDMG) &&\n                (svrcod != CodePoint.SVRCOD_SESDMG)) {\n            doValnsprmSemantics(CodePoint.SVRCOD, svrcod);\n        }\n\n        if (svrcod < minSvrcod || svrcod > maxSvrcod) {\n            doValnsprmSemantics(CodePoint.SVRCOD, svrcod);\n        }\n\n        return svrcod;\n    }\n\n    protected NetSqlca parseSQLCARD(Sqlca[] rowsetSqlca) throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.SQLCARD);\n        int ddmLength = getDdmLength();\n        ensureBLayerDataInBuffer(ddmLength);\n        NetSqlca netSqlca = parseSQLCARDrow(rowsetSqlca);\n        adjustLengths(getDdmLength());\n        return netSqlca;\n    }\n    //--------------------------parse FDOCA objects------------------------\n\n    // SQLCARD : FDOCA EARLY ROW\n    // SQL Communications Area Row Description\n    //\n    // FORMAT FOR ALL SQLAM LEVELS\n    //   SQLCAGRP; GROUP LID 0x54; ELEMENT TAKEN 0(all); REP FACTOR 1\n\n    NetSqlca parseSQLCARDrow(Sqlca[] rowsetSqlca) throws DisconnectException {\n        return parseSQLCAGRP(rowsetSqlca);\n    }\n\n    // SQLNUMROW : FDOCA EARLY ROW\n    // SQL Number of Elements Row Description\n    //\n    // FORMAT FOR SQLAM LEVELS\n    //   SQLNUMGRP; GROUP LID 0x58; ELEMENT TAKEN 0(all); REP FACTOR 1\n    int parseSQLNUMROW() throws DisconnectException {\n        return parseSQLNUMGRP();\n    }\n\n    int parseFastSQLNUMROW() throws DisconnectException {\n        return parseFastSQLNUMGRP();\n    }\n\n    // SQLNUMGRP : FDOCA EARLY GROUP\n    // SQL Number of Elements Group Description\n    //\n    // FORMAT FOR ALL SQLAM LEVELS\n    //   SQLNUM; PROTOCOL TYPE I2; ENVLID 0x04; Length Override 2\n    private int parseSQLNUMGRP() throws DisconnectException {\n        return readShort();\n    }\n\n    private int parseFastSQLNUMGRP() throws DisconnectException {\n        return readFastShort();\n    }\n\n    // SQLCAGRP : FDOCA EARLY GROUP\n    // SQL Communcations Area Group Description\n    //\n    // FORMAT FOR SQLAM <= 6\n    //   SQLCODE; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    //   SQLSTATE; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 5\n    //   SQLERRPROC; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 8\n    //   SQLCAXGRP; PROTOCOL TYPE N-GDA; ENVLID 0x52; Length Override 0\n    //\n    // FORMAT FOR SQLAM >= 7\n    //   SQLCODE; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    //   SQLSTATE; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 5\n    //   SQLERRPROC; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 8\n    //   SQLCAXGRP; PROTOCOL TYPE N-GDA; ENVLID 0x52; Length Override 0\n    //   SQLDIAGGRP; PROTOCOL TYPE N-GDA; ENVLID 0x56; Length Override 0\n    private NetSqlca parseSQLCAGRP(Sqlca[] rowsetSqlca) throws DisconnectException {\n        if (readFastUnsignedByte() == CodePoint.NULLDATA) {\n            return null;\n        }\n\n        int sqlcode = readFastInt();\n        byte[] sqlstate = readFastBytes(5);\n        byte[] sqlerrproc = readFastBytes(8);\n        NetSqlca netSqlca = null;\n        \n        try\n        {\n            netSqlca = new NetSqlca(netAgent_.netConnection_,\n                    sqlcode,\n                    sqlstate,\n                    sqlerrproc);\n        }\n        catch(SqlException sqle)\n        {\n            throw new DisconnectException(netAgent_,sqle);\n        }\n        parseSQLCAXGRP(netSqlca);\n\n        if (netAgent_.targetSqlam_ >= NetConfiguration.MGRLVL_7) {\n            netSqlca.setRowsetRowCount(parseSQLDIAGGRP(rowsetSqlca));\n        }\n\n        return netSqlca;\n    }\n\n    // SQLCAXGRP : EARLY FDOCA GROUP\n    // SQL Communications Area Exceptions Group Description\n    //\n    // FORMAT FOR SQLAM <= 6\n    //   SQLRDBNME; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 18\n    //   SQLERRD1; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    //   SQLERRD2; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    //   SQLERRD3; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    //   SQLERRD4; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    //   SQLERRD5; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    //   SQLERRD6; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    //   SQLWARN0; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN1; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN2; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN3; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN4; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN5; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN6; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN7; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN8; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN9; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARNA; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLERRMSG_m; PROTOCOL TYPE VCM; ENVLID 0x3E; Length Override 70\n    //   SQLERRMSG_s; PROTOCOL TYPE VCS; ENVLID 0x32; Length Override 70\n    //\n    // FORMAT FOR SQLAM >= 7\n    //   SQLERRD1; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    //   SQLERRD2; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    //   SQLERRD3; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    //   SQLERRD4; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    //   SQLERRD5; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    //   SQLERRD6; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    //   SQLWARN0; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN1; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN2; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN3; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN4; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN5; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN6; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN7; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN8; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARN9; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLWARNA; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    //   SQLRDBNAME; PROTOCOL TYPE VCS; ENVLID 0x32; Length Override 255\n    //   SQLERRMSG_m; PROTOCOL TYPE VCM; ENVLID 0x3E; Length Override 70\n    //   SQLERRMSG_s; PROTOCOL TYPE VCS; ENVLID 0x32; Length Override 70\n    private void parseSQLCAXGRP(NetSqlca netSqlca) throws DisconnectException {\n        if (readFastUnsignedByte() == CodePoint.NULLDATA) {\n            netSqlca.setContainsSqlcax(false);\n            return;\n        }\n\n        if (netAgent_.targetSqlam_ < NetConfiguration.MGRLVL_7) {\n            // skip over the rdbnam for now\n            //   SQLRDBNME; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 18\n            skipFastBytes(18);\n        }\n        //   SQLERRD1 to SQLERRD6; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n        int[] sqlerrd = new int[6];\n        readFastIntArray(sqlerrd);\n\n        //   SQLWARN0 to SQLWARNA; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n        byte[] sqlwarn = readFastBytes(11);\n\n        if (netAgent_.targetSqlam_ >= NetConfiguration.MGRLVL_7) {\n            // skip over the rdbnam for now\n            // SQLRDBNAME; PROTOCOL TYPE VCS; ENVLID 0x32; Length Override 255\n            parseFastVCS();\n        }\n\n\n        int sqlerrmcCcsid = 0;\n        byte[] sqlerrmc = readFastLDBytes();\n        if (sqlerrmc != null) {\n            sqlerrmcCcsid = netAgent_.targetTypdef_.getCcsidMbc();\n            skipFastBytes(2);\n        } else {\n            sqlerrmc = readFastLDBytes();\n            sqlerrmcCcsid = netAgent_.targetTypdef_.getCcsidSbc();\n        }\n\n        netSqlca.setSqlerrd(sqlerrd);\n        netSqlca.setSqlwarnBytes(sqlwarn);\n        netSqlca.setSqlerrmcBytes(sqlerrmc, sqlerrmcCcsid); // sqlerrmc may be null\n    }\n\n    // SQLDIAGGRP : FDOCA EARLY GROUP\n    // SQL Diagnostics Group Description - Identity 0xD1\n    // Nullable Group\n    // SQLDIAGSTT; PROTOCOL TYPE N-GDA; ENVLID 0xD3; Length Override 0\n    // SQLDIAGCN;  DRFA TYPE N-RLO; ENVLID 0xF6; Length Override 0\n    // SQLDIAGCI;  PROTOCOL TYPE N-RLO; ENVLID 0xF5; Length Override 0\n    private long parseSQLDIAGGRP(Sqlca[] rowsetSqlca) throws DisconnectException {\n        if (readFastUnsignedByte() == CodePoint.NULLDATA) {\n            return 0;\n        }\n\n        long row_count = parseSQLDIAGSTT(rowsetSqlca);\n        parseSQLDIAGCI(rowsetSqlca);\n        parseSQLDIAGCN();\n\n        return row_count;\n    }\n\n    // this is duplicated in parseColumnMetaData, but different\n    // DAGroup under NETColumnMetaData requires a lot more stuffs including\n    // precsion, scale and other stuffs\n    protected String parseFastVCS() throws DisconnectException {\n        // doublecheck what readString() does if the length is 0\n        return readFastString(readFastUnsignedShort(),\n                netAgent_.targetTypdef_.getCcsidSbcEncoding());\n    }\n    //----------------------non-parsing computational helper methods--------------\n\n    protected boolean checkAndGetReceivedFlag(boolean receivedFlag) throws DisconnectException {\n        if (receivedFlag) {\n            // this method will throw a disconnect exception if\n            // the received flag is already true;\n            doSyntaxrmSemantics(CodePoint.SYNERRCD_DUP_OBJ_PRESENT);\n        }\n        return true;\n    }\n\n    protected void checkRequiredObjects(boolean receivedFlag) throws DisconnectException {\n        if (!receivedFlag) {\n            doSyntaxrmSemantics(CodePoint.SYNERRCD_REQ_OBJ_NOT_FOUND);\n        }\n    }\n\n    protected void checkRequiredObjects(boolean receivedFlag,\n                                        boolean receivedFlag2) throws DisconnectException {\n        if (!receivedFlag || !receivedFlag2) {\n            doSyntaxrmSemantics(CodePoint.SYNERRCD_REQ_OBJ_NOT_FOUND);\n        }\n    }\n\n    protected void checkRequiredObjects(boolean receivedFlag,\n                                        boolean receivedFlag2,\n                                        boolean receivedFlag3) throws DisconnectException {\n        if (!receivedFlag || !receivedFlag2 || !receivedFlag3) {\n            doSyntaxrmSemantics(CodePoint.SYNERRCD_REQ_OBJ_NOT_FOUND);\n        }\n    }\n\n    protected void checkRequiredObjects(boolean receivedFlag,\n                                        boolean receivedFlag2,\n                                        boolean receivedFlag3,\n                                        boolean receivedFlag4) throws DisconnectException {\n        if (!receivedFlag || !receivedFlag2 || !receivedFlag3 || !receivedFlag4) {\n            doSyntaxrmSemantics(CodePoint.SYNERRCD_REQ_OBJ_NOT_FOUND);\n        }\n    }\n\n    protected void checkRequiredObjects(boolean receivedFlag,\n                                        boolean receivedFlag2,\n                                        boolean receivedFlag3,\n                                        boolean receivedFlag4,\n                                        boolean receivedFlag5,\n                                        boolean receivedFlag6) throws DisconnectException {\n        if (!receivedFlag || !receivedFlag2 || !receivedFlag3 || !receivedFlag4 ||\n                !receivedFlag5 || !receivedFlag6) {\n            doSyntaxrmSemantics(CodePoint.SYNERRCD_REQ_OBJ_NOT_FOUND);\n        }\n\n    }\n\n    protected void checkRequiredObjects(boolean receivedFlag,\n                                        boolean receivedFlag2,\n                                        boolean receivedFlag3,\n                                        boolean receivedFlag4,\n                                        boolean receivedFlag5,\n                                        boolean receivedFlag6,\n                                        boolean receivedFlag7) throws DisconnectException {\n        if (!receivedFlag || !receivedFlag2 || !receivedFlag3 || !receivedFlag4 ||\n                !receivedFlag5 || !receivedFlag6 || !receivedFlag7) {\n            doSyntaxrmSemantics(CodePoint.SYNERRCD_REQ_OBJ_NOT_FOUND);\n        }\n    }\n\n    // These methods are \"private protected\", which is not a recognized java privilege,\n    // but means that these methods are private to this class and to subclasses,\n    // and should not be used as package-wide friendly methods.\n\n    protected void doObjnsprmSemantics(int codePoint) throws DisconnectException {\n        agent_.accumulateChainBreakingReadExceptionAndThrow(new DisconnectException(agent_,\n            new ClientMessageId(SQLState.DRDA_DDM_OBJECT_NOT_SUPPORTED),\n            Integer.toHexString(codePoint)));\n    }\n\n    // Also called by NetStatementReply.\n    protected void doPrmnsprmSemantics(int codePoint) throws DisconnectException {\n        agent_.accumulateChainBreakingReadExceptionAndThrow(new DisconnectException(agent_,\n            new ClientMessageId(SQLState.DRDA_DDM_PARAM_NOT_SUPPORTED),\n            Integer.toHexString(codePoint)));\n    }\n\n    // Also called by NetStatementReply\n    void doValnsprmSemantics(int codePoint, int value) throws DisconnectException {\n        doValnsprmSemantics(codePoint, Integer.toString(value));\n    }\n\n    void doValnsprmSemantics(int codePoint, String value) throws DisconnectException {\n\n        // special case the FDODTA codepoint not to disconnect.\n        if (codePoint == CodePoint.FDODTA) {\n            agent_.accumulateReadException(new SqlException(agent_.logWriter_,\n                new ClientMessageId(SQLState.DRDA_DDM_PARAMVAL_NOT_SUPPORTED),\n                Integer.toHexString(codePoint)));\n            return;\n        }\n\n        if (codePoint == CodePoint.CCSIDSBC ||\n                codePoint == CodePoint.CCSIDDBC ||\n                codePoint == CodePoint.CCSIDMBC) {\n            // the server didn't like one of the ccsids.\n            // the message should reflect the error in question.  right now these values\n            // will be hard coded but this won't be correct if our driver starts sending\n            // other values to the server.  In order to pick up the correct values,\n            // a little reorganization may need to take place so that this code (or\n            // whatever code sets the message) has access to the correct values.\n            int cpValue = 0;\n            switch (codePoint) {\n            case CodePoint.CCSIDSBC:\n                cpValue = netAgent_.typdef_.getCcsidSbc();\n                break;\n            case CodePoint.CCSIDDBC:\n                cpValue = netAgent_.typdef_.getCcsidDbc();\n                break;\n            case CodePoint.CCSIDMBC:\n                cpValue = netAgent_.typdef_.getCcsidSbc();\n                break;\n            default:\n                // should never be in this default case...\n                cpValue = 0;\n                break;\n            }\n            agent_.accumulateChainBreakingReadExceptionAndThrow(new DisconnectException(agent_,\n                new ClientMessageId(SQLState.DRDA_NO_AVAIL_CODEPAGE_CONVERSION),\n                new Integer(cpValue), value));\n            return;\n        }\n        // the problem isn't with one of the ccsid values so...\n\n        // Returning more information would\n        // require rearranging this code a little.\n        agent_.accumulateChainBreakingReadExceptionAndThrow(new DisconnectException(agent_,\n            new ClientMessageId(SQLState.DRDA_DDM_PARAMVAL_NOT_SUPPORTED),\n            Integer.toHexString(codePoint)));\n    }\n\n    void doDtamchrmSemantics() throws DisconnectException {\n        agent_.accumulateChainBreakingReadExceptionAndThrow(new DisconnectException(agent_,\n            new ClientMessageId(SQLState.DRDA_CONNECTION_TERMINATED),\n                msgutil_.getTextMessage(MessageId.CONN_DRDA_DTARMCHRM)));\n    }\n\n    // Messages\n    //  SQLSTATE : 58010\n    //      Execution failed due to a distribution protocol error that\n    //      will affect the successful execution of subsequent DDM commands\n    //      or SQL statements.\n    //  SQLCODE : -30021\n    //       Execution failed because of a Distributed Protocol\n    //       Error that will affect the successful execution of subsequent\n    //       commands and SQL statements: Manager <manager> at Level\n    //       <level> not supported.\n    //\n    //       A system erro occurred that prevented successful connection\n    //       of the application to the remote database.  This message (SQLCODE)\n    //       is producted for SQL CONNECT statement.\n    private void doMgrlvlrmSemantics(String manager, String level) throws DisconnectException {\n        agent_.accumulateChainBreakingReadExceptionAndThrow(new DisconnectException(agent_,\n            new ClientMessageId(SQLState.DRDA_MGRLVLRM),\n            manager, level));\n    }\n\n    private void doMgrlvlrmSemantics(int manager, int level) throws DisconnectException {\n        doMgrlvlrmSemantics(\"0x\" + Integer.toHexString(manager),\n                \"0x\" + Integer.toHexString(level));\n    }\n\n    private void doMgrlvlrmSemantics(int[] nameList, int[] levelList) throws DisconnectException {\n        StringBuffer managerNames = new StringBuffer(100);\n        StringBuffer managerLevels = new StringBuffer(100);\n\n        int count = nameList.length;\n        for (int i = 0; i < count; i++) {\n            managerNames.append(\"0x\");\n            managerNames.append(nameList[i]);\n            managerLevels.append(\"0x\");\n            managerLevels.append(levelList[i]);\n            if (i != (count - 1)) {\n                managerNames.append(\",\");\n                managerLevels.append(\",\");\n            }\n        }\n        doMgrlvlrmSemantics(managerNames.toString(), managerLevels.toString());\n    }\n\n    // The client can detect that a conversational protocol error has occurred.\n    // This can also be detected at the server in which case a PRCCNVRM is returned.\n    // The Conversation Protocol Error Code, PRCCNVRM, describes the various errors.\n    //\n    // Note: Not all of these may be valid at the client.  See descriptions for\n    // which ones make sense for client side errors/checks.\n    // Conversation Error Code                  Description of Error\n    // -----------------------                  --------------------\n    // 0x01                                     RPYDSS received by target communications manager.\n    // 0x02                                     Multiple DSSs sent without chaining or multiple\n    //                                          DSS chains sent.\n    // 0x03                                     OBJDSS sent when not allowed.\n    // 0x04                                     Request correlation identifier of an RQSDSS\n    //                                          is less than or equal to the previous\n    //                                          RQSDSS's request correlatio identifier in the chain.\n    // 0x05                                     Request correlation identifier of an OBJDSS\n    //                                          does not equal the request correlation identifier\n    //                                          of the preceding RQSDSS.\n    // 0x06                                     EXCSAT was not the first command after the connection\n    //                                          was established.\n    // 0x10                                     ACCSEC or SECCHK command sent in wrong state.\n    // 0x11                                     SYNCCTL or SYNCRSY command is used incorrectly.\n    // 0x12                                     RDBNAM mismatch between ACCSEC, SECCHK, and ACCRDB.\n    // 0x13                                     A command follows one that returned EXTDTAs as reply object.\n    //\n    // When the client detects these errors, it will be handled as if a PRCCNVRM is returned\n    // from the server.  In this PRCCNVRM case, PROTOCOL architects an SQLSTATE of 58008 or 58009\n    // depening of the SVRCOD.  In this case, a 58009 will always be returned.\n    // Messages\n    // SQLSTATE : 58009\n    //     Execution failed due to a distribution protocol error that caused deallocation of the conversation.\n    //     SQLCODE : -30020\n    //     Execution failed because of a Distributed Protocol\n    //         Error that will affect the successful execution of subsequent\n    //         commands and SQL statements: Reason Code <reason-code>.\n    //      Some possible reason codes include:\n    //      121C Indicates that the user is not authorized to perform the requested command.\n    //      1232 The command could not be completed because of a permanent error.\n    //          In most cases, the server will be in the process of an abend.\n    //      220A The target server has received an invalid data description.\n    //          If a user SQLDA is specified, ensure that the fields are\n    //          initialized correctly. Also, ensure that the length does not\n    //          exceed the maximum allowed length for the data type being used.\n    //\n    //      The command or statement cannot be processed.  The current\n    //          transaction is rolled back and the application is disconnected\n    //          from the remote database.\n    protected void doPrccnvrmSemantics(int conversationProtocolErrorCode) throws DisconnectException {\n        // we may need to map the conversation protocol error code, prccnvcd, to some kind\n        // of reason code.  For now just return the prccnvcd as the reason code\n        agent_.accumulateChainBreakingReadExceptionAndThrow(new DisconnectException(agent_,\n            new ClientMessageId(SQLState.DRDA_CONNECTION_TERMINATED),\n                msgutil_.getTextMessage(MessageId.CONN_DRDA_PRCCNVRM, \n                    Integer.toHexString(conversationProtocolErrorCode))));\n    }\n\n    // SQL Diagnostics Condition Token Array - Identity 0xF7\n    // SQLNUMROW; ROW LID 0x68; ELEMENT TAKEN 0(all); REP FACTOR 1\n    // SQLTOKROW; ROW LID 0xE7; ELEMENT TAKEN 0(all); REP FACTOR 0(all)\n    void parseSQLDCTOKS() throws DisconnectException {\n        if (readFastUnsignedByte() == CodePoint.NULLDATA) {\n            return;\n        }\n        int num = parseFastSQLNUMROW();\n        for (int i = 0; i < num; i++) {\n            parseSQLTOKROW();\n        }\n    }\n\n    // SQL Diagnostics Condition Information Array - Identity 0xF5\n    // SQLNUMROW; ROW LID 0x68; ELEMENT TAKEN 0(all); REP FACTOR 1\n    // SQLDCIROW; ROW LID 0xE5; ELEMENT TAKEN 0(all); REP FACTOR 0(all)\n    private void parseSQLDIAGCI(Sqlca[] rowsetSqlca) throws DisconnectException {\n        if (readFastUnsignedByte() == CodePoint.NULLDATA) {\n            return;\n        }\n        int num = parseFastSQLNUMROW();\n        if (num == 0) {\n            resetRowsetSqlca(rowsetSqlca, 0);\n        }\n\n        // lastRow is the row number for the last row that had a non-null SQLCA.\n        int lastRow = 1;\n        for (int i = 0; i < num; i++) {\n            lastRow = parseSQLDCROW(rowsetSqlca, lastRow);\n        }\n        resetRowsetSqlca(rowsetSqlca, lastRow + 1);\n    }\n\n    // SQL Diagnostics Connection Array - Identity 0xF6\n    // SQLNUMROW; ROW LID 0x68; ELEMENT TAKEN 0(all); REP FACTOR 1\n    // SQLCNROW;  ROW LID 0xE6; ELEMENT TAKEN 0(all); REP FACTOR 0(all)\n    private void parseSQLDIAGCN() throws DisconnectException {\n        if (readUnsignedByte() == CodePoint.NULLDATA) {\n            return;\n        }\n        int num = parseFastSQLNUMROW();\n        for (int i = 0; i < num; i++) {\n            parseSQLCNROW();\n        }\n    }\n\n    // SQL Diagnostics Connection Row - Identity 0xE6\n    // SQLCNGRP; GROUP LID 0xD6; ELEMENT TAKEN 0(all); REP FACTOR 1\n    private void parseSQLCNROW() throws DisconnectException {\n        parseSQLCNGRP();\n    }\n\n    // SQL Diagnostics Condition Row - Identity 0xE5\n    // SQLDCGRP; GROUP LID 0xD5; ELEMENT TAKEN 0(all); REP FACTOR 1\n    private int parseSQLDCROW(Sqlca[] rowsetSqlca, int lastRow) throws DisconnectException {\n        return parseSQLDCGRP(rowsetSqlca, lastRow);\n    }\n\n    // SQL Diagnostics Token Row - Identity 0xE7\n    // SQLTOKGRP; GROUP LID 0xD7; ELEMENT TAKEN 0(all); REP FACTOR 1\n    private void parseSQLTOKROW() throws DisconnectException {\n        parseSQLTOKGRP();\n    }\n\n    // check on SQLTOKGRP format\n    private void parseSQLTOKGRP() throws DisconnectException {\n        skipFastNVCMorNVCS();\n    }\n\n    // SQL Diagnostics Statement Group Description - Identity 0xD3\n    // Nullable Group\n    // SQLDSFCOD; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLDSCOST; PROTOCOL TYPE I4; ENVLID 0X02; Length Override 4\n    // SQLDSLROW; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLDSNPM; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLDSNRS; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLDSRNS; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLDSDCOD; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLDSROWC; PROTOCOL TYPE FD; ENVLID 0x0E; Length Override 31\n    // SQLDSNROW; PROTOCOL TYPE FD; ENVLID 0x0E; Length Override 31\n    // SQLDSROWCS; PROTOCOL TYPE FD; ENVLID 0x0E; Length Override 31\n    // SQLDSACON; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    // SQLDSACRH; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    // SQLDSACRS; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    // SQLDSACSL; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    // SQLDSACSE; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    // SQLDSACTY; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    // SQLDSCERR; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    // SQLDSMORE; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    private long parseSQLDIAGSTT(Sqlca[] rowsetSqlca) throws DisconnectException {\n        if (readFastUnsignedByte() == CodePoint.NULLDATA) {\n            return 0;\n        }\n        int sqldsFcod = readFastInt(); // FUNCTION_CODE\n        int sqldsCost = readFastInt(); // COST_ESTIMATE\n        int sqldsLrow = readFastInt(); // LAST_ROW\n\n        skipFastBytes(16);\n\n        long sqldsRowc = readFastLong(); // ROW_COUNT\n\n        skipFastBytes(24);\n\n        return sqldsRowc;\n    }\n\n    // SQL Diagnostics Connection Group Description - Identity 0xD6\n    // Nullable\n    //\n    // SQLCNSTATE; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLCNSTATUS; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLCNATYPE; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    // SQLCNETYPE; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 1\n    // SQLCNPRDID; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 8\n    // SQLCNRDB; PROTOCOL TYPE VCS; ENVLID 0x32; Length Override 255\n    // SQLCNCLASS; PROTOCOL TYPE VCS; ENVLID 0x32; Length Override 255\n    // SQLCNAUTHID; PROTOCOL TYPE VCS; ENVLID 0x32; Length Override 255\n    private void parseSQLCNGRP() throws DisconnectException {\n        skipBytes(18);\n        String sqlcnRDB = parseFastVCS();    // RDBNAM\n        String sqlcnClass = parseFastVCS();  // CLASS_NAME\n        String sqlcnAuthid = parseFastVCS(); // AUTHID\n    }\n\n    // SQL Diagnostics Condition Group Description\n    //\n    // SQLDCCODE; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLDCSTATE; PROTOCOL TYPE FCS; ENVLID Ox30; Lengeh Override 5\n    // SQLDCREASON; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLDCLINEN; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLDCROWN; PROTOCOL TYPE FD; ENVLID 0x0E; Lengeh Override 31\n    // SQLDCER01; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLDCER02; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLDCER03; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLDCER04; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLDCPART; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLDCPPOP; PROTOCOL TYPE I4; ENVLID 0x02; Length Override 4\n    // SQLDCMSGID; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 10\n    // SQLDCMDE; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 8\n    // SQLDCPMOD; PROTOCOL TYPE FCS; ENVLID 0x30; Length Override 5\n    // SQLDCRDB; PROTOCOL TYPE VCS; ENVLID 0x32; Length Override 255\n    // SQLDCTOKS; PROTOCOL TYPE N-RLO; ENVLID 0xF7; Length Override 0\n    // SQLDCMSG_m; PROTOCOL TYPE NVMC; ENVLID 0x3F; Length Override 32672\n    // SQLDCMSG_S; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 32672\n    // SQLDCCOLN_m; PROTOCOL TYPE NVCM ; ENVLID 0x3F; Length Override 255\n    // SQLDCCOLN_s; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    // SQLDCCURN_m; PROTOCOL TYPE NVCM; ENVLID 0x3F; Length Override 255\n    // SQLDCCURN_s; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    // SQLDCPNAM_m; PROTOCOL TYPE NVCM; ENVLID 0x3F; Length Override 255\n    // SQLDCPNAM_s; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    // SQLDCXGRP; PROTOCOL TYPE N-GDA; ENVLID 0xD3; Length Override 1\n    private int parseSQLDCGRP(Sqlca[] rowsetSqlca, int lastRow) throws DisconnectException {\n        int sqldcCode = readFastInt(); // SQLCODE\n        String sqldcState = readFastString(5, Typdef.UTF8ENCODING); // SQLSTATE\n        int sqldcReason = readFastInt();  // REASON_CODE\n        int sqldcLinen = readFastInt(); // LINE_NUMBER\n        int sqldcRown = (int) readFastLong(); // ROW_NUMBER\n\n        // save +20237 in the 0th entry of the rowsetSqlca's.\n        // this info is going to be used when a subsequent fetch prior is issued, and if already\n        // received a +20237 then we've gone beyond the first row and there is no need to\n        // flow another fetch to the server.\n        if (sqldcCode == 20237) {\n            rowsetSqlca[0] = new NetSqlca(netAgent_.netConnection_,\n                    sqldcCode,\n                    sqldcState,\n                    null);\n        } else {\n            if (rowsetSqlca[sqldcRown] != null) {\n                rowsetSqlca[sqldcRown].resetRowsetSqlca(netAgent_.netConnection_,\n                        sqldcCode,\n                        sqldcState,\n                        null);\n            } else {\n                rowsetSqlca[sqldcRown] = new NetSqlca(netAgent_.netConnection_,\n                        sqldcCode,\n                        sqldcState,\n                        null);\n            }\n        }\n\n        // reset all entries between lastRow and sqldcRown to null\n        for (int i = lastRow + 1; i < sqldcRown; i++) {\n            rowsetSqlca[i] = null;\n        }\n\n        skipFastBytes(47);\n        String sqldcRdb = parseFastVCS(); // RDBNAM\n        // skip the tokens for now, since we already have the complete message.\n        parseSQLDCTOKS(); // MESSAGE_TOKENS\n        String sqldcMsg = parseFastNVCMorNVCS(); // MESSAGE_TEXT\n\n        // skip the following for now.\n        skipFastNVCMorNVCS();  // COLUMN_NAME\n        skipFastNVCMorNVCS();  // PARAMETER_NAME\n        skipFastNVCMorNVCS();  // EXTENDED_NAMES\n\n        parseSQLDCXGRP(); // SQLDCXGRP\n        return sqldcRown;\n    }\n\n    // SQL Diagnostics Extended Names Group Description - Identity 0xD5\n    // Nullable\n    //\n    // SQLDCXRDB_m ; PROTOCOL TYPE NVCM; ENVLID 0x3F; Length Override 255\n    // SQLDCXSCH_m ; PROTOCOL TYPE NVCM; ENVLID 0x3F; Length Override 255\n    // SQLDCXNAM_m ; PROTOCOL TYPE NVCM; ENVLID 0x3F; Length Override 255\n    // SQLDCXTBLN_m ; PROTOCOL TYPE NVCM; ENVLID 0x3F; Length Override 255\n    // SQLDCXRDB_s ; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    // SQLDCXSCH_s ; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    // SQLDCXNAM_s ; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    // SQLDCXTBLN_s ; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    //\n    // SQLDCXCRDB_m ; PROTOCOL TYPE NVCM; ENVLID 0x3F; Length Override 255\n    // SQLDCXCSCH_m ; PROTOCOL TYPE NVCM; ENVLID 0x3F; Length Override 255\n    // SQLDCXCNAM_m ; PROTOCOL TYPE NVCM; ENVLID 0x3F; Length Override 255\n    // SQLDCXCRDB_s ; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    // SQLDCXCSCH_s ; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    // SQLDCXCNAM_s ; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    //\n    // SQLDCXRRDB_m ; PROTOCOL TYPE NVCM; ENVLID 0x3F; Length Override 255\n    // SQLDCXRSCH_m ; PROTOCOL TYPE NVCM; ENVLID 0x3F; Length Override 255\n    // SQLDCXRNAM_m ; PROTOCOL TYPE NVCM; ENVLID 0x3F; Length Override 255\n    // SQLDCXRRDB_s ; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    // SQLDCXRSCH_s ; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    // SQLDCXRNAM_s ; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    //\n    // SQLDCXTRDB_m ; PROTOCOL TYPE NVCM; ENVLID 0x3F; Length Override 255\n    // SQLDCXTSCH_m ; PROTOCOL TYPE NVCM; ENVLID 0x3F; Length Override 255\n    // SQLDCXTNAM_m ; PROTOCOL TYPE NVCM; ENVLID 0x3F; Length Override 255\n    // SQLDCXTRDB_s ; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    // SQLDCXTSCH_s ; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    // SQLDCXTNAM_s ; PROTOCOL TYPE NVCS; ENVLID 0x33; Length Override 255\n    private void parseSQLDCXGRP() throws DisconnectException {\n        if (readFastUnsignedByte() == CodePoint.NULLDATA) {\n            return;\n        }\n        skipFastNVCMorNVCS();  // OBJECT_RDBNAM\n        skipFastNVCMorNVCS();  // OBJECT_SCHEMA\n        skipFastNVCMorNVCS();  // SPECIFIC_NAME\n        skipFastNVCMorNVCS();  // TABLE_NAME\n        String sqldcxCrdb = parseFastVCS();        // CONSTRAINT_RDBNAM\n        skipFastNVCMorNVCS();  // CONSTRAINT_SCHEMA\n        skipFastNVCMorNVCS();  // CONSTRAINT_NAME\n        parseFastVCS();        // ROUTINE_RDBNAM\n        skipFastNVCMorNVCS();  // ROUTINE_SCHEMA\n        skipFastNVCMorNVCS();  // ROUTINE_NAME\n        parseFastVCS();        // TRIGGER_RDBNAM\n        skipFastNVCMorNVCS();  // TRIGGER_SCHEMA\n        skipFastNVCMorNVCS();  // TRIGGER_NAME\n    }\n\n    private String parseFastNVCMorNVCS() throws DisconnectException {\n        String stringToBeSet = null;\n        int vcm_length = 0;\n        int vcs_length = 0;\n        if (readFastUnsignedByte() != CodePoint.NULLDATA) {\n            vcm_length = readFastUnsignedShort();\n            if (vcm_length > 0) {\n                stringToBeSet = readFastString(vcm_length, netAgent_.targetTypdef_.getCcsidMbcEncoding());\n            }\n            if (readFastUnsignedByte() != CodePoint.NULLDATA) {\n                agent_.accumulateChainBreakingReadExceptionAndThrow(\n                    new DisconnectException(agent_,\n                        new ClientMessageId(\n                            SQLState.NET_NVCM_NVCS_BOTH_NON_NULL)));\n            }\n        } else {\n            if (readFastUnsignedByte() != CodePoint.NULLDATA) {\n                vcs_length = readFastUnsignedShort();\n                if (vcs_length > 0) {\n                    stringToBeSet = readFastString(vcs_length, netAgent_.targetTypdef_.getCcsidSbcEncoding());\n                }\n            }\n        }\n        return stringToBeSet;\n    }\n\n    private void skipFastNVCMorNVCS() throws DisconnectException {\n        int vcm_length = 0;\n        int vcs_length = 0;\n        if (readFastUnsignedByte() != CodePoint.NULLDATA) {\n            vcm_length = readFastUnsignedShort();\n            if (vcm_length > 0)\n            //stringToBeSet = readString (vcm_length, netAgent_.targetTypdef_.getCcsidMbcEncoding());\n            {\n                skipFastBytes(vcm_length);\n            }\n            if (readFastUnsignedByte() != CodePoint.NULLDATA) {\n                agent_.accumulateChainBreakingReadExceptionAndThrow(\n                    new DisconnectException(agent_,\n                        new ClientMessageId(\n                            SQLState.NET_NVCM_NVCS_BOTH_NON_NULL)));\n            }\n        } else {\n            if (readFastUnsignedByte() != CodePoint.NULLDATA) {\n                vcs_length = readFastUnsignedShort();\n                if (vcs_length > 0)\n                //stringToBeSet = readString (vcs_length, netAgent_.targetTypdef_.getCcsidSbcEncoding());\n                {\n                    skipFastBytes(vcs_length);\n                }\n            }\n        }\n    }\n\n    void resetRowsetSqlca(Sqlca[] rowsetSqlca, int row) {\n        // rowsetSqlca can be null.\n        int count = ((rowsetSqlca == null) ? 0 : rowsetSqlca.length);\n        for (int i = row; i < count; i++) {\n            rowsetSqlca[i] = null;\n        }\n    }\n\n     /**\n     * Parse the initial PBSD - PiggyBackedSessionData code point.\n     * <p>\n     * If sent by the server, it contains a PBSD_ISO code point followed by a\n     * byte representing the JDBC isolation level, and a PBSD_SCHEMA code point\n     * followed by the name of the current schema as an UTF-8 String.\n     *\n     * @throws org.apache.derby.client.am.DisconnectException\n     */\n    protected void parseInitialPBSD(Connection connection)\n            throws DisconnectException {\n        if (peekCodePoint() != CodePoint.PBSD) {\n            return;\n        }\n        parseLengthAndMatchCodePoint(CodePoint.PBSD);\n        int peekCP = peekCodePoint();\n        while (peekCP != END_OF_SAME_ID_CHAIN) {\n            parseLengthAndMatchCodePoint(peekCP);\n            switch (peekCP) {\n                case CodePoint.PBSD_ISO:\n                    netAgent_.netConnection_.\n                        completeInitialPiggyBackIsolation(readUnsignedByte());\n                    break;\n                case CodePoint.PBSD_SCHEMA:\n                    netAgent_.netConnection_.\n                        completeInitialPiggyBackSchema\n                            (readString(getDdmLength(), \"UTF-8\"));\n                    break;\n                default:\n                    parseCommonError(peekCP);\n            }\n            peekCP = peekCodePoint();\n        }\n    }\n\n    /**\n     * Parse a PBSD - PiggyBackedSessionData code point. Can contain one or\n     * both of, a PBSD_ISO code point followed by a byte representing the jdbc\n     * isolation level, and a PBSD_SCHEMA code point followed by the name of the\n     * current schema as an UTF-8 String.\n     * @throws org.apache.derby.client.am.DisconnectException\n     */\n    protected void parsePBSD() throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.PBSD);\n        int peekCP = peekCodePoint();\n        while (peekCP != END_OF_SAME_ID_CHAIN) {\n            parseLengthAndMatchCodePoint(peekCP);\n            switch (peekCP) {\n            case CodePoint.PBSD_ISO:\n                netAgent_.netConnection_.\n                    completePiggyBackIsolation(readUnsignedByte());\n                break;\n            case CodePoint.PBSD_SCHEMA:\n                netAgent_.netConnection_.\n                    completePiggyBackSchema\n                    (readString(getDdmLength(), \"UTF-8\"));\n                break;\n            default:\n                parseCommonError(peekCP);\n            }\n            peekCP = peekCodePoint();\n        }\n    }\n\n\tpublic java.io.InputStream getInputStream(NetAgent netAgent) {\n\t    return netAgent.rawSocketInputStream_;\n\t}\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 62504
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_method_names": [
                        "parseEXCSATreply",
                        "parseDummyEXCSATreply",
                        "parseACCSECreply",
                        "parseSECCHKreply",
                        "parseACCRDBreply",
                        "parseRDBNACRM",
                        "parseRDBNFNRM",
                        "parseRDBATHRM",
                        "parseRDBAFLRM",
                        "parseMGRLVLRM",
                        "parseCMDCHKRM"
                    ],
                    "llm_response_time": 20797
                },
                {
                    "iteration_num": 2,
                    "suggested_method_names": [
                        "parseMGRLVLLS",
                        "parseEXCSATRD",
                        "parseACCSECRD",
                        "parseSQLCARD",
                        "parseSQLDIAGGRP",
                        "parseSQLCAGRP",
                        "doMgrlvlrmSemantics",
                        "doValnsprmSemantics"
                    ],
                    "llm_response_time": 15776
                },
                {
                    "iteration_num": 3,
                    "suggested_method_names": [
                        "parseMGRLVLLS",
                        "parseSQLCARD",
                        "parseSQLCAGRP",
                        "parseSQLDIAGGRP",
                        "parseSQLDCGRP",
                        "parseSQLCNGRP",
                        "parseSQLTOKGRP",
                        "parseSQLDIAGSTT",
                        "parseSQLCNROW",
                        "parseSQLTOKROW"
                    ],
                    "llm_response_time": 19581
                },
                {
                    "iteration_num": -1,
                    "suggested_method_names": [
                        "parseEXCSATreply",
                        "parseDummyEXCSATreply",
                        "parseACCSECreply",
                        "parseSECCHKreply",
                        "parseACCRDBreply",
                        "parseRDBNACRM",
                        "parseRDBNFNRM",
                        "parseRDBATHRM",
                        "parseRDBAFLRM",
                        "parseMGRLVLRM",
                        "parseCMDCHKRM",
                        "parseMGRLVLLS",
                        "parseEXCSATRD",
                        "parseACCSECRD",
                        "parseSQLCARD",
                        "parseSQLDIAGGRP",
                        "parseSQLCAGRP",
                        "doMgrlvlrmSemantics",
                        "doValnsprmSemantics",
                        "parseSQLDCGRP",
                        "parseSQLCNGRP",
                        "parseSQLTOKGRP",
                        "parseSQLDIAGSTT",
                        "parseSQLCNROW",
                        "parseSQLTOKROW"
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "parseEXCSATreply",
                    "parseACCSECreply",
                    "parseSECCHKreply",
                    "parseACCRDBreply",
                    "parseRDBNACRM",
                    "parseRDBNFNRM",
                    "parseRDBATHRM",
                    "parseRDBAFLRM",
                    "parseMGRLVLRM",
                    "parseCMDCHKRM",
                    "parseMGRLVLLS",
                    "parseEXCSATRD",
                    "parseACCSECRD",
                    "parseSQLCARD",
                    "parseSQLCAGRP",
                    "parseSQLDIAGGRP",
                    "parseSQLDIAGSTT",
                    "doValnsprmSemantics",
                    "doMgrlvlrmSemantics",
                    "parseSQLCNGRP",
                    "parseSQLTOKGRP",
                    "parseSQLCNROW",
                    "parseSQLTOKROW",
                    "parseDummyEXCSATreply",
                    "parseSQLDCGRP"
                ],
                "llm_response_time": 6171
            },
            "targetClassMap": {
                "parseEXCSATreply": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1173,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "parseACCSECreply": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1691,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "parseSECCHKreply": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1908,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "- method org.apache.derby.impl.store.access.btree.OpenBTree::lockScanRow(OpenBTree, BTree, BTreeRowPosition, FetchDescriptor, DataValueDescriptor[], RowLocation, boolean, boolean, int):boolean need move to org.apache.derby.impl.store.access.btree.index.B2IRowLocking1",
        "class_name": "org.apache.derby.impl.store.access.btree.OpenBTree",
        "telemetry": {
            "id": "aa0e1e9e-99a2-4288-a121-bc144f5a42d4",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 678,
                "lineStart": 43,
                "lineEnd": 720,
                "bodyLineStart": 43,
                "language": "java",
                "sourceCode": "/**\n\n  An open b-tree contains fields and methods common to scans and controllers.\n  <P>\n  <B>Concurrency Notes</B>\n  <P>\n  An instance of an open b-tree is owned by a single context.  The b-tree code\n  assumes that the context ensures that only one thread at a time is using\n  the open b-tree.  The open b-tree itself does not enforce or check this.\n\n**/\n\npublic class OpenBTree \n{\n\t/*\n\t** Fields of OpenBTree\n\t*/\n\n    /**\n     * The following group of fields are all basic input parameters which are\n     * provided by the calling code when doing any sort of operation requiring\n     * an open conglomerate (openScan(), open(), openCostController(), ...).\n     * These are just saved values from what was initially input.\n     **/\n    private BTree                           init_conglomerate;\n\n    /**\n    The TransactionManager that open'd this btree.  In the case of Internal\n    transactions used by split this will be the internal transaction, and \n    init_open_user_scans will be the user transaction that began the internal\n    transaction.\n    **/\n    private TransactionManager              init_xact_manager;\n\n    private Transaction                     init_rawtran;\n\n\t/**\n\tThe ContainerHandle mode the container is opened with.  Remember this so\n\tthat if the BTree needs to do SMO with another transaction, it would open\n\tthe container with the same mode.\n\t**/\n    private int                             init_openmode;\n\n    /**\n    Table or page locking?\n    **/\n    protected int                           init_lock_level;\n\n    private boolean                         init_hold;\n\n    /**\n    The Locking Policy to use for for access to this btree.\n    **/\n    private BTreeLockingPolicy              init_btree_locking_policy;\n\n\t\n\t/**\n\tThe (open) container which contains the b-tree.\n\t**/\n\tprotected ContainerHandle container;\n\n    /**\n    The conglomerate containerid for error reporting.\n    **/\n    protected long  err_containerid;\n\n    /** The user transaction that opened this B-tree. */\n    protected TransactionManager init_open_user_scans = null;\n\n\n    protected LogicalUndo btree_undo = null;\n\n    /**\n     * scratch space used for stuff like templates, export rows, ...\n     **/\n    protected OpenConglomerateScratchSpace  runtime_mem;\n\n    /**************************************************************************\n     * Public Accessors of This class:\n     **************************************************************************\n     */\n    public final TransactionManager getXactMgr()\n    {\n        return(init_xact_manager);\n    }\n\n    public final Transaction getRawTran()\n    {\n        return(init_rawtran);\n    }\n    public final int getLockLevel()\n    {\n        return(init_lock_level);\n    }\n\n    public final ContainerHandle getContainer()\n    {\n        return(container);\n    }\n\n    public final int getOpenMode()\n    {\n        return(init_openmode);\n    }\n    \n    public final BTree getConglomerate()\n    {\n        return(init_conglomerate);\n    }\n\n    public final boolean getHold()\n    {\n        return(init_hold);\n    }\n    public final BTreeLockingPolicy getLockingPolicy()\n    {\n        return(init_btree_locking_policy);\n    }\n    public final void setLockingPolicy(BTreeLockingPolicy policy)\n    {\n        init_btree_locking_policy = policy;\n    }\n\n\n    public final boolean isClosed()\n    {\n        return(container == null);\n    }\n\n    public final OpenConglomerateScratchSpace getRuntimeMem()\n    {\n        return(runtime_mem);\n    }\n\n    /**************************************************************************\n     * Public Methods of RowCountable class:\n     **************************************************************************\n     */\n\n    /**\n     * Get the total estimated number of rows in the container.\n     * <p>\n     * The number is a rough estimate and may be grossly off.  In general\n     * the server will cache the row count and then occasionally write\n     * the count unlogged to a backing store.  If the system happens to \n     * shutdown before the store gets a chance to update the row count it\n     * may wander from reality.\n     * <p>\n     * This call is currently only supported on Heap conglomerates, it\n     * will throw an exception if called on btree conglomerates.\n     *\n\t * @return The total estimated number of rows in the conglomerate.\n     *\n\t * @exception  StandardException  Standard exception policy.\n     **/\n    public long getEstimatedRowCount()\n\t\tthrows StandardException\n    {\n        if (container == null)\n            reopen();\n\n        // Don't return 0 rows (return 1 instead), as this often leads the \n        // optimizer to produce plans which don't use indexes because of the 0 \n        // row edge case.\n        //\n        // Eventually the plan is recompiled when rows are added, but we\n        // have seen multiple customer cases of deadlocks and timeouts \n        // because of these 0 row based plans.  \n        long row_count = \n            this.container.getEstimatedRowCount(/* unused flag */ 0);\n\n        return(row_count == 0 ? 1 : row_count);\n    }\n\n    /**\n     * Set the total estimated number of rows in the container.\n     * <p>\n     * Often, after a scan, the client of RawStore has a much better estimate\n     * of the number of rows in the container than what store has.  For \n     * instance if we implement some sort of update statistics command, or\n     * just after a create index a complete scan will have been done of the\n     * table.  In this case this interface allows the client to set the\n     * estimated row count for the container, and store will use that number\n     * for all future references.\n     * <p>\n     * This call is currently only supported on Heap conglomerates, it\n     * will throw an exception if called on btree conglomerates.\n     *\n     * @param count the estimated number of rows in the container.\n     *\n\t * @exception  StandardException  Standard exception policy.\n     **/\n    public void setEstimatedRowCount(long count)\n\t\tthrows StandardException\n    {\n        if (container == null)\n            reopen();\n\n        this.container.setEstimatedRowCount(count, /* unused flag */ 0);\n    }\n\n\n    /**************************************************************************\n     * Public Methods of ConglomerateController interface:\n     **************************************************************************\n     */\n\n    /**\n     * Check consistency of a btree.\n     * <p>\n     * Read in root and check consistency of entire tree.  Currently raises\n     * sanity check errors.\n     * <p>\n     * RESOLVE (mikem) if this is to be supported in non-sanity servers what \n     * should it do?\n     *\n\t * @exception  StandardException  Standard exception policy.\n     **/\n    public void checkConsistency()\n\t\tthrows StandardException\n    {\n\t\tControlRow root = null;\n\n        try\n        {\n            if (this.container == null)\n            {\n                throw(StandardException.newException(\n                        SQLState.BTREE_IS_CLOSED, new Long(err_containerid)));\n            }\n\n            if (SanityManager.DEBUG)\n                SanityManager.ASSERT(this.init_conglomerate.format_ids != null);\n\n            root = ControlRow.get(this, BTree.ROOTPAGEID);\n\n            int actualpages = root.checkConsistency(this, null, true);\n\n            // RESOLVE (mikem) - anything useful to assert about number of pages\n            // in the tree?\n        }\n        finally\n        {\n            if (root != null)\n                root.release();\n        }\n    }\n\n    /**************************************************************************\n     * Public Methods of ScanController interface:\n     **************************************************************************\n     */\n\n    /**\n     * is the open btree table locked?\n     **/\n    public boolean isTableLocked()\n    {\n        return(init_lock_level == TransactionController.MODE_TABLE);\n    }\n\n\n\t/*\n\t** Methods of OpenBTree\n\t*/\n\n\t/**\n\tInitialize the open conglomerate.\n\n    If container is null, open the container, otherwise use the container\n    passed in.\n\n    @exception StandardException standard exception policy.\n\t**/\n    /**\n     * Initialize the open conglomerate.\n     * <p>\n     * If container is null, open the container, otherwise use the container\n     * passed in.  The container is always opened with no locking, it is up\n     * to the caller to make the appropriate container locking call.\n     * <p>\n     *\n     * @param open_user_scans The user transaction which opened this btree.\n     * @param xact_manager    The current transaction, usually the same as\n     *                        \"open_user_scans\", but in the case of split it\n     *                        is the internal xact nested below the user xact.\n     * @param input_container The open container holding the index, if it is\n     *                        already open, else null which will mean this\n     *                        routine will open it.\n     * @param rawtran         The current raw store transaction.\n     * @param open_mode       The opening mode for the ContainerHandle.\n     * @param conglomerate    Readonly description of the conglomerate.\n     * @param undo            Logical undo object to associate with all updates\n     *                        done on this open btree.\n     *\n     *\n\t * @exception  StandardException  Standard exception policy.\n     **/\n\tpublic void init(\n    TransactionManager              open_user_scans,\n    TransactionManager              xact_manager,\n    ContainerHandle                 input_container,\n    Transaction                     rawtran,\n    boolean                         hold,\n\tint                             open_mode,\n    int                             lock_level,\n    BTreeLockingPolicy              btree_locking_policy,\n    BTree                           conglomerate,\n    LogicalUndo                     undo,\n    DynamicCompiledOpenConglomInfo  dynamic_info)\n        throws StandardException\n\t{\n\t\t// If the b-tree is already open, close it.\n\t\tif (this.container != null)\n        {\n            if (SanityManager.DEBUG)\n                SanityManager.ASSERT(false, \"why is the container open?\");\n\t\t\tclose();\n        }\n        err_containerid = conglomerate.id.getContainerId();\n\n        // Locking policy to pass back to concrete implementation lock calls\n        this.init_btree_locking_policy = btree_locking_policy;\n\n\t\t// if the conglomerate is temporary, open with IS_KEPT set.\n\t\t// RESOLVE(mikem): track 1825\n\t\t// don't want to open temp cantainer with IS_KEPT always.\n\t\tif (conglomerate.isTemporary())\n\t\t\topen_mode |= ContainerHandle.MODE_TEMP_IS_KEPT;\n\n        // now open the container if it wasn't already opened by the client.\n        // No locks will be requested by raw store on this open.\n        if (input_container == null)\n        {\n            // Open the container. \n            this.container = \n                rawtran.openContainer(\n                    conglomerate.id, \n                    (LockingPolicy) null /* get no locks on btree */,\n\t\t\t\t\topen_mode);\n        }\n        else\n        {\n            // Use the open container passed in.\n            this.container = input_container;\n\n\t\t\t// RESOLVE (sku) - ContainerHandle should have an interface to\n\t\t\t// verify that it is opened with open_mode\n        }\n\n\t\tif (this.container == null)\n        {\n            throw StandardException.newException(\n                    SQLState.BTREE_CONTAINER_NOT_FOUND,\n                    new Long(err_containerid));\n        }\n\n\t\t// Remember the conglomerate so its properties can be found.\n        init_conglomerate   = conglomerate;\n\n        // Remember the transaction manager so commit() can be called\n        init_xact_manager   = xact_manager;\n\n        init_rawtran        = rawtran;\n\n        init_openmode       = open_mode;\n\n        // Isolation level of this btree.\n        init_lock_level     = lock_level;\n\n        init_hold           = hold;\n\n\n        this.init_open_user_scans = open_user_scans;\n\n        // Logical undo class to pass to raw store, on inserts/deletes.\n        this.btree_undo = undo;\n\n        // either use passed in \"compiled\" runtime scratch space, or create\n        // new space.\n        this.runtime_mem    = \n            (dynamic_info != null ? \n             ((OpenConglomerateScratchSpace) dynamic_info) : \n              (OpenConglomerateScratchSpace)\n                conglomerate.getDynamicCompiledConglomInfo());\n\n\t}\n\n    /**\n     * Open the container after it has been closed previously.\n     * <p>\n     * Open the container, obtaining necessary locks.  Most work is actually\n     * done by RawStore.openContainer().  Will only reopen() if the container\n     * is not already open.\n     *\n\t * @exception  StandardException  Standard exception policy.\n     **/\n    public ContainerHandle reopen()\n        throws StandardException\n    {\n        // reget transaction from context manager, in the case of XA\n        // transaction this may have changed.\n        //\n        /* TODO - XA transactions my change the current transaction on the \n         * context stack.  Will want to something like:\n         *\n         * init_rawtran = context_manager.getcurrenttransaction()\n         */\n\n\t\t// If the b-tree is already open, close it.\n\n        /*\n\t\tif (this.container != null)\n        {\n\t\t\tclose();\n        }\n        */\n\n        if (SanityManager.DEBUG)\n        {\n            SanityManager.ASSERT(init_xact_manager != null);\n            SanityManager.ASSERT(init_xact_manager.getRawStoreXact() != null);\n            SanityManager.ASSERT(init_conglomerate != null);\n        }\n     \n        if (container == null)\n        {\n            // Open the container. \n            this.container = \n                init_xact_manager.getRawStoreXact().openContainer(\n                    init_conglomerate.id, \n                    (LockingPolicy) null /* get no locks on btree */,\n                    init_openmode);\n        }\n\n        return(this.container);\n    }\n\n    /**\n    Close the open conglomerate.\n    **/\n    public void close()\n        throws StandardException\n\t{\n\t\tif (container != null)\n\t\t\tcontainer.close();\n\t\tcontainer = null;\n\t}\n\n    /**\n    Check if all the \n    columns are Indexable and Storable.  Eventually this routine could\n    check whether all the types were right also.\n\n    @exception StandardException Standard Exception Policy.\n    **/\n    void isIndexableRowConsistent(DataValueDescriptor[] row)\n        throws StandardException\n    {\n        if (SanityManager.DEBUG)\n        {\n            DataValueDescriptor[] template = \n                this.init_conglomerate.createTemplate(getRawTran());\n\n            for (int i = 0; i < row.length; i++)\n            {\n                // Compare class's rather than format id's to pick up \n                // different problems with wrong collation implementation.\n\t\t\t\tif (!row[i].getClass().equals(template[i].getClass()))\n                {\n                    SanityManager.THROWASSERT(\n                        \"type of inserted column[\" + i + \"] = \" + \n                        row[i].getClass().getName()                +\n                        \"type of template column[\" + i + \"] = \" +\n                        template[i].getClass().getName());\n                }\n            }\n        }\n    }\n\n    /**\n     * Return the container handle.\n     * <p>\n\t * @return The open container handle of the btree.\n     **/\n    public ContainerHandle getContainerHandle()\n    {\n        return(container);\n    }\n\t\n\t/**\n     * get height of the tree.\n     * <p>\n     * Read in root and return the height (number of levels) of the tree.\n     * The level of a tree is 0 in the leaf and increases by 1 for each\n     * level of the tree as you go up the tree.  \n     *\n\t * @exception  StandardException  Standard exception policy.\n     **/\n    public int getHeight()\n\t\tthrows StandardException\n    {\n\t\t// container.checkConsistency();\n\n\t\tControlRow root = null;\n\n        try\n        {\n            root = ControlRow.get(this, BTree.ROOTPAGEID);\n\n            int height = root.getLevel() + 1;\n\n            return(height);\n        }\n        finally\n        {\n            if (root != null)\n                root.release();\n        }\n    }\n\n    /**\n     * Dump information about tree into the log.\n     * <p>\n     * Traverse the tree dumping info about tree into the log.\n     *\n\t * @exception  StandardException  Standard exception policy.\n     **/\n    public void debugConglomerate()\n\t\tthrows StandardException\n    {\n\t\t// container.checkConsistency();\n\n\t\tControlRow root = null;\n\n        try\n        {\n            if (SanityManager.DEBUG)\n            {\n                SanityManager.DEBUG_PRINT(\n                    \"p_tree\", \"BTREE Dump: containerId \" + container.getId());\n                SanityManager.DEBUG_PRINT(\n                    \"p_tree\", \"BTREE Dump: btree \" + this.init_conglomerate);\n            }\n\n            root = ControlRow.get(this, BTree.ROOTPAGEID);\n            root.printTree(this);\n        }\n        finally\n        {\n            if (root != null)\n                root.release();\n        }\n    }\n\n    /**\n     * Testing infrastructure to cause unusual paths through the code.\n     * <p>\n     * Through the use of debug flags allow test code to cause otherwise\n     * hard to cause paths through the code.  \n     * <p>\n     *\n     * @param pos the current scan position if the condition simulated by\n     * this call would have resulted in the position being saved\n\t * @return whether the latch has been released by this routine.\n     *\n\t * @exception  StandardException  Standard exception policy.\n     **/\n    public static boolean test_errors(\n    OpenBTree           open_btree,\n    String              debug_string,\n    BTreeRowPosition    pos,\n    BTreeLockingPolicy  btree_locking_policy,\n    LeafControlRow      leaf,\n    boolean             input_latch_released)\n        throws StandardException\n    {\n        boolean latch_released = input_latch_released;\n\n        // special test to see if latch release code works\n        if (SanityManager.DEBUG)\n        {\n            String debug_lost_latch = debug_string + \"1\";\n\n            if (SanityManager.DEBUG_ON(debug_lost_latch))\n            {\n                // Simulate a lost latch because of a wait for a lock.\n                if (!latch_released)\n                {\n                    if (pos != null) {\n                        SanityManager.ASSERT(pos.current_leaf == leaf);\n                        pos.saveMeAndReleasePage();\n                    } else {\n                        leaf.release();\n                    }\n\n                    latch_released = true;\n                    SanityManager.DEBUG_PRINT(\n                        debug_lost_latch, debug_lost_latch);\n                    SanityManager.DEBUG_CLEAR(debug_lost_latch);\n                }\n            }\n\n            String debug_deadlock = debug_string + \"2\";\n\n            if (SanityManager.DEBUG_ON(debug_deadlock))\n            {\n                SanityManager.DEBUG_PRINT(debug_deadlock, debug_deadlock);\n                SanityManager.DEBUG_CLEAR(debug_deadlock);\n\n                // Simulate a deadlock error.\n                StandardException se = \n                    StandardException.newException(\n                        SQLState.DEADLOCK, \"fake deadlock\", \"fake victim\");\n\n\t\t\t\tse.setReport(StandardException.REPORT_ALWAYS);\n\t\t\t\tthrow se;\n            }\n        }\n\n        return(latch_released);\n    }\n\n    public SpaceInfo getSpaceInfo()\n        throws StandardException\n    {\n        return container.getSpaceInfo();\n    }\n\n\t// return column Sort order information\n\tpublic boolean[] getColumnSortOrderInfo()\n\t\tthrows\tStandardException\n\t{\n\t\treturn init_conglomerate.ascDescInfo;\n\t}\n\n\t/**\n\t * Lock a row as part of doing the scan.\n\t * <p>\n\t * Lock the row at the given slot (or the previous row if slot is 0).\n\t * <p>\n\t * If this routine returns true all locks were acquired while maintaining\n\t * the latch on leaf.  If this routine returns false, locks may or may\n\t * not have been acquired, and the routine should be called again after\n\t * the client has researched the tree to reget the latch on the \n\t * appropriate page.\n\t *\n\t * @param b2iRowLocking1 TODO\n\t * @param btree             the conglomerate info.\n\t * @param pos               The position of the row to lock.\n\t * @param lock_fetch_desc TODO\n\t * @param lock_template     A scratch area to use to read in rows.\n\t * @param lock_row_loc TODO\n\t * @param previous_key_lock Is this a previous key lock call?\n\t * @param forUpdate         Is the scan for update or for read only.\n\t * @param lock_operation TODO\n\t * @return Whether locks were acquired without releasing latch on leaf.\n\t *\n\t * @exception  StandardException  Standard exception policy.\n\t **/\n\tpublic boolean lockScanRow(\n\tB2IRowLocking1 b2iRowLocking1, BTree btree, BTreeRowPosition pos, FetchDescriptor lock_fetch_desc, DataValueDescriptor[] lock_template, RowLocation lock_row_loc, boolean previous_key_lock, boolean forUpdate, int lock_operation)\n\t\tthrows StandardException\n\t{\n\t    // only get the row lock if it is not a previous key lock and iff\n\t    // it is an update lock.\n\t    return(\n\t        b2iRowLocking1._lockScanRow(\n\t             this,\n\t             btree,\n\t             pos,\n\t             (forUpdate && !previous_key_lock), // only get update row lock\n\t             lock_fetch_desc, lock_template, lock_row_loc,\n\t             previous_key_lock,\n\t             forUpdate,\n\t             lock_operation));\n\t}\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 3,
                "candidates": [
                    {
                        "lineStart": 249,
                        "lineEnd": 288,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.apache.derby.impl.store.access.btree.BTree\nRationale: The checkConsistency() method is directly related to the structure and integrity of the B-tree, making it most appropriate to reside within the BTree class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 532,
                        "lineEnd": 561,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.apache.derby.impl.store.access.btree.BTree\nRationale: The getHeight() method is directly related to the structure and properties of a B-tree, specifically calculating the height based on the root node. It logically belongs in the BTree class, which manages the tree structure.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 181,
                        "lineEnd": 214,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.apache.derby.iapi.store.raw.ContainerHandle\nRationale: The method getEstimatedRowCount() is directly related to the management and estimation of rows within a container, making ContainerHandle the most appropriate class for this method.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 17448
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_method_names": [
                        "getEstimatedRowCount",
                        "setEstimatedRowCount",
                        "checkConsistency",
                        "getHeight",
                        "debugConglomerate",
                        "lockScanRow"
                    ],
                    "llm_response_time": 6237
                },
                {
                    "iteration_num": 2,
                    "suggested_method_names": [
                        "getEstimatedRowCount",
                        "setEstimatedRowCount",
                        "checkConsistency",
                        "getHeight",
                        "debugConglomerate",
                        "lockScanRow"
                    ],
                    "llm_response_time": 5069
                },
                {
                    "iteration_num": 3,
                    "suggested_method_names": [
                        "getEstimatedRowCount",
                        "setEstimatedRowCount",
                        "checkConsistency",
                        "getHeight",
                        "debugConglomerate",
                        "lockScanRow"
                    ],
                    "llm_response_time": 5151
                },
                {
                    "iteration_num": -1,
                    "suggested_method_names": [
                        "getEstimatedRowCount",
                        "setEstimatedRowCount",
                        "checkConsistency",
                        "getHeight",
                        "debugConglomerate",
                        "lockScanRow"
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "checkConsistency",
                    "getHeight",
                    "getEstimatedRowCount",
                    "setEstimatedRowCount",
                    "debugConglomerate",
                    "lockScanRow"
                ],
                "llm_response_time": 867
            },
            "targetClassMap": {
                "checkConsistency": {
                    "target_classes": [
                        {
                            "class_name": "BTree",
                            "similarity_score": 0.6389303199066336
                        },
                        {
                            "class_name": "TransactionManager",
                            "similarity_score": 0.6011158281403202
                        },
                        {
                            "class_name": "Transaction",
                            "similarity_score": 0.41819053928839856
                        },
                        {
                            "class_name": "BTreeLockingPolicy",
                            "similarity_score": 0.516751068042523
                        },
                        {
                            "class_name": "ContainerHandle",
                            "similarity_score": 0.3382714662104009
                        },
                        {
                            "class_name": "TransactionManager",
                            "similarity_score": 0.6011158281403202
                        },
                        {
                            "class_name": "LogicalUndo",
                            "similarity_score": 0.19410766494455656
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BTree",
                        "ContainerHandle",
                        "TransactionManager",
                        "TransactionManager",
                        "BTreeLockingPolicy",
                        "Transaction",
                        "LogicalUndo"
                    ],
                    "llm_response_time": 1560,
                    "similarity_computation_time": 14,
                    "similarity_metric": "cosine"
                },
                "getHeight": {
                    "target_classes": [
                        {
                            "class_name": "BTree",
                            "similarity_score": 0.7491076386797721
                        },
                        {
                            "class_name": "TransactionManager",
                            "similarity_score": 0.6180579499830451
                        },
                        {
                            "class_name": "Transaction",
                            "similarity_score": 0.5769686246128918
                        },
                        {
                            "class_name": "BTreeLockingPolicy",
                            "similarity_score": 0.6424776531260166
                        },
                        {
                            "class_name": "ContainerHandle",
                            "similarity_score": 0.509807097858621
                        },
                        {
                            "class_name": "TransactionManager",
                            "similarity_score": 0.6180579499830451
                        },
                        {
                            "class_name": "LogicalUndo",
                            "similarity_score": 0.44079106725227596
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "BTree",
                        "ContainerHandle",
                        "BTreeLockingPolicy",
                        "TransactionManager",
                        "TransactionManager",
                        "Transaction",
                        "LogicalUndo"
                    ],
                    "llm_response_time": 1716,
                    "similarity_computation_time": 9,
                    "similarity_metric": "cosine"
                },
                "getEstimatedRowCount": {
                    "target_classes": [
                        {
                            "class_name": "BTree",
                            "similarity_score": 0.7680002372833518
                        },
                        {
                            "class_name": "TransactionManager",
                            "similarity_score": 0.7284215346819861
                        },
                        {
                            "class_name": "Transaction",
                            "similarity_score": 0.6834622029126461
                        },
                        {
                            "class_name": "BTreeLockingPolicy",
                            "similarity_score": 0.7734319796916482
                        },
                        {
                            "class_name": "ContainerHandle",
                            "similarity_score": 0.6137524339326025
                        },
                        {
                            "class_name": "TransactionManager",
                            "similarity_score": 0.7284215346819861
                        },
                        {
                            "class_name": "LogicalUndo",
                            "similarity_score": 0.5592849443319985
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ContainerHandle",
                        "BTree",
                        "TransactionManager",
                        "TransactionManager",
                        "Transaction",
                        "BTreeLockingPolicy",
                        "LogicalUndo"
                    ],
                    "llm_response_time": 2793,
                    "similarity_computation_time": 9,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.apache.derby.iapi.sql.dictionary.IndexRowGenerator::setConglomerateNumber(long):void need move to org.apache.derby.impl.sql.catalog.IndexInfoImpl",
        "class_name": "org.apache.derby.iapi.sql.dictionary.IndexRowGenerator",
        "telemetry": {
            "id": "e9f54da8-e97c-4fce-8a5f-310ac9c10d34",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 412,
                "lineStart": 45,
                "lineEnd": 456,
                "bodyLineStart": 45,
                "language": "java",
                "sourceCode": "/**\n * This class extends IndexDescriptor for internal use by the\n * DataDictionary.\n */\npublic class IndexRowGenerator implements IndexDescriptor, Formatable\n{\n\tprivate IndexDescriptor\tid;\n\tprivate ExecutionFactory ef;\n\n\t/**\n\t * Constructor for an IndexRowGeneratorImpl\n\t *\n\t * @param indexType\t\tThe type of index\n\t * @param isUnique\t\tTrue means the index is unique\n\t * @param baseColumnPositions\tAn array of column positions in the base\n\t *\t\t\t\t\t\t\t\ttable.  Each index column corresponds to a\n\t *\t\t\t\t\t\t\t\tcolumn position in the base table.\n\t * @param isAscending\tAn array of booleans telling asc/desc on each\n\t *\t\t\t\t\t\tcolumn.\n\t * @param numberOfOrderedColumns\tIn the future, it will be possible\n\t *\t\t\t\t\t\t\t\t\tto store non-ordered columns in an\n\t *\t\t\t\t\t\t\t\t\tindex.  These will be useful for\n\t *\t\t\t\t\t\t\t\t\tcovered queries.\n\t */\n\tpublic IndexRowGenerator(String indexType,\n\t\t\t\t\t\t\t\tboolean isUnique,\n\t\t\t\t\t\t\t\tint[] baseColumnPositions,\n\t\t\t\t\t\t\t\tboolean[] isAscending,\n\t\t\t\t\t\t\t\tint numberOfOrderedColumns)\n\t{\n\t\tid = new IndexDescriptorImpl(\n                        indexType,\n                        isUnique, //default uniqueWithDuplicateNulls to false\n                        false,\n                        baseColumnPositions,\n                        isAscending,\n                        numberOfOrderedColumns);\n\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(baseColumnPositions != null,\n\t\t\t\t\"baseColumnPositions are null\");\n\t\t}\n\t}\n        \n    /**\n     * Constructor for an IndexRowGeneratorImpl\n     * \n     * @param indexType\t\tThe type of index\n     * @param isUnique\t\tTrue means the index is unique\n     * @param isUniqueWithDuplicateNulls means the index is almost unique\n     *                              i.e. unique only for non null keys\n     * @param baseColumnPositions\tAn array of column positions in the base\n     * \t\t\t\t\t\t\t\ttable.  Each index column corresponds to a\n     * \t\t\t\t\t\t\t\tcolumn position in the base table.\n     * @param isAscending\tAn array of booleans telling asc/desc on each\n     * \t\t\t\t\t\tcolumn.\n     * @param numberOfOrderedColumns\tIn the future, it will be possible\n     * \t\t\t\t\t\t\t\t\tto store non-ordered columns in an\n     * \t\t\t\t\t\t\t\t\tindex.  These will be useful for\n     * \t\t\t\t\t\t\t\t\tcovered queries.\n     */\n\tpublic IndexRowGenerator(String indexType,\n\t\t\t\t\t\t\t\tboolean isUnique,\n\t\t\t\t\t\t\t\tboolean isUniqueWithDuplicateNulls,\n\t\t\t\t\t\t\t\tint[] baseColumnPositions,\n\t\t\t\t\t\t\t\tboolean[] isAscending,\n\t\t\t\t\t\t\t\tint numberOfOrderedColumns)\n\t{\n\t\tid = new IndexDescriptorImpl(indexType,\n\t\t\t\t\t\t\t\t\tisUnique,\n\t\t\t\t\t\t\t\t\tisUniqueWithDuplicateNulls,\n\t\t\t\t\t\t\t\t\tbaseColumnPositions,\n\t\t\t\t\t\t\t\t\tisAscending,\n\t\t\t\t\t\t\t\t\tnumberOfOrderedColumns);\n\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(baseColumnPositions != null,\n\t\t\t\t\"baseColumnPositions are null\");\n\t\t}\n\t}\n\n\t/**\n\t * Constructor for an IndexRowGeneratorImpl\n\t *\n\t * @param indexDescriptor\t\tAn IndexDescriptor to delegate calls to\n\t */\n\tpublic IndexRowGenerator(IndexDescriptor indexDescriptor)\n\t{\n\t\tid = indexDescriptor;\n\t}\n\n\t/**\n\t * Get a template for the index row, to be used with getIndexRow.\n\t *\n\t * @return\tA row template for the index row.\n\t */\n\tpublic ExecIndexRow getIndexRowTemplate()\n\t{\n\t\treturn getExecutionFactory().getIndexableRow(\n\t\t\t\t\t\t\t\t\t\tid.baseColumnPositions().length + 1);\n\t}\n\n    /**\n     * Get a NULL Index Row for this index. This is useful to create objects\n     * that need to be passed to ScanController.\n     *\n     * @param columnList ColumnDescriptors describing the base table.\n     * @param rowLocation   empty row location.\n     *\n     * @exception StandardException thrown on error.\n     */\n    public ExecIndexRow getNullIndexRow(ColumnDescriptorList columnList,\n    \t\tRowLocation rowLocation)\n    throws StandardException\n    {\n            int[] baseColumnPositions = id.baseColumnPositions();\n            ExecIndexRow indexRow = getIndexRowTemplate();\n\n            for (int i = 0; i < baseColumnPositions.length; i++)\n            {\n                    DataTypeDescriptor dtd =\n                            columnList.elementAt(baseColumnPositions[i] - 1).getType();\n                    indexRow.setColumn(i + 1, dtd.getNull());\n            }\n\n            indexRow.setColumn(baseColumnPositions.length + 1, rowLocation);\n            return indexRow;\n    }\n\n\t/**\n\t * Get an index row for this index given a row from the base table\n\t * and the RowLocation of the base row.  This method can be used\n\t * to get the new index row for inserts, and the old and new index\n\t * rows for deletes and updates.  For updates, the result row has\n\t * all the old column values followed by all of the new column values,\n\t * so you must form a row using the new column values to pass to\n\t * this method to get the new index row.\n\t *\n\t * @param baseRow\tA row in the base table\n\t * @param rowLocation\tThe RowLocation of the row in the base table\n\t * @param indexRow\tA template for the index row.  It must have the\n\t *\t\t\t\t\tcorrect number of columns.\n\t * @param bitSet\tIf non-null, then baseRow is a partial row and the\n\t *\t\t\t\t\tset bits in bitSet represents the column mapping for\n\t *\t\t\t\t\tthe partial row to the complete base row. <B> WARNING:\n\t *\t\t\t\t\t</B> ONE based!!!\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\tpublic void getIndexRow(ExecRow baseRow,\n\t\t\t\t\t\t\tRowLocation rowLocation,\n\t\t\t\t\t\t\tExecIndexRow indexRow,\n\t\t\t\t\t\t\tFormatableBitSet bitSet)\n\t\t\t\t\t\tthrows StandardException\n\t{\n\t\t/*\n\t\t** Set the columns in the index row that are based on columns in\n\t\t** the base row.\n\t\t*/\n\t\tint[] baseColumnPositions = id.baseColumnPositions();\n\t\tint colCount = baseColumnPositions.length;\n\n\t\tif (bitSet == null)\n\t\t{\n\t\t\t/*\n\t\t\t** Set the columns in the index row that are based on columns in\n\t\t\t** the base row.\n\t\t\t*/\n\t\t\tfor (int i = 0; i < colCount ; i++)\n\t\t\t{\n\t\t\t\tindexRow.setColumn(i + 1,\n\t\t\t\t\t\tbaseRow.getColumn(baseColumnPositions[i]));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (SanityManager.DEBUG)\n\t\t\t{\n\t\t\t\tSanityManager.ASSERT(!bitSet.get(0), \"element zero of the bitSet passed into getIndexRow() is not false, bitSet should be 1 based\");\n\t\t\t}\n \n\t\t\t/*\n\t\t\t** Set the columns in the index row that are based on columns in\n\t\t\t** the base row.\n\t\t\t*/\n\t\t\tfor (int i = 0; i < colCount; i++)\n\t\t\t{\n\t\t\t\tint fullColumnNumber = baseColumnPositions[i];\n\t\t\t\tint partialColumnNumber = 0;\n\t\t\t\tfor (int index = 1; index <= fullColumnNumber; index++)\n\t\t\t\t{\n\t\t\t\t\tif (bitSet.get(index))\n\t\t\t\t\t{\n\t\t\t\t\t\tpartialColumnNumber++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindexRow.setColumn(i + 1,\n\t\t\t\t\t\t\tbaseRow.getColumn(partialColumnNumber));\n\t\t\t}\n\t\t}\n\n\t\t/* Set the row location in the last column of the index row */\n\t\tindexRow.setColumn(colCount + 1, rowLocation);\n\t}\n\n    /**\n     * Return an array of collation ids for this table.\n     * <p>\n     * Return an array of collation ids, one for each column in the\n     * columnDescriptorList.  This is useful for passing collation id info\n     * down to store, for instance in createConglomerate() to create\n     * the index.\n     *\n     * This is only expected to get called during ddl, so object allocation\n     * is ok. \n     *\n\t * @param columnList ColumnDescriptors describing the base table.\n     *\n\t * @exception  StandardException  Standard exception policy.\n     **/\n    public int[] getColumnCollationIds(ColumnDescriptorList columnList)\n\t\tthrows StandardException\n    {\n        int[] base_cols     = id.baseColumnPositions();\n        int[] collation_ids = new int[base_cols.length + 1];\n\n\t\tfor (int i = 0; i < base_cols.length; i++)\n\t\t{\n            collation_ids[i] =\n\t\t\t\tcolumnList.elementAt(\n                    base_cols[i] - 1).getType().getCollationType();\n\t\t}\n\n        // row location column at end is always basic collation type.\n        collation_ids[collation_ids.length - 1] = \n            StringDataValue.COLLATION_TYPE_UCS_BASIC; \n\n\t\treturn(collation_ids);\n    }\n\n\t\t \n\t/**\n\t * Get the IndexDescriptor that this IndexRowGenerator is based on.\n\t */\n\tpublic IndexDescriptor getIndexDescriptor()\n\t{\n\t\treturn id;\n\t}\n\n\t/** Zero-argument constructor for Formatable interface */\n\tpublic IndexRowGenerator()\n\t{\n\t}\n\n\t/**\n     * @see IndexDescriptor#isUniqueWithDuplicateNulls\n     */\n\tpublic boolean isUniqueWithDuplicateNulls()\n\t{\n\t\treturn id.isUniqueWithDuplicateNulls();\n\t}\n\t/** @see IndexDescriptor#isUnique */\n\tpublic boolean isUnique()\n\t{\n\t\treturn id.isUnique();\n\t}\n\n\t/** @see IndexDescriptor#baseColumnPositions */\n\tpublic int[] baseColumnPositions()\n\t{\n\t\treturn id.baseColumnPositions();\n\t}\n\n\t/** @see IndexDescriptor#getKeyColumnPosition */\n\tpublic int getKeyColumnPosition(int heapColumnPosition)\n\t{\n\t\treturn id.getKeyColumnPosition(heapColumnPosition);\n\t}\n\n\t/** @see IndexDescriptor#numberOfOrderedColumns */\n\tpublic int numberOfOrderedColumns()\n\t{\n\t\treturn id.numberOfOrderedColumns();\n\t}\n\n\t/** @see IndexDescriptor#indexType */\n\tpublic String indexType()\n\t{\n\t\treturn id.indexType();\n\t}\n\n\tpublic String toString()\n\t{\n\t\treturn id.toString();\n\t}\n\n\t/** @see IndexDescriptor#isAscending */\n\tpublic boolean\t\t\tisAscending(Integer keyColumnPosition)\n\t{\n\t\treturn id.isAscending(keyColumnPosition);\n\t}\n\n\t/** @see IndexDescriptor#isDescending */\n\tpublic boolean\t\t\tisDescending(Integer keyColumnPosition)\n\t{\n\t\treturn id.isDescending(keyColumnPosition);\n\t}\n\n\t/** @see IndexDescriptor#isAscending */\n\tpublic boolean[]\t\tisAscending()\n\t{\n\t\treturn id.isAscending();\n\t}\n\n\t/** @see IndexDescriptor#setBaseColumnPositions */\n\tpublic void\t\tsetBaseColumnPositions(int[] baseColumnPositions)\n\t{\n\t\tid.setBaseColumnPositions(baseColumnPositions);\n\t}\n\n\t/** @see IndexDescriptor#setIsAscending */\n\tpublic void\t\tsetIsAscending(boolean[] isAscending)\n\t{\n\t\tid.setIsAscending(isAscending);\n\t}\n\n\t/** @see IndexDescriptor#setNumberOfOrderedColumns */\n\tpublic void\t\tsetNumberOfOrderedColumns(int numberOfOrderedColumns)\n\t{\n\t\tid.setNumberOfOrderedColumns(numberOfOrderedColumns);\n\t}\n\n\t/**\n\t * Test for value equality\n\t *\n\t * @param other\t\tThe other indexrowgenerator to compare this one with\n\t *\n\t * @return\ttrue if this indexrowgenerator has the same value as other\n\t */\n\n\tpublic boolean equals(Object other)\n\t{\n\t\treturn id.equals(other);\n\t}\n\n\t/**\n\t  @see java.lang.Object#hashCode\n\t  */\n\tpublic int hashCode()\n\t{\n\t\treturn id.hashCode();\n\t}\n\n\tprivate ExecutionFactory getExecutionFactory()\n\t{\n\t\tif (ef == null)\n\t\t{\n\t\t\tExecutionContext\tec;\n\n\t\t\tec = (ExecutionContext)\n\t\t\t\t\tContextService.getContext(ExecutionContext.CONTEXT_ID);\n\t\t\tef = ec.getExecutionFactory();\n\t\t}\n\t\treturn ef;\n\t}\n\n\t////////////////////////////////////////////////////////////////////////////\n\t//\n\t// EXTERNALIZABLE\n\t//\n\t////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * @see java.io.Externalizable#readExternal\n\t *\n\t * @exception IOException\tThrown on read error\n\t * @exception ClassNotFoundException\tThrown on read error\n\t */\n\tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException\n\t{\n\t\tid = (IndexDescriptor)in.readObject();\n\t}\n\n\t/**\n\t *\n\t * @exception IOException\tThrown on write error\n\t */\n\tpublic void writeExternal(ObjectOutput out) throws IOException\n\t{\n\t\tout.writeObject(id);\n\t}\n\n\t/* TypedFormat interface */\n\tpublic int getTypeFormatId()\n\t{\n\t\treturn StoredFormatIds.INDEX_ROW_GENERATOR_V01_ID;\n\t}\n\n\t/**\n\t * Set the conglomerate number for the index.\n\t *\n\t * @param indexInfoImpl TODO\n\t * @param conglomerateNumber\tThe conglomerateNumber for the index.\n\t */\n\tpublic void setConglomerateNumber(IndexInfoImpl indexInfoImpl, long conglomerateNumber)\n\t{\n\t\tindexInfoImpl.conglomerateNumber = conglomerateNumber;\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 2,
                "candidates": [
                    {
                        "lineStart": 399,
                        "lineEnd": 410,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.apache.derby.iapi.sql.execute.ExecutionFactory\nRationale: The method getExecutionFactory() is responsible for retrieving an instance of ExecutionFactory, which indicates that it is closely related to the functionality of the ExecutionFactory class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 444,
                        "lineEnd": 453,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.apache.derby.impl.sql.catalog.IndexInfoImpl\nRationale: The method directly modifies the 'conglomerateNumber' property of the IndexInfoImpl instance, indicating that it is closely related to the state and behavior of the IndexInfoImpl class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 7536
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_method_names": [
                        "getExecutionFactory",
                        "setConglomerateNumber"
                    ],
                    "llm_response_time": 2349
                },
                {
                    "iteration_num": 2,
                    "suggested_method_names": [
                        "getExecutionFactory",
                        "setConglomerateNumber"
                    ],
                    "llm_response_time": 2540
                },
                {
                    "iteration_num": 3,
                    "suggested_method_names": [
                        "setConglomerateNumber",
                        "getExecutionFactory"
                    ],
                    "llm_response_time": 1971
                },
                {
                    "iteration_num": -1,
                    "suggested_method_names": [
                        "getExecutionFactory",
                        "setConglomerateNumber"
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "getExecutionFactory",
                    "setConglomerateNumber"
                ],
                "llm_response_time": 601
            },
            "targetClassMap": {
                "getExecutionFactory": {
                    "target_classes": [
                        {
                            "class_name": "IndexDescriptor",
                            "similarity_score": 0.023755052166878232
                        },
                        {
                            "class_name": "ExecutionFactory",
                            "similarity_score": 0.025856776851497038
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ExecutionFactory",
                        "IndexDescriptor"
                    ],
                    "llm_response_time": 1117,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                },
                "setConglomerateNumber": {
                    "target_classes": [
                        {
                            "class_name": "IndexInfoImpl",
                            "similarity_score": 0.7914169227312173
                        },
                        {
                            "class_name": "IndexDescriptor",
                            "similarity_score": 0.6625082005462068
                        },
                        {
                            "class_name": "ExecutionFactory",
                            "similarity_score": 0.6974373043173009
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "IndexInfoImpl",
                        "IndexDescriptor",
                        "ExecutionFactory"
                    ],
                    "llm_response_time": 2995,
                    "similarity_computation_time": 2,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.apache.derby.jdbc.ClientConnectionPoolDataSource40::getParentLogger():Logger need move to org.apache.derbyTesting.functionTests.tests.jdbc4.Wrapper41DataSource",
        "class_name": "org.apache.derby.jdbc.ClientConnectionPoolDataSource40",
        "telemetry": {
            "id": "dbd10ded-af25-4b92-8f2c-4916b96f178f",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 77,
                "lineStart": 35,
                "lineEnd": 111,
                "bodyLineStart": 35,
                "language": "java",
                "sourceCode": "/**\n * ClientConnectionPoolDataSource40 is a factory for PooledConnection objects.\n * An object that implements this interface\n * will typically be registered with a naming service that is based on the\n * Java Naming and Directory Interface (JNDI). Use this factory\n * if your application runs under JDBC4.0.\n * Use\n * ClientConnectionPoolDataSource, instead, if your application runs under\n * JDBC3.0 or JDBC2.0, that is, on the following Java Virtual Machines:\n * <p/>\n * <UL>\n * <LI> JDBC 3.0 - Java 2 - JDK 1.4, J2SE 5.0\n * <LI> JDBC 2.0 - Java 2 - JDK 1.2,1.3\n * </UL>\n */\npublic class ClientConnectionPoolDataSource40\n        extends ClientConnectionPoolDataSource {\n    /**\n     * Returns false unless <code>interfaces</code> is implemented \n     * \n     * @param  interfaces             a Class defining an interface.\n     * @return true                   if this implements the interface or \n     *                                directly or indirectly wraps an object \n     *                                that does.\n     * @throws java.sql.SQLException  if an error occurs while determining \n     *                                whether this is a wrapper for an object \n     *                                with the given interface.\n     */\n    public boolean isWrapperFor(Class<?> interfaces) throws SQLException {\n        return interfaces.isInstance(this);\n    }\n    \n    /**\n     * Returns <code>this</code> if this class implements the interface\n     *\n     * @param  interfaces a Class defining an interface\n     * @return an object that implements the interface\n     * @throws java.sql.SQLExption if no object if found that implements the \n     * interface\n     */\n    public <T> T unwrap(java.lang.Class<T> interfaces)\n                                   throws SQLException {\n        try { \n            return interfaces.cast(this);\n        } catch (ClassCastException cce) {\n            throw new SqlException(null,new ClientMessageId(\n                    SQLState.UNABLE_TO_UNWRAP), interfaces).getSQLException();\n        }\n    }    \n\n    ////////////////////////////////////////////////////////////////////\n    //\n    // INTRODUCED BY JDBC 4.1 IN JAVA 7\n    //\n    ////////////////////////////////////////////////////////////////////\n\n    public  Logger getParentLogger()\n        throws SQLFeatureNotSupportedException\n    {\n        throw (SQLFeatureNotSupportedException)\n            (\n             new SqlException( null, new ClientMessageId(SQLState.NOT_IMPLEMENTED), \"getParentLogger\" )\n             ).getSQLException();\n    }\n\n\tpublic  Logger    getParentLogger(Wrapper41DataSource wrapper41DataSource) throws SQLException\n\t{\n\t    if ( wrapper41DataSource._embedded != null ) { return wrapper41DataSource._embedded.getParentLogger(); }\n\t    else if ( wrapper41DataSource._netclient != null ) { return wrapper41DataSource._netclient.getParentLogger(); }\n\t    else if ( wrapper41DataSource._ecpds != null ) { return wrapper41DataSource._ecpds.getParentLogger(); }\n\t    else if ( wrapper41DataSource._exads != null ) { return wrapper41DataSource._exads.getParentLogger(); }\n\t    else if ( this != null ) { return getParentLogger(); }\n\t    else if ( wrapper41DataSource._cxads != null ) { return wrapper41DataSource._cxads.getParentLogger(); }\n\t    else { throw wrapper41DataSource.nothingWrapped(); }\n\t}\n    \n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 99,
                        "lineEnd": 108,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.apache.derbyTesting.functionTests.tests.jdbc4.Wrapper41DataSource\nRationale: The method getParentLogger() directly operates on the properties of the Wrapper41DataSource class, checking its various fields to determine which logger to return. It is logical for this method to reside within the Wrapper41DataSource class as it encapsulates the behavior related to its internal state.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 5230
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_method_names": [
                        "getParentLogger",
                        "getParentLogger"
                    ],
                    "llm_response_time": 1737
                },
                {
                    "iteration_num": 2,
                    "suggested_method_names": [
                        "getParentLogger"
                    ],
                    "llm_response_time": 1303
                },
                {
                    "iteration_num": 3,
                    "suggested_method_names": [
                        "getParentLogger",
                        "getParentLogger"
                    ],
                    "llm_response_time": 1555
                },
                {
                    "iteration_num": -1,
                    "suggested_method_names": [
                        "getParentLogger"
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "getParentLogger"
                ],
                "llm_response_time": 508
            },
            "targetClassMap": {
                "getParentLogger": {
                    "target_classes": [
                        {
                            "class_name": "Wrapper41DataSource",
                            "similarity_score": 0.77138921583987
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "Wrapper41DataSource"
                    ],
                    "llm_response_time": 966,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "- method org.apache.derby.client.net.NetPackageReply::resetAgent_(org.apache.derby.client.am.LogWriter, int, String, int):void need move to org.apache.derby.client.net.NetAgent",
        "class_name": "org.apache.derby.client.net.NetPackageReply",
        "telemetry": {
            "id": "934bc8af-a18c-4037-be7c-99e8fa9419f9",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 209,
                "lineStart": 30,
                "lineEnd": 238,
                "bodyLineStart": 30,
                "language": "java",
                "sourceCode": "public class NetPackageReply extends NetConnectionReply {\n    NetPackageReply(NetAgent netAgent, int bufferSize) {\n        super(netAgent, bufferSize);\n    }\n\n\n    NetSqlca parseSqlErrorCondition() throws DisconnectException {\n        parseSQLERRRM();\n        parseTypdefsOrMgrlvlovrs();\n        NetSqlca netSqlca = parseSQLCARD(null);\n        return netSqlca;\n    }\n\n\n    // Also called by NetStatementReply\n    void parseDTAMCHRM() throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n\n        parseLengthAndMatchCodePoint(CodePoint.DTAMCHRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_ERROR);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived, rdbnamReceived);\n\n        netAgent_.setSvrcod(svrcod);\n        doDtamchrmSemantics();\n    }\n\n    // RDB Update Reply Message indicates that a DDM command resulted\n    // in an update at the target relational database.  If a command\n    // generated multiple reply messages including an RDBUPDRM, then\n    // the RDBUPDRM must be the first reply message for the command.\n    // For each target server, the RDBUPDRM  must be returned the first\n    // time an update is made to the target RDB within a unit of work.\n    // The target server may optionally return the RDBUPDRM after subsequent\n    // updates within the UOW.  If multiple target RDBs are involved with\n    // the current UOW and updates are made with any of them, then the RDBUPDRM\n    // must be returned in response to the first update at each of them.\n    protected void parseRDBUPDRM() throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n\n        parseLengthAndMatchCodePoint(CodePoint.RDBUPDRM);\n        pushLengthOnCollectionStack();\n\n        // in XA Global transaction we need to know if we have a read-only\n        //  transaction, if we get a RDBUPDRM this is NOT a read-only transaction\n        //  currently only XAConnections care about read-only transactions, if\n        //  non-XA wants this information they will need to initialize the flag\n        //  at start of UOW\n        netAgent_.netConnection_.setReadOnlyTransactionFlag(false);\n\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_INFO, CodePoint.SVRCOD_INFO);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived, rdbnamReceived);\n\n        // call an event to indicate the server has been updated\n        netAgent_.setSvrcod(svrcod);\n\n    }\n\n    // SQL Error Condition Reply Message indicates that an SQL error\n    // has occurred.  It may be sent even though no reply message\n    // precedes the SQLCARD object that is the normal\n    // response to a command when an exception occurs.\n    // The SQLERRM is also used when a BNDSQLSTT command is terminated\n    // by an INTRRDBRQS command.\n    // This reply message must precede an SQLCARD object.\n    // The SQLSTATE is returned in the SQLCARD.\n    //\n    // Returned from Server:\n    // SVRCOD - required  (8 - ERROR)\n    // RDBNAM - optional\n    //\n    // Also called by NetResultSetReply and NetStatementReply\n    void parseSQLERRRM() throws DisconnectException {\n        boolean svrcodReceived = false;\n        int svrcod = CodePoint.SVRCOD_INFO;\n        boolean rdbnamReceived = false;\n        String rdbnam = null;\n\n        parseLengthAndMatchCodePoint(CodePoint.SQLERRRM);\n        pushLengthOnCollectionStack();\n        int peekCP = peekCodePoint();\n\n        while (peekCP != Reply.END_OF_COLLECTION) {\n\n            boolean foundInPass = false;\n\n            if (peekCP == CodePoint.SVRCOD) {\n                foundInPass = true;\n                svrcodReceived = checkAndGetReceivedFlag(svrcodReceived);\n                svrcod = parseSVRCOD(CodePoint.SVRCOD_ERROR, CodePoint.SVRCOD_ERROR);\n                peekCP = peekCodePoint();\n            }\n\n            if (peekCP == CodePoint.RDBNAM) {\n                foundInPass = true;\n                rdbnamReceived = checkAndGetReceivedFlag(rdbnamReceived);\n                rdbnam = parseRDBNAM(true);\n                peekCP = peekCodePoint();\n            }\n\n            if (!foundInPass) {\n                doPrmnsprmSemantics(peekCP);\n            }\n\n        }\n        popCollectionStack();\n        checkRequiredObjects(svrcodReceived);\n\n        // move into a method\n        netAgent_.setSvrcod(svrcod);\n    }\n\n    //--------------------- parse DDM Reply Data--------------------------------------\n\n    //------------------------parse DDM Scalars-----------------------------\n\n    // RDB Package Name and Consistency token Scalar Object specifies the\n    // fully qualified name of a relational database package and its\n    // consistency token.\n    protected Object parsePKGNAMCT(boolean skip) throws DisconnectException {\n        parseLengthAndMatchCodePoint(CodePoint.PKGNAMCT);\n        if (skip) {\n            skipBytes();\n            return null;\n        }\n        agent_.accumulateChainBreakingReadExceptionAndThrow(new DisconnectException(agent_,\n                new ClientMessageId(SQLState.DRDA_COMMAND_NOT_IMPLEMENTED),\n                \"parsePKGNAMCT\"));\n        return null; // to make compiler happy\n    }\n\n\n\tprotected void resetAgent_(NetAgent netAgent, LogWriter netLogWriter, int loginTimeout, String server, int port) throws SqlException {\n\t    \n\t    netAgent.exceptionConvertingRdbnam = null;\n\t    // most properties will remain unchanged on connect reset.\n\t    netAgent.targetTypdef_ = netAgent.originalTargetTypdef_;\n\t    netAgent.svrcod_ = 0;\n\t\n\t    // Set TCP/IP Socket Properties\n\t    try {\n\t        netAgent.socket_.setSoTimeout(loginTimeout * 1000);\n\t    } catch (java.net.SocketException e) {\n\t        try {\n\t            netAgent.socket_.close();\n\t        } catch (java.io.IOException doNothing) {\n\t        }\n\t        throw new SqlException(netAgent.logWriter_, \n\t            new ClientMessageId(SQLState.SOCKET_EXCEPTION),\n\t            e.getMessage(), e);\n\t    }\n\t}\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 0,
                "candidates": []
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 10565
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_method_names": [
                        "parseDTAMCHRM",
                        "parseRDBUPDRM",
                        "parseSQLERRRM",
                        "resetAgent_"
                    ],
                    "llm_response_time": 3019
                },
                {
                    "iteration_num": 2,
                    "suggested_method_names": [
                        "parseDTAMCHRM",
                        "parseRDBUPDRM",
                        "parseSQLERRRM",
                        "resetAgent_"
                    ],
                    "llm_response_time": 3276
                },
                {
                    "iteration_num": 3,
                    "suggested_method_names": [
                        "parseDTAMCHRM",
                        "parseRDBUPDRM",
                        "parseSQLERRRM",
                        "resetAgent_"
                    ],
                    "llm_response_time": 3440
                },
                {
                    "iteration_num": -1,
                    "suggested_method_names": [
                        "parseDTAMCHRM",
                        "parseRDBUPDRM",
                        "parseSQLERRRM",
                        "resetAgent_"
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "parseSQLERRRM",
                    "parseDTAMCHRM",
                    "parseRDBUPDRM",
                    "resetAgent_"
                ],
                "llm_response_time": 712
            },
            "targetClassMap": {
                "parseSQLERRRM": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1724,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "parseDTAMCHRM": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1299,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "parseRDBUPDRM": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1252,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.apache.derby.iapi.types.SQLInteger::isUpdated():boolean need move to org.apache.derby.impl.sql.execute.ScrollInsensitiveResultSet",
        "class_name": "org.apache.derby.iapi.types.SQLInteger",
        "telemetry": {
            "id": "b2b9b472-e5fd-4a89-9c7a-759885f4b2e0",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 677,
                "lineStart": 46,
                "lineEnd": 722,
                "bodyLineStart": 46,
                "language": "java",
                "sourceCode": "/**\n * SQLInteger represents an INTEGER value.\n */\npublic final class SQLInteger\n\textends NumberDataType\n{\n\t/*\n\t * DataValueDescriptor interface\n\t * (mostly implemented in DataType)\n\t */\n\n\n        // JDBC is lax in what it permits and what it\n\t// returns, so we are similarly lax\n\t// @see DataValueDescriptor\n\tpublic int\tgetInt()\n\t{\n\t\t/* This value is 0 if the SQLInteger is null */\n\t\treturn value;\n\t}\n\n\t/**\n\t * @exception StandardException thrown on failure to convert\n\t */\n\tpublic byte\tgetByte() throws StandardException\n\t{\n\t\tif (value > Byte.MAX_VALUE || value < Byte.MIN_VALUE)\n\t\t\tthrow StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, \"TINYINT\");\n\t\treturn (byte) value;\n\t}\n\n\t/**\n\t * @exception StandardException thrown on failure to convert\n\t */\n\tpublic short\tgetShort() throws StandardException\n\t{\n\t\tif (value > Short.MAX_VALUE || value < Short.MIN_VALUE)\n\t\t\tthrow StandardException.newException(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE, \"SMALLINT\");\n\t\treturn (short) value;\n\t}\n\n\tpublic long\tgetLong()\n\t{\n\t\treturn (long) value;\n\t}\n\n\tpublic float\tgetFloat()\n\t{\n\t\treturn (float) value;\n\t}\n\n\tpublic double\tgetDouble()\n\t{\n\t\treturn (double) value;\n\t}\n\n    // for lack of a specification: 0 or null is false,\n    // all else is true\n\tpublic boolean\tgetBoolean()\n\t{\n\t\treturn (value != 0);\n\t}\n\n\tpublic String\tgetString()\n\t{\n\t\tif (isNull())\n\t\t\treturn null;\n\t\telse\n\t\t\treturn Integer.toString(value);\n\t}\n\n\tpublic Object\tgetObject()\n\t{\n\t\tif (isNull())\n\t\t\treturn null;\n\t\telse\n\t\t\treturn new Integer(value);\n\t}\n\n\tpublic int\tgetLength()\n\t{\n\t\treturn INTEGER_LENGTH;\n\t}\n\n\t// this is for DataType's error generator\n\tpublic String getTypeName()\n\t{\n\t\treturn TypeId.INTEGER_NAME;\n\t}\n\n\t/*\n\t * Storable interface, implies Externalizable, TypedFormat\n\t */\n\n\n\t/**\n\t\tReturn my format identifier.\n\n\t\t@see org.apache.derby.iapi.services.io.TypedFormat#getTypeFormatId\n\t*/\n\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.SQL_INTEGER_ID;\n\t}\n\n\t/*\n\t * see if the integer value is null.\n\t */\n\t/** @see Storable#isNull */\n\tpublic boolean isNull()\n\t{\n\t\treturn isnull;\n\t}\n\n\tpublic void writeExternal(ObjectOutput out) throws IOException {\n\n\t\t// never called when value is null\n\t\tif (SanityManager.DEBUG)\n\t\t\tSanityManager.ASSERT(! isNull());\n\n\t\tout.writeInt(value);\n\t}\n\n\t/** @see java.io.Externalizable#readExternal */\n\tpublic final void readExternal(ObjectInput in) \n        throws IOException {\n\n\t\tvalue = in.readInt();\n\t\tisnull = false;\n\t}\n\tpublic final void readExternalFromArray(ArrayInputStream in) \n        throws IOException {\n\n\t\tvalue = in.readInt();\n\t\tisnull = false;\n\t}\n\n\t/**\n\t * @see Storable#restoreToNull\n\t *\n\t */\n\n\tpublic void restoreToNull()\n\t{\n\t\tvalue = 0;\n\t\tisnull = true;\n\t}\n\n\n\t/** @exception StandardException\t\tThrown on error */\n\tprotected int typeCompare(DataValueDescriptor arg) throws StandardException\n\t{\n\t\t/* neither are null, get the value */\n\n\t\tint thisValue = this.getInt();\n\n\t\tint otherValue = arg.getInt();\n\n\t\tif (thisValue == otherValue)\n\t\t\treturn 0;\n\t\telse if (thisValue > otherValue)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\n\t/*\n\t * DataValueDescriptor interface\n\t */\n\n\t/** @see DataValueDescriptor#cloneValue */\n\tpublic DataValueDescriptor cloneValue(boolean forceMaterialization)\n\t{\n\t\tSQLInteger nsi = new SQLInteger(value);\n\n\t\tnsi.isnull = isnull;\n\t\treturn nsi;\n\t}\n\n\t/**\n\t * @see DataValueDescriptor#getNewNull\n\t */\n\tpublic DataValueDescriptor getNewNull()\n\t{\n\t\treturn new SQLInteger();\n\t}\n\n\t/** \n\t * @see DataValueDescriptor#setValueFromResultSet \n\t *\n\t * @exception SQLException\t\tThrown on error\n\t */\n\tpublic void setValueFromResultSet(ResultSet resultSet, int colNumber,\n\t\t\t\t\t\t\t\t\t  boolean isNullable)\n\t\tthrows SQLException\n\t{\n\t\t\tif ((value = resultSet.getInt(colNumber)) == 0)\n\t\t\t\tisnull = (isNullable && resultSet.wasNull());\n\t\t\telse\n\t\t\t\tisnull = false;\n\t}\n\t/**\n\t\tSet the value into a PreparedStatement.\n\n\t\t@exception SQLException Error setting value in PreparedStatement\n\t*/\n\tpublic final void setInto(PreparedStatement ps, int position) throws SQLException {\n\n\t\tif (isNull()) {\n\t\t\tps.setNull(position, java.sql.Types.INTEGER);\n\t\t\treturn;\n\t\t}\n\n\t\tps.setInt(position, value);\n\t}\n\t/**\n\t\tSet this value into a ResultSet for a subsequent ResultSet.insertRow\n\t\tor ResultSet.updateRow. This method will only be called for non-null values.\n\n\t\t@exception SQLException thrown by the ResultSet object\n\t*/\n\tpublic final void setInto(ResultSet rs, int position) throws SQLException {\n\t\trs.updateInt(position, value);\n\t}\n\n\t/*\n\t * class interface\n\t */\n\n\t/*\n\t * constructors\n\t */\n\n\t/** no-arg constructor, required by Formattable */\n    // This constructor also gets used when we are\n    // allocating space for an integer.\n\tpublic SQLInteger() \n\t{\n\t\tisnull = true;\n\t}\n\n\tpublic SQLInteger(int val)\n\t{\n\t\tvalue = val;\n\t}\n\n\tpublic SQLInteger(char val)\n\t{\n\t\tvalue = val;\n\t}\n\n\tpublic SQLInteger(Integer obj) {\n\t\tif (isnull = (obj == null))\n\t\t\t;\n\t\telse\n\t\t\tvalue = obj.intValue();\n\t}\n\n\t/**\n\t\t@exception StandardException thrown if string not accepted\n\t */\n\tpublic void setValue(String theValue)\n\t\tthrows StandardException\n\t{\n\t\tif (theValue == null)\n\t\t{\n\t\t\tvalue = 0;\n\t\t\tisnull = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t    try {\n\t\t        value = Integer.parseInt(theValue.trim());\n\t\t\t} catch (NumberFormatException nfe) {\n\t\t\t    throw invalidFormat();\n\t\t\t}\n\t\t\tisnull = false;\n\t\t}\n\t}\n\n\tpublic void setValue(int theValue)\n\t{\n\t\tvalue = theValue;\n\t\tisnull = false;\n\t}\n\n\t/**\n\t\t@exception StandardException thrown on overflow\n\t */\n\tpublic void setValue(long theValue) throws StandardException\n\t{\n\t\tif (theValue > Integer.MAX_VALUE || theValue < Integer.MIN_VALUE) {\n\t\t\tthrow outOfRange();\n\t\t}\n\n\t\tvalue = (int)theValue;\n\t\tisnull = false;\n\t}\n\n\t/**\n\t * @see NumberDataValue#setValue\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\tpublic void setValue(float theValue) throws StandardException\n\t{\n        theValue = NumberDataType.normalizeREAL(theValue);\n\n\t\tif (theValue > Integer.MAX_VALUE || theValue < Integer.MIN_VALUE)\n\t\t\tthrow outOfRange();\n\n\t\tfloat floorValue = (float)Math.floor(theValue);\n\n\t\tvalue = (int)floorValue;\n\t\tisnull = false;\n\t}\n\n\t/**\n\t * @see NumberDataValue#setValue\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\tpublic void setValue(double theValue) throws StandardException\n\t{\n\t\ttheValue = NumberDataType.normalizeDOUBLE(theValue);\n\n\t\tif (theValue > Integer.MAX_VALUE || theValue < Integer.MIN_VALUE)\n\t\t\tthrow outOfRange();\n\n\t\tdouble floorValue = Math.floor(theValue);\n\n\t\tvalue = (int)floorValue;\n\t\tisnull = false;\n\t}\n\n\tpublic void setValue(boolean theValue)\n\t{\n\t\tvalue = theValue?1:0;\n\t\tisnull = false;\n\t}\n\n\tprotected void setFrom(DataValueDescriptor theValue) throws StandardException {\n\n\t\tsetValue(theValue.getInt());\n\t}\n\n\t/*\n\t * DataValueDescriptor interface\n\t */\n\n\t/** @see DataValueDescriptor#typePrecedence */\n\tpublic int typePrecedence()\n\t{\n\t\treturn TypeId.INT_PRECEDENCE;\n\t}\n\n\t/*\n\t** SQL Operators\n\t*/\n\n\t/**\n\t * The = operator as called from the language module, as opposed to\n\t * the storage module.\n\t *\n\t * @param left\t\t\tThe value on the left side of the =\n\t * @param right\t\t\tThe value on the right side of the =\n\t *\n\t * @return\tA SQL boolean value telling whether the two parameters are equal\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\n\tpublic BooleanDataValue equals(DataValueDescriptor left,\n\t\t\t\t\t\t\tDataValueDescriptor right)\n\t\t\tthrows StandardException\n\t{\n\t\treturn SQLBoolean.truthValue(left,\n\t\t\t\t\t\t\t\t\t right,\n\t\t\t\t\t\t\t\t\t left.getInt() == right.getInt());\n\t}\n\n\t/**\n\t * The <> operator as called from the language module, as opposed to\n\t * the storage module.\n\t *\n\t * @param left\t\t\tThe value on the left side of the <>\n\t * @param right\t\t\tThe value on the right side of the <>\n\t *\n\t * @return\tA SQL boolean value telling whether the two parameters\n\t *\t\t\tare not equal\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\n\tpublic BooleanDataValue notEquals(DataValueDescriptor left,\n\t\t\t\t\t\t\tDataValueDescriptor right)\n\t\t\tthrows StandardException\n\t{\n\t\treturn SQLBoolean.truthValue(left,\n\t\t\t\t\t\t\t\t\t right,\n\t\t\t\t\t\t\t\t\t left.getInt() != right.getInt());\n\t}\n\n\t/**\n\t * The < operator as called from the language module, as opposed to\n\t * the storage module.\n\t *\n\t * @param left\t\t\tThe value on the left side of the <\n\t * @param right\t\t\tThe value on the right side of the <\n\t *\n\t * @return\tA SQL boolean value telling whether the first operand is less\n\t *\t\t\tthan the second operand\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\n\tpublic BooleanDataValue lessThan(DataValueDescriptor left,\n\t\t\t\t\t\t\tDataValueDescriptor right)\n\t\t\tthrows StandardException\n\t{\n\t\treturn SQLBoolean.truthValue(left,\n\t\t\t\t\t\t\t\t\t right,\n\t\t\t\t\t\t\t\t\t left.getInt() < right.getInt());\n\t}\n\n\t/**\n\t * The > operator as called from the language module, as opposed to\n\t * the storage module.\n\t *\n\t * @param left\t\t\tThe value on the left side of the >\n\t * @param right\t\t\tThe value on the right side of the >\n\t *\n\t * @return\tA SQL boolean value telling whether the first operand is greater\n\t *\t\t\tthan the second operand\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\n\tpublic BooleanDataValue greaterThan(DataValueDescriptor left,\n\t\t\t\t\t\t\tDataValueDescriptor right)\n\t\t\tthrows StandardException\n\t{\n\t\treturn SQLBoolean.truthValue(left,\n\t\t\t\t\t\t\t\t\t right,\n\t\t\t\t\t\t\t\t\t left.getInt() > right.getInt());\n\t}\n\n\t/**\n\t * The <= operator as called from the language module, as opposed to\n\t * the storage module.\n\t *\n\t * @param left\t\t\tThe value on the left side of the <=\n\t * @param right\t\t\tThe value on the right side of the <=\n\t *\n\t * @return\tA SQL boolean value telling whether the first operand is less\n\t *\t\t\tthan or equal to the second operand\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\n\tpublic BooleanDataValue lessOrEquals(DataValueDescriptor left,\n\t\t\t\t\t\t\tDataValueDescriptor right)\n\t\t\tthrows StandardException\n\t{\n\t\treturn SQLBoolean.truthValue(left,\n\t\t\t\t\t\t\t\t\t right,\n\t\t\t\t\t\t\t\t\t left.getInt() <= right.getInt());\n\t}\n\n\t/**\n\t * The >= operator as called from the language module, as opposed to\n\t * the storage module.\n\t *\n\t * @param left\t\t\tThe value on the left side of the >=\n\t * @param right\t\t\tThe value on the right side of the >=\n\t *\n\t * @return\tA SQL boolean value telling whether the first operand is greater\n\t *\t\t\tthan or equal to the second operand\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\n\tpublic BooleanDataValue greaterOrEquals(DataValueDescriptor left,\n\t\t\t\t\t\t\tDataValueDescriptor right)\n\t\t\tthrows StandardException\n\t{\n\t\treturn SQLBoolean.truthValue(left,\n\t\t\t\t\t\t\t\t\t right,\n\t\t\t\t\t\t\t\t\t left.getInt() >= right.getInt());\n\t}\n\n\t/**\n\t * This method implements the * operator for \"int * int\".\n\t *\n\t * @param left\tThe first value to be multiplied\n\t * @param right\tThe second value to be multiplied\n\t * @param result\tThe result of a previous call to this method, null\n\t *\t\t\t\t\tif not called yet\n\t *\n\t * @return\tA SQLInteger containing the result of the multiplication\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\n\tpublic NumberDataValue times(NumberDataValue left,\n\t\t\t\t\t\t\tNumberDataValue right,\n\t\t\t\t\t\t\tNumberDataValue result)\n\t\t\t\tthrows StandardException\n\t{\n\t\tif (result == null)\n\t\t{\n\t\t\tresult = new SQLInteger();\n\t\t}\n\n\t\tif (left.isNull() || right.isNull())\n\t\t{\n\t\t\tresult.setToNull();\n\t\t\treturn result;\n\t\t}\n\n\t\t/*\n\t\t** Java does not check for overflow with integral types. We have to\n\t\t** check the result ourselves.\n\t\t**\n\t\t** We can't use sign checking tricks like we do for '+' and '-' since\n\t\t** the product of 2 integers can wrap around multiple times.  So, we\n\t\t** do long arithmetic and then verify that the result is within the \n\t\t** range of an int, throwing an error if it isn't.\n\t\t*/\n\t\tlong tempResult = left.getLong() * right.getLong();\n\n\t\tresult.setValue(tempResult);\n\t\treturn result;\n\t}\n\n\n\t/**\n\t\tmod(int, int)\n\t*/\n\tpublic NumberDataValue mod(NumberDataValue dividend,\n\t\t\t\t\t\t\t\tNumberDataValue divisor,\n\t\t\t\t\t\t\t\tNumberDataValue result)\n\t\t\t\t\t\t\t\tthrows StandardException {\n\t\tif (result == null)\n\t\t{\n\t\t\tresult = new SQLInteger();\n\t\t}\n\n\t\tif (dividend.isNull() || divisor.isNull())\n\t\t{\n\t\t\tresult.setToNull();\n\t\t\treturn result;\n\t\t}\n\n\t\t/* Catch divide by 0 */\n\t\tint intDivisor = divisor.getInt();\n\t\tif (intDivisor == 0)\n\t\t{\n\t\t\tthrow StandardException.newException(SQLState.LANG_DIVIDE_BY_ZERO);\n\t\t}\n\n\t\tresult.setValue(dividend.getInt() % intDivisor);\n\t\treturn result;\n\t}\n\t/**\n\t * This method implements the unary minus operator for int.\n\t *\n\t * @param result\tThe result of a previous call to this method, null\n\t *\t\t\t\t\tif not called yet\n\t *\n\t * @return\tA SQLInteger containing the result of the division\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\n\tpublic NumberDataValue minus(NumberDataValue result)\n\t\t\t\t\t\t\t\t\tthrows StandardException\n\t{\n\t\tint\t\toperandValue;\n\n\t\tif (result == null)\n\t\t{\n\t\t\tresult = new SQLInteger();\n\t\t}\n\n\t\tif (this.isNull())\n\t\t{\n\t\t\tresult.setToNull();\n\t\t\treturn result;\n\t\t}\n\n\t\toperandValue = this.getInt();\n\n\t\t/*\n\t\t** In two's complement arithmetic, the minimum value for a number\n\t\t** can't be negated, since there is no representation for its\n\t\t** positive value.  For integers, the minimum value is -2147483648,\n\t\t** and the maximum value is 2147483647.\n\t\t*/\n\t\tif (operandValue == Integer.MIN_VALUE)\n\t\t{\n\t\t\tthrow outOfRange();\n\t\t}\n\n\t\tresult.setValue(-operandValue);\n\t\treturn result;\n\t}\n\n    /**\n     * This method implements the isNegative method.\n     *\n     * @return  A boolean.  If this.value is negative, return true.\n     *          For positive values or null, return false.\n     */\n\n    protected boolean isNegative()\n    {\n        return !isNull() && value < 0;\n    }\n\n\t/*\n\t * String display of value\n\t */\n\n\tpublic String toString()\n\t{\n\t\tif (isNull())\n\t\t\treturn \"NULL\";\n\t\telse\n\t\t\treturn Integer.toString(value);\n\t}\n\n\t/*\n\t * Hash code\n\t */\n\tpublic int hashCode()\n\t{\n\t\treturn value;\n\t}\n\n\t/*\n\t * useful constants...\n\t */\n\tstatic final int INTEGER_LENGTH\t\t= 4; // must match the number of bytes written by DataOutput.writeInt()\n\n    private static final int BASE_MEMORY_USAGE = ClassSize.estimateBaseFromCatalog( SQLInteger.class);\n\n    public int estimateMemoryUsage()\n    {\n        return BASE_MEMORY_USAGE;\n    }\n\n\t/**\n\t * Returns TRUE if the row was been updated within the transaction,\n\t * otherwise returns FALSE\n\t *\n\t * @return True if the row has been deleted, otherwise false\n\t *\n\t * @param scrollInsensitiveResultSet TODO\n\t * @exception StandardException on error\n\t */\n\tpublic boolean isUpdated(ScrollInsensitiveResultSet scrollInsensitiveResultSet) throws StandardException {\n\t\tif (scrollInsensitiveResultSet.currentPosition <= scrollInsensitiveResultSet.positionInSource && scrollInsensitiveResultSet.currentPosition > 0) {\n\t\t\tsetValue(scrollInsensitiveResultSet.currentPosition);\n\t\t\tDataValueDescriptor[] hashRowArray = (DataValueDescriptor[]) \n\t\t\t\t\tscrollInsensitiveResultSet.ht.get(this);\n\t\t\treturn hashRowArray[ScrollInsensitiveResultSet.POS_ROWUPDATED].getBoolean();\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*\n\t * object state\n\t */\n\tprivate int\t\tvalue;\n\tprivate boolean\tisnull;\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 697,
                        "lineEnd": 714,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.apache.derby.impl.sql.execute.ScrollInsensitiveResultSet\nRationale: The method isUpdated() directly operates on the properties of the ScrollInsensitiveResultSet instance, such as currentPosition and positionInSource, making it more appropriate for this class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 5907
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_method_names": [
                        "isUpdated"
                    ],
                    "llm_response_time": 1453
                },
                {
                    "iteration_num": 2,
                    "suggested_method_names": [
                        "isUpdated"
                    ],
                    "llm_response_time": 2561
                },
                {
                    "iteration_num": 3,
                    "suggested_method_names": [
                        "isUpdated"
                    ],
                    "llm_response_time": 1257
                },
                {
                    "iteration_num": -1,
                    "suggested_method_names": [
                        "isUpdated"
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "isUpdated"
                ],
                "llm_response_time": 548
            },
            "targetClassMap": {
                "isUpdated": {
                    "target_classes": [
                        {
                            "class_name": "ScrollInsensitiveResultSet",
                            "similarity_score": 0.7233257139898187
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "ScrollInsensitiveResultSet"
                    ],
                    "llm_response_time": 1028,
                    "similarity_computation_time": 6,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "- method org.apache.derby.vti.Restriction::getFloat(int):float need move to org.apache.derbyTesting.functionTests.tests.lang.RestrictedTableVTI",
        "class_name": "org.apache.derby.vti.Restriction",
        "telemetry": {
            "id": "61349697-0f1d-4e53-9852-674c1a3215a6",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 242,
                "lineStart": 29,
                "lineEnd": 270,
                "bodyLineStart": 29,
                "language": "java",
                "sourceCode": "/**\n   <p>\n * An expression to be pushed into a Table Function so that the Table Function\n * can short-circuit its processing and return fewer rows. A restriction is represented\n * as a binary tree. The non-leaf nodes are ANDs and ORs. The leaf nodes\n * are ColumnQualifiers. A ColumnQualifier\n * is a simple expression comparing a constant value to a column in\n * the Table Function.\n * </p>\n */\npublic abstract class Restriction implements Serializable\n{\n    /**\n     * Turn this Restriction into a string suitable for use in a WHERE clause.\n     */\n    public abstract String toSQL();\n\n    /** Utility method to parenthesize an expression */\n    protected String parenthesize( String raw ) { return \"( \" + raw + \" )\"; }\n    \n    public  float \tgetFloat(RestrictedTableVTI restrictedTableVTI, int i) throws SQLException\n\t{ return restrictedTableVTI._resultSet.getFloat( restrictedTableVTI.mapColumnNumber( i ) ); }\n\n\t/** An AND of two Restrictions */\n    public static class AND extends Restriction\n    {\n        /** Derby serializes these objects in PreparedStatements */\n        public static final long serialVersionUID = -8205388794606605844L;\n        \n        private Restriction _leftChild;\n        private Restriction _rightChild;\n\n        /** AND together two other Restrictions */\n        public AND( Restriction leftChild, Restriction rightChild )\n        {\n            _leftChild = leftChild;\n            _rightChild = rightChild;\n        }\n\n        /** Get the left Restriction */\n        public Restriction getLeftChild() { return _leftChild; }\n\n        /** Get the right Restriction */\n        public Restriction getRightChild() { return _rightChild; }\n        \n        public String toSQL()\n        {\n            return parenthesize( _leftChild.toSQL() ) + \" AND \" + parenthesize( _rightChild.toSQL() );\n        }\n    }\n\n    /** An OR of two Restrictions */\n    public static class OR extends Restriction\n    {\n        /** Derby serializes these objects in PreparedStatements */\n        public static final long serialVersionUID = -8205388794606605844L;\n        \n        private Restriction _leftChild;\n        private Restriction _rightChild;\n\n        /** OR together two other Restrictions */\n        public OR( Restriction leftChild, Restriction rightChild )\n        {\n            _leftChild = leftChild;\n            _rightChild = rightChild;\n        }\n\n        /** Get the left Restriction */\n        public Restriction getLeftChild() { return _leftChild; }\n\n        /** Get the right Restriction */\n        public Restriction getRightChild() { return _rightChild; }\n\n        public String toSQL()\n        {\n            return parenthesize( _leftChild.toSQL() ) + \" OR \" + parenthesize( _rightChild.toSQL() );\n        }\n    }\n\n    /**\n       <p>\n       * A simple comparison of a column to a constant value. The comparison\n       * has the form:\n       * </p>\n       *\n       * <blockquote><pre>\n       * column OP constant\n       * </pre></blockquote>\n       *\n       * <p>\n       * where OP is one of the following:\n       * </p>\n       *\n       * <blockquote><pre>\n       *  <     =     <=     >      >=    IS NULL    IS NOT NULL\n       * </pre></blockquote>\n       */\n    public static class ColumnQualifier extends Restriction\n    {\n        ////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // CONSTANTS\n        //\n        ////////////////////////////////////////////////////////////////////////////////////////\n\n        /** Derby serializes these objects in PreparedStatements */\n        public static final long serialVersionUID = -8205388794606605844L;\n        \n        /**\t Ordering operation constant representing '<' **/\n        public static final int ORDER_OP_LESSTHAN = 0;\n\n        /**\t Ordering operation constant representing '=' **/\n        public static final int ORDER_OP_EQUALS = 1;\n\n        /**\t Ordering operation constant representing '<=' **/\n        public static final int ORDER_OP_LESSOREQUALS = 2;\n\n        /**\t Ordering operation constant representing '>' **/\n        public static final int ORDER_OP_GREATERTHAN = 3;\n\n        /**\t Ordering operation constant representing '>=' **/\n        public static final int ORDER_OP_GREATEROREQUALS = 4;\n\n        /**\t Ordering operation constant representing 'IS NULL' **/\n        public static final int ORDER_OP_ISNULL = 5;\n\n        /**\t Ordering operation constant representing 'IS NOT NULL' **/\n        public static final int ORDER_OP_ISNOTNULL = 6;\n\n        /**\t Ordering operation constant representing '!=' **/\n        public static final int ORDER_OP_NOT_EQUALS = 7;\n\n        // Visible forms of the constants above\n        private String[] OPERATOR_SYMBOLS = new String[] {  \"<\", \"=\", \"<=\", \">\", \">=\", \"IS NULL\", \"IS NOT NULL\", \"!=\" };\n\n        ////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // STATE\n        //\n        ////////////////////////////////////////////////////////////////////////////////////////\n\n        /** name of column being restricted */\n        private String _columnName;\n\n        /** comparison operator, one of the ORDER_OP constants */\n        private int     _comparisonOperator;\n\n        /** value to compare the column to */\n        private Object _constantOperand;\n        \n        ////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // CONSTRUCTORS\n        //\n        ////////////////////////////////////////////////////////////////////////////////////////\n\n        /**\n         * <p>\n         * Construct from pieces.\n         * </p>\n         *\n         * @param columnName Name of column as declared in the CREATE FUNCTION statement.\n         * @param comparisonOperator One of the ORDER_OP constants.\n         * @param constantOperand Constant value to which the column should be compared.\n         */\n        public ColumnQualifier\n            (\n             String columnName,\n             int comparisonOperator,\n             Object constantOperand\n             )\n        {\n            _columnName = columnName;\n            _comparisonOperator = comparisonOperator;\n            _constantOperand = constantOperand;\n        }\n        \n        ////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // ACCESSORS\n        //\n        ////////////////////////////////////////////////////////////////////////////////////////\n        \n        /**\n         * <p>\n         * The name of the column being compared.\n         * </p>\n         */\n        public String getColumnName() { return _columnName; }\n\n        /**\n         * <p>\n         * The type of comparison to perform. This is one of the ORDER_OP constants\n         * defined above.\n         * </p>\n         */\n        public int getComparisonOperator() { return _comparisonOperator; }\n\n        /**\n         * <p>\n         * Get the constant value to which the column should be compared. The\n         * constant value must be an Object of the Java type which corresponds to\n         * the SQL type of the column. The column's SQL type was declared in the CREATE FUNCTION statement.\n         * The mapping of SQL types to Java types is defined in table 4 of chapter 14\n         * of the original JDBC 1 specification (dated 1996). Bascially, these are the Java\n         * wrapper values you would expect. For instance, SQL INT maps to java.lang.Integer, SQL CHAR\n         * maps to java.lang.String, etc.. This object will be null if the\n         * comparison operator is ORDER_OP_ISNULL or ORDER_OP_ISNOTNULL.\n         * </p>\n         */\n        public Object getConstantOperand() { return _constantOperand; }\n        \n        public String toSQL()\n        {\n            StringBuffer buffer = new StringBuffer();\n\n            buffer.append( IdUtil.normalToDelimited( _columnName ) );\n            buffer.append( \" \" + OPERATOR_SYMBOLS[ _comparisonOperator ] + \" \" );\n            if ( _constantOperand != null ) { buffer.append( toEscapedString( _constantOperand ) ); }\n\n            return buffer.toString();\n        }\n\n        protected String toEscapedString(Object o) {\n            if (o instanceof java.sql.Timestamp) {\n                return \"TIMESTAMP('\" + o.toString() + \"')\";\n            } else if (o instanceof java.sql.Date) {\n                return \"DATE('\" + o.toString() + \"')\";\n            } else if (o instanceof java.sql.Time) {\n                return \"TIME('\" + o.toString() + \"')\";\n            } else if (o instanceof String) {\n                return \"\\'\" + o.toString() + \"\\'\";\n            } else if (o instanceof byte[]) {\n                byte[] b = (byte[]) o;\n                return \"X\\'\" + org.apache.derby.iapi.util.StringUtil.toHexString(b, 0, b.length) + \"\\'\" ;\n            } else {\n                return o.toString();\n            }\n        }\n    }\n    \n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 48,
                        "lineEnd": 49,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.apache.derbyTesting.functionTests.tests.lang.RestrictedTableVTI\nRationale: The method directly interacts with the RestrictedTableVTI instance and its properties, making it logical for it to reside within the same class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 6610
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_method_names": [
                        "getFloat",
                        "toEscapedString"
                    ],
                    "llm_response_time": 2415
                },
                {
                    "iteration_num": 2,
                    "suggested_method_names": [
                        "getFloat",
                        "toEscapedString"
                    ],
                    "llm_response_time": 1856
                },
                {
                    "iteration_num": 3,
                    "suggested_method_names": [
                        "getFloat",
                        "toEscapedString"
                    ],
                    "llm_response_time": 1724
                },
                {
                    "iteration_num": -1,
                    "suggested_method_names": [
                        "getFloat",
                        "toEscapedString"
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "toEscapedString",
                    "getFloat"
                ],
                "llm_response_time": 477
            },
            "targetClassMap": {
                "toEscapedString": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1349,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "getFloat": {
                    "target_classes": [
                        {
                            "class_name": "RestrictedTableVTI",
                            "similarity_score": 0.6750191019555044
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "RestrictedTableVTI"
                    ],
                    "llm_response_time": 714,
                    "similarity_computation_time": 1,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "method org.apache.derby.iapi.sql.dictionary.PermDescriptor::getUncachedGenericPermDescriptor(PermDescriptor):PermDescriptor need move to org.apache.derby.impl.sql.catalog.DataDictionaryImpl",
        "class_name": "org.apache.derby.iapi.sql.dictionary.PermDescriptor",
        "telemetry": {
            "id": "669768c6-eabb-484a-a580-b2ac2fc453c6",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 213,
                "lineStart": 35,
                "lineEnd": 247,
                "bodyLineStart": 35,
                "language": "java",
                "sourceCode": "/**\n * This class describes rows in the SYS.SYSPERMS system table, which keeps track of the\n * permissions that have been granted but not revoked.\n */\npublic class PermDescriptor extends PermissionsDescriptor\n        implements Provider\n{\n    // object types\n    public static final String SEQUENCE_TYPE = \"SEQUENCE\";\n    public static final String UDT_TYPE = \"TYPE\";\n\n    // permissions\n    public static final String USAGE_PRIV = \"USAGE\";\n\n    // state\n    \n    private String objectType;\n    private UUID permObjectId;\n    private String permission;\n    private boolean grantable;\n\n    /**\n     * Constructor\n     *\n     * @param dataDictionary data dictionary\n     * @param permUUID       unique identification in time and space of this perm descriptor\n     * @param objectType     E.g., SEQUENCE_TYPE\n     * @param permObjectId   Unique id of the object being protected\n     * @param permission     E.g., USAGE_PRIV\n     * @param grantor        Authorization id which confers the privilege\n     * @param grantee        Authorization id which receives the privilege\n     * @param isGrantable    True if the privilege can be granted onwards\n     */\n\n    public PermDescriptor(DataDictionary dataDictionary, UUID permUUID, String objectType,\n                          UUID permObjectId, String permission, String grantor,\n                          String grantee, boolean isGrantable) {\n        super(dataDictionary, grantee, grantor);\n        setUUID(permUUID);\n        this.objectType = objectType;\n        this.permObjectId = permObjectId;\n        this.permission = permission;\n        this.grantable = isGrantable;\n    }\n\n    public PermDescriptor(DataDictionary dd, UUID permUUID)\n            throws StandardException {\n        /*\n    TODO When merging all permisions catalogs to this master catalog at a future date,\n    this pattern which uses a partially initialised key descriptor should be cleaned up.\n     */\n        this(dd, permUUID, null, null, null, null, null, false);\n    }\n\n    public String getObjectType() {\n        return objectType;\n    }\n\n    public UUID getPermObjectId() {\n        return permObjectId;\n    }\n\n    public String getPermission() {\n        return permission;\n    }\n\n    public boolean isGrantable() {\n        return grantable;\n    }\n\n    public int getCatalogNumber() {\n        return DataDictionary.SYSPERMS_CATALOG_NUM;\n    }\n\n    public String toString() {\n        if (SanityManager.DEBUG) {\n            return \"permUUID: \" + oid + \"\\n\" +\n                    \"objectType: \" + objectType + \"\\n\" +\n                    \"permObjectId: \" + permObjectId + \"\\n\" +\n                    \"permission: \" + permission + \"\\n\" +\n                    \"grantable: \" + grantable + \"\\n\";\n        } else {\n            return \"\";\n        }\n    }\n\n    /**\n     * @return true iff the key part of this perm descriptor equals the key part of another perm\n     *         descriptor.\n     */\n    public boolean equals(Object other) {\n        if (!(other instanceof PermDescriptor))\n            return false;\n        PermDescriptor otherPerm = (PermDescriptor) other;\n        return super.keyEquals(otherPerm) &&\n                permObjectId.equals(otherPerm.permObjectId);\n    }\n\n    /**\n     * @return the hashCode for the key part of this permissions descriptor\n     */\n    public int hashCode() {\n        return super.keyHashCode() + permObjectId.hashCode();\n    }\n\n    /**\n     * @see PermissionsDescriptor#checkOwner\n     */\n    public boolean checkOwner( String authorizationId ) throws StandardException\n    {\n        DataDictionary dd = getDataDictionary();\n        PrivilegedSQLObject pso = getProtectedObject( dd, permObjectId, objectType );\n        \n        return pso.getSchemaDescriptor().getAuthorizationId().equals(authorizationId);\n    }\n\n    /**\n     * Get the protected object.\n     *\n     * @param dd Metadata\n     * @param objectID Unique handle on the protected object\n     * @param objectType Type of the object\n     */\n    public static PrivilegedSQLObject getProtectedObject\n        ( DataDictionary dd, UUID objectID, String objectType ) throws StandardException\n    {\n        if ( PermDescriptor.SEQUENCE_TYPE.equals( objectType ) )\n        {\n            return dd.getSequenceDescriptor( objectID );\n        }\n        else if ( PermDescriptor.UDT_TYPE.equals( objectType ) )\n        {\n            return dd.getAliasDescriptor( objectID );\n        }\n        else\n        {\n            // oops, still need to implement support for this kind\n            // of privileged object\n            throw StandardException.newException( SQLState.BTREE_UNIMPLEMENTED_FEATURE );\n        }\n    }\n\n    //////////////////////////////////////////////\n    //\n    // PROVIDER INTERFACE\n    //\n    //////////////////////////////////////////////\n\n    /**\n     * Return the name of this Provider.  (Useful for errors.)\n     *\n     * @return String   The name of this provider.\n     */\n    public String getObjectName()\n    {\n        try {\n            DataDictionary dd = getDataDictionary();\n            PrivilegedSQLObject pso = getProtectedObject( dd, permObjectId, objectType );\n        \n            return pso.getName();\n        } catch (StandardException se) { return objectType; }\n    }\n\n    /**\n     * Get the provider's type.\n     *\n     * @return char         The provider's type.\n     */\n    public String getClassType() {\n        return Dependable.PERM;\n    }\n\n    /**\n     * @return the stored form of this provider\n     * @see Dependable#getDependableFinder\n     */\n    public DependableFinder getDependableFinder() {\n        return getDependableFinder(\n                StoredFormatIds.PERM_DESCRIPTOR_FINDER_V01_ID);\n    }\n\n\t/**\n\t * Get an object's permission descriptor from the system tables, without going through the cache.\n\t * This method is called to fill the permissions cache.\n\t *\n\t * @param dataDictionaryImpl TODO\n\t * @return a PermDescriptor that describes the table permissions granted to the grantee on an objcet\n\t * , null if no table-level permissions have been granted to him on the table.\n\t * @throws StandardException\n\t */\n\tpublic PermDescriptor getUncachedGenericPermDescriptor(DataDictionaryImpl dataDictionaryImpl)\n\t        throws StandardException\n\t{\n\t\tif (getObjectID() == null)\n\t\t{\n\t\t\t//the PERMISSSIONID for SYSRPERMS is not known, so use the id of the\n\t\t\t//protected object plus the\n\t\t\t//grantor and granteee to find a PermDescriptor\n\t        return (PermDescriptor)\n\t            dataDictionaryImpl.getUncachedPermissionsDescriptor(DataDictionary.SYSPERMS_CATALOG_NUM,\n\t                    SYSPERMSRowFactory.GRANTEE_OBJECTID_GRANTOR_INDEX_NUM, this);\n\t\t} else\n\t\t{\n\t\t\t//we know the PERMISSIONID for SYSPERMS, so use that to\n\t\t\t//find a PermDescriptor from the sytem table\n\t\t\treturn (PermDescriptor)\n\t\t\tdataDictionaryImpl.getUncachedPermissionsDescriptor(DataDictionary.SYSPERMS_CATALOG_NUM,\n\t\t\t\t\tSYSPERMSRowFactory.PERMS_UUID_IDX_NUM,this);\n\t\t}\n\t\n\t}\n\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 2,
                "candidates": [
                    {
                        "lineStart": 150,
                        "lineEnd": 174,
                        "refactoringType": "MyMoveStaticMethodRefactoring",
                        "description": "move method to org.apache.derby.iapi.sql.dictionary.DataDictionary\nRationale: The method getProtectedObject() interacts directly with the DataDictionary to retrieve various descriptors based on the object type, making it logical to place this method within the DataDictionary class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    },
                    {
                        "lineStart": 215,
                        "lineEnd": 244,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.apache.derby.impl.sql.catalog.DataDictionaryImpl\nRationale: The method interacts directly with the DataDictionaryImpl to retrieve permission descriptors, making it more appropriate for this method to reside within the DataDictionaryImpl class.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 7615
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_method_names": [
                        "getProtectedObject",
                        "getUncachedGenericPermDescriptor"
                    ],
                    "llm_response_time": 1974
                },
                {
                    "iteration_num": 2,
                    "suggested_method_names": [
                        "getProtectedObject",
                        "getUncachedGenericPermDescriptor"
                    ],
                    "llm_response_time": 2189
                },
                {
                    "iteration_num": 3,
                    "suggested_method_names": [
                        "getProtectedObject",
                        "getUncachedGenericPermDescriptor"
                    ],
                    "llm_response_time": 2266
                },
                {
                    "iteration_num": -1,
                    "suggested_method_names": [
                        "getProtectedObject",
                        "getUncachedGenericPermDescriptor"
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "getProtectedObject",
                    "getUncachedGenericPermDescriptor"
                ],
                "llm_response_time": 1116
            },
            "targetClassMap": {
                "getProtectedObject": {
                    "target_classes": [
                        {
                            "class_name": "DDUtils",
                            "similarity_score": 0.34476364527372316
                        },
                        {
                            "class_name": "ConsInfo",
                            "similarity_score": 0.4069380491904754
                        },
                        {
                            "class_name": "IndexLister",
                            "similarity_score": 0.5354278283078433
                        },
                        {
                            "class_name": "SystemColumn",
                            "similarity_score": 0.4476436382078131
                        },
                        {
                            "class_name": "SPSDescriptor",
                            "similarity_score": 0.5681867714898452
                        },
                        {
                            "class_name": "DataDictionary",
                            "similarity_score": 0.48407393643142327
                        },
                        {
                            "class_name": "PasswordHasher",
                            "similarity_score": 0.5828552712030761
                        },
                        {
                            "class_name": "UserDescriptor",
                            "similarity_score": 0.5565479932556289
                        },
                        {
                            "class_name": "ViewDescriptor",
                            "similarity_score": 0.5546693401883078
                        },
                        {
                            "class_name": "AliasDescriptor",
                            "similarity_score": 0.5913637548962182
                        },
                        {
                            "class_name": "TableDescriptor",
                            "similarity_score": 0.5953239549424705
                        },
                        {
                            "class_name": "TupleDescriptor",
                            "similarity_score": 0.4961254305093957
                        },
                        {
                            "class_name": "ColumnDescriptor",
                            "similarity_score": 0.5445995726634105
                        },
                        {
                            "class_name": "SchemaDescriptor",
                            "similarity_score": 0.49632606889740233
                        },
                        {
                            "class_name": "CatalogRowFactory",
                            "similarity_score": 0.5632476833010795
                        },
                        {
                            "class_name": "DefaultDescriptor",
                            "similarity_score": 0.578309028561338
                        },
                        {
                            "class_name": "IndexRowGenerator",
                            "similarity_score": 0.5644178873380827
                        },
                        {
                            "class_name": "TriggerDescriptor",
                            "similarity_score": 0.5714926076324647
                        },
                        {
                            "class_name": "ColPermsDescriptor",
                            "similarity_score": 0.4970969206169967
                        },
                        {
                            "class_name": "FileInfoDescriptor",
                            "similarity_score": 0.5415473521053148
                        },
                        {
                            "class_name": "SequenceDescriptor",
                            "similarity_score": 0.56144134476775
                        },
                        {
                            "class_name": "PrivilegedSQLObject",
                            "similarity_score": 0.3886648790538205
                        },
                        {
                            "class_name": "RoleClosureIterator",
                            "similarity_score": 0.3627469251921502
                        },
                        {
                            "class_name": "RoleGrantDescriptor",
                            "similarity_score": 0.515774732998989
                        },
                        {
                            "class_name": "StatementPermission",
                            "similarity_score": 0.6254475246408319
                        },
                        {
                            "class_name": "ColumnDescriptorList",
                            "similarity_score": 0.5476890265503752
                        },
                        {
                            "class_name": "ConstraintDescriptor",
                            "similarity_score": 0.5635008908290536
                        },
                        {
                            "class_name": "DependencyDescriptor",
                            "similarity_score": 0.5050239839885948
                        },
                        {
                            "class_name": "StatisticsDescriptor",
                            "similarity_score": 0.37285355877477233
                        },
                        {
                            "class_name": "TablePermsDescriptor",
                            "similarity_score": 0.42602626903504054
                        },
                        {
                            "class_name": "GenericDescriptorList",
                            "similarity_score": 0.5107594431951689
                        },
                        {
                            "class_name": "PermissionsDescriptor",
                            "similarity_score": 0.5642938528863058
                        },
                        {
                            "class_name": "UniqueTupleDescriptor",
                            "similarity_score": 0.43519315983152607
                        },
                        {
                            "class_name": "ConglomerateDescriptor",
                            "similarity_score": 0.5226762391430421
                        },
                        {
                            "class_name": "RoutinePermsDescriptor",
                            "similarity_score": 0.5220513800195468
                        },
                        {
                            "class_name": "DataDescriptorGenerator",
                            "similarity_score": 0.5553990488462598
                        },
                        {
                            "class_name": "KeyConstraintDescriptor",
                            "similarity_score": 0.5603106781690812
                        },
                        {
                            "class_name": "StatementRolePermission",
                            "similarity_score": 0.525889107644878
                        },
                        {
                            "class_name": "SubConstraintDescriptor",
                            "similarity_score": 0.5346285212971208
                        },
                        {
                            "class_name": "ConstraintDescriptorList",
                            "similarity_score": 0.516071106142787
                        },
                        {
                            "class_name": "StatementTablePermission",
                            "similarity_score": 0.5530971771973152
                        },
                        {
                            "class_name": "CheckConstraintDescriptor",
                            "similarity_score": 0.5840742501911904
                        },
                        {
                            "class_name": "StatementColumnPermission",
                            "similarity_score": 0.507031004618424
                        },
                        {
                            "class_name": "StatementSchemaPermission",
                            "similarity_score": 0.5086539387587125
                        },
                        {
                            "class_name": "UniqueSQLObjectDescriptor",
                            "similarity_score": 0.4168619120190003
                        },
                        {
                            "class_name": "ConglomerateDescriptorList",
                            "similarity_score": 0.5007058834578131
                        },
                        {
                            "class_name": "StatementGenericPermission",
                            "similarity_score": 0.6017917222918001
                        },
                        {
                            "class_name": "StatementRoutinePermission",
                            "similarity_score": 0.5306097533544236
                        },
                        {
                            "class_name": "SubKeyConstraintDescriptor",
                            "similarity_score": 0.509519044987291
                        },
                        {
                            "class_name": "SubCheckConstraintDescriptor",
                            "similarity_score": 0.5324964848972417
                        },
                        {
                            "class_name": "ForeignKeyConstraintDescriptor",
                            "similarity_score": 0.5814573959222743
                        },
                        {
                            "class_name": "ReferencedKeyConstraintDescriptor",
                            "similarity_score": 0.6148203829880943
                        },
                        {
                            "class_name": "DDUtils",
                            "similarity_score": 0.23764391084886888
                        },
                        {
                            "class_name": "ConsInfo",
                            "similarity_score": 0.13089673940283172
                        },
                        {
                            "class_name": "IndexLister",
                            "similarity_score": 0.24337542436688384
                        },
                        {
                            "class_name": "SystemColumn",
                            "similarity_score": 0.20507577810739896
                        },
                        {
                            "class_name": "SPSDescriptor",
                            "similarity_score": 0.23763021521056593
                        },
                        {
                            "class_name": "DataDictionary",
                            "similarity_score": 0.041550659727129
                        },
                        {
                            "class_name": "PasswordHasher",
                            "similarity_score": 0.2294677249418128
                        },
                        {
                            "class_name": "UserDescriptor",
                            "similarity_score": 0.2398370230736339
                        },
                        {
                            "class_name": "ViewDescriptor",
                            "similarity_score": 0.25275033364605626
                        },
                        {
                            "class_name": "AliasDescriptor",
                            "similarity_score": 0.25083915862396433
                        },
                        {
                            "class_name": "TableDescriptor",
                            "similarity_score": 0.2607516470715711
                        },
                        {
                            "class_name": "TupleDescriptor",
                            "similarity_score": 0.2769753643616176
                        },
                        {
                            "class_name": "ColumnDescriptor",
                            "similarity_score": 0.24704585718136104
                        },
                        {
                            "class_name": "SchemaDescriptor",
                            "similarity_score": 0.19623664285981013
                        },
                        {
                            "class_name": "CatalogRowFactory",
                            "similarity_score": 0.27034954159032343
                        },
                        {
                            "class_name": "DefaultDescriptor",
                            "similarity_score": 0.2546124050132244
                        },
                        {
                            "class_name": "IndexRowGenerator",
                            "similarity_score": 0.26040340038751186
                        },
                        {
                            "class_name": "TriggerDescriptor",
                            "similarity_score": 0.2525277336536766
                        },
                        {
                            "class_name": "ColPermsDescriptor",
                            "similarity_score": 0.25498979919755793
                        },
                        {
                            "class_name": "FileInfoDescriptor",
                            "similarity_score": 0.24837776257146407
                        },
                        {
                            "class_name": "SequenceDescriptor",
                            "similarity_score": 0.25248766157155056
                        },
                        {
                            "class_name": "PrivilegedSQLObject",
                            "similarity_score": 0.21616885058355848
                        },
                        {
                            "class_name": "RoleClosureIterator",
                            "similarity_score": 0.22786197567488775
                        },
                        {
                            "class_name": "RoleGrantDescriptor",
                            "similarity_score": 0.24770593549539927
                        },
                        {
                            "class_name": "StatementPermission",
                            "similarity_score": 0.2515528099612026
                        },
                        {
                            "class_name": "ColumnDescriptorList",
                            "similarity_score": 0.2573194209133315
                        },
                        {
                            "class_name": "ConstraintDescriptor",
                            "similarity_score": 0.25290503587643975
                        },
                        {
                            "class_name": "DependencyDescriptor",
                            "similarity_score": 0.23380026520164254
                        },
                        {
                            "class_name": "StatisticsDescriptor",
                            "similarity_score": 0.24032251073771518
                        },
                        {
                            "class_name": "TablePermsDescriptor",
                            "similarity_score": 0.2350576170119895
                        },
                        {
                            "class_name": "GenericDescriptorList",
                            "similarity_score": 0.2673248717548622
                        },
                        {
                            "class_name": "PermissionsDescriptor",
                            "similarity_score": 0.26982150878387134
                        },
                        {
                            "class_name": "UniqueTupleDescriptor",
                            "similarity_score": 0.23253407519796082
                        },
                        {
                            "class_name": "ConglomerateDescriptor",
                            "similarity_score": 0.251086017404896
                        },
                        {
                            "class_name": "RoutinePermsDescriptor",
                            "similarity_score": 0.2587772688254878
                        },
                        {
                            "class_name": "DataDescriptorGenerator",
                            "similarity_score": 0.19384758584933376
                        },
                        {
                            "class_name": "KeyConstraintDescriptor",
                            "similarity_score": 0.25234079421150896
                        },
                        {
                            "class_name": "StatementRolePermission",
                            "similarity_score": 0.25940262070027015
                        },
                        {
                            "class_name": "SubConstraintDescriptor",
                            "similarity_score": 0.2600424535798635
                        },
                        {
                            "class_name": "ConstraintDescriptorList",
                            "similarity_score": 0.2598525822191908
                        },
                        {
                            "class_name": "StatementTablePermission",
                            "similarity_score": 0.2738084458935384
                        },
                        {
                            "class_name": "CheckConstraintDescriptor",
                            "similarity_score": 0.2538234175596303
                        },
                        {
                            "class_name": "StatementColumnPermission",
                            "similarity_score": 0.2543836930064561
                        },
                        {
                            "class_name": "StatementSchemaPermission",
                            "similarity_score": 0.24733069438997185
                        },
                        {
                            "class_name": "UniqueSQLObjectDescriptor",
                            "similarity_score": 0.18959262392869294
                        },
                        {
                            "class_name": "ConglomerateDescriptorList",
                            "similarity_score": 0.26457982006258907
                        },
                        {
                            "class_name": "StatementGenericPermission",
                            "similarity_score": 0.2584808572764259
                        },
                        {
                            "class_name": "StatementRoutinePermission",
                            "similarity_score": 0.26599595767154216
                        },
                        {
                            "class_name": "SubKeyConstraintDescriptor",
                            "similarity_score": 0.2416964527694345
                        },
                        {
                            "class_name": "SubCheckConstraintDescriptor",
                            "similarity_score": 0.2540650080866609
                        },
                        {
                            "class_name": "ForeignKeyConstraintDescriptor",
                            "similarity_score": 0.23216140122640666
                        },
                        {
                            "class_name": "ReferencedKeyConstraintDescriptor",
                            "similarity_score": 0.24644597785706907
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "DataDictionary",
                        "PrivilegedSQLObject",
                        "StatementPermission",
                        "ReferencedKeyConstraintDescriptor",
                        "StatementGenericPermission",
                        "TableDescriptor",
                        "AliasDescriptor",
                        "CheckConstraintDescriptor",
                        "PasswordHasher",
                        "ForeignKeyConstraintDescriptor",
                        "DefaultDescriptor",
                        "TriggerDescriptor",
                        "SPSDescriptor",
                        "IndexRowGenerator",
                        "PermissionsDescriptor",
                        "ConstraintDescriptor",
                        "CatalogRowFactory",
                        "SequenceDescriptor",
                        "KeyConstraintDescriptor",
                        "UserDescriptor",
                        "DataDescriptorGenerator",
                        "ViewDescriptor",
                        "StatementTablePermission",
                        "ColumnDescriptorList",
                        "ColumnDescriptor",
                        "FileInfoDescriptor",
                        "IndexLister",
                        "SubConstraintDescriptor",
                        "SubCheckConstraintDescriptor",
                        "StatementRoutinePermission",
                        "StatementRolePermission",
                        "ConglomerateDescriptor",
                        "RoutinePermsDescriptor",
                        "ConstraintDescriptorList",
                        "RoleGrantDescriptor",
                        "GenericDescriptorList",
                        "SubKeyConstraintDescriptor",
                        "StatementSchemaPermission",
                        "StatementColumnPermission",
                        "DependencyDescriptor",
                        "ConglomerateDescriptorList",
                        "ColPermsDescriptor",
                        "SchemaDescriptor",
                        "TupleDescriptor",
                        "SystemColumn",
                        "UniqueTupleDescriptor",
                        "TablePermsDescriptor",
                        "UniqueSQLObjectDescriptor",
                        "ConsInfo",
                        "StatisticsDescriptor",
                        "RoleClosureIterator",
                        "DDUtils"
                    ],
                    "llm_response_time": 1408,
                    "similarity_computation_time": 146,
                    "similarity_metric": "cosine"
                },
                "getUncachedGenericPermDescriptor": {
                    "target_classes": [
                        {
                            "class_name": "DataDictionaryImpl",
                            "similarity_score": 0.6965975774014387
                        },
                        {
                            "class_name": "UUID",
                            "similarity_score": 0.33625000750973877
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "DataDictionaryImpl",
                        "UUID"
                    ],
                    "llm_response_time": 1679,
                    "similarity_computation_time": 20,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "- method org.apache.derby.iapi.sql.dictionary.GenericDescriptorList::setRefActionInfo(long, int[], String, boolean):void need move to org.apache.derby.impl.sql.compile.DMLModStatementNode",
        "class_name": "org.apache.derby.iapi.sql.dictionary.GenericDescriptorList",
        "telemetry": {
            "id": "def83c7f-684f-44b2-89a5-8efe59de34af",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 57,
                "lineStart": 30,
                "lineEnd": 86,
                "bodyLineStart": 30,
                "language": "java",
                "sourceCode": "public class GenericDescriptorList extends ArrayList\n{\n\tprivate boolean scanned;\n\n\t/**\n\t * Mark whether or not the underlying system table has\n\t * been scanned.  (If a table does not have any\n\t * constraints then the size of its CDL will always\n\t * be 0.  We used these get/set methods to determine\n\t * when we need to scan the table.\n\t *\n\t * @param scanned\tWhether or not the underlying system table has been scanned.\n\t */\n\tpublic void setScanned(boolean scanned)\n\t{\n\t\tthis.scanned = scanned;\n\t}\n\n\t/**\n\t * Return whether or not the underlying system table has been scanned.\n\t *\n\t * @return\t\tWhere or not the underlying system table has been scanned.\n\t */\n\tpublic boolean getScanned()\n\t{\n\t\treturn scanned;\n\t}\n\n\t/**\n\t * Get the UniqueTupleDescriptor that matches the \n\t * input uuid.\n\t *\n\t * @param uuid\t\tThe UUID for the object\n\t *\n\t * @return The matching UniqueTupleDescriptor.\n\t */\n\tpublic UniqueTupleDescriptor getUniqueTupleDescriptor(UUID uuid)\n\t{\n\t\tfor (Iterator iterator = iterator(); iterator.hasNext(); )\n\t\t{\n\t\t\tUniqueTupleDescriptor ud = (UniqueTupleDescriptor) iterator.next();\n\t\t\tif (ud.getUUID().equals(uuid))\n\t\t\t{\n\t\t\t\treturn ud;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void setRefActionInfo(DMLModStatementNode dmlModStatementNode, long fkIndexConglomId, int[] fkColArray, String parentResultSetId, boolean dependentScan)\n\t{\n\t\tdmlModStatementNode.resultSet.setRefActionInfo(fkIndexConglomId,\n\t\t\t\t\t\t\t\t   fkColArray,\n\t\t\t\t\t\t\t\t   parentResultSetId,\n\t\t\t\t\t\t\t\t   dependentScan);\n\t}\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 78,
                        "lineEnd": 84,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.apache.derby.impl.sql.compile.DMLModStatementNode\nRationale: The method directly manipulates the 'resultSet' property of the DMLModStatementNode instance, making it logical for the method to reside within the DMLModStatementNode class to encapsulate related functionality.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 8899
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_method_names": [
                        "setScanned",
                        "getScanned",
                        "setRefActionInfo"
                    ],
                    "llm_response_time": 3039
                },
                {
                    "iteration_num": 2,
                    "suggested_method_names": [
                        "setScanned",
                        "getScanned",
                        "setRefActionInfo"
                    ],
                    "llm_response_time": 2639
                },
                {
                    "iteration_num": 3,
                    "suggested_method_names": [
                        "setScanned",
                        "getScanned",
                        "setRefActionInfo"
                    ],
                    "llm_response_time": 2559
                },
                {
                    "iteration_num": -1,
                    "suggested_method_names": [
                        "setScanned",
                        "getScanned",
                        "setRefActionInfo"
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "setRefActionInfo",
                    "setScanned",
                    "getScanned"
                ],
                "llm_response_time": 549
            },
            "targetClassMap": {
                "setRefActionInfo": {
                    "target_classes": [
                        {
                            "class_name": "DMLModStatementNode",
                            "similarity_score": 0.13635242737868983
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "DMLModStatementNode"
                    ],
                    "llm_response_time": 972,
                    "similarity_computation_time": 8,
                    "similarity_metric": "cosine"
                },
                "setScanned": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1528,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                },
                "getScanned": {
                    "target_classes": [],
                    "target_classes_sorted_by_llm": [],
                    "llm_response_time": 1403,
                    "similarity_computation_time": 0,
                    "similarity_metric": "cosine"
                }
            }
        }
    },
    {
        "oracle": "- method org.apache.derby.impl.sql.compile.SubqueryList::setSharedState(String, java.io.Serializable):void need move to org.apache.derby.impl.sql.compile.FromVTI",
        "class_name": "org.apache.derby.impl.sql.compile.SubqueryList",
        "telemetry": {
            "id": "12ad6756-75a3-4e45-9fdd-06d7395b1679",
            "hostFunctionTelemetryData": {
                "hostFunctionSize": 231,
                "lineStart": 31,
                "lineEnd": 261,
                "bodyLineStart": 31,
                "language": "java",
                "sourceCode": "/**\n * A SubqueryList represents a list of subquerys within a specific clause \n * (select, where or having) in a DML statement.  It extends QueryTreeNodeVector.\n *\n */\n\npublic class SubqueryList extends QueryTreeNodeVector\n{\n\t/**\n\t * Add a subquery to the list.\n\t *\n\t * @param subqueryNode\tA SubqueryNode to add to the list\n\t *\n\t */\n\n\tpublic void addSubqueryNode(SubqueryNode subqueryNode) throws StandardException\n\t{\n\t\taddElement(subqueryNode);\n\t}\n\n\t/**\n\t * Preprocess a SubqueryList.  For now, we just preprocess each SubqueryNode\n\t * in the list.\n\t *\n\t * @param\tnumTables\t\t\tNumber of tables in the DML Statement\n\t * @param\touterFromList\t\tFromList from outer query block\n\t * @param\touterSubqueryList\tSubqueryList from outer query block\n\t * @param\touterPredicateList\tPredicateList from outer query block\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\tpublic void preprocess(int numTables,\n\t\t\t\t\t\t\tFromList outerFromList,\n\t\t\t\t\t\t\tSubqueryList outerSubqueryList,\n\t\t\t\t\t\t\tPredicateList outerPredicateList) \n\t\t\t\tthrows StandardException\n\t{\n\t\tSubqueryNode\tsubqueryNode;\n\n\t\tint size = size();\n\t\tfor (int index = 0; index < size; index++)\n\t\t{\n\t\t\tsubqueryNode = (SubqueryNode) elementAt(index);\n\t\t\tsubqueryNode.preprocess(numTables, outerFromList,\n\t\t\t\t\t\t\t\t\touterSubqueryList,\n\t\t\t\t\t\t\t\t\touterPredicateList);\n\t\t}\n\t}\n\n\t/**\n\t * Optimize the subqueries in this list.  \n\t *\n\t * @param dataDictionary\tThe data dictionary to use for optimization\n\t * @param outerRows\t\t\tThe optimizer's estimate of the number of\n\t *\t\t\t\t\t\t\ttimes this subquery will be executed.\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\n\tpublic void optimize(DataDictionary dataDictionary, double outerRows)\n\t\t\tthrows StandardException\n\t{\n\t\tint size = size();\n\t\tfor (int index = 0; index < size; index++)\n\t\t{\n\t\t\tSubqueryNode\tsubqueryNode;\n\t\t\tsubqueryNode = (SubqueryNode) elementAt(index);\n\t\t\tsubqueryNode.optimize(dataDictionary, outerRows);\n\t\t}\n\t}\n\n\t/**\n\t * Modify the access paths for all subqueries in this list.\n\t *\n\t * @see ResultSetNode#modifyAccessPaths\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\tpublic void modifyAccessPaths()\n\t\t\tthrows StandardException\n\t{\n\t\tint size = size();\n\t\tfor (int index = 0; index < size; index++)\n\t\t{\n\t\t\tSubqueryNode\tsubqueryNode;\n\t\t\tsubqueryNode = (SubqueryNode) elementAt(index);\n\t\t\tsubqueryNode.modifyAccessPaths();\n\t\t}\n\t}\n\n\t/**\n\t * Search to see if a query references the specifed table name.\n\t *\n\t * @param name\t\tTable name (String) to search for.\n\t * @param baseTable\tWhether or not name is for a base table\n\t *\n\t * @return\ttrue if found, else false\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\tpublic boolean referencesTarget(String name, boolean baseTable)\n\t\tthrows StandardException\n\t{\n\t\tint size = size();\n\t\tfor (int index = 0; index < size; index++)\n\t\t{\n\t\t\tSubqueryNode\tsubqueryNode;\n\n\t\t\tsubqueryNode = (SubqueryNode) elementAt(index);\n\t\t\tif (subqueryNode.isMaterializable())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (subqueryNode.getResultSet().referencesTarget(name, baseTable))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return true if the node references SESSION schema tables (temporary or permanent)\n\t *\n\t * @return\ttrue if references SESSION schema tables, else false\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\tpublic boolean referencesSessionSchema()\n\t\tthrows StandardException\n\t{\n\t\tint size = size();\n\t\tfor (int index = 0; index < size; index++)\n\t\t{\n\t\t\tSubqueryNode\tsubqueryNode;\n\n\t\t\tsubqueryNode = (SubqueryNode) elementAt(index);\n\n\t\t\tif (subqueryNode.getResultSet().referencesSessionSchema())\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Set the point of attachment in all subqueries in this list.\n\t *\n\t * @param pointOfAttachment\t\tThe point of attachment\n\t *\n\t * @exception StandardException\t\t\tThrown on error\n\t */\n\tpublic void setPointOfAttachment(int pointOfAttachment)\n\t\tthrows StandardException\n\t{\n\t\tint size = size();\n\n\t\tfor (int index = 0; index < size; index++)\n\t\t{\n\t\t\tSubqueryNode\tsubqueryNode;\n\n\t\t\tsubqueryNode = (SubqueryNode) elementAt(index);\n\t\t\tsubqueryNode.setPointOfAttachment(pointOfAttachment);\n\t\t}\n\t}\n\n\t/**\n\t * Decrement (query block) level (0-based) for \n\t * all of the tables in this subquery list.\n\t * This is useful when flattening a subquery.\n\t *\n\t * @param decrement\tThe amount to decrement by.\n\t */\n\tvoid decrementLevel(int decrement)\n\t{\n\t\tint size = size();\n\n\t\tfor (int index = 0; index < size; index++)\n\t\t{\n\t\t\t((SubqueryNode) elementAt(index)).getResultSet().decrementLevel(decrement);\n\t\t}\n\t}\n\n\t/**\n     * Mark all of the subqueries in this \n     * list as being part of a having clause,\n     * so we can avoid flattenning later.\n\t * \n\t */\n\tpublic void markHavingSubqueries() {\n\t    int size = size();\n\t    \n\t    for (int index = 0; index < size; index++)\n\t    {\n\t        SubqueryNode    subqueryNode;\n\n\t        subqueryNode = (SubqueryNode) elementAt(index);\n\t        subqueryNode.setHavingSubquery(true);\n\t    }\n\t}\n\n\t/**\n\t * Mark all of the subqueries in this list as being part of a where clause\n\t * so we can avoid flattening later if needed.\n\t */\n\tpublic void markWhereSubqueries() {\n\t\tint size = size();\n\t\tfor (int index = 0; index < size; index++)\n\t\t{\n\t\t\tSubqueryNode    subqueryNode;\n\n\t\t\tsubqueryNode = (SubqueryNode) elementAt(index);\n\t\t\tsubqueryNode.setWhereSubquery(true);\n\t\t}\n\t}\n\n\tpublic void setSharedState(FromVTI fromVTI, String key, Serializable value) {\n\t\n\t\tif (key == null)\n\t\t\treturn;\n\t\n\t\tif (fromVTI.compileTimeConstants == null)\n\t\t\tfromVTI.compileTimeConstants = new FormatableHashtable();\n\t\n\t\tfromVTI.compileTimeConstants.put(key, value);\n\t}\n}"
            },
            "candidatesTelemetryData": {
                "numberOfSuggestions": 1,
                "candidates": [
                    {
                        "lineStart": 250,
                        "lineEnd": 259,
                        "refactoringType": "MyMoveMethodRefactoring",
                        "description": "Move method to org.apache.derby.impl.sql.compile.FromVTI\nRationale: The method setSharedState directly manipulates the compileTimeConstants property of the FromVTI class, making it logical for the method to reside within the FromVTI class itself.",
                        "couldCreateRefObject": true,
                        "applied": false,
                        "undone": false
                    }
                ]
            },
            "processingTime": {
                "llmResponseTime": -1,
                "pluginProcessingTime": -1,
                "totalTime": 6288
            },
            "iterationData": [
                {
                    "iteration_num": 1,
                    "suggested_method_names": [
                        "setSharedState"
                    ],
                    "llm_response_time": 3137
                },
                {
                    "iteration_num": 2,
                    "suggested_method_names": [
                        "setSharedState"
                    ],
                    "llm_response_time": 1331
                },
                {
                    "iteration_num": 3,
                    "suggested_method_names": [
                        "setSharedState"
                    ],
                    "llm_response_time": 1219
                },
                {
                    "iteration_num": -1,
                    "suggested_method_names": [
                        "setSharedState"
                    ],
                    "llm_response_time": 0
                }
            ],
            "llmMethodPriority": {
                "priority_method_names": [
                    "setSharedState"
                ],
                "llm_response_time": 502
            },
            "targetClassMap": {
                "setSharedState": {
                    "target_classes": [
                        {
                            "class_name": "FromVTI",
                            "similarity_score": 0.3132054925887995
                        }
                    ],
                    "target_classes_sorted_by_llm": [
                        "FromVTI"
                    ],
                    "llm_response_time": 841,
                    "similarity_computation_time": 4,
                    "similarity_metric": "cosine"
                }
            }
        }
    }
]