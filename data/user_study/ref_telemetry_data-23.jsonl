{"id":"b47351f6-7c1c-4693-90bd-198f2bfca1cf","hostFunctionTelemetryData":{"hostFunctionSize":180,"lineStart":13,"lineEnd":192,"bodyLineStart":13,"language":"java","filePath":"C:/Users/khush/IdeaProjects/BreakingTheTower/src/main/java/com/mojang/tower/data/Bitmaps.java","sourceCode":"public class Bitmaps implements Serializable {\n\n    private static final Logger LOGGER \u003d LoggerFactory.getLogger(Bitmaps.class);\n\n    private static final String RESOURCE_PATH \u003d \"res/\";\n    private static final String LOGO_PATH \u003d RESOURCE_PATH + \"logo.gif\";\n    private static final String WON_SCREEN_PATH \u003d RESOURCE_PATH + \"winscreen.gif\";\n    private static final String SHEET_PATH \u003d RESOURCE_PATH + \"sheet.gif\";\n    private static final String ISLAND_PATH \u003d RESOURCE_PATH + \"island.gif\";\n\n    private BufferedImage[] trees;\n    private BufferedImage[] farmPlots;\n    private BufferedImage[] rocks;\n    private BufferedImage[] carriedResources;\n    private BufferedImage[][] peons;\n    private BufferedImage island;\n    private BufferedImage towerTop;\n    private BufferedImage towerMid;\n    private BufferedImage towerBot;\n    private BufferedImage[] smoke;\n    private BufferedImage[] infoPuffs;\n    private BufferedImage[][] houses;\n    private BufferedImage delete, help;\n    private BufferedImage[] soundButtons;\n\n    private BufferedImage logo, wonScreen;\n\n    public void loadAll() throws IOException {\n        try {\n\n            logo \u003d ImageIO.read(new FileInputStream(LOGO_PATH));\n            wonScreen \u003d ImageIO.read(new FileInputStream(WON_SCREEN_PATH));\n            BufferedImage src \u003d ImageIO.read(new FileInputStream(SHEET_PATH));\n\n            trees \u003d new BufferedImage[16];\n            for (int i \u003d 0; i \u003c 16; i++)\n                trees[i] \u003d clip(src, 32 + i * 8, 0, 8, 16);\n\n            farmPlots \u003d new BufferedImage[9];\n            for (int i \u003d 0; i \u003c 9; i++)\n                farmPlots[i] \u003d clip(src, 32 + i * 8, 11 * 8, 8, 8);\n\n            rocks \u003d new BufferedImage[4];\n            for (int i \u003d 0; i \u003c 4; i++)\n                rocks[i] \u003d clip(src, 32 + 12 * 8 + i * 8, 16, 8, 8);\n\n            carriedResources \u003d new BufferedImage[4];\n            for (int i \u003d 0; i \u003c 4; i++)\n                carriedResources[i] \u003d clip(src, 32 + 12 * 8 + i * 8, 16 + 16, 8, 8);\n\n            delete \u003d clip(src, 32 + 16 * 8 + 3 * 16, 0, 16, 16);\n            help \u003d clip(src, 32 + 16 * 8 + 3 * 16, 16, 16, 16);\n            soundButtons \u003d new BufferedImage[2];\n            for (int i \u003d 0; i \u003c 2; i++)\n                soundButtons[i] \u003d clip(src, 32 + 16 * 8 + 3 * 16, 32 + i * 16, 16, 16);\n\n            houses \u003d new BufferedImage[3][8];\n            for (int x \u003d 0; x \u003c 3; x++)\n                for (int y \u003d 0; y \u003c 8; y++)\n                    houses[x][y] \u003d clip(src, 32 + 16 * 8 + x * 16, y * 16, 16, 16);\n\n            peons \u003d new BufferedImage[4][3 * 4];\n            for (int i \u003d 0; i \u003c 4; i++)\n                for (int j \u003d 0; j \u003c 3 * 4; j++)\n                    peons[i][j] \u003d clip(src, 32 + j * 8, 16 + i * 8, 8, 8);\n\n            towerTop \u003d clip(src, 0, 0, 32, 16);\n            towerMid \u003d clip(src, 0, 16, 32, 8);\n            towerBot \u003d clip(src, 0, 24, 32, 8);\n\n            smoke \u003d new BufferedImage[5];\n            for (int i \u003d 0; i \u003c 5; i++)\n                smoke[i] \u003d clip(src, 256 - 8, i * 8, 8, 8);\n\n            infoPuffs \u003d new BufferedImage[5];\n            for (int i \u003d 0; i \u003c 5; i++)\n                infoPuffs[i] \u003d clip(src, 256 - 8 - 16, i * 8, 16, 8);\n\n            island \u003d new BufferedImage(256, 256, BufferedImage.TYPE_INT_ARGB);\n            int[] pixels \u003d new int[256 * 256];\n            ImageIO.read(new FileInputStream(ISLAND_PATH)).getRGB(0, 0, 256, 256, pixels, 0, 256);\n            island.setRGB(0, 0, 256, 256, pixels, 0, 256);\n\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to load images\", e);\n        }\n\n    }\n\n    public static BufferedImage clip(BufferedImage src, int x, int y, int w, int h) {\n        GraphicsEnvironment ge \u003d GraphicsEnvironment.getLocalGraphicsEnvironment();\n        BufferedImage newImage \u003d null;\n\n        try {\n            GraphicsDevice screen \u003d ge.getDefaultScreenDevice();\n            GraphicsConfiguration gc \u003d screen.getDefaultConfiguration();\n            newImage \u003d gc.createCompatibleImage(w, h, Transparency.BITMASK);\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to create compatible image, falling back to default\", e);\n        }\n\n        if (newImage \u003d\u003d null) {\n            newImage \u003d new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n        }\n\n        int[] pixels \u003d new int[w * h];\n        src.getRGB(x, y, w, h, pixels, 0, w);\n        newImage.setRGB(0, 0, w, h, pixels, 0, w);\n\n        return newImage;\n    }\n\n    public BufferedImage[] getTrees() {\n        return trees;\n    }\n\n    public BufferedImage[] getFarmPlots() {\n        return farmPlots;\n    }\n\n    public BufferedImage[] getRocks() {\n        return rocks;\n    }\n\n    public BufferedImage[] getCarriedResources() {\n        return carriedResources;\n    }\n\n    public BufferedImage[][] getPeons() {\n        return peons;\n    }\n\n    public BufferedImage getIsland() {\n        return island;\n    }\n\n    public BufferedImage getTowerTop() {\n        return towerTop;\n    }\n\n    public BufferedImage getTowerMid() {\n        return towerMid;\n    }\n\n    public BufferedImage getTowerBot() {\n        return towerBot;\n    }\n\n    public BufferedImage[] getSmoke() {\n        return smoke;\n    }\n\n    public BufferedImage[] getInfoPuffs() {\n        return infoPuffs;\n    }\n\n    public BufferedImage[][] getHouses() {\n        return houses;\n    }\n\n    public BufferedImage getDelete() {\n        return delete;\n    }\n\n    public BufferedImage getHelp() {\n        return help;\n    }\n\n    public BufferedImage[] getSoundButtons() {\n        return soundButtons;\n    }\n\n    public BufferedImage getLogo() {\n        return logo;\n    }\n\n    public BufferedImage getWonScreen() {\n        return wonScreen;\n    }\n}","methodCount":19,"staticMethodCount":1,"instanceMethodCount":18,"classLoc":180,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"754cae34-cab4-4920-ace9-deb7b7a9ed07","hostFunctionTelemetryData":{"hostFunctionSize":85,"lineStart":5,"lineEnd":89,"bodyLineStart":5,"language":"java","filePath":"C:/Users/khush/IdeaProjects/BreakingTheTower/src/main/java/com/mojang/tower/data/HouseType.java","sourceCode":"public class HouseType {\n    public static final HouseType[] houseTypes \u003d new HouseType[8];\n\n    public static final HouseType MASON \u003d new HouseType(1, \"Mason\", 10, 0, 15, 0).setAcceptsResource(Resources.RESOURCE_ROCK_ID);\n    public static final HouseType WOODCUTTER \u003d new HouseType(2, \"Woodcutter\", 10, 15, 0, 0).setAcceptsResource(Resources.RESOURCE_WOOD_ID);\n    public static final HouseType PLANTER \u003d new HouseType(0, \"Planter\", 10, 30, 15, 10);\n    public static final HouseType FARM \u003d new HouseType(6, \"Farmer\", 10, 30, 30, 0);\n    public static final HouseType WINDMILL \u003d new HouseType(7, \"Miller\", 8, 15, 15, 0).setAcceptsResource(Resources.RESOURCE_FOOD_ID);\n    public static final HouseType GUARDPOST \u003d new HouseType(5, \"Guardpost\", 3, 0, 30, 0);\n    public static final HouseType BARRACKS \u003d new HouseType(3, \"Barracks\", 10, 15, 50, 0);\n    public static final HouseType RESIDENCE \u003d new HouseType(4, \"Residence\", 10, 30, 30, 30);\n\n    private final int image;\n    private final int radius;\n    private final String name;\n    private final int wood, rock, food;\n    private int acceptResource \u003d -1;\n\n    private static int id \u003d 0;\n\n    private HouseType(int image, String name, int radius, int wood, int rock, int food) {\n        this.image \u003d image;\n        this.name \u003d name;\n        this.radius \u003d radius;\n        this.wood \u003d wood;\n        this.rock \u003d rock;\n        this.food \u003d food;\n        houseTypes[id++] \u003d this;\n    }\n\n    private HouseType setAcceptsResource(int acceptResource) {\n        this.acceptResource \u003d acceptResource;\n        return this;\n    }\n\n    public BufferedImage getImage(Bitmaps bitmaps) {\n        return bitmaps.getHouses()[image % 2 + 1][image / 2];\n    }\n\n    public String getString() {\n        String res \u003d name + \" [\";\n        if (wood \u003e 0) res +\u003d \" wood:\" + wood;\n        if (rock \u003e 0) res +\u003d \" rock:\" + rock;\n        if (food \u003e 0) res +\u003d \" food:\" + food;\n        res +\u003d \" ]\";\n        return res;\n    }\n\n    public String getDescription() {\n        if (this \u003d\u003d MASON) return \"Gathers nearby stones, produces rock\";\n        if (this \u003d\u003d WOODCUTTER) return \"Cuts down nearby trees, produces wood\";\n        if (this \u003d\u003d PLANTER) return \"Plants new trees that can later be cut down\";\n        if (this \u003d\u003d FARM) return \"Plants crops that can later be harvested\";\n        if (this \u003d\u003d WINDMILL) return \"Gathers nearby grown crops, produces food\";\n        if (this \u003d\u003d GUARDPOST) return \"Peons and warriors generally stay near these\";\n        if (this \u003d\u003d BARRACKS) return \"Converts peons into warriors for 5 wood each\";\n        if (this \u003d\u003d RESIDENCE) return \"Produces peons for 5 food each\";\n\n        return \"**unknown**\";\n    }\n\n    public int getRadius() {\n        return radius;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getWood() {\n        return wood;\n    }\n\n    public int getRock() {\n        return rock;\n    }\n\n    public int getFood() {\n        return food;\n    }\n\n    public int getAcceptResource() {\n        return acceptResource;\n    }\n}","methodCount":11,"staticMethodCount":0,"instanceMethodCount":11,"classLoc":85,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":6518},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"getImage","method_signature":"public getImage(Bitmaps bitmaps)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"getImage","method_signature":"public getImage(Bitmaps bitmaps)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public getImage(Bitmaps bitmaps)":{"first":{"method_name":"getImage","method_signature":"public getImage(Bitmaps bitmaps)","target_class":"","rationale":""},"second":0.311679164238191}},"targetClassMap":{"getImage":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":6337,"similarity_computation_time":0,"similarity_metric":"cosine"}}}
{"id":"e61b19b8-dc1a-4a54-b7f8-5c0afd9fad7b","hostFunctionTelemetryData":{"hostFunctionSize":61,"lineStart":3,"lineEnd":63,"bodyLineStart":3,"language":"java","filePath":"C:/Users/khush/IdeaProjects/BreakingTheTower/src/main/java/com/mojang/tower/data/Resources.java","sourceCode":"public class Resources\n{\n    public static final int RESOURCE_WOOD_ID \u003d 0;\n    public static final int RESOURCE_ROCK_ID \u003d 1;\n    public static final int RESOURCE_FOOD_ID \u003d 2;\n    \n    private int wood \u003d 100;\n    private int rock \u003d 100;\n    private int food \u003d 100;\n    \n    public void add(int resourceId, int count)\n    {\n        switch(resourceId)\n        {\n            case RESOURCE_WOOD_ID: wood+\u003dcount; break;\n            case RESOURCE_ROCK_ID: rock+\u003dcount; break;\n            case RESOURCE_FOOD_ID: food+\u003dcount; break;\n        }\n    }\n\n    public void charge(HouseType type) {\n        wood -\u003d type.getWood();\n        rock -\u003d type.getRock();\n        food -\u003d type.getFood();\n    }\n\n    public boolean canAfford(HouseType type) {\n        if (wood \u003c type.getWood()) return false;\n        if (rock \u003c type.getRock()) return false;\n        if (food \u003c type.getFood()) return false;\n        return true;\n    }\n\n    public int getWood() {\n        return wood;\n    }\n\n    public int getRock() {\n        return rock;\n    }\n\n    public int getFood() {\n        return food;\n    }\n\n    public void decreaseWood(int value) {\n        this.wood -\u003d value;\n    }\n\n    public void decreaseFood(int value) {\n        this.food -\u003d value;\n    }\n\n    public void increaseWood(int value) {\n        this.wood +\u003d value;\n    }\n\n    public void increaseRock(int value) {\n        this.rock +\u003d value;\n    }\n}","methodCount":10,"staticMethodCount":0,"instanceMethodCount":10,"classLoc":61,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":8430},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"charge","method_signature":"public charge(HouseType type)","target_class":"","rationale":""},{"method_name":"canAfford","method_signature":"public canAfford(HouseType type)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"canAfford","method_signature":"public canAfford(HouseType type)","target_class":"","rationale":""},{"method_name":"charge","method_signature":"public charge(HouseType type)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public canAfford(HouseType type)":{"first":{"method_name":"canAfford","method_signature":"public canAfford(HouseType type)","target_class":"","rationale":""},"second":0.2329767706236124},"public charge(HouseType type)":{"first":{"method_name":"charge","method_signature":"public charge(HouseType type)","target_class":"","rationale":""},"second":0.38843813059795285}},"targetClassMap":{"canAfford":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":3776,"similarity_computation_time":0,"similarity_metric":"cosine"},"charge":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":4610,"similarity_computation_time":0,"similarity_metric":"cosine"}}}
{"id":"2d2b4fda-45bb-4e97-80f8-b74342b15212","hostFunctionTelemetryData":{"hostFunctionSize":208,"lineStart":5,"lineEnd":212,"bodyLineStart":5,"language":"java","filePath":"C:/Users/khush/IdeaProjects/BreakingTheTower/src/main/java/com/mojang/tower/sound/Sound.java","sourceCode":"public abstract class Sound {\n    public static class Select extends Sound {\n        public Select() {\n            super(10);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                buffer[i] +\u003d ((i * 3000 / Sounds.SAMPLE_RATE) % 2 * 180 - 90) * (duration - p) / duration;\n            }\n        }\n    }\n\n    public static class Plant extends Sound {\n        int val \u003d 0;\n\n        public Plant() {\n            super(250);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                if (p % 20 \u003d\u003d 0) val \u003d random.nextInt(180) - 90;\n                buffer[i] +\u003d (val) * (duration - p) / duration;\n            }\n        }\n    }\n\n    public static class FinishBuilding extends Sound {\n        int val \u003d 0;\n\n        public FinishBuilding() {\n            super(50);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                if (p % 11 \u003d\u003d 0) val \u003d random.nextInt(100) - 50;\n                buffer[i] +\u003d (val);\n            }\n        }\n    }\n\n    public static class Gather extends Sound {\n        int val \u003d 0;\n\n        public Gather() {\n            super(10);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                if (p % 4 \u003d\u003d 0) val \u003d random.nextInt(100) - 50;\n                buffer[i] +\u003d (val);\n            }\n        }\n    }\n\n    public static class Destroy extends Sound {\n        int val \u003d 0;\n\n        public Destroy() {\n            super(1000);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                if (p % 60 \u003d\u003d 0) val \u003d random.nextInt(256) - 128;\n                buffer[i] +\u003d (val) * (duration - p) / duration * (duration - p) / duration;\n            }\n        }\n    }\n\n    public static class Spawn extends Sound {\n        public Spawn() {\n            super(200);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                int rate \u003d 1000 + p * 2000 / duration * p / duration;\n                buffer[i] +\u003d ((i * rate / Sounds.SAMPLE_RATE) % 2 * 180 - 90) * (duration - p) / duration * (duration - p) / duration / 2;\n            }\n        }\n    }\n\n    public static class SpawnWarrior extends Sound {\n        public SpawnWarrior() {\n            super(400);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                int rate \u003d 800 - p * 200 / duration * p / duration;\n                buffer[i] +\u003d ((i * rate / Sounds.SAMPLE_RATE) % 2 * 180 - 90) * (duration - p) / duration * (duration - p) / duration / 2;\n            }\n        }\n    }\n\n    public static class Ding extends Sound {\n        public Ding() {\n            super(200);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                double rate \u003d 2000 + p * 1000 / duration;\n                if (p \u003c duration / 2)\n                    rate \u003d 5000 - rate;\n                buffer[i] +\u003d (int) (Math.sin(p * rate / Sounds.SAMPLE_RATE * Math.PI * 2) * 120) * (duration - p) / duration;\n            }\n        }\n    }\n\n    public static class WinSound extends Sound {\n        public WinSound() {\n            super(200 * 5);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                int d \u003d duration / 5;\n                double volume \u003d 1 - (p % d) / (double) d;\n                double rate \u003d 440 * Math.pow(2, p / d / 6.0);\n                double tone \u003d Math.sin(p * rate / Sounds.SAMPLE_RATE * Math.PI * 2) * 120;\n                buffer[i] +\u003d (int) (tone * volume);\n            }\n        }\n    }\n\n    public static class Death extends Sound {\n        public Death() {\n            super(250);\n        }\n\n        ;\n        double noise \u003d 0;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                double rate \u003d 3000 - p * 100 / duration * p / duration;\n                rate /\u003d 2;\n\n                noise \u003d noise + (random.nextDouble() * 200 - 100 - noise) * 0.6;\n                double smp2 \u003d Math.sin(p * rate / Sounds.SAMPLE_RATE * Math.PI * 2) * 120;\n                double smp1 \u003d noise;\n                double smp \u003d smp1 + (smp2 - smp1) * p / duration;\n                buffer[i] +\u003d (int) (smp) * (duration - p) / duration;\n            }\n        }\n    }\n\n    public static class MonsterDeath extends Sound {\n        public MonsterDeath() {\n            super(250);\n        }\n\n        ;\n        double noise \u003d 0;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                double rate \u003d 1000 + p * 100 / duration * p / duration;\n                rate /\u003d 2;\n\n                noise \u003d noise + (random.nextDouble() * 200 - 100 - noise) * 0.8;\n                double smp2 \u003d Math.sin(p * rate / Sounds.SAMPLE_RATE * Math.PI * 2) * 120;\n                double smp1 \u003d noise;\n                double smp \u003d smp1 + (smp2 - smp1) * p / duration;\n                buffer[i] +\u003d (int) (smp) * (duration - p) / duration;\n            }\n        }\n    }\n\n    protected int p \u003d 0;\n    protected int duration;\n    protected Random random \u003d new Random();\n\n    protected Sound(int ms) {\n        duration \u003d Sounds.SAMPLE_RATE * ms / 1000;\n    }\n\n    public boolean read(int[] buffer, int len) {\n        if (p + len \u003e duration) len \u003d duration - p;\n        fill(buffer, len);\n        return p \u003c\u003d duration;\n    }\n\n    protected abstract void fill(int[] buffer, int len);\n}","methodCount":25,"staticMethodCount":0,"instanceMethodCount":25,"classLoc":208,"innerClassCount":11},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"056fe731-49a0-4e34-b9d0-3fc6d519b6f7","hostFunctionTelemetryData":{"hostFunctionSize":208,"lineStart":5,"lineEnd":212,"bodyLineStart":5,"language":"java","filePath":"C:/Users/khush/IdeaProjects/BreakingTheTower/src/main/java/com/mojang/tower/sound/Sound.java","sourceCode":"public abstract class Sound {\n    public static class Select extends Sound {\n        public Select() {\n            super(10);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                buffer[i] +\u003d ((i * 3000 / Sounds.SAMPLE_RATE) % 2 * 180 - 90) * (duration - p) / duration;\n            }\n        }\n    }\n\n    public static class Plant extends Sound {\n        int val \u003d 0;\n\n        public Plant() {\n            super(250);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                if (p % 20 \u003d\u003d 0) val \u003d random.nextInt(180) - 90;\n                buffer[i] +\u003d (val) * (duration - p) / duration;\n            }\n        }\n    }\n\n    public static class FinishBuilding extends Sound {\n        int val \u003d 0;\n\n        public FinishBuilding() {\n            super(50);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                if (p % 11 \u003d\u003d 0) val \u003d random.nextInt(100) - 50;\n                buffer[i] +\u003d (val);\n            }\n        }\n    }\n\n    public static class Gather extends Sound {\n        int val \u003d 0;\n\n        public Gather() {\n            super(10);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                if (p % 4 \u003d\u003d 0) val \u003d random.nextInt(100) - 50;\n                buffer[i] +\u003d (val);\n            }\n        }\n    }\n\n    public static class Destroy extends Sound {\n        int val \u003d 0;\n\n        public Destroy() {\n            super(1000);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                if (p % 60 \u003d\u003d 0) val \u003d random.nextInt(256) - 128;\n                buffer[i] +\u003d (val) * (duration - p) / duration * (duration - p) / duration;\n            }\n        }\n    }\n\n    public static class Spawn extends Sound {\n        public Spawn() {\n            super(200);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                int rate \u003d 1000 + p * 2000 / duration * p / duration;\n                buffer[i] +\u003d ((i * rate / Sounds.SAMPLE_RATE) % 2 * 180 - 90) * (duration - p) / duration * (duration - p) / duration / 2;\n            }\n        }\n    }\n\n    public static class SpawnWarrior extends Sound {\n        public SpawnWarrior() {\n            super(400);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                int rate \u003d 800 - p * 200 / duration * p / duration;\n                buffer[i] +\u003d ((i * rate / Sounds.SAMPLE_RATE) % 2 * 180 - 90) * (duration - p) / duration * (duration - p) / duration / 2;\n            }\n        }\n    }\n\n    public static class Ding extends Sound {\n        public Ding() {\n            super(200);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                double rate \u003d 2000 + p * 1000 / duration;\n                if (p \u003c duration / 2)\n                    rate \u003d 5000 - rate;\n                buffer[i] +\u003d (int) (Math.sin(p * rate / Sounds.SAMPLE_RATE * Math.PI * 2) * 120) * (duration - p) / duration;\n            }\n        }\n    }\n\n    public static class WinSound extends Sound {\n        public WinSound() {\n            super(200 * 5);\n        }\n\n        ;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                int d \u003d duration / 5;\n                double volume \u003d 1 - (p % d) / (double) d;\n                double rate \u003d 440 * Math.pow(2, p / d / 6.0);\n                double tone \u003d Math.sin(p * rate / Sounds.SAMPLE_RATE * Math.PI * 2) * 120;\n                buffer[i] +\u003d (int) (tone * volume);\n            }\n        }\n    }\n\n    public static class Death extends Sound {\n        public Death() {\n            super(250);\n        }\n\n        ;\n        double noise \u003d 0;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                double rate \u003d 3000 - p * 100 / duration * p / duration;\n                rate /\u003d 2;\n\n                noise \u003d noise + (random.nextDouble() * 200 - 100 - noise) * 0.6;\n                double smp2 \u003d Math.sin(p * rate / Sounds.SAMPLE_RATE * Math.PI * 2) * 120;\n                double smp1 \u003d noise;\n                double smp \u003d smp1 + (smp2 - smp1) * p / duration;\n                buffer[i] +\u003d (int) (smp) * (duration - p) / duration;\n            }\n        }\n    }\n\n    public static class MonsterDeath extends Sound {\n        public MonsterDeath() {\n            super(250);\n        }\n\n        ;\n        double noise \u003d 0;\n\n        protected void fill(int[] buffer, int len) {\n            for (int i \u003d 0; i \u003c len; i++, p++) {\n                double rate \u003d 1000 + p * 100 / duration * p / duration;\n                rate /\u003d 2;\n\n                noise \u003d noise + (random.nextDouble() * 200 - 100 - noise) * 0.8;\n                double smp2 \u003d Math.sin(p * rate / Sounds.SAMPLE_RATE * Math.PI * 2) * 120;\n                double smp1 \u003d noise;\n                double smp \u003d smp1 + (smp2 - smp1) * p / duration;\n                buffer[i] +\u003d (int) (smp) * (duration - p) / duration;\n            }\n        }\n    }\n\n    protected int p \u003d 0;\n    protected int duration;\n    protected Random random \u003d new Random();\n\n    protected Sound(int ms) {\n        duration \u003d Sounds.SAMPLE_RATE * ms / 1000;\n    }\n\n    public boolean read(int[] buffer, int len) {\n        if (p + len \u003e duration) len \u003d duration - p;\n        fill(buffer, len);\n        return p \u003c\u003d duration;\n    }\n\n    protected abstract void fill(int[] buffer, int len);\n}","methodCount":25,"staticMethodCount":0,"instanceMethodCount":25,"classLoc":208,"innerClassCount":11},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"25c70c6e-2a1a-41e3-b239-2af9dadc0ab1","hostFunctionTelemetryData":{"hostFunctionSize":222,"lineStart":10,"lineEnd":231,"bodyLineStart":10,"language":"java","filePath":"C:/Users/khush/IdeaProjects/BreakingTheTower/src/main/java/com/mojang/tower/model/House.java","sourceCode":"public class House extends Entity {\n    private static final int POPULATION_PER_RESIDENCE \u003d 10;\n    private static final int WARRIORS_PER_BARRACKS \u003d 5;\n    public static final int FOOD_PER_PEON \u003d 5;\n    public static final int WOOD_PER_WARRIOR \u003d 5;\n\n\n    private static final int DEFAULT_BUILD_DURATION \u003d 192; // 32 * 6\n\n    private static final int DEFAULT_MAX_HP \u003d 256;\n\n    private static final int HP_INCREMENT \u003d 1;\n\n    private HouseType type;\n    private int buildTime;\n    private int buildDuration;\n    private int maxHp;\n    private int hp;\n\n    public House(double x, double y, HouseType type) {\n        super(x, y, type.getRadius());\n        this.type \u003d type;\n        this.buildDuration \u003d DEFAULT_BUILD_DURATION;\n        this.maxHp \u003d DEFAULT_MAX_HP;\n        this.hp \u003d maxHp;\n    }\n\n    @Override\n    public void fight(Monster monster) {\n        if (hp \u003c\u003d 0) return;\n        if (--hp \u003c\u003d 0) {\n            die();\n        }\n    }\n\n    public void die() {\n        Sounds.play(new Sound.Destroy());\n        if (type \u003d\u003d HouseType.RESIDENCE) {\n            island.decreasePopulationCap(POPULATION_PER_RESIDENCE);\n        }\n        if (type \u003d\u003d HouseType.BARRACKS) {\n            island.decreaseWarriorPopulationCap(WARRIORS_PER_BARRACKS);\n        }\n        alive \u003d false;\n    }\n\n    public void complete() {\n        hp \u003d maxHp;\n        buildTime \u003d buildDuration;\n    }\n\n    public boolean acceptsResource(int resourceId) {\n        return buildTime \u003e\u003d buildDuration \u0026\u0026 type.getAcceptResource() \u003d\u003d resourceId;\n    }\n\n    public boolean submitResource(int resourceId) {\n        if (buildTime \u003e\u003d buildDuration \u0026\u0026 type.getAcceptResource() \u003d\u003d resourceId) {\n            Sounds.play(new Sound.Gather());\n            puff();\n            return true;\n        }\n        return false;\n    }\n\n    public boolean build() {\n        if (buildTime \u003c buildDuration) {\n            buildTime++;\n            hp \u003d Math.min(hp + HP_INCREMENT, maxHp);\n            if (buildTime \u003d\u003d buildDuration) {\n                Sounds.play(new Sound.FinishBuilding());\n                if (type \u003d\u003d HouseType.RESIDENCE) {\n                    island.increasePopulationCap(POPULATION_PER_RESIDENCE);\n                }\n                if (type \u003d\u003d HouseType.BARRACKS) {\n                    island.increaseWarriorPopulationCap(WARRIORS_PER_BARRACKS);\n                }\n            }\n        }\n        return buildTime \u003d\u003d buildDuration;\n    }\n\n    public void tick() {\n        if (buildTime \u003c buildDuration) {\n            for (int i \u003d 0; i \u003c 2; i++) {\n                Peon peon \u003d getRandomPeon(100, 80, true);\n                if (peon !\u003d null \u0026\u0026 peon.job \u003d\u003d null) {\n                    peon.setJob(new Job.Build(this));\n                }\n            }\n        } else {\n            if (hp \u003c maxHp \u0026\u0026 random.nextInt(4) \u003d\u003d 0) {\n                hp++;\n            }\n\n            Peon peon \u003d getRandomPeon(50, 50, true);\n            if (peon !\u003d null \u0026\u0026 peon.job \u003d\u003d null \u0026\u0026 peon.getType() \u003d\u003d 0) {\n                TargetFilter noMobFilter \u003d new TargetFilter() {\n                    public boolean accepts(Entity e) {\n                        return !(e instanceof Peon || e instanceof Monster);\n                    }\n                };\n                if (type \u003d\u003d HouseType.MASON) {\n                    peon.setJob(new Job.Gather(Resources.RESOURCE_ROCK_ID, this));\n                } else if (type \u003d\u003d HouseType.WOODCUTTER) {\n                    peon.setJob(new Job.Gather(Resources.RESOURCE_WOOD_ID, this));\n                } else if (type \u003d\u003d HouseType.WINDMILL) {\n                    peon.setJob(new Job.Gather(Resources.RESOURCE_FOOD_ID, this));\n                } else if (type \u003d\u003d HouseType.PLANTER) {\n                    if (getRandomTarget(6, 40, noMobFilter) \u003d\u003d null)\n                        peon.setJob(new Job.Plant(this, 0));\n                } else if (type \u003d\u003d HouseType.FARM) {\n                    if (getRandomTarget(6, 40, noMobFilter) \u003d\u003d null)\n                        peon.setJob(new Job.Plant(this, 1));\n                }\n            }\n\n            if (type \u003d\u003d HouseType.GUARDPOST) {\n                peon \u003d getRandomPeon(80, 80, true);\n                if (peon !\u003d null \u0026\u0026 peon.job \u003d\u003d null \u0026\u0026 (peon.getType() \u003d\u003d 0 \u0026\u0026 random.nextInt(2) \u003d\u003d 0)) {\n                    peon.setJob(new Job.Goto(this));\n                }\n            }\n\n            if (type \u003d\u003d HouseType.BARRACKS \u0026\u0026 island.getWarriorPopulation() \u003c island.getWarriorPopulationCap() \u0026\u0026 island.getResources().getWood() \u003e\u003d WOOD_PER_WARRIOR) {\n                peon \u003d getRandomPeon(80, 80, true);\n                if (peon !\u003d null \u0026\u0026 peon.job \u003d\u003d null \u0026\u0026 peon.getType() \u003d\u003d 0) {\n                    peon.setJob(new Job.GotoAndConvert(this));\n                }\n            }\n\n            if (type \u003d\u003d HouseType.RESIDENCE \u0026\u0026 island.getPopulation() \u003c island.getPopulationCap() \u0026\u0026 island.getResources().getFood() \u003e\u003d FOOD_PER_PEON \u0026\u0026 random.nextInt(20) \u003d\u003d 0) {\n                double xt \u003d x + (random.nextDouble() * 2 - 1) * 9;\n                double yt \u003d y + (random.nextDouble() * 2 - 1) * 9;\n\n                peon \u003d new Peon(xt, yt, 0);\n                if (island.isFree(peon.getX(), peon.getY(), peon.getR())) {\n                    puff();\n                    island.getResources().decreaseFood(FOOD_PER_PEON);\n                    island.addEntity(peon);\n                    Sounds.play(new Sound.Spawn());\n                }\n            }\n        }\n    }\n\n    public void destroy() {\n        if (type \u003d\u003d HouseType.RESIDENCE) {\n            island.decreasePopulationCap(POPULATION_PER_RESIDENCE);\n        }\n        if (type \u003d\u003d HouseType.BARRACKS) {\n            island.decreaseWarriorPopulationCap(POPULATION_PER_RESIDENCE);\n        }\n    }\n\n    private Peon getRandomPeon(double r, double s, final boolean mustBeFree) {\n        TargetFilter peonFilter \u003d new TargetFilter() {\n            public boolean accepts(Entity e) {\n                return e.isAlive() \u0026\u0026 (e instanceof Peon) \u0026\u0026 (!mustBeFree || ((Peon) e).job \u003d\u003d null);\n            }\n        };\n\n        Entity e \u003d getRandomTarget(r, s, peonFilter);\n        if (e instanceof Peon) {\n            Peon peon \u003d (Peon) e;\n            return peon;\n        }\n        return null;\n    }\n\n    @Override\n    public void render(Graphics2D g, double alpha) {\n\n        int xPos \u003d (int) (xr - 8);\n        int yPos \u003d calculateYPosition();\n\n        if (buildTime \u003c buildDuration) {\n            g.drawImage(bitmaps.getHouses()[0][buildTime * 6 / buildDuration], xPos, yPos, null);\n        } else {\n            g.drawImage(type.getImage(bitmaps), xPos, yPos, null);\n        }\n\n        renderHpBar(g, xPos, yPos);\n\n    }\n\n    private int calculateYPosition() {\n\n        int yPos \u003d -(int) (yr / 2 + 16 - 4);\n\n        if (type \u003d\u003d HouseType.GUARDPOST) yPos -\u003d 2;\n        if (type \u003d\u003d HouseType.WINDMILL) yPos -\u003d 1;\n\n        return yPos;\n\n    }\n\n    private void renderHpBar(Graphics2D g, int x, int y) {\n\n        if (hp \u003c maxHp) {\n            g.setColor(Color.BLACK);\n            g.fillRect(x + 4, y - 2, 8, 1);\n            g.setColor(Color.RED);\n            g.fillRect(x + 4, y - 2, hp * 8 / maxHp, 1);\n        }\n\n    }\n\n    public void puff() {\n        island.addEntity(new Puff(x, y));\n    }\n\n    public void sell() {\n        island.getResources().increaseWood(type.getWood() * 3 * hp / (maxHp * 4));\n        island.getResources().increaseRock(type.getRock() * 3 * hp / (maxHp * 4));\n        die();\n    }\n\n    @Override\n    public boolean isTargetable() {\n        return true;\n    }\n}","methodCount":18,"staticMethodCount":0,"instanceMethodCount":18,"classLoc":222,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"die","method_signature":"public die()","target_class":"","rationale":""},{"method_name":"acceptsResource","method_signature":"public acceptsResource(int resourceId)","target_class":"","rationale":""},{"method_name":"submitResource","method_signature":"public submitResource(int resourceId)","target_class":"","rationale":""},{"method_name":"build","method_signature":"public build()","target_class":"","rationale":""},{"method_name":"tick","method_signature":"public tick()","target_class":"","rationale":""},{"method_name":"destroy","method_signature":"public destroy()","target_class":"","rationale":""},{"method_name":"accepts","method_signature":"public accepts(Entity e)","target_class":"","rationale":""},{"method_name":"getRandomPeon","method_signature":"private getRandomPeon(double r, double s, final boolean mustBeFree)","target_class":"","rationale":""},{"method_name":"puff","method_signature":"public puff()","target_class":"","rationale":""},{"method_name":"sell","method_signature":"public sell()","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"sell","method_signature":"public sell()","target_class":"","rationale":""},{"method_name":"accepts","method_signature":"public accepts(Entity e)","target_class":"","rationale":""},{"method_name":"puff","method_signature":"public puff()","target_class":"","rationale":""},{"method_name":"acceptsResource","method_signature":"public acceptsResource(int resourceId)","target_class":"","rationale":""},{"method_name":"submitResource","method_signature":"public submitResource(int resourceId)","target_class":"","rationale":""},{"method_name":"getRandomPeon","method_signature":"private getRandomPeon(double r, double s, final boolean mustBeFree)","target_class":"","rationale":""},{"method_name":"tick","method_signature":"public tick()","target_class":"","rationale":""},{"method_name":"destroy","method_signature":"public destroy()","target_class":"","rationale":""},{"method_name":"die","method_signature":"public die()","target_class":"","rationale":""},{"method_name":"build","method_signature":"public build()","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public sell()":{"first":{"method_name":"sell","method_signature":"public sell()","target_class":"","rationale":""},"second":0.21535291494958003},"public accepts(Entity e)":{"first":{"method_name":"accepts","method_signature":"public accepts(Entity e)","target_class":"","rationale":""},"second":0.41521044181443484},"public puff()":{"first":{"method_name":"puff","method_signature":"public puff()","target_class":"","rationale":""},"second":0.4198130615851477},"public acceptsResource(int resourceId)":{"first":{"method_name":"acceptsResource","method_signature":"public acceptsResource(int resourceId)","target_class":"","rationale":""},"second":0.485357629919627},"public submitResource(int resourceId)":{"first":{"method_name":"submitResource","method_signature":"public submitResource(int resourceId)","target_class":"","rationale":""},"second":0.5797374494549892},"private getRandomPeon(double r, double s, final boolean mustBeFree)":{"first":{"method_name":"getRandomPeon","method_signature":"private getRandomPeon(double r, double s, final boolean mustBeFree)","target_class":"","rationale":""},"second":0.6034099327890902},"public tick()":{"first":{"method_name":"tick","method_signature":"public tick()","target_class":"","rationale":""},"second":0.708135253850083},"public destroy()":{"first":{"method_name":"destroy","method_signature":"public destroy()","target_class":"","rationale":""},"second":0.7590217952836088},"public die()":{"first":{"method_name":"die","method_signature":"public die()","target_class":"","rationale":""},"second":0.7650563974295889},"public build()":{"first":{"method_name":"build","method_signature":"public build()","target_class":"","rationale":""},"second":0.7823328641415596}},"targetClassMap":{"sell":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5619,"similarity_computation_time":0,"similarity_metric":"cosine"},"accepts":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5216,"similarity_computation_time":0,"similarity_metric":"cosine"},"puff":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":1966,"similarity_computation_time":0,"similarity_metric":"cosine"},"acceptsResource":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":3943,"similarity_computation_time":0,"similarity_metric":"cosine"},"submitResource":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":4195,"similarity_computation_time":0,"similarity_metric":"cosine"},"getRandomPeon":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":4987,"similarity_computation_time":0,"similarity_metric":"cosine"},"tick":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":7504,"similarity_computation_time":0,"similarity_metric":"cosine"},"destroy":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5022,"similarity_computation_time":0,"similarity_metric":"cosine"}}}
{"id":"03af54bf-500b-4998-ba51-2013ab756d59","hostFunctionTelemetryData":{"hostFunctionSize":222,"lineStart":10,"lineEnd":231,"bodyLineStart":10,"language":"java","filePath":"C:/Users/khush/IdeaProjects/BreakingTheTower/src/main/java/com/mojang/tower/model/House.java","sourceCode":"public class House extends Entity {\n    private static final int POPULATION_PER_RESIDENCE \u003d 10;\n    private static final int WARRIORS_PER_BARRACKS \u003d 5;\n    public static final int FOOD_PER_PEON \u003d 5;\n    public static final int WOOD_PER_WARRIOR \u003d 5;\n\n\n    private static final int DEFAULT_BUILD_DURATION \u003d 192; // 32 * 6\n\n    private static final int DEFAULT_MAX_HP \u003d 256;\n\n    private static final int HP_INCREMENT \u003d 1;\n\n    private HouseType type;\n    private int buildTime;\n    private int buildDuration;\n    private int maxHp;\n    private int hp;\n\n    public House(double x, double y, HouseType type) {\n        super(x, y, type.getRadius());\n        this.type \u003d type;\n        this.buildDuration \u003d DEFAULT_BUILD_DURATION;\n        this.maxHp \u003d DEFAULT_MAX_HP;\n        this.hp \u003d maxHp;\n    }\n\n    @Override\n    public void fight(Monster monster) {\n        if (hp \u003c\u003d 0) return;\n        if (--hp \u003c\u003d 0) {\n            die();\n        }\n    }\n\n    public void die() {\n        Sounds.play(new Sound.Destroy());\n        if (type \u003d\u003d HouseType.RESIDENCE) {\n            island.decreasePopulationCap(POPULATION_PER_RESIDENCE);\n        }\n        if (type \u003d\u003d HouseType.BARRACKS) {\n            island.decreaseWarriorPopulationCap(WARRIORS_PER_BARRACKS);\n        }\n        alive \u003d false;\n    }\n\n    public void complete() {\n        hp \u003d maxHp;\n        buildTime \u003d buildDuration;\n    }\n\n    public boolean acceptsResource(int resourceId) {\n        return buildTime \u003e\u003d buildDuration \u0026\u0026 type.getAcceptResource() \u003d\u003d resourceId;\n    }\n\n    public boolean submitResource(int resourceId) {\n        if (buildTime \u003e\u003d buildDuration \u0026\u0026 type.getAcceptResource() \u003d\u003d resourceId) {\n            Sounds.play(new Sound.Gather());\n            puff();\n            return true;\n        }\n        return false;\n    }\n\n    public boolean build() {\n        if (buildTime \u003c buildDuration) {\n            buildTime++;\n            hp \u003d Math.min(hp + HP_INCREMENT, maxHp);\n            if (buildTime \u003d\u003d buildDuration) {\n                Sounds.play(new Sound.FinishBuilding());\n                if (type \u003d\u003d HouseType.RESIDENCE) {\n                    island.increasePopulationCap(POPULATION_PER_RESIDENCE);\n                }\n                if (type \u003d\u003d HouseType.BARRACKS) {\n                    island.increaseWarriorPopulationCap(WARRIORS_PER_BARRACKS);\n                }\n            }\n        }\n        return buildTime \u003d\u003d buildDuration;\n    }\n\n    public void tick() {\n        if (buildTime \u003c buildDuration) {\n            for (int i \u003d 0; i \u003c 2; i++) {\n                Peon peon \u003d getRandomPeon(100, 80, true);\n                if (peon !\u003d null \u0026\u0026 peon.job \u003d\u003d null) {\n                    peon.setJob(new Job.Build(this));\n                }\n            }\n        } else {\n            if (hp \u003c maxHp \u0026\u0026 random.nextInt(4) \u003d\u003d 0) {\n                hp++;\n            }\n\n            Peon peon \u003d getRandomPeon(50, 50, true);\n            if (peon !\u003d null \u0026\u0026 peon.job \u003d\u003d null \u0026\u0026 peon.getType() \u003d\u003d 0) {\n                TargetFilter noMobFilter \u003d new TargetFilter() {\n                    public boolean accepts(Entity e) {\n                        return !(e instanceof Peon || e instanceof Monster);\n                    }\n                };\n                if (type \u003d\u003d HouseType.MASON) {\n                    peon.setJob(new Job.Gather(Resources.RESOURCE_ROCK_ID, this));\n                } else if (type \u003d\u003d HouseType.WOODCUTTER) {\n                    peon.setJob(new Job.Gather(Resources.RESOURCE_WOOD_ID, this));\n                } else if (type \u003d\u003d HouseType.WINDMILL) {\n                    peon.setJob(new Job.Gather(Resources.RESOURCE_FOOD_ID, this));\n                } else if (type \u003d\u003d HouseType.PLANTER) {\n                    if (getRandomTarget(6, 40, noMobFilter) \u003d\u003d null)\n                        peon.setJob(new Job.Plant(this, 0));\n                } else if (type \u003d\u003d HouseType.FARM) {\n                    if (getRandomTarget(6, 40, noMobFilter) \u003d\u003d null)\n                        peon.setJob(new Job.Plant(this, 1));\n                }\n            }\n\n            if (type \u003d\u003d HouseType.GUARDPOST) {\n                peon \u003d getRandomPeon(80, 80, true);\n                if (peon !\u003d null \u0026\u0026 peon.job \u003d\u003d null \u0026\u0026 (peon.getType() \u003d\u003d 0 \u0026\u0026 random.nextInt(2) \u003d\u003d 0)) {\n                    peon.setJob(new Job.Goto(this));\n                }\n            }\n\n            if (type \u003d\u003d HouseType.BARRACKS \u0026\u0026 island.getWarriorPopulation() \u003c island.getWarriorPopulationCap() \u0026\u0026 island.getResources().getWood() \u003e\u003d WOOD_PER_WARRIOR) {\n                peon \u003d getRandomPeon(80, 80, true);\n                if (peon !\u003d null \u0026\u0026 peon.job \u003d\u003d null \u0026\u0026 peon.getType() \u003d\u003d 0) {\n                    peon.setJob(new Job.GotoAndConvert(this));\n                }\n            }\n\n            if (type \u003d\u003d HouseType.RESIDENCE \u0026\u0026 island.getPopulation() \u003c island.getPopulationCap() \u0026\u0026 island.getResources().getFood() \u003e\u003d FOOD_PER_PEON \u0026\u0026 random.nextInt(20) \u003d\u003d 0) {\n                double xt \u003d x + (random.nextDouble() * 2 - 1) * 9;\n                double yt \u003d y + (random.nextDouble() * 2 - 1) * 9;\n\n                peon \u003d new Peon(xt, yt, 0);\n                if (island.isFree(peon.getX(), peon.getY(), peon.getR())) {\n                    puff();\n                    island.getResources().decreaseFood(FOOD_PER_PEON);\n                    island.addEntity(peon);\n                    Sounds.play(new Sound.Spawn());\n                }\n            }\n        }\n    }\n\n    public void destroy() {\n        if (type \u003d\u003d HouseType.RESIDENCE) {\n            island.decreasePopulationCap(POPULATION_PER_RESIDENCE);\n        }\n        if (type \u003d\u003d HouseType.BARRACKS) {\n            island.decreaseWarriorPopulationCap(POPULATION_PER_RESIDENCE);\n        }\n    }\n\n    private Peon getRandomPeon(double r, double s, final boolean mustBeFree) {\n        TargetFilter peonFilter \u003d new TargetFilter() {\n            public boolean accepts(Entity e) {\n                return e.isAlive() \u0026\u0026 (e instanceof Peon) \u0026\u0026 (!mustBeFree || ((Peon) e).job \u003d\u003d null);\n            }\n        };\n\n        Entity e \u003d getRandomTarget(r, s, peonFilter);\n        if (e instanceof Peon) {\n            Peon peon \u003d (Peon) e;\n            return peon;\n        }\n        return null;\n    }\n\n    @Override\n    public void render(Graphics2D g, double alpha) {\n\n        int xPos \u003d (int) (xr - 8);\n        int yPos \u003d calculateYPosition();\n\n        if (buildTime \u003c buildDuration) {\n            g.drawImage(bitmaps.getHouses()[0][buildTime * 6 / buildDuration], xPos, yPos, null);\n        } else {\n            g.drawImage(type.getImage(bitmaps), xPos, yPos, null);\n        }\n\n        renderHpBar(g, xPos, yPos);\n\n    }\n\n    private int calculateYPosition() {\n\n        int yPos \u003d -(int) (yr / 2 + 16 - 4);\n\n        if (type \u003d\u003d HouseType.GUARDPOST) yPos -\u003d 2;\n        if (type \u003d\u003d HouseType.WINDMILL) yPos -\u003d 1;\n\n        return yPos;\n\n    }\n\n    private void renderHpBar(Graphics2D g, int x, int y) {\n\n        if (hp \u003c maxHp) {\n            g.setColor(Color.BLACK);\n            g.fillRect(x + 4, y - 2, 8, 1);\n            g.setColor(Color.RED);\n            g.fillRect(x + 4, y - 2, hp * 8 / maxHp, 1);\n        }\n\n    }\n\n    public void puff() {\n        island.addEntity(new Puff(x, y));\n    }\n\n    public void sell() {\n        island.getResources().increaseWood(type.getWood() * 3 * hp / (maxHp * 4));\n        island.getResources().increaseRock(type.getRock() * 3 * hp / (maxHp * 4));\n        die();\n    }\n\n    @Override\n    public boolean isTargetable() {\n        return true;\n    }\n}","methodCount":18,"staticMethodCount":0,"instanceMethodCount":18,"classLoc":222,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":10264},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"die","method_signature":"public die()","target_class":"","rationale":""},{"method_name":"acceptsResource","method_signature":"public acceptsResource(int resourceId)","target_class":"","rationale":""},{"method_name":"submitResource","method_signature":"public submitResource(int resourceId)","target_class":"","rationale":""},{"method_name":"build","method_signature":"public build()","target_class":"","rationale":""},{"method_name":"tick","method_signature":"public tick()","target_class":"","rationale":""},{"method_name":"destroy","method_signature":"public destroy()","target_class":"","rationale":""},{"method_name":"accepts","method_signature":"public accepts(Entity e)","target_class":"","rationale":""},{"method_name":"getRandomPeon","method_signature":"private getRandomPeon(double r, double s, final boolean mustBeFree)","target_class":"","rationale":""},{"method_name":"puff","method_signature":"public puff()","target_class":"","rationale":""},{"method_name":"sell","method_signature":"public sell()","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"sell","method_signature":"public sell()","target_class":"","rationale":""},{"method_name":"accepts","method_signature":"public accepts(Entity e)","target_class":"","rationale":""},{"method_name":"puff","method_signature":"public puff()","target_class":"","rationale":""},{"method_name":"acceptsResource","method_signature":"public acceptsResource(int resourceId)","target_class":"","rationale":""},{"method_name":"submitResource","method_signature":"public submitResource(int resourceId)","target_class":"","rationale":""},{"method_name":"getRandomPeon","method_signature":"private getRandomPeon(double r, double s, final boolean mustBeFree)","target_class":"","rationale":""},{"method_name":"tick","method_signature":"public tick()","target_class":"","rationale":""},{"method_name":"destroy","method_signature":"public destroy()","target_class":"","rationale":""},{"method_name":"die","method_signature":"public die()","target_class":"","rationale":""},{"method_name":"build","method_signature":"public build()","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public sell()":{"first":{"method_name":"sell","method_signature":"public sell()","target_class":"","rationale":""},"second":0.21535291494958003},"public accepts(Entity e)":{"first":{"method_name":"accepts","method_signature":"public accepts(Entity e)","target_class":"","rationale":""},"second":0.41521044181443484},"public puff()":{"first":{"method_name":"puff","method_signature":"public puff()","target_class":"","rationale":""},"second":0.4198130615851477},"public acceptsResource(int resourceId)":{"first":{"method_name":"acceptsResource","method_signature":"public acceptsResource(int resourceId)","target_class":"","rationale":""},"second":0.485357629919627},"public submitResource(int resourceId)":{"first":{"method_name":"submitResource","method_signature":"public submitResource(int resourceId)","target_class":"","rationale":""},"second":0.5797374494549892},"private getRandomPeon(double r, double s, final boolean mustBeFree)":{"first":{"method_name":"getRandomPeon","method_signature":"private getRandomPeon(double r, double s, final boolean mustBeFree)","target_class":"","rationale":""},"second":0.6034099327890902},"public tick()":{"first":{"method_name":"tick","method_signature":"public tick()","target_class":"","rationale":""},"second":0.708135253850083},"public destroy()":{"first":{"method_name":"destroy","method_signature":"public destroy()","target_class":"","rationale":""},"second":0.7590217952836088},"public die()":{"first":{"method_name":"die","method_signature":"public die()","target_class":"","rationale":""},"second":0.7650563974295889},"public build()":{"first":{"method_name":"build","method_signature":"public build()","target_class":"","rationale":""},"second":0.7823328641415596}},"targetClassMap":{"sell":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":0,"similarity_computation_time":0,"similarity_metric":"cosine"},"accepts":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":0,"similarity_computation_time":0,"similarity_metric":"cosine"},"puff":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":0,"similarity_computation_time":0,"similarity_metric":"cosine"},"acceptsResource":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":0,"similarity_computation_time":0,"similarity_metric":"cosine"},"submitResource":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":0,"similarity_computation_time":0,"similarity_metric":"cosine"},"getRandomPeon":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":0,"similarity_computation_time":0,"similarity_metric":"cosine"},"tick":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":0,"similarity_computation_time":0,"similarity_metric":"cosine"},"destroy":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":0,"similarity_computation_time":0,"similarity_metric":"cosine"},"die":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":4386,"similarity_computation_time":0,"similarity_metric":"cosine"},"build":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5721,"similarity_computation_time":0,"similarity_metric":"cosine"}}}
{"id":"247d05e7-34a7-40fa-8dce-9f71794f2158","hostFunctionTelemetryData":{"hostFunctionSize":79,"lineStart":7,"lineEnd":85,"bodyLineStart":7,"language":"java","filePath":"C:/Users/khush/IdeaProjects/BreakingTheTower/src/main/java/com/mojang/tower/model/Tower.java","sourceCode":"public class Tower extends Entity {\n    private static final boolean DEBUG \u003d false;\n    private int h \u003d 0;\n    private int staminaPerLevel \u003d 4096 * 2;\n    private int stamina \u003d staminaPerLevel;\n    private int minMonsters \u003d 3;\n\n    public Tower(double x, double y) {\n        super(x, y, 16);\n        h \u003d 80;\n    }\n\n    public void tick() {\n        if (random.nextInt(100) \u003d\u003d 0 \u0026\u0026 island.getMonsterPopulation() \u003c minMonsters) {\n            spawnMonster();\n        }\n    }\n\n    private void spawnMonster() {\n        double xt \u003d x + (random.nextDouble() * 2 - 1) * (r + 5);\n        double yt \u003d y + (random.nextDouble() * 2 - 1) * (r + 5);\n\n        Monster monster \u003d new Monster(xt, yt);\n        if (island.isFree(monster.x, monster.y, monster.r)) {\n            if (!DEBUG) island.addEntity(monster);\n        }\n    }\n\n    public void render(Graphics2D g, double alpha) {\n        int x \u003d (int) (xr - 16);\n        int y \u003d -(int) (yr / 2);\n\n        renderTower(g, x, y);\n    }\n\n    private void renderTower(Graphics2D g, int x, int y) {\n        for (int i \u003d 0; i \u003c h / 8; i++) {\n            g.drawImage(bitmaps.getTowerMid(), x, y - 8 - i * 8, null);\n        }\n        g.drawImage(bitmaps.getTowerMid(), x, y - h - 1, null);\n        g.drawImage(bitmaps.getTowerBot(), x, y, null);\n        g.drawImage(bitmaps.getTowerTop(), x, y - h - 8, null);\n    }\n\n    public boolean gatherResource(int resourceId) {\n        stamina -\u003d 64;\n        if (stamina \u003c\u003d 0) {\n            gatherResources();\n            return true;\n        }\n        return false;\n    }\n\n    private void gatherResources() {\n        for (int i \u003d 0; i \u003c 1; ) {\n            double xt \u003d x + (random.nextDouble() * 2 - 1) * (r + 5);\n            double yt \u003d y + (random.nextDouble() * 2 - 1) * (r + 5);\n\n            Monster monster \u003d new Monster(xt, yt);\n            if (island.isFree(monster.x, monster.y, monster.r)) {\n                if (!DEBUG) island.addEntity(monster);\n                i++;\n            }\n        }\n        stamina +\u003d staminaPerLevel;\n        if (DEBUG) {\n            stamina \u003d 0;\n        }\n        if (h % 20 \u003d\u003d 0) minMonsters++;\n        if (--h \u003c\u003d 4) {\n            island.win();\n            alive \u003d false;\n        }\n    }\n\n    public boolean givesResource(int resourceId) {\n        return resourceId \u003d\u003d Resources.RESOURCE_ROCK_ID;\n    }\n}","methodCount":8,"staticMethodCount":0,"instanceMethodCount":8,"classLoc":79,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":16851},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"tick","method_signature":"public tick()","target_class":"","rationale":""},{"method_name":"spawnMonster","method_signature":"private spawnMonster()","target_class":"","rationale":""},{"method_name":"renderTower","method_signature":"private renderTower(Graphics2D g, int x, int y)","target_class":"","rationale":""},{"method_name":"gatherResources","method_signature":"private gatherResources()","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"renderTower","method_signature":"private renderTower(Graphics2D g, int x, int y)","target_class":"","rationale":""},{"method_name":"tick","method_signature":"public tick()","target_class":"","rationale":""},{"method_name":"spawnMonster","method_signature":"private spawnMonster()","target_class":"","rationale":""},{"method_name":"gatherResources","method_signature":"private gatherResources()","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"private renderTower(Graphics2D g, int x, int y)":{"first":{"method_name":"renderTower","method_signature":"private renderTower(Graphics2D g, int x, int y)","target_class":"","rationale":""},"second":0.3941073604892429},"public tick()":{"first":{"method_name":"tick","method_signature":"public tick()","target_class":"","rationale":""},"second":0.4271448527727779},"private spawnMonster()":{"first":{"method_name":"spawnMonster","method_signature":"private spawnMonster()","target_class":"","rationale":""},"second":0.632056185269258},"private gatherResources()":{"first":{"method_name":"gatherResources","method_signature":"private gatherResources()","target_class":"","rationale":""},"second":0.73468738139047}},"targetClassMap":{"renderTower":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5803,"similarity_computation_time":0,"similarity_metric":"cosine"},"tick":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":3081,"similarity_computation_time":0,"similarity_metric":"cosine"},"spawnMonster":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":4392,"similarity_computation_time":0,"similarity_metric":"cosine"},"gatherResources":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":3537,"similarity_computation_time":0,"similarity_metric":"cosine"}}}
{"id":"2bfbb71c-0732-4734-abc5-7720e0a8b517","hostFunctionTelemetryData":{"hostFunctionSize":168,"lineStart":52,"lineEnd":219,"bodyLineStart":52,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/annotations/AbstractAnnotation.java","sourceCode":"/**\n * An abstract implementation of the {@link Annotation} interface, containing a\n * mechanism for registering change listeners.\n */\npublic abstract class AbstractAnnotation implements Annotation, Cloneable,\n        Serializable {\n\n    /** Storage for registered change listeners. */\n    private transient EventListenerList listenerList;\n\n    /**\n     * A flag that indicates whether listeners should be notified\n     * about changes of the annotation.\n     */\n    private boolean notify \u003d true;\n\n    /**\n     * Constructs an annotation.\n     */\n    protected AbstractAnnotation() {\n        this.listenerList \u003d new EventListenerList();\n    }\n\n    /**\n     * Registers an object to receive notification of changes to the\n     * annotation.\n     *\n     * @param listener  the object to register.\n     *\n     * @see #removeChangeListener(AnnotationChangeListener)\n     */\n    @Override\n    public void addChangeListener(AnnotationChangeListener listener) {\n        this.listenerList.add(AnnotationChangeListener.class, listener);\n    }\n\n    /**\n     * Deregisters an object so that it no longer receives notification of\n     * changes to the annotation.\n     *\n     * @param listener  the object to deregister.\n     *\n     * @see #addChangeListener(AnnotationChangeListener)\n     */\n    @Override\n    public void removeChangeListener(AnnotationChangeListener listener) {\n        this.listenerList.remove(AnnotationChangeListener.class, listener);\n    }\n\n    /**\n     * Returns {@code true} if the specified object is registered with\n     * the annotation as a listener.  Most applications won\u0027t need to call this\n     * method, it exists mainly for use by unit testing code.\n     *\n     * @param listener  the listener.\n     *\n     * @return A boolean.\n     *\n     * @see #addChangeListener(AnnotationChangeListener)\n     * @see #removeChangeListener(AnnotationChangeListener)\n     */\n    public boolean hasListener(EventListener listener) {\n        List list \u003d Arrays.asList(this.listenerList.getListenerList());\n        return list.contains(listener);\n    }\n\n    /**\n     * Notifies all registered listeners that the annotation has changed.\n     *\n     * @see #addChangeListener(AnnotationChangeListener)\n     */\n    protected void fireAnnotationChanged() {\n        if (notify) {\n            notifyListeners(new AnnotationChangeEvent(this, this));\n        }\n    }\n\n    /**\n     * Notifies all registered listeners that the annotation has changed.\n     *\n     * @param event  contains information about the event that triggered the\n     *               notification.\n     *\n     * @see #addChangeListener(AnnotationChangeListener)\n     * @see #removeChangeListener(AnnotationChangeListener)\n     */\n    protected void notifyListeners(AnnotationChangeEvent event) {\n\n        Object[] listeners \u003d this.listenerList.getListenerList();\n        for (int i \u003d listeners.length - 2; i \u003e\u003d 0; i -\u003d 2) {\n            if (listeners[i] \u003d\u003d AnnotationChangeListener.class) {\n                ((AnnotationChangeListener) listeners[i + 1]).annotationChanged(\n                        event);\n            }\n        }\n\n    }\n\n    /**\n     * Returns a flag that indicates whether listeners should be \n     * notified about changes to the annotation.\n     *\n     * @return  the flag.\n     *\n     * @see #setNotify(boolean)\n     */\n    public boolean getNotify(){\n        return this.notify;\n    }\n\n    /**\n     * Sets a flag that indicates whether listeners should be notified about\n     * changes of an annotation.\n     *\n     * @param flag  the flag\n     *\n     * @see #getNotify()\n     */\n    public void setNotify(boolean flag){\n        this.notify \u003d flag;\n        if (notify) {\n            fireAnnotationChanged();\n        }\n    }\n\n    /**\n     * Returns a clone of the annotation. The cloned annotation will NOT \n     * include the {@link AnnotationChangeListener} references that have been\n     * registered with this annotation.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  if the annotation does not support\n     *                                     cloning.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        AbstractAnnotation clone \u003d (AbstractAnnotation) super.clone();\n        clone.listenerList \u003d new EventListenerList();\n        return clone;\n    }\n\n    /**\n     * Handles serialization.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException if there is an I/O problem.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n    }\n\n    /**\n     * Restores a serialized object.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException if there is an I/O problem.\n     * @throws ClassNotFoundException if there is a problem loading a class.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.listenerList \u003d new EventListenerList();\n    }\n\n}","methodCount":11,"staticMethodCount":0,"instanceMethodCount":11,"classLoc":168,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"6e79caf9-d2b0-4440-9a5d-c1c55665a773","hostFunctionTelemetryData":{"hostFunctionSize":286,"lineStart":65,"lineEnd":350,"bodyLineStart":65,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/annotations/XYPolygonAnnotation.java","sourceCode":"/**\n * A polygon annotation that can be placed on an {@link XYPlot}.  The\n * polygon coordinates are specified in data space.\n */\npublic class XYPolygonAnnotation extends AbstractXYAnnotation\n        implements Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -6984203651995900036L;\n\n    /** The polygon. */\n    private double[] polygon;\n\n    /** The stroke used to draw the box outline. */\n    private transient Stroke stroke;\n\n    /** The paint used to draw the box outline. */\n    private transient Paint outlinePaint;\n\n    /** The paint used to fill the box. */\n    private transient Paint fillPaint;\n\n    /**\n     * Creates a new annotation (where, by default, the polygon is drawn\n     * with a black outline).  The array of polygon coordinates must contain\n     * an even number of coordinates (each pair is an (x, y) location on the\n     * plot) and the last point is automatically joined back to the first point.\n     *\n     * @param polygon  the coordinates of the polygon\u0027s vertices\n     *     ({@code null} not permitted).\n     */\n    public XYPolygonAnnotation(double[] polygon) {\n        this(polygon, new BasicStroke(1.0f), Color.BLACK);\n    }\n\n    /**\n     * Creates a new annotation where the box is drawn as an outline using\n     * the specified {@code stroke} and {@code outlinePaint}.\n     * The array of polygon coordinates must contain an even number of\n     * coordinates (each pair is an (x, y) location on the plot) and the last\n     * point is automatically joined back to the first point.\n     *\n     * @param polygon  the coordinates of the polygon\u0027s vertices\n     *     ({@code null} not permitted).\n     * @param stroke  the shape stroke ({@code null} permitted).\n     * @param outlinePaint  the shape color ({@code null} permitted).\n     */\n    public XYPolygonAnnotation(double[] polygon,\n                               Stroke stroke, Paint outlinePaint) {\n        this(polygon, stroke, outlinePaint, null);\n    }\n\n    /**\n     * Creates a new annotation.  The array of polygon coordinates must\n     * contain an even number of coordinates (each pair is an (x, y) location\n     * on the plot) and the last point is automatically joined back to the\n     * first point.\n     *\n     * @param polygon  the coordinates of the polygon\u0027s vertices\n     *     ({@code null} not permitted).\n     * @param stroke  the shape stroke ({@code null} permitted).\n     * @param outlinePaint  the shape color ({@code null} permitted).\n     * @param fillPaint  the paint used to fill the shape ({@code null}\n     *                   permitted).\n     */\n    public XYPolygonAnnotation(double[] polygon, Stroke stroke, \n            Paint outlinePaint, Paint fillPaint) {\n        super();\n        Args.nullNotPermitted(polygon, \"polygon\");\n        if (polygon.length % 2 !\u003d 0) {\n            throw new IllegalArgumentException(\"The \u0027polygon\u0027 array must \"\n                    + \"contain an even number of items.\");\n        }\n        this.polygon \u003d (double[]) polygon.clone();\n        this.stroke \u003d stroke;\n        this.outlinePaint \u003d outlinePaint;\n        this.fillPaint \u003d fillPaint;\n    }\n\n    /**\n     * Returns the coordinates of the polygon\u0027s vertices.  The returned array\n     * is a copy, so it is safe to modify without altering the annotation\u0027s\n     * state.\n     *\n     * @return The coordinates of the polygon\u0027s vertices.\n     */\n    public double[] getPolygonCoordinates() {\n        return (double[]) this.polygon.clone();\n    }\n\n    /**\n     * Returns the fill paint.\n     *\n     * @return The fill paint (possibly {@code null}).\n     */\n    public Paint getFillPaint() {\n        return this.fillPaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke (possibly {@code null}).\n     */\n    public Stroke getOutlineStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint (possibly {@code null}).\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Draws the annotation.  This method is usually called by the\n     * {@link XYPlot} class, you shouldn\u0027t need to call it directly.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param dataArea  the data area.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param rendererIndex  the renderer index.\n     * @param info  the plot rendering info.\n     */\n    @Override\n    public void draw(Graphics2D g2, XYPlot plot, Rectangle2D dataArea,\n                     ValueAxis domainAxis, ValueAxis rangeAxis,\n                     int rendererIndex, PlotRenderingInfo info) {\n\n        // if we don\u0027t have at least 2 (x, y) coordinates, just return\n        if (this.polygon.length \u003c 4) {\n            return;\n        }\n        PlotOrientation orientation \u003d plot.getOrientation();\n        RectangleEdge domainEdge \u003d Plot.resolveDomainAxisLocation(\n                plot.getDomainAxisLocation(), orientation);\n        RectangleEdge rangeEdge \u003d Plot.resolveRangeAxisLocation(\n                plot.getRangeAxisLocation(), orientation);\n\n        GeneralPath area \u003d new GeneralPath();\n        double x \u003d domainAxis.valueToJava2D(this.polygon[0], dataArea,\n                domainEdge);\n        double y \u003d rangeAxis.valueToJava2D(this.polygon[1], dataArea,\n                rangeEdge);\n        if (orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n            area.moveTo((float) y, (float) x);\n            for (int i \u003d 2; i \u003c this.polygon.length; i +\u003d 2) {\n                x \u003d domainAxis.valueToJava2D(this.polygon[i], dataArea,\n                        domainEdge);\n                y \u003d rangeAxis.valueToJava2D(this.polygon[i + 1], dataArea,\n                        rangeEdge);\n                area.lineTo((float) y, (float) x);\n            }\n            area.closePath();\n        }\n        else if (orientation \u003d\u003d PlotOrientation.VERTICAL) {\n            area.moveTo((float) x, (float) y);\n            for (int i \u003d 2; i \u003c this.polygon.length; i +\u003d 2) {\n                x \u003d domainAxis.valueToJava2D(this.polygon[i], dataArea,\n                        domainEdge);\n                y \u003d rangeAxis.valueToJava2D(this.polygon[i + 1], dataArea,\n                        rangeEdge);\n                area.lineTo((float) x, (float) y);\n            }\n            area.closePath();\n       }\n\n\n        if (this.fillPaint !\u003d null) {\n            g2.setPaint(this.fillPaint);\n            g2.fill(area);\n        }\n\n        if (this.stroke !\u003d null \u0026\u0026 this.outlinePaint !\u003d null) {\n            g2.setPaint(this.outlinePaint);\n            g2.setStroke(this.stroke);\n            g2.draw(area);\n        }\n        addEntity(info, area, rendererIndex, getToolTipText(), getURL());\n\n    }\n\n    /**\n     * Tests this annotation for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        // now try to reject equality\n        if (!super.equals(obj)) {\n            return false;\n        }\n        if (!(obj instanceof XYPolygonAnnotation)) {\n            return false;\n        }\n        XYPolygonAnnotation that \u003d (XYPolygonAnnotation) obj;\n        if (!Arrays.equals(this.polygon, that.polygon)) {\n            return false;\n        }\n        if (!Objects.equals(this.stroke, that.stroke)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.outlinePaint, that.outlinePaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.fillPaint, that.fillPaint)) {\n            return false;\n        }\n        // seem to be the same\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this instance.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d 193;\n        result \u003d 37 * result + HashUtils.hashCodeForDoubleArray(\n                this.polygon);\n        result \u003d 37 * result + HashUtils.hashCodeForPaint(this.fillPaint);\n        result \u003d 37 * result + HashUtils.hashCodeForPaint(\n                this.outlinePaint);\n        if (this.stroke !\u003d null) {\n            result \u003d 37 * result + this.stroke.hashCode();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a clone.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException not thrown by this class, but may be\n     *                                    by subclasses.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream ({@code null} not permitted).\n     *\n     * @throws IOException if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writeStroke(this.stroke, stream);\n        SerialUtils.writePaint(this.outlinePaint, stream);\n        SerialUtils.writePaint(this.fillPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream ({@code null} not permitted).\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n            throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.stroke \u003d SerialUtils.readStroke(stream);\n        this.outlinePaint \u003d SerialUtils.readPaint(stream);\n        this.fillPaint \u003d SerialUtils.readPaint(stream);\n    }\n\n}","methodCount":13,"staticMethodCount":0,"instanceMethodCount":13,"classLoc":286,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"8c5a0f0a-a550-4b9e-a51b-239c33d60a5e","hostFunctionTelemetryData":{"hostFunctionSize":129,"lineStart":44,"lineEnd":172,"bodyLineStart":44,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/renderer/OutlierListCollection.java","sourceCode":"/**\n * A collection of outlier lists for a box and whisker plot. Each collection is\n * associated with a single box and whisker entity.\n *\n * Outliers are grouped in lists for each entity. Lists contain\n * one or more outliers, determined by whether overlaps have\n * occurred. Overlapping outliers are grouped in the same list.\n *\n * @see org.jfree.chart.renderer.OutlierList\n */\npublic class OutlierListCollection {\n\n    /** Storage for the outlier lists. */\n    private List\u003cOutlierList\u003e outlierLists;\n\n    /**\n     * Unbelievably, outliers which are more than 2 * interquartile range are\n     * called far outs...  See Tukey EDA  (a classic one of a kind...)\n     */\n    private boolean highFarOut \u003d false;\n\n    /**\n     * A flag that indicates whether or not the collection contains low far\n     * out values.\n     */\n    private boolean lowFarOut \u003d false;\n\n    /**\n     * Creates a new empty collection.\n     */\n    public OutlierListCollection() {\n        this.outlierLists \u003d new ArrayList\u003c\u003e();\n    }\n\n    /**\n     * A flag to indicate the presence of one or more far out values at the\n     * top end of the range.\n     *\n     * @return A {@code boolean}.\n     */\n    public boolean isHighFarOut() {\n        return this.highFarOut;\n    }\n\n    /**\n     * Sets the flag that indicates the presence of one or more far out values\n     * at the top end of the range.\n     *\n     * @param farOut  the flag.\n     */\n    public void setHighFarOut(boolean farOut) {\n        this.highFarOut \u003d farOut;\n    }\n\n    /**\n     * A flag to indicate the presence of one or more far out values at the\n     * bottom end of the range.\n     *\n     * @return A {@code boolean}.\n     */\n    public boolean isLowFarOut() {\n        return this.lowFarOut;\n    }\n\n    /**\n     * Sets the flag that indicates the presence of one or more far out values\n     * at the bottom end of the range.\n     *\n     * @param farOut  the flag.\n     */\n    public void setLowFarOut(boolean farOut) {\n        this.lowFarOut \u003d farOut;\n    }\n    /**\n     * Appends the specified element as a new {@code OutlierList} to the\n     * end of this list if it does not overlap an outlier in an existing list.\n     *\n     * If it does overlap, it is appended to the outlier list which it overlaps\n     * and that list is updated.\n     *\n     * @param outlier  element to be appended to this list.\n     *\n     * @return {@code true} (as per the general contract of Collection.add).\n     */\n    public boolean add(Outlier outlier) {\n        if (this.outlierLists.isEmpty()) {\n            return this.outlierLists.add(new OutlierList(outlier));\n        } else {\n            boolean updated \u003d false;\n            for (OutlierList list : this.outlierLists) {\n                if (list.isOverlapped(outlier)) {\n                    updated \u003d updateOutlierList(list, outlier);\n                }\n            }\n            if (!updated) {\n                updated \u003d this.outlierLists.add(new OutlierList(outlier));\n            }\n            return updated;\n        }\n    }\n\n    /**\n     * Returns an iterator for the outlier lists.\n     *\n     * @return An iterator.\n     */\n    public Iterator\u003cOutlierList\u003e iterator() {\n        return this.outlierLists.iterator();\n    }\n\n\n    /**\n     * Updates the outlier list by adding the outlier to the end of the list and\n     * setting the averaged outlier to the average x and y coordinate values\n     * of the outliers in the list.\n     *\n     * @param list  the outlier list to be updated.\n     * @param outlier  the outlier to be added\n     *\n     * @return \u003ctt\u003etrue\u003c/tt\u003e (as per the general contract of Collection.add).\n     */\n    private boolean updateOutlierList(OutlierList list, Outlier outlier) {\n        boolean result \u003d list.add(outlier);\n        list.updateAveragedOutlier();\n        list.setMultiple(true);\n        return result;\n    }\n\n}","methodCount":8,"staticMethodCount":0,"instanceMethodCount":8,"classLoc":129,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":1,"candidates":[{"lineStart":154,"lineEnd":169,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method updateOutlierList to class OutlierList","description":"Move method updateOutlierList to org.jfree.chart.renderer.OutlierList\nRationale: The updateOutlierList method strongly depends on the OutlierList class since it primarily performs operations on an outlier list, such as adding an outlier and updating the averaged outlier. Moving this method to the OutlierList class will encapsulate all the responsibilities related to the outlier list within that class, promoting a cleaner and more maintainable code structure. Additionally, it leverages existing methods (add, updateAveragedOutlier, setMultiple), making OutlierList the most appropriate destination.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":171554}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":10374},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"add","method_signature":"public add(Outlier outlier)","target_class":"","rationale":""},{"method_name":"updateOutlierList","method_signature":"private updateOutlierList(OutlierList list, Outlier outlier)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"add","method_signature":"public add(Outlier outlier)","target_class":"","rationale":""},{"method_name":"updateOutlierList","method_signature":"private updateOutlierList(OutlierList list, Outlier outlier)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public add(Outlier outlier)":{"first":{"method_name":"add","method_signature":"public add(Outlier outlier)","target_class":"","rationale":""},"second":0.6624609340663695},"private updateOutlierList(OutlierList list, Outlier outlier)":{"first":{"method_name":"updateOutlierList","method_signature":"private updateOutlierList(OutlierList list, Outlier outlier)","target_class":"","rationale":""},"second":0.713227910440244}},"targetClassMap":{"add":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5479,"similarity_computation_time":0,"similarity_metric":"cosine"},"updateOutlierList":{"target_classes":[{"class_name":"OutlierList","similarity_score":0.7140240603554819},{"class_name":"Outlier","similarity_score":0.759199192484853}],"target_classes_sorted_by_llm":["OutlierList","Outlier"],"llm_response_time":4404,"similarity_computation_time":4,"similarity_metric":"cosine"}}}
{"id":"6157680e-9faa-4e9e-9b17-bd966ebf37a7","hostFunctionTelemetryData":{"hostFunctionSize":468,"lineStart":67,"lineEnd":534,"bodyLineStart":67,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/annotations/CategoryPointerAnnotation.java","sourceCode":"/**\n * An arrow and label that can be placed on a {@link CategoryPlot}.  The arrow\n * is drawn at a user-definable angle so that it points towards the (category,\n * value) location for the annotation.\n * \u003cp\u003e\n * The arrow length (and its offset from the (category, value) location) is\n * controlled by the tip radius and the base radius attributes.  Imagine two\n * circles around the (category, value) coordinate: the inner circle defined by\n * the tip radius, and the outer circle defined by the base radius.  Now, draw\n * the arrow starting at some point on the outer circle (the point is\n * determined by the angle), with the arrow tip being drawn at a corresponding\n * point on the inner circle.\n */\npublic class CategoryPointerAnnotation extends CategoryTextAnnotation\n        implements Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -4031161445009858551L;\n\n    /** The default tip radius (in Java2D units). */\n    public static final double DEFAULT_TIP_RADIUS \u003d 10.0;\n\n    /** The default base radius (in Java2D units). */\n    public static final double DEFAULT_BASE_RADIUS \u003d 30.0;\n\n    /** The default label offset (in Java2D units). */\n    public static final double DEFAULT_LABEL_OFFSET \u003d 3.0;\n\n    /** The default arrow length (in Java2D units). */\n    public static final double DEFAULT_ARROW_LENGTH \u003d 5.0;\n\n    /** The default arrow width (in Java2D units). */\n    public static final double DEFAULT_ARROW_WIDTH \u003d 3.0;\n\n    /** The angle of the arrow\u0027s line (in radians). */\n    private double angle;\n\n    /**\n     * The radius from the (x, y) point to the tip of the arrow (in Java2D\n     * units).\n     */\n    private double tipRadius;\n\n    /**\n     * The radius from the (x, y) point to the start of the arrow line (in\n     * Java2D units).\n     */\n    private double baseRadius;\n\n    /** The length of the arrow head (in Java2D units). */\n    private double arrowLength;\n\n    /** The arrow width (in Java2D units, per side). */\n    private double arrowWidth;\n\n    /** The arrow stroke. */\n    private transient Stroke arrowStroke;\n\n    /** The arrow paint. */\n    private transient Paint arrowPaint;\n\n    /** The radius from the base point to the anchor point for the label. */\n    private double labelOffset;\n\n    /**\n     * Creates a new label and arrow annotation.\n     *\n     * @param label  the label ({@code null} permitted).\n     * @param key  the category key.\n     * @param value  the y-value (measured against the chart\u0027s range axis).\n     * @param angle  the angle of the arrow\u0027s line (in radians).\n     */\n    public CategoryPointerAnnotation(String label, Comparable key, double value,\n            double angle) {\n\n        super(label, key, value);\n        this.angle \u003d angle;\n        this.tipRadius \u003d DEFAULT_TIP_RADIUS;\n        this.baseRadius \u003d DEFAULT_BASE_RADIUS;\n        this.arrowLength \u003d DEFAULT_ARROW_LENGTH;\n        this.arrowWidth \u003d DEFAULT_ARROW_WIDTH;\n        this.labelOffset \u003d DEFAULT_LABEL_OFFSET;\n        this.arrowStroke \u003d new BasicStroke(1.0f);\n        this.arrowPaint \u003d Color.BLACK;\n\n    }\n\n    /**\n     * Returns the angle of the arrow.\n     *\n     * @return The angle (in radians).\n     *\n     * @see #setAngle(double)\n     */\n    public double getAngle() {\n        return this.angle;\n    }\n\n    /**\n     * Sets the angle of the arrow and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param angle  the angle (in radians).\n     *\n     * @see #getAngle()\n     */\n    public void setAngle(double angle) {\n        this.angle \u003d angle;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the tip radius.\n     *\n     * @return The tip radius (in Java2D units).\n     *\n     * @see #setTipRadius(double)\n     */\n    public double getTipRadius() {\n        return this.tipRadius;\n    }\n\n    /**\n     * Sets the tip radius and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param radius  the radius (in Java2D units).\n     *\n     * @see #getTipRadius()\n     */\n    public void setTipRadius(double radius) {\n        this.tipRadius \u003d radius;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the base radius.\n     *\n     * @return The base radius (in Java2D units).\n     *\n     * @see #setBaseRadius(double)\n     */\n    public double getBaseRadius() {\n        return this.baseRadius;\n    }\n\n    /**\n     * Sets the base radius and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param radius  the radius (in Java2D units).\n     *\n     * @see #getBaseRadius()\n     */\n    public void setBaseRadius(double radius) {\n        this.baseRadius \u003d radius;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the label offset.\n     *\n     * @return The label offset (in Java2D units).\n     *\n     * @see #setLabelOffset(double)\n     */\n    public double getLabelOffset() {\n        return this.labelOffset;\n    }\n\n    /**\n     * Sets the label offset (from the arrow base, continuing in a straight\n     * line, in Java2D units) and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset (in Java2D units).\n     *\n     * @see #getLabelOffset()\n     */\n    public void setLabelOffset(double offset) {\n        this.labelOffset \u003d offset;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the arrow length.\n     *\n     * @return The arrow length.\n     *\n     * @see #setArrowLength(double)\n     */\n    public double getArrowLength() {\n        return this.arrowLength;\n    }\n\n    /**\n     * Sets the arrow length and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param length  the length.\n     *\n     * @see #getArrowLength()\n     */\n    public void setArrowLength(double length) {\n        this.arrowLength \u003d length;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the arrow width.\n     *\n     * @return The arrow width (in Java2D units).\n     *\n     * @see #setArrowWidth(double)\n     */\n    public double getArrowWidth() {\n        return this.arrowWidth;\n    }\n\n    /**\n     * Sets the arrow width and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param width  the width (in Java2D units).\n     *\n     * @see #getArrowWidth()\n     */\n    public void setArrowWidth(double width) {\n        this.arrowWidth \u003d width;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the stroke used to draw the arrow line.\n     *\n     * @return The arrow stroke (never {@code null}).\n     *\n     * @see #setArrowStroke(Stroke)\n     */\n    public Stroke getArrowStroke() {\n        return this.arrowStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the arrow line and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getArrowStroke()\n     */\n    public void setArrowStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.arrowStroke \u003d stroke;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the paint used for the arrow.\n     *\n     * @return The arrow paint (never {@code null}).\n     *\n     * @see #setArrowPaint(Paint)\n     */\n    public Paint getArrowPaint() {\n        return this.arrowPaint;\n    }\n\n    /**\n     * Sets the paint used for the arrow and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param paint  the arrow paint ({@code null} not permitted).\n     *\n     * @see #getArrowPaint()\n     */\n    public void setArrowPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.arrowPaint \u003d paint;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Draws the annotation.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param dataArea  the data area.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     */\n    @Override\n    public void draw(Graphics2D g2, CategoryPlot plot, Rectangle2D dataArea,\n            CategoryAxis domainAxis, ValueAxis rangeAxis) {\n\n        PlotOrientation orientation \u003d plot.getOrientation();\n        RectangleEdge domainEdge \u003d Plot.resolveDomainAxisLocation(\n                plot.getDomainAxisLocation(), orientation);\n        RectangleEdge rangeEdge \u003d Plot.resolveRangeAxisLocation(\n                plot.getRangeAxisLocation(), orientation);\n        CategoryDataset dataset \u003d plot.getDataset();\n        int catIndex \u003d dataset.getColumnIndex(getCategory());\n        int catCount \u003d dataset.getColumnCount();\n        double j2DX \u003d domainAxis.getCategoryMiddle(catIndex, catCount,\n                dataArea, domainEdge);\n        double j2DY \u003d rangeAxis.valueToJava2D(getValue(), dataArea, rangeEdge);\n        if (orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n            double temp \u003d j2DX;\n            j2DX \u003d j2DY;\n            j2DY \u003d temp;\n        }\n        double startX \u003d j2DX + Math.cos(this.angle) * this.baseRadius;\n        double startY \u003d j2DY + Math.sin(this.angle) * this.baseRadius;\n\n        double endX \u003d j2DX + Math.cos(this.angle) * this.tipRadius;\n        double endY \u003d j2DY + Math.sin(this.angle) * this.tipRadius;\n\n        double arrowBaseX \u003d endX + Math.cos(this.angle) * this.arrowLength;\n        double arrowBaseY \u003d endY + Math.sin(this.angle) * this.arrowLength;\n\n        double arrowLeftX \u003d arrowBaseX\n            + Math.cos(this.angle + Math.PI / 2.0) * this.arrowWidth;\n        double arrowLeftY \u003d arrowBaseY\n            + Math.sin(this.angle + Math.PI / 2.0) * this.arrowWidth;\n\n        double arrowRightX \u003d arrowBaseX\n            - Math.cos(this.angle + Math.PI / 2.0) * this.arrowWidth;\n        double arrowRightY \u003d arrowBaseY\n            - Math.sin(this.angle + Math.PI / 2.0) * this.arrowWidth;\n\n        GeneralPath arrow \u003d new GeneralPath();\n        arrow.moveTo((float) endX, (float) endY);\n        arrow.lineTo((float) arrowLeftX, (float) arrowLeftY);\n        arrow.lineTo((float) arrowRightX, (float) arrowRightY);\n        arrow.closePath();\n\n        g2.setStroke(this.arrowStroke);\n        g2.setPaint(this.arrowPaint);\n        Line2D line \u003d new Line2D.Double(startX, startY, arrowBaseX, arrowBaseY);\n        g2.draw(line);\n        g2.fill(arrow);\n\n        // draw the label\n        g2.setFont(getFont());\n        g2.setPaint(getPaint());\n        double labelX \u003d j2DX\n            + Math.cos(this.angle) * (this.baseRadius + this.labelOffset);\n        double labelY \u003d j2DY\n            + Math.sin(this.angle) * (this.baseRadius + this.labelOffset);\n        /* Rectangle2D hotspot \u003d */ TextUtils.drawAlignedString(getText(),\n                g2, (float) labelX, (float) labelY, getTextAnchor());\n        // TODO: implement the entity for the annotation\n\n    }\n\n    /**\n     * Tests this annotation for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return {@code true} or {@code false}.\n     */\n    @Override\n    public boolean equals(Object obj) {\n\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryPointerAnnotation)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        CategoryPointerAnnotation that \u003d (CategoryPointerAnnotation) obj;\n        if (this.angle !\u003d that.angle) {\n            return false;\n        }\n        if (this.tipRadius !\u003d that.tipRadius) {\n            return false;\n        }\n        if (this.baseRadius !\u003d that.baseRadius) {\n            return false;\n        }\n        if (this.arrowLength !\u003d that.arrowLength) {\n            return false;\n        }\n        if (this.arrowWidth !\u003d that.arrowWidth) {\n            return false;\n        }\n        if (!this.arrowPaint.equals(that.arrowPaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.arrowStroke, that.arrowStroke)) {\n            return false;\n        }\n        if (this.labelOffset !\u003d that.labelOffset) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this instance.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d 193;\n        long temp \u003d Double.doubleToLongBits(this.angle);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.tipRadius);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.baseRadius);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.arrowLength);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.arrowWidth);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        result \u003d 37 * result + HashUtils.hashCodeForPaint(this.arrowPaint);\n        result \u003d 37 * result + this.arrowStroke.hashCode();\n        temp \u003d Double.doubleToLongBits(this.labelOffset);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        return result;\n    }\n\n    /**\n     * Returns a clone of the annotation.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  if the annotation can\u0027t be cloned.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writePaint(this.arrowPaint, stream);\n        SerialUtils.writeStroke(this.arrowStroke, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.arrowPaint \u003d SerialUtils.readPaint(stream);\n        this.arrowStroke \u003d SerialUtils.readStroke(stream);\n    }\n\n}","methodCount":23,"staticMethodCount":0,"instanceMethodCount":23,"classLoc":468,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"6157680e-9faa-4e9e-9b17-bd966ebf37a7","hostFunctionTelemetryData":{"hostFunctionSize":468,"lineStart":67,"lineEnd":534,"bodyLineStart":67,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/annotations/CategoryPointerAnnotation.java","sourceCode":"/**\n * An arrow and label that can be placed on a {@link CategoryPlot}.  The arrow\n * is drawn at a user-definable angle so that it points towards the (category,\n * value) location for the annotation.\n * \u003cp\u003e\n * The arrow length (and its offset from the (category, value) location) is\n * controlled by the tip radius and the base radius attributes.  Imagine two\n * circles around the (category, value) coordinate: the inner circle defined by\n * the tip radius, and the outer circle defined by the base radius.  Now, draw\n * the arrow starting at some point on the outer circle (the point is\n * determined by the angle), with the arrow tip being drawn at a corresponding\n * point on the inner circle.\n */\npublic class CategoryPointerAnnotation extends CategoryTextAnnotation\n        implements Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -4031161445009858551L;\n\n    /** The default tip radius (in Java2D units). */\n    public static final double DEFAULT_TIP_RADIUS \u003d 10.0;\n\n    /** The default base radius (in Java2D units). */\n    public static final double DEFAULT_BASE_RADIUS \u003d 30.0;\n\n    /** The default label offset (in Java2D units). */\n    public static final double DEFAULT_LABEL_OFFSET \u003d 3.0;\n\n    /** The default arrow length (in Java2D units). */\n    public static final double DEFAULT_ARROW_LENGTH \u003d 5.0;\n\n    /** The default arrow width (in Java2D units). */\n    public static final double DEFAULT_ARROW_WIDTH \u003d 3.0;\n\n    /** The angle of the arrow\u0027s line (in radians). */\n    private double angle;\n\n    /**\n     * The radius from the (x, y) point to the tip of the arrow (in Java2D\n     * units).\n     */\n    private double tipRadius;\n\n    /**\n     * The radius from the (x, y) point to the start of the arrow line (in\n     * Java2D units).\n     */\n    private double baseRadius;\n\n    /** The length of the arrow head (in Java2D units). */\n    private double arrowLength;\n\n    /** The arrow width (in Java2D units, per side). */\n    private double arrowWidth;\n\n    /** The arrow stroke. */\n    private transient Stroke arrowStroke;\n\n    /** The arrow paint. */\n    private transient Paint arrowPaint;\n\n    /** The radius from the base point to the anchor point for the label. */\n    private double labelOffset;\n\n    /**\n     * Creates a new label and arrow annotation.\n     *\n     * @param label  the label ({@code null} permitted).\n     * @param key  the category key.\n     * @param value  the y-value (measured against the chart\u0027s range axis).\n     * @param angle  the angle of the arrow\u0027s line (in radians).\n     */\n    public CategoryPointerAnnotation(String label, Comparable key, double value,\n            double angle) {\n\n        super(label, key, value);\n        this.angle \u003d angle;\n        this.tipRadius \u003d DEFAULT_TIP_RADIUS;\n        this.baseRadius \u003d DEFAULT_BASE_RADIUS;\n        this.arrowLength \u003d DEFAULT_ARROW_LENGTH;\n        this.arrowWidth \u003d DEFAULT_ARROW_WIDTH;\n        this.labelOffset \u003d DEFAULT_LABEL_OFFSET;\n        this.arrowStroke \u003d new BasicStroke(1.0f);\n        this.arrowPaint \u003d Color.BLACK;\n\n    }\n\n    /**\n     * Returns the angle of the arrow.\n     *\n     * @return The angle (in radians).\n     *\n     * @see #setAngle(double)\n     */\n    public double getAngle() {\n        return this.angle;\n    }\n\n    /**\n     * Sets the angle of the arrow and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param angle  the angle (in radians).\n     *\n     * @see #getAngle()\n     */\n    public void setAngle(double angle) {\n        this.angle \u003d angle;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the tip radius.\n     *\n     * @return The tip radius (in Java2D units).\n     *\n     * @see #setTipRadius(double)\n     */\n    public double getTipRadius() {\n        return this.tipRadius;\n    }\n\n    /**\n     * Sets the tip radius and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param radius  the radius (in Java2D units).\n     *\n     * @see #getTipRadius()\n     */\n    public void setTipRadius(double radius) {\n        this.tipRadius \u003d radius;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the base radius.\n     *\n     * @return The base radius (in Java2D units).\n     *\n     * @see #setBaseRadius(double)\n     */\n    public double getBaseRadius() {\n        return this.baseRadius;\n    }\n\n    /**\n     * Sets the base radius and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param radius  the radius (in Java2D units).\n     *\n     * @see #getBaseRadius()\n     */\n    public void setBaseRadius(double radius) {\n        this.baseRadius \u003d radius;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the label offset.\n     *\n     * @return The label offset (in Java2D units).\n     *\n     * @see #setLabelOffset(double)\n     */\n    public double getLabelOffset() {\n        return this.labelOffset;\n    }\n\n    /**\n     * Sets the label offset (from the arrow base, continuing in a straight\n     * line, in Java2D units) and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset (in Java2D units).\n     *\n     * @see #getLabelOffset()\n     */\n    public void setLabelOffset(double offset) {\n        this.labelOffset \u003d offset;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the arrow length.\n     *\n     * @return The arrow length.\n     *\n     * @see #setArrowLength(double)\n     */\n    public double getArrowLength() {\n        return this.arrowLength;\n    }\n\n    /**\n     * Sets the arrow length and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param length  the length.\n     *\n     * @see #getArrowLength()\n     */\n    public void setArrowLength(double length) {\n        this.arrowLength \u003d length;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the arrow width.\n     *\n     * @return The arrow width (in Java2D units).\n     *\n     * @see #setArrowWidth(double)\n     */\n    public double getArrowWidth() {\n        return this.arrowWidth;\n    }\n\n    /**\n     * Sets the arrow width and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param width  the width (in Java2D units).\n     *\n     * @see #getArrowWidth()\n     */\n    public void setArrowWidth(double width) {\n        this.arrowWidth \u003d width;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the stroke used to draw the arrow line.\n     *\n     * @return The arrow stroke (never {@code null}).\n     *\n     * @see #setArrowStroke(Stroke)\n     */\n    public Stroke getArrowStroke() {\n        return this.arrowStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the arrow line and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getArrowStroke()\n     */\n    public void setArrowStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.arrowStroke \u003d stroke;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the paint used for the arrow.\n     *\n     * @return The arrow paint (never {@code null}).\n     *\n     * @see #setArrowPaint(Paint)\n     */\n    public Paint getArrowPaint() {\n        return this.arrowPaint;\n    }\n\n    /**\n     * Sets the paint used for the arrow and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param paint  the arrow paint ({@code null} not permitted).\n     *\n     * @see #getArrowPaint()\n     */\n    public void setArrowPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.arrowPaint \u003d paint;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Draws the annotation.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param dataArea  the data area.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     */\n    @Override\n    public void draw(Graphics2D g2, CategoryPlot plot, Rectangle2D dataArea,\n            CategoryAxis domainAxis, ValueAxis rangeAxis) {\n\n        PlotOrientation orientation \u003d plot.getOrientation();\n        RectangleEdge domainEdge \u003d Plot.resolveDomainAxisLocation(\n                plot.getDomainAxisLocation(), orientation);\n        RectangleEdge rangeEdge \u003d Plot.resolveRangeAxisLocation(\n                plot.getRangeAxisLocation(), orientation);\n        CategoryDataset dataset \u003d plot.getDataset();\n        int catIndex \u003d dataset.getColumnIndex(getCategory());\n        int catCount \u003d dataset.getColumnCount();\n        double j2DX \u003d domainAxis.getCategoryMiddle(catIndex, catCount,\n                dataArea, domainEdge);\n        double j2DY \u003d rangeAxis.valueToJava2D(getValue(), dataArea, rangeEdge);\n        if (orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n            double temp \u003d j2DX;\n            j2DX \u003d j2DY;\n            j2DY \u003d temp;\n        }\n        double startX \u003d j2DX + Math.cos(this.angle) * this.baseRadius;\n        double startY \u003d j2DY + Math.sin(this.angle) * this.baseRadius;\n\n        double endX \u003d j2DX + Math.cos(this.angle) * this.tipRadius;\n        double endY \u003d j2DY + Math.sin(this.angle) * this.tipRadius;\n\n        double arrowBaseX \u003d endX + Math.cos(this.angle) * this.arrowLength;\n        double arrowBaseY \u003d endY + Math.sin(this.angle) * this.arrowLength;\n\n        double arrowLeftX \u003d arrowBaseX\n            + Math.cos(this.angle + Math.PI / 2.0) * this.arrowWidth;\n        double arrowLeftY \u003d arrowBaseY\n            + Math.sin(this.angle + Math.PI / 2.0) * this.arrowWidth;\n\n        double arrowRightX \u003d arrowBaseX\n            - Math.cos(this.angle + Math.PI / 2.0) * this.arrowWidth;\n        double arrowRightY \u003d arrowBaseY\n            - Math.sin(this.angle + Math.PI / 2.0) * this.arrowWidth;\n\n        GeneralPath arrow \u003d new GeneralPath();\n        arrow.moveTo((float) endX, (float) endY);\n        arrow.lineTo((float) arrowLeftX, (float) arrowLeftY);\n        arrow.lineTo((float) arrowRightX, (float) arrowRightY);\n        arrow.closePath();\n\n        g2.setStroke(this.arrowStroke);\n        g2.setPaint(this.arrowPaint);\n        Line2D line \u003d new Line2D.Double(startX, startY, arrowBaseX, arrowBaseY);\n        g2.draw(line);\n        g2.fill(arrow);\n\n        // draw the label\n        g2.setFont(getFont());\n        g2.setPaint(getPaint());\n        double labelX \u003d j2DX\n            + Math.cos(this.angle) * (this.baseRadius + this.labelOffset);\n        double labelY \u003d j2DY\n            + Math.sin(this.angle) * (this.baseRadius + this.labelOffset);\n        /* Rectangle2D hotspot \u003d */ TextUtils.drawAlignedString(getText(),\n                g2, (float) labelX, (float) labelY, getTextAnchor());\n        // TODO: implement the entity for the annotation\n\n    }\n\n    /**\n     * Tests this annotation for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return {@code true} or {@code false}.\n     */\n    @Override\n    public boolean equals(Object obj) {\n\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryPointerAnnotation)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        CategoryPointerAnnotation that \u003d (CategoryPointerAnnotation) obj;\n        if (this.angle !\u003d that.angle) {\n            return false;\n        }\n        if (this.tipRadius !\u003d that.tipRadius) {\n            return false;\n        }\n        if (this.baseRadius !\u003d that.baseRadius) {\n            return false;\n        }\n        if (this.arrowLength !\u003d that.arrowLength) {\n            return false;\n        }\n        if (this.arrowWidth !\u003d that.arrowWidth) {\n            return false;\n        }\n        if (!this.arrowPaint.equals(that.arrowPaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.arrowStroke, that.arrowStroke)) {\n            return false;\n        }\n        if (this.labelOffset !\u003d that.labelOffset) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this instance.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d 193;\n        long temp \u003d Double.doubleToLongBits(this.angle);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.tipRadius);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.baseRadius);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.arrowLength);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.arrowWidth);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        result \u003d 37 * result + HashUtils.hashCodeForPaint(this.arrowPaint);\n        result \u003d 37 * result + this.arrowStroke.hashCode();\n        temp \u003d Double.doubleToLongBits(this.labelOffset);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        return result;\n    }\n\n    /**\n     * Returns a clone of the annotation.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  if the annotation can\u0027t be cloned.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writePaint(this.arrowPaint, stream);\n        SerialUtils.writeStroke(this.arrowStroke, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.arrowPaint \u003d SerialUtils.readPaint(stream);\n        this.arrowStroke \u003d SerialUtils.readStroke(stream);\n    }\n\n}","methodCount":23,"staticMethodCount":0,"instanceMethodCount":23,"classLoc":468,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":136503}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":9},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"eb99478b-a032-4a15-899e-ac6344337f83","hostFunctionTelemetryData":{"hostFunctionSize":295,"lineStart":56,"lineEnd":350,"bodyLineStart":56,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/annotations/TextAnnotation.java","sourceCode":"/**\n * A base class for text annotations.  This class records the content but not\n * the location of the annotation.\n */\npublic class TextAnnotation extends AbstractAnnotation implements Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d 7008912287533127432L;\n\n    /** The default font. */\n    public static final Font DEFAULT_FONT\n            \u003d new Font(\"SansSerif\", Font.PLAIN, 10);\n\n    /** The default paint. */\n    public static final Paint DEFAULT_PAINT \u003d Color.BLACK;\n\n    /** The default text anchor. */\n    public static final TextAnchor DEFAULT_TEXT_ANCHOR \u003d TextAnchor.CENTER;\n\n    /** The default rotation anchor. */\n    public static final TextAnchor DEFAULT_ROTATION_ANCHOR \u003d TextAnchor.CENTER;\n\n    /** The default rotation angle. */\n    public static final double DEFAULT_ROTATION_ANGLE \u003d 0.0;\n\n    /** The text. */\n    private String text;\n\n    /** The font. */\n    private Font font;\n\n    /** The paint. */\n    private transient Paint paint;\n\n    /** The text anchor. */\n    private TextAnchor textAnchor;\n\n    /** The rotation anchor. */\n    private TextAnchor rotationAnchor;\n\n    /** The rotation angle. */\n    private double rotationAngle;\n\n    /**\n     * Creates a text annotation with default settings.\n     *\n     * @param text  the text ({@code null} not permitted).\n     */\n    protected TextAnnotation(String text) {\n        super();\n        Args.nullNotPermitted(text, \"text\");\n        this.text \u003d text;\n        this.font \u003d DEFAULT_FONT;\n        this.paint \u003d DEFAULT_PAINT;\n        this.textAnchor \u003d DEFAULT_TEXT_ANCHOR;\n        this.rotationAnchor \u003d DEFAULT_ROTATION_ANCHOR;\n        this.rotationAngle \u003d DEFAULT_ROTATION_ANGLE;\n    }\n\n    /**\n     * Returns the text for the annotation.\n     *\n     * @return The text (never {@code null}).\n     *\n     * @see #setText(String)\n     */\n    public String getText() {\n        return this.text;\n    }\n\n    /**\n     * Sets the text for the annotation and sends an \n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param text  the text ({@code null} not permitted).\n     *\n     * @see #getText()\n     */\n    public void setText(String text) {\n        Args.nullNotPermitted(text, \"text\");\n        this.text \u003d text;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the font for the annotation.\n     *\n     * @return The font (never {@code null}).\n     *\n     * @see #setFont(Font)\n     */\n    public Font getFont() {\n        return this.font;\n    }\n\n    /**\n     * Sets the font for the annotation and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param font  the font ({@code null} not permitted).\n     *\n     * @see #getFont()\n     */\n    public void setFont(Font font) {\n        Args.nullNotPermitted(font, \"font\");\n        this.font \u003d font;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the paint for the annotation.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setPaint(Paint)\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Sets the paint for the annotation and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getPaint()\n     */\n    public void setPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.paint \u003d paint;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the text anchor.\n     *\n     * @return The text anchor.\n     *\n     * @see #setTextAnchor(TextAnchor)\n     */\n    public TextAnchor getTextAnchor() {\n        return this.textAnchor;\n    }\n\n    /**\n     * Sets the text anchor (the point on the text bounding rectangle that is\n     * aligned to the (x, y) coordinate of the annotation) and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param anchor  the anchor point ({@code null} not permitted).\n     *\n     * @see #getTextAnchor()\n     */\n    public void setTextAnchor(TextAnchor anchor) {\n        Args.nullNotPermitted(anchor, \"anchor\");\n        this.textAnchor \u003d anchor;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the rotation anchor.\n     *\n     * @return The rotation anchor point (never {@code null}).\n     *\n     * @see #setRotationAnchor(TextAnchor)\n     */\n    public TextAnchor getRotationAnchor() {\n        return this.rotationAnchor;\n    }\n\n    /**\n     * Sets the rotation anchor point and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param anchor  the anchor ({@code null} not permitted).\n     *\n     * @see #getRotationAnchor()\n     */\n    public void setRotationAnchor(TextAnchor anchor) {\n        Args.nullNotPermitted(anchor, \"anchor\");\n        this.rotationAnchor \u003d anchor;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the rotation angle in radians.\n     *\n     * @return The rotation angle.\n     *\n     * @see #setRotationAngle(double)\n     */\n    public double getRotationAngle() {\n        return this.rotationAngle;\n    }\n\n    /**\n     * Sets the rotation angle and sends an {@link AnnotationChangeEvent} to\n     * all registered listeners.  The angle is measured clockwise in radians.\n     *\n     * @param angle  the angle (in radians).\n     *\n     * @see #getRotationAngle()\n     */\n    public void setRotationAngle(double angle) {\n        this.rotationAngle \u003d angle;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Tests this object for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return {@code true} or {@code false}.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        // now try to reject equality...\n        if (!(obj instanceof TextAnnotation)) {\n            return false;\n        }\n        TextAnnotation that \u003d (TextAnnotation) obj;\n        if (!Objects.equals(this.text, that.getText())) {\n            return false;\n        }\n        if (!Objects.equals(this.font, that.getFont())) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.paint, that.getPaint())) {\n            return false;\n        }\n        if (!Objects.equals(this.textAnchor, that.getTextAnchor())) {\n            return false;\n        }\n        if (!Objects.equals(this.rotationAnchor, that.getRotationAnchor())) {\n            return false;\n        }\n        if (this.rotationAngle !\u003d that.getRotationAngle()) {\n            return false;\n        }\n\n        // seem to be the same...\n        return true;\n\n    }\n\n    /**\n     * Returns a hash code for this instance.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d 193;\n        result \u003d 37 * result + this.font.hashCode();\n        result \u003d 37 * result + HashUtils.hashCodeForPaint(this.paint);\n        result \u003d 37 * result + this.rotationAnchor.hashCode();\n        long temp \u003d Double.doubleToLongBits(this.rotationAngle);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        result \u003d 37 * result + this.text.hashCode();\n        result \u003d 37 * result + this.textAnchor.hashCode();\n        return result;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writePaint(this.paint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.paint \u003d SerialUtils.readPaint(stream);\n    }\n\n}","methodCount":17,"staticMethodCount":0,"instanceMethodCount":17,"classLoc":295,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"b49fcca5-727d-48f3-b178-e73cabd27d10","hostFunctionTelemetryData":{"hostFunctionSize":307,"lineStart":58,"lineEnd":364,"bodyLineStart":58,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/annotations/XYDataImageAnnotation.java","sourceCode":"/**\n * An annotation that allows an image to be placed within a rectangle specified\n * in data coordinates on an {@link XYPlot}.  Note that this annotation\n * is not currently serializable, so don\u0027t use it if you plan on serializing\n * your chart(s).\n */\npublic class XYDataImageAnnotation extends AbstractXYAnnotation\n        implements Cloneable, PublicCloneable, XYAnnotationBoundsInfo {\n\n    /** The image. */\n    private transient Image image;\n\n    /**\n     * The x-coordinate (in data space).\n     */\n    private double x;\n\n    /**\n     * The y-coordinate (in data space).\n     */\n    private double y;\n\n    /**\n     * The image display area width in data coordinates.\n     */\n    private double w;\n\n    /**\n     * The image display area height in data coordinates.\n     */\n    private double h;\n\n    /**\n     * A flag indicating whether or not the annotation should contribute to\n     * the data range for a plot/renderer.\n     */\n    private boolean includeInDataBounds;\n\n    /**\n     * Creates a new annotation to be displayed within the specified rectangle.\n     *\n     * @param image  the image ({@code null} not permitted).\n     * @param x  the x-coordinate (in data space).\n     * @param y  the y-coordinate (in data space).\n     * @param w  the image display area width.\n     * @param h  the image display area height.\n     */\n    public XYDataImageAnnotation(Image image, double x, double y, double w,\n            double h) {\n        this(image, x, y, w, h, false);\n    }\n\n    /**\n     * Creates a new annotation to be displayed within the specified rectangle.\n     *\n     * @param image  the image ({@code null} not permitted).\n     * @param x  the x-coordinate (in data space).\n     * @param y  the y-coordinate (in data space).\n     * @param w  the image display area width.\n     * @param h  the image display area height.\n     * @param includeInDataBounds  a flag that controls whether or not the\n     *     annotation is included in the data bounds for the axis autoRange.\n     */\n    public XYDataImageAnnotation(Image image, double x, double y, double w,\n            double h, boolean includeInDataBounds) {\n\n        super();\n        Args.nullNotPermitted(image, \"image\");\n        this.image \u003d image;\n        this.x \u003d x;\n        this.y \u003d y;\n        this.w \u003d w;\n        this.h \u003d h;\n        this.includeInDataBounds \u003d includeInDataBounds;\n    }\n\n    /**\n     * Returns the image for the annotation.\n     *\n     * @return The image.\n     */\n    public Image getImage() {\n        return this.image;\n    }\n\n    /**\n     * Returns the x-coordinate (in data space) for the annotation.\n     *\n     * @return The x-coordinate.\n     */\n    public double getX() {\n        return this.x;\n    }\n\n    /**\n     * Returns the y-coordinate (in data space) for the annotation.\n     *\n     * @return The y-coordinate.\n     */\n    public double getY() {\n        return this.y;\n    }\n\n    /**\n     * Returns the width (in data space) of the data rectangle into which the\n     * image will be drawn.\n     *\n     * @return The width.\n     */\n    public double getWidth() {\n        return this.w;\n    }\n\n    /**\n     * Returns the height (in data space) of the data rectangle into which the\n     * image will be drawn.\n     *\n     * @return The height.\n     */\n    public double getHeight() {\n        return this.h;\n    }\n\n    /**\n     * Returns the flag that controls whether or not the annotation should\n     * contribute to the autoRange for the axis it is plotted against.\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean getIncludeInDataBounds() {\n        return this.includeInDataBounds;\n    }\n\n    /**\n     * Returns the x-range for the annotation.\n     *\n     * @return The range.\n     */\n    @Override\n    public Range getXRange() {\n        return new Range(this.x, this.x + this.w);\n    }\n\n    /**\n     * Returns the y-range for the annotation.\n     *\n     * @return The range.\n     */\n    @Override\n    public Range getYRange() {\n        return new Range(this.y, this.y + this.h);\n    }\n\n    /**\n     * Draws the annotation.  This method is called by the drawing code in the\n     * {@link XYPlot} class, you don\u0027t normally need to call this method\n     * directly.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param dataArea  the data area.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param rendererIndex  the renderer index.\n     * @param info  if supplied, this info object will be populated with\n     *              entity information.\n     */\n    @Override\n    public void draw(Graphics2D g2, XYPlot plot, Rectangle2D dataArea,\n                     ValueAxis domainAxis, ValueAxis rangeAxis,\n                     int rendererIndex,\n                     PlotRenderingInfo info) {\n\n        PlotOrientation orientation \u003d plot.getOrientation();\n        AxisLocation xAxisLocation \u003d plot.getDomainAxisLocation();\n        AxisLocation yAxisLocation \u003d plot.getRangeAxisLocation();\n        RectangleEdge xEdge \u003d Plot.resolveDomainAxisLocation(xAxisLocation,\n                orientation);\n        RectangleEdge yEdge \u003d Plot.resolveRangeAxisLocation(yAxisLocation,\n                orientation);\n        float j2DX0 \u003d (float) domainAxis.valueToJava2D(this.x, dataArea, xEdge);\n        float j2DY0 \u003d (float) rangeAxis.valueToJava2D(this.y, dataArea, yEdge);\n        float j2DX1 \u003d (float) domainAxis.valueToJava2D(this.x + this.w,\n                dataArea, xEdge);\n        float j2DY1 \u003d (float) rangeAxis.valueToJava2D(this.y + this.h,\n                dataArea, yEdge);\n        float xx0 \u003d 0.0f;\n        float yy0 \u003d 0.0f;\n        float xx1 \u003d 0.0f;\n        float yy1 \u003d 0.0f;\n        if (orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n            xx0 \u003d j2DY0;\n            xx1 \u003d j2DY1;\n            yy0 \u003d j2DX0;\n            yy1 \u003d j2DX1;\n        }\n        else if (orientation \u003d\u003d PlotOrientation.VERTICAL) {\n            xx0 \u003d j2DX0;\n            xx1 \u003d j2DX1;\n            yy0 \u003d j2DY0;\n            yy1 \u003d j2DY1;\n        }\n        // TODO: rotate the image when drawn with horizontal orientation?\n        g2.drawImage(this.image, (int) xx0, (int) Math.min(yy0, yy1),\n                (int) (xx1 - xx0), (int) Math.abs(yy1 - yy0), null);\n        String toolTip \u003d getToolTipText();\n        String url \u003d getURL();\n        if (toolTip !\u003d null || url !\u003d null) {\n            addEntity(info, new Rectangle2D.Float(xx0, yy0, (xx1 - xx0),\n                    (yy1 - yy0)), rendererIndex, toolTip, url);\n        }\n    }\n\n    /**\n     * Tests this object for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        // now try to reject equality...\n        if (!super.equals(obj)) {\n            return false;\n        }\n        if (!(obj instanceof XYDataImageAnnotation)) {\n            return false;\n        }\n        XYDataImageAnnotation that \u003d (XYDataImageAnnotation) obj;\n        if (this.x !\u003d that.x) {\n            return false;\n        }\n        if (this.y !\u003d that.y) {\n            return false;\n        }\n        if (this.w !\u003d that.w) {\n            return false;\n        }\n        if (this.h !\u003d that.h) {\n            return false;\n        }\n        if (this.includeInDataBounds !\u003d that.includeInDataBounds) {\n            return false;\n        }\n        if (!Objects.equals(this.image, that.image)) {\n            return false;\n        }\n        // seems to be the same...\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this object.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        return this.image.hashCode();\n    }\n\n    /**\n     * Returns a clone of the annotation.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  if the annotation can\u0027t be cloned.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        // FIXME\n        //SerialUtils.writeImage(this.image, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        // FIXME\n        //this.image \u003d SerialUtils.readImage(stream);\n    }\n\n}","methodCount":16,"staticMethodCount":0,"instanceMethodCount":16,"classLoc":307,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"05e397f0-e0e3-4288-9ece-19961ac18311","hostFunctionTelemetryData":{"hostFunctionSize":243,"lineStart":55,"lineEnd":297,"bodyLineStart":55,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/annotations/XYDrawableAnnotation.java","sourceCode":"/**\n * A general annotation that can be placed on an {@link XYPlot}.\n */\npublic class XYDrawableAnnotation extends AbstractXYAnnotation\n        implements Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -6540812859722691020L;\n\n    /** The scaling factor. */\n    private double drawScaleFactor;\n\n    /** The x-coordinate. */\n    private double x;\n\n    /** The y-coordinate. */\n    private double y;\n\n    /** The width. */\n    private double displayWidth;\n\n    /** The height. */\n    private double displayHeight;\n\n    /** The drawable object. */\n    private Drawable drawable;\n\n    /**\n     * Creates a new annotation to be displayed within the given area.\n     *\n     * @param x  the x-coordinate for the area (must be finite).\n     * @param y  the y-coordinate for the area (must be finite).\n     * @param width  the width of the area (must be finite).\n     * @param height  the height of the area (must be finite).\n     * @param drawable  the drawable object ({@code null} not permitted).\n     */\n    public XYDrawableAnnotation(double x, double y, double width, double height,\n                                Drawable drawable) {\n        this(x, y, width, height, 1.0, drawable);\n    }\n\n    /**\n     * Creates a new annotation to be displayed within the given area.  If you\n     * specify a {@code drawScaleFactor} of 2.0, the {@code drawable}\n     * will be drawn at twice the requested display size then scaled down to\n     * fit the space.\n     *\n     * @param x  the x-coordinate for the area (must be finite).\n     * @param y  the y-coordinate for the area (must be finite).\n     * @param displayWidth  the width of the area (must be finite).\n     * @param displayHeight  the height of the area (must be finite).\n     * @param drawScaleFactor  the scaling factor for drawing (must be finite).\n     * @param drawable  the drawable object ({@code null} not permitted).\n     */\n    public XYDrawableAnnotation(double x, double y, double displayWidth,\n            double displayHeight, double drawScaleFactor, Drawable drawable) {\n        super();\n        Args.nullNotPermitted(drawable, \"drawable\");\n        Args.requireFinite(x, \"x\");\n        Args.requireFinite(y, \"y\");\n        Args.requireFinite(displayWidth, \"displayWidth\");\n        Args.requireFinite(displayHeight, \"displayHeight\");\n        Args.requireFinite(drawScaleFactor, \"drawScaleFactor\");\n        this.x \u003d x;\n        this.y \u003d y;\n        this.displayWidth \u003d displayWidth;\n        this.displayHeight \u003d displayHeight;\n        this.drawScaleFactor \u003d drawScaleFactor;\n        this.drawable \u003d drawable;\n    }\n\n    /**\n     * Returns the x-coordinate (set in the constructor).\n     * \n     * @return The x-coordinate.\n     */\n    public double getX() {\n        return x;\n    }\n\n    /**\n     * Returns the y-coordinate (set in the constructor).\n     * \n     * @return The y-coordinate.\n     */\n    public double getY() {\n        return y;\n    }\n\n    /**\n     * Returns the display width (set in the constructor).\n     * \n     * @return The display width.\n     */\n    public double getDisplayWidth() {\n        return displayWidth;\n    }\n\n    /**\n     * Returns the display height (set in the constructor).\n     * \n     * @return The display height.\n     */\n    public double getDisplayHeight() {\n        return displayHeight;\n    }\n\n    /**\n     * Returns the scale factor (set in the constructor).\n     * \n     * @return The scale factor.\n     */\n    public double getDrawScaleFactor() {\n        return drawScaleFactor;\n    }\n\n    /**\n     * Draws the annotation.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param dataArea  the data area.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param rendererIndex  the renderer index.\n     * @param info  if supplied, this info object will be populated with\n     *              entity information.\n     */\n    @Override\n    public void draw(Graphics2D g2, XYPlot plot, Rectangle2D dataArea,\n                     ValueAxis domainAxis, ValueAxis rangeAxis,\n                     int rendererIndex,\n                     PlotRenderingInfo info) {\n\n        PlotOrientation orientation \u003d plot.getOrientation();\n        RectangleEdge domainEdge \u003d Plot.resolveDomainAxisLocation(\n                plot.getDomainAxisLocation(), orientation);\n        RectangleEdge rangeEdge \u003d Plot.resolveRangeAxisLocation(\n                plot.getRangeAxisLocation(), orientation);\n        float j2DX \u003d (float) domainAxis.valueToJava2D(this.x, dataArea,\n                domainEdge);\n        float j2DY \u003d (float) rangeAxis.valueToJava2D(this.y, dataArea,\n                rangeEdge);\n        Rectangle2D displayArea \u003d new Rectangle2D.Double(\n                j2DX - this.displayWidth / 2.0,\n                j2DY - this.displayHeight / 2.0, this.displayWidth,\n                this.displayHeight);\n\n        // here we change the AffineTransform so we can draw the annotation\n        // to a larger area and scale it down into the display area\n        // afterwards, the original transform is restored\n        AffineTransform savedTransform \u003d g2.getTransform();\n        Rectangle2D drawArea \u003d new Rectangle2D.Double(0.0, 0.0,\n                this.displayWidth * this.drawScaleFactor,\n                this.displayHeight * this.drawScaleFactor);\n\n        g2.scale(1 / this.drawScaleFactor, 1 / this.drawScaleFactor);\n        g2.translate((j2DX - this.displayWidth / 2.0) * this.drawScaleFactor,\n                (j2DY - this.displayHeight / 2.0) * this.drawScaleFactor);\n        this.drawable.draw(g2, drawArea);\n        g2.setTransform(savedTransform);\n        String toolTip \u003d getToolTipText();\n        String url \u003d getURL();\n        if (toolTip !\u003d null || url !\u003d null) {\n            addEntity(info, displayArea, rendererIndex, toolTip, url);\n        }\n\n    }\n\n    /**\n     * Tests this annotation for equality with an arbitrary object.\n     *\n     * @param obj  the object to test against.\n     *\n     * @return {@code true} or {@code false}.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) { // simple case\n            return true;\n        }\n        // now try to reject equality...\n        if (!super.equals(obj)) {\n            return false;\n        }\n        if (!(obj instanceof XYDrawableAnnotation)) {\n            return false;\n        }\n        XYDrawableAnnotation that \u003d (XYDrawableAnnotation) obj;\n        if (this.x !\u003d that.x) {\n            return false;\n        }\n        if (this.y !\u003d that.y) {\n            return false;\n        }\n        if (this.displayWidth !\u003d that.displayWidth) {\n            return false;\n        }\n        if (this.displayHeight !\u003d that.displayHeight) {\n            return false;\n        }\n        if (this.drawScaleFactor !\u003d that.drawScaleFactor) {\n            return false;\n        }\n        if (!Objects.equals(this.drawable, that.drawable)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result;\n        long temp;\n        temp \u003d Double.doubleToLongBits(this.x);\n        result \u003d (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.y);\n        result \u003d 29 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.displayWidth);\n        result \u003d 29 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.displayHeight);\n        result \u003d 29 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        return result;\n    }\n\n    /**\n     * Returns a clone of the annotation.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  if the annotation can\u0027t be cloned.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n}","methodCount":11,"staticMethodCount":0,"instanceMethodCount":11,"classLoc":243,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"cc0bfe29-80bf-45eb-bd6d-2e15c8ac8908","hostFunctionTelemetryData":{"hostFunctionSize":482,"lineStart":67,"lineEnd":548,"bodyLineStart":67,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/annotations/XYPointerAnnotation.java","sourceCode":"/**\n * An arrow and label that can be placed on an {@link XYPlot}.  The arrow is\n * drawn at a user-definable angle so that it points towards the (x, y)\n * location for the annotation.\n * \u003cp\u003e\n * The arrow length (and its offset from the (x, y) location) is controlled by\n * the tip radius and the base radius attributes.  Imagine two circles around\n * the (x, y) coordinate: the inner circle defined by the tip radius, and the\n * outer circle defined by the base radius.  Now, draw the arrow starting at\n * some point on the outer circle (the point is determined by the angle), with\n * the arrow tip being drawn at a corresponding point on the inner circle.\n */\npublic class XYPointerAnnotation extends XYTextAnnotation\n        implements Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -4031161445009858551L;\n\n    /** The default tip radius (in Java2D units). */\n    public static final double DEFAULT_TIP_RADIUS \u003d 10.0;\n\n    /** The default base radius (in Java2D units). */\n    public static final double DEFAULT_BASE_RADIUS \u003d 30.0;\n\n    /** The default label offset (in Java2D units). */\n    public static final double DEFAULT_LABEL_OFFSET \u003d 3.0;\n\n    /** The default arrow length (in Java2D units). */\n    public static final double DEFAULT_ARROW_LENGTH \u003d 5.0;\n\n    /** The default arrow width (in Java2D units). */\n    public static final double DEFAULT_ARROW_WIDTH \u003d 3.0;\n\n    /** The angle of the arrow\u0027s line (in radians). */\n    private double angle;\n\n    /**\n     * The radius from the (x, y) point to the tip of the arrow (in Java2D\n     * units).\n     */\n    private double tipRadius;\n\n    /**\n     * The radius from the (x, y) point to the start of the arrow line (in\n     * Java2D units).\n     */\n    private double baseRadius;\n\n    /** The length of the arrow head (in Java2D units). */\n    private double arrowLength;\n\n    /** The arrow width (in Java2D units, per side). */\n    private double arrowWidth;\n\n    /** The arrow stroke. */\n    private transient Stroke arrowStroke;\n\n    /** The arrow paint. */\n    private transient Paint arrowPaint;\n\n    /** The radius from the base point to the anchor point for the label. */\n    private double labelOffset;\n\n    /**\n     * Creates a new label and arrow annotation.\n     *\n     * @param label  the label ({@code null} permitted).\n     * @param x  the x-coordinate (measured against the chart\u0027s domain axis).\n     * @param y  the y-coordinate (measured against the chart\u0027s range axis).\n     * @param angle  the angle of the arrow\u0027s line (in radians).\n     */\n    public XYPointerAnnotation(String label, double x, double y, double angle) {\n\n        super(label, x, y);\n        Args.requireFinite(x, \"x\");\n        Args.requireFinite(y, \"y\");\n        Args.requireFinite(angle, \"angle\");\n        this.angle \u003d angle;\n        this.tipRadius \u003d DEFAULT_TIP_RADIUS;\n        this.baseRadius \u003d DEFAULT_BASE_RADIUS;\n        this.arrowLength \u003d DEFAULT_ARROW_LENGTH;\n        this.arrowWidth \u003d DEFAULT_ARROW_WIDTH;\n        this.labelOffset \u003d DEFAULT_LABEL_OFFSET;\n        this.arrowStroke \u003d new BasicStroke(1.0f);\n        this.arrowPaint \u003d Color.BLACK;\n\n    }\n\n    /**\n     * Returns the angle of the arrow.\n     *\n     * @return The angle (in radians).\n     *\n     * @see #setAngle(double)\n     */\n    public double getAngle() {\n        return this.angle;\n    }\n\n    /**\n     * Sets the angle of the arrow and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param angle  the angle (in radians).\n     *\n     * @see #getAngle()\n     */\n    public void setAngle(double angle) {\n        this.angle \u003d angle;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the tip radius.\n     *\n     * @return The tip radius (in Java2D units).\n     *\n     * @see #setTipRadius(double)\n     */\n    public double getTipRadius() {\n        return this.tipRadius;\n    }\n\n    /**\n     * Sets the tip radius and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param radius  the radius (in Java2D units).\n     *\n     * @see #getTipRadius()\n     */\n    public void setTipRadius(double radius) {\n        this.tipRadius \u003d radius;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the base radius.\n     *\n     * @return The base radius (in Java2D units).\n     *\n     * @see #setBaseRadius(double)\n     */\n    public double getBaseRadius() {\n        return this.baseRadius;\n    }\n\n    /**\n     * Sets the base radius and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param radius  the radius (in Java2D units).\n     *\n     * @see #getBaseRadius()\n     */\n    public void setBaseRadius(double radius) {\n        this.baseRadius \u003d radius;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the label offset.\n     *\n     * @return The label offset (in Java2D units).\n     *\n     * @see #setLabelOffset(double)\n     */\n    public double getLabelOffset() {\n        return this.labelOffset;\n    }\n\n    /**\n     * Sets the label offset (from the arrow base, continuing in a straight\n     * line, in Java2D units) and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset (in Java2D units).\n     *\n     * @see #getLabelOffset()\n     */\n    public void setLabelOffset(double offset) {\n        this.labelOffset \u003d offset;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the arrow length.\n     *\n     * @return The arrow length.\n     *\n     * @see #setArrowLength(double)\n     */\n    public double getArrowLength() {\n        return this.arrowLength;\n    }\n\n    /**\n     * Sets the arrow length and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param length  the length.\n     *\n     * @see #getArrowLength()\n     */\n    public void setArrowLength(double length) {\n        this.arrowLength \u003d length;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the arrow width.\n     *\n     * @return The arrow width (in Java2D units).\n     *\n     * @see #setArrowWidth(double)\n     */\n    public double getArrowWidth() {\n        return this.arrowWidth;\n    }\n\n    /**\n     * Sets the arrow width and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param width  the width (in Java2D units).\n     *\n     * @see #getArrowWidth()\n     */\n    public void setArrowWidth(double width) {\n        this.arrowWidth \u003d width;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the stroke used to draw the arrow line.\n     *\n     * @return The arrow stroke (never {@code null}).\n     *\n     * @see #setArrowStroke(Stroke)\n     */\n    public Stroke getArrowStroke() {\n        return this.arrowStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the arrow line and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getArrowStroke()\n     */\n    public void setArrowStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.arrowStroke \u003d stroke;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the paint used for the arrow.\n     *\n     * @return The arrow paint (never {@code null}).\n     *\n     * @see #setArrowPaint(Paint)\n     */\n    public Paint getArrowPaint() {\n        return this.arrowPaint;\n    }\n\n    /**\n     * Sets the paint used for the arrow and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param paint  the arrow paint ({@code null} not permitted).\n     *\n     * @see #getArrowPaint()\n     */\n    public void setArrowPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.arrowPaint \u003d paint;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Draws the annotation.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param dataArea  the data area.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param rendererIndex  the renderer index.\n     * @param info  the plot rendering info.\n     */\n    @Override\n    public void draw(Graphics2D g2, XYPlot plot, Rectangle2D dataArea,\n            ValueAxis domainAxis, ValueAxis rangeAxis, int rendererIndex, \n            PlotRenderingInfo info) {\n\n        PlotOrientation orientation \u003d plot.getOrientation();\n        RectangleEdge domainEdge \u003d Plot.resolveDomainAxisLocation(\n                plot.getDomainAxisLocation(), orientation);\n        RectangleEdge rangeEdge \u003d Plot.resolveRangeAxisLocation(\n                plot.getRangeAxisLocation(), orientation);\n        double j2DX \u003d domainAxis.valueToJava2D(getX(), dataArea, domainEdge);\n        double j2DY \u003d rangeAxis.valueToJava2D(getY(), dataArea, rangeEdge);\n        if (orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n            double temp \u003d j2DX;\n            j2DX \u003d j2DY;\n            j2DY \u003d temp;\n        }\n        double startX \u003d j2DX + Math.cos(this.angle) * this.baseRadius;\n        double startY \u003d j2DY + Math.sin(this.angle) * this.baseRadius;\n\n        double endX \u003d j2DX + Math.cos(this.angle) * this.tipRadius;\n        double endY \u003d j2DY + Math.sin(this.angle) * this.tipRadius;\n\n        double arrowBaseX \u003d endX + Math.cos(this.angle) * this.arrowLength;\n        double arrowBaseY \u003d endY + Math.sin(this.angle) * this.arrowLength;\n\n        double arrowLeftX \u003d arrowBaseX\n                + Math.cos(this.angle + Math.PI / 2.0) * this.arrowWidth;\n        double arrowLeftY \u003d arrowBaseY\n                + Math.sin(this.angle + Math.PI / 2.0) * this.arrowWidth;\n\n        double arrowRightX \u003d arrowBaseX\n                - Math.cos(this.angle + Math.PI / 2.0) * this.arrowWidth;\n        double arrowRightY \u003d arrowBaseY\n                - Math.sin(this.angle + Math.PI / 2.0) * this.arrowWidth;\n\n        GeneralPath arrow \u003d new GeneralPath();\n        arrow.moveTo((float) endX, (float) endY);\n        arrow.lineTo((float) arrowLeftX, (float) arrowLeftY);\n        arrow.lineTo((float) arrowRightX, (float) arrowRightY);\n        arrow.closePath();\n\n        g2.setStroke(this.arrowStroke);\n        g2.setPaint(this.arrowPaint);\n        Line2D line \u003d new Line2D.Double(startX, startY, arrowBaseX, arrowBaseY);\n        g2.draw(line);\n        g2.fill(arrow);\n\n        // draw the label\n        double labelX \u003d j2DX + Math.cos(this.angle) * (this.baseRadius\n                + this.labelOffset);\n        double labelY \u003d j2DY + Math.sin(this.angle) * (this.baseRadius\n                + this.labelOffset);\n        g2.setFont(getFont());\n        Shape hotspot \u003d TextUtils.calculateRotatedStringBounds(\n                getText(), g2, (float) labelX, (float) labelY, getTextAnchor(),\n                getRotationAngle(), getRotationAnchor());\n        if (getBackgroundPaint() !\u003d null) {\n            g2.setPaint(getBackgroundPaint());\n            g2.fill(hotspot);\n        }\n        g2.setPaint(getPaint());\n        TextUtils.drawRotatedString(getText(), g2, (float) labelX,\n                (float) labelY, getTextAnchor(), getRotationAngle(),\n                getRotationAnchor());\n        if (isOutlineVisible()) {\n            g2.setStroke(getOutlineStroke());\n            g2.setPaint(getOutlinePaint());\n            g2.draw(hotspot);\n        }\n\n        String toolTip \u003d getToolTipText();\n        String url \u003d getURL();\n        if (toolTip !\u003d null || url !\u003d null) {\n            addEntity(info, hotspot, rendererIndex, toolTip, url);\n        }\n\n    }\n\n    /**\n     * Tests this annotation for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return {@code true} or {@code false}.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof XYPointerAnnotation)) {\n            return false;\n        }\n        XYPointerAnnotation that \u003d (XYPointerAnnotation) obj;\n        if (this.angle !\u003d that.angle) {\n            return false;\n        }\n        if (this.tipRadius !\u003d that.tipRadius) {\n            return false;\n        }\n        if (this.baseRadius !\u003d that.baseRadius) {\n            return false;\n        }\n        if (this.arrowLength !\u003d that.arrowLength) {\n            return false;\n        }\n        if (this.arrowWidth !\u003d that.arrowWidth) {\n            return false;\n        }\n        if (!this.arrowPaint.equals(that.arrowPaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.arrowStroke, that.arrowStroke)) {\n            return false;\n        }\n        if (this.labelOffset !\u003d that.labelOffset) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a hash code for this instance.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d super.hashCode();\n        long temp \u003d Double.doubleToLongBits(this.angle);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.tipRadius);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.baseRadius);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.arrowLength);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.arrowWidth);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        result \u003d result * 37 + HashUtils.hashCodeForPaint(this.arrowPaint);\n        result \u003d result * 37 + this.arrowStroke.hashCode();\n        temp \u003d Double.doubleToLongBits(this.labelOffset);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        return result;\n    }\n\n    /**\n     * Returns a clone of the annotation.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  if the annotation can\u0027t be cloned.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writePaint(this.arrowPaint, stream);\n        SerialUtils.writeStroke(this.arrowStroke, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.arrowPaint \u003d SerialUtils.readPaint(stream);\n        this.arrowStroke \u003d SerialUtils.readStroke(stream);\n    }\n\n}","methodCount":23,"staticMethodCount":0,"instanceMethodCount":23,"classLoc":482,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"7f8b21fd-902a-40b6-ba94-6c68e71986c2","hostFunctionTelemetryData":{"hostFunctionSize":286,"lineStart":65,"lineEnd":350,"bodyLineStart":65,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/annotations/XYPolygonAnnotation.java","sourceCode":"/**\n * A polygon annotation that can be placed on an {@link XYPlot}.  The\n * polygon coordinates are specified in data space.\n */\npublic class XYPolygonAnnotation extends AbstractXYAnnotation\n        implements Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -6984203651995900036L;\n\n    /** The polygon. */\n    private double[] polygon;\n\n    /** The stroke used to draw the box outline. */\n    private transient Stroke stroke;\n\n    /** The paint used to draw the box outline. */\n    private transient Paint outlinePaint;\n\n    /** The paint used to fill the box. */\n    private transient Paint fillPaint;\n\n    /**\n     * Creates a new annotation (where, by default, the polygon is drawn\n     * with a black outline).  The array of polygon coordinates must contain\n     * an even number of coordinates (each pair is an (x, y) location on the\n     * plot) and the last point is automatically joined back to the first point.\n     *\n     * @param polygon  the coordinates of the polygon\u0027s vertices\n     *     ({@code null} not permitted).\n     */\n    public XYPolygonAnnotation(double[] polygon) {\n        this(polygon, new BasicStroke(1.0f), Color.BLACK);\n    }\n\n    /**\n     * Creates a new annotation where the box is drawn as an outline using\n     * the specified {@code stroke} and {@code outlinePaint}.\n     * The array of polygon coordinates must contain an even number of\n     * coordinates (each pair is an (x, y) location on the plot) and the last\n     * point is automatically joined back to the first point.\n     *\n     * @param polygon  the coordinates of the polygon\u0027s vertices\n     *     ({@code null} not permitted).\n     * @param stroke  the shape stroke ({@code null} permitted).\n     * @param outlinePaint  the shape color ({@code null} permitted).\n     */\n    public XYPolygonAnnotation(double[] polygon,\n                               Stroke stroke, Paint outlinePaint) {\n        this(polygon, stroke, outlinePaint, null);\n    }\n\n    /**\n     * Creates a new annotation.  The array of polygon coordinates must\n     * contain an even number of coordinates (each pair is an (x, y) location\n     * on the plot) and the last point is automatically joined back to the\n     * first point.\n     *\n     * @param polygon  the coordinates of the polygon\u0027s vertices\n     *     ({@code null} not permitted).\n     * @param stroke  the shape stroke ({@code null} permitted).\n     * @param outlinePaint  the shape color ({@code null} permitted).\n     * @param fillPaint  the paint used to fill the shape ({@code null}\n     *                   permitted).\n     */\n    public XYPolygonAnnotation(double[] polygon, Stroke stroke, \n            Paint outlinePaint, Paint fillPaint) {\n        super();\n        Args.nullNotPermitted(polygon, \"polygon\");\n        if (polygon.length % 2 !\u003d 0) {\n            throw new IllegalArgumentException(\"The \u0027polygon\u0027 array must \"\n                    + \"contain an even number of items.\");\n        }\n        this.polygon \u003d (double[]) polygon.clone();\n        this.stroke \u003d stroke;\n        this.outlinePaint \u003d outlinePaint;\n        this.fillPaint \u003d fillPaint;\n    }\n\n    /**\n     * Returns the coordinates of the polygon\u0027s vertices.  The returned array\n     * is a copy, so it is safe to modify without altering the annotation\u0027s\n     * state.\n     *\n     * @return The coordinates of the polygon\u0027s vertices.\n     */\n    public double[] getPolygonCoordinates() {\n        return (double[]) this.polygon.clone();\n    }\n\n    /**\n     * Returns the fill paint.\n     *\n     * @return The fill paint (possibly {@code null}).\n     */\n    public Paint getFillPaint() {\n        return this.fillPaint;\n    }\n\n    /**\n     * Returns the outline stroke.\n     *\n     * @return The outline stroke (possibly {@code null}).\n     */\n    public Stroke getOutlineStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint (possibly {@code null}).\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Draws the annotation.  This method is usually called by the\n     * {@link XYPlot} class, you shouldn\u0027t need to call it directly.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param dataArea  the data area.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param rendererIndex  the renderer index.\n     * @param info  the plot rendering info.\n     */\n    @Override\n    public void draw(Graphics2D g2, XYPlot plot, Rectangle2D dataArea,\n                     ValueAxis domainAxis, ValueAxis rangeAxis,\n                     int rendererIndex, PlotRenderingInfo info) {\n\n        // if we don\u0027t have at least 2 (x, y) coordinates, just return\n        if (this.polygon.length \u003c 4) {\n            return;\n        }\n        PlotOrientation orientation \u003d plot.getOrientation();\n        RectangleEdge domainEdge \u003d Plot.resolveDomainAxisLocation(\n                plot.getDomainAxisLocation(), orientation);\n        RectangleEdge rangeEdge \u003d Plot.resolveRangeAxisLocation(\n                plot.getRangeAxisLocation(), orientation);\n\n        GeneralPath area \u003d new GeneralPath();\n        double x \u003d domainAxis.valueToJava2D(this.polygon[0], dataArea,\n                domainEdge);\n        double y \u003d rangeAxis.valueToJava2D(this.polygon[1], dataArea,\n                rangeEdge);\n        if (orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n            area.moveTo((float) y, (float) x);\n            for (int i \u003d 2; i \u003c this.polygon.length; i +\u003d 2) {\n                x \u003d domainAxis.valueToJava2D(this.polygon[i], dataArea,\n                        domainEdge);\n                y \u003d rangeAxis.valueToJava2D(this.polygon[i + 1], dataArea,\n                        rangeEdge);\n                area.lineTo((float) y, (float) x);\n            }\n            area.closePath();\n        }\n        else if (orientation \u003d\u003d PlotOrientation.VERTICAL) {\n            area.moveTo((float) x, (float) y);\n            for (int i \u003d 2; i \u003c this.polygon.length; i +\u003d 2) {\n                x \u003d domainAxis.valueToJava2D(this.polygon[i], dataArea,\n                        domainEdge);\n                y \u003d rangeAxis.valueToJava2D(this.polygon[i + 1], dataArea,\n                        rangeEdge);\n                area.lineTo((float) x, (float) y);\n            }\n            area.closePath();\n       }\n\n\n        if (this.fillPaint !\u003d null) {\n            g2.setPaint(this.fillPaint);\n            g2.fill(area);\n        }\n\n        if (this.stroke !\u003d null \u0026\u0026 this.outlinePaint !\u003d null) {\n            g2.setPaint(this.outlinePaint);\n            g2.setStroke(this.stroke);\n            g2.draw(area);\n        }\n        addEntity(info, area, rendererIndex, getToolTipText(), getURL());\n\n    }\n\n    /**\n     * Tests this annotation for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        // now try to reject equality\n        if (!super.equals(obj)) {\n            return false;\n        }\n        if (!(obj instanceof XYPolygonAnnotation)) {\n            return false;\n        }\n        XYPolygonAnnotation that \u003d (XYPolygonAnnotation) obj;\n        if (!Arrays.equals(this.polygon, that.polygon)) {\n            return false;\n        }\n        if (!Objects.equals(this.stroke, that.stroke)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.outlinePaint, that.outlinePaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.fillPaint, that.fillPaint)) {\n            return false;\n        }\n        // seem to be the same\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this instance.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d 193;\n        result \u003d 37 * result + HashUtils.hashCodeForDoubleArray(\n                this.polygon);\n        result \u003d 37 * result + HashUtils.hashCodeForPaint(this.fillPaint);\n        result \u003d 37 * result + HashUtils.hashCodeForPaint(\n                this.outlinePaint);\n        if (this.stroke !\u003d null) {\n            result \u003d 37 * result + this.stroke.hashCode();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a clone.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException not thrown by this class, but may be\n     *                                    by subclasses.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream ({@code null} not permitted).\n     *\n     * @throws IOException if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writeStroke(this.stroke, stream);\n        SerialUtils.writePaint(this.outlinePaint, stream);\n        SerialUtils.writePaint(this.fillPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream ({@code null} not permitted).\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n            throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.stroke \u003d SerialUtils.readStroke(stream);\n        this.outlinePaint \u003d SerialUtils.readPaint(stream);\n        this.fillPaint \u003d SerialUtils.readPaint(stream);\n    }\n\n}","methodCount":13,"staticMethodCount":0,"instanceMethodCount":13,"classLoc":286,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"9a3cfcfc-902f-4555-9385-be1508589b47","hostFunctionTelemetryData":{"hostFunctionSize":578,"lineStart":67,"lineEnd":644,"bodyLineStart":67,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/annotations/XYTextAnnotation.java","sourceCode":"/**\n * A text annotation that can be placed at a particular (x, y) location on an\n * {@link XYPlot}.\n */\npublic class XYTextAnnotation extends AbstractXYAnnotation\n        implements Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -2946063342782506328L;\n\n    /** The default font. */\n    public static final Font DEFAULT_FONT \u003d new Font(\"SansSerif\", Font.PLAIN,\n            10);\n\n    /** The default paint. */\n    public static final Paint DEFAULT_PAINT \u003d Color.BLACK;\n\n    /** The default text anchor. */\n    public static final TextAnchor DEFAULT_TEXT_ANCHOR \u003d TextAnchor.CENTER;\n\n    /** The default rotation anchor. */\n    public static final TextAnchor DEFAULT_ROTATION_ANCHOR \u003d TextAnchor.CENTER;\n\n    /** The default rotation angle. */\n    public static final double DEFAULT_ROTATION_ANGLE \u003d 0.0;\n\n    /** The text. */\n    private String text;\n\n    /** The font. */\n    private Font font;\n\n    /** The paint. */\n    private transient Paint paint;\n\n    /** The x-coordinate. */\n    private double x;\n\n    /** The y-coordinate. */\n    private double y;\n\n    /** The text anchor (to be aligned with (x, y)). */\n    private TextAnchor textAnchor;\n\n    /** The rotation anchor. */\n    private TextAnchor rotationAnchor;\n\n    /** The rotation angle. */\n    private double rotationAngle;\n\n    /**\n     * The background paint (possibly null).\n     */\n    private transient Paint backgroundPaint;\n\n    /**\n     * The flag that controls the visibility of the outline.\n     */\n    private boolean outlineVisible;\n\n    /**\n     * The outline paint (never null).\n     */\n    private transient Paint outlinePaint;\n\n    /**\n     * The outline stroke (never null).\n     */\n    private transient Stroke outlineStroke;\n\n    /**\n     * Creates a new annotation to be displayed at the given coordinates.  The\n     * coordinates are specified in data space (they will be converted to\n     * Java2D space for display).\n     *\n     * @param text  the text ({@code null} not permitted).\n     * @param x  the x-coordinate (in data space, must be finite).\n     * @param y  the y-coordinate (in data space, must be finite).\n     */\n    public XYTextAnnotation(String text, double x, double y) {\n        super();\n        Args.nullNotPermitted(text, \"text\");\n        Args.requireFinite(x, \"x\");\n        Args.requireFinite(y, \"y\");\n        this.text \u003d text;\n        this.font \u003d DEFAULT_FONT;\n        this.paint \u003d DEFAULT_PAINT;\n        this.x \u003d x;\n        this.y \u003d y;\n        this.textAnchor \u003d DEFAULT_TEXT_ANCHOR;\n        this.rotationAnchor \u003d DEFAULT_ROTATION_ANCHOR;\n        this.rotationAngle \u003d DEFAULT_ROTATION_ANGLE;\n\n        // by default the outline and background won\u0027t be visible\n        this.backgroundPaint \u003d null;\n        this.outlineVisible \u003d false;\n        this.outlinePaint \u003d Color.BLACK;\n        this.outlineStroke \u003d new BasicStroke(0.5f);\n    }\n\n    /**\n     * Returns the text for the annotation.\n     *\n     * @return The text (never {@code null}).\n     *\n     * @see #setText(String)\n     */\n    public String getText() {\n        return this.text;\n    }\n\n    /**\n     * Sets the text for the annotation.\n     *\n     * @param text  the text ({@code null} not permitted).\n     *\n     * @see #getText()\n     */\n    public void setText(String text) {\n        Args.nullNotPermitted(text, \"text\");\n        this.text \u003d text;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the font for the annotation.\n     *\n     * @return The font (never {@code null}).\n     *\n     * @see #setFont(Font)\n     */\n    public Font getFont() {\n        return this.font;\n    }\n\n    /**\n     * Sets the font for the annotation and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param font  the font ({@code null} not permitted).\n     *\n     * @see #getFont()\n     */\n    public void setFont(Font font) {\n        Args.nullNotPermitted(font, \"font\");\n        this.font \u003d font;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the paint for the annotation.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setPaint(Paint)\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Sets the paint for the annotation and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getPaint()\n     */\n    public void setPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.paint \u003d paint;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the text anchor.\n     *\n     * @return The text anchor (never {@code null}).\n     *\n     * @see #setTextAnchor(TextAnchor)\n     */\n    public TextAnchor getTextAnchor() {\n        return this.textAnchor;\n    }\n\n    /**\n     * Sets the text anchor (the point on the text bounding rectangle that is\n     * aligned to the (x, y) coordinate of the annotation) and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param anchor  the anchor point ({@code null} not permitted).\n     *\n     * @see #getTextAnchor()\n     */\n    public void setTextAnchor(TextAnchor anchor) {\n        Args.nullNotPermitted(anchor, \"anchor\");\n        this.textAnchor \u003d anchor;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the rotation anchor.\n     *\n     * @return The rotation anchor point (never {@code null}).\n     *\n     * @see #setRotationAnchor(TextAnchor)\n     */\n    public TextAnchor getRotationAnchor() {\n        return this.rotationAnchor;\n    }\n\n    /**\n     * Sets the rotation anchor point and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param anchor  the anchor ({@code null} not permitted).\n     *\n     * @see #getRotationAnchor()\n     */\n    public void setRotationAnchor(TextAnchor anchor) {\n        Args.nullNotPermitted(anchor, \"anchor\");\n        this.rotationAnchor \u003d anchor;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the rotation angle.\n     *\n     * @return The rotation angle.\n     *\n     * @see #setRotationAngle(double)\n     */\n    public double getRotationAngle() {\n        return this.rotationAngle;\n    }\n\n    /**\n     * Sets the rotation angle and sends an {@link AnnotationChangeEvent} to\n     * all registered listeners.  The angle is measured clockwise in radians.\n     *\n     * @param angle  the angle (in radians).\n     *\n     * @see #getRotationAngle()\n     */\n    public void setRotationAngle(double angle) {\n        this.rotationAngle \u003d angle;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the x coordinate for the text anchor point (measured against the\n     * domain axis).\n     *\n     * @return The x coordinate (in data space).\n     *\n     * @see #setX(double)\n     */\n    public double getX() {\n        return this.x;\n    }\n\n    /**\n     * Sets the x coordinate for the text anchor point (measured against the\n     * domain axis) and sends an {@link AnnotationChangeEvent} to all\n     * registered listeners.\n     *\n     * @param x  the x coordinate (in data space).\n     *\n     * @see #getX()\n     */\n    public void setX(double x) {\n        Args.requireFinite(x, \"x\");\n        this.x \u003d x;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the y coordinate for the text anchor point (measured against the\n     * range axis).\n     *\n     * @return The y coordinate (in data space).\n     *\n     * @see #setY(double)\n     */\n    public double getY() {\n        return this.y;\n    }\n\n    /**\n     * Sets the y coordinate for the text anchor point (measured against the\n     * range axis) and sends an {@link AnnotationChangeEvent} to all registered\n     * listeners.\n     *\n     * @param y  the y coordinate.\n     *\n     * @see #getY()\n     */\n    public void setY(double y) {\n        Args.requireFinite(y, \"y\");\n        this.y \u003d y;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the background paint for the annotation.\n     *\n     * @return The background paint (possibly {@code null}).\n     *\n     * @see #setBackgroundPaint(Paint)\n     */\n    public Paint getBackgroundPaint() {\n        return this.backgroundPaint;\n    }\n\n    /**\n     * Sets the background paint for the annotation and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} permitted).\n     *\n     * @see #getBackgroundPaint()\n     */\n    public void setBackgroundPaint(Paint paint) {\n        this.backgroundPaint \u003d paint;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the outline paint for the annotation.\n     *\n     * @return The outline paint (never {@code null}).\n     *\n     * @see #setOutlinePaint(Paint)\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Sets the outline paint for the annotation and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getOutlinePaint()\n     */\n    public void setOutlinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.outlinePaint \u003d paint;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the outline stroke for the annotation.\n     *\n     * @return The outline stroke (never {@code null}).\n     *\n     * @see #setOutlineStroke(Stroke)\n     */\n    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }\n\n    /**\n     * Sets the outline stroke for the annotation and sends an\n     * {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getOutlineStroke()\n     */\n    public void setOutlineStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.outlineStroke \u003d stroke;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Returns the flag that controls whether or not the outline is drawn.\n     *\n     * @return A boolean.\n     */\n    public boolean isOutlineVisible() {\n        return this.outlineVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the outline is drawn and\n     * sends an {@link AnnotationChangeEvent} to all registered listeners.\n     *\n     * @param visible  the new flag value.\n     */\n    public void setOutlineVisible(boolean visible) {\n        this.outlineVisible \u003d visible;\n        fireAnnotationChanged();\n    }\n\n    /**\n     * Draws the annotation.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param dataArea  the data area.\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param rendererIndex  the renderer index.\n     * @param info  an optional info object that will be populated with\n     *              entity information.\n     */\n    @Override\n    public void draw(Graphics2D g2, XYPlot plot, Rectangle2D dataArea,\n                     ValueAxis domainAxis, ValueAxis rangeAxis,\n                     int rendererIndex, PlotRenderingInfo info) {\n\n        PlotOrientation orientation \u003d plot.getOrientation();\n        RectangleEdge domainEdge \u003d Plot.resolveDomainAxisLocation(\n                plot.getDomainAxisLocation(), orientation);\n        RectangleEdge rangeEdge \u003d Plot.resolveRangeAxisLocation(\n                plot.getRangeAxisLocation(), orientation);\n\n        float anchorX \u003d (float) domainAxis.valueToJava2D(\n                this.x, dataArea, domainEdge);\n        float anchorY \u003d (float) rangeAxis.valueToJava2D(\n                this.y, dataArea, rangeEdge);\n\n        if (orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n            float tempAnchor \u003d anchorX;\n            anchorX \u003d anchorY;\n            anchorY \u003d tempAnchor;\n        }\n\n        g2.setFont(getFont());\n        Shape hotspot \u003d TextUtils.calculateRotatedStringBounds(\n                getText(), g2, anchorX, anchorY, getTextAnchor(),\n                getRotationAngle(), getRotationAnchor());\n        if (this.backgroundPaint !\u003d null) {\n            g2.setPaint(this.backgroundPaint);\n            g2.fill(hotspot);\n        }\n        g2.setPaint(getPaint());\n        TextUtils.drawRotatedString(getText(), g2, anchorX, anchorY,\n                getTextAnchor(), getRotationAngle(), getRotationAnchor());\n        if (this.outlineVisible) {\n            g2.setStroke(this.outlineStroke);\n            g2.setPaint(this.outlinePaint);\n            g2.draw(hotspot);\n        }\n\n        String toolTip \u003d getToolTipText();\n        String url \u003d getURL();\n        if (toolTip !\u003d null || url !\u003d null) {\n            addEntity(info, hotspot, rendererIndex, toolTip, url);\n        }\n\n    }\n\n    /**\n     * Tests this annotation for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof XYTextAnnotation)) {\n            return false;\n        }\n        XYTextAnnotation that \u003d (XYTextAnnotation) obj;\n        if (!this.text.equals(that.text)) {\n            return false;\n        }\n        if (this.x !\u003d that.x) {\n            return false;\n        }\n        if (this.y !\u003d that.y) {\n            return false;\n        }\n        if (!this.font.equals(that.font)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.paint, that.paint)) {\n            return false;\n        }\n        if (!this.rotationAnchor.equals(that.rotationAnchor)) {\n            return false;\n        }\n        if (this.rotationAngle !\u003d that.rotationAngle) {\n            return false;\n        }\n        if (!this.textAnchor.equals(that.textAnchor)) {\n            return false;\n        }\n        if (this.outlineVisible !\u003d that.outlineVisible) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.backgroundPaint, that.backgroundPaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.outlinePaint, that.outlinePaint)) {\n            return false;\n        }\n        if (!(this.outlineStroke.equals(that.outlineStroke))) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a hash code for the object.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d 193;\n        result \u003d 37 * result + this.text.hashCode();\n        result \u003d 37 * result + this.font.hashCode();\n        result \u003d 37 * result + HashUtils.hashCodeForPaint(this.paint);\n        long temp \u003d Double.doubleToLongBits(this.x);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.y);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        result \u003d 37 * result + this.textAnchor.hashCode();\n        result \u003d 37 * result + this.rotationAnchor.hashCode();\n        temp \u003d Double.doubleToLongBits(this.rotationAngle);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        return result;\n    }\n\n    /**\n     * Returns a clone of the annotation.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  if the annotation can\u0027t be cloned.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writePaint(this.paint, stream);\n        SerialUtils.writePaint(this.backgroundPaint, stream);\n        SerialUtils.writePaint(this.outlinePaint, stream);\n        SerialUtils.writeStroke(this.outlineStroke, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.paint \u003d SerialUtils.readPaint(stream);\n        this.backgroundPaint \u003d SerialUtils.readPaint(stream);\n        this.outlinePaint \u003d SerialUtils.readPaint(stream);\n        this.outlineStroke \u003d SerialUtils.readStroke(stream);\n    }\n\n}","methodCount":31,"staticMethodCount":0,"instanceMethodCount":31,"classLoc":578,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"09625fcb-17d7-4897-a1c0-403ab0482ad6","hostFunctionTelemetryData":{"hostFunctionSize":489,"lineStart":35,"lineEnd":523,"bodyLineStart":35,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/api/RectangleInsets.java","sourceCode":"/**\n * Represents the insets for a rectangle, specified in absolute or relative \n * terms. This class is immutable.\n */\npublic class RectangleInsets implements Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d 1902273207559319996L;\n    \n    /**\n     * A useful constant representing zero insets.\n     */\n    public static final RectangleInsets ZERO_INSETS \u003d new RectangleInsets(\n        UnitType.ABSOLUTE, 0.0, 0.0, 0.0, 0.0);\n    \n    /** Absolute or relative units. */\n    private UnitType unitType;\n    \n    /** The top insets. */\n    private double top;\n    \n    /** The left insets. */\n    private double left;\n    \n    /** The bottom insets. */\n    private double bottom;\n    \n    /** The right insets. */\n    private double right;\n    \n    /**\n     * Creates a new instance with all insets initialised to {@code 1.0}.\n     */\n    public RectangleInsets() {\n        this(1.0, 1.0, 1.0, 1.0);\n    }\n    \n    /**\n     * Creates a new instance with the specified insets (as \u0027absolute\u0027 units).\n     * \n     * @param top  the top insets.\n     * @param left  the left insets.\n     * @param bottom  the bottom insets.\n     * @param right  the right insets.\n     */\n    public RectangleInsets(double top, double left, double bottom, \n            double right) {\n        this(UnitType.ABSOLUTE, top, left, bottom, right);   \n    }\n    \n    /**\n     * Creates a new instance.\n     * \n     * @param unitType  absolute or relative units ({@code null} not permitted).\n     * @param top  the top insets.\n     * @param left  the left insets.\n     * @param bottom  the bottom insets.\n     * @param right  the right insets.\n     */\n    public RectangleInsets(UnitType unitType, double top, double left, \n            double bottom, double right) {\n        Args.nullNotPermitted(unitType, \"unitType\");\n        this.unitType \u003d unitType;\n        this.top \u003d top;\n        this.bottom \u003d bottom;\n        this.left \u003d left;\n        this.right \u003d right;\n    }\n    \n    /**\n     * Returns the unit type (absolute or relative).  This specifies whether \n     * the insets are measured as Java2D units or percentages.\n     * \n     * @return The unit type (never {@code null}).\n     */\n    public UnitType getUnitType() {\n        return this.unitType;\n    }\n  \n    /**\n     * Returns the top insets.\n     * \n     * @return The top insets.\n     */\n    public double getTop() {\n        return this.top;\n    }\n    \n    /**\n     * Returns the bottom insets.\n     * \n     * @return The bottom insets.\n     */\n    public double getBottom() {\n        return this.bottom;\n    }\n    \n    /**\n     * Returns the left insets.\n     * \n     * @return The left insets.\n     */\n    public double getLeft() {\n        return this.left;\n    }\n    \n    /**\n     * Returns the right insets.\n     * \n     * @return The right insets.\n     */\n    public double getRight() {\n        return this.right;\n    }\n    \n    /**\n     * Tests this instance for equality with an arbitrary object.\n     * \n     * @param obj  the object ({@code null} permitted).\n     * \n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;   \n        }\n        if (!(obj instanceof RectangleInsets)) {\n                return false;\n        }\n        final RectangleInsets that \u003d (RectangleInsets) obj;\n        if (that.unitType !\u003d this.unitType) {\n            return false;   \n        }\n        if (this.left !\u003d that.left) {\n            return false;   \n        }\n        if (this.right !\u003d that.right) {\n            return false;   \n        }\n        if (this.top !\u003d that.top) {\n            return false;   \n        }\n        if (this.bottom !\u003d that.bottom) {\n            return false;   \n        }\n        return true;   \n    }\n\n    /**\n     * Returns a hash code for the object.\n     * \n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result;\n        long temp;\n        result \u003d (this.unitType !\u003d null ? this.unitType.hashCode() : 0);\n        temp \u003d this.top !\u003d +0.0d ? Double.doubleToLongBits(this.top) : 0L;\n        result \u003d 29 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d this.bottom !\u003d +0.0d ? Double.doubleToLongBits(this.bottom) : 0L;\n        result \u003d 29 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d this.left !\u003d +0.0d ? Double.doubleToLongBits(this.left) : 0L;\n        result \u003d 29 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d this.right !\u003d +0.0d ? Double.doubleToLongBits(this.right) : 0L;\n        result \u003d 29 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        return result;\n    }\n\n    /**\n     * Returns a textual representation of this instance, useful for debugging\n     * purposes.\n     * \n     * @return A string representing this instance.\n     */\n    @Override\n    public String toString() {\n        return \"RectangleInsets[t\u003d\" + this.top + \",l\u003d\" + this.left\n                + \",b\u003d\" + this.bottom + \",r\u003d\" + this.right + \"]\";\n    }\n    \n    /**\n     * Creates an adjusted rectangle using the supplied rectangle, the insets\n     * specified by this instance, and the horizontal and vertical \n     * adjustment types.\n     * \n     * @param base  the base rectangle ({@code null} not permitted).\n     * @param horizontal  the horizontal adjustment type ({@code null} not\n     *                    permitted).\n     * @param vertical  the vertical adjustment type ({@code null} not \n     *                  permitted).\n     * \n     * @return The inset rectangle.\n     */\n    public Rectangle2D createAdjustedRectangle(Rectangle2D base,\n            LengthAdjustmentType horizontal, LengthAdjustmentType vertical) {\n        Args.nullNotPermitted(base, \"base\");\n        double x \u003d base.getX();\n        double y \u003d base.getY();\n        double w \u003d base.getWidth();\n        double h \u003d base.getHeight();\n        if (horizontal \u003d\u003d LengthAdjustmentType.EXPAND) {\n            final double leftOutset \u003d calculateLeftOutset(w);\n            x \u003d x - leftOutset;\n            w \u003d w + leftOutset + calculateRightOutset(w);\n        }\n        else if (horizontal \u003d\u003d LengthAdjustmentType.CONTRACT) {\n            final double leftMargin \u003d calculateLeftInset(w);\n            x \u003d x + leftMargin;\n            w \u003d w - leftMargin - calculateRightInset(w);\n        }\n        if (vertical \u003d\u003d LengthAdjustmentType.EXPAND) {\n            final double topMargin \u003d calculateTopOutset(h);\n            y \u003d y - topMargin;\n            h \u003d h + topMargin + calculateBottomOutset(h);\n        }\n        else if (vertical \u003d\u003d LengthAdjustmentType.CONTRACT) {\n            final double topMargin \u003d calculateTopInset(h);\n            y \u003d y + topMargin;\n            h \u003d h - topMargin - calculateBottomInset(h);\n        }\n        return new Rectangle2D.Double(x, y, w, h);\n    }\n    \n    /**\n     * Creates an \u0027inset\u0027 rectangle.\n     * \n     * @param base  the base rectangle ({@code null} not permitted).\n     * \n     * @return The inset rectangle.\n     */\n    public Rectangle2D createInsetRectangle(Rectangle2D base) {\n        return createInsetRectangle(base, true, true);\n    }\n    \n    /**\n     * Creates an \u0027inset\u0027 rectangle.\n     * \n     * @param base  the base rectangle ({@code null} not permitted).\n     * @param horizontal  apply horizontal insets?\n     * @param vertical  apply vertical insets?\n     * \n     * @return The inset rectangle.\n     */\n    public Rectangle2D createInsetRectangle(Rectangle2D base,\n            boolean horizontal, boolean vertical) {\n        Args.nullNotPermitted(base, \"base\");\n        double topMargin \u003d 0.0;\n        double bottomMargin \u003d 0.0;\n        if (vertical) {\n            topMargin \u003d calculateTopInset(base.getHeight());\n            bottomMargin \u003d calculateBottomInset(base.getHeight());\n        }\n        double leftMargin \u003d 0.0;\n        double rightMargin \u003d 0.0;\n        if (horizontal) {\n            leftMargin \u003d calculateLeftInset(base.getWidth());\n            rightMargin \u003d calculateRightInset(base.getWidth());\n        }\n        return new Rectangle2D.Double(base.getX() + leftMargin, \n                base.getY() + topMargin,\n                base.getWidth() - leftMargin - rightMargin,\n                base.getHeight() - topMargin - bottomMargin);\n    }\n    \n    /**\n     * Creates an outset rectangle.\n     * \n     * @param base  the base rectangle ({@code null} not permitted).\n     * \n     * @return An outset rectangle.\n     */\n    public Rectangle2D createOutsetRectangle(Rectangle2D base) {\n        return createOutsetRectangle(base, true, true);\n    }\n    \n    /**\n     * Creates an outset rectangle.\n     * \n     * @param base  the base rectangle ({@code null} not permitted).\n     * @param horizontal  apply horizontal insets?\n     * @param vertical  apply vertical insets? \n     * \n     * @return An outset rectangle.\n     */\n    public Rectangle2D createOutsetRectangle(Rectangle2D base,\n            boolean horizontal, boolean vertical) {\n        Args.nullNotPermitted(base, \"base\");\n        double topMargin \u003d 0.0;\n        double bottomMargin \u003d 0.0;\n        if (vertical) {\n            topMargin \u003d calculateTopOutset(base.getHeight());\n            bottomMargin \u003d calculateBottomOutset(base.getHeight());\n        }\n        double leftMargin \u003d 0.0;\n        double rightMargin \u003d 0.0;\n        if (horizontal) {\n            leftMargin \u003d calculateLeftOutset(base.getWidth());\n            rightMargin \u003d calculateRightOutset(base.getWidth());\n        }\n        return new Rectangle2D.Double(base.getX() - leftMargin, \n                base.getY() - topMargin,\n                base.getWidth() + leftMargin + rightMargin,\n                base.getHeight() + topMargin + bottomMargin);\n    }\n    \n    /**\n     * Returns the top margin.\n     * \n     * @param height  the height of the base rectangle.\n     * \n     * @return The top margin (in Java2D units).\n     */\n    public double calculateTopInset(double height) {\n        double result \u003d this.top;\n        if (this.unitType \u003d\u003d UnitType.RELATIVE) {\n            result \u003d (this.top * height);\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the top margin.\n     * \n     * @param height  the height of the base rectangle.\n     * \n     * @return The top margin (in Java2D units).\n     */\n    public double calculateTopOutset(double height) {\n        double result \u003d this.top;\n        if (this.unitType \u003d\u003d UnitType.RELATIVE) {\n            result \u003d (height / (1 - this.top - this.bottom)) * this.top;\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the bottom margin.\n     * \n     * @param height  the height of the base rectangle.\n     * \n     * @return The bottom margin (in Java2D units).\n     */\n    public double calculateBottomInset(double height) {\n        double result \u003d this.bottom;\n        if (this.unitType \u003d\u003d UnitType.RELATIVE) {\n            result \u003d (this.bottom * height);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the bottom margin.\n     * \n     * @param height  the height of the base rectangle.\n     * \n     * @return The bottom margin (in Java2D units).\n     */\n    public double calculateBottomOutset(double height) {\n        double result \u003d this.bottom;\n        if (this.unitType \u003d\u003d UnitType.RELATIVE) {\n            result \u003d (height / (1 - this.top - this.bottom)) * this.bottom;\n        }\n        return result;\n    }\n\n    /**\n     * Returns the left margin.\n     * \n     * @param width  the width of the base rectangle.\n     * \n     * @return The left margin (in Java2D units).\n     */\n    public double calculateLeftInset(double width) {\n        double result \u003d this.left;\n        if (this.unitType \u003d\u003d UnitType.RELATIVE) {\n            result \u003d (this.left * width);\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the left margin.\n     * \n     * @param width  the width of the base rectangle.\n     * \n     * @return The left margin (in Java2D units).\n     */\n    public double calculateLeftOutset(double width) {\n        double result \u003d this.left;\n        if (this.unitType \u003d\u003d UnitType.RELATIVE) {\n            result \u003d (width / (1 - this.left - this.right)) * this.left;\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the right margin.\n     * \n     * @param width  the width of the base rectangle.\n     * \n     * @return The right margin (in Java2D units).\n     */\n    public double calculateRightInset(double width) {\n        double result \u003d this.right;\n        if (this.unitType \u003d\u003d UnitType.RELATIVE) {\n            result \u003d (this.right * width);\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the right margin.\n     * \n     * @param width  the width of the base rectangle.\n     * \n     * @return The right margin (in Java2D units).\n     */\n    public double calculateRightOutset(double width) {\n        double result \u003d this.right;\n        if (this.unitType \u003d\u003d UnitType.RELATIVE) {\n            result \u003d (width / (1 - this.left - this.right)) * this.right;\n        }\n        return result;\n    }\n    \n    /**\n     * Trims the given width to allow for the insets.\n     * \n     * @param width  the width.\n     * \n     * @return The trimmed width.\n     */\n    public double trimWidth(double width) {\n        return width - calculateLeftInset(width) - calculateRightInset(width);   \n    }\n    \n    /**\n     * Extends the given width to allow for the insets.\n     * \n     * @param width  the width.\n     * \n     * @return The extended width.\n     */\n    public double extendWidth(double width) {\n        return width + calculateLeftOutset(width) + calculateRightOutset(width);   \n    }\n\n    /**\n     * Trims the given height to allow for the insets.\n     * \n     * @param height  the height.\n     * \n     * @return The trimmed height.\n     */\n    public double trimHeight(double height) {\n        return height - calculateTopInset(height) \n                - calculateBottomInset(height);   \n    }\n    \n    /**\n     * Extends the given height to allow for the insets.\n     * \n     * @param height  the height.\n     * \n     * @return The extended height.\n     */\n    public double extendHeight(double height) {\n        return height + calculateTopOutset(height) \n                + calculateBottomOutset(height);   \n    }\n\n    /**\n     * Shrinks the given rectangle by the amount of these insets.\n     * \n     * @param area  the area ({@code null} not permitted).\n     */\n    public void trim(Rectangle2D area) {\n        double w \u003d area.getWidth();\n        double h \u003d area.getHeight();\n        double l \u003d calculateLeftInset(w);\n        double r \u003d calculateRightInset(w);\n        double t \u003d calculateTopInset(h);\n        double b \u003d calculateBottomInset(h);\n        area.setRect(area.getX() + l, area.getY() + t, w - l - r, h - t - b);    \n    }\n    \n}","methodCount":29,"staticMethodCount":0,"instanceMethodCount":29,"classLoc":489,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"148a1d7e-be2a-470c-910e-26c67cce74de","hostFunctionTelemetryData":{"hostFunctionSize":1598,"lineStart":85,"lineEnd":1682,"bodyLineStart":85,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/axis/Axis.java","sourceCode":"/**\n * The base class for all axes in JFreeChart.  Subclasses are divided into\n * those that display values ({@link ValueAxis}) and those that display\n * categories ({@link CategoryAxis}).\n */\npublic abstract class Axis implements ChartElement, Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d 7719289504573298271L;\n\n    /** The default axis visibility ({@code true}). */\n    public static final boolean DEFAULT_AXIS_VISIBLE \u003d true;\n\n    /** The default axis label font ({@code Font(\"SansSerif\", Font.PLAIN, 12)}). */\n    public static final Font DEFAULT_AXIS_LABEL_FONT \u003d new Font(\n            \"SansSerif\", Font.PLAIN, 12);\n\n    /** The default axis label paint ({@code Color.BLACK}). */\n    public static final Paint DEFAULT_AXIS_LABEL_PAINT \u003d Color.BLACK;\n\n    /** The default axis label insets ({@code RectangleInsets(3.0, 3.0, 3.0, 3.0)}). */\n    public static final RectangleInsets DEFAULT_AXIS_LABEL_INSETS\n            \u003d new RectangleInsets(3.0, 3.0, 3.0, 3.0);\n\n    /** The default axis line paint ({@code Color.GRAY}). */\n    public static final Paint DEFAULT_AXIS_LINE_PAINT \u003d Color.GRAY;\n\n    /** The default axis line stroke ({@code BasicStroke(0.5f)}). */\n    public static final Stroke DEFAULT_AXIS_LINE_STROKE \u003d new BasicStroke(0.5f);\n\n    /** The default tick labels visibility ({@code true}). */\n    public static final boolean DEFAULT_TICK_LABELS_VISIBLE \u003d true;\n\n    /** The default tick label font ({@code Font(\"SansSerif\", Font.PLAIN, 10)}). */\n    public static final Font DEFAULT_TICK_LABEL_FONT \u003d new Font(\"SansSerif\",\n            Font.PLAIN, 10);\n\n    /** The default tick label paint ({@code Color.BLACK}). */\n    public static final Paint DEFAULT_TICK_LABEL_PAINT \u003d Color.BLACK;\n\n    /** The default tick label insets ({@code RectangleInsets(2.0, 4.0, 2.0, 4.0)}). */\n    public static final RectangleInsets DEFAULT_TICK_LABEL_INSETS\n            \u003d new RectangleInsets(2.0, 4.0, 2.0, 4.0);\n\n    /** The default tick marks visible ({@code true}). */\n    public static final boolean DEFAULT_TICK_MARKS_VISIBLE \u003d true;\n\n    /** The default tick stroke ({@code BasicStroke(0.5f)}). */\n    public static final Stroke DEFAULT_TICK_MARK_STROKE \u003d new BasicStroke(0.5f);\n\n    /** The default tick paint ({@code Color.GRAY}). */\n    public static final Paint DEFAULT_TICK_MARK_PAINT \u003d Color.GRAY;\n\n    /** The default tick mark inside length ({@code 0.0f}). */\n    public static final float DEFAULT_TICK_MARK_INSIDE_LENGTH \u003d 0.0f;\n\n    /** The default tick mark outside length ({@code 2.0f}). */\n    public static final float DEFAULT_TICK_MARK_OUTSIDE_LENGTH \u003d 2.0f;\n\n    /** A flag indicating whether or not the axis is visible. */\n    private boolean visible;\n\n    /** The label for the axis. */\n    private String label;\n    \n    /** \n     * An attributed label for the axis (overrides label if non-null).\n     * We have to use this override method to preserve the API compatibility.\n     */\n    private transient AttributedString attributedLabel;\n\n    /** The font for displaying the axis label. */\n    private Font labelFont;\n\n    /** The paint for drawing the axis label. */\n    private transient Paint labelPaint;\n\n    /** The insets for the axis label. */\n    private RectangleInsets labelInsets;\n\n    /** The label angle. */\n    private double labelAngle;\n    \n    /** The axis label location (new in 1.0.16). */\n    private AxisLabelLocation labelLocation;\n\n    /** A flag that controls whether or not the axis line is visible. */\n    private boolean axisLineVisible;\n\n    /** The stroke used for the axis line. */\n    private transient Stroke axisLineStroke;\n\n    /** The paint used for the axis line. */\n    private transient Paint axisLinePaint;\n\n    /**\n     * A flag that indicates whether or not tick labels are visible for the\n     * axis.\n     */\n    private boolean tickLabelsVisible;\n\n    /** The font used to display the tick labels. */\n    private Font tickLabelFont;\n\n    /** The color used to display the tick labels. */\n    private transient Paint tickLabelPaint;\n\n    /** The blank space around each tick label. */\n    private RectangleInsets tickLabelInsets;\n\n    /**\n     * A flag that indicates whether or not major tick marks are visible for\n     * the axis.\n     */\n    private boolean tickMarksVisible;\n\n    /**\n     * The length of the major tick mark inside the data area (zero\n     * permitted).\n     */\n    private float tickMarkInsideLength;\n\n    /**\n     * The length of the major tick mark outside the data area (zero\n     * permitted).\n     */\n    private float tickMarkOutsideLength;\n\n    /**\n     * A flag that indicates whether or not minor tick marks are visible for the\n     * axis.\n     */\n    private boolean minorTickMarksVisible;\n\n    /**\n     * The length of the minor tick mark inside the data area (zero permitted).\n     */\n    private float minorTickMarkInsideLength;\n\n    /**\n     * The length of the minor tick mark outside the data area (zero permitted).\n     */\n    private float minorTickMarkOutsideLength;\n\n    /** The stroke used to draw tick marks. */\n    private transient Stroke tickMarkStroke;\n\n    /** The paint used to draw tick marks. */\n    private transient Paint tickMarkPaint;\n\n    /** The fixed (horizontal or vertical) dimension for the axis. */\n    private double fixedDimension;\n\n    /**\n     * A reference back to the plot that the axis is assigned to (can be\n     * {@code null}).\n     */\n    private transient Plot plot;\n\n    /** Storage for registered listeners. */\n    private transient EventListenerList listenerList;\n\n    /**\n     * Constructs an axis with the specific label and default values for other\n     * attributes.  \n     *\n     * @param label  the axis label ({@code null} permitted).\n     */\n    protected Axis(String label) {\n\n        this.label \u003d label;\n        this.visible \u003d DEFAULT_AXIS_VISIBLE;\n        this.labelFont \u003d DEFAULT_AXIS_LABEL_FONT;\n        this.labelPaint \u003d DEFAULT_AXIS_LABEL_PAINT;\n        this.labelInsets \u003d DEFAULT_AXIS_LABEL_INSETS;\n        this.labelAngle \u003d 0.0;\n        this.labelLocation \u003d AxisLabelLocation.MIDDLE;\n\n        this.axisLineVisible \u003d true;\n        this.axisLinePaint \u003d DEFAULT_AXIS_LINE_PAINT;\n        this.axisLineStroke \u003d DEFAULT_AXIS_LINE_STROKE;\n\n        this.tickLabelsVisible \u003d DEFAULT_TICK_LABELS_VISIBLE;\n        this.tickLabelFont \u003d DEFAULT_TICK_LABEL_FONT;\n        this.tickLabelPaint \u003d DEFAULT_TICK_LABEL_PAINT;\n        this.tickLabelInsets \u003d DEFAULT_TICK_LABEL_INSETS;\n\n        this.tickMarksVisible \u003d DEFAULT_TICK_MARKS_VISIBLE;\n        this.tickMarkStroke \u003d DEFAULT_TICK_MARK_STROKE;\n        this.tickMarkPaint \u003d DEFAULT_TICK_MARK_PAINT;\n        this.tickMarkInsideLength \u003d DEFAULT_TICK_MARK_INSIDE_LENGTH;\n        this.tickMarkOutsideLength \u003d DEFAULT_TICK_MARK_OUTSIDE_LENGTH;\n\n        this.minorTickMarksVisible \u003d false;\n        this.minorTickMarkInsideLength \u003d 0.0f;\n        this.minorTickMarkOutsideLength \u003d 2.0f;\n\n        this.plot \u003d null;\n\n        this.listenerList \u003d new EventListenerList();\n    }\n\n    /**\n     * Returns {@code true} if the axis is visible, and\n     * {@code false} otherwise.\n     *\n     * @return A boolean.\n     *\n     * @see #setVisible(boolean)\n     */\n    public boolean isVisible() {\n        return this.visible;\n    }\n\n    /**\n     * Sets a flag that controls whether or not the axis is visible and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     *\n     * @see #isVisible()\n     */\n    public void setVisible(boolean flag) {\n        if (flag !\u003d this.visible) {\n            this.visible \u003d flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the label for the axis.\n     *\n     * @return The label for the axis ({@code null} possible).\n     *\n     * @see #getLabelFont()\n     * @see #getLabelPaint()\n     * @see #setLabel(String)\n     */\n    public String getLabel() {\n        return this.label;\n    }\n\n    /**\n     * Sets the label for the axis and sends an {@link AxisChangeEvent} to all\n     * registered listeners.\n     *\n     * @param label  the new label ({@code null} permitted).\n     *\n     * @see #getLabel()\n     * @see #setLabelFont(Font)\n     * @see #setLabelPaint(Paint)\n     */\n    public void setLabel(String label) {\n        this.label \u003d label;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the attributed label (the returned value is a copy, so \n     * modifying it will not impact the state of the axis).  The default value \n     * is {@code null}.\n     * \n     * @return The attributed label (possibly {@code null}).\n     */\n    public AttributedString getAttributedLabel() {\n        if (this.attributedLabel !\u003d null) {\n            return new AttributedString(this.attributedLabel.getIterator());\n        } else {\n            return null;\n        }\n    }\n    \n    /**\n     * Sets the attributed label for the axis and sends an \n     * {@link AxisChangeEvent} to all registered listeners.  This is a \n     * convenience method that converts the string into an \n     * {@code AttributedString} using the current font attributes.\n     * \n     * @param label  the label ({@code null} permitted).\n     */\n    public void setAttributedLabel(String label) {\n        setAttributedLabel(createAttributedLabel(label));    \n    }\n    \n    /**\n     * Sets the attributed label for the axis and sends an \n     * {@link AxisChangeEvent} to all registered listeners.\n     * \n     * @param label  the label ({@code null} permitted).\n     */\n    public void setAttributedLabel(AttributedString label) {\n        if (label !\u003d null) {\n            this.attributedLabel \u003d new AttributedString(label.getIterator());\n        } else {\n            this.attributedLabel \u003d null;\n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Creates and returns an {@code AttributedString} with the specified\n     * text and the labelFont and labelPaint applied as attributes.\n     * \n     * @param label  the label ({@code null} permitted).\n     * \n     * @return An attributed string or {@code null}.\n     */\n    public AttributedString createAttributedLabel(String label) {\n        if (label \u003d\u003d null) {\n            return null;\n        }\n        AttributedString s \u003d new AttributedString(label);\n        s.addAttributes(this.labelFont.getAttributes(), 0, label.length());\n        return s;\n    }\n    \n    /**\n     * Returns the font for the axis label.\n     *\n     * @return The font (never {@code null}).\n     *\n     * @see #setLabelFont(Font)\n     */\n    public Font getLabelFont() {\n        return this.labelFont;\n    }\n\n    /**\n     * Sets the font for the axis label and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param font  the font ({@code null} not permitted).\n     *\n     * @see #getLabelFont()\n     */\n    public void setLabelFont(Font font) {\n        Args.nullNotPermitted(font, \"font\");\n        if (!this.labelFont.equals(font)) {\n            this.labelFont \u003d font;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the color/shade used to draw the axis label.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setLabelPaint(Paint)\n     */\n    public Paint getLabelPaint() {\n        return this.labelPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the axis label and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getLabelPaint()\n     */\n    public void setLabelPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.labelPaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the insets for the label (that is, the amount of blank space\n     * that should be left around the label).\n     *\n     * @return The label insets (never {@code null}).\n     *\n     * @see #setLabelInsets(RectangleInsets)\n     */\n    public RectangleInsets getLabelInsets() {\n        return this.labelInsets;\n    }\n\n    /**\n     * Sets the insets for the axis label, and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param insets  the insets ({@code null} not permitted).\n     *\n     * @see #getLabelInsets()\n     */\n    public void setLabelInsets(RectangleInsets insets) {\n        setLabelInsets(insets, true);\n    }\n\n    /**\n     * Sets the insets for the axis label, and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param insets  the insets ({@code null} not permitted).\n     * @param notify  notify listeners?\n     */\n    public void setLabelInsets(RectangleInsets insets, boolean notify) {\n        Args.nullNotPermitted(insets, \"insets\");\n        if (!insets.equals(this.labelInsets)) {\n            this.labelInsets \u003d insets;\n            if (notify) {\n                fireChangeEvent();\n            }\n        }\n    }\n\n    /**\n     * Returns the angle of the axis label.\n     *\n     * @return The angle (in radians).\n     *\n     * @see #setLabelAngle(double)\n     */\n    public double getLabelAngle() {\n        return this.labelAngle;\n    }\n\n    /**\n     * Sets the angle for the label and sends an {@link AxisChangeEvent} to all\n     * registered listeners.\n     *\n     * @param angle  the angle (in radians).\n     *\n     * @see #getLabelAngle()\n     */\n    public void setLabelAngle(double angle) {\n        this.labelAngle \u003d angle;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the location of the axis label.  The default is\n     * {@link AxisLabelLocation#MIDDLE}.\n     * \n     * @return The location of the axis label (never {@code null}). \n     */\n    public AxisLabelLocation getLabelLocation() {\n        return this.labelLocation;\n    }\n    \n    /**\n     * Sets the axis label location and sends an {@link AxisChangeEvent} to\n     * all registered listeners.\n     * \n     * @param location  the new location ({@code null} not permitted).\n     */\n    public void setLabelLocation(AxisLabelLocation location) {\n        Args.nullNotPermitted(location, \"location\");\n        this.labelLocation \u003d location;\n        fireChangeEvent();\n    }\n\n    /**\n     * A flag that controls whether or not the axis line is drawn.\n     *\n     * @return A boolean.\n     *\n     * @see #getAxisLinePaint()\n     * @see #getAxisLineStroke()\n     * @see #setAxisLineVisible(boolean)\n     */\n    public boolean isAxisLineVisible() {\n        return this.axisLineVisible;\n    }\n\n    /**\n     * Sets a flag that controls whether or not the axis line is visible and\n     * sends an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param visible  the flag.\n     *\n     * @see #isAxisLineVisible()\n     * @see #setAxisLinePaint(Paint)\n     * @see #setAxisLineStroke(Stroke)\n     */\n    public void setAxisLineVisible(boolean visible) {\n        this.axisLineVisible \u003d visible;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw the axis line.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setAxisLinePaint(Paint)\n     */\n    public Paint getAxisLinePaint() {\n        return this.axisLinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the axis line and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getAxisLinePaint()\n     */\n    public void setAxisLinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.axisLinePaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used to draw the axis line.\n     *\n     * @return The stroke (never {@code null}).\n     *\n     * @see #setAxisLineStroke(Stroke)\n     */\n    public Stroke getAxisLineStroke() {\n        return this.axisLineStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the axis line and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getAxisLineStroke()\n     */\n    public void setAxisLineStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.axisLineStroke \u003d stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag indicating whether or not the tick labels are visible.\n     *\n     * @return The flag.\n     *\n     * @see #getTickLabelFont()\n     * @see #getTickLabelPaint()\n     * @see #setTickLabelsVisible(boolean)\n     */\n    public boolean isTickLabelsVisible() {\n        return this.tickLabelsVisible;\n    }\n\n    /**\n     * Sets the flag that determines whether or not the tick labels are\n     * visible and sends an {@link AxisChangeEvent} to all registered\n     * listeners.\n     *\n     * @param flag  the flag.\n     *\n     * @see #isTickLabelsVisible()\n     * @see #setTickLabelFont(Font)\n     * @see #setTickLabelPaint(Paint)\n     */\n    public void setTickLabelsVisible(boolean flag) {\n\n        if (flag !\u003d this.tickLabelsVisible) {\n            this.tickLabelsVisible \u003d flag;\n            fireChangeEvent();\n        }\n\n    }\n\n    /**\n     * Returns the flag that indicates whether or not the minor tick marks are\n     * showing.\n     *\n     * @return The flag that indicates whether or not the minor tick marks are\n     *         showing.\n     *\n     * @see #setMinorTickMarksVisible(boolean)\n     */\n    public boolean isMinorTickMarksVisible() {\n        return this.minorTickMarksVisible;\n    }\n\n    /**\n     * Sets the flag that indicates whether or not the minor tick marks are \n     * showing and sends an {@link AxisChangeEvent} to all registered\n     * listeners.\n     *\n     * @param flag  the flag.\n     *\n     * @see #isMinorTickMarksVisible()\n     */\n    public void setMinorTickMarksVisible(boolean flag) {\n        if (flag !\u003d this.minorTickMarksVisible) {\n            this.minorTickMarksVisible \u003d flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the font used for the tick labels (if showing).\n     *\n     * @return The font (never {@code null}).\n     *\n     * @see #setTickLabelFont(Font)\n     */\n    public Font getTickLabelFont() {\n        return this.tickLabelFont;\n    }\n\n    /**\n     * Sets the font for the tick labels and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param font  the font ({@code null} not allowed).\n     *\n     * @see #getTickLabelFont()\n     */\n    public void setTickLabelFont(Font font) {\n        Args.nullNotPermitted(font, \"font\");\n        if (!this.tickLabelFont.equals(font)) {\n            this.tickLabelFont \u003d font;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the color/shade used for the tick labels.\n     *\n     * @return The paint used for the tick labels.\n     *\n     * @see #setTickLabelPaint(Paint)\n     */\n    public Paint getTickLabelPaint() {\n        return this.tickLabelPaint;\n    }\n\n    /**\n     * Sets the paint used to draw tick labels (if they are showing) and\n     * sends an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getTickLabelPaint()\n     */\n    public void setTickLabelPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.tickLabelPaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the insets for the tick labels.\n     *\n     * @return The insets (never {@code null}).\n     *\n     * @see #setTickLabelInsets(RectangleInsets)\n     */\n    public RectangleInsets getTickLabelInsets() {\n        return this.tickLabelInsets;\n    }\n\n    /**\n     * Sets the insets for the tick labels and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param insets  the insets ({@code null} not permitted).\n     *\n     * @see #getTickLabelInsets()\n     */\n    public void setTickLabelInsets(RectangleInsets insets) {\n        Args.nullNotPermitted(insets, \"insets\");\n        if (!this.tickLabelInsets.equals(insets)) {\n            this.tickLabelInsets \u003d insets;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the flag that indicates whether or not the tick marks are\n     * showing.\n     *\n     * @return The flag that indicates whether or not the tick marks are\n     *         showing.\n     *\n     * @see #setTickMarksVisible(boolean)\n     */\n    public boolean isTickMarksVisible() {\n        return this.tickMarksVisible;\n    }\n\n    /**\n     * Sets the flag that indicates whether or not the tick marks are showing\n     * and sends an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     *\n     * @see #isTickMarksVisible()\n     */\n    public void setTickMarksVisible(boolean flag) {\n        if (flag !\u003d this.tickMarksVisible) {\n            this.tickMarksVisible \u003d flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the inside length of the tick marks.\n     *\n     * @return The length.\n     *\n     * @see #getTickMarkOutsideLength()\n     * @see #setTickMarkInsideLength(float)\n     */\n    public float getTickMarkInsideLength() {\n        return this.tickMarkInsideLength;\n    }\n\n    /**\n     * Sets the inside length of the tick marks and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param length  the new length.\n     *\n     * @see #getTickMarkInsideLength()\n     */\n    public void setTickMarkInsideLength(float length) {\n        this.tickMarkInsideLength \u003d length;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the outside length of the tick marks.\n     *\n     * @return The length.\n     *\n     * @see #getTickMarkInsideLength()\n     * @see #setTickMarkOutsideLength(float)\n     */\n    public float getTickMarkOutsideLength() {\n        return this.tickMarkOutsideLength;\n    }\n\n    /**\n     * Sets the outside length of the tick marks and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param length  the new length.\n     *\n     * @see #getTickMarkInsideLength()\n     */\n    public void setTickMarkOutsideLength(float length) {\n        this.tickMarkOutsideLength \u003d length;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used to draw tick marks.\n     *\n     * @return The stroke (never {@code null}).\n     *\n     * @see #setTickMarkStroke(Stroke)\n     */\n    public Stroke getTickMarkStroke() {\n        return this.tickMarkStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw tick marks and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getTickMarkStroke()\n     */\n    public void setTickMarkStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        if (!this.tickMarkStroke.equals(stroke)) {\n            this.tickMarkStroke \u003d stroke;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the paint used to draw tick marks (if they are showing).\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setTickMarkPaint(Paint)\n     */\n    public Paint getTickMarkPaint() {\n        return this.tickMarkPaint;\n    }\n\n    /**\n     * Sets the paint used to draw tick marks and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getTickMarkPaint()\n     */\n    public void setTickMarkPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.tickMarkPaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the inside length of the minor tick marks.\n     *\n     * @return The length.\n     *\n     * @see #getMinorTickMarkOutsideLength()\n     * @see #setMinorTickMarkInsideLength(float)\n     */\n    public float getMinorTickMarkInsideLength() {\n        return this.minorTickMarkInsideLength;\n    }\n\n    /**\n     * Sets the inside length of the minor tick marks and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param length  the new length.\n     *\n     * @see #getMinorTickMarkInsideLength()\n     */\n    public void setMinorTickMarkInsideLength(float length) {\n        this.minorTickMarkInsideLength \u003d length;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the outside length of the minor tick marks.\n     *\n     * @return The length.\n     *\n     * @see #getMinorTickMarkInsideLength()\n     * @see #setMinorTickMarkOutsideLength(float)\n     */\n    public float getMinorTickMarkOutsideLength() {\n        return this.minorTickMarkOutsideLength;\n    }\n\n    /**\n     * Sets the outside length of the minor tick marks and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param length  the new length.\n     *\n     * @see #getMinorTickMarkInsideLength()\n     */\n    public void setMinorTickMarkOutsideLength(float length) {\n        this.minorTickMarkOutsideLength \u003d length;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the plot that the axis is assigned to.  This method will return\n     * {@code null} if the axis is not currently assigned to a plot.\n     *\n     * @return The plot that the axis is assigned to (possibly {@code null}).\n     *\n     * @see #setPlot(Plot)\n     */\n    public Plot getPlot() {\n        return this.plot;\n    }\n\n    /**\n     * Sets a reference to the plot that the axis is assigned to.\n     * \u003cP\u003e\n     * This method is used internally, you shouldn\u0027t need to call it yourself.\n     *\n     * @param plot  the plot.\n     *\n     * @see #getPlot()\n     */\n    public void setPlot(Plot plot) {\n        this.plot \u003d plot;\n        configure();\n    }\n\n    /**\n     * Returns the fixed dimension for the axis.\n     *\n     * @return The fixed dimension.\n     *\n     * @see #setFixedDimension(double)\n     */\n    public double getFixedDimension() {\n        return this.fixedDimension;\n    }\n\n    /**\n     * Sets the fixed dimension for the axis.\n     * \u003cP\u003e\n     * This is used when combining more than one plot on a chart.  In this case,\n     * there may be several axes that need to have the same height or width so\n     * that they are aligned.  This method is used to fix a dimension for the\n     * axis (the context determines whether the dimension is horizontal or\n     * vertical).\n     *\n     * @param dimension  the fixed dimension.\n     *\n     * @see #getFixedDimension()\n     */\n    public void setFixedDimension(double dimension) {\n        this.fixedDimension \u003d dimension;\n    }\n\n    /**\n     * Configures the axis to work with the current plot.  Override this method\n     * to perform any special processing (such as auto-rescaling).\n     */\n    public abstract void configure();\n\n    /**\n     * Estimates the space (height or width) required to draw the axis.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot that the axis belongs to.\n     * @param plotArea  the area within which the plot (including axes) should\n     *                  be drawn.\n     * @param edge  the axis location.\n     * @param space  space already reserved.\n     *\n     * @return The space required to draw the axis (including pre-reserved\n     *         space).\n     */\n    public abstract AxisSpace reserveSpace(Graphics2D g2, Plot plot,\n            Rectangle2D plotArea, RectangleEdge edge, AxisSpace space);\n\n    /**\n     * Receives a chart element visitor.  Many plot subclasses will override\n     * this method to handle their subcomponents.\n     * \n     * @param visitor  the visitor ({@code null} not permitted).\n     */\n    @Override\n    public void receive(ChartElementVisitor visitor) {\n        visitor.visit(this);\n    }\n\n    /**\n     * Draws the axis on a Java 2D graphics device (such as the screen or a\n     * printer).\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param cursor  the cursor location (determines where to draw the axis).\n     * @param plotArea  the area within which the axes and plot should be drawn.\n     * @param dataArea  the area within which the data should be drawn.\n     * @param edge  the axis location ({@code null} not permitted).\n     * @param plotState  collects information about the plot\n     *                   ({@code null} permitted).\n     *\n     * @return The axis state (never {@code null}).\n     */\n    public abstract AxisState draw(Graphics2D g2, double cursor,\n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge,\n            PlotRenderingInfo plotState);\n\n    /**\n     * Calculates the positions of the ticks for the axis, storing the results\n     * in the tick list (ready for drawing).\n     *\n     * @param g2  the graphics device.\n     * @param state  the axis state.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the edge on which the axis is located.\n     *\n     * @return The list of ticks.\n     */\n    public abstract List refreshTicks(Graphics2D g2, AxisState state,\n            Rectangle2D dataArea, RectangleEdge edge);\n\n    /**\n     * Creates an entity for the axis and adds it to the rendering info.\n     * If {@code plotState} is {@code null}, this means that rendering info\n     * is not being collected so this method simply returns without doing \n     * anything.\n     *\n     * @param cursor  the initial cursor value.\n     * @param state  the axis state after completion of the drawing with a\n     *     possibly updated cursor position.\n     * @param dataArea  the data area.\n     * @param edge  the edge ({@code null} not permitted).\n     * @param plotState  the PlotRenderingInfo from which a reference to the\n     *     entity collection can be obtained ({@code null} permitted).\n     */\n    protected void createAndAddEntity(double cursor, AxisState state,\n            Rectangle2D dataArea, RectangleEdge edge,\n            PlotRenderingInfo plotState) {\n\n        Args.nullNotPermitted(edge, \"edge\");\n        if (plotState \u003d\u003d null || plotState.getOwner() \u003d\u003d null) {\n            return;  // no need to create entity if we can\u0027t save it anyways...\n        }\n        Rectangle2D hotspot \u003d null;\n        switch (edge) {\n            case TOP:\n                hotspot \u003d new Rectangle2D.Double(dataArea.getX(),\n                        state.getCursor(), dataArea.getWidth(),\n                        cursor - state.getCursor());\n                break;\n            case BOTTOM:\n                hotspot \u003d new Rectangle2D.Double(dataArea.getX(), cursor,\n                        dataArea.getWidth(), state.getCursor() - cursor);\n                break;\n            case LEFT:\n                hotspot \u003d new Rectangle2D.Double(state.getCursor(),\n                        dataArea.getY(), cursor - state.getCursor(),\n                        dataArea.getHeight());\n                break;\n            case RIGHT:\n                hotspot \u003d new Rectangle2D.Double(cursor, dataArea.getY(),\n                        state.getCursor() - cursor, dataArea.getHeight());\n                break;\n            default:\n                break;\n        }\n        EntityCollection e \u003d plotState.getOwner().getEntityCollection();\n        if (e !\u003d null) {\n            e.add(new AxisEntity(hotspot, this));\n        }\n    }\n\n    /**\n     * Registers an object for notification of changes to the axis.\n     *\n     * @param listener  the object that is being registered.\n     *\n     * @see #removeChangeListener(AxisChangeListener)\n     */\n    public void addChangeListener(AxisChangeListener listener) {\n        this.listenerList.add(AxisChangeListener.class, listener);\n    }\n\n    /**\n     * Deregisters an object for notification of changes to the axis.\n     *\n     * @param listener  the object to deregister.\n     *\n     * @see #addChangeListener(AxisChangeListener)\n     */\n    public void removeChangeListener(AxisChangeListener listener) {\n        this.listenerList.remove(AxisChangeListener.class, listener);\n    }\n\n    /**\n     * Returns {@code true} if the specified object is registered with\n     * the dataset as a listener.  Most applications won\u0027t need to call this\n     * method, it exists mainly for use by unit testing code.\n     *\n     * @param listener  the listener.\n     *\n     * @return A boolean.\n     */\n    public boolean hasListener(EventListener listener) {\n        List list \u003d Arrays.asList(this.listenerList.getListenerList());\n        return list.contains(listener);\n    }\n\n    /**\n     * Notifies all registered listeners that the axis has changed.\n     * The AxisChangeEvent provides information about the change.\n     *\n     * @param event  information about the change to the axis.\n     */\n    protected void notifyListeners(AxisChangeEvent event) {\n        Object[] listeners \u003d this.listenerList.getListenerList();\n        for (int i \u003d listeners.length - 2; i \u003e\u003d 0; i -\u003d 2) {\n            if (listeners[i] \u003d\u003d AxisChangeListener.class) {\n                ((AxisChangeListener) listeners[i + 1]).axisChanged(event);\n            }\n        }\n    }\n\n    /**\n     * Sends an {@link AxisChangeEvent} to all registered listeners.\n     */\n    protected void fireChangeEvent() {\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * Returns a rectangle that encloses the axis label.  This is typically\n     * used for layout purposes (it gives the maximum dimensions of the label).\n     *\n     * @param g2  the graphics device.\n     * @param edge  the edge of the plot area along which the axis is measuring.\n     *\n     * @return The enclosing rectangle.\n     */\n    protected Rectangle2D getLabelEnclosure(Graphics2D g2, RectangleEdge edge) {\n        Rectangle2D result \u003d new Rectangle2D.Double();\n        Rectangle2D bounds \u003d null;\n        if (this.attributedLabel !\u003d null) {\n            TextLayout layout \u003d new TextLayout(\n                    this.attributedLabel.getIterator(), \n                    g2.getFontRenderContext());\n            bounds \u003d layout.getBounds();\n        } else {\n            String axisLabel \u003d getLabel();\n            if (axisLabel !\u003d null \u0026\u0026 !axisLabel.equals(\"\")) {\n                FontMetrics fm \u003d g2.getFontMetrics(getLabelFont());\n                bounds \u003d TextUtils.getTextBounds(axisLabel, g2, fm);\n            }\n        }\n        if (bounds !\u003d null) {\n            RectangleInsets insets \u003d getLabelInsets();\n            bounds \u003d insets.createOutsetRectangle(bounds);\n            double angle \u003d getLabelAngle();\n            if (edge \u003d\u003d RectangleEdge.LEFT || edge \u003d\u003d RectangleEdge.RIGHT) {\n                angle \u003d angle - Math.PI / 2.0;\n            }\n            double x \u003d bounds.getCenterX();\n            double y \u003d bounds.getCenterY();\n            AffineTransform transformer\n                \u003d AffineTransform.getRotateInstance(angle, x, y);\n            Shape labelBounds \u003d transformer.createTransformedShape(bounds);\n            result \u003d labelBounds.getBounds2D();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the x-coordinate for the point to which the axis label should \n     * be aligned.\n     * \n     * @param location  the axis label location ({@code null} not permitted).\n     * @param dataArea  the display area in which the data will be rendered ({@code null} not permitted).\n     * \n     * @return The x-coordinate. \n     */\n    protected double labelLocationX(AxisLabelLocation location, \n            Rectangle2D dataArea) {\n        if (location.equals(AxisLabelLocation.HIGH_END)) {\n            return dataArea.getMaxX();\n        }\n        if (location.equals(AxisLabelLocation.MIDDLE)) {\n            return dataArea.getCenterX();\n        }\n        if (location.equals(AxisLabelLocation.LOW_END)) {\n            return dataArea.getMinX();\n        }\n        throw new RuntimeException(\"Unexpected AxisLabelLocation: \" + location);\n    }\n    \n    /**\n     * Returns the y-coordinate for the point to which the axis label should\n     * be aligned.\n     * \n     * @param location  the location ({@code null} not permitted).\n     * @param dataArea  the data area ({@code null} not permitted).\n     * \n     * @return The y-coordinate. \n     */\n    protected double labelLocationY(AxisLabelLocation location, \n            Rectangle2D dataArea) {\n        if (location.equals(AxisLabelLocation.HIGH_END)) {\n            return dataArea.getMinY();\n        }\n        if (location.equals(AxisLabelLocation.MIDDLE)) {\n            return dataArea.getCenterY();\n        }\n        if (location.equals(AxisLabelLocation.LOW_END)) {\n            return dataArea.getMaxY();\n        }\n        throw new RuntimeException(\"Unexpected AxisLabelLocation: \" + location);\n    }\n    \n    /**\n     * Returns the appropriate horizontal text anchor for the specified axis \n     * location.\n     * \n     * @param location  the location ({@code null} not permitted).\n     * \n     * @return The text anchor (never {@code null}). \n     */\n    protected TextAnchor labelAnchorH(AxisLabelLocation location) {\n        if (location.equals(AxisLabelLocation.HIGH_END)) {\n            return TextAnchor.CENTER_RIGHT;\n        }\n        if (location.equals(AxisLabelLocation.MIDDLE)) {\n            return TextAnchor.CENTER;\n        }\n        if (location.equals(AxisLabelLocation.LOW_END)) {\n            return TextAnchor.CENTER_LEFT;\n        }\n        throw new RuntimeException(\"Unexpected AxisLabelLocation: \" + location);\n    }\n    \n    /**\n     * Returns the appropriate vertical text anchor for the specified axis \n     * location.\n     * \n     * @param location  the location ({@code null} not permitted).\n     * \n     * @return The text anchor (never {@code null}). \n     */\n    protected TextAnchor labelAnchorV(AxisLabelLocation location) {\n        if (location.equals(AxisLabelLocation.HIGH_END)) {\n            return TextAnchor.CENTER_RIGHT;\n        }\n        if (location.equals(AxisLabelLocation.MIDDLE)) {\n            return TextAnchor.CENTER;\n        }\n        if (location.equals(AxisLabelLocation.LOW_END)) {\n            return TextAnchor.CENTER_LEFT;\n        }\n        throw new RuntimeException(\"Unexpected AxisLabelLocation: \" + location);\n    }\n\n    /**\n     * Draws the axis label.\n     *\n     * @param label  the label text.\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the location of the axis.\n     * @param state  the axis state ({@code null} not permitted).\n     *\n     * @return Information about the axis.\n     */\n    protected AxisState drawLabel(String label, Graphics2D g2,\n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge,\n            AxisState state) {\n\n        // it is unlikely that \u0027state\u0027 will be null, but check anyway...\n        Args.nullNotPermitted(state, \"state\");\n\n        if ((label \u003d\u003d null) || (label.equals(\"\"))) {\n            return state;\n        }\n\n        Font font \u003d getLabelFont();\n        RectangleInsets insets \u003d getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm \u003d g2.getFontMetrics();\n        Rectangle2D labelBounds \u003d TextUtils.getTextBounds(label, g2, fm);\n\n        if (edge \u003d\u003d RectangleEdge.TOP) {\n            AffineTransform t \u003d AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(),\n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds \u003d t.createTransformedShape(labelBounds);\n            labelBounds \u003d rotatedLabelBounds.getBounds2D();\n            double labelx \u003d labelLocationX(this.labelLocation, dataArea);\n            double labely \u003d state.getCursor() - insets.getBottom()\n                            - labelBounds.getHeight() / 2.0;\n            TextAnchor anchor \u003d labelAnchorH(this.labelLocation);\n            TextUtils.drawRotatedString(label, g2, (float) labelx,\n                    (float) labely, anchor, getLabelAngle(), TextAnchor.CENTER);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight()\n                    + insets.getBottom());\n        }\n        else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n            AffineTransform t \u003d AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(),\n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds \u003d t.createTransformedShape(labelBounds);\n            labelBounds \u003d rotatedLabelBounds.getBounds2D();\n            double labelx \u003d labelLocationX(this.labelLocation, dataArea);\n            double labely \u003d state.getCursor()\n                            + insets.getTop() + labelBounds.getHeight() / 2.0;\n            TextAnchor anchor \u003d labelAnchorH(this.labelLocation);\n            TextUtils.drawRotatedString(label, g2, (float) labelx,\n                    (float) labely, anchor, getLabelAngle(), TextAnchor.CENTER);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight()\n                    + insets.getBottom());\n        }\n        else if (edge \u003d\u003d RectangleEdge.LEFT) {\n            AffineTransform t \u003d AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(),\n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds \u003d t.createTransformedShape(labelBounds);\n            labelBounds \u003d rotatedLabelBounds.getBounds2D();\n            double labelx \u003d state.getCursor()\n                            - insets.getRight() - labelBounds.getWidth() / 2.0;\n            double labely \u003d labelLocationY(this.labelLocation, dataArea);\n            TextAnchor anchor \u003d labelAnchorV(this.labelLocation);\n            TextUtils.drawRotatedString(label, g2, (float) labelx,\n                    (float) labely, anchor, getLabelAngle() - Math.PI / 2.0, \n                    anchor);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth()\n                    + insets.getRight());\n        }\n        else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n            AffineTransform t \u003d AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0,\n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds \u003d t.createTransformedShape(labelBounds);\n            labelBounds \u003d rotatedLabelBounds.getBounds2D();\n            double labelx \u003d state.getCursor()\n                            + insets.getLeft() + labelBounds.getWidth() / 2.0;\n            double labely \u003d labelLocationY(this.labelLocation, dataArea);\n            TextAnchor anchor \u003d labelAnchorV(this.labelLocation);\n            TextUtils.drawRotatedString(label, g2, (float) labelx,\n                    (float) labely, anchor, getLabelAngle() + Math.PI / 2.0, \n                    anchor);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth()\n                    + insets.getRight());\n        }\n\n        return state;\n\n    }\n\n    /**\n     * Draws the axis label.\n     *\n     * @param label  the label text.\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the location of the axis.\n     * @param state  the axis state ({@code null} not permitted).\n     *\n     * @return Information about the axis.\n     */\n    protected AxisState drawAttributedLabel(AttributedString label, \n            Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, \n            RectangleEdge edge, AxisState state) {\n\n        // it is unlikely that \u0027state\u0027 will be null, but check anyway...\n        Args.nullNotPermitted(state, \"state\");\n\n        if (label \u003d\u003d null) {\n            return state;\n        }\n\n        RectangleInsets insets \u003d getLabelInsets();\n        g2.setFont(getLabelFont());\n        g2.setPaint(getLabelPaint());\n        TextLayout layout \u003d new TextLayout(this.attributedLabel.getIterator(),\n                g2.getFontRenderContext());\n        Rectangle2D labelBounds \u003d layout.getBounds();\n\n        if (edge \u003d\u003d RectangleEdge.TOP) {\n            AffineTransform t \u003d AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(),\n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds \u003d t.createTransformedShape(labelBounds);\n            labelBounds \u003d rotatedLabelBounds.getBounds2D();\n            double labelx \u003d labelLocationX(this.labelLocation, dataArea);\n            double labely \u003d state.getCursor() - insets.getBottom()\n                            - labelBounds.getHeight() / 2.0;\n            TextAnchor anchor \u003d labelAnchorH(this.labelLocation);\n            AttrStringUtils.drawRotatedString(label, g2, (float) labelx,\n                    (float) labely, anchor, getLabelAngle(), TextAnchor.CENTER);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight()\n                    + insets.getBottom());\n        }\n        else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n            AffineTransform t \u003d AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(),\n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds \u003d t.createTransformedShape(labelBounds);\n            labelBounds \u003d rotatedLabelBounds.getBounds2D();\n            double labelx \u003d labelLocationX(this.labelLocation, dataArea);\n            double labely \u003d state.getCursor()\n                            + insets.getTop() + labelBounds.getHeight() / 2.0;\n            TextAnchor anchor \u003d labelAnchorH(this.labelLocation);\n            AttrStringUtils.drawRotatedString(label, g2, (float) labelx,\n                    (float) labely, anchor, getLabelAngle(), TextAnchor.CENTER);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight()\n                    + insets.getBottom());\n        }\n        else if (edge \u003d\u003d RectangleEdge.LEFT) {\n            AffineTransform t \u003d AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(),\n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds \u003d t.createTransformedShape(labelBounds);\n            labelBounds \u003d rotatedLabelBounds.getBounds2D();\n            double labelx \u003d state.getCursor()\n                            - insets.getRight() - labelBounds.getWidth() / 2.0;\n            double labely \u003d labelLocationY(this.labelLocation, dataArea);\n            TextAnchor anchor \u003d labelAnchorV(this.labelLocation);\n            AttrStringUtils.drawRotatedString(label, g2, (float) labelx,\n                    (float) labely, anchor, getLabelAngle() - Math.PI / 2.0, \n                    anchor);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth()\n                    + insets.getRight());\n        }\n        else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n            AffineTransform t \u003d AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0,\n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds \u003d t.createTransformedShape(labelBounds);\n            labelBounds \u003d rotatedLabelBounds.getBounds2D();\n            double labelx \u003d state.getCursor()\n                            + insets.getLeft() + labelBounds.getWidth() / 2.0;\n            double labely \u003d labelLocationY(this.labelLocation, dataArea);\n            TextAnchor anchor \u003d labelAnchorV(this.labelLocation);\n            AttrStringUtils.drawRotatedString(label, g2, (float) labelx,\n                    (float) labely, anchor, getLabelAngle() + Math.PI / 2.0, \n                    anchor);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth()\n                    + insets.getRight());\n        }\n        return state;\n    }\n\n    /**\n     * Draws an axis line at the current cursor position and edge.\n     *\n     * @param g2  the graphics device.\n     * @param cursor  the cursor position.\n     * @param dataArea  the data area.\n     * @param edge  the edge.\n     */\n    protected void drawAxisLine(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge) {\n        Line2D axisLine \u003d null;\n        double x \u003d dataArea.getX();\n        double y \u003d dataArea.getY();\n        if (edge \u003d\u003d RectangleEdge.TOP) {\n            axisLine \u003d new Line2D.Double(x, cursor, dataArea.getMaxX(), cursor);\n        } else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n            axisLine \u003d new Line2D.Double(x, cursor, dataArea.getMaxX(), cursor);\n        } else if (edge \u003d\u003d RectangleEdge.LEFT) {\n            axisLine \u003d new Line2D.Double(cursor, y, cursor, dataArea.getMaxY());\n        } else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n            axisLine \u003d new Line2D.Double(cursor, y, cursor, dataArea.getMaxY());\n        }\n        g2.setPaint(this.axisLinePaint);\n        g2.setStroke(this.axisLineStroke);\n        Object saved \u003d g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, \n                RenderingHints.VALUE_STROKE_NORMALIZE);\n        g2.draw(axisLine);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, saved);\n    }\n\n    /**\n     * Returns a clone of the axis.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if some component of the axis does\n     *         not support cloning.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        Axis clone \u003d (Axis) super.clone();\n        // It\u0027s up to the plot which clones up to restore the correct references\n        clone.plot \u003d null;\n        clone.listenerList \u003d new EventListenerList();\n        return clone;\n    }\n\n    /**\n     * Tests this axis for equality with another object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return {@code true} or {@code false}.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof Axis)) {\n            return false;\n        }\n        Axis that \u003d (Axis) obj;\n        if (this.visible !\u003d that.visible) {\n            return false;\n        }\n        if (!Objects.equals(this.label, that.label)) {\n            return false;\n        }\n        if (!AttributedStringUtils.equal(this.attributedLabel, \n                that.attributedLabel)) {\n            return false;\n        }\n        if (!Objects.equals(this.labelFont, that.labelFont)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.labelPaint, that.labelPaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.labelInsets, that.labelInsets)) {\n            return false;\n        }\n        if (this.labelAngle !\u003d that.labelAngle) {\n            return false;\n        }\n        if (!this.labelLocation.equals(that.labelLocation)) {\n            return false;\n        }\n        if (this.axisLineVisible !\u003d that.axisLineVisible) {\n            return false;\n        }\n        if (!Objects.equals(this.axisLineStroke, that.axisLineStroke)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.axisLinePaint, that.axisLinePaint)) {\n            return false;\n        }\n        if (this.tickLabelsVisible !\u003d that.tickLabelsVisible) {\n            return false;\n        }\n        if (!Objects.equals(this.tickLabelFont, that.tickLabelFont)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.tickLabelPaint, that.tickLabelPaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.tickLabelInsets, that.tickLabelInsets)) {\n            return false;\n        }\n        if (this.tickMarksVisible !\u003d that.tickMarksVisible) {\n            return false;\n        }\n        if (this.tickMarkInsideLength !\u003d that.tickMarkInsideLength) {\n            return false;\n        }\n        if (this.tickMarkOutsideLength !\u003d that.tickMarkOutsideLength) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.tickMarkPaint, that.tickMarkPaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.tickMarkStroke, that.tickMarkStroke)) {\n            return false;\n        }\n        if (this.minorTickMarksVisible !\u003d that.minorTickMarksVisible) {\n            return false;\n        }\n        if (this.minorTickMarkInsideLength !\u003d that.minorTickMarkInsideLength) {\n            return false;\n        }\n        if (this.minorTickMarkOutsideLength\n                !\u003d that.minorTickMarkOutsideLength) {\n            return false;\n        }\n        if (this.fixedDimension !\u003d that.fixedDimension) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this instance.\n     * \n     * @return A hash code. \n     */\n    @Override\n    public int hashCode() {\n        int hash \u003d 3;\n        if (this.label !\u003d null) {\n            hash \u003d 83 * hash + this.label.hashCode();\n        }\n        return hash;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writeAttributedString(this.attributedLabel, stream);\n        SerialUtils.writePaint(this.labelPaint, stream);\n        SerialUtils.writePaint(this.tickLabelPaint, stream);\n        SerialUtils.writeStroke(this.axisLineStroke, stream);\n        SerialUtils.writePaint(this.axisLinePaint, stream);\n        SerialUtils.writeStroke(this.tickMarkStroke, stream);\n        SerialUtils.writePaint(this.tickMarkPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.attributedLabel \u003d SerialUtils.readAttributedString(stream);\n        this.labelPaint \u003d SerialUtils.readPaint(stream);\n        this.tickLabelPaint \u003d SerialUtils.readPaint(stream);\n        this.axisLineStroke \u003d SerialUtils.readStroke(stream);\n        this.axisLinePaint \u003d SerialUtils.readPaint(stream);\n        this.tickMarkStroke \u003d SerialUtils.readStroke(stream);\n        this.tickMarkPaint \u003d SerialUtils.readPaint(stream);\n        this.listenerList \u003d new EventListenerList();\n    }\n\n}","methodCount":78,"staticMethodCount":0,"instanceMethodCount":78,"classLoc":1598,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":3,"candidates":[{"lineStart":1057,"lineEnd":1106,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method createAndAddEntity to class Plot","description":"Move method createAndAddEntity to org.jfree.chart.plot.Plot\nRationale: The createAndAddEntity method\u0027s primary purpose is to handle the creation and addition of entities to the rendering info based on the axis and plot state. The \u0027Plot\u0027 class has direct access to managing various plot rendering details, including managing entities associated with plots. The creation and addition of entities are more closely related to the responsibilities of the \u0027Plot\u0027 class than \u0027AxisState\u0027 or \u0027PlotRenderingInfo\u0027 since the \u0027Plot\u0027 class directly manages rendering through info provided by \u0027AxisState\u0027 and \u0027PlotRenderingInfo\u0027. This method ensures entities are correctly associated with plot state during render processing.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Helpful"},{"lineStart":1274,"lineEnd":1293,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method labelAnchorV to class Plot","description":"Move method labelAnchorV to org.jfree.chart.plot.Plot\nRationale: The labelAnchorV() method seems to be more related to plot-related actions, specifically in terms of positioning and rendering labels based on their axis location. The Plot class, being responsible for handling drawing and element placement within a chart, is a more suitable candidate. The method doesn\u0027t align well with RectangleInsets, which focuses on geometric manipulations and adjustments of rectangles rather than determining label positions.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false},{"lineStart":1253,"lineEnd":1272,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method labelAnchorH to class Plot","description":"Move method labelAnchorH to org.jfree.chart.plot.Plot\nRationale: The method `labelAnchorH(AxisLabelLocation location)` is more aligned with the responsibilities of the Plot class. The method deals with axis label locations and relevant text anchors, which are concepts tightly connected to plotting and rendering of axes on a chart. The Plot class deals with various elements of chart drawing and rendering, making it a more appropriate place for this method. Moving it here ensures better cohesion as it keeps axis-related behavior centralized and maintains the single responsibility principle.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":184573}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":74543},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"setLabelInsets","method_signature":"public setLabelInsets(RectangleInsets insets, boolean notify)","target_class":"","rationale":""},{"method_name":"createAndAddEntity","method_signature":"protected createAndAddEntity(double cursor, AxisState state,\n            Rectangle2D dataArea, RectangleEdge edge,\n            PlotRenderingInfo plotState)","target_class":"","rationale":""},{"method_name":"labelLocationX","method_signature":"protected labelLocationX(AxisLabelLocation location, \n            Rectangle2D dataArea)","target_class":"","rationale":""},{"method_name":"labelLocationY","method_signature":"protected labelLocationY(AxisLabelLocation location, \n            Rectangle2D dataArea)","target_class":"","rationale":""},{"method_name":"labelAnchorH","method_signature":"protected labelAnchorH(AxisLabelLocation location)","target_class":"","rationale":""},{"method_name":"labelAnchorV","method_signature":"protected labelAnchorV(AxisLabelLocation location)","target_class":"","rationale":""},{"method_name":"drawLabel","method_signature":"protected drawLabel(String label, Graphics2D g2,\n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge,\n            AxisState state)","target_class":"","rationale":""},{"method_name":"drawAttributedLabel","method_signature":"protected drawAttributedLabel(AttributedString label, \n            Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, \n            RectangleEdge edge, AxisState state)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"drawLabel","method_signature":"protected drawLabel(String label, Graphics2D g2,\n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge,\n            AxisState state)","target_class":"","rationale":""},{"method_name":"drawAttributedLabel","method_signature":"protected drawAttributedLabel(AttributedString label, \n            Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, \n            RectangleEdge edge, AxisState state)","target_class":"","rationale":""},{"method_name":"createAndAddEntity","method_signature":"protected createAndAddEntity(double cursor, AxisState state,\n            Rectangle2D dataArea, RectangleEdge edge,\n            PlotRenderingInfo plotState)","target_class":"","rationale":""},{"method_name":"labelAnchorV","method_signature":"protected labelAnchorV(AxisLabelLocation location)","target_class":"","rationale":""},{"method_name":"labelAnchorH","method_signature":"protected labelAnchorH(AxisLabelLocation location)","target_class":"","rationale":""},{"method_name":"setLabelInsets","method_signature":"public setLabelInsets(RectangleInsets insets, boolean notify)","target_class":"","rationale":""},{"method_name":"labelLocationX","method_signature":"protected labelLocationX(AxisLabelLocation location, \n            Rectangle2D dataArea)","target_class":"","rationale":""},{"method_name":"labelLocationY","method_signature":"protected labelLocationY(AxisLabelLocation location, \n            Rectangle2D dataArea)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"protected drawLabel(String label, Graphics2D g2,\n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge,\n            AxisState state)":{"first":{"method_name":"drawLabel","method_signature":"protected drawLabel(String label, Graphics2D g2,\n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge,\n            AxisState state)","target_class":"","rationale":""},"second":0.5104416698316799},"protected drawAttributedLabel(AttributedString label, \n            Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, \n            RectangleEdge edge, AxisState state)":{"first":{"method_name":"drawAttributedLabel","method_signature":"protected drawAttributedLabel(AttributedString label, \n            Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, \n            RectangleEdge edge, AxisState state)","target_class":"","rationale":""},"second":0.5149769561895908},"protected createAndAddEntity(double cursor, AxisState state,\n            Rectangle2D dataArea, RectangleEdge edge,\n            PlotRenderingInfo plotState)":{"first":{"method_name":"createAndAddEntity","method_signature":"protected createAndAddEntity(double cursor, AxisState state,\n            Rectangle2D dataArea, RectangleEdge edge,\n            PlotRenderingInfo plotState)","target_class":"","rationale":""},"second":0.7174143352918894},"protected labelAnchorV(AxisLabelLocation location)":{"first":{"method_name":"labelAnchorV","method_signature":"protected labelAnchorV(AxisLabelLocation location)","target_class":"","rationale":""},"second":0.7576823751282614},"protected labelAnchorH(AxisLabelLocation location)":{"first":{"method_name":"labelAnchorH","method_signature":"protected labelAnchorH(AxisLabelLocation location)","target_class":"","rationale":""},"second":0.7577941029417887},"public setLabelInsets(RectangleInsets insets, boolean notify)":{"first":{"method_name":"setLabelInsets","method_signature":"public setLabelInsets(RectangleInsets insets, boolean notify)","target_class":"","rationale":""},"second":0.7674723480843276},"protected labelLocationX(AxisLabelLocation location, \n            Rectangle2D dataArea)":{"first":{"method_name":"labelLocationX","method_signature":"protected labelLocationX(AxisLabelLocation location, \n            Rectangle2D dataArea)","target_class":"","rationale":""},"second":0.7958465534616422},"protected labelLocationY(AxisLabelLocation location, \n            Rectangle2D dataArea)":{"first":{"method_name":"labelLocationY","method_signature":"protected labelLocationY(AxisLabelLocation location, \n            Rectangle2D dataArea)","target_class":"","rationale":""},"second":0.8064940037036646}},"targetClassMap":{"drawLabel":{"target_classes":[{"class_name":"AxisLabelLocation","similarity_score":0.18389659487884807}],"target_classes_sorted_by_llm":["AxisLabelLocation"],"llm_response_time":6173,"similarity_computation_time":0,"similarity_metric":"cosine"},"drawAttributedLabel":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5778,"similarity_computation_time":0,"similarity_metric":"cosine"},"createAndAddEntity":{"target_classes":[{"class_name":"AxisState","similarity_score":0.675239047070596},{"class_name":"RectangleEdge","similarity_score":0.5896826842206664},{"class_name":"PlotRenderingInfo","similarity_score":0.6733558395262693},{"class_name":"RectangleInsets","similarity_score":0.6628583980710846},{"class_name":"RectangleInsets","similarity_score":0.6628583980710846},{"class_name":"RectangleInsets","similarity_score":0.6628583980710846},{"class_name":"AxisLabelLocation","similarity_score":0.29755912576974214},{"class_name":"RectangleInsets","similarity_score":0.6628583980710846},{"class_name":"Plot","similarity_score":0.7237006880088522}],"target_classes_sorted_by_llm":["Plot","PlotRenderingInfo","AxisState"],"llm_response_time":9978,"similarity_computation_time":8,"similarity_metric":"cosine"},"labelAnchorV":{"target_classes":[{"class_name":"AxisLabelLocation","similarity_score":0.3586731404623837},{"class_name":"RectangleInsets","similarity_score":0.7024220557636462},{"class_name":"RectangleInsets","similarity_score":0.7024220557636462},{"class_name":"RectangleInsets","similarity_score":0.7024220557636462},{"class_name":"AxisLabelLocation","similarity_score":0.3586731404623837},{"class_name":"RectangleInsets","similarity_score":0.7024220557636462},{"class_name":"Plot","similarity_score":0.7555278922843748}],"target_classes_sorted_by_llm":["Plot","RectangleInsets","RectangleInsets"],"llm_response_time":10105,"similarity_computation_time":8,"similarity_metric":"cosine"},"labelAnchorH":{"target_classes":[{"class_name":"AxisLabelLocation","similarity_score":0.3586731404623837},{"class_name":"RectangleInsets","similarity_score":0.7024220557636462},{"class_name":"RectangleInsets","similarity_score":0.7024220557636462},{"class_name":"RectangleInsets","similarity_score":0.7024220557636462},{"class_name":"AxisLabelLocation","similarity_score":0.3586731404623837},{"class_name":"RectangleInsets","similarity_score":0.7024220557636462},{"class_name":"Plot","similarity_score":0.7555278922843748}],"target_classes_sorted_by_llm":["Plot","RectangleInsets","RectangleInsets"],"llm_response_time":10002,"similarity_computation_time":4,"similarity_metric":"cosine"},"setLabelInsets":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":11908,"similarity_computation_time":0,"similarity_metric":"cosine"},"labelLocationX":{"target_classes":[{"class_name":"AxisLabelLocation","similarity_score":0.45108352622852843},{"class_name":"RectangleInsets","similarity_score":0.7210876839064038},{"class_name":"RectangleInsets","similarity_score":0.7210876839064038},{"class_name":"RectangleInsets","similarity_score":0.7210876839064038},{"class_name":"AxisLabelLocation","similarity_score":0.45108352622852843},{"class_name":"RectangleInsets","similarity_score":0.7210876839064038},{"class_name":"Plot","similarity_score":0.7776287443068929}],"target_classes_sorted_by_llm":["Plot","RectangleInsets","RectangleInsets"],"llm_response_time":10214,"similarity_computation_time":5,"similarity_metric":"cosine"},"labelLocationY":{"target_classes":[{"class_name":"AxisLabelLocation","similarity_score":0.4051222845854956},{"class_name":"RectangleInsets","similarity_score":0.7461411583831348},{"class_name":"RectangleInsets","similarity_score":0.7461411583831348},{"class_name":"RectangleInsets","similarity_score":0.7461411583831348},{"class_name":"AxisLabelLocation","similarity_score":0.4051222845854956},{"class_name":"RectangleInsets","similarity_score":0.7461411583831348},{"class_name":"Plot","similarity_score":0.7966135629766714}],"target_classes_sorted_by_llm":["Plot","RectangleInsets","RectangleInsets"],"llm_response_time":9759,"similarity_computation_time":4,"similarity_metric":"cosine"}}}
{"id":"ee3affad-261e-46ca-b82d-3117a2b8e427","hostFunctionTelemetryData":{"hostFunctionSize":326,"lineStart":45,"lineEnd":370,"bodyLineStart":45,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/axis/AxisSpace.java","sourceCode":"/**\n * A record that contains the space required at each edge of a plot.\n */\npublic class AxisSpace implements Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -2490732595134766305L;\n\n    /** The top space. */\n    private double top;\n\n    /** The bottom space. */\n    private double bottom;\n\n    /** The left space. */\n    private double left;\n\n    /** The right space. */\n    private double right;\n\n    /**\n     * Creates a new axis space record.\n     */\n    public AxisSpace() {\n        this.top \u003d 0.0;\n        this.bottom \u003d 0.0;\n        this.left \u003d 0.0;\n        this.right \u003d 0.0;\n    }\n\n    /**\n     * Returns the space reserved for axes at the top of the plot area.\n     *\n     * @return The space (in Java2D units).\n     */\n    public double getTop() {\n        return this.top;\n    }\n\n    /**\n     * Sets the space reserved for axes at the top of the plot area.\n     *\n     * @param space  the space (in Java2D units).\n     */\n    public void setTop(double space) {\n        this.top \u003d space;\n    }\n\n    /**\n     * Returns the space reserved for axes at the bottom of the plot area.\n     *\n     * @return The space (in Java2D units).\n     */\n    public double getBottom() {\n        return this.bottom;\n    }\n\n    /**\n     * Sets the space reserved for axes at the bottom of the plot area.\n     *\n     * @param space  the space (in Java2D units).\n     */\n    public void setBottom(double space) {\n        this.bottom \u003d space;\n    }\n\n    /**\n     * Returns the space reserved for axes at the left of the plot area.\n     *\n     * @return The space (in Java2D units).\n     */\n    public double getLeft() {\n        return this.left;\n    }\n\n    /**\n     * Sets the space reserved for axes at the left of the plot area.\n     *\n     * @param space  the space (in Java2D units).\n     */\n    public void setLeft(double space) {\n        this.left \u003d space;\n    }\n\n    /**\n     * Returns the space reserved for axes at the right of the plot area.\n     *\n     * @return The space (in Java2D units).\n     */\n    public double getRight() {\n        return this.right;\n    }\n\n    /**\n     * Sets the space reserved for axes at the right of the plot area.\n     *\n     * @param space  the space (in Java2D units).\n     */\n    public void setRight(double space) {\n        this.right \u003d space;\n    }\n\n    /**\n     * Adds space to the top, bottom, left or right edge of the plot area.\n     *\n     * @param space  the space (in Java2D units).\n     * @param edge  the edge ({@code null} not permitted).\n     */\n    public void add(double space, RectangleEdge edge) {\n        Args.nullNotPermitted(edge, \"edge\");\n        if (edge \u003d\u003d RectangleEdge.TOP) {\n            this.top +\u003d space;\n        }\n        else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n            this.bottom +\u003d space;\n        }\n        else if (edge \u003d\u003d RectangleEdge.LEFT) {\n            this.left +\u003d space;\n        }\n        else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n            this.right +\u003d space;\n        }\n        else {\n            throw new IllegalStateException(\"Unrecognised \u0027edge\u0027 argument.\");\n        }\n    }\n\n    /**\n     * Ensures that this object reserves at least as much space as another.\n     *\n     * @param space  the other space.\n     */\n    public void ensureAtLeast(AxisSpace space) {\n        this.top \u003d Math.max(this.top, space.top);\n        this.bottom \u003d Math.max(this.bottom, space.bottom);\n        this.left \u003d Math.max(this.left, space.left);\n        this.right \u003d Math.max(this.right, space.right);\n    }\n\n    /**\n     * Ensures there is a minimum amount of space at the edge corresponding to\n     * the specified axis location.\n     *\n     * @param space  the space.\n     * @param edge  the location.\n     */\n    public void ensureAtLeast(double space, RectangleEdge edge) {\n        if (edge \u003d\u003d RectangleEdge.TOP) {\n            if (this.top \u003c space) {\n                this.top \u003d space;\n            }\n        }\n        else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n            if (this.bottom \u003c space) {\n                this.bottom \u003d space;\n            }\n        }\n        else if (edge \u003d\u003d RectangleEdge.LEFT) {\n            if (this.left \u003c space) {\n                this.left \u003d space;\n            }\n        }\n        else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n            if (this.right \u003c space) {\n                this.right \u003d space;\n            }\n        }\n        else {\n            throw new IllegalStateException(\n                \"AxisSpace.ensureAtLeast(): unrecognised AxisLocation.\"\n            );\n        }\n    }\n\n    /**\n     * Shrinks an area by the space attributes.\n     *\n     * @param area  the area to shrink.\n     * @param result  an optional carrier for the result.\n     *\n     * @return The result.\n     */\n    public Rectangle2D shrink(Rectangle2D area, Rectangle2D result) {\n        if (result \u003d\u003d null) {\n            result \u003d new Rectangle2D.Double();\n        }\n        result.setRect(\n            area.getX() + this.left,\n            area.getY() + this.top,\n            area.getWidth() - this.left - this.right,\n            area.getHeight() - this.top - this.bottom\n        );\n        return result;\n    }\n\n    /**\n     * Expands an area by the amount of space represented by this object.\n     *\n     * @param area  the area to expand.\n     * @param result  an optional carrier for the result.\n     *\n     * @return The result.\n     */\n    public Rectangle2D expand(Rectangle2D area, Rectangle2D result) {\n        if (result \u003d\u003d null) {\n            result \u003d new Rectangle2D.Double();\n        }\n        result.setRect(\n            area.getX() - this.left,\n            area.getY() - this.top,\n            area.getWidth() + this.left + this.right,\n            area.getHeight() + this.top + this.bottom\n        );\n        return result;\n    }\n\n    /**\n     * Calculates the reserved area.\n     *\n     * @param area  the area.\n     * @param edge  the edge.\n     *\n     * @return The reserved area.\n     */\n    public Rectangle2D reserved(Rectangle2D area, RectangleEdge edge) {\n        Rectangle2D result \u003d null;\n        if (edge \u003d\u003d RectangleEdge.TOP) {\n            result \u003d new Rectangle2D.Double(\n                area.getX(), area.getY(), area.getWidth(), this.top\n            );\n        }\n        else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n            result \u003d new Rectangle2D.Double(\n                area.getX(), area.getMaxY() - this.top,\n                area.getWidth(), this.bottom\n            );\n        }\n        else if (edge \u003d\u003d RectangleEdge.LEFT) {\n            result \u003d new Rectangle2D.Double(\n                area.getX(), area.getY(), this.left, area.getHeight()\n            );\n        }\n        else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n            result \u003d new Rectangle2D.Double(\n                area.getMaxX() - this.right, area.getY(),\n                this.right, area.getHeight()\n            );\n        }\n        return result;\n    }\n\n    /**\n     * Returns a clone of the object.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException This class won\u0027t throw this exception,\n     *         but subclasses (if any) might.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Tests this object for equality with another object.\n     *\n     * @param obj  the object to compare against.\n     *\n     * @return {@code true} or {@code false}.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof AxisSpace)) {\n            return false;\n        }\n        AxisSpace that \u003d (AxisSpace) obj;\n        if (this.top !\u003d that.top) {\n            return false;\n        }\n        if (this.bottom !\u003d that.bottom) {\n            return false;\n        }\n        if (this.left !\u003d that.left) {\n            return false;\n        }\n        if (this.right !\u003d that.right) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this object.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d 23;\n        long l \u003d Double.doubleToLongBits(this.top);\n        result \u003d 37 * result + (int) (l ^ (l \u003e\u003e\u003e 32));\n        l \u003d Double.doubleToLongBits(this.bottom);\n        result \u003d 37 * result + (int) (l ^ (l \u003e\u003e\u003e 32));\n        l \u003d Double.doubleToLongBits(this.left);\n        result \u003d 37 * result + (int) (l ^ (l \u003e\u003e\u003e 32));\n        l \u003d Double.doubleToLongBits(this.right);\n        result \u003d 37 * result + (int) (l ^ (l \u003e\u003e\u003e 32));\n        return result;\n    }\n\n    /**\n     * Returns a string representing the object (for debugging purposes).\n     *\n     * @return A string.\n     */\n    @Override\n    public String toString() {\n        return super.toString() + \"[left\u003d\" + this.left + \",right\u003d\" + this.right\n                    + \",top\u003d\" + this.top + \",bottom\u003d\" + this.bottom + \"]\";\n    }\n\n}","methodCount":19,"staticMethodCount":0,"instanceMethodCount":19,"classLoc":326,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":6328},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"ensureAtLeast","method_signature":"public ensureAtLeast(AxisSpace space)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"ensureAtLeast","method_signature":"public ensureAtLeast(AxisSpace space)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public ensureAtLeast(AxisSpace space)":{"first":{"method_name":"ensureAtLeast","method_signature":"public ensureAtLeast(AxisSpace space)","target_class":"","rationale":""},"second":0.5823017871354119}},"targetClassMap":{"ensureAtLeast":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":6300,"similarity_computation_time":0,"similarity_metric":"cosine"}}}
{"id":"6c05614a-ab94-48e0-a801-76cf0a8986aa","hostFunctionTelemetryData":{"hostFunctionSize":326,"lineStart":45,"lineEnd":370,"bodyLineStart":45,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/axis/AxisSpace.java","sourceCode":"/**\n * A record that contains the space required at each edge of a plot.\n */\npublic class AxisSpace implements Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -2490732595134766305L;\n\n    /** The top space. */\n    private double top;\n\n    /** The bottom space. */\n    private double bottom;\n\n    /** The left space. */\n    private double left;\n\n    /** The right space. */\n    private double right;\n\n    /**\n     * Creates a new axis space record.\n     */\n    public AxisSpace() {\n        this.top \u003d 0.0;\n        this.bottom \u003d 0.0;\n        this.left \u003d 0.0;\n        this.right \u003d 0.0;\n    }\n\n    /**\n     * Returns the space reserved for axes at the top of the plot area.\n     *\n     * @return The space (in Java2D units).\n     */\n    public double getTop() {\n        return this.top;\n    }\n\n    /**\n     * Sets the space reserved for axes at the top of the plot area.\n     *\n     * @param space  the space (in Java2D units).\n     */\n    public void setTop(double space) {\n        this.top \u003d space;\n    }\n\n    /**\n     * Returns the space reserved for axes at the bottom of the plot area.\n     *\n     * @return The space (in Java2D units).\n     */\n    public double getBottom() {\n        return this.bottom;\n    }\n\n    /**\n     * Sets the space reserved for axes at the bottom of the plot area.\n     *\n     * @param space  the space (in Java2D units).\n     */\n    public void setBottom(double space) {\n        this.bottom \u003d space;\n    }\n\n    /**\n     * Returns the space reserved for axes at the left of the plot area.\n     *\n     * @return The space (in Java2D units).\n     */\n    public double getLeft() {\n        return this.left;\n    }\n\n    /**\n     * Sets the space reserved for axes at the left of the plot area.\n     *\n     * @param space  the space (in Java2D units).\n     */\n    public void setLeft(double space) {\n        this.left \u003d space;\n    }\n\n    /**\n     * Returns the space reserved for axes at the right of the plot area.\n     *\n     * @return The space (in Java2D units).\n     */\n    public double getRight() {\n        return this.right;\n    }\n\n    /**\n     * Sets the space reserved for axes at the right of the plot area.\n     *\n     * @param space  the space (in Java2D units).\n     */\n    public void setRight(double space) {\n        this.right \u003d space;\n    }\n\n    /**\n     * Adds space to the top, bottom, left or right edge of the plot area.\n     *\n     * @param space  the space (in Java2D units).\n     * @param edge  the edge ({@code null} not permitted).\n     */\n    public void add(double space, RectangleEdge edge) {\n        Args.nullNotPermitted(edge, \"edge\");\n        if (edge \u003d\u003d RectangleEdge.TOP) {\n            this.top +\u003d space;\n        }\n        else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n            this.bottom +\u003d space;\n        }\n        else if (edge \u003d\u003d RectangleEdge.LEFT) {\n            this.left +\u003d space;\n        }\n        else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n            this.right +\u003d space;\n        }\n        else {\n            throw new IllegalStateException(\"Unrecognised \u0027edge\u0027 argument.\");\n        }\n    }\n\n    /**\n     * Ensures that this object reserves at least as much space as another.\n     *\n     * @param space  the other space.\n     */\n    public void ensureAtLeast(AxisSpace space) {\n        this.top \u003d Math.max(this.top, space.top);\n        this.bottom \u003d Math.max(this.bottom, space.bottom);\n        this.left \u003d Math.max(this.left, space.left);\n        this.right \u003d Math.max(this.right, space.right);\n    }\n\n    /**\n     * Ensures there is a minimum amount of space at the edge corresponding to\n     * the specified axis location.\n     *\n     * @param space  the space.\n     * @param edge  the location.\n     */\n    public void ensureAtLeast(double space, RectangleEdge edge) {\n        if (edge \u003d\u003d RectangleEdge.TOP) {\n            if (this.top \u003c space) {\n                this.top \u003d space;\n            }\n        }\n        else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n            if (this.bottom \u003c space) {\n                this.bottom \u003d space;\n            }\n        }\n        else if (edge \u003d\u003d RectangleEdge.LEFT) {\n            if (this.left \u003c space) {\n                this.left \u003d space;\n            }\n        }\n        else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n            if (this.right \u003c space) {\n                this.right \u003d space;\n            }\n        }\n        else {\n            throw new IllegalStateException(\n                \"AxisSpace.ensureAtLeast(): unrecognised AxisLocation.\"\n            );\n        }\n    }\n\n    /**\n     * Shrinks an area by the space attributes.\n     *\n     * @param area  the area to shrink.\n     * @param result  an optional carrier for the result.\n     *\n     * @return The result.\n     */\n    public Rectangle2D shrink(Rectangle2D area, Rectangle2D result) {\n        if (result \u003d\u003d null) {\n            result \u003d new Rectangle2D.Double();\n        }\n        result.setRect(\n            area.getX() + this.left,\n            area.getY() + this.top,\n            area.getWidth() - this.left - this.right,\n            area.getHeight() - this.top - this.bottom\n        );\n        return result;\n    }\n\n    /**\n     * Expands an area by the amount of space represented by this object.\n     *\n     * @param area  the area to expand.\n     * @param result  an optional carrier for the result.\n     *\n     * @return The result.\n     */\n    public Rectangle2D expand(Rectangle2D area, Rectangle2D result) {\n        if (result \u003d\u003d null) {\n            result \u003d new Rectangle2D.Double();\n        }\n        result.setRect(\n            area.getX() - this.left,\n            area.getY() - this.top,\n            area.getWidth() + this.left + this.right,\n            area.getHeight() + this.top + this.bottom\n        );\n        return result;\n    }\n\n    /**\n     * Calculates the reserved area.\n     *\n     * @param area  the area.\n     * @param edge  the edge.\n     *\n     * @return The reserved area.\n     */\n    public Rectangle2D reserved(Rectangle2D area, RectangleEdge edge) {\n        Rectangle2D result \u003d null;\n        if (edge \u003d\u003d RectangleEdge.TOP) {\n            result \u003d new Rectangle2D.Double(\n                area.getX(), area.getY(), area.getWidth(), this.top\n            );\n        }\n        else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n            result \u003d new Rectangle2D.Double(\n                area.getX(), area.getMaxY() - this.top,\n                area.getWidth(), this.bottom\n            );\n        }\n        else if (edge \u003d\u003d RectangleEdge.LEFT) {\n            result \u003d new Rectangle2D.Double(\n                area.getX(), area.getY(), this.left, area.getHeight()\n            );\n        }\n        else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n            result \u003d new Rectangle2D.Double(\n                area.getMaxX() - this.right, area.getY(),\n                this.right, area.getHeight()\n            );\n        }\n        return result;\n    }\n\n    /**\n     * Returns a clone of the object.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException This class won\u0027t throw this exception,\n     *         but subclasses (if any) might.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Tests this object for equality with another object.\n     *\n     * @param obj  the object to compare against.\n     *\n     * @return {@code true} or {@code false}.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof AxisSpace)) {\n            return false;\n        }\n        AxisSpace that \u003d (AxisSpace) obj;\n        if (this.top !\u003d that.top) {\n            return false;\n        }\n        if (this.bottom !\u003d that.bottom) {\n            return false;\n        }\n        if (this.left !\u003d that.left) {\n            return false;\n        }\n        if (this.right !\u003d that.right) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this object.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d 23;\n        long l \u003d Double.doubleToLongBits(this.top);\n        result \u003d 37 * result + (int) (l ^ (l \u003e\u003e\u003e 32));\n        l \u003d Double.doubleToLongBits(this.bottom);\n        result \u003d 37 * result + (int) (l ^ (l \u003e\u003e\u003e 32));\n        l \u003d Double.doubleToLongBits(this.left);\n        result \u003d 37 * result + (int) (l ^ (l \u003e\u003e\u003e 32));\n        l \u003d Double.doubleToLongBits(this.right);\n        result \u003d 37 * result + (int) (l ^ (l \u003e\u003e\u003e 32));\n        return result;\n    }\n\n    /**\n     * Returns a string representing the object (for debugging purposes).\n     *\n     * @return A string.\n     */\n    @Override\n    public String toString() {\n        return super.toString() + \"[left\u003d\" + this.left + \",right\u003d\" + this.right\n                    + \",top\u003d\" + this.top + \",bottom\u003d\" + this.bottom + \"]\";\n    }\n\n}","methodCount":19,"staticMethodCount":0,"instanceMethodCount":19,"classLoc":326,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":27},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"ensureAtLeast","method_signature":"public ensureAtLeast(AxisSpace space)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"ensureAtLeast","method_signature":"public ensureAtLeast(AxisSpace space)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public ensureAtLeast(AxisSpace space)":{"first":{"method_name":"ensureAtLeast","method_signature":"public ensureAtLeast(AxisSpace space)","target_class":"","rationale":""},"second":0.5823017871354119}},"targetClassMap":{"ensureAtLeast":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":0,"similarity_computation_time":0,"similarity_metric":"cosine"}}}
{"id":"9b7b04c9-7f1b-46c3-aac5-802d8bc4f35b","hostFunctionTelemetryData":{"hostFunctionSize":1328,"lineStart":76,"lineEnd":1403,"bodyLineStart":76,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/axis/CategoryAxis.java","sourceCode":"/**\n * An axis that displays categories.\n */\npublic class CategoryAxis extends Axis implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d 5886554608114265863L;\n\n    /**\n     * The default margin for the axis (used for both lower and upper margins).\n     */\n    public static final double DEFAULT_AXIS_MARGIN \u003d 0.05;\n\n    /**\n     * The default margin between categories (a percentage of the overall axis\n     * length).\n     */\n    public static final double DEFAULT_CATEGORY_MARGIN \u003d 0.20;\n\n    /** The amount of space reserved at the start of the axis. */\n    private double lowerMargin;\n\n    /** The amount of space reserved at the end of the axis. */\n    private double upperMargin;\n\n    /** The amount of space reserved between categories. */\n    private double categoryMargin;\n\n    /** The maximum number of lines for category labels. */\n    private int maximumCategoryLabelLines;\n\n    /**\n     * A ratio that is multiplied by the width of one category to determine the\n     * maximum label width.\n     */\n    private float maximumCategoryLabelWidthRatio;\n\n    /** The category label offset. */\n    private int categoryLabelPositionOffset;\n\n    /**\n     * A structure defining the category label positions for each axis\n     * location.\n     */\n    private CategoryLabelPositions categoryLabelPositions;\n\n    /** Storage for tick label font overrides (if any). */\n    private Map\u003cComparable, Font\u003e tickLabelFontMap; \n\n    /** Storage for tick label paint overrides (if any). */\n    private transient Map\u003cComparable, Paint\u003e tickLabelPaintMap;\n\n    /** Storage for the category label tooltips (if any). */\n    private Map\u003cComparable, String\u003e categoryLabelToolTips;\n\n    /** Storage for the category label URLs (if any). */\n    private Map\u003cComparable, String\u003e categoryLabelURLs;\n    \n    /**\n     * Creates a new category axis with no label.\n     */\n    public CategoryAxis() {\n        this(null);\n    }\n\n    /**\n     * Constructs a category axis, using default values where necessary.\n     *\n     * @param label  the axis label ({@code null} permitted).\n     */\n    public CategoryAxis(String label) {\n        super(label);\n\n        this.lowerMargin \u003d DEFAULT_AXIS_MARGIN;\n        this.upperMargin \u003d DEFAULT_AXIS_MARGIN;\n        this.categoryMargin \u003d DEFAULT_CATEGORY_MARGIN;\n        this.maximumCategoryLabelLines \u003d 1;\n        this.maximumCategoryLabelWidthRatio \u003d 0.0f;\n\n        this.categoryLabelPositionOffset \u003d 4;\n        this.categoryLabelPositions \u003d CategoryLabelPositions.STANDARD;\n        this.tickLabelFontMap \u003d new HashMap\u003c\u003e();\n        this.tickLabelPaintMap \u003d new HashMap\u003c\u003e();\n        this.categoryLabelToolTips \u003d new HashMap\u003c\u003e();\n        this.categoryLabelURLs \u003d new HashMap\u003c\u003e();\n    }\n\n    /**\n     * Returns the lower margin for the axis.\n     *\n     * @return The margin.\n     *\n     * @see #getUpperMargin()\n     * @see #setLowerMargin(double)\n     */\n    public double getLowerMargin() {\n        return this.lowerMargin;\n    }\n\n    /**\n     * Sets the lower margin for the axis and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param margin  the margin as a percentage of the axis length (for\n     *                example, 0.05 is five percent).\n     *\n     * @see #getLowerMargin()\n     */\n    public void setLowerMargin(double margin) {\n        this.lowerMargin \u003d margin;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the upper margin for the axis.\n     *\n     * @return The margin.\n     *\n     * @see #getLowerMargin()\n     * @see #setUpperMargin(double)\n     */\n    public double getUpperMargin() {\n        return this.upperMargin;\n    }\n\n    /**\n     * Sets the upper margin for the axis and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param margin  the margin as a percentage of the axis length (for\n     *                example, 0.05 is five percent).\n     *\n     * @see #getUpperMargin()\n     */\n    public void setUpperMargin(double margin) {\n        this.upperMargin \u003d margin;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the category margin.\n     *\n     * @return The margin.\n     *\n     * @see #setCategoryMargin(double)\n     */\n    public double getCategoryMargin() {\n        return this.categoryMargin;\n    }\n\n    /**\n     * Sets the category margin and sends an {@link AxisChangeEvent} to all\n     * registered listeners.  The overall category margin is distributed over\n     * N-1 gaps, where N is the number of categories on the axis.\n     *\n     * @param margin  the margin as a percentage of the axis length (for\n     *                example, 0.05 is five percent).\n     *\n     * @see #getCategoryMargin()\n     */\n    public void setCategoryMargin(double margin) {\n        this.categoryMargin \u003d margin;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the maximum number of lines to use for each category label.\n     *\n     * @return The maximum number of lines.\n     *\n     * @see #setMaximumCategoryLabelLines(int)\n     */\n    public int getMaximumCategoryLabelLines() {\n        return this.maximumCategoryLabelLines;\n    }\n\n    /**\n     * Sets the maximum number of lines to use for each category label and\n     * sends an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param lines  the maximum number of lines.\n     *\n     * @see #getMaximumCategoryLabelLines()\n     */\n    public void setMaximumCategoryLabelLines(int lines) {\n        this.maximumCategoryLabelLines \u003d lines;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the category label width ratio.\n     *\n     * @return The ratio.\n     *\n     * @see #setMaximumCategoryLabelWidthRatio(float)\n     */\n    public float getMaximumCategoryLabelWidthRatio() {\n        return this.maximumCategoryLabelWidthRatio;\n    }\n\n    /**\n     * Sets the maximum category label width ratio and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param ratio  the ratio.\n     *\n     * @see #getMaximumCategoryLabelWidthRatio()\n     */\n    public void setMaximumCategoryLabelWidthRatio(float ratio) {\n        this.maximumCategoryLabelWidthRatio \u003d ratio;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the offset between the axis and the category labels (before\n     * label positioning is taken into account).\n     *\n     * @return The offset (in Java2D units).\n     *\n     * @see #setCategoryLabelPositionOffset(int)\n     */\n    public int getCategoryLabelPositionOffset() {\n        return this.categoryLabelPositionOffset;\n    }\n\n    /**\n     * Sets the offset between the axis and the category labels (before label\n     * positioning is taken into account) and sends a change event to all \n     * registered listeners.\n     *\n     * @param offset  the offset (in Java2D units).\n     *\n     * @see #getCategoryLabelPositionOffset()\n     */\n    public void setCategoryLabelPositionOffset(int offset) {\n        this.categoryLabelPositionOffset \u003d offset;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the category label position specification (this contains label\n     * positioning info for all four possible axis locations).\n     *\n     * @return The positions (never {@code null}).\n     *\n     * @see #setCategoryLabelPositions(CategoryLabelPositions)\n     */\n    public CategoryLabelPositions getCategoryLabelPositions() {\n        return this.categoryLabelPositions;\n    }\n\n    /**\n     * Sets the category label position specification for the axis and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param positions  the positions ({@code null} not permitted).\n     *\n     * @see #getCategoryLabelPositions()\n     */\n    public void setCategoryLabelPositions(CategoryLabelPositions positions) {\n        Args.nullNotPermitted(positions, \"positions\");\n        this.categoryLabelPositions \u003d positions;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the font for the tick label for the given category.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @return The font (never {@code null}).\n     *\n     * @see #setTickLabelFont(Comparable, Font)\n     */\n    public Font getTickLabelFont(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        Font result \u003d this.tickLabelFontMap.get(category);\n        // if there is no specific font, use the general one...\n        if (result \u003d\u003d null) {\n            result \u003d getTickLabelFont();\n        }\n        return result;\n    }\n\n    /**\n     * Sets the font for the tick label for the specified category and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     * @param font  the font ({@code null} permitted).\n     *\n     * @see #getTickLabelFont(Comparable)\n     */\n    public void setTickLabelFont(Comparable category, Font font) {\n        Args.nullNotPermitted(category, \"category\");\n        if (font \u003d\u003d null) {\n            this.tickLabelFontMap.remove(category);\n        } else {\n            this.tickLabelFontMap.put(category, font);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the tick label for the given category.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setTickLabelPaint(Paint)\n     */\n    public Paint getTickLabelPaint(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        Paint result \u003d this.tickLabelPaintMap.get(category);\n        // if there is no specific paint, use the general one...\n        if (result \u003d\u003d null) {\n            result \u003d getTickLabelPaint();\n        }\n        return result;\n    }\n\n    /**\n     * Sets the paint for the tick label for the specified category and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     * @param paint  the paint ({@code null} permitted).\n     *\n     * @see #getTickLabelPaint(Comparable)\n     */\n    public void setTickLabelPaint(Comparable category, Paint paint) {\n        Args.nullNotPermitted(category, \"category\");\n        if (paint \u003d\u003d null) {\n            this.tickLabelPaintMap.remove(category);\n        } else {\n            this.tickLabelPaintMap.put(category, paint);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a tooltip to the specified category and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     * @param tooltip  the tooltip text ({@code null} permitted).\n     *\n     * @see #removeCategoryLabelToolTip(Comparable)\n     */\n    public void addCategoryLabelToolTip(Comparable category, String tooltip) {\n        Args.nullNotPermitted(category, \"category\");\n        this.categoryLabelToolTips.put(category, tooltip);\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the tool tip text for the label belonging to the specified\n     * category.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @return The tool tip text (possibly {@code null}).\n     *\n     * @see #addCategoryLabelToolTip(Comparable, String)\n     * @see #removeCategoryLabelToolTip(Comparable)\n     */\n    public String getCategoryLabelToolTip(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        return this.categoryLabelToolTips.get(category);\n    }\n\n    /**\n     * Removes the tooltip for the specified category and, if there was a value\n     * associated with that category, sends an {@link AxisChangeEvent} to all \n     * registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @see #addCategoryLabelToolTip(Comparable, String)\n     * @see #clearCategoryLabelToolTips()\n     */\n    public void removeCategoryLabelToolTip(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        if (this.categoryLabelToolTips.remove(category) !\u003d null) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears the category label tooltips and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @see #addCategoryLabelToolTip(Comparable, String)\n     * @see #removeCategoryLabelToolTip(Comparable)\n     */\n    public void clearCategoryLabelToolTips() {\n        this.categoryLabelToolTips.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a URL (to be used in image maps) to the specified category and \n     * sends an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     * @param url  the URL text ({@code null} permitted).\n     *\n     * @see #removeCategoryLabelURL(Comparable)\n     */\n    public void addCategoryLabelURL(Comparable category, String url) {\n        Args.nullNotPermitted(category, \"category\");\n        this.categoryLabelURLs.put(category, url);\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the URL for the label belonging to the specified category.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @return The URL text (possibly {@code null}).\n     * \n     * @see #addCategoryLabelURL(Comparable, String)\n     * @see #removeCategoryLabelURL(Comparable)\n     */\n    public String getCategoryLabelURL(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        return this.categoryLabelURLs.get(category);\n    }\n\n    /**\n     * Removes the URL for the specified category and, if there was a URL \n     * associated with that category, sends an {@link AxisChangeEvent} to all \n     * registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @see #addCategoryLabelURL(Comparable, String)\n     * @see #clearCategoryLabelURLs()\n     */\n    public void removeCategoryLabelURL(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        if (this.categoryLabelURLs.remove(category) !\u003d null) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears the category label URLs and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @see #addCategoryLabelURL(Comparable, String)\n     * @see #removeCategoryLabelURL(Comparable)\n     */\n    public void clearCategoryLabelURLs() {\n        this.categoryLabelURLs.clear();\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the Java 2D coordinate for a category.\n     *\n     * @param anchor  the anchor point ({@code null} not permitted).\n     * @param category  the category index.\n     * @param categoryCount  the category count.\n     * @param area  the data area.\n     * @param edge  the location of the axis.\n     *\n     * @return The coordinate.\n     */\n    public double getCategoryJava2DCoordinate(CategoryAnchor anchor, \n            int category, int categoryCount, Rectangle2D area, \n            RectangleEdge edge) {\n        Args.nullNotPermitted(anchor, \"anchor\");\n        double result \u003d 0.0;\n        switch (anchor) {\n            case START:\n                result \u003d getCategoryStart(category, categoryCount, area, edge);\n                break;\n            case MIDDLE:\n                result \u003d getCategoryMiddle(category, categoryCount, area, edge);\n                break;\n            case END:\n                result \u003d getCategoryEnd(category, categoryCount, area, edge);\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected anchor value.\");\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the starting coordinate for the specified category.\n     *\n     * @param category  the category.\n     * @param categoryCount  the number of categories.\n     * @param area  the data area.\n     * @param edge  the axis location.\n     *\n     * @return The coordinate.\n     *\n     * @see #getCategoryMiddle(int, int, Rectangle2D, RectangleEdge)\n     * @see #getCategoryEnd(int, int, Rectangle2D, RectangleEdge)\n     */\n    public double getCategoryStart(int category, int categoryCount, \n            Rectangle2D area, RectangleEdge edge) {\n\n        double result \u003d 0.0;\n        if ((edge \u003d\u003d RectangleEdge.TOP) || (edge \u003d\u003d RectangleEdge.BOTTOM)) {\n            result \u003d area.getX() + area.getWidth() * getLowerMargin();\n        }\n        else if ((edge \u003d\u003d RectangleEdge.LEFT)\n                || (edge \u003d\u003d RectangleEdge.RIGHT)) {\n            result \u003d area.getMinY() + area.getHeight() * getLowerMargin();\n        }\n\n        double categorySize \u003d calculateCategorySize(categoryCount, area, edge);\n        double categoryGapWidth \u003d calculateCategoryGapSize(categoryCount, area,\n                edge);\n\n        result \u003d result + category * (categorySize + categoryGapWidth);\n        return result;\n    }\n\n    /**\n     * Returns the middle coordinate for the specified category.\n     *\n     * @param category  the category.\n     * @param categoryCount  the number of categories.\n     * @param area  the data area.\n     * @param edge  the axis location.\n     *\n     * @return The coordinate.\n     *\n     * @see #getCategoryStart(int, int, Rectangle2D, RectangleEdge)\n     * @see #getCategoryEnd(int, int, Rectangle2D, RectangleEdge)\n     */\n    public double getCategoryMiddle(int category, int categoryCount,\n            Rectangle2D area, RectangleEdge edge) {\n\n        if (category \u003c 0 || category \u003e\u003d categoryCount) {\n            throw new IllegalArgumentException(\"Invalid category index: \"\n                    + category);\n        }\n        return getCategoryStart(category, categoryCount, area, edge)\n               + calculateCategorySize(categoryCount, area, edge) / 2;\n\n    }\n\n    /**\n     * Returns the end coordinate for the specified category.\n     *\n     * @param category  the category.\n     * @param categoryCount  the number of categories.\n     * @param area  the data area.\n     * @param edge  the axis location.\n     *\n     * @return The coordinate.\n     *\n     * @see #getCategoryStart(int, int, Rectangle2D, RectangleEdge)\n     * @see #getCategoryMiddle(int, int, Rectangle2D, RectangleEdge)\n     */\n    public double getCategoryEnd(int category, int categoryCount,\n            Rectangle2D area, RectangleEdge edge) {\n        return getCategoryStart(category, categoryCount, area, edge)\n               + calculateCategorySize(categoryCount, area, edge);\n    }\n\n    /**\n     * A convenience method that returns the axis coordinate for the centre of\n     * a category.\n     *\n     * @param category  the category key ({@code null} not permitted).\n     * @param categories  the categories ({@code null} not permitted).\n     * @param area  the data area ({@code null} not permitted).\n     * @param edge  the edge along which the axis lies ({@code null} not\n     *     permitted).\n     *\n     * @return The centre coordinate.\n     *\n     * @see #getCategorySeriesMiddle(Comparable, Comparable, CategoryDataset,\n     *     double, Rectangle2D, RectangleEdge)\n     */\n    public double getCategoryMiddle(Comparable category,\n            List categories, Rectangle2D area, RectangleEdge edge) {\n        Args.nullNotPermitted(categories, \"categories\");\n        int categoryIndex \u003d categories.indexOf(category);\n        int categoryCount \u003d categories.size();\n        return getCategoryMiddle(categoryIndex, categoryCount, area, edge);\n    }\n\n    /**\n     * Returns the middle coordinate (in Java2D space) for a series within a\n     * category.\n     *\n     * @param category  the category ({@code null} not permitted).\n     * @param seriesKey  the series key ({@code null} not permitted).\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param itemMargin  the item margin (0.0 \u0026lt;\u003d itemMargin \u0026lt; 1.0);\n     * @param area  the area ({@code null} not permitted).\n     * @param edge  the edge ({@code null} not permitted).\n     *\n     * @return The coordinate in Java2D space.\n     */\n    public double getCategorySeriesMiddle(Comparable category,\n            Comparable seriesKey, CategoryDataset dataset, double itemMargin,\n            Rectangle2D area, RectangleEdge edge) {\n\n        int categoryIndex \u003d dataset.getColumnIndex(category);\n        int categoryCount \u003d dataset.getColumnCount();\n        int seriesIndex \u003d dataset.getRowIndex(seriesKey);\n        int seriesCount \u003d dataset.getRowCount();\n        double start \u003d getCategoryStart(categoryIndex, categoryCount, area,\n                edge);\n        double end \u003d getCategoryEnd(categoryIndex, categoryCount, area, edge);\n        double width \u003d end - start;\n        if (seriesCount \u003d\u003d 1) {\n            return start + width / 2.0;\n        }\n        else {\n            double gap \u003d (width * itemMargin) / (seriesCount - 1);\n            double ww \u003d (width * (1 - itemMargin)) / seriesCount;\n            return start + (seriesIndex * (ww + gap)) + ww / 2.0;\n        }\n    }\n\n    /**\n     * Returns the middle coordinate (in Java2D space) for a series within a\n     * category.\n     *\n     * @param categoryIndex  the category index.\n     * @param categoryCount  the category count.\n     * @param seriesIndex the series index.\n     * @param seriesCount the series count.\n     * @param itemMargin  the item margin (0.0 \u0026lt;\u003d itemMargin \u0026lt; 1.0);\n     * @param area  the area ({@code null} not permitted).\n     * @param edge  the edge ({@code null} not permitted).\n     *\n     * @return The coordinate in Java2D space.\n     */\n    public double getCategorySeriesMiddle(int categoryIndex, int categoryCount,\n            int seriesIndex, int seriesCount, double itemMargin,\n            Rectangle2D area, RectangleEdge edge) {\n\n        double start \u003d getCategoryStart(categoryIndex, categoryCount, area,\n                edge);\n        double end \u003d getCategoryEnd(categoryIndex, categoryCount, area, edge);\n        double width \u003d end - start;\n        if (seriesCount \u003d\u003d 1) {\n            return start + width / 2.0;\n        }\n        else {\n            double gap \u003d (width * itemMargin) / (seriesCount - 1);\n            double ww \u003d (width * (1 - itemMargin)) / seriesCount;\n            return start + (seriesIndex * (ww + gap)) + ww / 2.0;\n        }\n    }\n\n    /**\n     * Calculates the size (width or height, depending on the location of the\n     * axis) of a category.\n     *\n     * @param categoryCount  the number of categories.\n     * @param area  the area within which the categories will be drawn.\n     * @param edge  the axis location.\n     *\n     * @return The category size.\n     */\n    protected double calculateCategorySize(int categoryCount, Rectangle2D area,\n            RectangleEdge edge) {\n        double result;\n        double available \u003d 0.0;\n\n        if ((edge \u003d\u003d RectangleEdge.TOP) || (edge \u003d\u003d RectangleEdge.BOTTOM)) {\n            available \u003d area.getWidth();\n        }\n        else if ((edge \u003d\u003d RectangleEdge.LEFT)\n                || (edge \u003d\u003d RectangleEdge.RIGHT)) {\n            available \u003d area.getHeight();\n        }\n        if (categoryCount \u003e 1) {\n            result \u003d available * (1 - getLowerMargin() - getUpperMargin()\n                     - getCategoryMargin());\n            result \u003d result / categoryCount;\n        }\n        else {\n            result \u003d available * (1 - getLowerMargin() - getUpperMargin());\n        }\n        return result;\n    }\n\n    /**\n     * Calculates the size (width or height, depending on the location of the\n     * axis) of a category gap.\n     *\n     * @param categoryCount  the number of categories.\n     * @param area  the area within which the categories will be drawn.\n     * @param edge  the axis location.\n     *\n     * @return The category gap width.\n     */\n    protected double calculateCategoryGapSize(int categoryCount, \n            Rectangle2D area, RectangleEdge edge) {\n\n        double result \u003d 0.0;\n        double available \u003d 0.0;\n\n        if ((edge \u003d\u003d RectangleEdge.TOP) || (edge \u003d\u003d RectangleEdge.BOTTOM)) {\n            available \u003d area.getWidth();\n        }\n        else if ((edge \u003d\u003d RectangleEdge.LEFT)\n                || (edge \u003d\u003d RectangleEdge.RIGHT)) {\n            available \u003d area.getHeight();\n        }\n\n        if (categoryCount \u003e 1) {\n            result \u003d available * getCategoryMargin() / (categoryCount - 1);\n        }\n        return result;\n    }\n\n    /**\n     * Estimates the space required for the axis, given a specific drawing area.\n     *\n     * @param g2  the graphics device (used to obtain font information).\n     * @param plot  the plot that the axis belongs to.\n     * @param plotArea  the area within which the axis should be drawn.\n     * @param edge  the axis location ({@code null} not permitted).\n     * @param space  the space already reserved.\n     *\n     * @return The space required to draw the axis.\n     */\n    @Override\n    public AxisSpace reserveSpace(Graphics2D g2, Plot plot, \n            Rectangle2D plotArea, RectangleEdge edge, AxisSpace space) {\n\n        // create a new space object if one wasn\u0027t supplied...\n        if (space \u003d\u003d null) {\n            space \u003d new AxisSpace();\n        }\n\n        // if the axis is not visible, no additional space is required...\n        if (!isVisible()) {\n            return space;\n        }\n\n        // calculate the max size of the tick labels (if visible)...\n        double tickLabelHeight \u003d 0.0;\n        double tickLabelWidth \u003d 0.0;\n        if (isTickLabelsVisible()) {\n            g2.setFont(getTickLabelFont());\n            AxisState state \u003d new AxisState();\n            // we call refresh ticks just to get the maximum width or height\n            refreshTicks(g2, state, plotArea, edge);\n            switch (edge) {\n                case TOP:\n                    tickLabelHeight \u003d state.getMax();\n                    break;\n                case BOTTOM:\n                    tickLabelHeight \u003d state.getMax();\n                    break;\n                case LEFT:\n                    tickLabelWidth \u003d state.getMax();\n                    break;\n                case RIGHT:\n                    tickLabelWidth \u003d state.getMax();\n                    break;\n                default:\n                    throw new IllegalStateException(\"Unexpected RectangleEdge value.\");\n            }\n        }\n\n        // get the axis label size and update the space object...\n        Rectangle2D labelEnclosure \u003d getLabelEnclosure(g2, edge);\n        double labelHeight, labelWidth;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            labelHeight \u003d labelEnclosure.getHeight();\n            space.add(labelHeight + tickLabelHeight\n                    + this.categoryLabelPositionOffset, edge);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            labelWidth \u003d labelEnclosure.getWidth();\n            space.add(labelWidth + tickLabelWidth\n                    + this.categoryLabelPositionOffset, edge);\n        }\n        return space;\n    }\n\n    /**\n     * Configures the axis against the current plot.\n     */\n    @Override\n    public void configure() {\n        // nothing required\n    }\n\n    /**\n     * Draws the axis on a Java 2D graphics device (such as the screen or a\n     * printer).\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param cursor  the cursor location.\n     * @param plotArea  the area within which the axis should be drawn\n     *                  ({@code null} not permitted).\n     * @param dataArea  the area within which the plot is being drawn\n     *                  ({@code null} not permitted).\n     * @param edge  the location of the axis ({@code null} not permitted).\n     * @param plotState  collects information about the plot\n     *                   ({@code null} permitted).\n     *\n     * @return The axis state (never {@code null}).\n     */\n    @Override\n    public AxisState draw(Graphics2D g2, double cursor, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge,\n            PlotRenderingInfo plotState) {\n\n        // if the axis is not visible, don\u0027t draw it...\n        if (!isVisible()) {\n            return new AxisState(cursor);\n        }\n\n        if (isAxisLineVisible()) {\n            drawAxisLine(g2, cursor, dataArea, edge);\n        }\n        AxisState state \u003d new AxisState(cursor);\n        if (isTickMarksVisible()) {\n            drawTickMarks(g2, cursor, dataArea, edge, state);\n        }\n\n        createAndAddEntity(cursor, state, dataArea, edge, plotState);\n\n        // draw the category labels and axis label\n        state \u003d drawCategoryLabels(g2, plotArea, dataArea, edge, state,\n                plotState);\n        if (getAttributedLabel() !\u003d null) {\n            state \u003d drawAttributedLabel(getAttributedLabel(), g2, plotArea, \n                    dataArea, edge, state);\n            \n        } else {\n            state \u003d drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);\n        }\n        return state;\n\n    }\n\n    /**\n     * Draws the category labels and returns the updated axis state.\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param plotArea  the plot area ({@code null} not permitted).\n     * @param dataArea  the area inside the axes ({@code null} not\n     *                  permitted).\n     * @param edge  the axis location ({@code null} not permitted).\n     * @param state  the axis state ({@code null} not permitted).\n     * @param plotState  collects information about the plot ({@code null}\n     *                   permitted).\n     *\n     * @return The updated axis state (never {@code null}).\n     */\n    protected AxisState drawCategoryLabels(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state,\n            PlotRenderingInfo plotState) {\n\n        Args.nullNotPermitted(state, \"state\");\n        if (!isTickLabelsVisible()) {\n            return state;\n        }\n \n        List ticks \u003d refreshTicks(g2, state, plotArea, edge);\n        state.setTicks(ticks);\n        int categoryIndex \u003d 0;\n        for (Object o : ticks) {\n            CategoryTick tick \u003d (CategoryTick) o;\n            g2.setFont(getTickLabelFont(tick.getCategory()));\n            g2.setPaint(getTickLabelPaint(tick.getCategory()));\n\n            CategoryLabelPosition position\n                    \u003d this.categoryLabelPositions.getLabelPosition(edge);\n            double x0 \u003d 0.0;\n            double x1 \u003d 0.0;\n            double y0 \u003d 0.0;\n            double y1 \u003d 0.0;\n            if (edge \u003d\u003d RectangleEdge.TOP) {\n                x0 \u003d getCategoryStart(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                x1 \u003d getCategoryEnd(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                y1 \u003d state.getCursor() - this.categoryLabelPositionOffset;\n                y0 \u003d y1 - state.getMax();\n            }\n            else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n                x0 \u003d getCategoryStart(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                x1 \u003d getCategoryEnd(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                y0 \u003d state.getCursor() + this.categoryLabelPositionOffset;\n                y1 \u003d y0 + state.getMax();\n            }\n            else if (edge \u003d\u003d RectangleEdge.LEFT) {\n                y0 \u003d getCategoryStart(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                y1 \u003d getCategoryEnd(categoryIndex, ticks.size(), dataArea,\n                        edge);\n                x1 \u003d state.getCursor() - this.categoryLabelPositionOffset;\n                x0 \u003d x1 - state.getMax();\n            }\n            else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n                y0 \u003d getCategoryStart(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                y1 \u003d getCategoryEnd(categoryIndex, ticks.size(), dataArea,\n                        edge);\n                x0 \u003d state.getCursor() + this.categoryLabelPositionOffset;\n                x1 \u003d x0 - state.getMax();\n            }\n            Rectangle2D area \u003d new Rectangle2D.Double(x0, y0, (x1 - x0),\n                    (y1 - y0));\n            Point2D anchorPoint \u003d position.getCategoryAnchor().getAnchorPoint(area);\n            TextBlock block \u003d tick.getLabel();\n            block.draw(g2, (float) anchorPoint.getX(),\n                    (float) anchorPoint.getY(), position.getLabelAnchor(),\n                    (float) anchorPoint.getX(), (float) anchorPoint.getY(),\n                    position.getAngle());\n            Shape bounds \u003d block.calculateBounds(g2,\n                    (float) anchorPoint.getX(), (float) anchorPoint.getY(),\n                    position.getLabelAnchor(), (float) anchorPoint.getX(),\n                    (float) anchorPoint.getY(), position.getAngle());\n            if (plotState !\u003d null \u0026\u0026 plotState.getOwner() !\u003d null) {\n                EntityCollection entities \u003d plotState.getOwner()\n                        .getEntityCollection();\n                if (entities !\u003d null) {\n                    String tooltip \u003d getCategoryLabelToolTip(\n                            tick.getCategory());\n                    String url \u003d getCategoryLabelURL(tick.getCategory());\n                    entities.add(new CategoryLabelEntity(tick.getCategory(),\n                            bounds, tooltip, url));\n                }\n            }\n            categoryIndex++;\n        }\n\n        if (edge.equals(RectangleEdge.TOP)) {\n            double h \u003d state.getMax() + this.categoryLabelPositionOffset;\n            state.cursorUp(h);\n        }\n        else if (edge.equals(RectangleEdge.BOTTOM)) {\n            double h \u003d state.getMax() + this.categoryLabelPositionOffset;\n            state.cursorDown(h);\n        }\n        else if (edge \u003d\u003d RectangleEdge.LEFT) {\n            double w \u003d state.getMax() + this.categoryLabelPositionOffset;\n            state.cursorLeft(w);\n        }\n        else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n            double w \u003d state.getMax() + this.categoryLabelPositionOffset;\n            state.cursorRight(w);\n        }\n        return state;\n    }\n\n    /**\n     * Creates a temporary list of ticks that can be used when drawing the axis.\n     *\n     * @param g2  the graphics device (used to get font measurements).\n     * @param state  the axis state.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the location of the axis.\n     *\n     * @return A list of ticks.\n     */\n    @Override\n    public List refreshTicks(Graphics2D g2, AxisState state, \n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        List ticks \u003d new java.util.ArrayList(); // FIXME generics\n\n        // sanity check for data area...\n        if (dataArea.getHeight() \u003c\u003d 0.0 || dataArea.getWidth() \u003c 0.0) {\n            return ticks;\n        }\n\n        CategoryPlot plot \u003d (CategoryPlot) getPlot();\n        List categories \u003d plot.getCategoriesForAxis(this);\n        double max \u003d 0.0;\n\n        if (categories !\u003d null) {\n            CategoryLabelPosition position\n                    \u003d this.categoryLabelPositions.getLabelPosition(edge);\n            float r \u003d this.maximumCategoryLabelWidthRatio;\n            if (r \u003c\u003d 0.0) {\n                r \u003d position.getWidthRatio();\n            }\n\n            float l;\n            if (position.getWidthType() \u003d\u003d CategoryLabelWidthType.CATEGORY) {\n                l \u003d (float) calculateCategorySize(categories.size(), dataArea,\n                        edge);\n            }\n            else {\n                if (RectangleEdge.isLeftOrRight(edge)) {\n                    l \u003d (float) dataArea.getWidth();\n                }\n                else {\n                    l \u003d (float) dataArea.getHeight();\n                }\n            }\n            int categoryIndex \u003d 0;\n            for (Object o : categories) {\n                Comparable category \u003d (Comparable) o;\n                g2.setFont(getTickLabelFont(category));\n                TextBlock label \u003d createLabel(category, l * r, edge, g2);\n                if (edge \u003d\u003d RectangleEdge.TOP || edge \u003d\u003d RectangleEdge.BOTTOM) {\n                    max \u003d Math.max(max, calculateCategoryLabelHeight(label,\n                            position, getTickLabelInsets(), g2));\n                } else if (edge \u003d\u003d RectangleEdge.LEFT\n                        || edge \u003d\u003d RectangleEdge.RIGHT) {\n                    max \u003d Math.max(max, calculateCategoryLabelWidth(label,\n                            position, getTickLabelInsets(), g2));\n                }\n                Tick tick \u003d new CategoryTick(category, label,\n                        position.getLabelAnchor(),\n                        position.getRotationAnchor(), position.getAngle());\n                ticks.add(tick);\n                categoryIndex \u003d categoryIndex + 1;\n            }\n        }\n        state.setMax(max);\n        return ticks;\n\n    }\n\n    /**\n     * Draws the tick marks.\n     * \n     * @param g2  the graphics target.\n     * @param cursor  the cursor position (an offset when drawing multiple axes)\n     * @param dataArea  the area for plotting the data.\n     * @param edge  the location of the axis.\n     * @param state  the axis state.\n     */\n    public void drawTickMarks(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state) {\n\n        Plot p \u003d getPlot();\n        if (p \u003d\u003d null) {\n            return;\n        }\n        CategoryPlot plot \u003d (CategoryPlot) p;\n        double il \u003d getTickMarkInsideLength();\n        double ol \u003d getTickMarkOutsideLength();\n        Line2D line \u003d new Line2D.Double();\n        List\u003cComparable\u003e categories \u003d plot.getCategoriesForAxis(this);\n        g2.setPaint(getTickMarkPaint());\n        g2.setStroke(getTickMarkStroke());\n        Object saved \u003d g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, \n                RenderingHints.VALUE_STROKE_NORMALIZE);\n        if (edge.equals(RectangleEdge.TOP)) {\n            for (Comparable category : categories) {\n                double x \u003d getCategoryMiddle(category, categories, dataArea, edge);\n                line.setLine(x, cursor, x, cursor + il);\n                g2.draw(line);\n                line.setLine(x, cursor, x, cursor - ol);\n                g2.draw(line);\n            }\n            state.cursorUp(ol);\n        } else if (edge.equals(RectangleEdge.BOTTOM)) {\n            for (Comparable category : categories) {\n                double x \u003d getCategoryMiddle(category, categories, dataArea, edge);\n                line.setLine(x, cursor, x, cursor - il);\n                g2.draw(line);\n                line.setLine(x, cursor, x, cursor + ol);\n                g2.draw(line);\n            }\n            state.cursorDown(ol);\n        } else if (edge.equals(RectangleEdge.LEFT)) {\n            for (Comparable category : categories) {\n                double y \u003d getCategoryMiddle(category, categories, dataArea, edge);\n                line.setLine(cursor, y, cursor + il, y);\n                g2.draw(line);\n                line.setLine(cursor, y, cursor - ol, y);\n                g2.draw(line);\n            }\n            state.cursorLeft(ol);\n        } else if (edge.equals(RectangleEdge.RIGHT)) {\n            for (Comparable category : categories) {\n                double y \u003d getCategoryMiddle(category, categories, dataArea, edge);\n                line.setLine(cursor, y, cursor - il, y);\n                g2.draw(line);\n                line.setLine(cursor, y, cursor + ol, y);\n                g2.draw(line);\n            }\n            state.cursorRight(ol);\n        }\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, saved);\n    }\n\n    /**\n     * Creates a label.\n     *\n     * @param category  the category.\n     * @param width  the available width.\n     * @param edge  the edge on which the axis appears.\n     * @param g2  the graphics device.\n     *\n     * @return A label.\n     */\n    protected TextBlock createLabel(Comparable category, float width,\n            RectangleEdge edge, Graphics2D g2) {\n        TextBlock label \u003d TextUtils.createTextBlock(category.toString(),\n                getTickLabelFont(category), getTickLabelPaint(category), width,\n                this.maximumCategoryLabelLines, new G2TextMeasurer(g2));\n        return label;\n    }\n\n    /**\n     * Calculates the width of a category label when rendered.\n     *\n     * @param label  the text block ({@code null} not permitted).\n     * @param position  the position.\n     * @param insets  the label insets.\n     * @param g2  the graphics device.\n     *\n     * @return The width.\n     */\n    protected double calculateCategoryLabelWidth(TextBlock label, \n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2) {\n        Size2D size \u003d label.calculateDimensions(g2);\n        Rectangle2D box \u003d new Rectangle2D.Double(0.0, 0.0, size.getWidth(),\n                size.getHeight());\n        Shape rotatedBox \u003d ShapeUtils.rotateShape(box, position.getAngle(),\n                0.0f, 0.0f);\n        double w \u003d rotatedBox.getBounds2D().getWidth() + insets.getLeft()\n                + insets.getRight();\n        return w;\n    }\n\n    /**\n     * Calculates the height of a category label when rendered.\n     *\n     * @param block  the text block ({@code null} not permitted).\n     * @param position  the label position ({@code null} not permitted).\n     * @param insets  the label insets ({@code null} not permitted).\n     * @param g2  the graphics device ({@code null} not permitted).\n     *\n     * @return The height.\n     */\n    protected double calculateCategoryLabelHeight(TextBlock block,\n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2) {\n        Size2D size \u003d block.calculateDimensions(g2);\n        Rectangle2D box \u003d new Rectangle2D.Double(0.0, 0.0, size.getWidth(),\n                size.getHeight());\n        Shape rotatedBox \u003d ShapeUtils.rotateShape(box, position.getAngle(),\n                0.0f, 0.0f);\n        double h \u003d rotatedBox.getBounds2D().getHeight()\n                   + insets.getTop() + insets.getBottom();\n        return h;\n    }\n\n    /**\n     * Creates a clone of the axis.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if some component of the axis does\n     *         not support cloning.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        CategoryAxis clone \u003d (CategoryAxis) super.clone();\n        clone.tickLabelFontMap \u003d new HashMap\u003c\u003e(this.tickLabelFontMap);\n        clone.tickLabelPaintMap \u003d new HashMap\u003c\u003e(this.tickLabelPaintMap);\n        clone.categoryLabelToolTips \u003d new HashMap\u003c\u003e(this.categoryLabelToolTips);\n        clone.categoryLabelURLs \u003d new HashMap\u003c\u003e(this.categoryLabelToolTips);\n        return clone;\n    }\n\n    /**\n     * Tests this axis for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryAxis)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        CategoryAxis that \u003d (CategoryAxis) obj;\n        if (that.lowerMargin !\u003d this.lowerMargin) {\n            return false;\n        }\n        if (that.upperMargin !\u003d this.upperMargin) {\n            return false;\n        }\n        if (that.categoryMargin !\u003d this.categoryMargin) {\n            return false;\n        }\n        if (that.maximumCategoryLabelWidthRatio\n                !\u003d this.maximumCategoryLabelWidthRatio) {\n            return false;\n        }\n        if (that.categoryLabelPositionOffset\n                !\u003d this.categoryLabelPositionOffset) {\n            return false;\n        }\n        if (!Objects.equals(that.categoryLabelPositions, this.categoryLabelPositions)) {\n            return false;\n        }\n        if (!Objects.equals(that.categoryLabelToolTips, this.categoryLabelToolTips)) {\n            return false;\n        }\n        if (!Objects.equals(this.categoryLabelURLs, that.categoryLabelURLs)) {\n            return false;\n        }\n        if (!Objects.equals(this.tickLabelFontMap, that.tickLabelFontMap)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.tickLabelPaintMap, that.tickLabelPaintMap)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this object.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        writePaintMap(this.tickLabelPaintMap, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.tickLabelPaintMap \u003d readPaintMap(stream);\n    }\n\n    /**\n     * Reads a {@code Map} of ({@code Comparable}, {@code Paint})\n     * elements from a stream.\n     *\n     * @param in  the input stream.\n     *\n     * @return The map.\n     *\n     * @throws IOException\n     * @throws ClassNotFoundException\n     *\n     * @see #writePaintMap(Map, ObjectOutputStream)\n     */\n    private Map readPaintMap(ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n        boolean isNull \u003d in.readBoolean();\n        if (isNull) {\n            return null;\n        }\n        Map result \u003d new HashMap();\n        int count \u003d in.readInt();\n        for (int i \u003d 0; i \u003c count; i++) {\n            Comparable category \u003d (Comparable) in.readObject();\n            Paint paint \u003d SerialUtils.readPaint(in);\n            result.put(category, paint);\n        }\n        return result;\n    }\n\n    /**\n     * Writes a map of ({@code Comparable}, {@code Paint})\n     * elements to a stream.\n     *\n     * @param map  the map ({@code null} permitted).\n     *\n     * @param out\n     * @throws IOException\n     *\n     * @see #readPaintMap(ObjectInputStream)\n     */\n    private void writePaintMap(Map map, ObjectOutputStream out)\n            throws IOException {\n        if (map \u003d\u003d null) {\n            out.writeBoolean(true);\n        }\n        else {\n            out.writeBoolean(false);\n            Set keys \u003d map.keySet();\n            int count \u003d keys.size();\n            out.writeInt(count);\n            for (Object o : keys) {\n                Comparable key \u003d (Comparable) o;\n                out.writeObject(key);\n                SerialUtils.writePaint((Paint) map.get(key), out);\n            }\n        }\n    }\n\n}","methodCount":53,"staticMethodCount":0,"instanceMethodCount":53,"classLoc":1328,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":3,"candidates":[{"lineStart":1108,"lineEnd":1172,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method drawTickMarks to class AxisState","description":"Move method drawTickMarks to org.jfree.chart.axis.AxisState\nRationale: The `drawTickMarks` method is intimately tied to the state and movement of the axis cursor, which is managed by the `AxisState` class. Specifically, the method calls `cursorUp`, `cursorDown`, `cursorLeft`, and `cursorRight` methods on the `AxisState` object, indicating that the primary operations performed by `drawTickMarks` are directly related to the axis state. Moving this method to `AxisState` encapsulates these related functionalities, leading to more cohesive and maintainable code.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false,"userRating":"Very Helpful"},{"lineStart":1214,"lineEnd":1234,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method calculateCategoryLabelHeight to class TextBlock","description":"Move method calculateCategoryLabelHeight to org.jfree.chart.text.TextBlock\nRationale: The method `calculateCategoryLabelHeight` relies most heavily on the `TextBlock` class, as it calls `block.calculateDimensions(g2)` to perform a significant part of its function. Moving this method to `TextBlock` will centralize functionality related to text block dimension calculations in one place, providing better cohesion and potentially simplifying future maintenance.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false},{"lineStart":668,"lineEnd":701,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method getCategorySeriesMiddle to class CategoryDataset","description":"Move method getCategorySeriesMiddle to org.jfree.data.category.CategoryDataset\nRationale: The method `getCategorySeriesMiddle` relies heavily on the structure and indices of the `CategoryDataset` class. It references dataset-specific methods and indices like `getColumnIndex`, `getColumnCount`, `getRowIndex`, and `getRowCount`, which are specific to datasets and inherently tied to their layout and content. Therefore, `CategoryDataset` is the most suitable class for this method to ensure data cohesion and maintain a clear, logical structure.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false}]},"userSelectionTelemetryData":{"lineStart":1108,"lineEnd":1172,"functionSize":65,"positionInHostFunction":1032,"selectedCandidateIndex":0,"candidateType":"AS_IS","elementsType":[{"elementType":"METHOD","quantity":1}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":185716}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":36924},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"getCategorySeriesMiddle","method_signature":"public getCategorySeriesMiddle(Comparable category,\n            Comparable seriesKey, CategoryDataset dataset, double itemMargin,\n            Rectangle2D area, RectangleEdge edge)","target_class":"","rationale":""},{"method_name":"drawCategoryLabels","method_signature":"protected drawCategoryLabels(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state,\n            PlotRenderingInfo plotState)","target_class":"","rationale":""},{"method_name":"drawTickMarks","method_signature":"public drawTickMarks(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state)","target_class":"","rationale":""},{"method_name":"calculateCategoryLabelWidth","method_signature":"protected calculateCategoryLabelWidth(TextBlock label, \n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""},{"method_name":"calculateCategoryLabelHeight","method_signature":"protected calculateCategoryLabelHeight(TextBlock block,\n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"drawTickMarks","method_signature":"public drawTickMarks(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state)","target_class":"","rationale":""},{"method_name":"drawCategoryLabels","method_signature":"protected drawCategoryLabels(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state,\n            PlotRenderingInfo plotState)","target_class":"","rationale":""},{"method_name":"calculateCategoryLabelHeight","method_signature":"protected calculateCategoryLabelHeight(TextBlock block,\n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""},{"method_name":"getCategorySeriesMiddle","method_signature":"public getCategorySeriesMiddle(Comparable category,\n            Comparable seriesKey, CategoryDataset dataset, double itemMargin,\n            Rectangle2D area, RectangleEdge edge)","target_class":"","rationale":""},{"method_name":"calculateCategoryLabelWidth","method_signature":"protected calculateCategoryLabelWidth(TextBlock label, \n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public drawTickMarks(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state)":{"first":{"method_name":"drawTickMarks","method_signature":"public drawTickMarks(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state)","target_class":"","rationale":""},"second":0.5957687788428276},"protected drawCategoryLabels(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state,\n            PlotRenderingInfo plotState)":{"first":{"method_name":"drawCategoryLabels","method_signature":"protected drawCategoryLabels(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state,\n            PlotRenderingInfo plotState)","target_class":"","rationale":""},"second":0.5990457865804262},"protected calculateCategoryLabelHeight(TextBlock block,\n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)":{"first":{"method_name":"calculateCategoryLabelHeight","method_signature":"protected calculateCategoryLabelHeight(TextBlock block,\n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""},"second":0.7492838377176047},"public getCategorySeriesMiddle(Comparable category,\n            Comparable seriesKey, CategoryDataset dataset, double itemMargin,\n            Rectangle2D area, RectangleEdge edge)":{"first":{"method_name":"getCategorySeriesMiddle","method_signature":"public getCategorySeriesMiddle(Comparable category,\n            Comparable seriesKey, CategoryDataset dataset, double itemMargin,\n            Rectangle2D area, RectangleEdge edge)","target_class":"","rationale":""},"second":0.7869275000000587},"protected calculateCategoryLabelWidth(TextBlock label, \n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)":{"first":{"method_name":"calculateCategoryLabelWidth","method_signature":"protected calculateCategoryLabelWidth(TextBlock label, \n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""},"second":0.8052308864395809}},"targetClassMap":{"drawTickMarks":{"target_classes":[{"class_name":"RectangleEdge","similarity_score":0.361986331459829},{"class_name":"AxisState","similarity_score":0.521351834157547},{"class_name":"CategoryLabelPositions","similarity_score":0.4240434314852193}],"target_classes_sorted_by_llm":["AxisState","RectangleEdge","CategoryLabelPositions"],"llm_response_time":8529,"similarity_computation_time":3,"similarity_metric":"cosine"},"drawCategoryLabels":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5475,"similarity_computation_time":0,"similarity_metric":"cosine"},"calculateCategoryLabelHeight":{"target_classes":[{"class_name":"TextBlock","similarity_score":0.7011913103331406},{"class_name":"CategoryLabelPosition","similarity_score":0.7361336689221182},{"class_name":"RectangleInsets","similarity_score":0.6933703123527621},{"class_name":"CategoryLabelPositions","similarity_score":0.6654201622829171}],"target_classes_sorted_by_llm":["TextBlock","CategoryLabelPosition","RectangleInsets"],"llm_response_time":6831,"similarity_computation_time":3,"similarity_metric":"cosine"},"getCategorySeriesMiddle":{"target_classes":[{"class_name":"CategoryDataset","similarity_score":0.4133068570297462},{"class_name":"RectangleEdge","similarity_score":0.5433384646359788},{"class_name":"CategoryLabelPositions","similarity_score":0.6277228465829806}],"target_classes_sorted_by_llm":["CategoryDataset","CategoryLabelPositions","RectangleEdge"],"llm_response_time":6229,"similarity_computation_time":1,"similarity_metric":"cosine"},"calculateCategoryLabelWidth":{"target_classes":[{"class_name":"TextBlock","similarity_score":0.7646439778966989},{"class_name":"CategoryLabelPosition","similarity_score":0.7621550089818219},{"class_name":"RectangleInsets","similarity_score":0.7712776634736744},{"class_name":"CategoryLabelPositions","similarity_score":0.6868161123688303}],"target_classes_sorted_by_llm":["TextBlock","CategoryLabelPosition","RectangleInsets"],"llm_response_time":9685,"similarity_computation_time":3,"similarity_metric":"cosine"}}}
{"id":"680412e2-96f1-4c8b-859b-275564511884","hostFunctionTelemetryData":{"hostFunctionSize":211,"lineStart":45,"lineEnd":255,"bodyLineStart":45,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/axis/CategoryLabelPosition.java","sourceCode":"/**\n * The attributes that control the position of the labels for the categories on\n * a {@link CategoryAxis}. Instances of this class are immutable and other\n * JFreeChart classes rely upon this.\n */\npublic class CategoryLabelPosition implements Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d 5168681143844183864L;\n\n    /** The category anchor point. */\n    private RectangleAnchor categoryAnchor;\n\n    /** The text block anchor. */\n    private TextBlockAnchor labelAnchor;\n\n    /** The rotation anchor. */\n    private TextAnchor rotationAnchor;\n\n    /** The rotation angle (in radians). */\n    private double angle;\n\n    /** The width calculation type. */\n    private CategoryLabelWidthType widthType;\n\n    /**\n     * The maximum label width as a percentage of the category space or the\n     * range space.\n     */\n    private float widthRatio;\n\n    /**\n     * Creates a new position record with default settings.\n     */\n    public CategoryLabelPosition() {\n        this(RectangleAnchor.CENTER, TextBlockAnchor.BOTTOM_CENTER,\n                TextAnchor.CENTER, 0.0, CategoryLabelWidthType.CATEGORY, 0.95f);\n    }\n\n    /**\n     * Creates a new category label position record.\n     *\n     * @param categoryAnchor  the category anchor ({@code null} not\n     *                        permitted).\n     * @param labelAnchor  the label anchor ({@code null} not permitted).\n     */\n    public CategoryLabelPosition(RectangleAnchor categoryAnchor,\n                                 TextBlockAnchor labelAnchor) {\n        // argument checking delegated...\n        this(categoryAnchor, labelAnchor, TextAnchor.CENTER, 0.0,\n                CategoryLabelWidthType.CATEGORY, 0.95f);\n    }\n\n    /**\n     * Creates a new category label position record.\n     *\n     * @param categoryAnchor  the category anchor ({@code null} not\n     *                        permitted).\n     * @param labelAnchor  the label anchor ({@code null} not permitted).\n     * @param widthType  the width type ({@code null} not permitted).\n     * @param widthRatio  the maximum label width as a percentage (of the\n     *                    category space or the range space).\n     */\n    public CategoryLabelPosition(RectangleAnchor categoryAnchor,\n            TextBlockAnchor labelAnchor, CategoryLabelWidthType widthType,\n            float widthRatio) {\n        // argument checking delegated...\n        this(categoryAnchor, labelAnchor, TextAnchor.CENTER, 0.0, widthType,\n                widthRatio);\n    }\n\n    /**\n     * Creates a new position record.  The item label anchor is a point\n     * relative to the data item (dot, bar or other visual item) on a chart.\n     * The item label is aligned by aligning the text anchor with the item\n     * label anchor.\n     *\n     * @param categoryAnchor  the category anchor ({@code null} not\n     *                        permitted).\n     * @param labelAnchor  the label anchor ({@code null} not permitted).\n     * @param rotationAnchor  the rotation anchor ({@code null} not\n     *                        permitted).\n     * @param angle  the rotation angle ({@code null} not permitted).\n     * @param widthType  the width type ({@code null} not permitted).\n     * @param widthRatio  the maximum label width as a percentage (of the\n     *                    category space or the range space).\n     */\n    public CategoryLabelPosition(RectangleAnchor categoryAnchor,\n            TextBlockAnchor labelAnchor, TextAnchor rotationAnchor, \n            double angle, CategoryLabelWidthType widthType, float widthRatio) {\n\n        Args.nullNotPermitted(categoryAnchor, \"categoryAnchor\");\n        Args.nullNotPermitted(labelAnchor, \"labelAnchor\");\n        Args.nullNotPermitted(rotationAnchor, \"rotationAnchor\");\n        Args.nullNotPermitted(widthType, \"widthType\");\n\n        this.categoryAnchor \u003d categoryAnchor;\n        this.labelAnchor \u003d labelAnchor;\n        this.rotationAnchor \u003d rotationAnchor;\n        this.angle \u003d angle;\n        this.widthType \u003d widthType;\n        this.widthRatio \u003d widthRatio;\n\n    }\n\n    /**\n     * Returns the item label anchor.\n     *\n     * @return The item label anchor (never {@code null}).\n     */\n    public RectangleAnchor getCategoryAnchor() {\n        return this.categoryAnchor;\n    }\n\n    /**\n     * Returns the text block anchor.\n     *\n     * @return The text block anchor (never {@code null}).\n     */\n    public TextBlockAnchor getLabelAnchor() {\n        return this.labelAnchor;\n    }\n\n    /**\n     * Returns the rotation anchor point.\n     *\n     * @return The rotation anchor point (never {@code null}).\n     */\n    public TextAnchor getRotationAnchor() {\n        return this.rotationAnchor;\n    }\n\n    /**\n     * Returns the angle of rotation for the label.\n     *\n     * @return The angle (in radians).\n     */\n    public double getAngle() {\n        return this.angle;\n    }\n\n    /**\n     * Returns the width calculation type.\n     *\n     * @return The width calculation type (never {@code null}).\n     */\n    public CategoryLabelWidthType getWidthType() {\n        return this.widthType;\n    }\n\n    /**\n     * Returns the ratio used to calculate the maximum category label width.\n     *\n     * @return The ratio.\n     */\n    public float getWidthRatio() {\n        return this.widthRatio;\n    }\n\n    /**\n     * Tests this instance for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryLabelPosition)) {\n            return false;\n        }\n        CategoryLabelPosition that \u003d (CategoryLabelPosition) obj;\n        if (!this.categoryAnchor.equals(that.categoryAnchor)) {\n            return false;\n        }\n        if (!this.labelAnchor.equals(that.labelAnchor)) {\n            return false;\n        }\n        if (!this.rotationAnchor.equals(that.rotationAnchor)) {\n            return false;\n        }\n        if (this.angle !\u003d that.angle) {\n            return false;\n        }\n        if (this.widthType !\u003d that.widthType) {\n            return false;\n        }\n        if (this.widthRatio !\u003d that.widthRatio) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this object.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d 19;\n        result \u003d 37 * result + this.categoryAnchor.hashCode();\n        result \u003d 37 * result + this.labelAnchor.hashCode();\n        result \u003d 37 * result + this.rotationAnchor.hashCode();\n        return result;\n    }\n\n}","methodCount":12,"staticMethodCount":0,"instanceMethodCount":12,"classLoc":211,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"ef0fd689-82a7-498a-b7b1-4773af395988","hostFunctionTelemetryData":{"hostFunctionSize":355,"lineStart":47,"lineEnd":401,"bodyLineStart":47,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/axis/CategoryLabelPositions.java","sourceCode":"/**\n * Records the label positions for a category axis.  Instances of this class\n * are immutable.\n */\npublic class CategoryLabelPositions implements Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -8999557901920364580L;\n\n    /** STANDARD category label positions. */\n    public static final CategoryLabelPositions\n        STANDARD \u003d new CategoryLabelPositions(\n            new CategoryLabelPosition(\n                RectangleAnchor.BOTTOM, TextBlockAnchor.BOTTOM_CENTER), // TOP\n            new CategoryLabelPosition(\n                RectangleAnchor.TOP, TextBlockAnchor.TOP_CENTER), // BOTTOM\n            new CategoryLabelPosition(\n                RectangleAnchor.RIGHT, TextBlockAnchor.CENTER_RIGHT,\n                CategoryLabelWidthType.RANGE, 0.30f), // LEFT\n            new CategoryLabelPosition(\n                RectangleAnchor.LEFT, TextBlockAnchor.CENTER_LEFT,\n                CategoryLabelWidthType.RANGE, 0.30f) // RIGHT\n        );\n\n    /** UP_90 category label positions. */\n    public static final CategoryLabelPositions\n        UP_90 \u003d new CategoryLabelPositions(\n            new CategoryLabelPosition(\n                RectangleAnchor.BOTTOM, TextBlockAnchor.CENTER_LEFT,\n                TextAnchor.CENTER_LEFT, -Math.PI / 2.0,\n                CategoryLabelWidthType.RANGE, 0.30f), // TOP\n            new CategoryLabelPosition(\n                RectangleAnchor.TOP, TextBlockAnchor.CENTER_RIGHT,\n                TextAnchor.CENTER_RIGHT, -Math.PI / 2.0,\n                CategoryLabelWidthType.RANGE, 0.30f), // BOTTOM\n            new CategoryLabelPosition(\n                RectangleAnchor.RIGHT, TextBlockAnchor.BOTTOM_CENTER,\n                TextAnchor.BOTTOM_CENTER, -Math.PI / 2.0,\n                CategoryLabelWidthType.CATEGORY, 0.9f), // LEFT\n            new CategoryLabelPosition(\n                RectangleAnchor.LEFT, TextBlockAnchor.TOP_CENTER,\n                TextAnchor.TOP_CENTER, -Math.PI / 2.0,\n                CategoryLabelWidthType.CATEGORY, 0.90f) // RIGHT\n        );\n\n    /** DOWN_90 category label positions. */\n    public static final CategoryLabelPositions\n        DOWN_90 \u003d new CategoryLabelPositions(\n            new CategoryLabelPosition(\n                RectangleAnchor.BOTTOM, TextBlockAnchor.CENTER_RIGHT,\n                TextAnchor.CENTER_RIGHT, Math.PI / 2.0,\n                CategoryLabelWidthType.RANGE, 0.30f), // TOP\n            new CategoryLabelPosition(\n                RectangleAnchor.TOP, TextBlockAnchor.CENTER_LEFT,\n                TextAnchor.CENTER_LEFT, Math.PI / 2.0,\n                CategoryLabelWidthType.RANGE, 0.30f), // BOTTOM\n            new CategoryLabelPosition(\n                RectangleAnchor.RIGHT, TextBlockAnchor.TOP_CENTER,\n                TextAnchor.TOP_CENTER, Math.PI / 2.0,\n                CategoryLabelWidthType.CATEGORY, 0.90f), // LEFT\n            new CategoryLabelPosition(\n                RectangleAnchor.LEFT, TextBlockAnchor.BOTTOM_CENTER,\n                TextAnchor.BOTTOM_CENTER, Math.PI / 2.0,\n                CategoryLabelWidthType.CATEGORY, 0.90f) // RIGHT\n        );\n\n    /** UP_45 category label positions. */\n    public static final CategoryLabelPositions UP_45\n        \u003d createUpRotationLabelPositions(Math.PI / 4.0);\n\n    /** DOWN_45 category label positions. */\n    public static final CategoryLabelPositions DOWN_45\n        \u003d createDownRotationLabelPositions(Math.PI / 4.0);\n\n    /**\n     * Creates a new instance where the category labels angled upwards by the\n     * specified amount.\n     *\n     * @param angle  the rotation angle (should be \u0026lt; Math.PI / 2.0).\n     *\n     * @return A category label position specification.\n     */\n    public static CategoryLabelPositions createUpRotationLabelPositions(\n            double angle) {\n        return new CategoryLabelPositions(\n            new CategoryLabelPosition(\n                RectangleAnchor.BOTTOM, TextBlockAnchor.BOTTOM_LEFT,\n                TextAnchor.BOTTOM_LEFT, -angle,\n                CategoryLabelWidthType.RANGE, 0.50f), // TOP\n            new CategoryLabelPosition(\n                RectangleAnchor.TOP, TextBlockAnchor.TOP_RIGHT,\n                TextAnchor.TOP_RIGHT, -angle,\n                CategoryLabelWidthType.RANGE, 0.50f), // BOTTOM\n            new CategoryLabelPosition(\n                RectangleAnchor.RIGHT, TextBlockAnchor.BOTTOM_RIGHT,\n                TextAnchor.BOTTOM_RIGHT, -angle,\n                CategoryLabelWidthType.RANGE, 0.50f), // LEFT\n            new CategoryLabelPosition(\n                RectangleAnchor.LEFT, TextBlockAnchor.TOP_LEFT,\n                TextAnchor.TOP_LEFT, -angle,\n                CategoryLabelWidthType.RANGE, 0.50f) // RIGHT\n        );\n    }\n\n    /**\n     * Creates a new instance where the category labels angled downwards by the\n     * specified amount.\n     *\n     * @param angle  the rotation angle (should be \u0026lt; Math.PI / 2.0).\n     *\n     * @return A category label position specification.\n     */\n    public static CategoryLabelPositions createDownRotationLabelPositions(\n            double angle) {\n        return new CategoryLabelPositions(\n            new CategoryLabelPosition(\n                RectangleAnchor.BOTTOM, TextBlockAnchor.BOTTOM_RIGHT,\n                TextAnchor.BOTTOM_RIGHT, angle,\n                CategoryLabelWidthType.RANGE, 0.50f), // TOP\n            new CategoryLabelPosition(\n                RectangleAnchor.TOP, TextBlockAnchor.TOP_LEFT,\n                TextAnchor.TOP_LEFT, angle,\n                CategoryLabelWidthType.RANGE, 0.50f), // BOTTOM\n            new CategoryLabelPosition(\n                RectangleAnchor.RIGHT, TextBlockAnchor.TOP_RIGHT,\n                TextAnchor.TOP_RIGHT, angle,\n                CategoryLabelWidthType.RANGE, 0.50f), // LEFT\n            new CategoryLabelPosition(\n                RectangleAnchor.LEFT, TextBlockAnchor.BOTTOM_LEFT,\n                TextAnchor.BOTTOM_LEFT, angle,\n                CategoryLabelWidthType.RANGE, 0.50f) // RIGHT\n        );\n    }\n\n    /**\n     * The label positioning details used when an axis is at the top of a\n     * chart.\n     */\n    private final CategoryLabelPosition positionForAxisAtTop;\n\n    /**\n     * The label positioning details used when an axis is at the bottom of a\n     * chart.\n     */\n    private final CategoryLabelPosition positionForAxisAtBottom;\n\n    /**\n     * The label positioning details used when an axis is at the left of a\n     * chart.\n     */\n    private final CategoryLabelPosition positionForAxisAtLeft;\n\n    /**\n     * The label positioning details used when an axis is at the right of a\n     * chart.\n     */\n    private final CategoryLabelPosition positionForAxisAtRight;\n\n    /**\n     * Default constructor.\n     */\n    public CategoryLabelPositions() {\n        this.positionForAxisAtTop \u003d new CategoryLabelPosition();\n        this.positionForAxisAtBottom \u003d new CategoryLabelPosition();\n        this.positionForAxisAtLeft \u003d new CategoryLabelPosition();\n        this.positionForAxisAtRight \u003d new CategoryLabelPosition();\n    }\n\n    /**\n     * Creates a new position specification.\n     *\n     * @param top  the label position info used when an axis is at the top\n     *             ({@code null} not permitted).\n     * @param bottom  the label position info used when an axis is at the\n     *                bottom ({@code null} not permitted).\n     * @param left  the label position info used when an axis is at the left\n     *              ({@code null} not permitted).\n     * @param right  the label position info used when an axis is at the right\n     *               ({@code null} not permitted).\n     */\n    public CategoryLabelPositions(CategoryLabelPosition top,\n            CategoryLabelPosition bottom, CategoryLabelPosition left,\n            CategoryLabelPosition right) {\n\n        Args.nullNotPermitted(top, \"top\");\n        Args.nullNotPermitted(bottom, \"bottom\");\n        Args.nullNotPermitted(left, \"left\");\n        Args.nullNotPermitted(right, \"right\");\n\n        this.positionForAxisAtTop \u003d top;\n        this.positionForAxisAtBottom \u003d bottom;\n        this.positionForAxisAtLeft \u003d left;\n        this.positionForAxisAtRight \u003d right;\n    }\n\n    /**\n     * Returns the category label position specification for an axis at the\n     * given location.\n     *\n     * @param edge  the axis location.\n     *\n     * @return The category label position specification.\n     */\n    public CategoryLabelPosition getLabelPosition(RectangleEdge edge) {\n        CategoryLabelPosition result \u003d null;\n        if (edge \u003d\u003d RectangleEdge.TOP) {\n            result \u003d this.positionForAxisAtTop;\n        }\n        else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n            result \u003d this.positionForAxisAtBottom;\n        }\n        else if (edge \u003d\u003d RectangleEdge.LEFT) {\n            result \u003d this.positionForAxisAtLeft;\n        }\n        else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n            result \u003d this.positionForAxisAtRight;\n        }\n        return result;\n    }\n\n    /**\n     * Returns a new instance based on an existing instance but with the top\n     * position changed.\n     *\n     * @param base  the base ({@code null} not permitted).\n     * @param top  the top position ({@code null} not permitted).\n     *\n     * @return A new instance (never {@code null}).\n     */\n    public static CategoryLabelPositions replaceTopPosition(\n            CategoryLabelPositions base, CategoryLabelPosition top) {\n\n        Args.nullNotPermitted(base, \"base\");\n        Args.nullNotPermitted(top, \"top\");\n\n        return new CategoryLabelPositions(top,\n            base.getLabelPosition(RectangleEdge.BOTTOM),\n            base.getLabelPosition(RectangleEdge.LEFT),\n            base.getLabelPosition(RectangleEdge.RIGHT));\n    }\n\n    /**\n     * Returns a new instance based on an existing instance but with the bottom\n     * position changed.\n     *\n     * @param base  the base ({@code null} not permitted).\n     * @param bottom  the bottom position ({@code null} not permitted).\n     *\n     * @return A new instance (never {@code null}).\n     */\n    public static CategoryLabelPositions replaceBottomPosition(\n            CategoryLabelPositions base, CategoryLabelPosition bottom) {\n\n        Args.nullNotPermitted(base, \"base\");\n        Args.nullNotPermitted(bottom, \"bottom\");\n\n        return new CategoryLabelPositions(\n            base.getLabelPosition(RectangleEdge.TOP),\n            bottom,\n            base.getLabelPosition(RectangleEdge.LEFT),\n            base.getLabelPosition(RectangleEdge.RIGHT));\n    }\n\n    /**\n     * Returns a new instance based on an existing instance but with the left\n     * position changed.\n     *\n     * @param base  the base ({@code null} not permitted).\n     * @param left  the left position ({@code null} not permitted).\n     *\n     * @return A new instance (never {@code null}).\n     */\n    public static CategoryLabelPositions replaceLeftPosition(\n            CategoryLabelPositions base, CategoryLabelPosition left) {\n\n        Args.nullNotPermitted(base, \"base\");\n        Args.nullNotPermitted(left, \"left\");\n\n        return new CategoryLabelPositions(\n            base.getLabelPosition(RectangleEdge.TOP),\n            base.getLabelPosition(RectangleEdge.BOTTOM),\n            left,\n            base.getLabelPosition(RectangleEdge.RIGHT));\n    }\n\n    /**\n     * Returns a new instance based on an existing instance but with the right\n     * position changed.\n     *\n     * @param base  the base ({@code null} not permitted).\n     * @param right  the right position ({@code null} not permitted).\n     *\n     * @return A new instance (never {@code null}).\n     */\n    public static CategoryLabelPositions replaceRightPosition(\n            CategoryLabelPositions base, CategoryLabelPosition right) {\n\n        Args.nullNotPermitted(base, \"base\");\n        Args.nullNotPermitted(right, \"right\");\n        return new CategoryLabelPositions(\n            base.getLabelPosition(RectangleEdge.TOP),\n            base.getLabelPosition(RectangleEdge.BOTTOM),\n            base.getLabelPosition(RectangleEdge.LEFT),\n            right);\n    }\n\n    /**\n     * Returns {@code true} if this object is equal to the specified\n     * object, and {@code false} otherwise.\n     *\n     * @param obj  the other object.\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (!(obj instanceof CategoryLabelPositions)) {\n            return false;\n        }\n\n        CategoryLabelPositions that \u003d (CategoryLabelPositions) obj;\n        if (!this.positionForAxisAtTop.equals(that.positionForAxisAtTop)) {\n            return false;\n        }\n        if (!this.positionForAxisAtBottom.equals(\n                that.positionForAxisAtBottom)) {\n            return false;\n        }\n        if (!this.positionForAxisAtLeft.equals(that.positionForAxisAtLeft)) {\n            return false;\n        }\n        if (!this.positionForAxisAtRight.equals(that.positionForAxisAtRight)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this object.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d 19;\n        result \u003d 37 * result + this.positionForAxisAtTop.hashCode();\n        result \u003d 37 * result + this.positionForAxisAtBottom.hashCode();\n        result \u003d 37 * result + this.positionForAxisAtLeft.hashCode();\n        result \u003d 37 * result + this.positionForAxisAtRight.hashCode();\n        return result;\n    }\n}","methodCount":11,"staticMethodCount":6,"instanceMethodCount":5,"classLoc":355,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":3,"candidates":[{"lineStart":266,"lineEnd":285,"refactoringType":"MyMoveStaticMethodRefactoring","refactoringInfo":"Move Static method replaceTopPosition to class CategoryLabelPosition","description":"move method replaceTopPosition to PsiClass:CategoryLabelPosition\nRationale: The method \u0027replaceTopPosition\u0027 is directly manipulating and returning instances of \u0027CategoryLabelPositions\u0027 and \u0027CategoryLabelPosition\u0027, which are closely related to the positioning of category labels in charts. The logic of replacing the top position fits well within the context and responsibilities of the \u0027CategoryLabelPosition\u0027 class, which manages label positions for categories on a chart.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Unhelpful"},{"lineStart":287,"lineEnd":307,"refactoringType":"MyMoveStaticMethodRefactoring","refactoringInfo":"Move Static method replaceBottomPosition to class CategoryLabelPosition","description":"move method replaceBottomPosition to PsiClass:CategoryLabelPosition\nRationale: The method `replaceBottomPosition` is designed to create a new `CategoryLabelPositions` instance with a different bottom position. It relies heavily on the structure and semantics of the `CategoryLabelPositions` and `CategoryLabelPosition`. This makes `CategoryLabelPosition` a suitable candidate class as it logically pertains to label positioning within a category axis, ensuring cohesion and maintainability while aligning with the natural domain it operates in.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false},{"lineStart":309,"lineEnd":329,"refactoringType":"MyMoveStaticMethodRefactoring","refactoringInfo":"Move Static method replaceLeftPosition to class CategoryLabelPosition","description":"move method replaceLeftPosition to PsiClass:CategoryLabelPosition\nRationale: The method `replaceLeftPosition` specifically deals with changing a left position within a collection of category label positions. The `CategoryLabelPosition` class is directly related to category labels and their positions, making it the most appropriate and cohesive place for this method. This method directly manipulates instances of `CategoryLabelPositions`, making `CategoryLabelPosition` the logical class to house this method to maintain encapsulation and keep relevant functionality grouped together.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":78593}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":35494},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"replaceTopPosition","method_signature":"public static replaceTopPosition(\n            CategoryLabelPositions base, CategoryLabelPosition top)","target_class":"","rationale":""},{"method_name":"replaceBottomPosition","method_signature":"public static replaceBottomPosition(\n            CategoryLabelPositions base, CategoryLabelPosition bottom)","target_class":"","rationale":""},{"method_name":"replaceLeftPosition","method_signature":"public static replaceLeftPosition(\n            CategoryLabelPositions base, CategoryLabelPosition left)","target_class":"","rationale":""},{"method_name":"replaceRightPosition","method_signature":"public static replaceRightPosition(\n            CategoryLabelPositions base, CategoryLabelPosition right)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"replaceTopPosition","method_signature":"public static replaceTopPosition(\n            CategoryLabelPositions base, CategoryLabelPosition top)","target_class":"","rationale":""},{"method_name":"replaceBottomPosition","method_signature":"public static replaceBottomPosition(\n            CategoryLabelPositions base, CategoryLabelPosition bottom)","target_class":"","rationale":""},{"method_name":"replaceLeftPosition","method_signature":"public static replaceLeftPosition(\n            CategoryLabelPositions base, CategoryLabelPosition left)","target_class":"","rationale":""},{"method_name":"replaceRightPosition","method_signature":"public static replaceRightPosition(\n            CategoryLabelPositions base, CategoryLabelPosition right)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public static replaceTopPosition(\n            CategoryLabelPositions base, CategoryLabelPosition top)":{"first":{"method_name":"replaceTopPosition","method_signature":"public static replaceTopPosition(\n            CategoryLabelPositions base, CategoryLabelPosition top)","target_class":"","rationale":""},"second":0.756707650856262},"public static replaceBottomPosition(\n            CategoryLabelPositions base, CategoryLabelPosition bottom)":{"first":{"method_name":"replaceBottomPosition","method_signature":"public static replaceBottomPosition(\n            CategoryLabelPositions base, CategoryLabelPosition bottom)","target_class":"","rationale":""},"second":0.7594985779589156},"public static replaceLeftPosition(\n            CategoryLabelPositions base, CategoryLabelPosition left)":{"first":{"method_name":"replaceLeftPosition","method_signature":"public static replaceLeftPosition(\n            CategoryLabelPositions base, CategoryLabelPosition left)","target_class":"","rationale":""},"second":0.7594985779589156},"public static replaceRightPosition(\n            CategoryLabelPositions base, CategoryLabelPosition right)":{"first":{"method_name":"replaceRightPosition","method_signature":"public static replaceRightPosition(\n            CategoryLabelPositions base, CategoryLabelPosition right)","target_class":"","rationale":""},"second":0.7594985779589156}},"targetClassMap":{"replaceTopPosition":{"target_classes":[{"class_name":"CloneUtils","similarity_score":0.5916444609061859},{"class_name":"LineUtils","similarity_score":0.38235372775473475},{"class_name":"RendererUtils","similarity_score":0.3728942744521448},{"class_name":"RendererXYPackageUtils","similarity_score":0.4498669229602721},{"class_name":"EncoderUtil","similarity_score":0.5282585894985207},{"class_name":"TestUtils","similarity_score":0.4559626604089598},{"class_name":"ExportUtils","similarity_score":0.6014267969747461},{"class_name":"HashUtils","similarity_score":0.6339401714756494},{"class_name":"ImageMapUtils","similarity_score":0.6670959477807669},{"class_name":"TextUtils","similarity_score":0.5897434603847396},{"class_name":"ShapeUtils","similarity_score":0.6722609954918499},{"class_name":"SerialUtils","similarity_score":0.5423013402084842},{"class_name":"AttrStringUtils","similarity_score":0.536178169775797},{"class_name":"UIUtils","similarity_score":0.6104007298602714},{"class_name":"ArrayUtils","similarity_score":0.47044636662741396},{"class_name":"PaintUtils","similarity_score":0.45077525068889446},{"class_name":"StringUtils","similarity_score":0.5782197896276667},{"class_name":"JSONUtils","similarity_score":0.5811690262487655},{"class_name":"DatasetUtils","similarity_score":0.5603905235142501},{"class_name":"FlowDatasetUtils","similarity_score":0.5925733515413276},{"class_name":"AttributedStringUtils","similarity_score":0.377917773253318},{"class_name":"CloneUtilsTest","similarity_score":0.3959307181859459},{"class_name":"SerialUtilsTest","similarity_score":0.1832485848776168},{"class_name":"LineUtilsTest","similarity_score":0.1238143085185992},{"class_name":"ShapeUtilsTest","similarity_score":0.37216962512851526},{"class_name":"RendererUtilsTest","similarity_score":0.19359378175010986},{"class_name":"ObjectWithMapOfPaint","similarity_score":0.1032318134468489},{"class_name":"ObjectWithMapOfStroke","similarity_score":0.1032318134468489},{"class_name":"HashUtilsTest","similarity_score":0.2540837929778085},{"class_name":"ImageMapUtilsTest","similarity_score":0.273392380570664},{"class_name":"DatasetUtilsTest","similarity_score":0.29714988358071454},{"class_name":"DataUtilsTest","similarity_score":0.23822180928399705},{"class_name":"Args","similarity_score":0.53782696656758},{"class_name":"PaintAlpha","similarity_score":0.6310401041736052},{"class_name":"ImageEncoderFactory","similarity_score":0.5525730354763054},{"class_name":"DatasetReader","similarity_score":0.6325832396982786},{"class_name":"ChartEditorManager","similarity_score":0.6179435387903899},{"class_name":"MovingAverage","similarity_score":0.5249469333179847},{"class_name":"JSONValue","similarity_score":0.508802843709574},{"class_name":"ChartColor","similarity_score":0.35328655076318755},{"class_name":"NumberAxis","similarity_score":0.5755074930894724},{"class_name":"PieChartTest","similarity_score":0.5102291262093425},{"class_name":"GanttChartTest","similarity_score":0.46801271946661926},{"class_name":"JSONObject","similarity_score":0.6551299269043744},{"class_name":"DateTickUnit","similarity_score":0.6710332102698021},{"class_name":"DateAxis","similarity_score":0.5726425109025204},{"class_name":"CompassFormat","similarity_score":0.5823575728486333},{"class_name":"AxisCollection","similarity_score":0.5180096315013587},{"class_name":"AxisLocationTest","similarity_score":0.28963356784814454},{"class_name":"AxisSpace","similarity_score":0.5451338779950718},{"class_name":"AxisSpaceTest","similarity_score":0.2691400850578561},{"class_name":"AxisState","similarity_score":0.5483044822401676},{"class_name":"AxisTest","similarity_score":0.10183107429663985},{"class_name":"DateTick","similarity_score":0.6357812876987435},{"class_name":"DateTickMarkPositionTest","similarity_score":0.2844435844500243},{"class_name":"DateTickTest","similarity_score":0.17030269182353527},{"class_name":"DateTickUnitTest","similarity_score":0.32251750938460555},{"class_name":"CycleBoundTick","similarity_score":0.5699161819610755},{"class_name":"CyclicNumberAxis","similarity_score":0.5544568404496376},{"class_name":"CyclicNumberAxisTest","similarity_score":0.22517665519790112},{"class_name":"CategoryAnchorTest","similarity_score":0.2891045563237118},{"class_name":"CategoryAxis","similarity_score":0.6646297099950039},{"class_name":"CategoryAxisTest","similarity_score":0.2048461655914735},{"class_name":"CategoryLabelPosition","similarity_score":0.6887190024131205},{"class_name":"CategoryLabelPositionsTest","similarity_score":0.25547684713325886},{"class_name":"CategoryLabelPositionTest","similarity_score":0.18939286664863605},{"class_name":"CategoryLabelWidthTypeTest","similarity_score":0.3136919210616374},{"class_name":"DefaultTimeline","similarity_score":0.6388601267840877},{"class_name":"CategoryTick","similarity_score":0.5992871822748967},{"class_name":"CategoryTickTest","similarity_score":0.20234063313204814},{"class_name":"DateAxisTest","similarity_score":0.19280523228349428},{"class_name":"NumberAxisTest","similarity_score":0.2988641226972616},{"class_name":"NumberTick","similarity_score":0.6035011071168881},{"class_name":"NumberTickUnit","similarity_score":0.6267861435371729},{"class_name":"NumberTickUnitSource","similarity_score":0.2710418903995995},{"class_name":"NumberTickUnitTest","similarity_score":0.324879874589469},{"class_name":"LogarithmicAxis","similarity_score":0.4450377813667634},{"class_name":"LogarithmicAxisTest","similarity_score":0.3907581114627765},{"class_name":"LogAxis","similarity_score":0.5853962435774641},{"class_name":"LogAxisTest","similarity_score":0.33875224999182096},{"class_name":"QuarterDateFormat","similarity_score":0.6433128588805314},{"class_name":"QuarterDateFormatTest","similarity_score":0.2511098047471192},{"class_name":"RelativeDateFormatTest","similarity_score":0.35228267904098093},{"class_name":"PeriodAxis","similarity_score":0.598766374269804},{"class_name":"PeriodAxisLabelInfo","similarity_score":0.6620917585580188},{"class_name":"PeriodAxisLabelInfoTest","similarity_score":0.20544884665344684},{"class_name":"PeriodAxisTest","similarity_score":0.3131778017963438},{"class_name":"MonthDateFormat","similarity_score":0.6545771422042024},{"class_name":"MonthDateFormatTest","similarity_score":0.24718417357136846},{"class_name":"LogTick","similarity_score":0.632299943843871},{"class_name":"MarkerAxisBand","similarity_score":0.5498341515361024},{"class_name":"MarkerAxisBandTest","similarity_score":0.16689409886074044},{"class_name":"MyDateAxis","similarity_score":0.4360070194091799},{"class_name":"MyLogarithmicAxis","similarity_score":0.49546252205588626},{"class_name":"ModuloAxis","similarity_score":0.5719427505465469},{"class_name":"ModuloAxisTest","similarity_score":0.3148568299398463},{"class_name":"StandardTickUnitSource","similarity_score":0.6564319172569947},{"class_name":"StandardTickUnitSourceTest","similarity_score":0.3452094373356426},{"class_name":"TickUnits","similarity_score":0.6311777071499766},{"class_name":"TickUnitsTest","similarity_score":0.3296817097484501}],"target_classes_sorted_by_llm":["CategoryLabelPosition","ShapeUtils","DateTickUnit"],"llm_response_time":7442,"similarity_computation_time":35,"similarity_metric":"cosine"},"replaceBottomPosition":{"target_classes":[{"class_name":"LineUtils","similarity_score":0.38110215736640457},{"class_name":"HashUtils","similarity_score":0.6318650753303837},{"class_name":"CloneUtils","similarity_score":0.5897078126301563},{"class_name":"EncoderUtil","similarity_score":0.5265294241733129},{"class_name":"ImageMapUtils","similarity_score":0.6649123217983022},{"class_name":"ExportUtils","similarity_score":0.5994581278728074},{"class_name":"TestUtils","similarity_score":0.45447014360442073},{"class_name":"RendererUtils","similarity_score":0.37167366798749035},{"class_name":"RendererXYPackageUtils","similarity_score":0.44839435952334},{"class_name":"TextUtils","similarity_score":0.5865610367690264},{"class_name":"ShapeUtils","similarity_score":0.6700604625975384},{"class_name":"SerialUtils","similarity_score":0.5405262083091763},{"class_name":"AttrStringUtils","similarity_score":0.5344230810413388},{"class_name":"UIUtils","similarity_score":0.6084026861037888},{"class_name":"ArrayUtils","similarity_score":0.4689064398553489},{"class_name":"PaintUtils","similarity_score":0.44929971399446417},{"class_name":"JSONUtils","similarity_score":0.5792666675398838},{"class_name":"StringUtils","similarity_score":0.5763270847470471},{"class_name":"DatasetUtils","similarity_score":0.5585561797267582},{"class_name":"FlowDatasetUtils","similarity_score":0.590633662698596},{"class_name":"AttributedStringUtils","similarity_score":0.3766807232132804},{"class_name":"ObjectWithMapOfPaint","similarity_score":0.1028939015305655},{"class_name":"ObjectWithMapOfStroke","similarity_score":0.1028939015305655},{"class_name":"SerialUtilsTest","similarity_score":0.18264875156650195},{"class_name":"LineUtilsTest","similarity_score":0.12340902327892486},{"class_name":"HashUtilsTest","similarity_score":0.2532520925696209},{"class_name":"ShapeUtilsTest","similarity_score":0.3709513906811044},{"class_name":"CloneUtilsTest","similarity_score":0.39463470581117},{"class_name":"ImageMapUtilsTest","similarity_score":0.2724974767601882},{"class_name":"RendererUtilsTest","similarity_score":0.1929600851832525},{"class_name":"DataUtilsTest","similarity_score":0.23744203040200448},{"class_name":"DatasetUtilsTest","similarity_score":0.2961772135942879},{"class_name":"Args","similarity_score":0.536066480775133},{"class_name":"PaintAlpha","similarity_score":0.6289745009091352},{"class_name":"ImageEncoderFactory","similarity_score":0.5507642809163512},{"class_name":"ChartEditorManager","similarity_score":0.6159208049220645},{"class_name":"JSONValue","similarity_score":0.5071373634841698},{"class_name":"MovingAverage","similarity_score":0.5232286081402923},{"class_name":"DatasetReader","similarity_score":0.6305125852401423},{"class_name":"ChartColor","similarity_score":0.3521301268723392},{"class_name":"NumberAxis","similarity_score":0.573623666453748},{"class_name":"PieChartTest","similarity_score":0.5085589772889251},{"class_name":"GanttChartTest","similarity_score":0.4664807588277471},{"class_name":"JSONObject","similarity_score":0.6465940947643803},{"class_name":"DateTickUnit","similarity_score":0.6688366963231706},{"class_name":"DateAxis","similarity_score":0.5707680623023897},{"class_name":"NumberAxisTest","similarity_score":0.2978858414384423},{"class_name":"NumberTick","similarity_score":0.6015256481108326},{"class_name":"NumberTickUnit","similarity_score":0.6247344648947981},{"class_name":"NumberTickUnitSource","similarity_score":0.2701546805219473},{"class_name":"NumberTickUnitTest","similarity_score":0.3238164351581646},{"class_name":"CategoryAnchorTest","similarity_score":0.2881582213580483},{"class_name":"CategoryAxis","similarity_score":0.6624541568256419},{"class_name":"CategoryAxisTest","similarity_score":0.20417563624545984},{"class_name":"CategoryLabelPosition","similarity_score":0.6864645970111847},{"class_name":"CategoryLabelPositionsTest","similarity_score":0.26671840119098855},{"class_name":"CategoryLabelPositionTest","similarity_score":0.18877292106826907},{"class_name":"CategoryLabelWidthTypeTest","similarity_score":0.3126651035077335},{"class_name":"CategoryTick","similarity_score":0.5973255168405213},{"class_name":"CategoryTickTest","similarity_score":0.20167830522361857},{"class_name":"AxisCollection","similarity_score":0.5176481591502577},{"class_name":"AxisLocationTest","similarity_score":0.2886855012525505},{"class_name":"AxisSpace","similarity_score":0.5438800889823968},{"class_name":"AxisSpaceTest","similarity_score":0.2682591004189744},{"class_name":"AxisState","similarity_score":0.5465097000687206},{"class_name":"AxisTest","similarity_score":0.10149774746352662},{"class_name":"CompassFormat","similarity_score":0.5804513236330779},{"class_name":"LogarithmicAxis","similarity_score":0.4435810253097018},{"class_name":"LogarithmicAxisTest","similarity_score":0.3894790307429977},{"class_name":"LogAxis","similarity_score":0.5834800477861908},{"class_name":"LogAxisTest","similarity_score":0.3376434016812274},{"class_name":"LogTick","similarity_score":0.6302302167068953},{"class_name":"PeriodAxis","similarity_score":0.5968064136125232},{"class_name":"PeriodAxisLabelInfo","similarity_score":0.6599245129442918},{"class_name":"PeriodAxisLabelInfoTest","similarity_score":0.20477634453270652},{"class_name":"PeriodAxisTest","similarity_score":0.31215266712507406},{"class_name":"MarkerAxisBand","similarity_score":0.548034362250416},{"class_name":"MarkerAxisBandTest","similarity_score":0.16634779919904305},{"class_name":"StandardTickUnitSource","similarity_score":0.6542831981784125},{"class_name":"StandardTickUnitSourceTest","similarity_score":0.3440794525122213},{"class_name":"MonthDateFormat","similarity_score":0.6524344944186784},{"class_name":"ExtendedCategoryAxis","similarity_score":0.6541555397747737},{"class_name":"MonthDateFormatTest","similarity_score":0.24637505790268524},{"class_name":"ExtendedCategoryAxisTest","similarity_score":0.2461567608443628},{"class_name":"MyDateAxis","similarity_score":0.43457982402703715},{"class_name":"MyLogarithmicAxis","similarity_score":0.49384070912163314},{"class_name":"QuarterDateFormat","similarity_score":0.6412070828251103},{"class_name":"QuarterDateFormatTest","similarity_score":0.25028783918740993},{"class_name":"SubCategoryAxis","similarity_score":0.6002594342107624},{"class_name":"SubCategoryAxisTest","similarity_score":0.3222985438675237},{"class_name":"ValueAxisTest","similarity_score":0.18455379733155833},{"class_name":"TickUnits","similarity_score":0.6291116534653902},{"class_name":"TickUnitsTest","similarity_score":0.32860255232027963},{"class_name":"SymbolAxis","similarity_score":0.5630953200956536},{"class_name":"SymbolAxisTest","similarity_score":0.254817263448359},{"class_name":"CycleBoundTick","similarity_score":0.5680506575385434},{"class_name":"CyclicNumberAxis","similarity_score":0.5526419195720804},{"class_name":"CyclicNumberAxisTest","similarity_score":0.22443957742584994},{"class_name":"ModuloAxis","similarity_score":0.5700705924938253},{"class_name":"ModuloAxisTest","similarity_score":0.31382619925336064}],"target_classes_sorted_by_llm":["CategoryLabelPosition","ShapeUtils","DateTickUnit"],"llm_response_time":6474,"similarity_computation_time":35,"similarity_metric":"cosine"},"replaceLeftPosition":{"target_classes":[{"class_name":"LineUtils","similarity_score":0.38110215736640457},{"class_name":"TestUtils","similarity_score":0.45447014360442073},{"class_name":"RendererUtils","similarity_score":0.37167366798749035},{"class_name":"RendererXYPackageUtils","similarity_score":0.44839435952334},{"class_name":"EncoderUtil","similarity_score":0.5265294241733129},{"class_name":"ExportUtils","similarity_score":0.5994581278728074},{"class_name":"CloneUtils","similarity_score":0.5897078126301563},{"class_name":"ImageMapUtils","similarity_score":0.6649123217983022},{"class_name":"HashUtils","similarity_score":0.6318650753303837},{"class_name":"TextUtils","similarity_score":0.5878130347130371},{"class_name":"ShapeUtils","similarity_score":0.6700604625975384},{"class_name":"SerialUtils","similarity_score":0.5405262083091763},{"class_name":"AttrStringUtils","similarity_score":0.5344230810413388},{"class_name":"UIUtils","similarity_score":0.6084026861037888},{"class_name":"ArrayUtils","similarity_score":0.4689064398553489},{"class_name":"PaintUtils","similarity_score":0.44929971399446417},{"class_name":"StringUtils","similarity_score":0.5763270847470471},{"class_name":"JSONUtils","similarity_score":0.5792666675398838},{"class_name":"DatasetUtils","similarity_score":0.5585561797267582},{"class_name":"FlowDatasetUtils","similarity_score":0.590633662698596},{"class_name":"AttributedStringUtils","similarity_score":0.3766807232132804},{"class_name":"ObjectWithMapOfPaint","similarity_score":0.1028939015305655},{"class_name":"ObjectWithMapOfStroke","similarity_score":0.1028939015305655},{"class_name":"SerialUtilsTest","similarity_score":0.18264875156650195},{"class_name":"LineUtilsTest","similarity_score":0.12340902327892486},{"class_name":"ShapeUtilsTest","similarity_score":0.3709513906811044},{"class_name":"RendererUtilsTest","similarity_score":0.1929600851832525},{"class_name":"CloneUtilsTest","similarity_score":0.39463470581117},{"class_name":"ImageMapUtilsTest","similarity_score":0.2724974767601882},{"class_name":"HashUtilsTest","similarity_score":0.2532520925696209},{"class_name":"DatasetUtilsTest","similarity_score":0.2961772135942879},{"class_name":"DataUtilsTest","similarity_score":0.23744203040200448},{"class_name":"PaintAlpha","similarity_score":0.6289745009091352},{"class_name":"Args","similarity_score":0.536066480775133},{"class_name":"ImageEncoderFactory","similarity_score":0.5507642809163512},{"class_name":"MovingAverage","similarity_score":0.5232286081402923},{"class_name":"DatasetReader","similarity_score":0.6305125852401423},{"class_name":"ChartEditorManager","similarity_score":0.6159208049220645},{"class_name":"JSONValue","similarity_score":0.5071373634841698},{"class_name":"ChartColor","similarity_score":0.3521301268723392},{"class_name":"NumberAxis","similarity_score":0.573623666453748},{"class_name":"PieChartTest","similarity_score":0.5085589772889251},{"class_name":"GanttChartTest","similarity_score":0.4664807588277471},{"class_name":"JSONObject","similarity_score":0.6465940947643803},{"class_name":"DateTickUnit","similarity_score":0.6688366963231706},{"class_name":"DateAxis","similarity_score":0.5707680623023897},{"class_name":"NumberAxisTest","similarity_score":0.2978858414384423},{"class_name":"NumberTick","similarity_score":0.6015256481108326},{"class_name":"NumberTickUnit","similarity_score":0.6247344648947981},{"class_name":"NumberTickUnitSource","similarity_score":0.2701546805219473},{"class_name":"NumberTickUnitTest","similarity_score":0.3238164351581646},{"class_name":"ValueAxisTest","similarity_score":0.18455379733155833},{"class_name":"QuarterDateFormat","similarity_score":0.6412070828251103},{"class_name":"QuarterDateFormatTest","similarity_score":0.25028783918740993},{"class_name":"StandardTickUnitSource","similarity_score":0.6542831981784125},{"class_name":"StandardTickUnitSourceTest","similarity_score":0.3440794525122213},{"class_name":"RelativeDateFormatTest","similarity_score":0.3511295411547665},{"class_name":"TickUnits","similarity_score":0.6291116534653902},{"class_name":"TickUnitsTest","similarity_score":0.32860255232027963},{"class_name":"ModuloAxis","similarity_score":0.5700705924938253},{"class_name":"ModuloAxisTest","similarity_score":0.31382619925336064},{"class_name":"MonthDateFormat","similarity_score":0.6524344944186784},{"class_name":"MonthDateFormatTest","similarity_score":0.24637505790268524},{"class_name":"SubCategoryAxis","similarity_score":0.5988234068561912},{"class_name":"SubCategoryAxisTest","similarity_score":0.3222985438675237},{"class_name":"SymbolAxis","similarity_score":0.5630953200956536},{"class_name":"SymbolAxisTest","similarity_score":0.254817263448359},{"class_name":"PeriodAxis","similarity_score":0.5963044738197456},{"class_name":"PeriodAxisLabelInfo","similarity_score":0.6599245129442918},{"class_name":"PeriodAxisLabelInfoTest","similarity_score":0.20477634453270652},{"class_name":"PeriodAxisTest","similarity_score":0.31215266712507406},{"class_name":"LogarithmicAxis","similarity_score":0.4435810253097018},{"class_name":"LogarithmicAxisTest","similarity_score":0.3909215456716755},{"class_name":"LogAxis","similarity_score":0.5839702298481787},{"class_name":"LogAxisTest","similarity_score":0.3376434016812274},{"class_name":"MyDateAxis","similarity_score":0.43457982402703715},{"class_name":"MyLogarithmicAxis","similarity_score":0.49384070912163314},{"class_name":"LogTick","similarity_score":0.6302302167068953},{"class_name":"MarkerAxisBand","similarity_score":0.5365572028315592},{"class_name":"MarkerAxisBandTest","similarity_score":0.16634779919904305},{"class_name":"DateTick","similarity_score":0.633700164970293},{"class_name":"DateTickMarkPositionTest","similarity_score":0.2835125063890397},{"class_name":"DateTickTest","similarity_score":0.16974523470812833},{"class_name":"DateTickUnitTest","similarity_score":0.32146180275704345},{"class_name":"CompassFormat","similarity_score":0.5804513236330779},{"class_name":"CategoryTick","similarity_score":0.5973255168405213},{"class_name":"CategoryTickTest","similarity_score":0.20167830522361857},{"class_name":"CycleBoundTick","similarity_score":0.5680506575385434},{"class_name":"CyclicNumberAxis","similarity_score":0.5526419195720804},{"class_name":"CyclicNumberAxisTest","similarity_score":0.22443957742584994},{"class_name":"DefaultTimeline","similarity_score":0.6367689259955845},{"class_name":"ExtendedCategoryAxis","similarity_score":0.6541555397747737},{"class_name":"ExtendedCategoryAxisTest","similarity_score":0.2461567608443628},{"class_name":"CategoryAnchorTest","similarity_score":0.2881582213580483},{"class_name":"CategoryAxis","similarity_score":0.6624541568256419},{"class_name":"CategoryAxisTest","similarity_score":0.20417563624545984},{"class_name":"CategoryLabelPosition","similarity_score":0.6864645970111847},{"class_name":"CategoryLabelPositionsTest","similarity_score":0.26671840119098855},{"class_name":"CategoryLabelPositionTest","similarity_score":0.18877292106826907},{"class_name":"CategoryLabelWidthTypeTest","similarity_score":0.3126651035077335}],"target_classes_sorted_by_llm":["CategoryLabelPosition","ShapeUtils","DateTickUnit"],"llm_response_time":9563,"similarity_computation_time":32,"similarity_metric":"cosine"},"replaceRightPosition":{"target_classes":[{"class_name":"ExportUtils","similarity_score":0.5994581278728074},{"class_name":"HashUtils","similarity_score":0.6318650753303837},{"class_name":"LineUtils","similarity_score":0.38110215736640457},{"class_name":"EncoderUtil","similarity_score":0.5265294241733129},{"class_name":"RendererUtils","similarity_score":0.37167366798749035},{"class_name":"RendererXYPackageUtils","similarity_score":0.44839435952334},{"class_name":"ImageMapUtils","similarity_score":0.6649123217983022},{"class_name":"CloneUtils","similarity_score":0.5897078126301563},{"class_name":"TestUtils","similarity_score":0.45447014360442073},{"class_name":"TextUtils","similarity_score":0.5865610367690264},{"class_name":"ShapeUtils","similarity_score":0.6700604625975384},{"class_name":"SerialUtils","similarity_score":0.5405262083091763},{"class_name":"AttrStringUtils","similarity_score":0.5344230810413388},{"class_name":"UIUtils","similarity_score":0.6084026861037888},{"class_name":"ArrayUtils","similarity_score":0.4689064398553489},{"class_name":"PaintUtils","similarity_score":0.44929971399446417},{"class_name":"StringUtils","similarity_score":0.5763270847470471},{"class_name":"JSONUtils","similarity_score":0.5792666675398838},{"class_name":"DatasetUtils","similarity_score":0.5585561797267582},{"class_name":"FlowDatasetUtils","similarity_score":0.590633662698596},{"class_name":"AttributedStringUtils","similarity_score":0.3766807232132804},{"class_name":"ObjectWithMapOfPaint","similarity_score":0.1028939015305655},{"class_name":"ObjectWithMapOfStroke","similarity_score":0.1028939015305655},{"class_name":"SerialUtilsTest","similarity_score":0.18264875156650195},{"class_name":"HashUtilsTest","similarity_score":0.2532520925696209},{"class_name":"LineUtilsTest","similarity_score":0.12340902327892486},{"class_name":"ShapeUtilsTest","similarity_score":0.3709513906811044},{"class_name":"RendererUtilsTest","similarity_score":0.1929600851832525},{"class_name":"ImageMapUtilsTest","similarity_score":0.2724974767601882},{"class_name":"CloneUtilsTest","similarity_score":0.39463470581117},{"class_name":"DatasetUtilsTest","similarity_score":0.2961772135942879},{"class_name":"DataUtilsTest","similarity_score":0.23744203040200448},{"class_name":"PaintAlpha","similarity_score":0.6289745009091352},{"class_name":"ImageEncoderFactory","similarity_score":0.5507642809163512},{"class_name":"Args","similarity_score":0.536066480775133},{"class_name":"DatasetReader","similarity_score":0.6305125852401423},{"class_name":"MovingAverage","similarity_score":0.5232286081402923},{"class_name":"ChartEditorManager","similarity_score":0.6249784638179772},{"class_name":"JSONValue","similarity_score":0.5071373634841698},{"class_name":"ChartColor","similarity_score":0.3521301268723392},{"class_name":"NumberAxis","similarity_score":0.573623666453748},{"class_name":"GanttChartTest","similarity_score":0.4664807588277471},{"class_name":"PieChartTest","similarity_score":0.5085589772889251},{"class_name":"JSONObject","similarity_score":0.6465940947643803},{"class_name":"DateTickUnit","similarity_score":0.6688366963231706},{"class_name":"DateAxis","similarity_score":0.5707680623023897},{"class_name":"NumberAxisTest","similarity_score":0.2978858414384423},{"class_name":"ExtendedCategoryAxis","similarity_score":0.6541555397747737},{"class_name":"ExtendedCategoryAxisTest","similarity_score":0.2461567608443628},{"class_name":"NumberTick","similarity_score":0.6015256481108326},{"class_name":"NumberTickUnit","similarity_score":0.6247344648947981},{"class_name":"NumberTickUnitSource","similarity_score":0.2701546805219473},{"class_name":"NumberTickUnitTest","similarity_score":0.3238164351581646},{"class_name":"QuarterDateFormat","similarity_score":0.6412070828251103},{"class_name":"QuarterDateFormatTest","similarity_score":0.25028783918740993},{"class_name":"RelativeDateFormatTest","similarity_score":0.3511295411547665},{"class_name":"DateTick","similarity_score":0.633700164970293},{"class_name":"DateTickMarkPositionTest","similarity_score":0.2835125063890397},{"class_name":"DateTickTest","similarity_score":0.16974523470812833},{"class_name":"DateTickUnitTest","similarity_score":0.32146180275704345},{"class_name":"CompassFormat","similarity_score":0.5804513236330779},{"class_name":"PeriodAxis","similarity_score":0.5963044738197456},{"class_name":"PeriodAxisLabelInfo","similarity_score":0.6599245129442918},{"class_name":"PeriodAxisLabelInfoTest","similarity_score":0.20477634453270652},{"class_name":"PeriodAxisTest","similarity_score":0.31215266712507406},{"class_name":"LogarithmicAxis","similarity_score":0.4435810253097018},{"class_name":"LogarithmicAxisTest","similarity_score":0.3894790307429977},{"class_name":"LogAxis","similarity_score":0.5841336238688413},{"class_name":"LogAxisTest","similarity_score":0.3376434016812274},{"class_name":"LogTick","similarity_score":0.6302302167068953},{"class_name":"DefaultTimeline","similarity_score":0.6367689259955845},{"class_name":"ValueAxisTest","similarity_score":0.18455379733155833},{"class_name":"CycleBoundTick","similarity_score":0.5680506575385434},{"class_name":"CyclicNumberAxis","similarity_score":0.5526419195720804},{"class_name":"CyclicNumberAxisTest","similarity_score":0.22443957742584994},{"class_name":"MarkerAxisBand","similarity_score":0.5365572028315592},{"class_name":"MarkerAxisBandTest","similarity_score":0.16634779919904305},{"class_name":"StandardTickUnitSource","similarity_score":0.6542831981784125},{"class_name":"StandardTickUnitSourceTest","similarity_score":0.3440794525122213},{"class_name":"DateAxisTest","similarity_score":0.19217411690021252},{"class_name":"MonthDateFormat","similarity_score":0.6524344944186784},{"class_name":"MonthDateFormatTest","similarity_score":0.24637505790268524},{"class_name":"MyDateAxis","similarity_score":0.43457982402703715},{"class_name":"MyLogarithmicAxis","similarity_score":0.49384070912163314},{"class_name":"AxisCollection","similarity_score":0.5203164486304137},{"class_name":"AxisLocationTest","similarity_score":0.2886855012525505},{"class_name":"AxisSpace","similarity_score":0.5449413184243137},{"class_name":"AxisSpaceTest","similarity_score":0.2682591004189744},{"class_name":"AxisState","similarity_score":0.5490516056504355},{"class_name":"AxisTest","similarity_score":0.10149774746352662},{"class_name":"SubCategoryAxis","similarity_score":0.5988234068561912},{"class_name":"SubCategoryAxisTest","similarity_score":0.3222985438675237},{"class_name":"CategoryAnchorTest","similarity_score":0.2881582213580483},{"class_name":"CategoryAxis","similarity_score":0.6624541568256419},{"class_name":"CategoryAxisTest","similarity_score":0.20417563624545984},{"class_name":"CategoryLabelPosition","similarity_score":0.6864645970111847},{"class_name":"CategoryLabelPositionsTest","similarity_score":0.26671840119098855},{"class_name":"CategoryLabelPositionTest","similarity_score":0.18877292106826907},{"class_name":"CategoryLabelWidthTypeTest","similarity_score":0.3126651035077335},{"class_name":"TickUnits","similarity_score":0.6291116534653902}],"target_classes_sorted_by_llm":["CategoryLabelPosition","ShapeUtils","DateTickUnit"],"llm_response_time":7020,"similarity_computation_time":25,"similarity_metric":"cosine"}}}
{"id":"fecf623e-8edb-4693-9ab4-b68797d645cd","hostFunctionTelemetryData":{"hostFunctionSize":1102,"lineStart":64,"lineEnd":1165,"bodyLineStart":64,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/axis/CyclicNumberAxis.java","sourceCode":"/**\nThis class extends NumberAxis and handles cycling.\n\nTraditional representation of data in the range x0..x1\n\u003cpre\u003e\n|-------------------------|\nx0                       x1\n\u003c/pre\u003e\n\nHere, the range bounds are at the axis extremities.\nWith cyclic axis, however, the time is split in\n\"cycles\", or \"time frames\", or the same duration : the period.\n\nA cycle axis cannot by definition handle a larger interval\nthan the period : \u003cpre\u003ex1 - x0 \u0026gt;\u003d period\u003c/pre\u003e. Thus, at most a full\nperiod can be represented with such an axis.\n\nThe cycle bound is the number between x0 and x1 which marks\nthe beginning of new time frame:\n\u003cpre\u003e\n|---------------------|----------------------------|\nx0                   cb                           x1\n\u0026lt;---previous cycle---\u0026gt;\u0026lt;-------current cycle--------\u0026gt;\n\u003c/pre\u003e\n\nIt is actually a multiple of the period, plus optionally\na start offset: \u003cpre\u003ecb \u003d n * period + offset\u003c/pre\u003e\n\nThus, by definition, two consecutive cycle bounds\nperiod apart, which is precisely why it is called a\nperiod.\n\nThe visual representation of a cyclic axis is like that:\n\u003cpre\u003e\n|----------------------------|---------------------|\ncb                         x1|x0                  cb\n\u0026lt;-------current cycle--------\u0026gt;\u0026lt;---previous cycle---\u0026gt;\n\u003c/pre\u003e\n\nThe cycle bound is at the axis ends, then current\ncycle is shown, then the last cycle. When using\ndynamic data, the visual effect is the current cycle\nerases the last cycle as x grows. Then, the next cycle\nbound is reached, and the process starts over, erasing\nthe previous cycle.\n\nA Cyclic item renderer is provided to do exactly this.\n\n */\npublic class CyclicNumberAxis extends NumberAxis {\n\n    /** For serialization. */\n    static final long serialVersionUID \u003d -7514160997164582554L;\n\n    /** The default axis line stroke. */\n    public static Stroke DEFAULT_ADVANCE_LINE_STROKE \u003d new BasicStroke(1.0f);\n\n    /** The default axis line paint. */\n    public static final Paint DEFAULT_ADVANCE_LINE_PAINT \u003d Color.GRAY;\n\n    /** The offset. */\n    protected double offset;\n\n    /** The period.*/\n    protected double period;\n\n    /** ??. */\n    protected boolean boundMappedToLastCycle;\n\n    /** A flag that controls whether or not the advance line is visible. */\n    protected boolean advanceLineVisible;\n\n    /** The advance line stroke. */\n    protected transient Stroke advanceLineStroke \u003d DEFAULT_ADVANCE_LINE_STROKE;\n\n    /** The advance line paint. */\n    protected transient Paint advanceLinePaint;\n\n    private transient boolean internalMarkerWhenTicksOverlap;\n    private transient Tick internalMarkerCycleBoundTick;\n\n    /**\n     * Creates a CycleNumberAxis with the given period.\n     *\n     * @param period  the period.\n     */\n    public CyclicNumberAxis(double period) {\n        this(period, 0.0);\n    }\n\n    /**\n     * Creates a CycleNumberAxis with the given period and offset.\n     *\n     * @param period  the period.\n     * @param offset  the offset.\n     */\n    public CyclicNumberAxis(double period, double offset) {\n        this(period, offset, null);\n    }\n\n    /**\n     * Creates a named CycleNumberAxis with the given period.\n     *\n     * @param period  the period.\n     * @param label  the label.\n     */\n    public CyclicNumberAxis(double period, String label) {\n        this(0, period, label);\n    }\n\n    /**\n     * Creates a named CycleNumberAxis with the given period and offset.\n     *\n     * @param period  the period.\n     * @param offset  the offset.\n     * @param label  the label.\n     */\n    public CyclicNumberAxis(double period, double offset, String label) {\n        super(label);\n        this.period \u003d period;\n        this.offset \u003d offset;\n        setFixedAutoRange(period);\n        this.advanceLineVisible \u003d true;\n        this.advanceLinePaint \u003d DEFAULT_ADVANCE_LINE_PAINT;\n    }\n\n    /**\n     * The advance line is the line drawn at the limit of the current cycle,\n     * when erasing the previous cycle.\n     *\n     * @return A boolean.\n     */\n    public boolean isAdvanceLineVisible() {\n        return this.advanceLineVisible;\n    }\n\n    /**\n     * The advance line is the line drawn at the limit of the current cycle,\n     * when erasing the previous cycle.\n     *\n     * @param visible  the flag.\n     */\n    public void setAdvanceLineVisible(boolean visible) {\n        this.advanceLineVisible \u003d visible;\n    }\n\n    /**\n     * The advance line is the line drawn at the limit of the current cycle,\n     * when erasing the previous cycle.\n     *\n     * @return The paint (never {@code null}).\n     */\n    public Paint getAdvanceLinePaint() {\n        return this.advanceLinePaint;\n    }\n\n    /**\n     * The advance line is the line drawn at the limit of the current cycle,\n     * when erasing the previous cycle.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     */\n    public void setAdvanceLinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.advanceLinePaint \u003d paint;\n    }\n\n    /**\n     * The advance line is the line drawn at the limit of the current cycle,\n     * when erasing the previous cycle.\n     *\n     * @return The stroke (never {@code null}).\n     */\n    public Stroke getAdvanceLineStroke() {\n        return this.advanceLineStroke;\n    }\n    /**\n     * The advance line is the line drawn at the limit of the current cycle,\n     * when erasing the previous cycle.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     */\n    public void setAdvanceLineStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.advanceLineStroke \u003d stroke;\n    }\n\n    /**\n     * The cycle bound can be associated either with the current or with the\n     * last cycle.  It\u0027s up to the user\u0027s choice to decide which, as this is\n     * just a convention.  By default, the cycle bound is mapped to the current\n     * cycle.\n     * \u003cbr\u003e\n     * Note that this has no effect on visual appearance, as the cycle bound is\n     * mapped successively for both axis ends. Use this function for correct\n     * results in translateValueToJava2D.\n     *\n     * @return {@code true} if the cycle bound is mapped to the last\n     *         cycle, {@code false} if it is bound to the current cycle\n     *         (default)\n     */\n    public boolean isBoundMappedToLastCycle() {\n        return this.boundMappedToLastCycle;\n    }\n\n    /**\n     * The cycle bound can be associated either with the current or with the\n     * last cycle.  It\u0027s up to the user\u0027s choice to decide which, as this is\n     * just a convention. By default, the cycle bound is mapped to the current\n     * cycle.\n     * \u003cbr\u003e\n     * Note that this has no effect on visual appearance, as the cycle bound is\n     * mapped successively for both axis ends. Use this function for correct\n     * results in valueToJava2D.\n     *\n     * @param boundMappedToLastCycle Set it to true to map the cycle bound to\n     *        the last cycle.\n     */\n    public void setBoundMappedToLastCycle(boolean boundMappedToLastCycle) {\n        this.boundMappedToLastCycle \u003d boundMappedToLastCycle;\n    }\n\n    /**\n     * Selects a tick unit when the axis is displayed horizontally.\n     *\n     * @param g2  the graphics device.\n     * @param drawArea  the drawing area.\n     * @param dataArea  the data area.\n     * @param edge  the side of the rectangle on which the axis is displayed.\n     */\n    protected void selectHorizontalAutoTickUnit(Graphics2D g2,\n            Rectangle2D drawArea, Rectangle2D dataArea, RectangleEdge edge) {\n\n        double tickLabelWidth\n            \u003d estimateMaximumTickLabelWidth(g2, getTickUnit());\n\n        // Compute number of labels\n        double n \u003d getRange().getLength()\n                   * tickLabelWidth / dataArea.getWidth();\n\n        setTickUnit(\n                (NumberTickUnit) getStandardTickUnits().getCeilingTickUnit(n),\n                false, false);\n\n     }\n\n    /**\n     * Selects a tick unit when the axis is displayed vertically.\n     *\n     * @param g2  the graphics device.\n     * @param drawArea  the drawing area.\n     * @param dataArea  the data area.\n     * @param edge  the side of the rectangle on which the axis is displayed.\n     */\n    protected void selectVerticalAutoTickUnit(Graphics2D g2,\n            Rectangle2D drawArea, Rectangle2D dataArea, RectangleEdge edge) {\n\n        double tickLabelWidth\n            \u003d estimateMaximumTickLabelWidth(g2, getTickUnit());\n\n        // Compute number of labels\n        double n \u003d getRange().getLength()\n                   * tickLabelWidth / dataArea.getHeight();\n\n        setTickUnit(\n            (NumberTickUnit) getStandardTickUnits().getCeilingTickUnit(n),\n            false, false);\n     }\n\n    /**\n     * A special Number tick that also hold information about the cycle bound\n     * mapping for this tick.  This is especially useful for having a tick at\n     * each axis end with the cycle bound value.  See also\n     * isBoundMappedToLastCycle()\n     */\n    protected static class CycleBoundTick extends NumberTick {\n\n        /** Map to last cycle. */\n        public boolean mapToLastCycle;\n\n        /**\n         * Creates a new tick.\n         *\n         * @param mapToLastCycle  map to last cycle?\n         * @param number  the number.\n         * @param label  the label.\n         * @param textAnchor  the text anchor.\n         * @param rotationAnchor  the rotation anchor.\n         * @param angle  the rotation angle.\n         */\n        public CycleBoundTick(boolean mapToLastCycle, Number number,\n                              String label, TextAnchor textAnchor,\n                              TextAnchor rotationAnchor, double angle) {\n            super(number, label, textAnchor, rotationAnchor, angle);\n            this.mapToLastCycle \u003d mapToLastCycle;\n        }\n    }\n\n    /**\n     * Calculates the anchor point for a tick.\n     *\n     * @param tick  the tick.\n     * @param cursor  the cursor.\n     * @param dataArea  the data area.\n     * @param edge  the side on which the axis is displayed.\n     *\n     * @return The anchor point.\n     */\n    @Override\n    protected float[] calculateAnchorPoint(ValueTick tick, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge) {\n        if (tick instanceof CycleBoundTick) {\n            boolean mapsav \u003d this.boundMappedToLastCycle;\n            this.boundMappedToLastCycle\n                \u003d ((CycleBoundTick) tick).mapToLastCycle;\n            float[] ret \u003d super.calculateAnchorPoint(\n                tick, cursor, dataArea, edge\n            );\n            this.boundMappedToLastCycle \u003d mapsav;\n            return ret;\n        }\n        return super.calculateAnchorPoint(tick, cursor, dataArea, edge);\n    }\n\n\n\n    /**\n     * Builds a list of ticks for the axis.  This method is called when the\n     * axis is at the top or bottom of the chart (so the axis is \"horizontal\").\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param edge  the edge.\n     *\n     * @return A list of ticks.\n     */\n    @Override\n    protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        List result \u003d new java.util.ArrayList();\n\n        Font tickLabelFont \u003d getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        double unit \u003d getTickUnit().getSize();\n        double cycleBound \u003d getCycleBound();\n        double currentTickValue \u003d Math.ceil(cycleBound / unit) * unit;\n        double upperValue \u003d getRange().getUpperBound();\n        boolean cycled \u003d false;\n\n        boolean boundMapping \u003d this.boundMappedToLastCycle;\n        this.boundMappedToLastCycle \u003d false;\n\n        CycleBoundTick lastTick \u003d null;\n        float lastX \u003d 0.0f;\n\n        if (upperValue \u003d\u003d cycleBound) {\n            currentTickValue \u003d calculateLowestVisibleTickValue();\n            cycled \u003d true;\n            this.boundMappedToLastCycle \u003d true;\n        }\n\n        while (currentTickValue \u003c\u003d upperValue) {\n\n            // Cycle when necessary\n            boolean cyclenow \u003d false;\n            if ((currentTickValue + unit \u003e upperValue) \u0026\u0026 !cycled) {\n                cyclenow \u003d true;\n            }\n\n            double xx \u003d valueToJava2D(currentTickValue, dataArea, edge);\n            String tickLabel;\n            NumberFormat formatter \u003d getNumberFormatOverride();\n            if (formatter !\u003d null) {\n                tickLabel \u003d formatter.format(currentTickValue);\n            }\n            else {\n                tickLabel \u003d getTickUnit().valueToString(currentTickValue);\n            }\n            float x \u003d (float) xx;\n            TextAnchor anchor;\n            TextAnchor rotationAnchor;\n            double angle \u003d 0.0;\n            if (isVerticalTickLabels()) {\n                if (edge \u003d\u003d RectangleEdge.TOP) {\n                    angle \u003d Math.PI / 2.0;\n                }\n                else {\n                    angle \u003d -Math.PI / 2.0;\n                }\n                anchor \u003d TextAnchor.CENTER_RIGHT;\n                // If tick overlap when cycling, update last tick too\n                if ((lastTick !\u003d null) \u0026\u0026 (lastX \u003d\u003d x)\n                        \u0026\u0026 (currentTickValue !\u003d cycleBound)) {\n                    anchor \u003d isInverted()\n                        ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT;\n                    result.remove(result.size() - 1);\n                    result.add(new CycleBoundTick(\n                        this.boundMappedToLastCycle, lastTick.getNumber(),\n                        lastTick.getText(), anchor, anchor,\n                        lastTick.getAngle())\n                    );\n                    this.internalMarkerWhenTicksOverlap \u003d true;\n                    anchor \u003d isInverted()\n                        ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT;\n                }\n                rotationAnchor \u003d anchor;\n            }\n            else {\n                if (edge \u003d\u003d RectangleEdge.TOP) {\n                    anchor \u003d TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick !\u003d null) \u0026\u0026 (lastX \u003d\u003d x)\n                            \u0026\u0026 (currentTickValue !\u003d cycleBound)) {\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap \u003d true;\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor \u003d anchor;\n                }\n                else {\n                    anchor \u003d TextAnchor.TOP_CENTER;\n                    if ((lastTick !\u003d null) \u0026\u0026 (lastX \u003d\u003d x)\n                            \u0026\u0026 (currentTickValue !\u003d cycleBound)) {\n                        anchor \u003d isInverted()\n                            ? TextAnchor.TOP_LEFT : TextAnchor.TOP_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap \u003d true;\n                        anchor \u003d isInverted()\n                            ? TextAnchor.TOP_RIGHT : TextAnchor.TOP_LEFT;\n                    }\n                    rotationAnchor \u003d anchor;\n                }\n            }\n\n            CycleBoundTick tick \u003d new CycleBoundTick(this.boundMappedToLastCycle, \n                    currentTickValue, tickLabel, anchor, rotationAnchor, angle);\n            if (currentTickValue \u003d\u003d cycleBound) {\n                this.internalMarkerCycleBoundTick \u003d tick;\n            }\n            result.add(tick);\n            lastTick \u003d tick;\n            lastX \u003d x;\n\n            currentTickValue +\u003d unit;\n\n            if (cyclenow) {\n                currentTickValue \u003d calculateLowestVisibleTickValue();\n                upperValue \u003d cycleBound;\n                cycled \u003d true;\n                this.boundMappedToLastCycle \u003d true;\n            }\n\n        }\n        this.boundMappedToLastCycle \u003d boundMapping;\n        return result;\n\n    }\n\n    /**\n     * Builds a list of ticks for the axis.  This method is called when the\n     * axis is at the left or right of the chart (so the axis is \"vertical\").\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param edge  the edge.\n     *\n     * @return A list of ticks.\n     */\n    protected List refreshVerticalTicks(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        List result \u003d new java.util.ArrayList();\n        result.clear();\n\n        Font tickLabelFont \u003d getTickLabelFont();\n        g2.setFont(tickLabelFont);\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        double unit \u003d getTickUnit().getSize();\n        double cycleBound \u003d getCycleBound();\n        double currentTickValue \u003d Math.ceil(cycleBound / unit) * unit;\n        double upperValue \u003d getRange().getUpperBound();\n        boolean cycled \u003d false;\n\n        boolean boundMapping \u003d this.boundMappedToLastCycle;\n        this.boundMappedToLastCycle \u003d true;\n\n        NumberTick lastTick \u003d null;\n        float lastY \u003d 0.0f;\n\n        if (upperValue \u003d\u003d cycleBound) {\n            currentTickValue \u003d calculateLowestVisibleTickValue();\n            cycled \u003d true;\n            this.boundMappedToLastCycle \u003d true;\n        }\n\n        while (currentTickValue \u003c\u003d upperValue) {\n\n            // Cycle when necessary\n            boolean cyclenow \u003d false;\n            if ((currentTickValue + unit \u003e upperValue) \u0026\u0026 !cycled) {\n                cyclenow \u003d true;\n            }\n\n            double yy \u003d valueToJava2D(currentTickValue, dataArea, edge);\n            String tickLabel;\n            NumberFormat formatter \u003d getNumberFormatOverride();\n            if (formatter !\u003d null) {\n                tickLabel \u003d formatter.format(currentTickValue);\n            }\n            else {\n                tickLabel \u003d getTickUnit().valueToString(currentTickValue);\n            }\n\n            float y \u003d (float) yy;\n            TextAnchor anchor;\n            TextAnchor rotationAnchor;\n            double angle \u003d 0.0;\n            if (isVerticalTickLabels()) {\n\n                if (edge \u003d\u003d RectangleEdge.LEFT) {\n                    anchor \u003d TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick !\u003d null) \u0026\u0026 (lastY \u003d\u003d y)\n                            \u0026\u0026 (currentTickValue !\u003d cycleBound)) {\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap \u003d true;\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor \u003d anchor;\n                    angle \u003d -Math.PI / 2.0;\n                }\n                else {\n                    anchor \u003d TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick !\u003d null) \u0026\u0026 (lastY \u003d\u003d y)\n                            \u0026\u0026 (currentTickValue !\u003d cycleBound)) {\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap \u003d true;\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                    }\n                    rotationAnchor \u003d anchor;\n                    angle \u003d Math.PI / 2.0;\n                }\n            }\n            else {\n                if (edge \u003d\u003d RectangleEdge.LEFT) {\n                    anchor \u003d TextAnchor.CENTER_RIGHT;\n                    if ((lastTick !\u003d null) \u0026\u0026 (lastY \u003d\u003d y)\n                            \u0026\u0026 (currentTickValue !\u003d cycleBound)) {\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap \u003d true;\n                        anchor \u003d isInverted()\n                            ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT;\n                    }\n                    rotationAnchor \u003d anchor;\n                }\n                else {\n                    anchor \u003d TextAnchor.CENTER_LEFT;\n                    if ((lastTick !\u003d null) \u0026\u0026 (lastY \u003d\u003d y)\n                            \u0026\u0026 (currentTickValue !\u003d cycleBound)) {\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.TOP_LEFT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap \u003d true;\n                        anchor \u003d isInverted()\n                            ? TextAnchor.TOP_LEFT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor \u003d anchor;\n                }\n            }\n\n            CycleBoundTick tick \u003d new CycleBoundTick(this.boundMappedToLastCycle, \n                    currentTickValue, tickLabel, anchor, rotationAnchor, angle);\n            if (currentTickValue \u003d\u003d cycleBound) {\n                this.internalMarkerCycleBoundTick \u003d tick;\n            }\n            result.add(tick);\n            lastTick \u003d tick;\n            lastY \u003d y;\n\n            if (currentTickValue \u003d\u003d cycleBound) {\n                this.internalMarkerCycleBoundTick \u003d tick;\n            }\n\n            currentTickValue +\u003d unit;\n\n            if (cyclenow) {\n                currentTickValue \u003d calculateLowestVisibleTickValue();\n                upperValue \u003d cycleBound;\n                cycled \u003d true;\n                this.boundMappedToLastCycle \u003d false;\n            }\n\n        }\n        this.boundMappedToLastCycle \u003d boundMapping;\n        return result;\n    }\n\n    /**\n     * Converts a coordinate from Java 2D space to data space.\n     *\n     * @param java2DValue  the coordinate in Java2D space.\n     * @param dataArea  the data area.\n     * @param edge  the edge.\n     *\n     * @return The data value.\n     */\n    @Override\n    public double java2DToValue(double java2DValue, Rectangle2D dataArea,\n            RectangleEdge edge) {\n        Range range \u003d getRange();\n\n        double vmax \u003d range.getUpperBound();\n        double vp \u003d getCycleBound();\n\n        double jmin \u003d 0.0;\n        double jmax \u003d 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            jmin \u003d dataArea.getMinX();\n            jmax \u003d dataArea.getMaxX();\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            jmin \u003d dataArea.getMaxY();\n            jmax \u003d dataArea.getMinY();\n        }\n\n        if (isInverted()) {\n            double jbreak \u003d jmax - (vmax - vp) * (jmax - jmin) / this.period;\n            if (java2DValue \u003e\u003d jbreak) {\n                return vp + (jmax - java2DValue) * this.period / (jmax - jmin);\n            }\n            else {\n                return vp - (java2DValue - jmin) * this.period / (jmax - jmin);\n            }\n        }\n        else {\n            double jbreak \u003d (vmax - vp) * (jmax - jmin) / this.period + jmin;\n            if (java2DValue \u003c\u003d jbreak) {\n                return vp + (java2DValue - jmin) * this.period / (jmax - jmin);\n            }\n            else {\n                return vp - (jmax - java2DValue) * this.period / (jmax - jmin);\n            }\n        }\n    }\n\n    /**\n     * Translates a value from data space to Java 2D space.\n     *\n     * @param value  the data value.\n     * @param dataArea  the data area.\n     * @param edge  the edge.\n     *\n     * @return The Java 2D value.\n     */\n    @Override\n    public double valueToJava2D(double value, Rectangle2D dataArea,\n            RectangleEdge edge) {\n        Range range \u003d getRange();\n\n        double vmin \u003d range.getLowerBound();\n        double vmax \u003d range.getUpperBound();\n        double vp \u003d getCycleBound();\n\n        if ((value \u003c vmin) || (value \u003e vmax)) {\n            return Double.NaN;\n        }\n\n\n        double jmin \u003d 0.0;\n        double jmax \u003d 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            jmin \u003d dataArea.getMinX();\n            jmax \u003d dataArea.getMaxX();\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            jmax \u003d dataArea.getMinY();\n            jmin \u003d dataArea.getMaxY();\n        }\n\n        if (isInverted()) {\n            if (value \u003d\u003d vp) {\n                return this.boundMappedToLastCycle ? jmin : jmax;\n            }\n            else if (value \u003e vp) {\n                return jmax - (value - vp) * (jmax - jmin) / this.period;\n            }\n            else {\n                return jmin + (vp - value) * (jmax - jmin) / this.period;\n            }\n        }\n        else {\n            if (value \u003d\u003d vp) {\n                return this.boundMappedToLastCycle ? jmax : jmin;\n            }\n            else if (value \u003e\u003d vp) {\n                return jmin + (value - vp) * (jmax - jmin) / this.period;\n            }\n            else {\n                return jmax - (vp - value) * (jmax - jmin) / this.period;\n            }\n        }\n    }\n\n    /**\n     * Centers the range about the given value.\n     *\n     * @param value  the data value.\n     */\n    @Override\n    public void centerRange(double value) {\n        setRange(value - this.period / 2.0, value + this.period / 2.0);\n    }\n\n    /**\n     * This function is nearly useless since the auto range is fixed for this\n     * class to the period.  The period is extended if necessary to fit the\n     * minimum size.\n     *\n     * @param size  the size.\n     * @param notify  notify?\n     *\n     * @see org.jfree.chart.axis.ValueAxis#setAutoRangeMinimumSize(double,\n     *      boolean)\n     */\n    @Override\n    public void setAutoRangeMinimumSize(double size, boolean notify) {\n        if (size \u003e this.period) {\n            this.period \u003d size;\n        }\n        super.setAutoRangeMinimumSize(size, notify);\n    }\n\n    /**\n     * The auto range is fixed for this class to the period by default.\n     * This function will thus set a new period.\n     *\n     * @param length  the length.\n     *\n     * @see org.jfree.chart.axis.ValueAxis#setFixedAutoRange(double)\n     */\n    @Override\n    public void setFixedAutoRange(double length) {\n        this.period \u003d length;\n        super.setFixedAutoRange(length);\n    }\n\n    /**\n     * Sets a new axis range. The period is extended to fit the range size, if\n     * necessary.\n     *\n     * @param range  the range.\n     * @param turnOffAutoRange  switch off the auto range.\n     * @param notify notify?\n     *\n     * @see org.jfree.chart.axis.ValueAxis#setRange(Range, boolean, boolean)\n     */\n    @Override\n    public void setRange(Range range, boolean turnOffAutoRange,\n            boolean notify) {\n        double size \u003d range.getUpperBound() - range.getLowerBound();\n        if (size \u003e this.period) {\n            this.period \u003d size;\n        }\n        super.setRange(range, turnOffAutoRange, notify);\n    }\n\n    /**\n     * The cycle bound is defined as the higest value x such that\n     * \"offset + period * i \u003d x\", with i and integer and x \u0026lt;\n     * range.getUpperBound() This is the value which is at both ends of the\n     * axis :  x...up|low...x\n     * The values from x to up are the valued in the current cycle.\n     * The values from low to x are the valued in the previous cycle.\n     *\n     * @return The cycle bound.\n     */\n    public double getCycleBound() {\n        return Math.floor(\n            (getRange().getUpperBound() - this.offset) / this.period\n        ) * this.period + this.offset;\n    }\n\n    /**\n     * The cycle bound is a multiple of the period, plus optionally a start\n     * offset.\n     * \u003cpre\u003ecb \u003d n * period + offset\u003c/pre\u003e\n     *\n     * @return The current offset.\n     *\n     * @see #getCycleBound()\n     */\n    public double getOffset() {\n        return this.offset;\n    }\n\n    /**\n     * The cycle bound is a multiple of the period, plus optionally a start\n     * offset.\n     * \u003cpre\u003ecb \u003d n * period + offset\u003c/pre\u003e\n     *\n     * @param offset The offset to set.\n     *\n     * @see #getCycleBound()\n     */\n    public void setOffset(double offset) {\n        this.offset \u003d offset;\n    }\n\n    /**\n     * The cycle bound is a multiple of the period, plus optionally a start\n     * offset.\n     * \u003cpre\u003ecb \u003d n * period + offset\u003c/pre\u003e\n     *\n     * @return The current period.\n     *\n     * @see #getCycleBound()\n     */\n    public double getPeriod() {\n        return this.period;\n    }\n\n    /**\n     * The cycle bound is a multiple of the period, plus optionally a start\n     * offset.\n     * \u003cpre\u003ecb \u003d n * period + offset\u003c/pre\u003e\n     *\n     * @param period The period to set.\n     *\n     * @see #getCycleBound()\n     */\n    public void setPeriod(double period) {\n        this.period \u003d period;\n    }\n\n    /**\n     * Draws the tick marks and labels.\n     *\n     * @param g2  the graphics device.\n     * @param cursor  the cursor.\n     * @param plotArea  the plot area.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the side on which the axis is displayed.\n     *\n     * @return The axis state.\n     */\n    @Override\n    protected AxisState drawTickMarksAndLabels(Graphics2D g2, double cursor,\n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge) {\n        this.internalMarkerWhenTicksOverlap \u003d false;\n        AxisState ret \u003d super.drawTickMarksAndLabels(g2, cursor, plotArea,\n                dataArea, edge);\n\n        // continue and separate the labels only if necessary\n        if (!this.internalMarkerWhenTicksOverlap) {\n            return ret;\n        }\n\n        double ol;\n        FontMetrics fm \u003d g2.getFontMetrics(getTickLabelFont());\n        if (isVerticalTickLabels()) {\n            ol \u003d fm.getMaxAdvance();\n        }\n        else {\n            ol \u003d fm.getHeight();\n        }\n\n        double il \u003d 0;\n        if (isTickMarksVisible()) {\n            float xx \u003d (float) valueToJava2D(getRange().getUpperBound(),\n                    dataArea, edge);\n            Line2D mark \u003d null;\n            g2.setStroke(getTickMarkStroke());\n            g2.setPaint(getTickMarkPaint());\n            if (edge \u003d\u003d RectangleEdge.LEFT) {\n                mark \u003d new Line2D.Double(cursor - ol, xx, cursor + il, xx);\n            }\n            else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n                mark \u003d new Line2D.Double(cursor + ol, xx, cursor - il, xx);\n            }\n            else if (edge \u003d\u003d RectangleEdge.TOP) {\n                mark \u003d new Line2D.Double(xx, cursor - ol, xx, cursor + il);\n            }\n            else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n                mark \u003d new Line2D.Double(xx, cursor + ol, xx, cursor - il);\n            }\n            g2.draw(mark);\n        }\n        return ret;\n    }\n\n    /**\n     * Draws the axis.\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param cursor  the cursor position.\n     * @param plotArea  the plot area ({@code null} not permitted).\n     * @param dataArea  the data area ({@code null} not permitted).\n     * @param edge  the edge ({@code null} not permitted).\n     * @param plotState  collects information about the plot\n     *                   ({@code null} permitted).\n     *\n     * @return The axis state (never {@code null}).\n     */\n    @Override\n    public AxisState draw(Graphics2D g2, double cursor, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, PlotRenderingInfo plotState) {\n\n        AxisState ret \u003d super.draw(g2, cursor, plotArea, dataArea, edge, \n                plotState);\n        if (isAdvanceLineVisible()) {\n            double xx \u003d valueToJava2D(getRange().getUpperBound(), dataArea, \n                    edge);\n            Line2D mark \u003d null;\n            g2.setStroke(getAdvanceLineStroke());\n            g2.setPaint(getAdvanceLinePaint());\n            if (edge \u003d\u003d RectangleEdge.LEFT) {\n                mark \u003d new Line2D.Double(cursor, xx, cursor \n                        + dataArea.getWidth(), xx);\n            }\n            else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n                mark \u003d new Line2D.Double(cursor - dataArea.getWidth(), xx, \n                        cursor, xx);\n            }\n            else if (edge \u003d\u003d RectangleEdge.TOP) {\n                mark \u003d new Line2D.Double(xx, cursor + dataArea.getHeight(), xx, \n                        cursor);\n            }\n            else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n                mark \u003d new Line2D.Double(xx, cursor, xx, \n                        cursor - dataArea.getHeight());\n            }\n            g2.draw(mark);\n        }\n        return ret;\n    }\n\n    /**\n     * Reserve some space on each axis side because we draw a centered label at\n     * each extremity.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param plotArea  the plot area.\n     * @param edge  the edge.\n     * @param space  the space already reserved.\n     *\n     * @return The reserved space.\n     */\n    @Override\n    public AxisSpace reserveSpace(Graphics2D g2, Plot plot,\n            Rectangle2D plotArea, RectangleEdge edge, AxisSpace space) {\n\n        this.internalMarkerCycleBoundTick \u003d null;\n        AxisSpace ret \u003d super.reserveSpace(g2, plot, plotArea, edge, space);\n        if (this.internalMarkerCycleBoundTick \u003d\u003d null) {\n            return ret;\n        }\n\n        FontMetrics fm \u003d g2.getFontMetrics(getTickLabelFont());\n        Rectangle2D r \u003d TextUtils.getTextBounds(\n            this.internalMarkerCycleBoundTick.getText(), g2, fm\n        );\n\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            if (isVerticalTickLabels()) {\n                space.add(r.getHeight() / 2, RectangleEdge.RIGHT);\n            }\n            else {\n                space.add(r.getWidth() / 2, RectangleEdge.RIGHT);\n            }\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            if (isVerticalTickLabels()) {\n                space.add(r.getWidth() / 2, RectangleEdge.TOP);\n            }\n            else {\n                space.add(r.getHeight() / 2, RectangleEdge.TOP);\n            }\n        }\n\n        return ret;\n\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writePaint(this.advanceLinePaint, stream);\n        SerialUtils.writeStroke(this.advanceLineStroke, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n            throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.advanceLinePaint \u003d SerialUtils.readPaint(stream);\n        this.advanceLineStroke \u003d SerialUtils.readStroke(stream);\n    }\n\n\n    /**\n     * Tests the axis for equality with another object.\n     *\n     * @param obj  the object to test against.\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof CyclicNumberAxis)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        CyclicNumberAxis that \u003d (CyclicNumberAxis) obj;\n        if (this.period !\u003d that.period) {\n            return false;\n        }\n        if (this.offset !\u003d that.offset) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.advanceLinePaint,\n                that.advanceLinePaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.advanceLineStroke, that.advanceLineStroke)) {\n            return false;\n        }\n        if (this.advanceLineVisible !\u003d that.advanceLineVisible) {\n            return false;\n        }\n        if (this.boundMappedToLastCycle !\u003d that.boundMappedToLastCycle) {\n            return false;\n        }\n        return true;\n    }\n}","methodCount":35,"staticMethodCount":0,"instanceMethodCount":35,"classLoc":1102,"innerClassCount":1},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"80060d9a-b95f-4deb-889f-0c99025c4bfe","hostFunctionTelemetryData":{"hostFunctionSize":1744,"lineStart":78,"lineEnd":1821,"bodyLineStart":78,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/axis/DateAxis.java","sourceCode":"/**\n * The base class for axes that display dates.  You will find it easier to\n * understand how this axis works if you bear in mind that it really\n * displays/measures integer (or long) data, where the integers are\n * milliseconds since midnight, 1-Jan-1970.  When displaying tick labels, the\n * millisecond values are converted back to dates using a {@code DateFormat} \n * instance.\n * \u003cP\u003e\n * You can also create a {@link org.jfree.chart.axis.Timeline} and supply in\n * the constructor to create an axis that only contains certain domain values.\n * For example, this allows you to create a date axis that only contains\n * working days.\n */\npublic class DateAxis extends ValueAxis implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -1013460999649007604L;\n\n    /** The default axis range. */\n    public static final DateRange DEFAULT_DATE_RANGE \u003d new DateRange();\n\n    /** The default minimum auto range size. */\n    public static final double\n            DEFAULT_AUTO_RANGE_MINIMUM_SIZE_IN_MILLISECONDS \u003d 2.0;\n\n    /** The default anchor date. */\n    public static final Date DEFAULT_ANCHOR_DATE \u003d new Date();\n\n    /** The current tick unit. */\n    private DateTickUnit tickUnit;\n\n    /** The override date format. */\n    private DateFormat dateFormatOverride;\n\n    /**\n     * Tick marks can be displayed at the start or the middle of the time\n     * period.\n     */\n    private DateTickMarkPosition tickMarkPosition \u003d DateTickMarkPosition.START;\n\n    /**\n     * A timeline that includes all milliseconds (as defined by\n     * {@code java.util.Date}) in the real time line.\n     */\n    private static class DefaultTimeline implements Timeline, Serializable {\n\n        /**\n         * Converts a millisecond into a timeline value.\n         *\n         * @param millisecond  the millisecond.\n         *\n         * @return The timeline value.\n         */\n        @Override\n        public long toTimelineValue(long millisecond) {\n            return millisecond;\n        }\n\n        /**\n         * Converts a date into a timeline value.\n         *\n         * @param date  the domain value.\n         *\n         * @return The timeline value.\n         */\n        @Override\n        public long toTimelineValue(Date date) {\n            return date.getTime();\n        }\n\n        /**\n         * Converts a timeline value into a millisecond (as encoded by\n         * {@code java.util.Date}).\n         *\n         * @param value  the value.\n         *\n         * @return The millisecond.\n         */\n        @Override\n        public long toMillisecond(long value) {\n            return value;\n        }\n\n        /**\n         * Returns {@code true} if the timeline includes the specified\n         * domain value.\n         *\n         * @param millisecond  the millisecond.\n         *\n         * @return {@code true}.\n         */\n        @Override\n        public boolean containsDomainValue(long millisecond) {\n            return true;\n        }\n\n        /**\n         * Returns {@code true} if the timeline includes the specified\n         * domain value.\n         *\n         * @param date  the date.\n         *\n         * @return {@code true}.\n         */\n        @Override\n        public boolean containsDomainValue(Date date) {\n            return true;\n        }\n\n        /**\n         * Returns {@code true} if the timeline includes the specified\n         * domain value range.\n         *\n         * @param from  the start value.\n         * @param to  the end value.\n         *\n         * @return {@code true}.\n         */\n        @Override\n        public boolean containsDomainRange(long from, long to) {\n            return true;\n        }\n\n        /**\n         * Returns {@code true} if the timeline includes the specified\n         * domain value range.\n         *\n         * @param from  the start date.\n         * @param to  the end date.\n         *\n         * @return {@code true}.\n         */\n        @Override\n        public boolean containsDomainRange(Date from, Date to) {\n            return true;\n        }\n\n        /**\n         * Tests an object for equality with this instance.\n         *\n         * @param object  the object.\n         *\n         * @return A boolean.\n         */\n        @Override\n        public boolean equals(Object object) {\n            if (object \u003d\u003d null) {\n                return false;\n            }\n            if (object \u003d\u003d this) {\n                return true;\n            }\n            if (object instanceof DefaultTimeline) {\n                return true;\n            }\n            return false;\n        }\n    }\n\n    /** A static default timeline shared by all standard DateAxis */\n    private static final Timeline DEFAULT_TIMELINE \u003d new DefaultTimeline();\n\n    /** The time zone for the axis. */\n    private TimeZone timeZone;\n\n    /**\n     * The locale for the axis ({@code null} is not permitted).\n     */\n    private Locale locale;\n\n    /** Our underlying timeline. */\n    private Timeline timeline;\n\n    /**\n     * Creates a date axis with no label.\n     */\n    public DateAxis() {\n        this(null);\n    }\n\n    /**\n     * Creates a date axis with the specified label.\n     *\n     * @param label  the axis label ({@code null} permitted).\n     */\n    public DateAxis(String label) {\n        this(label, TimeZone.getDefault(), Locale.getDefault());\n    }\n\n    /**\n     * Creates a date axis.\n     *\n     * @param label  the axis label ({@code null} permitted).\n     * @param zone  the time zone.\n     * @param locale  the locale ({@code null} not permitted).\n     */\n    public DateAxis(String label, TimeZone zone, Locale locale) {\n        super(label, DateAxis.createStandardDateTickUnits(zone, locale));\n        this.tickUnit \u003d new DateTickUnit(DateTickUnitType.DAY, 1, \n                new SimpleDateFormat());\n        setAutoRangeMinimumSize(\n                DEFAULT_AUTO_RANGE_MINIMUM_SIZE_IN_MILLISECONDS);\n        setRange(DEFAULT_DATE_RANGE, false, false);\n        this.dateFormatOverride \u003d null;\n        this.timeZone \u003d zone;\n        this.locale \u003d locale;\n        this.timeline \u003d DEFAULT_TIMELINE;\n    }\n\n    /**\n     * Returns the time zone for the axis.\n     *\n     * @return The time zone (never {@code null}).\n     *\n     * @see #setTimeZone(TimeZone)\n     */\n    public TimeZone getTimeZone() {\n        return this.timeZone;\n    }\n\n    /**\n     * Sets the time zone for the axis and sends an {@link AxisChangeEvent} to\n     * all registered listeners.\n     *\n     * @param zone  the time zone ({@code null} not permitted).\n     *\n     * @see #getTimeZone()\n     */\n    public void setTimeZone(TimeZone zone) {\n        Args.nullNotPermitted(zone, \"zone\");\n        this.timeZone \u003d zone;\n        setStandardTickUnits(createStandardDateTickUnits(zone, this.locale));\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the locale for this axis.\n     * \n     * @return The locale (never {@code null}).\n     */\n    public Locale getLocale() {\n        return this.locale;\n    }\n    \n    /**\n     * Sets the locale for the axis and sends a change event to all registered \n     * listeners.\n     * \n     * @param locale  the new locale ({@code null} not permitted).\n     */\n    public void setLocale(Locale locale) {\n        Args.nullNotPermitted(locale, \"locale\");\n        this.locale \u003d locale;\n        setStandardTickUnits(createStandardDateTickUnits(this.timeZone, \n                this.locale));\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the underlying timeline used by this axis.\n     *\n     * @return The timeline.\n     */\n    public Timeline getTimeline() {\n        return this.timeline;\n    }\n\n    /**\n     * Sets the underlying timeline to use for this axis.  If the timeline is \n     * changed, an {@link AxisChangeEvent} is sent to all registered listeners.\n     *\n     * @param timeline  the timeline.\n     */\n    public void setTimeline(Timeline timeline) {\n        if (this.timeline !\u003d timeline) {\n            this.timeline \u003d timeline;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the tick unit for the axis.\n     * \u003cp\u003e\n     * Note: if the {@code autoTickUnitSelection} flag is\n     * {@code true} the tick unit may be changed while the axis is being\n     * drawn, so in that case the return value from this method may be\n     * irrelevant if the method is called before the axis has been drawn.\n     *\n     * @return The tick unit (possibly {@code null}).\n     *\n     * @see #setTickUnit(DateTickUnit)\n     * @see ValueAxis#isAutoTickUnitSelection()\n     */\n    public DateTickUnit getTickUnit() {\n        return this.tickUnit;\n    }\n\n    /**\n     * Sets the tick unit for the axis.  The auto-tick-unit-selection flag is\n     * set to {@code false}, and registered listeners are notified that\n     * the axis has been changed.\n     *\n     * @param unit  the tick unit.\n     *\n     * @see #getTickUnit()\n     * @see #setTickUnit(DateTickUnit, boolean, boolean)\n     */\n    public void setTickUnit(DateTickUnit unit) {\n        setTickUnit(unit, true, true);\n    }\n\n    /**\n     * Sets the tick unit attribute and, if requested, sends an \n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param unit  the new tick unit.\n     * @param notify  notify registered listeners?\n     * @param turnOffAutoSelection  turn off auto selection?\n     *\n     * @see #getTickUnit()\n     */\n    public void setTickUnit(DateTickUnit unit, boolean notify,\n                            boolean turnOffAutoSelection) {\n\n        this.tickUnit \u003d unit;\n        if (turnOffAutoSelection) {\n            setAutoTickUnitSelection(false, false);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n\n    }\n\n    /**\n     * Returns the date format override.  If this is non-null, then it will be\n     * used to format the dates on the axis.\n     *\n     * @return The formatter (possibly {@code null}).\n     */\n    public DateFormat getDateFormatOverride() {\n        return this.dateFormatOverride;\n    }\n\n    /**\n     * Sets the date format override and sends an {@link AxisChangeEvent} to \n     * all registered listeners.  If this is non-null, then it will be\n     * used to format the dates on the axis.\n     *\n     * @param formatter  the date formatter ({@code null} permitted).\n     */\n    public void setDateFormatOverride(DateFormat formatter) {\n        this.dateFormatOverride \u003d formatter;\n        fireChangeEvent();\n    }\n\n    /**\n     * Sets the upper and lower bounds for the axis and sends an\n     * {@link AxisChangeEvent} to all registered listeners.  As a side-effect,\n     * the auto-range flag is set to false.\n     *\n     * @param range  the new range ({@code null} not permitted).\n     */\n    @Override\n    public void setRange(Range range) {\n        setRange(range, true, true);\n    }\n\n    /**\n     * Sets the range for the axis, if requested, sends an\n     * {@link AxisChangeEvent} to all registered listeners.  As a side-effect,\n     * the auto-range flag is set to {@code false} (optional).\n     *\n     * @param range  the range ({@code null} not permitted).\n     * @param turnOffAutoRange  a flag that controls whether or not the auto\n     *                          range is turned off.\n     * @param notify  a flag that controls whether or not listeners are\n     *                notified.\n     */\n    @Override\n    public void setRange(Range range, boolean turnOffAutoRange,\n                         boolean notify) {\n        Args.nullNotPermitted(range, \"range\");\n        // usually the range will be a DateRange, but if it isn\u0027t do a\n        // conversion...\n        if (!(range instanceof DateRange)) {\n            range \u003d new DateRange(range);\n        }\n        super.setRange(range, turnOffAutoRange, notify);\n    }\n\n    /**\n     * Sets the axis range and sends an {@link AxisChangeEvent} to all\n     * registered listeners.\n     *\n     * @param lower  the lower bound for the axis.\n     * @param upper  the upper bound for the axis.\n     */\n    public void setRange(Date lower, Date upper) {\n        if (lower.getTime() \u003e\u003d upper.getTime()) {\n            throw new IllegalArgumentException(\"Requires \u0027lower\u0027 \u003c \u0027upper\u0027.\");\n        }\n        setRange(new DateRange(lower, upper));\n    }\n\n    /**\n     * Sets the axis range and sends an {@link AxisChangeEvent} to all\n     * registered listeners.\n     *\n     * @param lower  the lower bound for the axis.\n     * @param upper  the upper bound for the axis.\n     */\n    @Override\n    public void setRange(double lower, double upper) {\n        if (lower \u003e\u003d upper) {\n            throw new IllegalArgumentException(\"Requires \u0027lower\u0027 \u003c \u0027upper\u0027.\");\n        }\n        setRange(new DateRange(lower, upper));\n    }\n\n    /**\n     * Returns the earliest date visible on the axis.\n     *\n     * @return The date.\n     *\n     * @see #setMinimumDate(Date)\n     * @see #getMaximumDate()\n     */\n    public Date getMinimumDate() {\n        Date result;\n        Range range \u003d getRange();\n        if (range instanceof DateRange) {\n            DateRange r \u003d (DateRange) range;\n            result \u003d r.getLowerDate();\n        }\n        else {\n            result \u003d new Date((long) range.getLowerBound());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the minimum date visible on the axis and sends an\n     * {@link AxisChangeEvent} to all registered listeners.  If\n     * {@code date} is on or after the current maximum date for\n     * the axis, the maximum date will be shifted to preserve the current\n     * length of the axis.\n     *\n     * @param date  the date ({@code null} not permitted).\n     *\n     * @see #getMinimumDate()\n     * @see #setMaximumDate(Date)\n     */\n    public void setMinimumDate(Date date) {\n        Args.nullNotPermitted(date, \"date\");\n        // check the new minimum date relative to the current maximum date\n        Date maxDate \u003d getMaximumDate();\n        long maxMillis \u003d maxDate.getTime();\n        long newMinMillis \u003d date.getTime();\n        if (maxMillis \u003c\u003d newMinMillis) {\n            Date oldMin \u003d getMinimumDate();\n            long length \u003d maxMillis - oldMin.getTime();\n            maxDate \u003d new Date(newMinMillis + length);\n        }\n        setRange(new DateRange(date, maxDate), true, false);\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the latest date visible on the axis.\n     *\n     * @return The date.\n     *\n     * @see #setMaximumDate(Date)\n     * @see #getMinimumDate()\n     */\n    public Date getMaximumDate() {\n        Date result;\n        Range range \u003d getRange();\n        if (range instanceof DateRange) {\n            DateRange r \u003d (DateRange) range;\n            result \u003d r.getUpperDate();\n        }\n        else {\n            result \u003d new Date((long) range.getUpperBound());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the maximum date visible on the axis and sends an\n     * {@link AxisChangeEvent} to all registered listeners.  If\n     * {@code maximumDate} is on or before the current minimum date for\n     * the axis, the minimum date will be shifted to preserve the current\n     * length of the axis.\n     *\n     * @param maximumDate  the date ({@code null} not permitted).\n     *\n     * @see #getMinimumDate()\n     * @see #setMinimumDate(Date)\n     */\n    public void setMaximumDate(Date maximumDate) {\n        Args.nullNotPermitted(maximumDate, \"maximumDate\");\n        // check the new maximum date relative to the current minimum date\n        Date minDate \u003d getMinimumDate();\n        long minMillis \u003d minDate.getTime();\n        long newMaxMillis \u003d maximumDate.getTime();\n        if (minMillis \u003e\u003d newMaxMillis) {\n            Date oldMax \u003d getMaximumDate();\n            long length \u003d oldMax.getTime() - minMillis;\n            minDate \u003d new Date(newMaxMillis - length);\n        }\n        setRange(new DateRange(minDate, maximumDate), true, false);\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the tick mark position (start, middle or end of the time period).\n     *\n     * @return The position (never {@code null}).\n     */\n    public DateTickMarkPosition getTickMarkPosition() {\n        return this.tickMarkPosition;\n    }\n\n    /**\n     * Sets the tick mark position (start, middle or end of the time period)\n     * and sends an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param position  the position ({@code null} not permitted).\n     */\n    public void setTickMarkPosition(DateTickMarkPosition position) {\n        Args.nullNotPermitted(position, \"position\");\n        this.tickMarkPosition \u003d position;\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the axis to work with the specified plot.  If the axis has\n     * auto-scaling, then sets the maximum and minimum values.\n     */\n    @Override\n    public void configure() {\n        if (isAutoRange()) {\n            autoAdjustRange();\n        }\n    }\n\n    /**\n     * Returns {@code true} if the axis hides this value, and\n     * {@code false} otherwise.\n     *\n     * @param millis  the data value.\n     *\n     * @return A value.\n     */\n    public boolean isHiddenValue(long millis) {\n        return (!this.timeline.containsDomainValue(new Date(millis)));\n    }\n\n    /**\n     * Translates the data value to the display coordinates (Java 2D User Space)\n     * of the chart.\n     *\n     * @param value  the date to be plotted.\n     * @param area  the rectangle (in Java2D space) where the data is to be\n     *              plotted.\n     * @param edge  the axis location.\n     *\n     * @return The coordinate corresponding to the supplied data value.\n     */\n    @Override\n    public double valueToJava2D(double value, Rectangle2D area,\n            RectangleEdge edge) {\n\n        value \u003d this.timeline.toTimelineValue((long) value);\n\n        DateRange range \u003d (DateRange) getRange();\n        double axisMin \u003d this.timeline.toTimelineValue(range.getLowerMillis());\n        double axisMax \u003d this.timeline.toTimelineValue(range.getUpperMillis());\n        double result \u003d 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            double minX \u003d area.getX();\n            double maxX \u003d area.getMaxX();\n            if (isInverted()) {\n                result \u003d maxX + ((value - axisMin) / (axisMax - axisMin))\n                         * (minX - maxX);\n            }\n            else {\n                result \u003d minX + ((value - axisMin) / (axisMax - axisMin))\n                         * (maxX - minX);\n            }\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            double minY \u003d area.getMinY();\n            double maxY \u003d area.getMaxY();\n            if (isInverted()) {\n                result \u003d minY + (((value - axisMin) / (axisMax - axisMin))\n                         * (maxY - minY));\n            }\n            else {\n                result \u003d maxY - (((value - axisMin) / (axisMax - axisMin))\n                         * (maxY - minY));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Translates a date to Java2D coordinates, based on the range displayed by\n     * this axis for the specified data area.\n     *\n     * @param date  the date.\n     * @param area  the rectangle (in Java2D space) where the data is to be\n     *              plotted.\n     * @param edge  the axis location.\n     *\n     * @return The coordinate corresponding to the supplied date.\n     */\n    public double dateToJava2D(Date date, Rectangle2D area, \n            RectangleEdge edge) {\n        double value \u003d date.getTime();\n        return valueToJava2D(value, area, edge);\n    }\n\n    /**\n     * Translates a Java2D coordinate into the corresponding data value.  To\n     * perform this translation, you need to know the area used for plotting\n     * data, and which edge the axis is located on.\n     *\n     * @param java2DValue  the coordinate in Java2D space.\n     * @param area  the rectangle (in Java2D space) where the data is to be\n     *              plotted.\n     * @param edge  the axis location.\n     *\n     * @return A data value.\n     */\n    @Override\n    public double java2DToValue(double java2DValue, Rectangle2D area, \n            RectangleEdge edge) {\n\n        DateRange range \u003d (DateRange) getRange();\n        double axisMin \u003d this.timeline.toTimelineValue(range.getLowerMillis());\n        double axisMax \u003d this.timeline.toTimelineValue(range.getUpperMillis());\n\n        double min \u003d 0.0;\n        double max \u003d 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            min \u003d area.getX();\n            max \u003d area.getMaxX();\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            min \u003d area.getMaxY();\n            max \u003d area.getY();\n        }\n\n        double result;\n        if (isInverted()) {\n             result \u003d axisMax - ((java2DValue - min) / (max - min)\n                      * (axisMax - axisMin));\n        }\n        else {\n             result \u003d axisMin + ((java2DValue - min) / (max - min)\n                      * (axisMax - axisMin));\n        }\n\n        return this.timeline.toMillisecond((long) result);\n    }\n\n    /**\n     * Calculates the value of the lowest visible tick on the axis.\n     *\n     * @param unit  date unit to use.\n     *\n     * @return The value of the lowest visible tick on the axis.\n     */\n    public Date calculateLowestVisibleTickValue(DateTickUnit unit) {\n        return nextStandardDate(getMinimumDate(), unit);\n    }\n\n    /**\n     * Calculates the value of the highest visible tick on the axis.\n     *\n     * @param unit  date unit to use.\n     *\n     * @return The value of the highest visible tick on the axis.\n     */\n    public Date calculateHighestVisibleTickValue(DateTickUnit unit) {\n        return previousStandardDate(getMaximumDate(), unit);\n    }\n\n    /**\n     * Returns the previous \"standard\" date, for a given date and tick unit.\n     *\n     * @param date  the reference date.\n     * @param unit  the tick unit.\n     *\n     * @return The previous \"standard\" date.\n     */\n    protected Date previousStandardDate(Date date, DateTickUnit unit) {\n\n        int milliseconds;\n        int seconds;\n        int minutes;\n        int hours;\n        int days;\n        int months;\n        int years;\n\n        Calendar calendar \u003d Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int count \u003d unit.getMultiple();\n        int current \u003d calendar.get(unit.getCalendarField());\n        int value \u003d count * (current / count);\n\n        if (DateTickUnitType.MILLISECOND.equals(unit.getUnitType())) {\n            years \u003d calendar.get(Calendar.YEAR);\n            months \u003d calendar.get(Calendar.MONTH);\n            days \u003d calendar.get(Calendar.DATE);\n            hours \u003d calendar.get(Calendar.HOUR_OF_DAY);\n            minutes \u003d calendar.get(Calendar.MINUTE);\n            seconds \u003d calendar.get(Calendar.SECOND);\n            calendar.set(years, months, days, hours, minutes, seconds);\n            calendar.set(Calendar.MILLISECOND, value);\n            Date mm \u003d calendar.getTime();\n            if (mm.getTime() \u003e\u003d date.getTime()) {\n                calendar.set(Calendar.MILLISECOND, value - count);\n                mm \u003d calendar.getTime();\n            }\n            return mm;\n        }\n        else if (DateTickUnitType.SECOND.equals(unit.getUnitType())) {\n            years \u003d calendar.get(Calendar.YEAR);\n            months \u003d calendar.get(Calendar.MONTH);\n            days \u003d calendar.get(Calendar.DATE);\n            hours \u003d calendar.get(Calendar.HOUR_OF_DAY);\n            minutes \u003d calendar.get(Calendar.MINUTE);\n            if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.START) {\n                milliseconds \u003d 0;\n            }\n            else if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.MIDDLE) {\n                milliseconds \u003d 500;\n            }\n            else {\n                milliseconds \u003d 999;\n            }\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n            calendar.set(years, months, days, hours, minutes, value);\n            Date dd \u003d calendar.getTime();\n            if (dd.getTime() \u003e\u003d date.getTime()) {\n                calendar.set(Calendar.SECOND, value - count);\n                dd \u003d calendar.getTime();\n            }\n            return dd;\n        }\n        else if (DateTickUnitType.MINUTE.equals(unit.getUnitType())) {\n            years \u003d calendar.get(Calendar.YEAR);\n            months \u003d calendar.get(Calendar.MONTH);\n            days \u003d calendar.get(Calendar.DATE);\n            hours \u003d calendar.get(Calendar.HOUR_OF_DAY);\n            if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.START) {\n                seconds \u003d 0;\n            }\n            else if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.MIDDLE) {\n                seconds \u003d 30;\n            }\n            else {\n                seconds \u003d 59;\n            }\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, months, days, hours, value, seconds);\n            Date d0 \u003d calendar.getTime();\n            if (d0.getTime() \u003e\u003d date.getTime()) {\n                calendar.set(Calendar.MINUTE, value - count);\n                d0 \u003d calendar.getTime();\n            }\n            return d0;\n        }\n        else if (DateTickUnitType.HOUR.equals(unit.getUnitType())) {\n            years \u003d calendar.get(Calendar.YEAR);\n            months \u003d calendar.get(Calendar.MONTH);\n            days \u003d calendar.get(Calendar.DATE);\n            if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.START) {\n                minutes \u003d 0;\n                seconds \u003d 0;\n            }\n            else if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.MIDDLE) {\n                minutes \u003d 30;\n                seconds \u003d 0;\n            }\n            else {\n                minutes \u003d 59;\n                seconds \u003d 59;\n            }\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, months, days, value, minutes, seconds);\n            Date d1 \u003d calendar.getTime();\n            if (d1.getTime() \u003e\u003d date.getTime()) {\n                calendar.set(Calendar.HOUR_OF_DAY, value - count);\n                d1 \u003d calendar.getTime();\n            }\n            return d1;\n        }\n        else if (DateTickUnitType.DAY.equals(unit.getUnitType())) {\n            years \u003d calendar.get(Calendar.YEAR);\n            months \u003d calendar.get(Calendar.MONTH);\n            if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.START) {\n                hours \u003d 0;\n            }\n            else if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.MIDDLE) {\n                hours \u003d 12;\n            }\n            else {\n                hours \u003d 23;\n            }\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, months, value, hours, 0, 0);\n            // long result \u003d calendar.getTimeInMillis();\n                // won\u0027t work with JDK 1.3\n            Date d2 \u003d calendar.getTime();\n            if (d2.getTime() \u003e\u003d date.getTime()) {\n                calendar.set(Calendar.DATE, value - count);\n                d2 \u003d calendar.getTime();\n            }\n            return d2;\n        }\n        else if (DateTickUnitType.MONTH.equals(unit.getUnitType())) {\n            value \u003d count * ((current + 1) / count) - 1;\n            years \u003d calendar.get(Calendar.YEAR);\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, value, 1, 0, 0, 0);\n            Month month \u003d new Month(calendar.getTime(), this.timeZone,\n                    this.locale);\n            Date standardDate \u003d calculateDateForPosition(\n                    month, this.tickMarkPosition);\n            long millis \u003d standardDate.getTime();\n            if (millis \u003e\u003d date.getTime()) {\n                for (int i \u003d 0; i \u003c count; i++) {\n                    month \u003d (Month) month.previous();\n                }\n                // need to peg the month in case the time zone isn\u0027t the\n                // default - see bug 2078057\n                month.peg(Calendar.getInstance(this.timeZone));\n                standardDate \u003d calculateDateForPosition(\n                        month, this.tickMarkPosition);\n            }\n            return standardDate;\n        }\n        else if (DateTickUnitType.YEAR.equals(unit.getUnitType())) {\n            if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.START) {\n                months \u003d 0;\n                days \u003d 1;\n            }\n            else if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.MIDDLE) {\n                months \u003d 6;\n                days \u003d 1;\n            }\n            else {\n                months \u003d 11;\n                days \u003d 31;\n            }\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(value, months, days, 0, 0, 0);\n            Date d3 \u003d calendar.getTime();\n            if (d3.getTime() \u003e\u003d date.getTime()) {\n                calendar.set(Calendar.YEAR, value - count);\n                d3 \u003d calendar.getTime();\n            }\n            return d3;\n        }\n        return null;\n    }\n\n    /**\n     * Returns a {@link java.util.Date} corresponding to the specified position\n     * within a {@link RegularTimePeriod}.\n     *\n     * @param period  the period.\n     * @param position  the position ({@code null} not permitted).\n     *\n     * @return A date.\n     */\n    private Date calculateDateForPosition(RegularTimePeriod period,\n            DateTickMarkPosition position) {\n        Args.nullNotPermitted(period, \"period\");\n        Date result \u003d null;\n        if (position \u003d\u003d DateTickMarkPosition.START) {\n            result \u003d new Date(period.getFirstMillisecond());\n        }\n        else if (position \u003d\u003d DateTickMarkPosition.MIDDLE) {\n            result \u003d new Date(period.getMiddleMillisecond());\n        }\n        else if (position \u003d\u003d DateTickMarkPosition.END) {\n            result \u003d new Date(period.getLastMillisecond());\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the first \"standard\" date (based on the specified field and\n     * units).\n     *\n     * @param date  the reference date.\n     * @param unit  the date tick unit.\n     *\n     * @return The next \"standard\" date.\n     */\n    protected Date nextStandardDate(Date date, DateTickUnit unit) {\n        Date previous \u003d previousStandardDate(date, unit);\n        Calendar calendar \u003d Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(previous);\n        calendar.add(unit.getCalendarField(), unit.getMultiple());\n        return calendar.getTime();\n    }\n\n    /**\n     * Returns a collection of standard date tick units that uses the default\n     * time zone.  This collection will be used by default, but you are free\n     * to create your own collection if you want to (see the\n     * {@link ValueAxis#setStandardTickUnits(TickUnitSource)} method inherited\n     * from the {@link ValueAxis} class).\n     *\n     * @return A collection of standard date tick units.\n     */\n    public static TickUnitSource createStandardDateTickUnits() {\n        return createStandardDateTickUnits(TimeZone.getDefault(),\n                Locale.getDefault());\n    }\n\n    /**\n     * Returns a collection of standard date tick units.  This collection will\n     * be used by default, but you are free to create your own collection if\n     * you want to (see the\n     * {@link ValueAxis#setStandardTickUnits(TickUnitSource)} method inherited\n     * from the {@link ValueAxis} class).\n     *\n     * @param zone  the time zone ({@code null} not permitted).\n     * @param locale  the locale ({@code null} not permitted).\n     *\n     * @return A collection of standard date tick units.\n     */\n    public static TickUnitSource createStandardDateTickUnits(TimeZone zone,\n            Locale locale) {\n\n        Args.nullNotPermitted(zone, \"zone\");\n        Args.nullNotPermitted(locale, \"locale\");\n        TickUnits units \u003d new TickUnits();\n\n        // date formatters\n        DateFormat f1 \u003d new SimpleDateFormat(\"HH:mm:ss.SSS\", locale);\n        DateFormat f2 \u003d new SimpleDateFormat(\"HH:mm:ss\", locale);\n        DateFormat f3 \u003d new SimpleDateFormat(\"HH:mm\", locale);\n        DateFormat f4 \u003d new SimpleDateFormat(\"d-MMM, HH:mm\", locale);\n        DateFormat f5 \u003d new SimpleDateFormat(\"d-MMM\", locale);\n        DateFormat f6 \u003d new SimpleDateFormat(\"MMM-yyyy\", locale);\n        DateFormat f7 \u003d new SimpleDateFormat(\"yyyy\", locale);\n\n        f1.setTimeZone(zone);\n        f2.setTimeZone(zone);\n        f3.setTimeZone(zone);\n        f4.setTimeZone(zone);\n        f5.setTimeZone(zone);\n        f6.setTimeZone(zone);\n        f7.setTimeZone(zone);\n\n        // milliseconds\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 1, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 5,\n                DateTickUnitType.MILLISECOND, 1, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 10,\n                DateTickUnitType.MILLISECOND, 1, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 25,\n                DateTickUnitType.MILLISECOND, 5, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 50,\n                DateTickUnitType.MILLISECOND, 10, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 100,\n                DateTickUnitType.MILLISECOND, 10, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 250,\n                DateTickUnitType.MILLISECOND, 10, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 500,\n                DateTickUnitType.MILLISECOND, 50, f1));\n\n        // seconds\n        units.add(new DateTickUnit(DateTickUnitType.SECOND, 1,\n                DateTickUnitType.MILLISECOND, 50, f2));\n        units.add(new DateTickUnit(DateTickUnitType.SECOND, 5,\n                DateTickUnitType.SECOND, 1, f2));\n        units.add(new DateTickUnit(DateTickUnitType.SECOND, 10,\n                DateTickUnitType.SECOND, 1, f2));\n        units.add(new DateTickUnit(DateTickUnitType.SECOND, 30,\n                DateTickUnitType.SECOND, 5, f2));\n\n        // minutes\n        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 1,\n                DateTickUnitType.SECOND, 5, f3));\n        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 2,\n                DateTickUnitType.SECOND, 10, f3));\n        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 5,\n                DateTickUnitType.MINUTE, 1, f3));\n        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 10,\n                DateTickUnitType.MINUTE, 1, f3));\n        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 15,\n                DateTickUnitType.MINUTE, 5, f3));\n        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 20,\n                DateTickUnitType.MINUTE, 5, f3));\n        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 30,\n                DateTickUnitType.MINUTE, 5, f3));\n\n        // hours\n        units.add(new DateTickUnit(DateTickUnitType.HOUR, 1,\n                DateTickUnitType.MINUTE, 5, f3));\n        units.add(new DateTickUnit(DateTickUnitType.HOUR, 2,\n                DateTickUnitType.MINUTE, 10, f3));\n        units.add(new DateTickUnit(DateTickUnitType.HOUR, 4,\n                DateTickUnitType.MINUTE, 30, f3));\n        units.add(new DateTickUnit(DateTickUnitType.HOUR, 6,\n                DateTickUnitType.HOUR, 1, f3));\n        units.add(new DateTickUnit(DateTickUnitType.HOUR, 12,\n                DateTickUnitType.HOUR, 1, f4));\n\n        // days\n        units.add(new DateTickUnit(DateTickUnitType.DAY, 1,\n                DateTickUnitType.HOUR, 1, f5));\n        units.add(new DateTickUnit(DateTickUnitType.DAY, 2,\n                DateTickUnitType.HOUR, 1, f5));\n        units.add(new DateTickUnit(DateTickUnitType.DAY, 7,\n                DateTickUnitType.DAY, 1, f5));\n        units.add(new DateTickUnit(DateTickUnitType.DAY, 15,\n                DateTickUnitType.DAY, 1, f5));\n\n        // months\n        units.add(new DateTickUnit(DateTickUnitType.MONTH, 1,\n                DateTickUnitType.DAY, 1, f6));\n        units.add(new DateTickUnit(DateTickUnitType.MONTH, 2,\n                DateTickUnitType.DAY, 1, f6));\n        units.add(new DateTickUnit(DateTickUnitType.MONTH, 3,\n                DateTickUnitType.MONTH, 1, f6));\n        units.add(new DateTickUnit(DateTickUnitType.MONTH, 4,\n                DateTickUnitType.MONTH, 1, f6));\n        units.add(new DateTickUnit(DateTickUnitType.MONTH, 6,\n                DateTickUnitType.MONTH, 1, f6));\n\n        // years\n        units.add(new DateTickUnit(DateTickUnitType.YEAR, 1,\n                DateTickUnitType.MONTH, 1, f7));\n        units.add(new DateTickUnit(DateTickUnitType.YEAR, 2,\n                DateTickUnitType.MONTH, 3, f7));\n        units.add(new DateTickUnit(DateTickUnitType.YEAR, 5,\n                DateTickUnitType.YEAR, 1, f7));\n        units.add(new DateTickUnit(DateTickUnitType.YEAR, 10,\n                DateTickUnitType.YEAR, 1, f7));\n        units.add(new DateTickUnit(DateTickUnitType.YEAR, 25,\n                DateTickUnitType.YEAR, 5, f7));\n        units.add(new DateTickUnit(DateTickUnitType.YEAR, 50,\n                DateTickUnitType.YEAR, 10, f7));\n        units.add(new DateTickUnit(DateTickUnitType.YEAR, 100,\n                DateTickUnitType.YEAR, 20, f7));\n\n        return units;\n\n    }\n\n    /**\n     * Rescales the axis to ensure that all data is visible.\n     */\n    @Override\n    protected void autoAdjustRange() {\n\n        Plot plot \u003d getPlot();\n\n        if (plot \u003d\u003d null) {\n            return;  // no plot, no data\n        }\n\n        if (plot instanceof ValueAxisPlot) {\n            ValueAxisPlot vap \u003d (ValueAxisPlot) plot;\n\n            Range r \u003d vap.getDataRange(this);\n            if (r \u003d\u003d null) {\n                r \u003d new DateRange();\n            }\n\n            long upper \u003d this.timeline.toTimelineValue(\n                    (long) r.getUpperBound());\n            long lower;\n            long fixedAutoRange \u003d (long) getFixedAutoRange();\n            if (fixedAutoRange \u003e 0.0) {\n                lower \u003d upper - fixedAutoRange;\n            }\n            else {\n                lower \u003d this.timeline.toTimelineValue((long) r.getLowerBound());\n                double range \u003d upper - lower;\n                long minRange \u003d (long) getAutoRangeMinimumSize();\n                if (range \u003c minRange) {\n                    long expand \u003d (long) (minRange - range) / 2;\n                    upper \u003d upper + expand;\n                    lower \u003d lower - expand;\n                }\n                upper \u003d upper + (long) (range * getUpperMargin());\n                lower \u003d lower - (long) (range * getLowerMargin());\n            }\n\n            upper \u003d this.timeline.toMillisecond(upper);\n            lower \u003d this.timeline.toMillisecond(lower);\n            DateRange dr \u003d new DateRange(new Date(lower), new Date(upper));\n            setRange(dr, false, false);\n        }\n\n    }\n\n    /**\n     * Selects an appropriate tick value for the axis.  The strategy is to\n     * display as many ticks as possible (selected from an array of \u0027standard\u0027\n     * tick units) without the labels overlapping.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area defined by the axes.\n     * @param edge  the axis location.\n     */\n    protected void selectAutoTickUnit(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            selectHorizontalAutoTickUnit(g2, dataArea, edge);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            selectVerticalAutoTickUnit(g2, dataArea, edge);\n        }\n\n    }\n\n    /**\n     * Selects an appropriate tick size for the axis.  The strategy is to\n     * display as many ticks as possible (selected from a collection of\n     * \u0027standard\u0027 tick units) without the labels overlapping.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area defined by the axes.\n     * @param edge  the axis location.\n     */\n    protected void selectHorizontalAutoTickUnit(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        double zero \u003d valueToJava2D(0.0, dataArea, edge);\n        double tickLabelWidth \u003d estimateMaximumTickLabelWidth(g2,\n                getTickUnit());\n\n        // start with the current tick unit...\n        TickUnitSource tickUnits \u003d getStandardTickUnits();\n        TickUnit unit1 \u003d tickUnits.getCeilingTickUnit(getTickUnit());\n        double x1 \u003d valueToJava2D(unit1.getSize(), dataArea, edge);\n        double unit1Width \u003d Math.abs(x1 - zero);\n\n        // then extrapolate...\n        double guess \u003d (tickLabelWidth / unit1Width) * unit1.getSize();\n        DateTickUnit unit2 \u003d (DateTickUnit) tickUnits.getCeilingTickUnit(guess);\n        double x2 \u003d valueToJava2D(unit2.getSize(), dataArea, edge);\n        double unit2Width \u003d Math.abs(x2 - zero);\n        tickLabelWidth \u003d estimateMaximumTickLabelWidth(g2, unit2);\n        if (tickLabelWidth \u003e unit2Width) {\n            unit2 \u003d (DateTickUnit) tickUnits.getLargerTickUnit(unit2);\n        }\n        setTickUnit(unit2, false, false);\n    }\n\n    /**\n     * Selects an appropriate tick size for the axis.  The strategy is to\n     * display as many ticks as possible (selected from a collection of\n     * \u0027standard\u0027 tick units) without the labels overlapping.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area in which the plot should be drawn.\n     * @param edge  the axis location.\n     */\n    protected void selectVerticalAutoTickUnit(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        // start with the current tick unit...\n        TickUnitSource tickUnits \u003d getStandardTickUnits();\n        double zero \u003d valueToJava2D(0.0, dataArea, edge);\n\n        // start with a unit that is at least 1/10th of the axis length\n        double estimate1 \u003d getRange().getLength() / 10.0;\n        DateTickUnit candidate1\n            \u003d (DateTickUnit) tickUnits.getCeilingTickUnit(estimate1);\n        double labelHeight1 \u003d estimateMaximumTickLabelHeight(g2, candidate1);\n        double y1 \u003d valueToJava2D(candidate1.getSize(), dataArea, edge);\n        double candidate1UnitHeight \u003d Math.abs(y1 - zero);\n\n        // now extrapolate based on label height and unit height...\n        double estimate2\n            \u003d (labelHeight1 / candidate1UnitHeight) * candidate1.getSize();\n        DateTickUnit candidate2\n            \u003d (DateTickUnit) tickUnits.getCeilingTickUnit(estimate2);\n        double labelHeight2 \u003d estimateMaximumTickLabelHeight(g2, candidate2);\n        double y2 \u003d valueToJava2D(candidate2.getSize(), dataArea, edge);\n        double unit2Height \u003d Math.abs(y2 - zero);\n\n       // make final selection...\n       DateTickUnit finalUnit;\n       if (labelHeight2 \u003c unit2Height) {\n           finalUnit \u003d candidate2;\n       }\n       else {\n           finalUnit \u003d (DateTickUnit) tickUnits.getLargerTickUnit(candidate2);\n       }\n       setTickUnit(finalUnit, false, false);\n\n    }\n\n    /**\n     * Estimates the maximum width of the tick labels, assuming the specified\n     * tick unit is used.\n     * \u003cP\u003e\n     * Rather than computing the string bounds of every tick on the axis, we\n     * just look at two values: the lower bound and the upper bound for the\n     * axis.  These two values will usually be representative.\n     *\n     * @param g2  the graphics device.\n     * @param unit  the tick unit to use for calculation.\n     *\n     * @return The estimated maximum width of the tick labels.\n     */\n    private double estimateMaximumTickLabelWidth(Graphics2D g2, \n            DateTickUnit unit) {\n\n        RectangleInsets tickLabelInsets \u003d getTickLabelInsets();\n        double result \u003d tickLabelInsets.getLeft() + tickLabelInsets.getRight();\n\n        Font tickLabelFont \u003d getTickLabelFont();\n        FontRenderContext frc \u003d g2.getFontRenderContext();\n        LineMetrics lm \u003d tickLabelFont.getLineMetrics(\"ABCxyz\", frc);\n        if (isVerticalTickLabels()) {\n            // all tick labels have the same width (equal to the height of\n            // the font)...\n            result +\u003d lm.getHeight();\n        }\n        else {\n            // look at lower and upper bounds...\n            DateRange range \u003d (DateRange) getRange();\n            Date lower \u003d range.getLowerDate();\n            Date upper \u003d range.getUpperDate();\n            String lowerStr, upperStr;\n            DateFormat formatter \u003d getDateFormatOverride();\n            if (formatter !\u003d null) {\n                lowerStr \u003d formatter.format(lower);\n                upperStr \u003d formatter.format(upper);\n            }\n            else {\n                lowerStr \u003d unit.dateToString(lower);\n                upperStr \u003d unit.dateToString(upper);\n            }\n            FontMetrics fm \u003d g2.getFontMetrics(tickLabelFont);\n            double w1 \u003d fm.stringWidth(lowerStr);\n            double w2 \u003d fm.stringWidth(upperStr);\n            result +\u003d Math.max(w1, w2);\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Estimates the maximum width of the tick labels, assuming the specified\n     * tick unit is used.\n     * \u003cP\u003e\n     * Rather than computing the string bounds of every tick on the axis, we\n     * just look at two values: the lower bound and the upper bound for the\n     * axis.  These two values will usually be representative.\n     *\n     * @param g2  the graphics device.\n     * @param unit  the tick unit to use for calculation.\n     *\n     * @return The estimated maximum width of the tick labels.\n     */\n    private double estimateMaximumTickLabelHeight(Graphics2D g2,\n            DateTickUnit unit) {\n\n        RectangleInsets tickLabelInsets \u003d getTickLabelInsets();\n        double result \u003d tickLabelInsets.getTop() + tickLabelInsets.getBottom();\n\n        Font tickLabelFont \u003d getTickLabelFont();\n        FontRenderContext frc \u003d g2.getFontRenderContext();\n        LineMetrics lm \u003d tickLabelFont.getLineMetrics(\"ABCxyz\", frc);\n        if (!isVerticalTickLabels()) {\n            // all tick labels have the same width (equal to the height of\n            // the font)...\n            result +\u003d lm.getHeight();\n        }\n        else {\n            // look at lower and upper bounds...\n            DateRange range \u003d (DateRange) getRange();\n            Date lower \u003d range.getLowerDate();\n            Date upper \u003d range.getUpperDate();\n            String lowerStr, upperStr;\n            DateFormat formatter \u003d getDateFormatOverride();\n            if (formatter !\u003d null) {\n                lowerStr \u003d formatter.format(lower);\n                upperStr \u003d formatter.format(upper);\n            }\n            else {\n                lowerStr \u003d unit.dateToString(lower);\n                upperStr \u003d unit.dateToString(upper);\n            }\n            FontMetrics fm \u003d g2.getFontMetrics(tickLabelFont);\n            double w1 \u003d fm.stringWidth(lowerStr);\n            double w2 \u003d fm.stringWidth(upperStr);\n            result +\u003d Math.max(w1, w2);\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Calculates the positions of the tick labels for the axis, storing the\n     * results in the tick label list (ready for drawing).\n     *\n     * @param g2  the graphics device.\n     * @param state  the axis state.\n     * @param dataArea  the area in which the plot should be drawn.\n     * @param edge  the location of the axis.\n     *\n     * @return A list of ticks.\n     */\n    @Override\n    public List\u003c? extends Tick\u003e refreshTicks(Graphics2D g2, AxisState state, \n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        List\u003c? extends Tick\u003e result \u003d null;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            result \u003d refreshTicksHorizontal(g2, dataArea, edge);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            result \u003d refreshTicksVertical(g2, dataArea, edge);\n        }\n        return result;\n\n    }\n\n    /**\n     * Corrects the given tick date for the position setting.\n     *\n     * @param time  the tick date/time.\n     * @param unit  the tick unit.\n     * @param position  the tick position.\n     *\n     * @return The adjusted time.\n     */\n    private Date correctTickDateForPosition(Date time, DateTickUnit unit,\n            DateTickMarkPosition position) {\n        Date result \u003d time;\n        if (unit.getUnitType().equals(DateTickUnitType.MONTH)) {\n            result \u003d calculateDateForPosition(new Month(time, this.timeZone,\n                    this.locale), position);\n        } else if (unit.getUnitType().equals(DateTickUnitType.YEAR)) {\n            result \u003d calculateDateForPosition(new Year(time, this.timeZone,\n                    this.locale), position);\n        }\n        return result;\n    }\n\n    /**\n     * Recalculates the ticks for the date axis.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area in which the data is to be drawn.\n     * @param edge  the location of the axis.\n     *\n     * @return A list of ticks.\n     */\n    protected List\u003c? extends Tick\u003e refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge) {\n\n        List\u003cDateTick\u003e result \u003d new ArrayList\u003c\u003e();\n\n        Font tickLabelFont \u003d getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        DateTickUnit unit \u003d getTickUnit();\n        Date tickDate \u003d calculateLowestVisibleTickValue(unit);\n        Date upperDate \u003d getMaximumDate();\n\n        boolean hasRolled \u003d false;\n        while (tickDate.before(upperDate)) {\n            // could add a flag to make the following correction optional...\n            if (!hasRolled) {\n                tickDate \u003d correctTickDateForPosition(tickDate, unit,\n                     this.tickMarkPosition);\n            }\n\n            long lowestTickTime \u003d tickDate.getTime();\n            long distance \u003d unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces \u003d getMinorTickCount();\n            if (minorTickSpaces \u003c\u003d 0) {\n                minorTickSpaces \u003d unit.getMinorTickCount();\n            }\n            for (int minorTick \u003d 1; minorTick \u003c minorTickSpaces; minorTick++) {\n                long minorTickTime \u003d lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime \u003e 0 \u0026\u0026 getRange().contains(minorTickTime)\n                        \u0026\u0026 (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n\n            if (!isHiddenValue(tickDate.getTime())) {\n                // work out the value, label and position\n                String tickLabel;\n                DateFormat formatter \u003d getDateFormatOverride();\n                if (formatter !\u003d null) {\n                    tickLabel \u003d formatter.format(tickDate);\n                }\n                else {\n                    tickLabel \u003d this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle \u003d 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor \u003d TextAnchor.CENTER_RIGHT;\n                    rotationAnchor \u003d TextAnchor.CENTER_RIGHT;\n                    if (edge \u003d\u003d RectangleEdge.TOP) {\n                        angle \u003d Math.PI / 2.0;\n                    }\n                    else {\n                        angle \u003d -Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge \u003d\u003d RectangleEdge.TOP) {\n                        anchor \u003d TextAnchor.BOTTOM_CENTER;\n                        rotationAnchor \u003d TextAnchor.BOTTOM_CENTER;\n                    }\n                    else {\n                        anchor \u003d TextAnchor.TOP_CENTER;\n                        rotationAnchor \u003d TextAnchor.TOP_CENTER;\n                    }\n                }\n\n                DateTick tick \u003d new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled \u003d false;\n\n                long currentTickTime \u003d tickDate.getTime();\n                tickDate \u003d unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime \u003d tickDate.getTime();\n                for (int minorTick \u003d 1; minorTick \u003c minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime \u003d currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            \u0026\u0026 (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n\n            }\n            else {\n                tickDate \u003d unit.rollDate(tickDate, this.timeZone);\n                hasRolled \u003d true;\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Recalculates the ticks for the date axis.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area in which the plot should be drawn.\n     * @param edge  the location of the axis.\n     *\n     * @return A list of ticks.\n     */\n    protected List\u003c? extends Tick\u003e refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        List\u003cDateTick\u003e result \u003d new ArrayList\u003c\u003e();\n\n        Font tickLabelFont \u003d getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n        DateTickUnit unit \u003d getTickUnit();\n        Date tickDate \u003d calculateLowestVisibleTickValue(unit);\n        Date upperDate \u003d getMaximumDate();\n\n        boolean hasRolled \u003d false;\n        while (tickDate.before(upperDate)) {\n\n            // could add a flag to make the following correction optional...\n            if (!hasRolled) {\n                tickDate \u003d correctTickDateForPosition(tickDate, unit,\n                    this.tickMarkPosition);\n            }\n\n            long lowestTickTime \u003d tickDate.getTime();\n            long distance \u003d unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces \u003d getMinorTickCount();\n            if (minorTickSpaces \u003c\u003d 0) {\n                minorTickSpaces \u003d unit.getMinorTickCount();\n            }\n            for (int minorTick \u003d 1; minorTick \u003c minorTickSpaces; minorTick++) {\n                long minorTickTime \u003d lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime \u003e 0 \u0026\u0026 getRange().contains(minorTickTime)\n                        \u0026\u0026 (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n            if (!isHiddenValue(tickDate.getTime())) {\n                // work out the value, label and position\n                String tickLabel;\n                DateFormat formatter \u003d getDateFormatOverride();\n                if (formatter !\u003d null) {\n                    tickLabel \u003d formatter.format(tickDate);\n                }\n                else {\n                    tickLabel \u003d this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle \u003d 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor \u003d TextAnchor.BOTTOM_CENTER;\n                    rotationAnchor \u003d TextAnchor.BOTTOM_CENTER;\n                    if (edge \u003d\u003d RectangleEdge.LEFT) {\n                        angle \u003d -Math.PI / 2.0;\n                    }\n                    else {\n                        angle \u003d Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge \u003d\u003d RectangleEdge.LEFT) {\n                        anchor \u003d TextAnchor.CENTER_RIGHT;\n                        rotationAnchor \u003d TextAnchor.CENTER_RIGHT;\n                    }\n                    else {\n                        anchor \u003d TextAnchor.CENTER_LEFT;\n                        rotationAnchor \u003d TextAnchor.CENTER_LEFT;\n                    }\n                }\n\n                DateTick tick \u003d new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled \u003d false;\n\n                long currentTickTime \u003d tickDate.getTime();\n                tickDate \u003d unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime \u003d tickDate.getTime();\n                for (int minorTick \u003d 1; minorTick \u003c minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime \u003d currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            \u0026\u0026 (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n            }\n            else {\n                tickDate \u003d unit.rollDate(tickDate, this.timeZone);\n                hasRolled \u003d true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Draws the axis on a Java 2D graphics device (such as the screen or a\n     * printer).\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param cursor  the cursor location.\n     * @param plotArea  the area within which the axes and data should be\n     *                  drawn ({@code null} not permitted).\n     * @param dataArea  the area within which the data should be drawn\n     *                  ({@code null} not permitted).\n     * @param edge  the location of the axis ({@code null} not permitted).\n     * @param plotState  collects information about the plot\n     *                   ({@code null} permitted).\n     *\n     * @return The axis state (never {@code null}).\n     */\n    @Override\n    public AxisState draw(Graphics2D g2, double cursor, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge,\n            PlotRenderingInfo plotState) {\n\n        // if the axis is not visible, don\u0027t draw it...\n        if (!isVisible()) {\n            AxisState state \u003d new AxisState(cursor);\n            // even though the axis is not visible, we need to refresh ticks in\n            // case the grid is being drawn...\n            List ticks \u003d refreshTicks(g2, state, dataArea, edge);\n            state.setTicks(ticks);\n            return state;\n        }\n\n        // draw the tick marks and labels...\n        AxisState state \u003d drawTickMarksAndLabels(g2, cursor, plotArea,\n                dataArea, edge);\n\n        // draw the axis label (note that \u0027state\u0027 is passed in *and*\n        // returned)...\n        if (getAttributedLabel() !\u003d null) {\n            state \u003d drawAttributedLabel(getAttributedLabel(), g2, plotArea, \n                    dataArea, edge, state);\n            \n        } else {\n            state \u003d drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);\n        }\n        createAndAddEntity(cursor, state, dataArea, edge, plotState);\n        return state;\n\n    }\n\n    /**\n     * Zooms in on the current range (zoom-in stops once the axis length \n     * reaches the equivalent of one millisecond).  \n     *\n     * @param lowerPercent  the new lower bound.\n     * @param upperPercent  the new upper bound.\n     */\n    @Override\n    public void zoomRange(double lowerPercent, double upperPercent) {\n        double start \u003d this.timeline.toTimelineValue(\n                (long) getRange().getLowerBound());\n        double end \u003d this.timeline.toTimelineValue(\n                (long) getRange().getUpperBound());\n        double length \u003d end - start;\n        Range adjusted;\n        long adjStart, adjEnd;\n        if (isInverted()) {\n            adjStart \u003d (long) (start + (length * (1 - upperPercent)));\n            adjEnd \u003d (long) (start + (length * (1 - lowerPercent)));\n        }\n        else {\n            adjStart \u003d (long) (start + length * lowerPercent);\n            adjEnd \u003d (long) (start + length * upperPercent);\n        }\n        // when zooming to sub-millisecond ranges, it can be the case that\n        // adjEnd \u003d\u003d adjStart...and we can\u0027t have an axis with zero length\n        // so we apply this instead:\n        if (adjEnd \u003c\u003d adjStart) {\n            adjEnd \u003d adjStart + 1L;\n        } \n        adjusted \u003d new DateRange(this.timeline.toMillisecond(adjStart),\n               this.timeline.toMillisecond(adjEnd));\n        setRange(adjusted);\n    }\n\n    /**\n     * Tests this axis for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof DateAxis)) {\n            return false;\n        }\n        DateAxis that \u003d (DateAxis) obj;\n        if (!Objects.equals(this.timeZone, that.timeZone)) {\n            return false;\n        }\n        if (!Objects.equals(this.locale, that.locale)) {\n            return false;\n        }\n        if (!Objects.equals(this.tickUnit, that.tickUnit)) {\n            return false;\n        }\n        if (!Objects.equals(this.dateFormatOverride, that.dateFormatOverride)) {\n            return false;\n        }\n        if (!Objects.equals(this.tickMarkPosition, that.tickMarkPosition)) {\n            return false;\n        }\n        if (!Objects.equals(this.timeline, that.timeline)) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a hash code for this object.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * Returns a clone of the object.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if some component of the axis does\n     *         not support cloning.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        DateAxis clone \u003d (DateAxis) super.clone();\n        // \u0027dateTickUnit\u0027 is immutable : no need to clone\n        if (this.dateFormatOverride !\u003d null) {\n            clone.dateFormatOverride\n                \u003d (DateFormat) this.dateFormatOverride.clone();\n        }\n        // \u0027tickMarkPosition\u0027 is immutable : no need to clone\n        return clone;\n    }\n\n}","methodCount":59,"staticMethodCount":2,"instanceMethodCount":57,"classLoc":1744,"innerClassCount":1},"candidatesTelemetryData":{"numberOfSuggestions":3,"candidates":[{"lineStart":625,"lineEnd":635,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method isHiddenValue to class Timeline","description":"Move method isHiddenValue to org.jfree.chart.axis.Timeline\nRationale: The method isHiddenValue relies heavily on the functionality of the Timeline class, specifically calling the containsDomainValue method within it. Moving this method to the Timeline interface makes logical sense because it is a domain-specific utility that closely interacts with the timeline\u0027s values. By relocating isHiddenValue to Timeline, we encapsulate timeline-specific behaviors within one interface, promoting coherence and maintainability.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false,"userRating":"Very Unhelpful"},{"lineStart":976,"lineEnd":991,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method nextStandardDate to class Timeline","description":"Move method nextStandardDate to org.jfree.chart.axis.Timeline\nRationale: The method nextStandardDate is responsible for calculating dates based on certain units, which closely aligns with the responsibilities of the Timeline interface. Given that Timeline deals explicitly with date-related transformations and verifications, it is appropriate to move this method there. This method would complement the existing methods such as toTimelineValue(Date date) and containsDomainRange(Date fromDate, Date toDate) by providing a way to compute the next standard date directly within the timeline context. Additionally, having this method within the Timeline interface could facilitate improved cohesion and usability of the Timeline API.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false},{"lineStart":1556,"lineEnd":1667,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method refreshTicksVertical to class Timeline","description":"Move method refreshTicksVertical to org.jfree.chart.axis.Timeline\nRationale: The method `refreshTicksVertical` deals primarily with the recalculation of date ticks for a date axis. This involves various operations related to time manipulation and date formatting which align well with the responsibilities of the `Timeline` class. The `Timeline` class is designed to handle transformations and validations related to date and time values. By moving this method to `Timeline`, we centralize date and time-sensitive logic within a class that is specifically equipped to handle it. This will enhance cohesion, making the codebase easier to maintain and extend. Additionally, `Timeline` already deals with concepts like millisecond values and ranges of dates, which are integral parts of the `refreshTicksVertical` method.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false}]},"userSelectionTelemetryData":{"lineStart":1556,"lineEnd":1667,"functionSize":112,"positionInHostFunction":1478,"selectedCandidateIndex":2,"candidateType":"AS_IS","elementsType":[{"elementType":"METHOD","quantity":1}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":206728},{"candidateIndex":1,"elapsedTime":7316},{"candidateIndex":2,"elapsedTime":26233}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":52028},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"isHiddenValue","method_signature":"public isHiddenValue(long millis)","target_class":"","rationale":""},{"method_name":"previousStandardDate","method_signature":"protected previousStandardDate(Date date, DateTickUnit unit)","target_class":"","rationale":""},{"method_name":"calculateDateForPosition","method_signature":"private calculateDateForPosition(RegularTimePeriod period,\n            DateTickMarkPosition position)","target_class":"","rationale":""},{"method_name":"nextStandardDate","method_signature":"protected nextStandardDate(Date date, DateTickUnit unit)","target_class":"","rationale":""},{"method_name":"estimateMaximumTickLabelWidth","method_signature":"private estimateMaximumTickLabelWidth(Graphics2D g2, \n            DateTickUnit unit)","target_class":"","rationale":""},{"method_name":"estimateMaximumTickLabelHeight","method_signature":"private estimateMaximumTickLabelHeight(Graphics2D g2,\n            DateTickUnit unit)","target_class":"","rationale":""},{"method_name":"correctTickDateForPosition","method_signature":"private correctTickDateForPosition(Date time, DateTickUnit unit,\n            DateTickMarkPosition position)","target_class":"","rationale":""},{"method_name":"refreshTicksHorizontal","method_signature":"protected refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge)","target_class":"","rationale":""},{"method_name":"refreshTicksVertical","method_signature":"protected refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"previousStandardDate","method_signature":"protected previousStandardDate(Date date, DateTickUnit unit)","target_class":"","rationale":""},{"method_name":"isHiddenValue","method_signature":"public isHiddenValue(long millis)","target_class":"","rationale":""},{"method_name":"nextStandardDate","method_signature":"protected nextStandardDate(Date date, DateTickUnit unit)","target_class":"","rationale":""},{"method_name":"refreshTicksVertical","method_signature":"protected refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge)","target_class":"","rationale":""},{"method_name":"refreshTicksHorizontal","method_signature":"protected refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge)","target_class":"","rationale":""},{"method_name":"calculateDateForPosition","method_signature":"private calculateDateForPosition(RegularTimePeriod period,\n            DateTickMarkPosition position)","target_class":"","rationale":""},{"method_name":"correctTickDateForPosition","method_signature":"private correctTickDateForPosition(Date time, DateTickUnit unit,\n            DateTickMarkPosition position)","target_class":"","rationale":""},{"method_name":"estimateMaximumTickLabelHeight","method_signature":"private estimateMaximumTickLabelHeight(Graphics2D g2,\n            DateTickUnit unit)","target_class":"","rationale":""},{"method_name":"estimateMaximumTickLabelWidth","method_signature":"private estimateMaximumTickLabelWidth(Graphics2D g2, \n            DateTickUnit unit)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"protected previousStandardDate(Date date, DateTickUnit unit)":{"first":{"method_name":"previousStandardDate","method_signature":"protected previousStandardDate(Date date, DateTickUnit unit)","target_class":"","rationale":""},"second":0.5821732401086368},"public isHiddenValue(long millis)":{"first":{"method_name":"isHiddenValue","method_signature":"public isHiddenValue(long millis)","target_class":"","rationale":""},"second":0.6643634754003933},"protected nextStandardDate(Date date, DateTickUnit unit)":{"first":{"method_name":"nextStandardDate","method_signature":"protected nextStandardDate(Date date, DateTickUnit unit)","target_class":"","rationale":""},"second":0.7103494305280967},"protected refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge)":{"first":{"method_name":"refreshTicksVertical","method_signature":"protected refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge)","target_class":"","rationale":""},"second":0.7369448117161602},"protected refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge)":{"first":{"method_name":"refreshTicksHorizontal","method_signature":"protected refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge)","target_class":"","rationale":""},"second":0.7393024942813281},"private calculateDateForPosition(RegularTimePeriod period,\n            DateTickMarkPosition position)":{"first":{"method_name":"calculateDateForPosition","method_signature":"private calculateDateForPosition(RegularTimePeriod period,\n            DateTickMarkPosition position)","target_class":"","rationale":""},"second":0.7549558793392384},"private correctTickDateForPosition(Date time, DateTickUnit unit,\n            DateTickMarkPosition position)":{"first":{"method_name":"correctTickDateForPosition","method_signature":"private correctTickDateForPosition(Date time, DateTickUnit unit,\n            DateTickMarkPosition position)","target_class":"","rationale":""},"second":0.7805112754114129},"private estimateMaximumTickLabelHeight(Graphics2D g2,\n            DateTickUnit unit)":{"first":{"method_name":"estimateMaximumTickLabelHeight","method_signature":"private estimateMaximumTickLabelHeight(Graphics2D g2,\n            DateTickUnit unit)","target_class":"","rationale":""},"second":0.8320859346755809},"private estimateMaximumTickLabelWidth(Graphics2D g2, \n            DateTickUnit unit)":{"first":{"method_name":"estimateMaximumTickLabelWidth","method_signature":"private estimateMaximumTickLabelWidth(Graphics2D g2, \n            DateTickUnit unit)","target_class":"","rationale":""},"second":0.8321817309915978}},"targetClassMap":{"previousStandardDate":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5983,"similarity_computation_time":0,"similarity_metric":"cosine"},"isHiddenValue":{"target_classes":[{"class_name":"Timeline","similarity_score":0.7807028472864754},{"class_name":"Timeline","similarity_score":0.7807028472864754}],"target_classes_sorted_by_llm":["Timeline","Timeline"],"llm_response_time":5276,"similarity_computation_time":0,"similarity_metric":"cosine"},"nextStandardDate":{"target_classes":[{"class_name":"Timeline","similarity_score":0.6553760708797578},{"class_name":"Timeline","similarity_score":0.6553760708797578}],"target_classes_sorted_by_llm":["Timeline","Timeline"],"llm_response_time":5436,"similarity_computation_time":1,"similarity_metric":"cosine"},"refreshTicksVertical":{"target_classes":[{"class_name":"Timeline","similarity_score":0.26464152775617245},{"class_name":"Timeline","similarity_score":0.26464152775617245}],"target_classes_sorted_by_llm":["Timeline","Timeline"],"llm_response_time":5159,"similarity_computation_time":0,"similarity_metric":"cosine"},"refreshTicksHorizontal":{"target_classes":[{"class_name":"Timeline","similarity_score":0.26880112587092475},{"class_name":"Timeline","similarity_score":0.26880112587092475}],"target_classes_sorted_by_llm":["Timeline","Timeline"],"llm_response_time":4359,"similarity_computation_time":0,"similarity_metric":"cosine"},"calculateDateForPosition":{"target_classes":[{"class_name":"RegularTimePeriod","similarity_score":0.6462685527714653},{"class_name":"DateTickMarkPosition","similarity_score":0.3366501646120693},{"class_name":"DateRange","similarity_score":0.6326948931973279},{"class_name":"DateTickUnit","similarity_score":0.6967858219474778},{"class_name":"DateTickMarkPosition","similarity_score":0.3366501646120693},{"class_name":"Timeline","similarity_score":0.5495501040844966},{"class_name":"Timeline","similarity_score":0.5495501040844966}],"target_classes_sorted_by_llm":["RegularTimePeriod","DateTickUnit","DateRange"],"llm_response_time":6739,"similarity_computation_time":1,"similarity_metric":"cosine"},"correctTickDateForPosition":{"target_classes":[{"class_name":"Timeline","similarity_score":0.5909692029727589},{"class_name":"Timeline","similarity_score":0.5909692029727589}],"target_classes_sorted_by_llm":["Timeline","Timeline"],"llm_response_time":3518,"similarity_computation_time":1,"similarity_metric":"cosine"},"estimateMaximumTickLabelHeight":{"target_classes":[{"class_name":"DateTickUnit","similarity_score":0.6620025933834841},{"class_name":"DateRange","similarity_score":0.6412898280652509},{"class_name":"DateTickUnit","similarity_score":0.6620025933834841},{"class_name":"DateTickMarkPosition","similarity_score":0.32109027532432616},{"class_name":"Timeline","similarity_score":0.5167363106398684},{"class_name":"Timeline","similarity_score":0.5167363106398684}],"target_classes_sorted_by_llm":["DateTickUnit","DateTickUnit","DateRange"],"llm_response_time":8133,"similarity_computation_time":1,"similarity_metric":"cosine"},"estimateMaximumTickLabelWidth":{"target_classes":[{"class_name":"DateTickUnit","similarity_score":0.6620025933834841},{"class_name":"DateRange","similarity_score":0.6412898280652509},{"class_name":"DateTickUnit","similarity_score":0.6620025933834841},{"class_name":"DateTickMarkPosition","similarity_score":0.32109027532432616},{"class_name":"Timeline","similarity_score":0.5167363106398684},{"class_name":"Timeline","similarity_score":0.5167363106398684}],"target_classes_sorted_by_llm":["DateTickUnit","DateTickUnit","DateRange"],"llm_response_time":7077,"similarity_computation_time":2,"similarity_metric":"cosine"}}}
{"id":"7f6ff03a-8887-4189-9d6c-819785a7628a","hostFunctionTelemetryData":{"hostFunctionSize":1262,"lineStart":74,"lineEnd":1335,"bodyLineStart":74,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/axis/CategoryAxis.java","sourceCode":"/**\n * An axis that displays categories.\n */\npublic class CategoryAxis extends Axis implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d 5886554608114265863L;\n\n    /**\n     * The default margin for the axis (used for both lower and upper margins).\n     */\n    public static final double DEFAULT_AXIS_MARGIN \u003d 0.05;\n\n    /**\n     * The default margin between categories (a percentage of the overall axis\n     * length).\n     */\n    public static final double DEFAULT_CATEGORY_MARGIN \u003d 0.20;\n\n    /** The amount of space reserved at the start of the axis. */\n    private double lowerMargin;\n\n    /** The amount of space reserved at the end of the axis. */\n    private double upperMargin;\n\n    /** The amount of space reserved between categories. */\n    private double categoryMargin;\n\n    /** The maximum number of lines for category labels. */\n    private int maximumCategoryLabelLines;\n\n    /**\n     * A ratio that is multiplied by the width of one category to determine the\n     * maximum label width.\n     */\n    private float maximumCategoryLabelWidthRatio;\n\n    /** The category label offset. */\n    private int categoryLabelPositionOffset;\n\n    /**\n     * A structure defining the category label positions for each axis\n     * location.\n     */\n    private CategoryLabelPositions categoryLabelPositions;\n\n    /** Storage for tick label font overrides (if any). */\n    private Map\u003cComparable, Font\u003e tickLabelFontMap; \n\n    /** Storage for tick label paint overrides (if any). */\n    private transient Map\u003cComparable, Paint\u003e tickLabelPaintMap;\n\n    /** Storage for the category label tooltips (if any). */\n    private Map\u003cComparable, String\u003e categoryLabelToolTips;\n\n    /** Storage for the category label URLs (if any). */\n    private Map\u003cComparable, String\u003e categoryLabelURLs;\n    \n    /**\n     * Creates a new category axis with no label.\n     */\n    public CategoryAxis() {\n        this(null);\n    }\n\n    /**\n     * Constructs a category axis, using default values where necessary.\n     *\n     * @param label  the axis label ({@code null} permitted).\n     */\n    public CategoryAxis(String label) {\n        super(label);\n\n        this.lowerMargin \u003d DEFAULT_AXIS_MARGIN;\n        this.upperMargin \u003d DEFAULT_AXIS_MARGIN;\n        this.categoryMargin \u003d DEFAULT_CATEGORY_MARGIN;\n        this.maximumCategoryLabelLines \u003d 1;\n        this.maximumCategoryLabelWidthRatio \u003d 0.0f;\n\n        this.categoryLabelPositionOffset \u003d 4;\n        this.categoryLabelPositions \u003d CategoryLabelPositions.STANDARD;\n        this.tickLabelFontMap \u003d new HashMap\u003c\u003e();\n        this.tickLabelPaintMap \u003d new HashMap\u003c\u003e();\n        this.categoryLabelToolTips \u003d new HashMap\u003c\u003e();\n        this.categoryLabelURLs \u003d new HashMap\u003c\u003e();\n    }\n\n    /**\n     * Returns the lower margin for the axis.\n     *\n     * @return The margin.\n     *\n     * @see #getUpperMargin()\n     * @see #setLowerMargin(double)\n     */\n    public double getLowerMargin() {\n        return this.lowerMargin;\n    }\n\n    /**\n     * Sets the lower margin for the axis and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param margin  the margin as a percentage of the axis length (for\n     *                example, 0.05 is five percent).\n     *\n     * @see #getLowerMargin()\n     */\n    public void setLowerMargin(double margin) {\n        this.lowerMargin \u003d margin;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the upper margin for the axis.\n     *\n     * @return The margin.\n     *\n     * @see #getLowerMargin()\n     * @see #setUpperMargin(double)\n     */\n    public double getUpperMargin() {\n        return this.upperMargin;\n    }\n\n    /**\n     * Sets the upper margin for the axis and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param margin  the margin as a percentage of the axis length (for\n     *                example, 0.05 is five percent).\n     *\n     * @see #getUpperMargin()\n     */\n    public void setUpperMargin(double margin) {\n        this.upperMargin \u003d margin;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the category margin.\n     *\n     * @return The margin.\n     *\n     * @see #setCategoryMargin(double)\n     */\n    public double getCategoryMargin() {\n        return this.categoryMargin;\n    }\n\n    /**\n     * Sets the category margin and sends an {@link AxisChangeEvent} to all\n     * registered listeners.  The overall category margin is distributed over\n     * N-1 gaps, where N is the number of categories on the axis.\n     *\n     * @param margin  the margin as a percentage of the axis length (for\n     *                example, 0.05 is five percent).\n     *\n     * @see #getCategoryMargin()\n     */\n    public void setCategoryMargin(double margin) {\n        this.categoryMargin \u003d margin;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the maximum number of lines to use for each category label.\n     *\n     * @return The maximum number of lines.\n     *\n     * @see #setMaximumCategoryLabelLines(int)\n     */\n    public int getMaximumCategoryLabelLines() {\n        return this.maximumCategoryLabelLines;\n    }\n\n    /**\n     * Sets the maximum number of lines to use for each category label and\n     * sends an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param lines  the maximum number of lines.\n     *\n     * @see #getMaximumCategoryLabelLines()\n     */\n    public void setMaximumCategoryLabelLines(int lines) {\n        this.maximumCategoryLabelLines \u003d lines;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the category label width ratio.\n     *\n     * @return The ratio.\n     *\n     * @see #setMaximumCategoryLabelWidthRatio(float)\n     */\n    public float getMaximumCategoryLabelWidthRatio() {\n        return this.maximumCategoryLabelWidthRatio;\n    }\n\n    /**\n     * Sets the maximum category label width ratio and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param ratio  the ratio.\n     *\n     * @see #getMaximumCategoryLabelWidthRatio()\n     */\n    public void setMaximumCategoryLabelWidthRatio(float ratio) {\n        this.maximumCategoryLabelWidthRatio \u003d ratio;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the offset between the axis and the category labels (before\n     * label positioning is taken into account).\n     *\n     * @return The offset (in Java2D units).\n     *\n     * @see #setCategoryLabelPositionOffset(int)\n     */\n    public int getCategoryLabelPositionOffset() {\n        return this.categoryLabelPositionOffset;\n    }\n\n    /**\n     * Sets the offset between the axis and the category labels (before label\n     * positioning is taken into account) and sends a change event to all \n     * registered listeners.\n     *\n     * @param offset  the offset (in Java2D units).\n     *\n     * @see #getCategoryLabelPositionOffset()\n     */\n    public void setCategoryLabelPositionOffset(int offset) {\n        this.categoryLabelPositionOffset \u003d offset;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the category label position specification (this contains label\n     * positioning info for all four possible axis locations).\n     *\n     * @return The positions (never {@code null}).\n     *\n     * @see #setCategoryLabelPositions(CategoryLabelPositions)\n     */\n    public CategoryLabelPositions getCategoryLabelPositions() {\n        return this.categoryLabelPositions;\n    }\n\n    /**\n     * Sets the category label position specification for the axis and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param positions  the positions ({@code null} not permitted).\n     *\n     * @see #getCategoryLabelPositions()\n     */\n    public void setCategoryLabelPositions(CategoryLabelPositions positions) {\n        Args.nullNotPermitted(positions, \"positions\");\n        this.categoryLabelPositions \u003d positions;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the font for the tick label for the given category.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @return The font (never {@code null}).\n     *\n     * @see #setTickLabelFont(Comparable, Font)\n     */\n    public Font getTickLabelFont(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        Font result \u003d this.tickLabelFontMap.get(category);\n        // if there is no specific font, use the general one...\n        if (result \u003d\u003d null) {\n            result \u003d getTickLabelFont();\n        }\n        return result;\n    }\n\n    /**\n     * Sets the font for the tick label for the specified category and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     * @param font  the font ({@code null} permitted).\n     *\n     * @see #getTickLabelFont(Comparable)\n     */\n    public void setTickLabelFont(Comparable category, Font font) {\n        Args.nullNotPermitted(category, \"category\");\n        if (font \u003d\u003d null) {\n            this.tickLabelFontMap.remove(category);\n        } else {\n            this.tickLabelFontMap.put(category, font);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the tick label for the given category.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setTickLabelPaint(Paint)\n     */\n    public Paint getTickLabelPaint(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        Paint result \u003d this.tickLabelPaintMap.get(category);\n        // if there is no specific paint, use the general one...\n        if (result \u003d\u003d null) {\n            result \u003d getTickLabelPaint();\n        }\n        return result;\n    }\n\n    /**\n     * Sets the paint for the tick label for the specified category and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     * @param paint  the paint ({@code null} permitted).\n     *\n     * @see #getTickLabelPaint(Comparable)\n     */\n    public void setTickLabelPaint(Comparable category, Paint paint) {\n        Args.nullNotPermitted(category, \"category\");\n        if (paint \u003d\u003d null) {\n            this.tickLabelPaintMap.remove(category);\n        } else {\n            this.tickLabelPaintMap.put(category, paint);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a tooltip to the specified category and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     * @param tooltip  the tooltip text ({@code null} permitted).\n     *\n     * @see #removeCategoryLabelToolTip(Comparable)\n     */\n    public void addCategoryLabelToolTip(Comparable category, String tooltip) {\n        Args.nullNotPermitted(category, \"category\");\n        this.categoryLabelToolTips.put(category, tooltip);\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the tool tip text for the label belonging to the specified\n     * category.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @return The tool tip text (possibly {@code null}).\n     *\n     * @see #addCategoryLabelToolTip(Comparable, String)\n     * @see #removeCategoryLabelToolTip(Comparable)\n     */\n    public String getCategoryLabelToolTip(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        return this.categoryLabelToolTips.get(category);\n    }\n\n    /**\n     * Removes the tooltip for the specified category and, if there was a value\n     * associated with that category, sends an {@link AxisChangeEvent} to all \n     * registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @see #addCategoryLabelToolTip(Comparable, String)\n     * @see #clearCategoryLabelToolTips()\n     */\n    public void removeCategoryLabelToolTip(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        if (this.categoryLabelToolTips.remove(category) !\u003d null) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears the category label tooltips and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @see #addCategoryLabelToolTip(Comparable, String)\n     * @see #removeCategoryLabelToolTip(Comparable)\n     */\n    public void clearCategoryLabelToolTips() {\n        this.categoryLabelToolTips.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a URL (to be used in image maps) to the specified category and \n     * sends an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     * @param url  the URL text ({@code null} permitted).\n     *\n     * @see #removeCategoryLabelURL(Comparable)\n     */\n    public void addCategoryLabelURL(Comparable category, String url) {\n        Args.nullNotPermitted(category, \"category\");\n        this.categoryLabelURLs.put(category, url);\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the URL for the label belonging to the specified category.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @return The URL text (possibly {@code null}).\n     * \n     * @see #addCategoryLabelURL(Comparable, String)\n     * @see #removeCategoryLabelURL(Comparable)\n     */\n    public String getCategoryLabelURL(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        return this.categoryLabelURLs.get(category);\n    }\n\n    /**\n     * Removes the URL for the specified category and, if there was a URL \n     * associated with that category, sends an {@link AxisChangeEvent} to all \n     * registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @see #addCategoryLabelURL(Comparable, String)\n     * @see #clearCategoryLabelURLs()\n     */\n    public void removeCategoryLabelURL(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        if (this.categoryLabelURLs.remove(category) !\u003d null) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears the category label URLs and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @see #addCategoryLabelURL(Comparable, String)\n     * @see #removeCategoryLabelURL(Comparable)\n     */\n    public void clearCategoryLabelURLs() {\n        this.categoryLabelURLs.clear();\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the Java 2D coordinate for a category.\n     *\n     * @param anchor  the anchor point ({@code null} not permitted).\n     * @param category  the category index.\n     * @param categoryCount  the category count.\n     * @param area  the data area.\n     * @param edge  the location of the axis.\n     *\n     * @return The coordinate.\n     */\n    public double getCategoryJava2DCoordinate(CategoryAnchor anchor, \n            int category, int categoryCount, Rectangle2D area, \n            RectangleEdge edge) {\n        Args.nullNotPermitted(anchor, \"anchor\");\n        double result \u003d 0.0;\n        switch (anchor) {\n            case START:\n                result \u003d getCategoryStart(category, categoryCount, area, edge);\n                break;\n            case MIDDLE:\n                result \u003d getCategoryMiddle(category, categoryCount, area, edge);\n                break;\n            case END:\n                result \u003d getCategoryEnd(category, categoryCount, area, edge);\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected anchor value.\");\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the starting coordinate for the specified category.\n     *\n     * @param category  the category.\n     * @param categoryCount  the number of categories.\n     * @param area  the data area.\n     * @param edge  the axis location.\n     *\n     * @return The coordinate.\n     *\n     * @see #getCategoryMiddle(int, int, Rectangle2D, RectangleEdge)\n     * @see #getCategoryEnd(int, int, Rectangle2D, RectangleEdge)\n     */\n    public double getCategoryStart(int category, int categoryCount, \n            Rectangle2D area, RectangleEdge edge) {\n\n        double result \u003d 0.0;\n        if ((edge \u003d\u003d RectangleEdge.TOP) || (edge \u003d\u003d RectangleEdge.BOTTOM)) {\n            result \u003d area.getX() + area.getWidth() * getLowerMargin();\n        }\n        else if ((edge \u003d\u003d RectangleEdge.LEFT)\n                || (edge \u003d\u003d RectangleEdge.RIGHT)) {\n            result \u003d area.getMinY() + area.getHeight() * getLowerMargin();\n        }\n\n        double categorySize \u003d calculateCategorySize(categoryCount, area, edge);\n        double categoryGapWidth \u003d calculateCategoryGapSize(categoryCount, area,\n                edge);\n\n        result \u003d result + category * (categorySize + categoryGapWidth);\n        return result;\n    }\n\n    /**\n     * Returns the middle coordinate for the specified category.\n     *\n     * @param category  the category.\n     * @param categoryCount  the number of categories.\n     * @param area  the data area.\n     * @param edge  the axis location.\n     *\n     * @return The coordinate.\n     *\n     * @see #getCategoryStart(int, int, Rectangle2D, RectangleEdge)\n     * @see #getCategoryEnd(int, int, Rectangle2D, RectangleEdge)\n     */\n    public double getCategoryMiddle(int category, int categoryCount,\n            Rectangle2D area, RectangleEdge edge) {\n\n        if (category \u003c 0 || category \u003e\u003d categoryCount) {\n            throw new IllegalArgumentException(\"Invalid category index: \"\n                    + category);\n        }\n        return getCategoryStart(category, categoryCount, area, edge)\n               + calculateCategorySize(categoryCount, area, edge) / 2;\n\n    }\n\n    /**\n     * Returns the end coordinate for the specified category.\n     *\n     * @param category  the category.\n     * @param categoryCount  the number of categories.\n     * @param area  the data area.\n     * @param edge  the axis location.\n     *\n     * @return The coordinate.\n     *\n     * @see #getCategoryStart(int, int, Rectangle2D, RectangleEdge)\n     * @see #getCategoryMiddle(int, int, Rectangle2D, RectangleEdge)\n     */\n    public double getCategoryEnd(int category, int categoryCount,\n            Rectangle2D area, RectangleEdge edge) {\n        return getCategoryStart(category, categoryCount, area, edge)\n               + calculateCategorySize(categoryCount, area, edge);\n    }\n\n    /**\n     * A convenience method that returns the axis coordinate for the centre of\n     * a category.\n     *\n     * @param category  the category key ({@code null} not permitted).\n     * @param categories  the categories ({@code null} not permitted).\n     * @param area  the data area ({@code null} not permitted).\n     * @param edge  the edge along which the axis lies ({@code null} not\n     *     permitted).\n     *\n     * @return The centre coordinate.\n     *\n     * @see #getCategorySeriesMiddle(Comparable, Comparable, CategoryDataset,\n     *     double, Rectangle2D, RectangleEdge)\n     */\n    public double getCategoryMiddle(Comparable category,\n            List categories, Rectangle2D area, RectangleEdge edge) {\n        Args.nullNotPermitted(categories, \"categories\");\n        int categoryIndex \u003d categories.indexOf(category);\n        int categoryCount \u003d categories.size();\n        return getCategoryMiddle(categoryIndex, categoryCount, area, edge);\n    }\n\n    /**\n     * Returns the middle coordinate (in Java2D space) for a series within a\n     * category.\n     *\n     * @param category  the category ({@code null} not permitted).\n     * @param seriesKey  the series key ({@code null} not permitted).\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param itemMargin  the item margin (0.0 \u0026lt;\u003d itemMargin \u0026lt; 1.0);\n     * @param area  the area ({@code null} not permitted).\n     * @param edge  the edge ({@code null} not permitted).\n     *\n     * @return The coordinate in Java2D space.\n     */\n    public double getCategorySeriesMiddle(Comparable category,\n            Comparable seriesKey, CategoryDataset dataset, double itemMargin,\n            Rectangle2D area, RectangleEdge edge) {\n\n        int categoryIndex \u003d dataset.getColumnIndex(category);\n        int categoryCount \u003d dataset.getColumnCount();\n        int seriesIndex \u003d dataset.getRowIndex(seriesKey);\n        int seriesCount \u003d dataset.getRowCount();\n        double start \u003d getCategoryStart(categoryIndex, categoryCount, area,\n                edge);\n        double end \u003d getCategoryEnd(categoryIndex, categoryCount, area, edge);\n        double width \u003d end - start;\n        if (seriesCount \u003d\u003d 1) {\n            return start + width / 2.0;\n        }\n        else {\n            double gap \u003d (width * itemMargin) / (seriesCount - 1);\n            double ww \u003d (width * (1 - itemMargin)) / seriesCount;\n            return start + (seriesIndex * (ww + gap)) + ww / 2.0;\n        }\n    }\n\n    /**\n     * Returns the middle coordinate (in Java2D space) for a series within a\n     * category.\n     *\n     * @param categoryIndex  the category index.\n     * @param categoryCount  the category count.\n     * @param seriesIndex the series index.\n     * @param seriesCount the series count.\n     * @param itemMargin  the item margin (0.0 \u0026lt;\u003d itemMargin \u0026lt; 1.0);\n     * @param area  the area ({@code null} not permitted).\n     * @param edge  the edge ({@code null} not permitted).\n     *\n     * @return The coordinate in Java2D space.\n     */\n    public double getCategorySeriesMiddle(int categoryIndex, int categoryCount,\n            int seriesIndex, int seriesCount, double itemMargin,\n            Rectangle2D area, RectangleEdge edge) {\n\n        double start \u003d getCategoryStart(categoryIndex, categoryCount, area,\n                edge);\n        double end \u003d getCategoryEnd(categoryIndex, categoryCount, area, edge);\n        double width \u003d end - start;\n        if (seriesCount \u003d\u003d 1) {\n            return start + width / 2.0;\n        }\n        else {\n            double gap \u003d (width * itemMargin) / (seriesCount - 1);\n            double ww \u003d (width * (1 - itemMargin)) / seriesCount;\n            return start + (seriesIndex * (ww + gap)) + ww / 2.0;\n        }\n    }\n\n    /**\n     * Calculates the size (width or height, depending on the location of the\n     * axis) of a category.\n     *\n     * @param categoryCount  the number of categories.\n     * @param area  the area within which the categories will be drawn.\n     * @param edge  the axis location.\n     *\n     * @return The category size.\n     */\n    protected double calculateCategorySize(int categoryCount, Rectangle2D area,\n            RectangleEdge edge) {\n        double result;\n        double available \u003d 0.0;\n\n        if ((edge \u003d\u003d RectangleEdge.TOP) || (edge \u003d\u003d RectangleEdge.BOTTOM)) {\n            available \u003d area.getWidth();\n        }\n        else if ((edge \u003d\u003d RectangleEdge.LEFT)\n                || (edge \u003d\u003d RectangleEdge.RIGHT)) {\n            available \u003d area.getHeight();\n        }\n        if (categoryCount \u003e 1) {\n            result \u003d available * (1 - getLowerMargin() - getUpperMargin()\n                     - getCategoryMargin());\n            result \u003d result / categoryCount;\n        }\n        else {\n            result \u003d available * (1 - getLowerMargin() - getUpperMargin());\n        }\n        return result;\n    }\n\n    /**\n     * Calculates the size (width or height, depending on the location of the\n     * axis) of a category gap.\n     *\n     * @param categoryCount  the number of categories.\n     * @param area  the area within which the categories will be drawn.\n     * @param edge  the axis location.\n     *\n     * @return The category gap width.\n     */\n    protected double calculateCategoryGapSize(int categoryCount, \n            Rectangle2D area, RectangleEdge edge) {\n\n        double result \u003d 0.0;\n        double available \u003d 0.0;\n\n        if ((edge \u003d\u003d RectangleEdge.TOP) || (edge \u003d\u003d RectangleEdge.BOTTOM)) {\n            available \u003d area.getWidth();\n        }\n        else if ((edge \u003d\u003d RectangleEdge.LEFT)\n                || (edge \u003d\u003d RectangleEdge.RIGHT)) {\n            available \u003d area.getHeight();\n        }\n\n        if (categoryCount \u003e 1) {\n            result \u003d available * getCategoryMargin() / (categoryCount - 1);\n        }\n        return result;\n    }\n\n    /**\n     * Estimates the space required for the axis, given a specific drawing area.\n     *\n     * @param g2  the graphics device (used to obtain font information).\n     * @param plot  the plot that the axis belongs to.\n     * @param plotArea  the area within which the axis should be drawn.\n     * @param edge  the axis location ({@code null} not permitted).\n     * @param space  the space already reserved.\n     *\n     * @return The space required to draw the axis.\n     */\n    @Override\n    public AxisSpace reserveSpace(Graphics2D g2, Plot plot, \n            Rectangle2D plotArea, RectangleEdge edge, AxisSpace space) {\n\n        // create a new space object if one wasn\u0027t supplied...\n        if (space \u003d\u003d null) {\n            space \u003d new AxisSpace();\n        }\n\n        // if the axis is not visible, no additional space is required...\n        if (!isVisible()) {\n            return space;\n        }\n\n        // calculate the max size of the tick labels (if visible)...\n        double tickLabelHeight \u003d 0.0;\n        double tickLabelWidth \u003d 0.0;\n        if (isTickLabelsVisible()) {\n            g2.setFont(getTickLabelFont());\n            AxisState state \u003d new AxisState();\n            // we call refresh ticks just to get the maximum width or height\n            refreshTicks(g2, state, plotArea, edge);\n            switch (edge) {\n                case TOP:\n                    tickLabelHeight \u003d state.getMax();\n                    break;\n                case BOTTOM:\n                    tickLabelHeight \u003d state.getMax();\n                    break;\n                case LEFT:\n                    tickLabelWidth \u003d state.getMax();\n                    break;\n                case RIGHT:\n                    tickLabelWidth \u003d state.getMax();\n                    break;\n                default:\n                    throw new IllegalStateException(\"Unexpected RectangleEdge value.\");\n            }\n        }\n\n        // get the axis label size and update the space object...\n        Rectangle2D labelEnclosure \u003d getLabelEnclosure(g2, edge);\n        double labelHeight, labelWidth;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            labelHeight \u003d labelEnclosure.getHeight();\n            space.add(labelHeight + tickLabelHeight\n                    + this.categoryLabelPositionOffset, edge);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            labelWidth \u003d labelEnclosure.getWidth();\n            space.add(labelWidth + tickLabelWidth\n                    + this.categoryLabelPositionOffset, edge);\n        }\n        return space;\n    }\n\n    /**\n     * Configures the axis against the current plot.\n     */\n    @Override\n    public void configure() {\n        // nothing required\n    }\n\n    /**\n     * Draws the axis on a Java 2D graphics device (such as the screen or a\n     * printer).\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param cursor  the cursor location.\n     * @param plotArea  the area within which the axis should be drawn\n     *                  ({@code null} not permitted).\n     * @param dataArea  the area within which the plot is being drawn\n     *                  ({@code null} not permitted).\n     * @param edge  the location of the axis ({@code null} not permitted).\n     * @param plotState  collects information about the plot\n     *                   ({@code null} permitted).\n     *\n     * @return The axis state (never {@code null}).\n     */\n    @Override\n    public AxisState draw(Graphics2D g2, double cursor, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge,\n            PlotRenderingInfo plotState) {\n\n        // if the axis is not visible, don\u0027t draw it...\n        if (!isVisible()) {\n            return new AxisState(cursor);\n        }\n\n        if (isAxisLineVisible()) {\n            drawAxisLine(g2, cursor, dataArea, edge);\n        }\n        AxisState state \u003d new AxisState(cursor);\n        if (isTickMarksVisible()) {\n            state.drawTickMarks(g2, cursor, dataArea, edge, this);\n        }\n\n        createAndAddEntity(cursor, state, dataArea, edge, plotState);\n\n        // draw the category labels and axis label\n        state \u003d drawCategoryLabels(g2, plotArea, dataArea, edge, state,\n                plotState);\n        if (getAttributedLabel() !\u003d null) {\n            state \u003d drawAttributedLabel(getAttributedLabel(), g2, plotArea, \n                    dataArea, edge, state);\n            \n        } else {\n            state \u003d drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);\n        }\n        return state;\n\n    }\n\n    /**\n     * Draws the category labels and returns the updated axis state.\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param plotArea  the plot area ({@code null} not permitted).\n     * @param dataArea  the area inside the axes ({@code null} not\n     *                  permitted).\n     * @param edge  the axis location ({@code null} not permitted).\n     * @param state  the axis state ({@code null} not permitted).\n     * @param plotState  collects information about the plot ({@code null}\n     *                   permitted).\n     *\n     * @return The updated axis state (never {@code null}).\n     */\n    protected AxisState drawCategoryLabels(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state,\n            PlotRenderingInfo plotState) {\n\n        Args.nullNotPermitted(state, \"state\");\n        if (!isTickLabelsVisible()) {\n            return state;\n        }\n \n        List ticks \u003d refreshTicks(g2, state, plotArea, edge);\n        state.setTicks(ticks);\n        int categoryIndex \u003d 0;\n        for (Object o : ticks) {\n            CategoryTick tick \u003d (CategoryTick) o;\n            g2.setFont(getTickLabelFont(tick.getCategory()));\n            g2.setPaint(getTickLabelPaint(tick.getCategory()));\n\n            CategoryLabelPosition position\n                    \u003d this.categoryLabelPositions.getLabelPosition(edge);\n            double x0 \u003d 0.0;\n            double x1 \u003d 0.0;\n            double y0 \u003d 0.0;\n            double y1 \u003d 0.0;\n            if (edge \u003d\u003d RectangleEdge.TOP) {\n                x0 \u003d getCategoryStart(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                x1 \u003d getCategoryEnd(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                y1 \u003d state.getCursor() - this.categoryLabelPositionOffset;\n                y0 \u003d y1 - state.getMax();\n            }\n            else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n                x0 \u003d getCategoryStart(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                x1 \u003d getCategoryEnd(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                y0 \u003d state.getCursor() + this.categoryLabelPositionOffset;\n                y1 \u003d y0 + state.getMax();\n            }\n            else if (edge \u003d\u003d RectangleEdge.LEFT) {\n                y0 \u003d getCategoryStart(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                y1 \u003d getCategoryEnd(categoryIndex, ticks.size(), dataArea,\n                        edge);\n                x1 \u003d state.getCursor() - this.categoryLabelPositionOffset;\n                x0 \u003d x1 - state.getMax();\n            }\n            else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n                y0 \u003d getCategoryStart(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                y1 \u003d getCategoryEnd(categoryIndex, ticks.size(), dataArea,\n                        edge);\n                x0 \u003d state.getCursor() + this.categoryLabelPositionOffset;\n                x1 \u003d x0 - state.getMax();\n            }\n            Rectangle2D area \u003d new Rectangle2D.Double(x0, y0, (x1 - x0),\n                    (y1 - y0));\n            Point2D anchorPoint \u003d position.getCategoryAnchor().getAnchorPoint(area);\n            TextBlock block \u003d tick.getLabel();\n            block.draw(g2, (float) anchorPoint.getX(),\n                    (float) anchorPoint.getY(), position.getLabelAnchor(),\n                    (float) anchorPoint.getX(), (float) anchorPoint.getY(),\n                    position.getAngle());\n            Shape bounds \u003d block.calculateBounds(g2,\n                    (float) anchorPoint.getX(), (float) anchorPoint.getY(),\n                    position.getLabelAnchor(), (float) anchorPoint.getX(),\n                    (float) anchorPoint.getY(), position.getAngle());\n            if (plotState !\u003d null \u0026\u0026 plotState.getOwner() !\u003d null) {\n                EntityCollection entities \u003d plotState.getOwner()\n                        .getEntityCollection();\n                if (entities !\u003d null) {\n                    String tooltip \u003d getCategoryLabelToolTip(\n                            tick.getCategory());\n                    String url \u003d getCategoryLabelURL(tick.getCategory());\n                    entities.add(new CategoryLabelEntity(tick.getCategory(),\n                            bounds, tooltip, url));\n                }\n            }\n            categoryIndex++;\n        }\n\n        if (edge.equals(RectangleEdge.TOP)) {\n            double h \u003d state.getMax() + this.categoryLabelPositionOffset;\n            state.cursorUp(h);\n        }\n        else if (edge.equals(RectangleEdge.BOTTOM)) {\n            double h \u003d state.getMax() + this.categoryLabelPositionOffset;\n            state.cursorDown(h);\n        }\n        else if (edge \u003d\u003d RectangleEdge.LEFT) {\n            double w \u003d state.getMax() + this.categoryLabelPositionOffset;\n            state.cursorLeft(w);\n        }\n        else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n            double w \u003d state.getMax() + this.categoryLabelPositionOffset;\n            state.cursorRight(w);\n        }\n        return state;\n    }\n\n    /**\n     * Creates a temporary list of ticks that can be used when drawing the axis.\n     *\n     * @param g2  the graphics device (used to get font measurements).\n     * @param state  the axis state.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the location of the axis.\n     *\n     * @return A list of ticks.\n     */\n    @Override\n    public List refreshTicks(Graphics2D g2, AxisState state, \n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        List ticks \u003d new java.util.ArrayList(); // FIXME generics\n\n        // sanity check for data area...\n        if (dataArea.getHeight() \u003c\u003d 0.0 || dataArea.getWidth() \u003c 0.0) {\n            return ticks;\n        }\n\n        CategoryPlot plot \u003d (CategoryPlot) getPlot();\n        List categories \u003d plot.getCategoriesForAxis(this);\n        double max \u003d 0.0;\n\n        if (categories !\u003d null) {\n            CategoryLabelPosition position\n                    \u003d this.categoryLabelPositions.getLabelPosition(edge);\n            float r \u003d this.maximumCategoryLabelWidthRatio;\n            if (r \u003c\u003d 0.0) {\n                r \u003d position.getWidthRatio();\n            }\n\n            float l;\n            if (position.getWidthType() \u003d\u003d CategoryLabelWidthType.CATEGORY) {\n                l \u003d (float) calculateCategorySize(categories.size(), dataArea,\n                        edge);\n            }\n            else {\n                if (RectangleEdge.isLeftOrRight(edge)) {\n                    l \u003d (float) dataArea.getWidth();\n                }\n                else {\n                    l \u003d (float) dataArea.getHeight();\n                }\n            }\n            int categoryIndex \u003d 0;\n            for (Object o : categories) {\n                Comparable category \u003d (Comparable) o;\n                g2.setFont(getTickLabelFont(category));\n                TextBlock label \u003d createLabel(category, l * r, edge, g2);\n                if (edge \u003d\u003d RectangleEdge.TOP || edge \u003d\u003d RectangleEdge.BOTTOM) {\n                    max \u003d Math.max(max, calculateCategoryLabelHeight(label,\n                            position, getTickLabelInsets(), g2));\n                } else if (edge \u003d\u003d RectangleEdge.LEFT\n                        || edge \u003d\u003d RectangleEdge.RIGHT) {\n                    max \u003d Math.max(max, calculateCategoryLabelWidth(label,\n                            position, getTickLabelInsets(), g2));\n                }\n                Tick tick \u003d new CategoryTick(category, label,\n                        position.getLabelAnchor(),\n                        position.getRotationAnchor(), position.getAngle());\n                ticks.add(tick);\n                categoryIndex \u003d categoryIndex + 1;\n            }\n        }\n        state.setMax(max);\n        return ticks;\n\n    }\n\n    /**\n     * Creates a label.\n     *\n     * @param category  the category.\n     * @param width  the available width.\n     * @param edge  the edge on which the axis appears.\n     * @param g2  the graphics device.\n     *\n     * @return A label.\n     */\n    protected TextBlock createLabel(Comparable category, float width,\n            RectangleEdge edge, Graphics2D g2) {\n        TextBlock label \u003d TextUtils.createTextBlock(category.toString(),\n                getTickLabelFont(category), getTickLabelPaint(category), width,\n                this.maximumCategoryLabelLines, new G2TextMeasurer(g2));\n        return label;\n    }\n\n    /**\n     * Calculates the width of a category label when rendered.\n     *\n     * @param label  the text block ({@code null} not permitted).\n     * @param position  the position.\n     * @param insets  the label insets.\n     * @param g2  the graphics device.\n     *\n     * @return The width.\n     */\n    protected double calculateCategoryLabelWidth(TextBlock label, \n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2) {\n        Size2D size \u003d label.calculateDimensions(g2);\n        Rectangle2D box \u003d new Rectangle2D.Double(0.0, 0.0, size.getWidth(),\n                size.getHeight());\n        Shape rotatedBox \u003d ShapeUtils.rotateShape(box, position.getAngle(),\n                0.0f, 0.0f);\n        double w \u003d rotatedBox.getBounds2D().getWidth() + insets.getLeft()\n                + insets.getRight();\n        return w;\n    }\n\n    /**\n     * Calculates the height of a category label when rendered.\n     *\n     * @param block  the text block ({@code null} not permitted).\n     * @param position  the label position ({@code null} not permitted).\n     * @param insets  the label insets ({@code null} not permitted).\n     * @param g2  the graphics device ({@code null} not permitted).\n     *\n     * @return The height.\n     */\n    protected double calculateCategoryLabelHeight(TextBlock block,\n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2) {\n        Size2D size \u003d block.calculateDimensions(g2);\n        Rectangle2D box \u003d new Rectangle2D.Double(0.0, 0.0, size.getWidth(),\n                size.getHeight());\n        Shape rotatedBox \u003d ShapeUtils.rotateShape(box, position.getAngle(),\n                0.0f, 0.0f);\n        double h \u003d rotatedBox.getBounds2D().getHeight()\n                   + insets.getTop() + insets.getBottom();\n        return h;\n    }\n\n    /**\n     * Creates a clone of the axis.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if some component of the axis does\n     *         not support cloning.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        CategoryAxis clone \u003d (CategoryAxis) super.clone();\n        clone.tickLabelFontMap \u003d new HashMap\u003c\u003e(this.tickLabelFontMap);\n        clone.tickLabelPaintMap \u003d new HashMap\u003c\u003e(this.tickLabelPaintMap);\n        clone.categoryLabelToolTips \u003d new HashMap\u003c\u003e(this.categoryLabelToolTips);\n        clone.categoryLabelURLs \u003d new HashMap\u003c\u003e(this.categoryLabelToolTips);\n        return clone;\n    }\n\n    /**\n     * Tests this axis for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryAxis)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        CategoryAxis that \u003d (CategoryAxis) obj;\n        if (that.lowerMargin !\u003d this.lowerMargin) {\n            return false;\n        }\n        if (that.upperMargin !\u003d this.upperMargin) {\n            return false;\n        }\n        if (that.categoryMargin !\u003d this.categoryMargin) {\n            return false;\n        }\n        if (that.maximumCategoryLabelWidthRatio\n                !\u003d this.maximumCategoryLabelWidthRatio) {\n            return false;\n        }\n        if (that.categoryLabelPositionOffset\n                !\u003d this.categoryLabelPositionOffset) {\n            return false;\n        }\n        if (!Objects.equals(that.categoryLabelPositions, this.categoryLabelPositions)) {\n            return false;\n        }\n        if (!Objects.equals(that.categoryLabelToolTips, this.categoryLabelToolTips)) {\n            return false;\n        }\n        if (!Objects.equals(this.categoryLabelURLs, that.categoryLabelURLs)) {\n            return false;\n        }\n        if (!Objects.equals(this.tickLabelFontMap, that.tickLabelFontMap)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.tickLabelPaintMap, that.tickLabelPaintMap)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this object.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        writePaintMap(this.tickLabelPaintMap, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.tickLabelPaintMap \u003d readPaintMap(stream);\n    }\n\n    /**\n     * Reads a {@code Map} of ({@code Comparable}, {@code Paint})\n     * elements from a stream.\n     *\n     * @param in  the input stream.\n     *\n     * @return The map.\n     *\n     * @throws IOException\n     * @throws ClassNotFoundException\n     *\n     * @see #writePaintMap(Map, ObjectOutputStream)\n     */\n    private Map readPaintMap(ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n        boolean isNull \u003d in.readBoolean();\n        if (isNull) {\n            return null;\n        }\n        Map result \u003d new HashMap();\n        int count \u003d in.readInt();\n        for (int i \u003d 0; i \u003c count; i++) {\n            Comparable category \u003d (Comparable) in.readObject();\n            Paint paint \u003d SerialUtils.readPaint(in);\n            result.put(category, paint);\n        }\n        return result;\n    }\n\n    /**\n     * Writes a map of ({@code Comparable}, {@code Paint})\n     * elements to a stream.\n     *\n     * @param map  the map ({@code null} permitted).\n     *\n     * @param out\n     * @throws IOException\n     *\n     * @see #readPaintMap(ObjectInputStream)\n     */\n    private void writePaintMap(Map map, ObjectOutputStream out)\n            throws IOException {\n        if (map \u003d\u003d null) {\n            out.writeBoolean(true);\n        }\n        else {\n            out.writeBoolean(false);\n            Set keys \u003d map.keySet();\n            int count \u003d keys.size();\n            out.writeInt(count);\n            for (Object o : keys) {\n                Comparable key \u003d (Comparable) o;\n                out.writeObject(key);\n                SerialUtils.writePaint((Paint) map.get(key), out);\n            }\n        }\n    }\n\n}","methodCount":52,"staticMethodCount":0,"instanceMethodCount":52,"classLoc":1262,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":3,"candidates":[{"lineStart":1146,"lineEnd":1166,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method calculateCategoryLabelHeight to class TextBlock","description":"Move method calculateCategoryLabelHeight to org.jfree.chart.text.TextBlock\nRationale: The method `calculateCategoryLabelHeight` relies most heavily on the `TextBlock` class, as it calls `block.calculateDimensions(g2)` to perform a significant part of its function. Moving this method to `TextBlock` will centralize functionality related to text block dimension calculations in one place, providing better cohesion and potentially simplifying future maintenance.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false},{"lineStart":666,"lineEnd":699,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method getCategorySeriesMiddle to class CategoryDataset","description":"Move method getCategorySeriesMiddle to org.jfree.data.category.CategoryDataset\nRationale: The method `getCategorySeriesMiddle` relies heavily on the structure and indices of the `CategoryDataset` class. It references dataset-specific methods and indices like `getColumnIndex`, `getColumnCount`, `getRowIndex`, and `getRowCount`, which are specific to datasets and inherently tied to their layout and content. Therefore, `CategoryDataset` is the most suitable class for this method to ensure data cohesion and maintain a clear, logical structure.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false},{"lineStart":1124,"lineEnd":1144,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method calculateCategoryLabelWidth to class TextBlock","description":"Move method calculateCategoryLabelWidth to org.jfree.chart.text.TextBlock\nRationale: The method `calculateCategoryLabelWidth` relies heavily on the `TextBlock` class to calculate the dimensions of the label and involves rendering logic related to the text block. By relocating the method to `TextBlock`, it encapsulates logic directly related to rendering and dimension calculation within the class responsible for managing text, improving cohesion and reducing dependencies with external classes.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":47378}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":139},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"getCategorySeriesMiddle","method_signature":"public getCategorySeriesMiddle(Comparable category,\n            Comparable seriesKey, CategoryDataset dataset, double itemMargin,\n            Rectangle2D area, RectangleEdge edge)","target_class":"","rationale":""},{"method_name":"drawCategoryLabels","method_signature":"protected drawCategoryLabels(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state,\n            PlotRenderingInfo plotState)","target_class":"","rationale":""},{"method_name":"calculateCategoryLabelWidth","method_signature":"protected calculateCategoryLabelWidth(TextBlock label, \n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""},{"method_name":"calculateCategoryLabelHeight","method_signature":"protected calculateCategoryLabelHeight(TextBlock block,\n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"drawCategoryLabels","method_signature":"protected drawCategoryLabels(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state,\n            PlotRenderingInfo plotState)","target_class":"","rationale":""},{"method_name":"calculateCategoryLabelHeight","method_signature":"protected calculateCategoryLabelHeight(TextBlock block,\n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""},{"method_name":"getCategorySeriesMiddle","method_signature":"public getCategorySeriesMiddle(Comparable category,\n            Comparable seriesKey, CategoryDataset dataset, double itemMargin,\n            Rectangle2D area, RectangleEdge edge)","target_class":"","rationale":""},{"method_name":"calculateCategoryLabelWidth","method_signature":"protected calculateCategoryLabelWidth(TextBlock label, \n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"protected drawCategoryLabels(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state,\n            PlotRenderingInfo plotState)":{"first":{"method_name":"drawCategoryLabels","method_signature":"protected drawCategoryLabels(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state,\n            PlotRenderingInfo plotState)","target_class":"","rationale":""},"second":0.5835401410129413},"protected calculateCategoryLabelHeight(TextBlock block,\n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)":{"first":{"method_name":"calculateCategoryLabelHeight","method_signature":"protected calculateCategoryLabelHeight(TextBlock block,\n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""},"second":0.7522964337873133},"public getCategorySeriesMiddle(Comparable category,\n            Comparable seriesKey, CategoryDataset dataset, double itemMargin,\n            Rectangle2D area, RectangleEdge edge)":{"first":{"method_name":"getCategorySeriesMiddle","method_signature":"public getCategorySeriesMiddle(Comparable category,\n            Comparable seriesKey, CategoryDataset dataset, double itemMargin,\n            Rectangle2D area, RectangleEdge edge)","target_class":"","rationale":""},"second":0.7849747734416521},"protected calculateCategoryLabelWidth(TextBlock label, \n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)":{"first":{"method_name":"calculateCategoryLabelWidth","method_signature":"protected calculateCategoryLabelWidth(TextBlock label, \n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""},"second":0.806778774538653}},"targetClassMap":{"drawCategoryLabels":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":0,"similarity_computation_time":0,"similarity_metric":"cosine"},"calculateCategoryLabelHeight":{"target_classes":[{"class_name":"TextBlock","similarity_score":0.7011913103331406},{"class_name":"CategoryLabelPosition","similarity_score":0.7361336689221182},{"class_name":"RectangleInsets","similarity_score":0.6933703123527621},{"class_name":"CategoryLabelPositions","similarity_score":0.6654201622829171}],"target_classes_sorted_by_llm":["TextBlock","CategoryLabelPosition","RectangleInsets"],"llm_response_time":0,"similarity_computation_time":4,"similarity_metric":"cosine"},"getCategorySeriesMiddle":{"target_classes":[{"class_name":"CategoryDataset","similarity_score":0.4133068570297462},{"class_name":"RectangleEdge","similarity_score":0.5433384646359788},{"class_name":"CategoryLabelPositions","similarity_score":0.6277228465829806}],"target_classes_sorted_by_llm":["CategoryDataset","CategoryLabelPositions","RectangleEdge"],"llm_response_time":0,"similarity_computation_time":1,"similarity_metric":"cosine"},"calculateCategoryLabelWidth":{"target_classes":[{"class_name":"TextBlock","similarity_score":0.7646439778966989},{"class_name":"CategoryLabelPosition","similarity_score":0.7621550089818219},{"class_name":"RectangleInsets","similarity_score":0.7712776634736744},{"class_name":"CategoryLabelPositions","similarity_score":0.6868161123688303}],"target_classes_sorted_by_llm":["TextBlock","CategoryLabelPosition","RectangleInsets"],"llm_response_time":0,"similarity_computation_time":1,"similarity_metric":"cosine"}}}
{"id":"295693f9-5135-458a-b9c9-f92c7d207c5f","hostFunctionTelemetryData":{"hostFunctionSize":976,"lineStart":64,"lineEnd":1039,"bodyLineStart":64,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/axis/LogAxis.java","sourceCode":"/**\n * A numerical axis that uses a logarithmic scale.  The class is an\n * alternative to the {@link LogarithmicAxis} class.\n */\npublic class LogAxis extends ValueAxis {\n\n    /** The logarithm base. */\n    private double base \u003d 10.0;\n\n    /** The logarithm of the base value - cached for performance. */\n    private double baseLog \u003d Math.log(10.0);\n\n    /** \n     * The base symbol to display (if {@code null} then the numerical\n     * value of the base is displayed).\n     */\n    private String baseSymbol \u003d null;\n    \n    /** \n     * The formatter to use for the base value when the base is displayed\n     * as a numerical value.\n     */\n    private Format baseFormatter \u003d new DecimalFormat(\"0\");\n    \n    /**  The smallest value permitted on the axis. */\n    private double smallestValue \u003d 1E-100;\n\n    /** The current tick unit. */\n    private NumberTickUnit tickUnit;\n\n    /** The override number format. */\n    private NumberFormat numberFormatOverride;\n\n    /**\n     * Creates a new {@code LogAxis} with no label.\n     */\n    public LogAxis() {\n        this(null);\n    }\n\n    /**\n     * Creates a new {@code LogAxis}with the given label.\n     *\n     * @param label  the axis label ({@code null} permitted).\n     */\n    public LogAxis(String label) {\n        super(label, new NumberTickUnitSource());\n        setDefaultAutoRange(new Range(0.01, 1.0));\n        this.tickUnit \u003d new NumberTickUnit(1.0, new DecimalFormat(\"0.#\"), 10);\n    }\n\n    /**\n     * Returns the base for the logarithm calculation.  The default value is\n     * {@code 10.0}.\n     *\n     * @return The base for the logarithm calculation.\n     *\n     * @see #setBase(double)\n     */\n    public double getBase() {\n        return this.base;\n    }\n\n    /**\n     * Sets the base for the logarithm calculation and sends a change event to\n     * all registered listeners.\n     *\n     * @param base  the base value (must be \u0026gt; 1.0).\n     *\n     * @see #getBase()\n     */\n    public void setBase(double base) {\n        if (base \u003c\u003d 1.0) {\n            throw new IllegalArgumentException(\"Requires \u0027base\u0027 \u003e 1.0.\");\n        }\n        this.base \u003d base;\n        this.baseLog \u003d Math.log(base);\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the symbol used to represent the base of the logarithmic scale\n     * for the axis.  If this is {@code null} (the default) then the \n     * numerical value of the base is displayed.\n     * \n     * @return The base symbol (possibly {@code null}).\n     */\n    public String getBaseSymbol() {\n        return this.baseSymbol;\n    }\n    \n    /**\n     * Sets the symbol used to represent the base value of the logarithmic \n     * scale and sends a change event to all registered listeners.\n     * \n     * @param symbol  the symbol ({@code null} permitted).\n     */\n    public void setBaseSymbol(String symbol) {\n        this.baseSymbol \u003d symbol;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the formatter used to format the base value of the logarithmic\n     * scale when it is displayed numerically.  The default value is\n     * {@code new DecimalFormat(\"0\")}.\n     * \n     * @return The base formatter (never {@code null}).\n     */\n    public Format getBaseFormatter() {\n        return this.baseFormatter;\n    }\n    \n    /**\n     * Sets the formatter used to format the base value of the logarithmic \n     * scale when it is displayed numerically and sends a change event to all\n     * registered listeners.\n     * \n     * @param formatter  the formatter ({@code null} not permitted).\n     */\n    public void setBaseFormatter(Format formatter) {\n        Args.nullNotPermitted(formatter, \"formatter\");\n        this.baseFormatter \u003d formatter;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the smallest value represented by the axis.\n     *\n     * @return The smallest value represented by the axis.\n     *\n     * @see #setSmallestValue(double)\n     */\n    public double getSmallestValue() {\n        return this.smallestValue;\n    }\n\n    /**\n     * Sets the smallest value represented by the axis and sends a change event\n     * to all registered listeners.\n     *\n     * @param value  the value.\n     *\n     * @see #getSmallestValue()\n     */\n    public void setSmallestValue(double value) {\n        if (value \u003c\u003d 0.0) {\n            throw new IllegalArgumentException(\"Requires \u0027value\u0027 \u003e 0.0.\");\n        }\n        this.smallestValue \u003d value;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the current tick unit.\n     *\n     * @return The current tick unit.\n     *\n     * @see #setTickUnit(NumberTickUnit)\n     */\n    public NumberTickUnit getTickUnit() {\n        return this.tickUnit;\n    }\n\n    /**\n     * Sets the tick unit for the axis and sends an {@link AxisChangeEvent} to\n     * all registered listeners.  A side effect of calling this method is that\n     * the \"auto-select\" feature for tick units is switched off (you can\n     * restore it using the {@link ValueAxis#setAutoTickUnitSelection(boolean)}\n     * method).\n     *\n     * @param unit  the new tick unit ({@code null} not permitted).\n     *\n     * @see #getTickUnit()\n     */\n    public void setTickUnit(NumberTickUnit unit) {\n        // defer argument checking...\n        setTickUnit(unit, true, true);\n    }\n\n    /**\n     * Sets the tick unit for the axis and, if requested, sends an\n     * {@link AxisChangeEvent} to all registered listeners.  In addition, an\n     * option is provided to turn off the \"auto-select\" feature for tick units\n     * (you can restore it using the\n     * {@link ValueAxis#setAutoTickUnitSelection(boolean)} method).\n     *\n     * @param unit  the new tick unit ({@code null} not permitted).\n     * @param notify  notify listeners?\n     * @param turnOffAutoSelect  turn off the auto-tick selection?\n     *\n     * @see #getTickUnit()\n     */\n    public void setTickUnit(NumberTickUnit unit, boolean notify,\n            boolean turnOffAutoSelect) {\n        Args.nullNotPermitted(unit, \"unit\");\n        this.tickUnit \u003d unit;\n        if (turnOffAutoSelect) {\n            setAutoTickUnitSelection(false, false);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the number format override.  If this is non-{@code null}, \n     * then it will be used to format the numbers on the axis.\n     *\n     * @return The number formatter (possibly {@code null}).\n     *\n     * @see #setNumberFormatOverride(NumberFormat)\n     */\n    public NumberFormat getNumberFormatOverride() {\n        return this.numberFormatOverride;\n    }\n\n    /**\n     * Sets the number format override and sends a change event to all \n     * registered listeners.  If this is non-{@code null}, then it will be\n     * used to format the numbers on the axis.\n     *\n     * @param formatter  the number formatter ({@code null} permitted).\n     *\n     * @see #getNumberFormatOverride()\n     */\n    public void setNumberFormatOverride(NumberFormat formatter) {\n        this.numberFormatOverride \u003d formatter;\n        fireChangeEvent();\n    }\n\n    /**\n     * Calculates the log of the given value, using the current base.\n     *\n     * @param value  the value.\n     *\n     * @return The log of the given value.\n     *\n     * @see #calculateValue(double)\n     * @see #getBase()\n     */\n    public double calculateLog(double value) {\n        return Math.log(value) / this.baseLog;\n    }\n\n    /**\n     * Calculates the value from a given log.\n     *\n     * @param log  the log value.\n     *\n     * @return The value with the given log.\n     *\n     * @see #calculateLog(double)\n     * @see #getBase()\n     */\n    public double calculateValue(double log) {\n        return Math.pow(this.base, log);\n    }\n    \n    private double calculateValueNoINF(double log) {\n        double result \u003d calculateValue(log);\n        if (Double.isInfinite(result)) {\n            result \u003d Double.MAX_VALUE;\n        }\n        if (result \u003c\u003d 0.0) {\n            result \u003d Double.MIN_VALUE;\n        }\n        return result;\n    }\n\n    /**\n     * Converts a Java2D coordinate to an axis value, assuming that the\n     * axis is aligned to the specified {@code edge} of the {@code area}.\n     *\n     * @param java2DValue  the Java2D coordinate.\n     * @param area  the area for plotting data ({@code null} not \n     *     permitted).\n     * @param edge  the edge that the axis is aligned to ({@code null} not\n     *     permitted).\n     *\n     * @return A value along the axis scale.\n     */\n    @Override\n    public double java2DToValue(double java2DValue, Rectangle2D area,\n            RectangleEdge edge) {\n\n        Range range \u003d getRange();\n        double axisMin \u003d calculateLog(Math.max(this.smallestValue, \n                range.getLowerBound()));\n        double axisMax \u003d calculateLog(range.getUpperBound());\n\n        double min \u003d 0.0;\n        double max \u003d 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            min \u003d area.getX();\n            max \u003d area.getMaxX();\n        } else if (RectangleEdge.isLeftOrRight(edge)) {\n            min \u003d area.getMaxY();\n            max \u003d area.getY();\n        }\n        double log;\n        if (isInverted()) {\n            log \u003d axisMax - (java2DValue - min) / (max - min)\n                    * (axisMax - axisMin);\n        } else {\n            log \u003d axisMin + (java2DValue - min) / (max - min)\n                    * (axisMax - axisMin);\n        }\n        return calculateValue(log);\n    }\n\n    /**\n     * Converts a value on the axis scale to a Java2D coordinate relative to\n     * the given {@code area}, based on the axis running along the\n     * specified {@code edge}.\n     *\n     * @param value  the data value.\n     * @param area  the area ({@code null} not permitted).\n     * @param edge  the edge ({@code null} not permitted).\n     *\n     * @return The Java2D coordinate corresponding to {@code value}.\n     */\n    @Override\n    public double valueToJava2D(double value, Rectangle2D area,\n            RectangleEdge edge) {\n\n        Range range \u003d getRange();\n        double axisMin \u003d calculateLog(range.getLowerBound());\n        double axisMax \u003d calculateLog(range.getUpperBound());\n        value \u003d calculateLog(value);\n\n        double min \u003d 0.0;\n        double max \u003d 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            min \u003d area.getX();\n            max \u003d area.getMaxX();\n        } else if (RectangleEdge.isLeftOrRight(edge)) {\n            max \u003d area.getMinY();\n            min \u003d area.getMaxY();\n        }\n        if (isInverted()) {\n            return max\n                   - ((value - axisMin) / (axisMax - axisMin)) * (max - min);\n        } else {\n            return min\n                   + ((value - axisMin) / (axisMax - axisMin)) * (max - min);\n        }\n    }\n\n    /**\n     * Configures the axis.  This method is typically called when an axis\n     * is assigned to a new plot.\n     */\n    @Override\n    public void configure() {\n        if (isAutoRange()) {\n            autoAdjustRange();\n        }\n    }\n\n    /**\n     * Adjusts the axis range to match the data range that the axis is\n     * required to display.\n     */\n    @Override\n    protected void autoAdjustRange() {\n        Plot plot \u003d getPlot();\n        if (plot \u003d\u003d null) {\n            return;  // no plot, no data\n        }\n\n        if (plot instanceof ValueAxisPlot) {\n            ValueAxisPlot vap \u003d (ValueAxisPlot) plot;\n\n            Range r \u003d vap.getDataRange(this);\n            if (r \u003d\u003d null) {\n                r \u003d getDefaultAutoRange();\n            }\n\n            double upper \u003d r.getUpperBound();\n            double lower \u003d Math.max(r.getLowerBound(), this.smallestValue);\n            double range \u003d upper - lower;\n\n            // if fixed auto range, then derive lower bound...\n            double fixedAutoRange \u003d getFixedAutoRange();\n            if (fixedAutoRange \u003e 0.0) {\n                lower \u003d Math.max(upper - fixedAutoRange, this.smallestValue);\n            }\n            else {\n                // ensure the autorange is at least \u003cminRange\u003e in size...\n                double minRange \u003d getAutoRangeMinimumSize();\n                if (range \u003c minRange) {\n                    double expand \u003d (minRange - range) / 2;\n                    upper \u003d upper + expand;\n                    lower \u003d lower - expand;\n                }\n\n                // apply the margins - these should apply to the exponent range\n                double logUpper \u003d calculateLog(upper);\n                double logLower \u003d calculateLog(lower);\n                double logRange \u003d logUpper - logLower;\n                logUpper \u003d logUpper + getUpperMargin() * logRange;\n                logLower \u003d logLower - getLowerMargin() * logRange;\n                upper \u003d calculateValueNoINF(logUpper);\n                lower \u003d calculateValueNoINF(logLower);\n            }\n            setRange(new Range(lower, upper), false, false);\n        }\n\n    }\n\n    /**\n     * Draws the axis on a Java 2D graphics device (such as the screen or a\n     * printer).\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param cursor  the cursor location (determines where to draw the axis).\n     * @param plotArea  the area within which the axes and plot should be drawn.\n     * @param dataArea  the area within which the data should be drawn.\n     * @param edge  the axis location ({@code null} not permitted).\n     * @param plotState  collects information about the plot ({@code null} \n     *         permitted).\n     *\n     * @return The axis state (never {@code null}).\n     */\n    @Override\n    public AxisState draw(Graphics2D g2, double cursor, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge,\n            PlotRenderingInfo plotState) {\n\n        AxisState state;\n        // if the axis is not visible, don\u0027t draw it...\n        if (!isVisible()) {\n            state \u003d new AxisState(cursor);\n            // even though the axis is not visible, we need ticks for the\n            // gridlines...\n            List ticks \u003d refreshTicks(g2, state, dataArea, edge);\n            state.setTicks(ticks);\n            return state;\n        }\n        state \u003d drawTickMarksAndLabels(g2, cursor, plotArea, dataArea, edge);\n        if (getAttributedLabel() !\u003d null) {\n            state \u003d drawAttributedLabel(getAttributedLabel(), g2, plotArea, \n                    dataArea, edge, state);\n            \n        } else {\n            state \u003d drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);\n        }\n        createAndAddEntity(cursor, state, dataArea, edge, plotState);\n        return state;\n    }\n\n    /**\n     * Calculates the positions of the tick labels for the axis, storing the\n     * results in the tick label list (ready for drawing).\n     *\n     * @param g2  the graphics device.\n     * @param state  the axis state.\n     * @param dataArea  the area in which the plot should be drawn.\n     * @param edge  the location of the axis.\n     *\n     * @return A list of ticks.\n     */\n    @Override\n    public List refreshTicks(Graphics2D g2, AxisState state,\n            Rectangle2D dataArea, RectangleEdge edge) {\n        List result \u003d new java.util.ArrayList();\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            result \u003d refreshTicksHorizontal(g2, dataArea, edge);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            result \u003d refreshTicksVertical(g2, dataArea, edge);\n        }\n        return result;\n    }\n    \n    /**\n     * Returns a list of ticks for an axis at the top or bottom of the chart.\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param dataArea  the data area ({@code null} not permitted).\n     * @param edge  the edge ({@code null} not permitted).\n     *\n     * @return A list of ticks.\n     */\n    protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        Range range \u003d getRange();\n        List ticks \u003d new ArrayList();\n        Font tickLabelFont \u003d getTickLabelFont();\n        g2.setFont(tickLabelFont);\n        TextAnchor textAnchor;\n        if (edge \u003d\u003d RectangleEdge.TOP) {\n            textAnchor \u003d TextAnchor.BOTTOM_CENTER;\n        }\n        else {\n            textAnchor \u003d TextAnchor.TOP_CENTER;\n        }\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n        int minorTickCount \u003d this.tickUnit.getMinorTickCount();\n        double unit \u003d getTickUnit().getSize();\n        double index \u003d Math.ceil(calculateLog(getRange().getLowerBound()) \n                / unit);\n        double start \u003d index * unit;\n        double end \u003d calculateLog(getUpperBound());\n        double current \u003d start;\n        boolean hasTicks \u003d (this.tickUnit.getSize() \u003e 0.0)\n                           \u0026\u0026 !Double.isInfinite(start);\n        while (hasTicks \u0026\u0026 current \u003c\u003d end) {\n            double v \u003d calculateValueNoINF(current);\n            if (range.contains(v)) {\n                ticks.add(new LogTick(TickType.MAJOR, v, createTickLabel(v),\n                        textAnchor));\n            }\n            // add minor ticks (for gridlines)\n            double next \u003d Math.pow(this.base, current\n                    + this.tickUnit.getSize());\n            for (int i \u003d 1; i \u003c minorTickCount; i++) {\n                double minorV \u003d v + i * ((next - v) / minorTickCount);\n                if (range.contains(minorV)) {\n                    ticks.add(new LogTick(TickType.MINOR, minorV, null,\n                            textAnchor));\n                }\n            }\n            current \u003d current + this.tickUnit.getSize();\n        }\n        return ticks;\n    }\n\n    /**\n     * Returns a list of ticks for an axis at the left or right of the chart.\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param dataArea  the data area ({@code null} not permitted).\n     * @param edge  the edge that the axis is aligned to ({@code null} \n     *     not permitted).\n     *\n     * @return A list of ticks.\n     */\n    protected List refreshTicksVertical(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        Range range \u003d getRange();\n        List ticks \u003d new ArrayList();\n        Font tickLabelFont \u003d getTickLabelFont();\n        g2.setFont(tickLabelFont);\n        TextAnchor textAnchor;\n        if (edge \u003d\u003d RectangleEdge.RIGHT) {\n            textAnchor \u003d TextAnchor.CENTER_LEFT;\n        }\n        else {\n            textAnchor \u003d TextAnchor.CENTER_RIGHT;\n        }\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n        int minorTickCount \u003d this.tickUnit.getMinorTickCount();\n        double unit \u003d getTickUnit().getSize();\n        double index \u003d Math.ceil(calculateLog(getRange().getLowerBound()) \n                / unit);\n        double start \u003d index * unit;\n        double end \u003d calculateLog(getUpperBound());\n        double current \u003d start;\n        boolean hasTicks \u003d (this.tickUnit.getSize() \u003e 0.0)\n                           \u0026\u0026 !Double.isInfinite(start);\n        while (hasTicks \u0026\u0026 current \u003c\u003d end) {\n            double v \u003d calculateValueNoINF(current);\n            if (range.contains(v)) {\n                ticks.add(new LogTick(TickType.MAJOR, v, createTickLabel(v),\n                        textAnchor));\n            }\n            // add minor ticks (for gridlines)\n            double next \u003d Math.pow(this.base, current\n                    + this.tickUnit.getSize());\n            for (int i \u003d 1; i \u003c minorTickCount; i++) {\n                double minorV \u003d v + i * ((next - v) / minorTickCount);\n                if (range.contains(minorV)) {\n                    ticks.add(new LogTick(TickType.MINOR, minorV, null,\n                            textAnchor));\n                }\n            }\n            current \u003d current + this.tickUnit.getSize();\n        }\n        return ticks;\n    }\n\n    /**\n     * Selects an appropriate tick value for the axis.  The strategy is to\n     * display as many ticks as possible (selected from an array of \u0027standard\u0027\n     * tick units) without the labels overlapping.\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param dataArea  the area defined by the axes ({@code null} not \n     *     permitted).\n     * @param edge  the axis location ({@code null} not permitted).\n     */\n    protected void selectAutoTickUnit(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            selectHorizontalAutoTickUnit(g2, dataArea, edge);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            selectVerticalAutoTickUnit(g2, dataArea, edge);\n        }\n    }\n\n    /**\n     * Selects an appropriate tick value for the axis.  The strategy is to\n     * display as many ticks as possible (selected from an array of \u0027standard\u0027\n     * tick units) without the labels overlapping.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area defined by the axes.\n     * @param edge  the axis location.\n     */\n    protected void selectHorizontalAutoTickUnit(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        // select a tick unit that is the next one bigger than the current\n        // (log) range divided by 50\n        Range range \u003d getRange();\n        double logAxisMin \u003d calculateLog(Math.max(this.smallestValue, \n                range.getLowerBound()));\n        double logAxisMax \u003d calculateLog(range.getUpperBound());\n        double size \u003d (logAxisMax - logAxisMin) / 50;\n        TickUnitSource tickUnits \u003d getStandardTickUnits();\n        TickUnit candidate \u003d tickUnits.getCeilingTickUnit(size);\n        TickUnit prevCandidate \u003d candidate;\n        boolean found \u003d false;\n        while (!found) {\n        // while the tick labels overlap and there are more tick sizes available,\n            // choose the next bigger label\n            this.tickUnit \u003d (NumberTickUnit) candidate;\n            double tickLabelWidth \u003d estimateMaximumTickLabelWidth(g2, \n                    candidate);\n            // what is the available space for one unit?\n            double candidateWidth \u003d exponentLengthToJava2D(candidate.getSize(), \n                    dataArea, edge);\n            if (tickLabelWidth \u003c candidateWidth) {\n                found \u003d true;\n            } else if (Double.isNaN(candidateWidth)) {\n                candidate \u003d prevCandidate;\n                found \u003d true;\n            } else {\n                prevCandidate \u003d candidate;\n                candidate \u003d tickUnits.getLargerTickUnit(prevCandidate);\n                if (candidate.equals(prevCandidate)) {\n                    found \u003d true;  // there are no more candidates\n                }\n            }\n        } \n        setTickUnit((NumberTickUnit) candidate, false, false);\n    }\n\n    /**\n     * Converts a length in data coordinates into the corresponding length in\n     * Java2D coordinates.\n     *\n     * @param length  the length.\n     * @param area  the plot area.\n     * @param edge  the edge along which the axis lies.\n     *\n     * @return The length in Java2D coordinates.\n     */\n    public double exponentLengthToJava2D(double length, Rectangle2D area,\n                                RectangleEdge edge) {\n        double one \u003d valueToJava2D(calculateValueNoINF(1.0), area, edge);\n        double l \u003d valueToJava2D(calculateValueNoINF(length + 1.0), area, edge);\n        return Math.abs(l - one);\n    }\n\n    /**\n     * Selects an appropriate tick value for the axis.  The strategy is to\n     * display as many ticks as possible (selected from an array of \u0027standard\u0027\n     * tick units) without the labels overlapping.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area in which the plot should be drawn.\n     * @param edge  the axis location.\n     */\n    protected void selectVerticalAutoTickUnit(Graphics2D g2, \n            Rectangle2D dataArea, RectangleEdge edge) {\n        // select a tick unit that is the next one bigger than the current\n        // (log) range divided by 50\n        Range range \u003d getRange();\n        double logAxisMin \u003d calculateLog(Math.max(this.smallestValue, \n                range.getLowerBound()));\n        double logAxisMax \u003d calculateLog(range.getUpperBound());\n        double size \u003d (logAxisMax - logAxisMin) / 50;\n        TickUnitSource tickUnits \u003d getStandardTickUnits();\n        TickUnit candidate \u003d tickUnits.getCeilingTickUnit(size);\n        TickUnit prevCandidate \u003d candidate;\n        boolean found \u003d false;\n        while (!found) {\n        // while the tick labels overlap and there are more tick sizes available,\n            // choose the next bigger label\n            this.tickUnit \u003d (NumberTickUnit) candidate;\n            double tickLabelHeight \u003d estimateMaximumTickLabelHeight(g2);\n            // what is the available space for one unit?\n            double candidateHeight \u003d exponentLengthToJava2D(candidate.getSize(), \n                    dataArea, edge);\n            if (tickLabelHeight \u003c candidateHeight) {\n                found \u003d true;\n            } else if (Double.isNaN(candidateHeight)) {\n                candidate \u003d prevCandidate;\n                found \u003d true;\n            } else {\n                prevCandidate \u003d candidate;\n                candidate \u003d tickUnits.getLargerTickUnit(prevCandidate);\n                if (candidate.equals(prevCandidate)) {\n                    found \u003d true;  // there are no more candidates\n                }\n            }\n        } \n        setTickUnit((NumberTickUnit) candidate, false, false);\n    }\n\n    /**\n     * Creates a tick label for the specified value based on the current\n     * tick unit (used for formatting the exponent).\n     *\n     * @param value  the value.\n     *\n     * @return The label.\n     */\n    protected AttributedString createTickLabel(double value) {\n        if (this.numberFormatOverride !\u003d null) {\n            String text \u003d this.numberFormatOverride.format(value);\n            AttributedString as \u003d new AttributedString(text);\n            as.addAttribute(TextAttribute.FONT, getTickLabelFont());\n            return as;\n        } else {\n            String baseStr \u003d this.baseSymbol;\n            if (baseStr \u003d\u003d null) {\n                baseStr \u003d this.baseFormatter.format(this.base);\n            }\n            double logy \u003d calculateLog(value);\n            String exponentStr \u003d getTickUnit().valueToString(logy);\n            AttributedString as \u003d new AttributedString(baseStr + exponentStr);\n            as.addAttributes(getTickLabelFont().getAttributes(), 0, (baseStr \n                    + exponentStr).length());\n            as.addAttribute(TextAttribute.SUPERSCRIPT, \n                    TextAttribute.SUPERSCRIPT_SUPER, baseStr.length(), \n                    baseStr.length() + exponentStr.length());\n            return as;\n        }\n    }\n\n    /**\n     * Estimates the maximum tick label height.\n     *\n     * @param g2  the graphics device.\n     *\n     * @return The maximum height.\n     */\n    protected double estimateMaximumTickLabelHeight(Graphics2D g2) {\n        RectangleInsets tickLabelInsets \u003d getTickLabelInsets();\n        double result \u003d tickLabelInsets.getTop() + tickLabelInsets.getBottom();\n\n        Font tickLabelFont \u003d getTickLabelFont();\n        FontRenderContext frc \u003d g2.getFontRenderContext();\n        result +\u003d tickLabelFont.getLineMetrics(\"123\", frc).getHeight();\n        return result;\n    }\n\n    /**\n     * Estimates the maximum width of the tick labels, assuming the specified\n     * tick unit is used.\n     * \u003cP\u003e\n     * Rather than computing the string bounds of every tick on the axis, we\n     * just look at two values: the lower bound and the upper bound for the\n     * axis.  These two values will usually be representative.\n     *\n     * @param g2  the graphics device.\n     * @param unit  the tick unit to use for calculation.\n     *\n     * @return The estimated maximum width of the tick labels.\n     */\n    protected double estimateMaximumTickLabelWidth(Graphics2D g2, \n            TickUnit unit) {\n\n        RectangleInsets tickLabelInsets \u003d getTickLabelInsets();\n        double result \u003d tickLabelInsets.getLeft() + tickLabelInsets.getRight();\n\n        if (isVerticalTickLabels()) {\n            // all tick labels have the same width (equal to the height of the\n            // font)...\n            FontRenderContext frc \u003d g2.getFontRenderContext();\n            LineMetrics lm \u003d getTickLabelFont().getLineMetrics(\"0\", frc);\n            result +\u003d lm.getHeight();\n        }\n        else {\n            // look at lower and upper bounds...\n            Range range \u003d getRange();\n            double lower \u003d range.getLowerBound();\n            double upper \u003d range.getUpperBound();\n            AttributedString lowerStr \u003d createTickLabel(lower);\n            AttributedString upperStr \u003d createTickLabel(upper);\n            double w1 \u003d AttrStringUtils.getTextBounds(lowerStr, g2).getWidth();\n            double w2 \u003d AttrStringUtils.getTextBounds(upperStr, g2).getWidth();\n            result +\u003d Math.max(w1, w2);\n        }\n        return result;\n    }\n\n    /**\n     * Zooms in on the current range.\n     *\n     * @param lowerPercent  the new lower bound.\n     * @param upperPercent  the new upper bound.\n     */\n    @Override\n    public void zoomRange(double lowerPercent, double upperPercent) {\n        Range range \u003d getRange();\n        double start \u003d range.getLowerBound();\n        double end \u003d range.getUpperBound();\n        double log1 \u003d calculateLog(start);\n        double log2 \u003d calculateLog(end);\n        double length \u003d log2 - log1;\n        Range adjusted;\n        if (isInverted()) {\n            double logA \u003d log1 + length * (1 - upperPercent);\n            double logB \u003d log1 + length * (1 - lowerPercent);\n            adjusted \u003d new Range(calculateValueNoINF(logA), \n                    calculateValueNoINF(logB));\n        }\n        else {\n            double logA \u003d log1 + length * lowerPercent;\n            double logB \u003d log1 + length * upperPercent;\n            adjusted \u003d new Range(calculateValueNoINF(logA), \n                    calculateValueNoINF(logB));\n        }\n        setRange(adjusted);\n    }\n\n    /**\n     * Slides the axis range by the specified percentage.\n     *\n     * @param percent  the percentage.\n     */\n    @Override\n    public void pan(double percent) {\n        Range range \u003d getRange();\n        double lower \u003d range.getLowerBound();\n        double upper \u003d range.getUpperBound();\n        double log1 \u003d calculateLog(lower);\n        double log2 \u003d calculateLog(upper);\n        double length \u003d log2 - log1;\n        double adj \u003d length * percent;\n        log1 \u003d log1 + adj;\n        log2 \u003d log2 + adj;\n        setRange(calculateValueNoINF(log1), calculateValueNoINF(log2));\n    }\n    \n    /**\n     * Increases or decreases the axis range by the specified percentage about\n     * the central value and sends an {@link AxisChangeEvent} to all registered\n     * listeners.\n     * \u003cP\u003e\n     * To double the length of the axis range, use 200% (2.0).\n     * To halve the length of the axis range, use 50% (0.5).\n     *\n     * @param percent  the resize factor.\n     *\n     * @see #resizeRange(double, double)\n     */\n    @Override\n    public void resizeRange(double percent) {\n        Range range \u003d getRange();\n        double logMin \u003d calculateLog(range.getLowerBound());\n        double logMax \u003d calculateLog(range.getUpperBound());\n        double centralValue \u003d calculateValueNoINF((logMin + logMax) / 2.0);\n        resizeRange(percent, centralValue);\n    }\n\n    @Override\n    public void resizeRange(double percent, double anchorValue) {\n        resizeRange2(percent, anchorValue);\n    }\n\n    /**\n     * Resizes the axis length to the specified percentage of the current\n     * range and sends a change event to all registered listeners.  If \n     * {@code percent} is greater than 1.0 (100 percent) then the axis\n     * range is increased (which has the effect of zooming out), while if the\n     * {@code percent} is less than 1.0 the axis range is decreased \n     * (which has the effect of zooming in).  The resize occurs around an \n     * anchor value (which may not be in the center of the axis).  This is used\n     * to support mouse wheel zooming around an arbitrary point on the plot.\n     * \u003cbr\u003e\u003cbr\u003e\n     * This method is overridden to perform the percentage calculations on the\n     * log values (which are linear for this axis).\n     * \n     * @param percent  the percentage (must be greater than zero).\n     * @param anchorValue  the anchor value.\n     */\n    @Override\n    public void resizeRange2(double percent, double anchorValue) {\n        if (percent \u003e 0.0) {\n            double logAnchorValue \u003d calculateLog(anchorValue);\n            Range range \u003d getRange();\n            double logAxisMin \u003d calculateLog(range.getLowerBound());\n            double logAxisMax \u003d calculateLog(range.getUpperBound());\n\n            double left \u003d percent * (logAnchorValue - logAxisMin);\n            double right \u003d percent * (logAxisMax - logAnchorValue);\n            \n            double upperBound \u003d calculateValueNoINF(logAnchorValue + right);\n            Range adjusted \u003d new Range(calculateValueNoINF(\n                    logAnchorValue - left), upperBound);\n            setRange(adjusted);\n        }\n        else {\n            setAutoRange(true);\n        }\n    }\n\n    /**\n     * Tests this axis for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof LogAxis)) {\n            return false;\n        }\n        LogAxis that \u003d (LogAxis) obj;\n        if (this.base !\u003d that.base) {\n            return false;\n        }\n        if (!Objects.equals(this.baseSymbol, that.baseSymbol)) {\n            return false;\n        }\n        if (!this.baseFormatter.equals(that.baseFormatter)) {\n            return false;\n        }\n        if (this.smallestValue !\u003d that.smallestValue) {\n            return false;\n        }\n        if (!Objects.equals(this.numberFormatOverride, that.numberFormatOverride)) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a hash code for this instance.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d 193;\n        long temp \u003d Double.doubleToLongBits(this.base);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        temp \u003d Double.doubleToLongBits(this.smallestValue);\n        result \u003d 37 * result + (int) (temp ^ (temp \u003e\u003e\u003e 32));\n        if (this.numberFormatOverride !\u003d null) {\n            result \u003d 37 * result + this.numberFormatOverride.hashCode();\n        }\n        result \u003d 37 * result + this.tickUnit.hashCode();\n        return result;\n    }\n\n}","methodCount":40,"staticMethodCount":0,"instanceMethodCount":40,"classLoc":976,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":13507},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"refreshTicksHorizontal","method_signature":"protected refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge)","target_class":"","rationale":""},{"method_name":"refreshTicksVertical","method_signature":"protected refreshTicksVertical(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"refreshTicksHorizontal","method_signature":"protected refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge)","target_class":"","rationale":""},{"method_name":"refreshTicksVertical","method_signature":"protected refreshTicksVertical(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"protected refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge)":{"first":{"method_name":"refreshTicksHorizontal","method_signature":"protected refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge)","target_class":"","rationale":""},"second":0.7700479559468807},"protected refreshTicksVertical(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge)":{"first":{"method_name":"refreshTicksVertical","method_signature":"protected refreshTicksVertical(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge)","target_class":"","rationale":""},"second":0.7987051532162743}},"targetClassMap":{"refreshTicksHorizontal":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":7289,"similarity_computation_time":0,"similarity_metric":"cosine"},"refreshTicksVertical":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":6144,"similarity_computation_time":0,"similarity_metric":"cosine"}}}
{"id":"cdbfae10-f66e-4062-ae2a-f3d6890d5389","hostFunctionTelemetryData":{"hostFunctionSize":981,"lineStart":54,"lineEnd":1034,"bodyLineStart":54,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/axis/LogarithmicAxis.java","sourceCode":"/**\n * A numerical axis that uses a logarithmic scale.\n */\npublic class LogarithmicAxis extends NumberAxis {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d 2502918599004103054L;\n\n    /** Useful constant for log(10). */\n    public static final double LOG10_VALUE \u003d Math.log(10.0);\n\n    /** Smallest arbitrarily-close-to-zero value allowed. */\n    public static final double SMALL_LOG_VALUE \u003d 1e-100;\n\n    /** Flag set true to allow negative values in data. */\n    protected boolean allowNegativesFlag \u003d false;\n\n    /**\n     * Flag set true make axis throw exception if any values are \u0026lt;\u003d 0 and \n     * \u0027allowNegativesFlag\u0027 is false.\n     */\n    protected boolean strictValuesFlag \u003d true;\n\n    /** Number formatter for generating numeric strings. */\n    protected final NumberFormat numberFormatterObj\n        \u003d NumberFormat.getInstance();\n\n    /** Flag set true for \"1e#\"-style tick labels. */\n    protected boolean expTickLabelsFlag \u003d false;\n\n    /** Flag set true for \"10^n\"-style tick labels. */\n    protected boolean log10TickLabelsFlag \u003d false;\n\n    /** True to make \u0027autoAdjustRange()\u0027 select \"10^n\" values. */\n    protected boolean autoRangeNextLogFlag \u003d false;\n\n    /** Helper flag for log axis processing. */\n    protected boolean smallLogFlag \u003d false;\n\n    /**\n     * Creates a new axis.\n     *\n     * @param label  the axis label.\n     */\n    public LogarithmicAxis(String label) {\n        super(label);\n        setupNumberFmtObj();      //setup number formatter obj\n    }\n\n    /**\n     * Sets the \u0027allowNegativesFlag\u0027 flag; true to allow negative values\n     * in data, false to be able to plot positive values arbitrarily close to\n     * zero.\n     *\n     * @param flgVal  the new value of the flag.\n     */\n    public void setAllowNegativesFlag(boolean flgVal) {\n        this.allowNegativesFlag \u003d flgVal;\n    }\n\n    /**\n     * Returns the \u0027allowNegativesFlag\u0027 flag; true to allow negative values\n     * in data, false to be able to plot positive values arbitrarily close\n     * to zero.\n     *\n     * @return The flag.\n     */\n    public boolean getAllowNegativesFlag() {\n        return this.allowNegativesFlag;\n    }\n\n    /**\n     * Sets the \u0027strictValuesFlag\u0027 flag; if true and \u0027allowNegativesFlag\u0027\n     * is false then this axis will throw a runtime exception if any of its\n     * values are less than or equal to zero; if false then the axis will\n     * adjust for values less than or equal to zero as needed.\n     *\n     * @param flgVal true for strict enforcement.\n     */\n    public void setStrictValuesFlag(boolean flgVal) {\n        this.strictValuesFlag \u003d flgVal;\n    }\n\n    /**\n     * Returns the \u0027strictValuesFlag\u0027 flag; if true and \u0027allowNegativesFlag\u0027\n     * is false then this axis will throw a runtime exception if any of its\n     * values are less than or equal to zero; if false then the axis will\n     * adjust for values less than or equal to zero as needed.\n     *\n     * @return {@code true} if strict enforcement is enabled.\n     */\n    public boolean getStrictValuesFlag() {\n        return this.strictValuesFlag;\n    }\n\n    /**\n     * Sets the \u0027expTickLabelsFlag\u0027 flag.  If the \u0027log10TickLabelsFlag\u0027\n     * is false then this will set whether or not \"1e#\"-style tick labels\n     * are used.  The default is to use regular numeric tick labels.\n     *\n     * @param flgVal true for \"1e#\"-style tick labels, false for\n     * log10 or regular numeric tick labels.\n     */\n    public void setExpTickLabelsFlag(boolean flgVal) {\n        this.expTickLabelsFlag \u003d flgVal;\n        setupNumberFmtObj();             //setup number formatter obj\n    }\n\n    /**\n     * Returns the \u0027expTickLabelsFlag\u0027 flag.\n     *\n     * @return {@code true} for \"1e#\"-style tick labels,\n     *         {@code false} for log10 or regular numeric tick labels.\n     */\n    public boolean getExpTickLabelsFlag() {\n      return this.expTickLabelsFlag;\n    }\n\n    /**\n     * Sets the \u0027log10TickLabelsFlag\u0027 flag.  The default value is false.\n     *\n     * @param flag true for \"10^n\"-style tick labels, false for \"1e#\"-style\n     * or regular numeric tick labels.\n     */\n    public void setLog10TickLabelsFlag(boolean flag) {\n        this.log10TickLabelsFlag \u003d flag;\n    }\n\n    /**\n     * Returns the \u0027log10TickLabelsFlag\u0027 flag.\n     *\n     * @return {@code true} for \"10^n\"-style tick labels,\n     *         {@code false} for \"1e#\"-style or regular numeric tick\n     *         labels.\n     */\n    public boolean getLog10TickLabelsFlag() {\n        return this.log10TickLabelsFlag;\n    }\n\n    /**\n     * Sets the \u0027autoRangeNextLogFlag\u0027 flag.  This determines whether or\n     * not the \u0027autoAdjustRange()\u0027 method will select the next \"10^n\"\n     * values when determining the upper and lower bounds.  The default\n     * value is false.\n     *\n     * @param flag {@code true} to make the \u0027autoAdjustRange()\u0027\n     * method select the next \"10^n\" values, {@code false} to not.\n     */\n    public void setAutoRangeNextLogFlag(boolean flag) {\n        this.autoRangeNextLogFlag \u003d flag;\n    }\n\n    /**\n     * Returns the \u0027autoRangeNextLogFlag\u0027 flag.\n     *\n     * @return {@code true} if the \u0027autoAdjustRange()\u0027 method will\n     * select the next \"10^n\" values, {@code false} if not.\n     */\n    public boolean getAutoRangeNextLogFlag() {\n        return this.autoRangeNextLogFlag;\n    }\n\n    /**\n     * Overridden version that calls original and then sets up flag for\n     * log axis processing.\n     *\n     * @param range  the new range.\n     */\n    @Override\n    public void setRange(Range range) {\n        super.setRange(range);      // call parent method\n        setupSmallLogFlag();        // setup flag based on bounds values\n    }\n\n    /**\n     * Sets up flag for log axis processing.  Set true if negative values\n     * not allowed and the lower bound is between 0 and 10.\n     */\n    protected void setupSmallLogFlag() {\n        // set flag true if negative values not allowed and the\n        // lower bound is between 0 and 10:\n        double lowerVal \u003d getRange().getLowerBound();\n        this.smallLogFlag \u003d (!this.allowNegativesFlag \u0026\u0026 lowerVal \u003c 10.0\n                \u0026\u0026 lowerVal \u003e 0.0);\n    }\n\n    /**\n     * Sets up the number formatter object according to the\n     * \u0027expTickLabelsFlag\u0027 flag.\n     */\n    protected void setupNumberFmtObj() {\n        if (this.numberFormatterObj instanceof DecimalFormat) {\n            //setup for \"1e#\"-style tick labels or regular\n            // numeric tick labels, depending on flag:\n            ((DecimalFormat) this.numberFormatterObj).applyPattern(\n                    this.expTickLabelsFlag ? \"0E0\" : \"0.###\");\n        }\n    }\n\n    /**\n     * Returns the log10 value, depending on if values between 0 and\n     * 1 are being plotted.  If negative values are not allowed and\n     * the lower bound is between 0 and 10 then a normal log is\n     * returned; otherwise the returned value is adjusted if the\n     * given value is less than 10.\n     *\n     * @param val the value.\n     *\n     * @return log\u003csub\u003e10\u003c/sub\u003e(val).\n     *\n     * @see #switchedPow10(double)\n     */\n    protected double switchedLog10(double val) {\n        return this.smallLogFlag ? Math.log(val)\n                / LOG10_VALUE : adjustedLog10(val);\n    }\n\n    /**\n     * Returns a power of 10, depending on if values between 0 and\n     * 1 are being plotted.  If negative values are not allowed and\n     * the lower bound is between 0 and 10 then a normal power is\n     * returned; otherwise the returned value is adjusted if the\n     * given value is less than 1.\n     *\n     * @param val the value.\n     *\n     * @return 10\u003csup\u003eval\u003c/sup\u003e.\n     * \n     * @see #switchedLog10(double)\n     */\n    public double switchedPow10(double val) {\n        return this.smallLogFlag ? Math.pow(10.0, val) : adjustedPow10(val);\n    }\n\n    /**\n     * Returns an adjusted log10 value for graphing purposes.  The first\n     * adjustment is that negative values are changed to positive during\n     * the calculations, and then the answer is negated at the end.  The\n     * second is that, for values less than 10, an increasingly large\n     * (0 to 1) scaling factor is added such that at 0 the value is\n     * adjusted to 1, resulting in a returned result of 0.\n     *\n     * @param val  value for which log10 should be calculated.\n     *\n     * @return An adjusted log\u003csub\u003e10\u003c/sub\u003e(val).\n     *\n     * @see #adjustedPow10(double)\n     */\n    public double adjustedLog10(double val) {\n        boolean negFlag \u003d (val \u003c 0.0);\n        if (negFlag) {\n            val \u003d -val;          // if negative then set flag and make positive\n        }\n        if (val \u003c 10.0) {                // if \u003c 10 then\n            val +\u003d (10.0 - val) / 10.0;  //increase so 0 translates to 0\n        }\n        //return value; negate if original value was negative:\n        double res \u003d Math.log(val) / LOG10_VALUE;\n        return negFlag ? (-res) : res;\n    }\n\n    /**\n     * Returns an adjusted power of 10 value for graphing purposes.  The first\n     * adjustment is that negative values are changed to positive during\n     * the calculations, and then the answer is negated at the end.  The\n     * second is that, for values less than 1, a progressive logarithmic\n     * offset is subtracted such that at 0 the returned result is also 0.\n     *\n     * @param val  value for which power of 10 should be calculated.\n     *\n     * @return An adjusted 10\u003csup\u003eval\u003c/sup\u003e.\n     * \n     * @see #adjustedLog10(double)\n     */\n    public double adjustedPow10(double val) {\n        boolean negFlag \u003d (val \u003c 0.0);\n        if (negFlag) {\n            val \u003d -val; // if negative then set flag and make positive\n        }\n        double res;\n        if (val \u003c 1.0) {\n            res \u003d (Math.pow(10, val + 1.0) - 10.0) / 9.0; //invert adjustLog10\n        }\n        else {\n            res \u003d Math.pow(10, val);\n        }\n        return negFlag ? (-res) : res;\n    }\n\n    /**\n     * Returns the largest (closest to positive infinity) double value that is\n     * not greater than the argument, is equal to a mathematical integer and\n     * satisfying the condition that log base 10 of the value is an integer\n     * (i.e., the value returned will be a power of 10: 1, 10, 100, 1000, etc.).\n     *\n     * @param lower a double value below which a floor will be calcualted.\n     *\n     * @return 10\u003csup\u003eN\u003c/sup\u003e with N .. { 1 ... }\n     */\n    protected double computeLogFloor(double lower) {\n\n        double logFloor;\n        if (this.allowNegativesFlag) {\n            //negative values are allowed\n            if (lower \u003e 10.0) {   //parameter value is \u003e 10\n                // The Math.log() function is based on e not 10.\n                logFloor \u003d Math.log(lower) / LOG10_VALUE;\n                logFloor \u003d Math.floor(logFloor);\n                logFloor \u003d Math.pow(10, logFloor);\n            }\n            else if (lower \u003c -10.0) {   //parameter value is \u003c -10\n                //calculate log using positive value:\n                logFloor \u003d Math.log(-lower) / LOG10_VALUE;\n                //calculate floor using negative value:\n                logFloor \u003d Math.floor(-logFloor);\n                //calculate power using positive value; then negate\n                logFloor \u003d -Math.pow(10, -logFloor);\n            }\n            else {\n                //parameter value is -10 \u003e val \u003c 10\n                logFloor \u003d Math.floor(lower);   //use as-is\n            }\n        }\n        else {\n            //negative values not allowed\n            if (lower \u003e 0.0) {   //parameter value is \u003e 0\n                // The Math.log() function is based on e not 10.\n                logFloor \u003d Math.log(lower) / LOG10_VALUE;\n                logFloor \u003d Math.floor(logFloor);\n                logFloor \u003d Math.pow(10, logFloor);\n            }\n            else {\n                //parameter value is \u003c\u003d 0\n                logFloor \u003d Math.floor(lower);   //use as-is\n            }\n        }\n        return logFloor;\n    }\n\n    /**\n     * Returns the smallest (closest to negative infinity) double value that is\n     * not less than the argument, is equal to a mathematical integer and\n     * satisfying the condition that log base 10 of the value is an integer\n     * (i.e., the value returned will be a power of 10: 1, 10, 100, 1000, etc.).\n     *\n     * @param upper a double value above which a ceiling will be calcualted.\n     *\n     * @return 10\u003csup\u003eN\u003c/sup\u003e with N .. { 1 ... }\n     */\n    protected double computeLogCeil(double upper) {\n\n        double logCeil;\n        if (this.allowNegativesFlag) {\n            //negative values are allowed\n            if (upper \u003e 10.0) {\n                //parameter value is \u003e 10\n                // The Math.log() function is based on e not 10.\n                logCeil \u003d Math.log(upper) / LOG10_VALUE;\n                logCeil \u003d Math.ceil(logCeil);\n                logCeil \u003d Math.pow(10, logCeil);\n            }\n            else if (upper \u003c -10.0) {\n                //parameter value is \u003c -10\n                //calculate log using positive value:\n                logCeil \u003d Math.log(-upper) / LOG10_VALUE;\n                //calculate ceil using negative value:\n                logCeil \u003d Math.ceil(-logCeil);\n                //calculate power using positive value; then negate\n                logCeil \u003d -Math.pow(10, -logCeil);\n            }\n            else {\n               //parameter value is -10 \u003e val \u003c 10\n               logCeil \u003d Math.ceil(upper);     //use as-is\n            }\n        }\n        else {\n            //negative values not allowed\n            if (upper \u003e 0.0) {\n                //parameter value is \u003e 0\n                // The Math.log() function is based on e not 10.\n                logCeil \u003d Math.log(upper) / LOG10_VALUE;\n                logCeil \u003d Math.ceil(logCeil);\n                logCeil \u003d Math.pow(10, logCeil);\n            }\n            else {\n                //parameter value is \u003c\u003d 0\n                logCeil \u003d Math.ceil(upper);     //use as-is\n            }\n        }\n        return logCeil;\n    }\n\n    /**\n     * Rescales the axis to ensure that all data is visible.\n     */\n    @Override\n    public void autoAdjustRange() {\n\n        Plot plot \u003d getPlot();\n        if (plot \u003d\u003d null) {\n            return;  // no plot, no data.\n        }\n\n        if (plot instanceof ValueAxisPlot) {\n            ValueAxisPlot vap \u003d (ValueAxisPlot) plot;\n\n            double lower;\n            Range r \u003d vap.getDataRange(this);\n            if (r \u003d\u003d null) {\n                   //no real data present\n                r \u003d getDefaultAutoRange();\n                lower \u003d r.getLowerBound();    //get lower bound value\n            }\n            else {\n                //actual data is present\n                lower \u003d r.getLowerBound();    //get lower bound value\n                if (this.strictValuesFlag\n                        \u0026\u0026 !this.allowNegativesFlag \u0026\u0026 lower \u003c\u003d 0.0) {\n                    //strict flag set, allow-negatives not set and values \u003c\u003d 0\n                    throw new RuntimeException(\"Values less than or equal to \"\n                            + \"zero not allowed with logarithmic axis\");\n                }\n            }\n\n            //apply lower margin by decreasing lower bound:\n            final double lowerMargin;\n            if (lower \u003e 0.0 \u0026\u0026 (lowerMargin \u003d getLowerMargin()) \u003e 0.0) {\n                   //lower bound and margin OK; get log10 of lower bound\n                final double logLower \u003d (Math.log(lower) / LOG10_VALUE);\n                double logAbs;      //get absolute value of log10 value\n                if ((logAbs \u003d Math.abs(logLower)) \u003c 1.0) {\n                    logAbs \u003d 1.0;     //if less than 1.0 then make it 1.0\n                }              //subtract out margin and get exponential value:\n                lower \u003d Math.pow(10, (logLower - (logAbs * lowerMargin)));\n            }\n\n            //if flag then change to log version of lowest value\n            // to make range begin at a 10^n value:\n            if (this.autoRangeNextLogFlag) {\n                lower \u003d computeLogFloor(lower);\n            }\n\n            if (!this.allowNegativesFlag \u0026\u0026 lower \u003e\u003d 0.0\n                    \u0026\u0026 lower \u003c SMALL_LOG_VALUE) {\n                //negatives not allowed and lower range bound is zero\n                lower \u003d r.getLowerBound();    //use data range bound instead\n            }\n\n            double upper \u003d r.getUpperBound();\n\n             //apply upper margin by increasing upper bound:\n            final double upperMargin;\n            if (upper \u003e 0.0 \u0026\u0026 (upperMargin \u003d getUpperMargin()) \u003e 0.0) {\n                   //upper bound and margin OK; get log10 of upper bound\n                final double logUpper \u003d (Math.log(upper) / LOG10_VALUE);\n                double logAbs;      //get absolute value of log10 value\n                if ((logAbs \u003d Math.abs(logUpper)) \u003c 1.0) {\n                    logAbs \u003d 1.0;     //if less than 1.0 then make it 1.0\n                }              //add in margin and get exponential value:\n                upper \u003d Math.pow(10, (logUpper + (logAbs * upperMargin)));\n            }\n\n            if (!this.allowNegativesFlag \u0026\u0026 upper \u003c 1.0 \u0026\u0026 upper \u003e 0.0\n                    \u0026\u0026 lower \u003e 0.0) {\n                //negatives not allowed and upper bound between 0 \u0026 1\n                //round up to nearest significant digit for bound:\n                //get negative exponent:\n                double expVal \u003d Math.log(upper) / LOG10_VALUE;\n                expVal \u003d Math.ceil(-expVal + 0.001); //get positive exponent\n                expVal \u003d Math.pow(10, expVal);      //create multiplier value\n                //multiply, round up, and divide for bound value:\n                upper \u003d (expVal \u003e 0.0) ? Math.ceil(upper * expVal) / expVal\n                    : Math.ceil(upper);\n            }\n            else {\n                //negatives allowed or upper bound not between 0 \u0026 1\n                //if flag then change to log version of highest value to\n                // make range begin at a 10^n value; else use nearest int\n                upper \u003d (this.autoRangeNextLogFlag) ? computeLogCeil(upper)\n                    : Math.ceil(upper);\n            }\n            // ensure the autorange is at least \u003cminRange\u003e in size...\n            double minRange \u003d getAutoRangeMinimumSize();\n            if (upper - lower \u003c minRange) {\n                upper \u003d (upper + lower + minRange) / 2;\n                lower \u003d (upper + lower - minRange) / 2;\n                //if autorange still below minimum then adjust by 1%\n                // (can be needed when minRange is very small):\n                if (upper - lower \u003c minRange) {\n                    double absUpper \u003d Math.abs(upper);\n                    //need to account for case where upper\u003d\u003d0.0\n                    double adjVal \u003d (absUpper \u003e SMALL_LOG_VALUE) ? absUpper\n                        / 100.0 : 0.01;\n                    upper \u003d (upper + lower + adjVal) / 2;\n                    lower \u003d (upper + lower - adjVal) / 2;\n                }\n            }\n\n            setRange(new Range(lower, upper), false, false);\n            setupSmallLogFlag();       //setup flag based on bounds values\n        }\n    }\n\n    /**\n     * Converts a data value to a coordinate in Java2D space, assuming that\n     * the axis runs along one edge of the specified plotArea.\n     * Note that it is possible for the coordinate to fall outside the\n     * plotArea.\n     *\n     * @param value  the data value.\n     * @param plotArea  the area for plotting the data.\n     * @param edge  the axis location.\n     *\n     * @return The Java2D coordinate.\n     */\n    @Override\n    public double valueToJava2D(double value, Rectangle2D plotArea,\n                                RectangleEdge edge) {\n\n        Range range \u003d getRange();\n        double axisMin \u003d switchedLog10(range.getLowerBound());\n        double axisMax \u003d switchedLog10(range.getUpperBound());\n\n        double min \u003d 0.0;\n        double max \u003d 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            min \u003d plotArea.getMinX();\n            max \u003d plotArea.getMaxX();\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            min \u003d plotArea.getMaxY();\n            max \u003d plotArea.getMinY();\n        }\n\n        value \u003d switchedLog10(value);\n\n        if (isInverted()) {\n            return max - (((value - axisMin) / (axisMax - axisMin))\n                    * (max - min));\n        }\n        else {\n            return min + (((value - axisMin) / (axisMax - axisMin))\n                    * (max - min));\n        }\n\n    }\n\n    /**\n     * Converts a coordinate in Java2D space to the corresponding data\n     * value, assuming that the axis runs along one edge of the specified\n     * plotArea.\n     *\n     * @param java2DValue  the coordinate in Java2D space.\n     * @param plotArea  the area in which the data is plotted.\n     * @param edge  the axis location.\n     *\n     * @return The data value.\n     */\n    @Override\n    public double java2DToValue(double java2DValue, Rectangle2D plotArea,\n                                RectangleEdge edge) {\n\n        Range range \u003d getRange();\n        double axisMin \u003d switchedLog10(range.getLowerBound());\n        double axisMax \u003d switchedLog10(range.getUpperBound());\n\n        double plotMin \u003d 0.0;\n        double plotMax \u003d 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            plotMin \u003d plotArea.getX();\n            plotMax \u003d plotArea.getMaxX();\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            plotMin \u003d plotArea.getMaxY();\n            plotMax \u003d plotArea.getMinY();\n        }\n\n        if (isInverted()) {\n            return switchedPow10(axisMax - ((java2DValue - plotMin)\n                    / (plotMax - plotMin)) * (axisMax - axisMin));\n        }\n        else {\n            return switchedPow10(axisMin + ((java2DValue - plotMin)\n                    / (plotMax - plotMin)) * (axisMax - axisMin));\n        }\n    }\n\n    /**\n     * Zooms in on the current range.\n     *\n     * @param lowerPercent  the new lower bound.\n     * @param upperPercent  the new upper bound.\n     */\n    @Override\n    public void zoomRange(double lowerPercent, double upperPercent) {\n        double startLog \u003d switchedLog10(getRange().getLowerBound());\n        double lengthLog \u003d switchedLog10(getRange().getUpperBound()) - startLog;\n        Range adjusted;\n\n        if (isInverted()) {\n            adjusted \u003d new Range(\n                    switchedPow10(startLog + (lengthLog * (1 - upperPercent))),\n                    switchedPow10(startLog + (lengthLog * (1 - lowerPercent))));\n        }\n        else {\n            adjusted \u003d new Range(\n                    switchedPow10(startLog + (lengthLog * lowerPercent)),\n                    switchedPow10(startLog + (lengthLog * upperPercent)));\n        }\n\n        setRange(adjusted);\n    }\n\n    /**\n     * Calculates the positions of the tick labels for the axis, storing the\n     * results in the tick label list (ready for drawing).\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area in which the plot should be drawn.\n     * @param edge  the location of the axis.\n     *\n     * @return A list of ticks.\n     */\n    @Override\n    protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        List ticks \u003d new java.util.ArrayList();\n        Range range \u003d getRange();\n\n        //get lower bound value:\n        double lowerBoundVal \u003d range.getLowerBound();\n              //if small log values and lower bound value too small\n              // then set to a small value (don\u0027t allow \u003c\u003d 0):\n        if (this.smallLogFlag \u0026\u0026 lowerBoundVal \u003c SMALL_LOG_VALUE) {\n            lowerBoundVal \u003d SMALL_LOG_VALUE;\n        }\n\n        //get upper bound value\n        double upperBoundVal \u003d range.getUpperBound();\n\n        //get log10 version of lower bound and round to integer:\n        int iBegCount \u003d (int) Math.rint(switchedLog10(lowerBoundVal));\n        //get log10 version of upper bound and round to integer:\n        int iEndCount \u003d (int) Math.rint(switchedLog10(upperBoundVal));\n\n        if (iBegCount \u003d\u003d iEndCount \u0026\u0026 iBegCount \u003e 0\n                \u0026\u0026 Math.pow(10, iBegCount) \u003e lowerBoundVal) {\n              //only 1 power of 10 value, it\u0027s \u003e 0 and its resulting\n              // tick value will be larger than lower bound of data\n            --iBegCount;       //decrement to generate more ticks\n        }\n\n        double currentTickValue;\n        String tickLabel;\n        boolean zeroTickFlag \u003d false;\n        for (int i \u003d iBegCount; i \u003c\u003d iEndCount; i++) {\n            //for each power of 10 value; create ten ticks\n            for (int j \u003d 0; j \u003c 10; ++j) {\n                //for each tick to be displayed\n                if (this.smallLogFlag) {\n                    //small log values in use; create numeric value for tick\n                    currentTickValue \u003d Math.pow(10, i) + (Math.pow(10, i) * j);\n                    if (this.expTickLabelsFlag\n                        || (i \u003c 0 \u0026\u0026 currentTickValue \u003e 0.0\n                        \u0026\u0026 currentTickValue \u003c 1.0)) {\n                        //showing \"1e#\"-style ticks or negative exponent\n                        // generating tick value between 0 \u0026 1; show fewer\n                        if (j \u003d\u003d 0 || (i \u003e -4 \u0026\u0026 j \u003c 2)\n                                   || currentTickValue \u003e\u003d upperBoundVal) {\n                          //first tick of series, or not too small a value and\n                          // one of first 3 ticks, or last tick to be displayed\n                            // set exact number of fractional digits to be shown\n                            // (no effect if showing \"1e#\"-style ticks):\n                            this.numberFormatterObj\n                                .setMaximumFractionDigits(-i);\n                               //create tick label (force use of fmt obj):\n                            tickLabel \u003d makeTickLabel(currentTickValue, true);\n                        }\n                        else {    //no tick label to be shown\n                            tickLabel \u003d \"\";\n                        }\n                    }\n                    else {     //tick value not between 0 \u0026 1\n                               //show tick label if it\u0027s the first or last in\n                               // the set, or if it\u0027s 1-5; beyond that show\n                               // fewer as the values get larger:\n                        tickLabel \u003d (j \u003c 1 || (i \u003c 1 \u0026\u0026 j \u003c 5) || (j \u003c 4 - i)\n                                         || currentTickValue \u003e\u003d upperBoundVal)\n                                         ? makeTickLabel(currentTickValue) : \"\";\n                    }\n                }\n                else { //not small log values in use; allow for values \u003c\u003d 0\n                    if (zeroTickFlag) {   //if did zero tick last iter then\n                        --j;              //decrement to do 1.0 tick now\n                    }     //calculate power-of-ten value for tick:\n                    currentTickValue \u003d (i \u003e\u003d 0)\n                        ? Math.pow(10, i) + (Math.pow(10, i) * j)\n                        : -(Math.pow(10, -i) - (Math.pow(10, -i - 1) * j));\n                    if (!zeroTickFlag) {  // did not do zero tick last iteration\n                        if (Math.abs(currentTickValue - 1.0) \u003c 0.0001\n                            \u0026\u0026 lowerBoundVal \u003c\u003d 0.0 \u0026\u0026 upperBoundVal \u003e\u003d 0.0) {\n                            //tick value is 1.0 and 0.0 is within data range\n                            currentTickValue \u003d 0.0;     //set tick value to zero\n                            zeroTickFlag \u003d true;        //indicate zero tick\n                        }\n                    }\n                    else {     //did zero tick last iteration\n                        zeroTickFlag \u003d false;         //clear flag\n                    }               //create tick label string:\n                               //show tick label if \"1e#\"-style and it\u0027s one\n                               // of the first two, if it\u0027s the first or last\n                               // in the set, or if it\u0027s 1-5; beyond that\n                               // show fewer as the values get larger:\n                    tickLabel \u003d ((this.expTickLabelsFlag \u0026\u0026 j \u003c 2)\n                                || j \u003c 1\n                                || (i \u003c 1 \u0026\u0026 j \u003c 5) || (j \u003c 4 - i)\n                                || currentTickValue \u003e\u003d upperBoundVal)\n                                   ? makeTickLabel(currentTickValue) : \"\";\n                }\n\n                if (currentTickValue \u003e upperBoundVal) {\n                    return ticks;   // if past highest data value then exit\n                                    // method\n                }\n\n                if (currentTickValue \u003e\u003d lowerBoundVal - SMALL_LOG_VALUE) {\n                    //tick value not below lowest data value\n                    TextAnchor anchor;\n                    TextAnchor rotationAnchor;\n                    double angle \u003d 0.0;\n                    if (isVerticalTickLabels()) {\n                        anchor \u003d TextAnchor.CENTER_RIGHT;\n                        rotationAnchor \u003d TextAnchor.CENTER_RIGHT;\n                        if (edge \u003d\u003d RectangleEdge.TOP) {\n                            angle \u003d Math.PI / 2.0;\n                        }\n                        else {\n                            angle \u003d -Math.PI / 2.0;\n                        }\n                    }\n                    else {\n                        if (edge \u003d\u003d RectangleEdge.TOP) {\n                            anchor \u003d TextAnchor.BOTTOM_CENTER;\n                            rotationAnchor \u003d TextAnchor.BOTTOM_CENTER;\n                        }\n                        else {\n                            anchor \u003d TextAnchor.TOP_CENTER;\n                            rotationAnchor \u003d TextAnchor.TOP_CENTER;\n                        }\n                    }\n\n                    Tick tick \u003d new NumberTick(currentTickValue, tickLabel, \n                            anchor, rotationAnchor, angle);\n                    ticks.add(tick);\n                }\n            }\n        }\n        return ticks;\n\n    }\n\n    /**\n     * Calculates the positions of the tick labels for the axis, storing the\n     * results in the tick label list (ready for drawing).\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area in which the plot should be drawn.\n     * @param edge  the location of the axis.\n     *\n     * @return A list of ticks.\n     */\n    @Override\n    protected List refreshTicksVertical(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        List ticks \u003d new java.util.ArrayList();\n\n        //get lower bound value:\n        double lowerBoundVal \u003d getRange().getLowerBound();\n        //if small log values and lower bound value too small\n        // then set to a small value (don\u0027t allow \u003c\u003d 0):\n        if (this.smallLogFlag \u0026\u0026 lowerBoundVal \u003c SMALL_LOG_VALUE) {\n            lowerBoundVal \u003d SMALL_LOG_VALUE;\n        }\n        //get upper bound value\n        double upperBoundVal \u003d getRange().getUpperBound();\n\n        //get log10 version of lower bound and round to integer:\n        int iBegCount \u003d (int) Math.rint(switchedLog10(lowerBoundVal));\n        //get log10 version of upper bound and round to integer:\n        int iEndCount \u003d (int) Math.rint(switchedLog10(upperBoundVal));\n\n        if (iBegCount \u003d\u003d iEndCount \u0026\u0026 iBegCount \u003e 0\n                \u0026\u0026 Math.pow(10, iBegCount) \u003e lowerBoundVal) {\n              //only 1 power of 10 value, it\u0027s \u003e 0 and its resulting\n              // tick value will be larger than lower bound of data\n            --iBegCount;       //decrement to generate more ticks\n        }\n\n        double tickVal;\n        String tickLabel;\n        boolean zeroTickFlag \u003d false;\n        for (int i \u003d iBegCount; i \u003c\u003d iEndCount; i++) {\n            //for each tick with a label to be displayed\n            int jEndCount \u003d 10;\n            if (i \u003d\u003d iEndCount) {\n                jEndCount \u003d 1;\n            }\n\n            for (int j \u003d 0; j \u003c jEndCount; j++) {\n                //for each tick to be displayed\n                if (this.smallLogFlag) {\n                    //small log values in use\n                    tickVal \u003d Math.pow(10, i) + (Math.pow(10, i) * j);\n                    if (j \u003d\u003d 0) {\n                        //first tick of group; create label text\n                        if (this.log10TickLabelsFlag) {\n                            //if flag then\n                            tickLabel \u003d \"10^\" + i;   //create \"log10\"-type label\n                        }\n                        else {    //not \"log10\"-type label\n                            if (this.expTickLabelsFlag) {\n                                //if flag then\n                                tickLabel \u003d \"1e\" + i;  //create \"1e#\"-type label\n                            }\n                            else {    //not \"1e#\"-type label\n                                if (i \u003e\u003d 0) {   // if positive exponent then\n                                                // make integer\n                                    NumberFormat format\n                                        \u003d getNumberFormatOverride();\n                                    if (format !\u003d null) {\n                                        tickLabel \u003d format.format(tickVal);\n                                    }\n                                    else {\n                                        tickLabel \u003d Long.toString((long)\n                                                Math.rint(tickVal));\n                                    }\n                                }\n                                else {\n                                    //negative exponent; create fractional value\n                                    //set exact number of fractional digits to\n                                    // be shown:\n                                    this.numberFormatterObj\n                                        .setMaximumFractionDigits(-i);\n                                    //create tick label:\n                                    tickLabel \u003d this.numberFormatterObj.format(\n                                            tickVal);\n                                }\n                            }\n                        }\n                    }\n                    else {   //not first tick to be displayed\n                        tickLabel \u003d \"\";     //no tick label\n                    }\n                }\n                else { //not small log values in use; allow for values \u003c\u003d 0\n                    if (zeroTickFlag) {      //if did zero tick last iter then\n                        --j;\n                    }               //decrement to do 1.0 tick now\n                    tickVal \u003d (i \u003e\u003d 0) ? Math.pow(10, i) + (Math.pow(10, i) * j)\n                             : -(Math.pow(10, -i) - (Math.pow(10, -i - 1) * j));\n                    if (j \u003d\u003d 0) {  //first tick of group\n                        if (!zeroTickFlag) {     // did not do zero tick last\n                                                 // iteration\n                            if (i \u003e iBegCount \u0026\u0026 i \u003c iEndCount\n                                    \u0026\u0026 Math.abs(tickVal - 1.0) \u003c 0.0001) {\n                                // not first or last tick on graph and value\n                                // is 1.0\n                                tickVal \u003d 0.0;        //change value to 0.0\n                                zeroTickFlag \u003d true;  //indicate zero tick\n                                tickLabel \u003d \"0\";      //create label for tick\n                            }\n                            else {\n                                //first or last tick on graph or value is 1.0\n                                //create label for tick:\n                                if (this.log10TickLabelsFlag) {\n                                       //create \"log10\"-type label\n                                    tickLabel \u003d (((i \u003c 0) ? \"-\" : \"\")\n                                            + \"10^\" + Math.abs(i));\n                                }\n                                else {\n                                    if (this.expTickLabelsFlag) {\n                                           //create \"1e#\"-type label\n                                        tickLabel \u003d (((i \u003c 0) ? \"-\" : \"\")\n                                                + \"1e\" + Math.abs(i));\n                                    }\n                                    else {\n                                        NumberFormat format\n                                            \u003d getNumberFormatOverride();\n                                        if (format !\u003d null) {\n                                            tickLabel \u003d format.format(tickVal);\n                                        }\n                                        else {\n                                            tickLabel \u003d  Long.toString(\n                                                    (long) Math.rint(tickVal));\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        else {     // did zero tick last iteration\n                            tickLabel \u003d \"\";         //no label\n                            zeroTickFlag \u003d false;   //clear flag\n                        }\n                    }\n                    else {       // not first tick of group\n                        tickLabel \u003d \"\";           //no label\n                        zeroTickFlag \u003d false;     //make sure flag cleared\n                    }\n                }\n\n                if (tickVal \u003e upperBoundVal) {\n                    return ticks;  //if past highest data value then exit method\n                }\n\n                if (tickVal \u003e\u003d lowerBoundVal - SMALL_LOG_VALUE) {\n                    //tick value not below lowest data value\n                    TextAnchor anchor;\n                    TextAnchor rotationAnchor;\n                    double angle \u003d 0.0;\n                    if (isVerticalTickLabels()) {\n                        if (edge \u003d\u003d RectangleEdge.LEFT) {\n                            anchor \u003d TextAnchor.BOTTOM_CENTER;\n                            rotationAnchor \u003d TextAnchor.BOTTOM_CENTER;\n                            angle \u003d -Math.PI / 2.0;\n                        }\n                        else {\n                            anchor \u003d TextAnchor.BOTTOM_CENTER;\n                            rotationAnchor \u003d TextAnchor.BOTTOM_CENTER;\n                            angle \u003d Math.PI / 2.0;\n                        }\n                    }\n                    else {\n                        if (edge \u003d\u003d RectangleEdge.LEFT) {\n                            anchor \u003d TextAnchor.CENTER_RIGHT;\n                            rotationAnchor \u003d TextAnchor.CENTER_RIGHT;\n                        }\n                        else {\n                            anchor \u003d TextAnchor.CENTER_LEFT;\n                            rotationAnchor \u003d TextAnchor.CENTER_LEFT;\n                        }\n                    }\n                    //create tick object and add to list:\n                    ticks.add(new NumberTick(tickVal, tickLabel, anchor, \n                            rotationAnchor, angle));\n                }\n            }\n        }\n        return ticks;\n    }\n\n    /**\n     * Converts the given value to a tick label string.\n     *\n     * @param val the value to convert.\n     * @param forceFmtFlag true to force the number-formatter object\n     * to be used.\n     *\n     * @return The tick label string.\n     */\n    protected String makeTickLabel(double val, boolean forceFmtFlag) {\n        if (this.expTickLabelsFlag || forceFmtFlag) {\n            //using exponents or force-formatter flag is set\n            // (convert \u0027E\u0027 to lower-case \u0027e\u0027):\n            return this.numberFormatterObj.format(val).toLowerCase();\n        }\n        return getTickUnit().valueToString(val);\n    }\n\n    /**\n     * Converts the given value to a tick label string.\n     * @param val the value to convert.\n     *\n     * @return The tick label string.\n     */\n    protected String makeTickLabel(double val) {\n        return makeTickLabel(val, false);\n    }\n\n}","methodCount":28,"staticMethodCount":0,"instanceMethodCount":28,"classLoc":981,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"2b5a06ab-00db-4bcd-8c35-c64461fd7173","hostFunctionTelemetryData":{"hostFunctionSize":383,"lineStart":45,"lineEnd":427,"bodyLineStart":45,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/axis/ModuloAxis.java","sourceCode":"/**\n * An axis that displays numerical values within a fixed range using a modulo\n * calculation.\n */\npublic class ModuloAxis extends NumberAxis {\n\n    /**\n     * The fixed range for the axis - all data values will be mapped to this\n     * range using a modulo calculation.\n     */\n    private Range fixedRange;\n\n    /**\n     * The display start value (this will sometimes be \u0026gt; displayEnd, in which\n     * case the axis wraps around at some point in the middle of the axis).\n     */\n    private double displayStart;\n\n    /**\n     * The display end value.\n     */\n    private double displayEnd;\n\n    /**\n     * Creates a new axis.\n     *\n     * @param label  the axis label ({@code null} permitted).\n     * @param fixedRange  the fixed range ({@code null} not permitted).\n     */\n    public ModuloAxis(String label, Range fixedRange) {\n        super(label);\n        this.fixedRange \u003d fixedRange;\n        this.displayStart \u003d 270.0;\n        this.displayEnd \u003d 90.0;\n    }\n\n    /**\n     * Returns the display start value.\n     *\n     * @return The display start value.\n     */\n    public double getDisplayStart() {\n        return this.displayStart;\n    }\n\n    /**\n     * Returns the display end value.\n     *\n     * @return The display end value.\n     */\n    public double getDisplayEnd() {\n        return this.displayEnd;\n    }\n\n    /**\n     * Sets the display range.  The values will be mapped to the fixed range if\n     * necessary.\n     *\n     * @param start  the start value.\n     * @param end  the end value.\n     */\n    public void setDisplayRange(double start, double end) {\n        this.displayStart \u003d mapValueToFixedRange(start);\n        this.displayEnd \u003d mapValueToFixedRange(end);\n        if (this.displayStart \u003c this.displayEnd) {\n            setRange(this.displayStart, this.displayEnd);\n        }\n        else {\n            setRange(this.displayStart, this.fixedRange.getUpperBound()\n                  + (this.displayEnd - this.fixedRange.getLowerBound()));\n        }\n        notifyListeners(new AxisChangeEvent(this));\n    }\n\n    /**\n     * This method should calculate a range that will show all the data values.\n     * For now, it just sets the axis range to the fixedRange.\n     */\n    @Override\n    protected void autoAdjustRange() {\n        setRange(this.fixedRange, false, false);\n    }\n\n    /**\n     * Translates a data value to a Java2D coordinate.\n     *\n     * @param value  the value.\n     * @param area  the area.\n     * @param edge  the edge.\n     *\n     * @return A Java2D coordinate.\n     */\n    @Override\n    public double valueToJava2D(double value, Rectangle2D area,\n            RectangleEdge edge) {\n        double result;\n        double v \u003d mapValueToFixedRange(value);\n        if (this.displayStart \u003c this.displayEnd) {  // regular number axis\n            result \u003d trans(v, area, edge);\n        }\n        else {  // displayStart \u003e displayEnd, need to handle split\n            double cutoff \u003d (this.displayStart + this.displayEnd) / 2.0;\n            double length1 \u003d this.fixedRange.getUpperBound()\n                             - this.displayStart;\n            double length2 \u003d this.displayEnd - this.fixedRange.getLowerBound();\n            if (v \u003e cutoff) {\n                result \u003d transStart(v, area, edge, length1, length2);\n            }\n            else {\n                result \u003d transEnd(v, area, edge, length1, length2);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * A regular translation from a data value to a Java2D value.\n     *\n     * @param value  the value.\n     * @param area  the data area.\n     * @param edge  the edge along which the axis lies.\n     *\n     * @return The Java2D coordinate.\n     */\n    private double trans(double value, Rectangle2D area, RectangleEdge edge) {\n        double min \u003d 0.0;\n        double max \u003d 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            min \u003d area.getX();\n            max \u003d area.getX() + area.getWidth();\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            min \u003d area.getMaxY();\n            max \u003d area.getMaxY() - area.getHeight();\n        }\n        if (isInverted()) {\n            return max - ((value - this.displayStart)\n                   / (this.displayEnd - this.displayStart)) * (max - min);\n        }\n        else {\n            return min + ((value - this.displayStart)\n                   / (this.displayEnd - this.displayStart)) * (max - min);\n        }\n\n    }\n\n    /**\n     * Translates a data value to a Java2D value for the first section of the\n     * axis.\n     *\n     * @param value  the value.\n     * @param area  the data area.\n     * @param edge  the edge along which the axis lies.\n     * @param length1  the length of the first section.\n     * @param length2  the length of the second section.\n     *\n     * @return The Java2D coordinate.\n     */\n    private double transStart(double value, Rectangle2D area, RectangleEdge edge,\n            double length1, double length2) {\n        double min \u003d 0.0;\n        double max \u003d 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            min \u003d area.getX();\n            max \u003d area.getX() + area.getWidth() * length1 / (length1 + length2);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            min \u003d area.getMaxY();\n            max \u003d area.getMaxY() - area.getHeight() * length1\n                  / (length1 + length2);\n        }\n        if (isInverted()) {\n            return max - ((value - this.displayStart)\n                / (this.fixedRange.getUpperBound() - this.displayStart))\n                * (max - min);\n        }\n        else {\n            return min + ((value - this.displayStart)\n                / (this.fixedRange.getUpperBound() - this.displayStart))\n                * (max - min);\n        }\n\n    }\n\n    /**\n     * Translates a data value to a Java2D value for the second section of the\n     * axis.\n     *\n     * @param value  the value.\n     * @param area  the data area.\n     * @param edge  the edge along which the axis lies.\n     * @param length1  the length of the first section.\n     * @param length2  the length of the second section.\n     *\n     * @return The Java2D coordinate.\n     */\n    private double transEnd(double value, Rectangle2D area, RectangleEdge edge,\n            double length1, double length2) {\n        double min \u003d 0.0;\n        double max \u003d 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            max \u003d area.getMaxX();\n            min \u003d area.getMaxX() - area.getWidth() * length2\n                  / (length1 + length2);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            max \u003d area.getMinY();\n            min \u003d area.getMinY() + area.getHeight() * length2\n                  / (length1 + length2);\n        }\n        if (isInverted()) {\n            return max - ((value - this.fixedRange.getLowerBound())\n                    / (this.displayEnd - this.fixedRange.getLowerBound()))\n                    * (max - min);\n        }\n        else {\n            return min + ((value - this.fixedRange.getLowerBound())\n                    / (this.displayEnd - this.fixedRange.getLowerBound()))\n                    * (max - min);\n        }\n\n    }\n\n    /**\n     * Maps a data value into the fixed range.\n     *\n     * @param value  the value.\n     *\n     * @return The mapped value.\n     */\n    private double mapValueToFixedRange(double value) {\n        double lower \u003d this.fixedRange.getLowerBound();\n        double length \u003d this.fixedRange.getLength();\n        if (value \u003c lower) {\n            return lower + length + ((value - lower) % length);\n        }\n        else {\n            return lower + ((value - lower) % length);\n        }\n    }\n\n    /**\n     * Translates a Java2D coordinate into a data value.\n     *\n     * @param java2DValue  the Java2D coordinate.\n     * @param area  the area.\n     * @param edge  the edge.\n     *\n     * @return The Java2D coordinate.\n     */\n    @Override\n    public double java2DToValue(double java2DValue, Rectangle2D area,\n            RectangleEdge edge) {\n        double result \u003d 0.0;\n        if (this.displayStart \u003c this.displayEnd) {  // regular number axis\n            result \u003d super.java2DToValue(java2DValue, area, edge);\n        }\n        else {  // displayStart \u003e displayEnd, need to handle split\n\n        }\n        return result;\n    }\n\n    /**\n     * Returns the display length for the axis.\n     *\n     * @return The display length.\n     */\n    private double getDisplayLength() {\n        if (this.displayStart \u003c this.displayEnd) {\n            return (this.displayEnd - this.displayStart);\n        }\n        else {\n            return (this.fixedRange.getUpperBound() - this.displayStart)\n                + (this.displayEnd - this.fixedRange.getLowerBound());\n        }\n    }\n\n    /**\n     * Returns the central value of the current display range.\n     *\n     * @return The central value.\n     */\n    private double getDisplayCentralValue() {\n        return mapValueToFixedRange(this.displayStart \n                + (getDisplayLength() / 2));\n    }\n\n    /**\n     * Increases or decreases the axis range by the specified percentage about\n     * the central value and sends an {@link AxisChangeEvent} to all registered\n     * listeners.\n     * \u003cP\u003e\n     * To double the length of the axis range, use 200% (2.0).\n     * To halve the length of the axis range, use 50% (0.5).\n     *\n     * @param percent  the resize factor.\n     */\n    @Override\n    public void resizeRange(double percent) {\n        resizeRange(percent, getDisplayCentralValue());\n    }\n\n    /**\n     * Increases or decreases the axis range by the specified percentage about\n     * the specified anchor value and sends an {@link AxisChangeEvent} to all\n     * registered listeners.\n     * \u003cP\u003e\n     * To double the length of the axis range, use 200% (2.0).\n     * To halve the length of the axis range, use 50% (0.5).\n     *\n     * @param percent  the resize factor.\n     * @param anchorValue  the new central value after the resize.\n     */\n    @Override\n    public void resizeRange(double percent, double anchorValue) {\n        if (percent \u003e 0.0) {\n            double halfLength \u003d getDisplayLength() * percent / 2;\n            setDisplayRange(anchorValue - halfLength, anchorValue + halfLength);\n        }\n        else {\n            setAutoRange(true);\n        }\n    }\n\n    /**\n     * Converts a length in data coordinates into the corresponding length in\n     * Java2D coordinates.\n     *\n     * @param length  the length.\n     * @param area  the plot area.\n     * @param edge  the edge along which the axis lies.\n     *\n     * @return The length in Java2D coordinates.\n     */\n    @Override\n    public double lengthToJava2D(double length, Rectangle2D area,\n            RectangleEdge edge) {\n        double axisLength;\n        if (this.displayEnd \u003e this.displayStart) {\n            axisLength \u003d this.displayEnd - this.displayStart;\n        } else {\n            axisLength \u003d (this.fixedRange.getUpperBound() - this.displayStart)\n                + (this.displayEnd - this.fixedRange.getLowerBound());\n        }\n        double areaLength;\n        if (RectangleEdge.isLeftOrRight(edge)) {\n            areaLength \u003d area.getHeight();\n        } else {\n            areaLength \u003d area.getWidth();\n        }\n        return (length / axisLength) * areaLength;\n    }\n\n    /**\n     * Tests this axis for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof ModuloAxis)) {\n            return false;\n        }\n        ModuloAxis that \u003d (ModuloAxis) obj;\n        if (this.displayStart !\u003d that.displayStart) {\n            return false;\n        }\n        if (this.displayEnd !\u003d that.displayEnd) {\n            return false;\n        }\n        if (!this.fixedRange.equals(that.fixedRange)) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n}","methodCount":17,"staticMethodCount":0,"instanceMethodCount":17,"classLoc":383,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":1,"candidates":[{"lineStart":267,"lineEnd":283,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method mapValueToFixedRange to class Range","description":"Move method mapValueToFixedRange to org.jfree.data.Range\nRationale: The mapValueToFixedRange method manipulates values within a range, specifically using the lower bound and length of a range to calculate a new value. Since the Range class encapsulates the concept of a range with bounded values, moving the method to this class aligns well with the responsibilities and operations of the Range class. Furthermore, Range already includes methods for similar manipulations like constrain and shift, making it an appropriate and cohesive target for mapValueToFixedRange.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Somewhat Helpful"}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":88068}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":23587},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"setDisplayRange","method_signature":"public setDisplayRange(double start, double end)","target_class":"","rationale":""},{"method_name":"transStart","method_signature":"private transStart(double value, Rectangle2D area, RectangleEdge edge,\n            double length1, double length2)","target_class":"","rationale":""},{"method_name":"transEnd","method_signature":"private transEnd(double value, Rectangle2D area, RectangleEdge edge,\n            double length1, double length2)","target_class":"","rationale":""},{"method_name":"mapValueToFixedRange","method_signature":"private mapValueToFixedRange(double value)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"mapValueToFixedRange","method_signature":"private mapValueToFixedRange(double value)","target_class":"","rationale":""},{"method_name":"setDisplayRange","method_signature":"public setDisplayRange(double start, double end)","target_class":"","rationale":""},{"method_name":"transEnd","method_signature":"private transEnd(double value, Rectangle2D area, RectangleEdge edge,\n            double length1, double length2)","target_class":"","rationale":""},{"method_name":"transStart","method_signature":"private transStart(double value, Rectangle2D area, RectangleEdge edge,\n            double length1, double length2)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"private mapValueToFixedRange(double value)":{"first":{"method_name":"mapValueToFixedRange","method_signature":"private mapValueToFixedRange(double value)","target_class":"","rationale":""},"second":0.7478116291539656},"public setDisplayRange(double start, double end)":{"first":{"method_name":"setDisplayRange","method_signature":"public setDisplayRange(double start, double end)","target_class":"","rationale":""},"second":0.7876988054249622},"private transEnd(double value, Rectangle2D area, RectangleEdge edge,\n            double length1, double length2)":{"first":{"method_name":"transEnd","method_signature":"private transEnd(double value, Rectangle2D area, RectangleEdge edge,\n            double length1, double length2)","target_class":"","rationale":""},"second":0.8945620963528701},"private transStart(double value, Rectangle2D area, RectangleEdge edge,\n            double length1, double length2)":{"first":{"method_name":"transStart","method_signature":"private transStart(double value, Rectangle2D area, RectangleEdge edge,\n            double length1, double length2)","target_class":"","rationale":""},"second":0.8959894234682194}},"targetClassMap":{"mapValueToFixedRange":{"target_classes":[{"class_name":"Range","similarity_score":0.7050873806440183}],"target_classes_sorted_by_llm":["Range"],"llm_response_time":3890,"similarity_computation_time":1,"similarity_metric":"cosine"},"setDisplayRange":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":7550,"similarity_computation_time":0,"similarity_metric":"cosine"},"transEnd":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":6644,"similarity_computation_time":0,"similarity_metric":"cosine"},"transStart":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5419,"similarity_computation_time":0,"similarity_metric":"cosine"}}}
{"id":"258610b4-5d2a-4f6b-a647-3b2f8a466c79","hostFunctionTelemetryData":{"hostFunctionSize":226,"lineStart":52,"lineEnd":277,"bodyLineStart":52,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/block/BlockContainer.java","sourceCode":"/**\n * A container for a collection of {@link Block} objects.  The container uses\n * an {@link Arrangement} object to handle the position of each block.\n */\npublic class BlockContainer extends AbstractBlock\n        implements Block, Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d 8199508075695195293L;\n\n    /** The blocks within the container. */\n    private final List\u003cBlock\u003e blocks;\n\n    /** The object responsible for laying out the blocks. */\n    private Arrangement arrangement;\n\n    /**\n     * Creates a new instance with default settings.\n     */\n    public BlockContainer() {\n        this(new BorderArrangement());\n    }\n\n    /**\n     * Creates a new instance with the specified arrangement.\n     *\n     * @param arrangement  the arrangement manager ({@code null} not\n     *                     permitted).\n     */\n    public BlockContainer(Arrangement arrangement) {\n        Args.nullNotPermitted(arrangement, \"arrangement\");\n        this.arrangement \u003d arrangement;\n        this.blocks \u003d new ArrayList\u003c\u003e();\n    }\n\n    /**\n     * Returns the arrangement (layout) manager for the container.\n     *\n     * @return The arrangement manager (never {@code null}).\n     */\n    public Arrangement getArrangement() {\n        return this.arrangement;\n    }\n\n    /**\n     * Sets the arrangement (layout) manager.\n     *\n     * @param arrangement  the arrangement ({@code null} not permitted).\n     */\n    public void setArrangement(Arrangement arrangement) {\n        Args.nullNotPermitted(arrangement, \"arrangement\");\n        this.arrangement \u003d arrangement;\n    }\n\n    /**\n     * Returns {@code true} if there are no blocks in the container, and\n     * {@code false} otherwise.\n     *\n     * @return A boolean.\n     */\n    public boolean isEmpty() {\n        return this.blocks.isEmpty();\n    }\n\n    /**\n     * Returns an unmodifiable list of the {@link Block} objects managed by\n     * this arrangement.\n     *\n     * @return A list of blocks (possibly empty, but never {@code null}).\n     */\n    public List\u003cBlock\u003e getBlocks() {\n        return Collections.unmodifiableList(this.blocks);\n    }\n\n    /**\n     * Adds a block to the container.\n     *\n     * @param block  the block ({@code null} permitted).\n     */\n    public void add(Block block) {\n        add(block, null);\n    }\n\n    /**\n     * Adds a block to the container.\n     *\n     * @param block  the block ({@code null} permitted).\n     * @param key  the key ({@code null} permitted).\n     */\n    public void add(Block block, Object key) {\n        this.blocks.add(block);\n        this.arrangement.add(block, key);\n    }\n\n    /**\n     * Clears all the blocks from the container.\n     */\n    public void clear() {\n        this.blocks.clear();\n        this.arrangement.clear();\n    }\n\n    /**\n     * Arranges the contents of the block, within the given constraints, and\n     * returns the block size.\n     *\n     * @param g2  the graphics device.\n     * @param constraint  the constraint ({@code null} not permitted).\n     *\n     * @return The block size (in Java2D units, never {@code null}).\n     */\n    @Override\n    public Size2D arrange(Graphics2D g2, RectangleConstraint constraint) {\n        return this.arrangement.arrange(this, g2, constraint);\n    }\n\n    /**\n     * Draws the container and all the blocks within it.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     */\n    @Override\n    public void draw(Graphics2D g2, Rectangle2D area) {\n        draw(g2, area, null);\n    }\n\n    /**\n     * Draws the block within the specified area.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     * @param params  passed on to blocks within the container\n     *                ({@code null} permitted).\n     *\n     * @return An instance of {@link EntityBlockResult}, or {@code null}.\n     */\n    @Override\n    public Object draw(Graphics2D g2, Rectangle2D area, Object params) {\n        // check if we need to collect chart entities from the container\n        EntityBlockParams ebp;\n        StandardEntityCollection sec \u003d null;\n        if (params instanceof EntityBlockParams) {\n            ebp \u003d (EntityBlockParams) params;\n            if (ebp.getGenerateEntities()) {\n                sec \u003d new StandardEntityCollection();\n            }\n        }\n        Rectangle2D contentArea \u003d (Rectangle2D) area.clone();\n        contentArea \u003d trimMargin(contentArea);\n        drawBorder(g2, contentArea);\n        contentArea \u003d trimBorder(contentArea);\n        contentArea \u003d trimPadding(contentArea);\n        for (Block block : this.blocks) {\n            Rectangle2D bounds \u003d block.getBounds();\n            Rectangle2D drawArea \u003d new Rectangle2D.Double(bounds.getX()\n                    + area.getX(), bounds.getY() + area.getY(),\n                    bounds.getWidth(), bounds.getHeight());\n            Object r \u003d block.draw(g2, drawArea, params);\n            if (sec !\u003d null) {\n                if (r instanceof EntityBlockResult) {\n                    EntityBlockResult ebr \u003d (EntityBlockResult) r;\n                    EntityCollection ec \u003d ebr.getEntityCollection();\n                    sec.addAll(ec);\n                }\n            }\n        }\n        BlockResult result \u003d null;\n        if (sec !\u003d null) {\n            result \u003d new BlockResult();\n            result.setEntityCollection(sec);\n        }\n        return result;\n    }\n\n    /**\n     * Tests this container for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof BlockContainer)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        BlockContainer that \u003d (BlockContainer) obj;\n        if (!this.arrangement.equals(that.arrangement)) {\n            return false;\n        }\n        if (!this.blocks.equals(that.blocks)) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode(){\n        int hash \u003d 3;\n        hash \u003d 97 * hash + Objects.hashCode(this.blocks);\n        hash \u003d 97 * hash + Objects.hashCode(this.arrangement);\n        return hash;\n    }\n\n    /**\n     * Returns a clone of the container.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if there is a problem cloning.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        BlockContainer clone \u003d (BlockContainer) super.clone();\n        // TODO : complete this\n        return clone;\n    }\n\n}","methodCount":15,"staticMethodCount":0,"instanceMethodCount":15,"classLoc":226,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":2,"candidates":[{"lineStart":145,"lineEnd":151,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method clear to class Arrangement","description":"Move method clear to org.jfree.chart.block.Arrangement\nRationale: The clear() method is responsible for clearing all blocks from the container as well as the arrangement. The Arrangement interface already contains a clear() method for clearing cached layout information, so adding the clear() method to Arrangement aligns with its responsibility of managing the layout of blocks. Given the method\u0027s scope, which fits well with the purpose and existing responsibilities of the Arrangement interface, it is logical to move this method to the Arrangement class to consolidate related functionality.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false,"userRating":"Very Helpful"},{"lineStart":134,"lineEnd":143,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method add to class Arrangement","description":"Move method add to org.jfree.chart.block.Arrangement\nRationale: The add(Block block, Object key) method directly interacts with the arrangement instance by calling its add method. This indicates that organizing blocks with associated keys to determine their positions is core to the functionality of the Arrangement class. Therefore, moving the method to Arrangement would centralize the logic related to arranging blocks, making the code more cohesive and maintainable.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false}]},"userSelectionTelemetryData":{"lineStart":134,"lineEnd":143,"functionSize":10,"positionInHostFunction":82,"selectedCandidateIndex":1,"candidateType":"AS_IS","elementsType":[{"elementType":"METHOD","quantity":1}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":204283},{"candidateIndex":1,"elapsedTime":18617}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":7918},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"add","method_signature":"public add(Block block, Object key)","target_class":"","rationale":""},{"method_name":"clear","method_signature":"public clear()","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"clear","method_signature":"public clear()","target_class":"","rationale":""},{"method_name":"add","method_signature":"public add(Block block, Object key)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public clear()":{"first":{"method_name":"clear","method_signature":"public clear()","target_class":"","rationale":""},"second":0.5874245272516715},"public add(Block block, Object key)":{"first":{"method_name":"add","method_signature":"public add(Block block, Object key)","target_class":"","rationale":""},"second":0.6589485764292509}},"targetClassMap":{"clear":{"target_classes":[{"class_name":"Arrangement","similarity_score":0.5193330350071134}],"target_classes_sorted_by_llm":["Arrangement"],"llm_response_time":3700,"similarity_computation_time":0,"similarity_metric":"cosine"},"add":{"target_classes":[{"class_name":"Block","similarity_score":0.6912204345970097},{"class_name":"Arrangement","similarity_score":0.7498257992218761}],"target_classes_sorted_by_llm":["Arrangement","Block"],"llm_response_time":3866,"similarity_computation_time":1,"similarity_metric":"cosine"}}}
{"id":"d15778b0-afd7-41e6-adee-92276f33f843","hostFunctionTelemetryData":{"hostFunctionSize":495,"lineStart":48,"lineEnd":542,"bodyLineStart":48,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/block/BorderArrangement.java","sourceCode":"/**\n * An arrangement manager that lays out blocks in a similar way to\n * Swing\u0027s BorderLayout class.\n */\npublic class BorderArrangement implements Arrangement, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d 506071142274883745L;\n\n    /** The block (if any) at the center of the layout. */\n    private Block centerBlock;\n\n    /** The block (if any) at the top of the layout. */\n    private Block topBlock;\n\n    /** The block (if any) at the bottom of the layout. */\n    private Block bottomBlock;\n\n    /** The block (if any) at the left of the layout. */\n    private Block leftBlock;\n\n    /** The block (if any) at the right of the layout. */\n    private Block rightBlock;\n\n    /**\n     * Creates a new instance.\n     */\n    public BorderArrangement() {\n    }\n\n    /**\n     * Adds a block to the arrangement manager at the specified edge.\n     * If the key is not an instance of {@link RectangleEdge} the block will\n     * be added in the center.\n     *\n     * @param block  the block ({@code null} permitted).\n     * @param key  the edge (an instance of {@link RectangleEdge}) or\n     *             {@code null} for the center block.\n     */\n    @Override\n    public void add(Block block, Object key) {\n\n        if (!(key instanceof RectangleEdge)) { // catches null also\n            this.centerBlock \u003d block;\n        }\n        else {\n            RectangleEdge edge \u003d (RectangleEdge) key;\n            if (edge \u003d\u003d RectangleEdge.TOP) {\n                this.topBlock \u003d block;\n            }\n            else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n                this.bottomBlock \u003d block;\n            }\n            else if (edge \u003d\u003d RectangleEdge.LEFT) {\n                this.leftBlock \u003d block;\n            }\n            else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n                this.rightBlock \u003d block;\n            }\n        }\n    }\n\n    /**\n     * Arranges the items in the specified container, subject to the given\n     * constraint.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     * @param constraint  the constraint.\n     *\n     * @return The block size.\n     */\n    @Override\n    public Size2D arrange(BlockContainer container, Graphics2D g2,\n            RectangleConstraint constraint) {\n        RectangleConstraint contentConstraint\n                \u003d container.toContentConstraint(constraint);\n        Size2D contentSize \u003d null;\n        LengthConstraintType w \u003d contentConstraint.getWidthConstraintType();\n        LengthConstraintType h \u003d contentConstraint.getHeightConstraintType();\n        if (w \u003d\u003d LengthConstraintType.NONE) {\n            if (h \u003d\u003d LengthConstraintType.NONE) {\n                contentSize \u003d arrangeNN(container, g2);\n            }\n            else if (h \u003d\u003d LengthConstraintType.FIXED) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n            else if (h \u003d\u003d LengthConstraintType.RANGE) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n        }\n        else if (w \u003d\u003d LengthConstraintType.FIXED) {\n            if (h \u003d\u003d LengthConstraintType.NONE) {\n                contentSize \u003d arrangeFN(container, g2, constraint.getWidth());\n            }\n            else if (h \u003d\u003d LengthConstraintType.FIXED) {\n                contentSize \u003d arrangeFF(container, g2, constraint);\n            }\n            else if (h \u003d\u003d LengthConstraintType.RANGE) {\n                contentSize \u003d arrangeFR(container, g2, constraint);\n            }\n        }\n        else if (w \u003d\u003d LengthConstraintType.RANGE) {\n            if (h \u003d\u003d LengthConstraintType.NONE) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n            else if (h \u003d\u003d LengthConstraintType.FIXED) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n            else if (h \u003d\u003d LengthConstraintType.RANGE) {\n                contentSize \u003d arrangeRR(container, constraint.getWidthRange(),\n                        constraint.getHeightRange(), g2);\n            }\n        }\n        assert contentSize !\u003d null; \n        return new Size2D(container.calculateTotalWidth(contentSize.getWidth()),\n                container.calculateTotalHeight(contentSize.getHeight()));\n    }\n\n    /**\n     * Performs an arrangement without constraints.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) {\n        double[] w \u003d new double[5];\n        double[] h \u003d new double[5];\n        if (this.topBlock !\u003d null) {\n            Size2D size \u003d this.topBlock.arrange(g2, RectangleConstraint.NONE);\n            w[0] \u003d size.width;\n            h[0] \u003d size.height;\n        }\n        if (this.bottomBlock !\u003d null) {\n            Size2D size \u003d this.bottomBlock.arrange(g2,\n                    RectangleConstraint.NONE);\n            w[1] \u003d size.width;\n            h[1] \u003d size.height;\n        }\n        if (this.leftBlock !\u003d null) {\n            Size2D size \u003d this.leftBlock.arrange(g2, RectangleConstraint.NONE);\n            w[2] \u003d size.width;\n            h[2] \u003d size.height;\n       }\n        if (this.rightBlock !\u003d null) {\n            Size2D size \u003d this.rightBlock.arrange(g2, RectangleConstraint.NONE);\n            w[3] \u003d size.width;\n            h[3] \u003d size.height;\n        }\n\n        h[2] \u003d Math.max(h[2], h[3]);\n        h[3] \u003d h[2];\n\n        if (this.centerBlock !\u003d null) {\n            Size2D size \u003d this.centerBlock.arrange(g2,\n                    RectangleConstraint.NONE);\n            w[4] \u003d size.width;\n            h[4] \u003d size.height;\n        }\n        double width \u003d Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));\n        double centerHeight \u003d Math.max(h[2], Math.max(h[3], h[4]));\n        double height \u003d h[0] + h[1] + centerHeight;\n        if (this.topBlock !\u003d null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width,\n                    h[0]));\n        }\n        if (this.bottomBlock !\u003d null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0,\n                    height - h[1], width, h[1]));\n        }\n        if (this.leftBlock !\u003d null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    centerHeight));\n        }\n        if (this.rightBlock !\u003d null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3],\n                    h[0], w[3], centerHeight));\n        }\n\n        if (this.centerBlock !\u003d null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0],\n                    width - w[2] - w[3], centerHeight));\n        }\n        return new Size2D(width, height);\n    }\n\n    /**\n     * Performs an arrangement with a fixed width and a range for the height.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     * @param constraint  the constraint.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeFR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        Size2D size1 \u003d arrangeFN(container, g2, constraint.getWidth());\n        if (constraint.getHeightRange().contains(size1.getHeight())) {\n            return size1;\n        }\n        else {\n            double h \u003d constraint.getHeightRange().constrain(size1.getHeight());\n            RectangleConstraint c2 \u003d constraint.toFixedHeight(h);\n            return arrange(container, g2, c2);\n        }\n    }\n\n    /**\n     * Arranges the container width a fixed width and no constraint on the\n     * height.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     * @param width  the fixed width.\n     *\n     * @return The container size after arranging the contents.\n     */\n    protected Size2D arrangeFN(BlockContainer container, Graphics2D g2,\n                               double width) {\n        double[] w \u003d new double[5];\n        double[] h \u003d new double[5];\n        RectangleConstraint c1 \u003d new RectangleConstraint(width, null,\n                LengthConstraintType.FIXED, 0.0, null,\n                LengthConstraintType.NONE);\n        if (this.topBlock !\u003d null) {\n            Size2D size \u003d this.topBlock.arrange(g2, c1);\n            w[0] \u003d size.width;\n            h[0] \u003d size.height;\n        }\n        if (this.bottomBlock !\u003d null) {\n            Size2D size \u003d this.bottomBlock.arrange(g2, c1);\n            w[1] \u003d size.width;\n            h[1] \u003d size.height;\n        }\n        RectangleConstraint c2 \u003d new RectangleConstraint(0.0,\n                new Range(0.0, width), LengthConstraintType.RANGE,\n                0.0, null, LengthConstraintType.NONE);\n        if (this.leftBlock !\u003d null) {\n            Size2D size \u003d this.leftBlock.arrange(g2, c2);\n            w[2] \u003d size.width;\n            h[2] \u003d size.height;\n        }\n        if (this.rightBlock !\u003d null) {\n            double maxW \u003d Math.max(width - w[2], 0.0);\n            RectangleConstraint c3 \u003d new RectangleConstraint(0.0,\n                    new Range(Math.min(w[2], maxW), maxW),\n                    LengthConstraintType.RANGE, 0.0, null,\n                    LengthConstraintType.NONE);\n            Size2D size \u003d this.rightBlock.arrange(g2, c3);\n            w[3] \u003d size.width;\n            h[3] \u003d size.height;\n        }\n\n        h[2] \u003d Math.max(h[2], h[3]);\n        h[3] \u003d h[2];\n\n        if (this.centerBlock !\u003d null) {\n            RectangleConstraint c4 \u003d new RectangleConstraint(width - w[2]\n                    - w[3], null, LengthConstraintType.FIXED, 0.0, null,\n                    LengthConstraintType.NONE);\n            Size2D size \u003d this.centerBlock.arrange(g2, c4);\n            w[4] \u003d size.width;\n            h[4] \u003d size.height;\n        }\n        double height \u003d h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n        return arrange(container, g2, new RectangleConstraint(width, height));\n    }\n\n    /**\n     * Performs an arrangement with range constraints on both the vertical\n     * and horizontal sides.\n     *\n     * @param container  the container.\n     * @param widthRange  the allowable range for the container width.\n     * @param heightRange  the allowable range for the container height.\n     * @param g2  the graphics device.\n     *\n     * @return The container size.\n     */\n    protected Size2D arrangeRR(BlockContainer container,\n                               Range widthRange, Range heightRange,\n                               Graphics2D g2) {\n        double[] w \u003d new double[5];\n        double[] h \u003d new double[5];\n        if (this.topBlock !\u003d null) {\n            RectangleConstraint c1 \u003d new RectangleConstraint(widthRange,\n                    heightRange);\n            Size2D size \u003d this.topBlock.arrange(g2, c1);\n            w[0] \u003d size.width;\n            h[0] \u003d size.height;\n        }\n        if (this.bottomBlock !\u003d null) {\n            Range heightRange2 \u003d Range.shift(heightRange, -h[0], false);\n            RectangleConstraint c2 \u003d new RectangleConstraint(widthRange,\n                    heightRange2);\n            Size2D size \u003d this.bottomBlock.arrange(g2, c2);\n            w[1] \u003d size.width;\n            h[1] \u003d size.height;\n        }\n        Range heightRange3 \u003d Range.shift(heightRange, -(h[0] + h[1]));\n        if (this.leftBlock !\u003d null) {\n            RectangleConstraint c3 \u003d new RectangleConstraint(widthRange,\n                    heightRange3);\n            Size2D size \u003d this.leftBlock.arrange(g2, c3);\n            w[2] \u003d size.width;\n            h[2] \u003d size.height;\n        }\n        Range widthRange2 \u003d Range.shift(widthRange, -w[2], false);\n        if (this.rightBlock !\u003d null) {\n            RectangleConstraint c4 \u003d new RectangleConstraint(widthRange2,\n                    heightRange3);\n            Size2D size \u003d this.rightBlock.arrange(g2, c4);\n            w[3] \u003d size.width;\n            h[3] \u003d size.height;\n        }\n\n        h[2] \u003d Math.max(h[2], h[3]);\n        h[3] \u003d h[2];\n        Range widthRange3 \u003d Range.shift(widthRange, -(w[2] + w[3]), false);\n        if (this.centerBlock !\u003d null) {\n            RectangleConstraint c5 \u003d new RectangleConstraint(widthRange3,\n                    heightRange3);\n            Size2D size \u003d this.centerBlock.arrange(g2, c5);\n            w[4] \u003d size.width;\n            h[4] \u003d size.height;\n        }\n        double width \u003d Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));\n        double height \u003d h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n        if (this.topBlock !\u003d null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width,\n                    h[0]));\n        }\n        if (this.bottomBlock !\u003d null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0,\n                    height - h[1], width, h[1]));\n        }\n        if (this.leftBlock !\u003d null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock !\u003d null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3],\n                    h[0], w[3], h[3]));\n        }\n\n        if (this.centerBlock !\u003d null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0],\n                    width - w[2] - w[3], height - h[0] - h[1]));\n        }\n        return new Size2D(width, height);\n    }\n\n    /**\n     * Arranges the items within a container.\n     *\n     * @param container  the container.\n     * @param constraint  the constraint.\n     * @param g2  the graphics device.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w \u003d new double[5];\n        double[] h \u003d new double[5];\n        w[0] \u003d constraint.getWidth();\n        if (this.topBlock !\u003d null) {\n            RectangleConstraint c1 \u003d new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size \u003d this.topBlock.arrange(g2, c1);\n            h[0] \u003d size.height;\n        }\n        w[1] \u003d w[0];\n        if (this.bottomBlock !\u003d null) {\n            RectangleConstraint c2 \u003d new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size \u003d this.bottomBlock.arrange(g2, c2);\n            h[1] \u003d size.height;\n        }\n        h[2] \u003d constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock !\u003d null) {\n            RectangleConstraint c3 \u003d new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size \u003d this.leftBlock.arrange(g2, c3);\n            w[2] \u003d size.width;\n        }\n        h[3] \u003d h[2];\n        if (this.rightBlock !\u003d null) {\n            RectangleConstraint c4 \u003d new RectangleConstraint(0.0,\n                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size \u003d this.rightBlock.arrange(g2, c4);\n            w[3] \u003d size.width;\n        }\n        h[4] \u003d h[2];\n        w[4] \u003d constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 \u003d new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock !\u003d null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n\n        if (this.topBlock !\u003d null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock !\u003d null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock !\u003d null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock !\u003d null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock !\u003d null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }\n\n    /**\n     * Clears the layout.\n     */\n    @Override\n    public void clear() {\n        this.centerBlock \u003d null;\n        this.topBlock \u003d null;\n        this.bottomBlock \u003d null;\n        this.leftBlock \u003d null;\n        this.rightBlock \u003d null;\n    }\n\n    /**\n     * Tests this arrangement for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof BorderArrangement)) {\n            return false;\n        }\n        BorderArrangement that \u003d (BorderArrangement) obj;\n        if (!Objects.equals(this.topBlock, that.topBlock)) {\n            return false;\n        }\n        if (!Objects.equals(this.bottomBlock, that.bottomBlock)) {\n            return false;\n        }\n        if (!Objects.equals(this.leftBlock, that.leftBlock)) {\n            return false;\n        }\n        if (!Objects.equals(this.rightBlock, that.rightBlock)) {\n            return false;\n        }\n        if (!Objects.equals(this.centerBlock, that.centerBlock)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this instance.\n     * \n     * @return A hash code. \n     */\n    @Override\n    public int hashCode() {\n        int hash \u003d 5;\n        hash \u003d 31 * hash + Objects.hashCode(this.centerBlock);\n        hash \u003d 31 * hash + Objects.hashCode(this.topBlock);\n        hash \u003d 31 * hash + Objects.hashCode(this.bottomBlock);\n        hash \u003d 31 * hash + Objects.hashCode(this.leftBlock);\n        hash \u003d 31 * hash + Objects.hashCode(this.rightBlock);\n        return hash;\n    }\n}","methodCount":11,"staticMethodCount":0,"instanceMethodCount":11,"classLoc":495,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":3,"candidates":[{"lineStart":235,"lineEnd":255,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method arrangeFR to class BlockContainer","description":"Move method arrangeFR to org.jfree.chart.block.BlockContainer\nRationale: The method \u0027arrangeFR\u0027 seems to manipulate block arrangement within a container using fixed width and a range for height, specifically dealing with graphical arrangements and constraints. Since the \u0027BlockContainer\u0027 class is responsible for handling a collection of blocks and their arrangements, it is a logical choice to move \u0027arrangeFR\u0027 to \u0027BlockContainer\u0027. This class already contains methods for arranging blocks, making it consistent to house the \u0027arrangeFR\u0027 method here.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Somewhat Helpful"},{"lineStart":257,"lineEnd":316,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method arrangeFN to class Block","description":"Move method arrangeFN to org.jfree.chart.block.Block\nRationale: The method arrangeFN() is primarily concerned with arranging blocks within given constraints, which directly relates to the responsibilities of the Block interface. The Block interface already defines behavior for arranging its contents (arrange(Graphics2D g2) and arrange(Graphics2D g2, RectangleConstraint constraint)). The arrangeFN() method would naturally fit within this class, as it extends the arrangement functionalities to include layout management involving multiple blocks (topBlock, bottomBlock, leftBlock, etc.). Moving this method to the Block class keeps the arrangement logic consolidated within the block management domain, increasing cohesion and making the architecture more intuitive.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false},{"lineStart":166,"lineEnd":233,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method arrangeNN to class Block","description":"Move method arrangeNN to org.jfree.chart.block.Block\nRationale: The arrangeNN() method aligns closely with the Block interface\u0027s responsibility of arranging and setting the bounds of its contents. Within the Block interface, methods like arrange(Graphics2D g2) and arrange(Graphics2D g2, RectangleConstraint constraint) serve similar purposes as arrangeNN(), making it the most appropriate target class for this method. Moving arrangeNN() to Block also adheres to the principle of placing closely related functionalities in the same class, thereby promoting cohesion.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":67200}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":27035},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"arrangeNN","method_signature":"protected arrangeNN(BlockContainer container, Graphics2D g2)","target_class":"","rationale":""},{"method_name":"arrangeFR","method_signature":"protected arrangeFR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)","target_class":"","rationale":""},{"method_name":"arrangeFN","method_signature":"protected arrangeFN(BlockContainer container, Graphics2D g2,\n                               double width)","target_class":"","rationale":""},{"method_name":"arrangeRR","method_signature":"protected arrangeRR(BlockContainer container,\n                               Range widthRange, Range heightRange,\n                               Graphics2D g2)","target_class":"","rationale":""},{"method_name":"arrangeFF","method_signature":"protected arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"arrangeFR","method_signature":"protected arrangeFR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)","target_class":"","rationale":""},{"method_name":"arrangeFN","method_signature":"protected arrangeFN(BlockContainer container, Graphics2D g2,\n                               double width)","target_class":"","rationale":""},{"method_name":"arrangeNN","method_signature":"protected arrangeNN(BlockContainer container, Graphics2D g2)","target_class":"","rationale":""},{"method_name":"arrangeFF","method_signature":"protected arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)","target_class":"","rationale":""},{"method_name":"arrangeRR","method_signature":"protected arrangeRR(BlockContainer container,\n                               Range widthRange, Range heightRange,\n                               Graphics2D g2)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"protected arrangeFR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)":{"first":{"method_name":"arrangeFR","method_signature":"protected arrangeFR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)","target_class":"","rationale":""},"second":0.6717679217623276},"protected arrangeFN(BlockContainer container, Graphics2D g2,\n                               double width)":{"first":{"method_name":"arrangeFN","method_signature":"protected arrangeFN(BlockContainer container, Graphics2D g2,\n                               double width)","target_class":"","rationale":""},"second":0.8420438438910937},"protected arrangeNN(BlockContainer container, Graphics2D g2)":{"first":{"method_name":"arrangeNN","method_signature":"protected arrangeNN(BlockContainer container, Graphics2D g2)","target_class":"","rationale":""},"second":0.8596077350055827},"protected arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)":{"first":{"method_name":"arrangeFF","method_signature":"protected arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)","target_class":"","rationale":""},"second":0.8659906937345077},"protected arrangeRR(BlockContainer container,\n                               Range widthRange, Range heightRange,\n                               Graphics2D g2)":{"first":{"method_name":"arrangeRR","method_signature":"protected arrangeRR(BlockContainer container,\n                               Range widthRange, Range heightRange,\n                               Graphics2D g2)","target_class":"","rationale":""},"second":0.8720998823821832}},"targetClassMap":{"arrangeFR":{"target_classes":[{"class_name":"BlockContainer","similarity_score":0.7961161814997734},{"class_name":"RectangleConstraint","similarity_score":0.7753263183953706},{"class_name":"Block","similarity_score":0.72572734458446},{"class_name":"Block","similarity_score":0.72572734458446},{"class_name":"Block","similarity_score":0.72572734458446},{"class_name":"Block","similarity_score":0.72572734458446},{"class_name":"Block","similarity_score":0.72572734458446}],"target_classes_sorted_by_llm":["BlockContainer","Block","RectangleConstraint"],"llm_response_time":8413,"similarity_computation_time":2,"similarity_metric":"cosine"},"arrangeFN":{"target_classes":[{"class_name":"Block","similarity_score":0.3131006042827163},{"class_name":"Block","similarity_score":0.3131006042827163},{"class_name":"Block","similarity_score":0.3131006042827163},{"class_name":"Block","similarity_score":0.3131006042827163},{"class_name":"Block","similarity_score":0.3131006042827163}],"target_classes_sorted_by_llm":["Block","Block","Block"],"llm_response_time":5789,"similarity_computation_time":1,"similarity_metric":"cosine"},"arrangeNN":{"target_classes":[{"class_name":"Block","similarity_score":0.21580219043274368},{"class_name":"Block","similarity_score":0.21580219043274368},{"class_name":"Block","similarity_score":0.21580219043274368},{"class_name":"Block","similarity_score":0.21580219043274368},{"class_name":"Block","similarity_score":0.21580219043274368}],"target_classes_sorted_by_llm":["Block","Block","Block"],"llm_response_time":4461,"similarity_computation_time":1,"similarity_metric":"cosine"},"arrangeFF":{"target_classes":[{"class_name":"Block","similarity_score":0.2594058437470989},{"class_name":"Block","similarity_score":0.2594058437470989},{"class_name":"Block","similarity_score":0.2594058437470989},{"class_name":"Block","similarity_score":0.2594058437470989},{"class_name":"Block","similarity_score":0.2594058437470989}],"target_classes_sorted_by_llm":["Block","Block","Block"],"llm_response_time":3927,"similarity_computation_time":2,"similarity_metric":"cosine"},"arrangeRR":{"target_classes":[{"class_name":"Block","similarity_score":0.2785101960163569},{"class_name":"Block","similarity_score":0.2785101960163569},{"class_name":"Block","similarity_score":0.2785101960163569},{"class_name":"Block","similarity_score":0.2785101960163569},{"class_name":"Block","similarity_score":0.2785101960163569}],"target_classes_sorted_by_llm":["Block","Block","Block"],"llm_response_time":4176,"similarity_computation_time":1,"similarity_metric":"cosine"}}}
{"id":"ec546c8c-dc71-4a6d-a0f1-00a8bcf8cf00","hostFunctionTelemetryData":{"hostFunctionSize":338,"lineStart":47,"lineEnd":384,"bodyLineStart":47,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/block/ColumnArrangement.java","sourceCode":"/**\n * Arranges blocks in a column layout.  This class is immutable.\n */\npublic class ColumnArrangement implements Arrangement, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -5315388482898581555L;\n\n    /** The horizontal alignment of blocks. */\n    private HorizontalAlignment horizontalAlignment;\n\n    /** The vertical alignment of blocks within each row. */\n    private VerticalAlignment verticalAlignment;\n\n    /** The horizontal gap between columns. */\n    private double horizontalGap;\n\n    /** The vertical gap between items in a column. */\n    private double verticalGap;\n\n    /**\n     * Creates a new instance.\n     */\n    public ColumnArrangement() {\n    }\n\n    /**\n     * Creates a new instance.\n     *\n     * @param hAlign  the horizontal alignment (currently ignored).\n     * @param vAlign  the vertical alignment (currently ignored).\n     * @param hGap  the horizontal gap.\n     * @param vGap  the vertical gap.\n     */\n    public ColumnArrangement(HorizontalAlignment hAlign,\n                             VerticalAlignment vAlign,\n                             double hGap, double vGap) {\n        this.horizontalAlignment \u003d hAlign;\n        this.verticalAlignment \u003d vAlign;\n        this.horizontalGap \u003d hGap;\n        this.verticalGap \u003d vGap;\n    }\n\n    /**\n     * Adds a block to be managed by this instance.  This method is usually\n     * called by the {@link BlockContainer}, you shouldn\u0027t need to call it\n     * directly.\n     *\n     * @param block  the block.\n     * @param key  a key that controls the position of the block.\n     */\n    @Override\n    public void add(Block block, Object key) {\n        // since the flow layout is relatively straightforward, no information\n        // needs to be recorded here\n    }\n\n    /**\n     * Calculates and sets the bounds of all the items in the specified\n     * container, subject to the given constraint.  The {@code Graphics2D}\n     * can be used by some items (particularly items containing text) to\n     * calculate sizing parameters.\n     *\n     * @param container  the container whose items are being arranged.\n     * @param g2  the graphics device.\n     * @param constraint  the size constraint.\n     *\n     * @return The size of the container after arrangement of the contents.\n     */\n    @Override\n    public Size2D arrange(BlockContainer container, Graphics2D g2,\n                          RectangleConstraint constraint) {\n\n        LengthConstraintType w \u003d constraint.getWidthConstraintType();\n        LengthConstraintType h \u003d constraint.getHeightConstraintType();\n        if (w \u003d\u003d LengthConstraintType.NONE) {\n            if (h \u003d\u003d LengthConstraintType.NONE) {\n                return arrangeNN(container, g2);\n            }\n            else if (h \u003d\u003d LengthConstraintType.FIXED) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n            else if (h \u003d\u003d LengthConstraintType.RANGE) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n        }\n        else if (w \u003d\u003d LengthConstraintType.FIXED) {\n            if (h \u003d\u003d LengthConstraintType.NONE) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n            else if (h \u003d\u003d LengthConstraintType.FIXED) {\n                return arrangeFF(container, g2, constraint);\n            }\n            else if (h \u003d\u003d LengthConstraintType.RANGE) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n        }\n        else if (w \u003d\u003d LengthConstraintType.RANGE) {\n            if (h \u003d\u003d LengthConstraintType.NONE) {\n                throw new RuntimeException(\"Not implemented.\");\n            }\n            else if (h \u003d\u003d LengthConstraintType.FIXED) {\n                return arrangeRF(container, g2, constraint);\n            }\n            else if (h \u003d\u003d LengthConstraintType.RANGE) {\n                return arrangeRR(container, g2, constraint);\n            }\n        }\n        return new Size2D();  // TODO: complete this\n\n    }\n\n    /**\n     * Calculates and sets the bounds of all the items in the specified\n     * container, subject to the given constraint.  The {@code Graphics2D}\n     * can be used by some items (particularly items containing text) to\n     * calculate sizing parameters.\n     *\n     * @param container  the container whose items are being arranged.\n     * @param g2  the graphics device.\n     * @param constraint  the size constraint.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        // TODO: implement properly\n        return arrangeNF(container, g2, constraint);\n    }\n\n    /**\n     * Calculates and sets the bounds of all the items in the specified\n     * container, subject to the given constraint.  The {@code Graphics2D}\n     * can be used by some items (particularly items containing text) to\n     * calculate sizing parameters.\n     *\n     * @param container  the container whose items are being arranged.\n     * @param constraint  the size constraint.\n     * @param g2  the graphics device.\n     *\n     * @return The container size after the arrangement.\n     */\n    protected Size2D arrangeNF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n\n        List\u003cBlock\u003e blocks \u003d container.getBlocks();\n\n        double height \u003d constraint.getHeight();\n        if (height \u003c\u003d 0.0) {\n            height \u003d Double.POSITIVE_INFINITY;\n        }\n\n        double x \u003d 0.0;\n        double y \u003d 0.0;\n        double maxWidth \u003d 0.0;\n        List\u003cBlock\u003e itemsInColumn \u003d new ArrayList\u003c\u003e();\n        for (Block block : blocks) {\n            Size2D size \u003d block.arrange(g2, RectangleConstraint.NONE);\n            if (y + size.height \u003c\u003d height) {\n                itemsInColumn.add(block);\n                block.setBounds(\n                    new Rectangle2D.Double(x, y, size.width, size.height)\n                );\n                y \u003d y + size.height + this.verticalGap;\n                maxWidth \u003d Math.max(maxWidth, size.width);\n            }\n            else {\n                if (itemsInColumn.isEmpty()) {\n                    // place in this column (truncated) anyway\n                    block.setBounds(\n                        new Rectangle2D.Double(\n                            x, y, size.width, Math.min(size.height, height - y)\n                        )\n                    );\n                    y \u003d 0.0;\n                    x \u003d x + size.width + this.horizontalGap;\n                }\n                else {\n                    // start new column\n                    itemsInColumn.clear();\n                    x \u003d x + maxWidth + this.horizontalGap;\n                    y \u003d 0.0;\n                    maxWidth \u003d size.width;\n                    block.setBounds(\n                        new Rectangle2D.Double(\n                            x, y, size.width, Math.min(size.height, height)\n                        )\n                    );\n                    y \u003d size.height + this.verticalGap;\n                    itemsInColumn.add(block);\n                }\n            }\n        }\n        return new Size2D(x + maxWidth, constraint.getHeight());\n    }\n\n    /**\n     * Arranges a container with range constraints for both the horizontal\n     * and vertical.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     * @param constraint  the constraint.\n     *\n     * @return The size of the container.\n     */\n    protected Size2D arrangeRR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n\n        // first arrange without constraints, and see if this fits within\n        // the required ranges...\n        Size2D s1 \u003d arrangeNN(container, g2);\n        if (constraint.getHeightRange().contains(s1.height)) {\n            return s1;  // TODO: we didn\u0027t check the width yet\n        }\n        else {\n            RectangleConstraint c \u003d constraint.toFixedHeight(\n                constraint.getHeightRange().getUpperBound()\n            );\n            return arrangeRF(container, g2, c);\n        }\n    }\n\n    /**\n     * Arranges the blocks in the container using a fixed height and a\n     * range for the width.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     * @param constraint  the constraint.\n     *\n     * @return The size of the container after arrangement.\n     */\n    protected Size2D arrangeRF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n\n        Size2D s \u003d arrangeNF(container, g2, constraint);\n        if (constraint.getWidthRange().contains(s.width)) {\n            return s;\n        }\n        else {\n            RectangleConstraint c \u003d constraint.toFixedWidth(\n                constraint.getWidthRange().constrain(s.getWidth())\n            );\n            return arrangeFF(container, g2, c);\n        }\n    }\n\n    /**\n     * Arranges the blocks without any constraints.  This puts all blocks\n     * into a single column.\n     *\n     * @param container  the container.\n     * @param g2  the graphics device.\n     *\n     * @return The size after the arrangement.\n     */\n    protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) {\n        double y \u003d 0.0;\n        double height \u003d 0.0;\n        double maxWidth \u003d 0.0;\n        List\u003cBlock\u003e blocks \u003d container.getBlocks();\n        int blockCount \u003d blocks.size();\n        if (blockCount \u003e 0) {\n            Size2D[] sizes \u003d new Size2D[blocks.size()];\n            for (int i \u003d 0; i \u003c blocks.size(); i++) {\n                Block block \u003d blocks.get(i);\n                sizes[i] \u003d block.arrange(g2, RectangleConstraint.NONE);\n                height \u003d height + sizes[i].getHeight();\n                maxWidth \u003d Math.max(sizes[i].width, maxWidth);\n                block.setBounds(\n                    new Rectangle2D.Double(\n                        0.0, y, sizes[i].width, sizes[i].height\n                    )\n                );\n                y \u003d y + sizes[i].height + this.verticalGap;\n            }\n            if (blockCount \u003e 1) {\n                height \u003d height + this.verticalGap * (blockCount - 1);\n            }\n            if (this.horizontalAlignment !\u003d HorizontalAlignment.LEFT) {\n                for (int i \u003d 0; i \u003c blocks.size(); i++) {\n                    //Block b \u003d (Block) blocks.get(i);\n                    if (this.horizontalAlignment\n                            \u003d\u003d HorizontalAlignment.CENTER) {\n                        //TODO: shift block right by half\n                    }\n                    else if (this.horizontalAlignment\n                            \u003d\u003d HorizontalAlignment.RIGHT) {\n                        //TODO: shift block over to right\n                    }\n                }\n            }\n        }\n        return new Size2D(maxWidth, height);\n    }\n\n    /**\n     * Clears any cached information.\n     */\n    @Override\n    public void clear() {\n        // no action required.\n    }\n\n    /**\n     * Tests this instance for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof ColumnArrangement)) {\n            return false;\n        }\n        ColumnArrangement that \u003d (ColumnArrangement) obj;\n        if (this.horizontalAlignment !\u003d that.horizontalAlignment) {\n            return false;\n        }\n        if (this.verticalAlignment !\u003d that.verticalAlignment) {\n            return false;\n        }\n        if (this.horizontalGap !\u003d that.horizontalGap) {\n            return false;\n        }\n        if (this.verticalGap !\u003d that.verticalGap) {\n            return false;\n        }\n        return true;\n    }\n\n\n}","methodCount":11,"staticMethodCount":0,"instanceMethodCount":11,"classLoc":338,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":2,"candidates":[{"lineStart":242,"lineEnd":267,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method arrangeRR to class BlockContainer","description":"Move method arrangeRR to org.jfree.chart.block.BlockContainer\nRationale: The `arrangeRR` method is based on arranging the contents of a `BlockContainer` within a given set of constraints, which is a functionality that is directly related to the responsibility of the `BlockContainer` class. Most of the logic concerning arranging blocks within containers should reside within the `BlockContainer` class to maintain cohesion and follow the single responsibility principle.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Somewhat Unhelpful"},{"lineStart":269,"lineEnd":292,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method arrangeRF to class BlockContainer","description":"Move method arrangeRF to org.jfree.chart.block.BlockContainer\nRationale: The method `arrangeRF` deals explicitly with arranging blocks within a container using given constraints. This is essentially the responsibility of a layout manager or the container itself. The method relies on arranging blocks, checking width constraints, and potentially re-arranging if constraints aren\u0027t met. This logic aligns closely with the core functionality of the `BlockContainer` class, which already manages blocks and uses arrangements. This makes `BlockContainer` the most appropriate location for `arrangeRF` as it directly deals with the blocks and their layouts.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":81744}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":28125},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"arrangeNF","method_signature":"protected arrangeNF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)","target_class":"","rationale":""},{"method_name":"arrangeRR","method_signature":"protected arrangeRR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)","target_class":"","rationale":""},{"method_name":"arrangeRF","method_signature":"protected arrangeRF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)","target_class":"","rationale":""},{"method_name":"arrangeNN","method_signature":"protected arrangeNN(BlockContainer container, Graphics2D g2)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"arrangeNN","method_signature":"protected arrangeNN(BlockContainer container, Graphics2D g2)","target_class":"","rationale":""},{"method_name":"arrangeNF","method_signature":"protected arrangeNF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)","target_class":"","rationale":""},{"method_name":"arrangeRR","method_signature":"protected arrangeRR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)","target_class":"","rationale":""},{"method_name":"arrangeRF","method_signature":"protected arrangeRF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"protected arrangeNN(BlockContainer container, Graphics2D g2)":{"first":{"method_name":"arrangeNN","method_signature":"protected arrangeNN(BlockContainer container, Graphics2D g2)","target_class":"","rationale":""},"second":0.6932557065272781},"protected arrangeNF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)":{"first":{"method_name":"arrangeNF","method_signature":"protected arrangeNF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)","target_class":"","rationale":""},"second":0.7217899568841308},"protected arrangeRR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)":{"first":{"method_name":"arrangeRR","method_signature":"protected arrangeRR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)","target_class":"","rationale":""},"second":0.796141748693793},"protected arrangeRF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)":{"first":{"method_name":"arrangeRF","method_signature":"protected arrangeRF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint)","target_class":"","rationale":""},"second":0.8196455117558615}},"targetClassMap":{"arrangeNN":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":8086,"similarity_computation_time":0,"similarity_metric":"cosine"},"arrangeNF":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5803,"similarity_computation_time":0,"similarity_metric":"cosine"},"arrangeRR":{"target_classes":[{"class_name":"BlockContainer","similarity_score":0.7737191298361277},{"class_name":"RectangleConstraint","similarity_score":0.7296897733403804}],"target_classes_sorted_by_llm":["BlockContainer","RectangleConstraint"],"llm_response_time":4903,"similarity_computation_time":1,"similarity_metric":"cosine"},"arrangeRF":{"target_classes":[{"class_name":"BlockContainer","similarity_score":0.7958954086220725},{"class_name":"RectangleConstraint","similarity_score":0.7635414008526216}],"target_classes_sorted_by_llm":["BlockContainer","RectangleConstraint"],"llm_response_time":9183,"similarity_computation_time":1,"similarity_metric":"cosine"}}}
{"id":"3e9b5f7a-189e-4d0c-ae52-97cbe7f7c1c1","hostFunctionTelemetryData":{"hostFunctionSize":360,"lineStart":62,"lineEnd":421,"bodyLineStart":62,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/block/LabelBlock.java","sourceCode":"/**\n * A block containing a label.\n */\npublic class LabelBlock extends AbstractBlock\n        implements Block, PublicCloneable {\n\n    /** For serialization. */\n    static final long serialVersionUID \u003d 249626098864178017L;\n\n    /**\n     * The text for the label - retained in case the label needs\n     * regenerating (for example, to change the font).\n     */\n    private final String text;\n\n    /** The label. */\n    private TextBlock label;\n\n    /** The font. */\n    private Font font;\n\n    /** The tool tip text (can be {@code null}). */\n    private String toolTipText;\n\n    /** The URL text (can be {@code null}). */\n    private String urlText;\n\n    /** The default color. */\n    public static final Paint DEFAULT_PAINT \u003d Color.BLACK;\n\n    /** The paint. */\n    private transient Paint paint;\n\n    /**\n     * The content alignment point.\n     */\n    private TextBlockAnchor contentAlignmentPoint;\n\n    /**\n     * The anchor point for the text.\n     */\n    private RectangleAnchor textAnchor;\n\n    /**\n     * Creates a new label block.\n     *\n     * @param label  the label ({@code null} not permitted).\n     */\n    public LabelBlock(String label) {\n        this(label, new Font(\"SansSerif\", Font.PLAIN, 10), DEFAULT_PAINT);\n    }\n\n    /**\n     * Creates a new label block.\n     *\n     * @param text  the text for the label ({@code null} not permitted).\n     * @param font  the font ({@code null} not permitted).\n     */\n    public LabelBlock(String text, Font font) {\n        this(text, font, DEFAULT_PAINT);\n    }\n\n    /**\n     * Creates a new label block.\n     *\n     * @param text  the text for the label ({@code null} not permitted).\n     * @param font  the font ({@code null} not permitted).\n     * @param paint the paint ({@code null} not permitted).\n     */\n    public LabelBlock(String text, Font font, Paint paint) {\n        this.text \u003d text;\n        this.paint \u003d paint;\n        this.label \u003d TextUtils.createTextBlock(text, font, this.paint);\n        this.font \u003d font;\n        this.toolTipText \u003d null;\n        this.urlText \u003d null;\n        this.contentAlignmentPoint \u003d TextBlockAnchor.CENTER;\n        this.textAnchor \u003d RectangleAnchor.CENTER;\n    }\n\n    /**\n     * Returns the font.\n     *\n     * @return The font (never {@code null}).\n     *\n     * @see #setFont(Font)\n     */\n    public Font getFont() {\n        return this.font;\n    }\n\n    /**\n     * Sets the font and regenerates the label.\n     *\n     * @param font  the font ({@code null} not permitted).\n     *\n     * @see #getFont()\n     */\n    public void setFont(Font font) {\n        Args.nullNotPermitted(font, \"font\");\n        this.font \u003d font;\n        this.label \u003d TextUtils.createTextBlock(this.text, font, this.paint);\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setPaint(Paint)\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Sets the paint and regenerates the label.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getPaint()\n     */\n    public void setPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.paint \u003d paint;\n        this.label \u003d TextUtils.createTextBlock(this.text, this.font,\n                this.paint);\n    }\n\n    /**\n     * Returns the tool tip text.\n     *\n     * @return The tool tip text (possibly {@code null}).\n     *\n     * @see #setToolTipText(String)\n     */\n    public String getToolTipText() {\n        return this.toolTipText;\n    }\n\n    /**\n     * Sets the tool tip text.\n     *\n     * @param text  the text ({@code null} permitted).\n     *\n     * @see #getToolTipText()\n     */\n    public void setToolTipText(String text) {\n        this.toolTipText \u003d text;\n    }\n\n    /**\n     * Returns the URL text.\n     *\n     * @return The URL text (possibly {@code null}).\n     *\n     * @see #setURLText(String)\n     */\n    public String getURLText() {\n        return this.urlText;\n    }\n\n    /**\n     * Sets the URL text.\n     *\n     * @param text  the text ({@code null} permitted).\n     *\n     * @see #getURLText()\n     */\n    public void setURLText(String text) {\n        this.urlText \u003d text;\n    }\n\n    /**\n     * Returns the content alignment point.\n     *\n     * @return The content alignment point (never {@code null}).\n     */\n    public TextBlockAnchor getContentAlignmentPoint() {\n        return this.contentAlignmentPoint;\n    }\n\n    /**\n     * Sets the content alignment point.\n     *\n     * @param anchor  the anchor used to determine the alignment point (never\n     *         {@code null}).\n     */\n    public void setContentAlignmentPoint(TextBlockAnchor anchor) {\n        Args.nullNotPermitted(anchor, \"anchor\");\n        this.contentAlignmentPoint \u003d anchor;\n    }\n\n    /**\n     * Returns the text anchor (never {@code null}).\n     *\n     * @return The text anchor.\n     */\n    public RectangleAnchor getTextAnchor() {\n        return this.textAnchor;\n    }\n\n    /**\n     * Sets the text anchor.\n     *\n     * @param anchor  the anchor ({@code null} not permitted).\n     */\n    public void setTextAnchor(RectangleAnchor anchor) {\n        this.textAnchor \u003d anchor;\n    }\n\n    /**\n     * Arranges the contents of the block, within the given constraints, and\n     * returns the block size.\n     *\n     * @param g2  the graphics device.\n     * @param constraint  the constraint ({@code null} not permitted).\n     *\n     * @return The block size (in Java2D units, never {@code null}).\n     */\n    @Override\n    public Size2D arrange(Graphics2D g2, RectangleConstraint constraint) {\n        g2.setFont(this.font);\n        Size2D s \u003d this.label.calculateDimensions(g2);\n        return new Size2D(calculateTotalWidth(s.getWidth()),\n                calculateTotalHeight(s.getHeight()));\n    }\n\n    /**\n     * Draws the block.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     */\n    @Override\n    public void draw(Graphics2D g2, Rectangle2D area) {\n        draw(g2, area, null);\n    }\n\n    /**\n     * Draws the block within the specified area.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     * @param params  ignored ({@code null} permitted).\n     *\n     * @return Always {@code null}.\n     */\n    @Override\n    public Object draw(Graphics2D g2, Rectangle2D area, Object params) {\n        area \u003d trimMargin(area);\n        drawBorder(g2, area);\n        area \u003d trimBorder(area);\n        area \u003d trimPadding(area);\n\n        // check if we need to collect chart entities from the container\n        EntityBlockParams ebp \u003d null;\n        StandardEntityCollection sec \u003d null;\n        Shape entityArea \u003d null;\n        if (params instanceof EntityBlockParams) {\n            ebp \u003d (EntityBlockParams) params;\n            if (ebp.getGenerateEntities()) {\n                sec \u003d new StandardEntityCollection();\n                entityArea \u003d (Shape) area.clone();\n            }\n        }\n        g2.setPaint(this.paint);\n        g2.setFont(this.font);\n        Point2D pt \u003d this.textAnchor.getAnchorPoint(area);\n        this.label.draw(g2, (float) pt.getX(), (float) pt.getY(),\n                this.contentAlignmentPoint);\n        BlockResult result \u003d null;\n        if (ebp !\u003d null \u0026\u0026 sec !\u003d null) {\n            if (this.toolTipText !\u003d null || this.urlText !\u003d null) {\n                ChartEntity entity \u003d new ChartEntity(entityArea,\n                        this.toolTipText, this.urlText);\n                sec.add(entity);\n                result \u003d new BlockResult();\n                result.setEntityCollection(sec);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Tests this {@code LabelBlock} for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (!(obj instanceof LabelBlock)) {\n            return false;\n        }\n        LabelBlock that \u003d (LabelBlock) obj;\n        if (!this.text.equals(that.text)) {\n            return false;\n        }\n        if (!this.font.equals(that.font)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.paint, that.paint)) {\n            return false;\n        }\n        if (!Objects.equals(this.toolTipText, that.toolTipText)) {\n            return false;\n        }\n        if (!Objects.equals(this.urlText, that.urlText)) {\n            return false;\n        }\n        if (!this.contentAlignmentPoint.equals(that.contentAlignmentPoint)) {\n            return false;\n        }\n        if (!this.textAnchor.equals(that.textAnchor)) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a clone of this {@code LabelBlock} instance.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if there is a problem cloning.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writePaint(this.paint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.paint \u003d SerialUtils.readPaint(stream);\n    }\n\n}","methodCount":22,"staticMethodCount":0,"instanceMethodCount":22,"classLoc":360,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"207ab4b1-9a10-4d6b-95d5-5b983af436e0","hostFunctionTelemetryData":{"hostFunctionSize":309,"lineStart":42,"lineEnd":350,"bodyLineStart":42,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/block/RectangleConstraint.java","sourceCode":"/**\n * A description of a constraint for resizing a rectangle.  Constraints are\n * immutable.\n */\npublic class RectangleConstraint {\n\n    /**\n     * An instance representing no constraint.\n     */\n    public static final RectangleConstraint NONE \u003d new RectangleConstraint(\n            0.0, null, LengthConstraintType.NONE,\n            0.0, null, LengthConstraintType.NONE);\n\n    /** The width. */\n    private final double width;\n\n    /** The width range. */\n    private final Range widthRange;\n\n    /** The width constraint type. */\n    private final LengthConstraintType widthConstraintType;\n\n    /** The fixed or maximum height. */\n    private final double height;\n\n    private final Range heightRange;\n\n    /** The constraint type. */\n    private final LengthConstraintType heightConstraintType;\n\n    /**\n     * Creates a new \"fixed width and height\" instance.\n     *\n     * @param w  the fixed width.\n     * @param h  the fixed height.\n     */\n    public RectangleConstraint(double w, double h) {\n        this(w, null, LengthConstraintType.FIXED,\n                h, null, LengthConstraintType.FIXED);\n    }\n\n    /**\n     * Creates a new \"range width and height\" instance.\n     *\n     * @param w  the width range.\n     * @param h  the height range.\n     */\n    public RectangleConstraint(Range w, Range h) {\n        this(0.0, w, LengthConstraintType.RANGE,\n                0.0, h, LengthConstraintType.RANGE);\n    }\n\n    /**\n     * Creates a new constraint with a range for the width and a\n     * fixed height.\n     *\n     * @param w  the width range.\n     * @param h  the fixed height.\n     */\n    public RectangleConstraint(Range w, double h) {\n        this(0.0, w, LengthConstraintType.RANGE,\n                h, null, LengthConstraintType.FIXED);\n    }\n\n    /**\n     * Creates a new constraint with a fixed width and a range for\n     * the height.\n     *\n     * @param w  the fixed width.\n     * @param h  the height range.\n     */\n    public RectangleConstraint(double w, Range h) {\n        this(w, null, LengthConstraintType.FIXED,\n                0.0, h, LengthConstraintType.RANGE);\n    }\n\n    /**\n     * Creates a new constraint.\n     *\n     * @param w  the fixed or maximum width.\n     * @param widthRange  the width range.\n     * @param widthConstraintType  the width type.\n     * @param h  the fixed or maximum height.\n     * @param heightRange  the height range.\n     * @param heightConstraintType  the height type.\n     */\n    public RectangleConstraint(double w, Range widthRange,\n                               LengthConstraintType widthConstraintType,\n                               double h, Range heightRange,\n                               LengthConstraintType heightConstraintType) {\n        Args.nullNotPermitted(widthConstraintType, \"widthConstraintType\");\n        Args.nullNotPermitted(heightConstraintType, \"heightConstraintType\");\n        this.width \u003d w;\n        this.widthRange \u003d widthRange;\n        this.widthConstraintType \u003d widthConstraintType;\n        this.height \u003d h;\n        this.heightRange \u003d heightRange;\n        this.heightConstraintType \u003d heightConstraintType;\n    }\n\n    /**\n     * Returns the fixed width.\n     *\n     * @return The width.\n     */\n    public double getWidth() {\n        return this.width;\n    }\n\n    /**\n     * Returns the width range.\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public Range getWidthRange() {\n        return this.widthRange;\n    }\n\n    /**\n     * Returns the constraint type.\n     *\n     * @return The constraint type (never {@code null}).\n     */\n    public LengthConstraintType getWidthConstraintType() {\n        return this.widthConstraintType;\n    }\n\n    /**\n     * Returns the fixed height.\n     *\n     * @return The height.\n     */\n    public double getHeight() {\n        return this.height;\n    }\n\n    /**\n     * Returns the width range.\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public Range getHeightRange() {\n        return this.heightRange;\n    }\n\n    /**\n     * Returns the constraint type.\n     *\n     * @return The constraint type (never {@code null}).\n     */\n    public LengthConstraintType getHeightConstraintType() {\n        return this.heightConstraintType;\n    }\n\n    /**\n     * Returns a constraint that matches this one on the height attributes,\n     * but has no width constraint.\n     *\n     * @return A new constraint.\n     */\n    public RectangleConstraint toUnconstrainedWidth() {\n        if (this.widthConstraintType \u003d\u003d LengthConstraintType.NONE) {\n            return this;\n        }\n        else {\n            return new RectangleConstraint(this.width, this.widthRange,\n                    LengthConstraintType.NONE, this.height, this.heightRange,\n                    this.heightConstraintType);\n        }\n    }\n\n    /**\n     * Returns a constraint that matches this one on the width attributes,\n     * but has no height constraint.\n     *\n     * @return A new constraint.\n     */\n    public RectangleConstraint toUnconstrainedHeight() {\n        if (this.heightConstraintType \u003d\u003d LengthConstraintType.NONE) {\n            return this;\n        }\n        else {\n            return new RectangleConstraint(this.width, this.widthRange,\n                    this.widthConstraintType, 0.0, this.heightRange,\n                    LengthConstraintType.NONE);\n        }\n    }\n\n    /**\n     * Returns a constraint that matches this one on the height attributes,\n     * but has a fixed width constraint.\n     *\n     * @param width  the fixed width.\n     *\n     * @return A new constraint.\n     */\n    public RectangleConstraint toFixedWidth(double width) {\n        return new RectangleConstraint(width, this.widthRange,\n                LengthConstraintType.FIXED, this.height, this.heightRange,\n                this.heightConstraintType);\n    }\n\n    /**\n     * Returns a constraint that matches this one on the width attributes,\n     * but has a fixed height constraint.\n     *\n     * @param height  the fixed height.\n     *\n     * @return A new constraint.\n     */\n    public RectangleConstraint toFixedHeight(double height) {\n        return new RectangleConstraint(this.width, this.widthRange,\n                this.widthConstraintType, height, this.heightRange,\n                LengthConstraintType.FIXED);\n    }\n\n    /**\n     * Returns a constraint that matches this one on the height attributes,\n     * but has a range width constraint.\n     *\n     * @param range  the width range ({@code null} not permitted).\n     *\n     * @return A new constraint.\n     */\n    public RectangleConstraint toRangeWidth(Range range) {\n        Args.nullNotPermitted(range, \"range\");\n        return new RectangleConstraint(range.getUpperBound(), range,\n                LengthConstraintType.RANGE, this.height, this.heightRange,\n                this.heightConstraintType);\n    }\n\n    /**\n     * Returns a constraint that matches this one on the width attributes,\n     * but has a range height constraint.\n     *\n     * @param range  the height range ({@code null} not permitted).\n     *\n     * @return A new constraint.\n     */\n    public RectangleConstraint toRangeHeight(Range range) {\n        Args.nullNotPermitted(range, \"range\");\n        return new RectangleConstraint(this.width, this.widthRange,\n                this.widthConstraintType, range.getUpperBound(), range,\n                LengthConstraintType.RANGE);\n    }\n\n    /**\n     * Returns a string representation of this instance, mostly used for\n     * debugging purposes.\n     *\n     * @return A string.\n     */\n    @Override\n    public String toString() {\n        return \"RectangleConstraint[\"\n                + this.widthConstraintType.toString() + \": width\u003d\"\n                + this.width + \", height\u003d\" + this.height + \"]\";\n    }\n\n    /**\n     * Returns the new size that reflects the constraints defined by this\n     * instance.\n     *\n     * @param base  the base size.\n     *\n     * @return The constrained size.\n     */\n    public Size2D calculateConstrainedSize(Size2D base) {\n        Size2D result \u003d new Size2D();\n        if (this.widthConstraintType \u003d\u003d LengthConstraintType.NONE) {\n            result.width \u003d base.width;\n            if (this.heightConstraintType \u003d\u003d LengthConstraintType.NONE) {\n               result.height \u003d base.height;\n            }\n            else if (this.heightConstraintType \u003d\u003d LengthConstraintType.RANGE) {\n               result.height \u003d this.heightRange.constrain(base.height);\n            }\n            else if (this.heightConstraintType \u003d\u003d LengthConstraintType.FIXED) {\n               result.height \u003d this.height;\n            }\n        }\n        else if (this.widthConstraintType \u003d\u003d LengthConstraintType.RANGE) {\n            result.width \u003d this.widthRange.constrain(base.width);\n            if (this.heightConstraintType \u003d\u003d LengthConstraintType.NONE) {\n                result.height \u003d base.height;\n            }\n            else if (this.heightConstraintType \u003d\u003d LengthConstraintType.RANGE) {\n                result.height \u003d this.heightRange.constrain(base.height);\n            }\n            else if (this.heightConstraintType \u003d\u003d LengthConstraintType.FIXED) {\n                result.height \u003d this.height;\n            }\n        }\n        else if (this.widthConstraintType \u003d\u003d LengthConstraintType.FIXED) {\n            result.width \u003d this.width;\n            if (this.heightConstraintType \u003d\u003d LengthConstraintType.NONE) {\n                result.height \u003d base.height;\n            }\n            else if (this.heightConstraintType \u003d\u003d LengthConstraintType.RANGE) {\n                result.height \u003d this.heightRange.constrain(base.height);\n            }\n            else if (this.heightConstraintType \u003d\u003d LengthConstraintType.FIXED) {\n                result.height \u003d this.height;\n            }\n        }\n        return result;\n    }\n\n}","methodCount":19,"staticMethodCount":0,"instanceMethodCount":19,"classLoc":309,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":23472},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"toRangeWidth","method_signature":"public toRangeWidth(Range range)","target_class":"","rationale":""},{"method_name":"toRangeHeight","method_signature":"public toRangeHeight(Range range)","target_class":"","rationale":""},{"method_name":"calculateConstrainedSize","method_signature":"public calculateConstrainedSize(Size2D base)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"calculateConstrainedSize","method_signature":"public calculateConstrainedSize(Size2D base)","target_class":"","rationale":""},{"method_name":"toRangeHeight","method_signature":"public toRangeHeight(Range range)","target_class":"","rationale":""},{"method_name":"toRangeWidth","method_signature":"public toRangeWidth(Range range)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public calculateConstrainedSize(Size2D base)":{"first":{"method_name":"calculateConstrainedSize","method_signature":"public calculateConstrainedSize(Size2D base)","target_class":"","rationale":""},"second":0.3638755429950839},"public toRangeHeight(Range range)":{"first":{"method_name":"toRangeHeight","method_signature":"public toRangeHeight(Range range)","target_class":"","rationale":""},"second":0.7838114321759517},"public toRangeWidth(Range range)":{"first":{"method_name":"toRangeWidth","method_signature":"public toRangeWidth(Range range)","target_class":"","rationale":""},"second":0.7891165061000356}},"targetClassMap":{"calculateConstrainedSize":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5507,"similarity_computation_time":0,"similarity_metric":"cosine"},"toRangeHeight":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":8476,"similarity_computation_time":0,"similarity_metric":"cosine"},"toRangeWidth":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":9315,"similarity_computation_time":0,"similarity_metric":"cosine"}}}
{"id":"c1b80f1e-7ac4-4233-b071-bc9b34971cc0","hostFunctionTelemetryData":{"hostFunctionSize":345,"lineStart":57,"lineEnd":401,"bodyLineStart":57,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/entity/ChartEntity.java","sourceCode":"/**\n * A class that captures information about some component of a chart (a bar,\n * line etc).\n */\npublic class ChartEntity implements Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -4445994133561919083L;\n\n    /** The area occupied by the entity (in Java 2D space). */\n    private transient Shape area;\n\n    /** The tool tip text for the entity. */\n    private String toolTipText;\n\n    /** The URL text for the entity. */\n    private String urlText;\n\n    /**\n     * Creates a new chart entity.\n     *\n     * @param area  the area ({@code null} not permitted).\n     */\n    public ChartEntity(Shape area) {\n        // defer argument checks...\n        this(area, null);\n    }\n\n    /**\n     * Creates a new chart entity.\n     *\n     * @param area  the area ({@code null} not permitted).\n     * @param toolTipText  the tool tip text ({@code null} permitted).\n     */\n    public ChartEntity(Shape area, String toolTipText) {\n        // defer argument checks...\n        this(area, toolTipText, null);\n    }\n\n    /**\n     * Creates a new entity.\n     *\n     * @param area  the area ({@code null} not permitted).\n     * @param toolTipText  the tool tip text ({@code null} permitted).\n     * @param urlText  the URL text for HTML image maps ({@code null}\n     *                 permitted).\n     */\n    public ChartEntity(Shape area, String toolTipText, String urlText) {\n        Args.nullNotPermitted(area, \"area\");\n        this.area \u003d area;\n        this.toolTipText \u003d toolTipText;\n        this.urlText \u003d urlText;\n    }\n\n    /**\n     * Returns the area occupied by the entity (in Java 2D space).\n     *\n     * @return The area (never {@code null}).\n     */\n    public Shape getArea() {\n        return this.area;\n    }\n\n    /**\n     * Sets the area for the entity.\n     * \u003cP\u003e\n     * This class conveys information about chart entities back to a client.\n     * Setting this area doesn\u0027t change the entity (which has already been\n     * drawn).\n     *\n     * @param area  the area ({@code null} not permitted).\n     */\n    public void setArea(Shape area) {\n        Args.nullNotPermitted(area, \"area\");\n        this.area \u003d area;\n    }\n\n    /**\n     * Returns the tool tip text for the entity.  Be aware that this text\n     * may have been generated from user supplied data, so for security\n     * reasons some form of filtering should be applied before incorporating\n     * this text into any HTML output.\n     *\n     * @return The tool tip text (possibly {@code null}).\n     */\n    public String getToolTipText() {\n        return this.toolTipText;\n    }\n\n    /**\n     * Sets the tool tip text.\n     *\n     * @param text  the text ({@code null} permitted).\n     */\n    public void setToolTipText(String text) {\n        this.toolTipText \u003d text;\n    }\n\n    /**\n     * Returns the URL text for the entity.  Be aware that this text\n     * may have been generated from user supplied data, so some form of\n     * filtering should be applied before this \"URL\" is used in any output.\n     *\n     * @return The URL text (possibly {@code null}).\n     */\n    public String getURLText() {\n        return this.urlText;\n    }\n\n    /**\n     * Sets the URL text.\n     *\n     * @param text the text ({@code null} permitted).\n     */\n    public void setURLText(String text) {\n        this.urlText \u003d text;\n    }\n\n    /**\n     * Returns a string describing the entity area.  This string is intended\n     * for use in an AREA tag when generating an image map.\n     *\n     * @return The shape type (never {@code null}).\n     */\n    public String getShapeType() {\n        if (this.area instanceof Rectangle2D) {\n            return \"rect\";\n        }\n        else {\n            return \"poly\";\n        }\n    }\n\n    /**\n     * Returns the shape coordinates as a string.\n     *\n     * @return The shape coordinates (never {@code null}).\n     */\n    public String getShapeCoords() {\n        if (this.area instanceof Rectangle2D) {\n            return getRectCoords((Rectangle2D) this.area);\n        }\n        else {\n            return getPolyCoords(this.area);\n        }\n    }\n\n    /**\n     * Returns a string containing the coordinates (x1, y1, x2, y2) for a given\n     * rectangle.  This string is intended for use in an image map.\n     *\n     * @param rectangle  the rectangle ({@code null} not permitted).\n     *\n     * @return Upper left and lower right corner of a rectangle.\n     */\n    private String getRectCoords(Rectangle2D rectangle) {\n        Args.nullNotPermitted(rectangle, \"rectangle\");\n        int x1 \u003d (int) rectangle.getX();\n        int y1 \u003d (int) rectangle.getY();\n        int x2 \u003d x1 + (int) rectangle.getWidth();\n        int y2 \u003d y1 + (int) rectangle.getHeight();\n        //      fix by rfuller\n        if (x2 \u003d\u003d x1) {\n            x2++;\n        }\n        if (y2 \u003d\u003d y1) {\n            y2++;\n        }\n        //      end fix by rfuller\n        return x1 + \",\" + y1 + \",\" + x2 + \",\" + y2;\n    }\n\n    /**\n     * Returns a string containing the coordinates for a given shape.  This\n     * string is intended for use in an image map.\n     *\n     * @param shape  the shape ({@code null} not permitted).\n     *\n     * @return The coordinates for a given shape as string.\n     */\n    private String getPolyCoords(Shape shape) {\n        Args.nullNotPermitted(shape, \"shape\");\n        StringBuilder result \u003d new StringBuilder();\n        boolean first \u003d true;\n        float[] coords \u003d new float[6];\n        PathIterator pi \u003d shape.getPathIterator(null, 1.0);\n        while (!pi.isDone()) {\n            pi.currentSegment(coords);\n            if (first) {\n                first \u003d false;\n                result.append((int) coords[0]);\n                result.append(\",\").append((int) coords[1]);\n            }\n            else {\n                result.append(\",\");\n                result.append((int) coords[0]);\n                result.append(\",\");\n                result.append((int) coords[1]);\n            }\n            pi.next();\n        }\n        return result.toString();\n    }\n\n    /**\n     * Returns an HTML image map tag for this entity.  The returned fragment\n     * should be {@code XHTML 1.0} compliant.\n     *\n     * @param toolTipTagFragmentGenerator  a generator for the HTML fragment\n     *     that will contain the tooltip text ({@code null} not permitted\n     *     if this entity contains tooltip information).\n     * @param urlTagFragmentGenerator  a generator for the HTML fragment that\n     *     will contain the URL reference ({@code null} not permitted if\n     *     this entity has a URL).\n     *\n     * @return The HTML tag.\n     */\n    public String getImageMapAreaTag(\n            ToolTipTagFragmentGenerator toolTipTagFragmentGenerator,\n            URLTagFragmentGenerator urlTagFragmentGenerator) {\n\n        StringBuilder tag \u003d new StringBuilder();\n        boolean hasURL \u003d (this.urlText \u003d\u003d null ? false\n                : !this.urlText.equals(\"\"));\n        boolean hasToolTip \u003d (this.toolTipText \u003d\u003d null ? false\n                : !this.toolTipText.equals(\"\"));\n        if (hasURL || hasToolTip) {\n            tag.append(\"\u003carea shape\u003d\\\"\").append(getShapeType()).append(\"\\\"\")\n                    .append(\" coords\u003d\\\"\").append(getShapeCoords()).append(\"\\\"\");\n            if (hasToolTip) {\n                tag.append(toolTipTagFragmentGenerator.generateToolTipFragment(\n                        this.toolTipText));\n            }\n            if (hasURL) {\n                tag.append(urlTagFragmentGenerator.generateURLFragment(\n                        this.urlText));\n            }\n            else {\n                tag.append(\" nohref\u003d\\\"nohref\\\"\");\n            }\n            // if there is a tool tip, we expect it to generate the title and\n            // alt values, so we only add an empty alt if there is no tooltip\n            if (!hasToolTip) {\n                tag.append(\" alt\u003d\\\"\\\"\");\n            }\n            tag.append(\"/\u003e\");\n        }\n        return tag.toString();\n    }\n\n    /**\n     * Returns a string representation of the chart entity, useful for\n     * debugging.\n     *\n     * @return A string.\n     */\n    @Override\n    public String toString() {\n        StringBuilder sb \u003d new StringBuilder(\"ChartEntity: \");\n        sb.append(\"tooltip \u003d \");\n        sb.append(this.toolTipText);\n        return sb.toString();\n    }\n\n    /**\n     * Tests the entity for equality with an arbitrary object.\n     *\n     * @param obj  the object to test against ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof ChartEntity)) {\n            return false;\n        }\n        ChartEntity that \u003d (ChartEntity) obj;\n        if (!this.area.equals(that.area)) {\n            return false;\n        }\n        if (!Objects.equals(this.toolTipText, that.toolTipText)) {\n            return false;\n        }\n        if (!Objects.equals(this.urlText, that.urlText)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this instance.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d 37;\n        result \u003d HashUtils.hashCode(result, this.toolTipText);\n        result \u003d HashUtils.hashCode(result, this.urlText);\n        return result;\n    }\n\n    /**\n     * Returns a clone of the entity.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if there is a problem cloning the\n     *         entity.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writeShape(this.area, stream);\n     }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.area \u003d SerialUtils.readShape(stream);\n    }\n\n}","methodCount":20,"staticMethodCount":0,"instanceMethodCount":20,"classLoc":345,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":1,"candidates":[{"lineStart":260,"lineEnd":304,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method getImageMapAreaTag to class ToolTipTagFragmentGenerator","description":"Move method getImageMapAreaTag to org.jfree.chart.imagemap.ToolTipTagFragmentGenerator\nRationale: The method getImageMapAreaTag heavily relies on generating HTML fragments for the tooltip and partially for the URL. While the full method deals with constructing an HTML map area tag, the primary focus seems to be on correctly generating tooltips, as evidenced by the complexity and checks around this functionality. Moving this method to ToolTipTagFragmentGenerator would centralize the tooltip generation logic, ensuring that it is managed by the class responsible for handling tooltip generation.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Unhelpful"}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":119926}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":3706},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"getImageMapAreaTag","method_signature":"public getImageMapAreaTag(\n            ToolTipTagFragmentGenerator toolTipTagFragmentGenerator,\n            URLTagFragmentGenerator urlTagFragmentGenerator)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"getImageMapAreaTag","method_signature":"public getImageMapAreaTag(\n            ToolTipTagFragmentGenerator toolTipTagFragmentGenerator,\n            URLTagFragmentGenerator urlTagFragmentGenerator)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public getImageMapAreaTag(\n            ToolTipTagFragmentGenerator toolTipTagFragmentGenerator,\n            URLTagFragmentGenerator urlTagFragmentGenerator)":{"first":{"method_name":"getImageMapAreaTag","method_signature":"public getImageMapAreaTag(\n            ToolTipTagFragmentGenerator toolTipTagFragmentGenerator,\n            URLTagFragmentGenerator urlTagFragmentGenerator)","target_class":"","rationale":""},"second":0.7443622015220257}},"targetClassMap":{"getImageMapAreaTag":{"target_classes":[{"class_name":"ToolTipTagFragmentGenerator","similarity_score":0.6316695488364368},{"class_name":"URLTagFragmentGenerator","similarity_score":0.604824374344943}],"target_classes_sorted_by_llm":["ToolTipTagFragmentGenerator","URLTagFragmentGenerator"],"llm_response_time":3659,"similarity_computation_time":2,"similarity_metric":"cosine"}}}
{"id":"c53a7e39-9c89-4191-aca3-ee1aeb923dda","hostFunctionTelemetryData":{"hostFunctionSize":23,"lineStart":43,"lineEnd":65,"bodyLineStart":43,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/imagemap/ToolTipTagFragmentGenerator.java","sourceCode":"/**\n * Interface for generating the tooltip fragment of an HTML image map area tag.\n * The fragment should be {@code XHTML 1.0} compliant.\n */\npublic interface ToolTipTagFragmentGenerator {\n\n    /**\n     * Generates a tooltip string to go in an HTML image map.  To allow for\n     * varying standards compliance among browsers, this method is expected\n     * to return an \u0027alt\u0027 attribute IN ADDITION TO whatever it does to create\n     * the tooltip (often a \u0027title\u0027 attribute).\n     * \u003cbr\u003e\u003cbr\u003e\n     * Note that the {@code toolTipText} may have been generated from\n     * user-defined data, so care should be taken to filter/escape any\n     * characters that may corrupt the HTML tag.\n     *\n     * @param toolTipText  the tooltip.\n     *\n     * @return The formatted HTML area tag attribute(s).\n     */\n    String generateToolTipFragment(String toolTipText);\n\n}","methodCount":1,"staticMethodCount":0,"instanceMethodCount":1,"classLoc":23,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"8a23bd48-b5fd-4d2a-bf46-a8c9d3c847bb","hostFunctionTelemetryData":{"hostFunctionSize":207,"lineStart":52,"lineEnd":258,"bodyLineStart":52,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/block/BlockContainer.java","sourceCode":"/**\n * A container for a collection of {@link Block} objects.  The container uses\n * an {@link Arrangement} object to handle the position of each block.\n */\npublic class BlockContainer extends AbstractBlock\n        implements Block, Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d 8199508075695195293L;\n\n    /** The blocks within the container. */\n    private final List\u003cBlock\u003e blocks;\n\n    /** The object responsible for laying out the blocks. */\n    public Arrangement arrangement;\n\n    /**\n     * Creates a new instance with default settings.\n     */\n    public BlockContainer() {\n        this(new BorderArrangement());\n    }\n\n    /**\n     * Creates a new instance with the specified arrangement.\n     *\n     * @param arrangement  the arrangement manager ({@code null} not\n     *                     permitted).\n     */\n    public BlockContainer(Arrangement arrangement) {\n        Args.nullNotPermitted(arrangement, \"arrangement\");\n        this.arrangement \u003d arrangement;\n        this.blocks \u003d new ArrayList\u003c\u003e();\n    }\n\n    /**\n     * Returns the arrangement (layout) manager for the container.\n     *\n     * @return The arrangement manager (never {@code null}).\n     */\n    public Arrangement getArrangement() {\n        return this.arrangement;\n    }\n\n    /**\n     * Sets the arrangement (layout) manager.\n     *\n     * @param arrangement  the arrangement ({@code null} not permitted).\n     */\n    public void setArrangement(Arrangement arrangement) {\n        Args.nullNotPermitted(arrangement, \"arrangement\");\n        this.arrangement \u003d arrangement;\n    }\n\n    /**\n     * Returns {@code true} if there are no blocks in the container, and\n     * {@code false} otherwise.\n     *\n     * @return A boolean.\n     */\n    public boolean isEmpty() {\n        return this.blocks.isEmpty();\n    }\n\n    /**\n     * Returns an unmodifiable list of the {@link Block} objects managed by\n     * this arrangement.\n     *\n     * @return A list of blocks (possibly empty, but never {@code null}).\n     */\n    public List\u003cBlock\u003e getBlocks() {\n        return Collections.unmodifiableList(this.blocks);\n    }\n\n    /**\n     * Adds a block to the container.\n     *\n     * @param block  the block ({@code null} permitted).\n     */\n    public void add(Block block) {\n        arrangement.add(block, null, this);\n    }\n\n    /**\n     * Arranges the contents of the block, within the given constraints, and\n     * returns the block size.\n     *\n     * @param g2  the graphics device.\n     * @param constraint  the constraint ({@code null} not permitted).\n     *\n     * @return The block size (in Java2D units, never {@code null}).\n     */\n    @Override\n    public Size2D arrange(Graphics2D g2, RectangleConstraint constraint) {\n        return this.arrangement.arrange(this, g2, constraint);\n    }\n\n    /**\n     * Draws the container and all the blocks within it.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     */\n    @Override\n    public void draw(Graphics2D g2, Rectangle2D area) {\n        draw(g2, area, null);\n    }\n\n    /**\n     * Draws the block within the specified area.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     * @param params  passed on to blocks within the container\n     *                ({@code null} permitted).\n     *\n     * @return An instance of {@link EntityBlockResult}, or {@code null}.\n     */\n    @Override\n    public Object draw(Graphics2D g2, Rectangle2D area, Object params) {\n        // check if we need to collect chart entities from the container\n        EntityBlockParams ebp;\n        StandardEntityCollection sec \u003d null;\n        if (params instanceof EntityBlockParams) {\n            ebp \u003d (EntityBlockParams) params;\n            if (ebp.getGenerateEntities()) {\n                sec \u003d new StandardEntityCollection();\n            }\n        }\n        Rectangle2D contentArea \u003d (Rectangle2D) area.clone();\n        contentArea \u003d trimMargin(contentArea);\n        drawBorder(g2, contentArea);\n        contentArea \u003d trimBorder(contentArea);\n        contentArea \u003d trimPadding(contentArea);\n        for (Block block : this.blocks) {\n            Rectangle2D bounds \u003d block.getBounds();\n            Rectangle2D drawArea \u003d new Rectangle2D.Double(bounds.getX()\n                    + area.getX(), bounds.getY() + area.getY(),\n                    bounds.getWidth(), bounds.getHeight());\n            Object r \u003d block.draw(g2, drawArea, params);\n            if (sec !\u003d null) {\n                if (r instanceof EntityBlockResult) {\n                    EntityBlockResult ebr \u003d (EntityBlockResult) r;\n                    EntityCollection ec \u003d ebr.getEntityCollection();\n                    sec.addAll(ec);\n                }\n            }\n        }\n        BlockResult result \u003d null;\n        if (sec !\u003d null) {\n            result \u003d new BlockResult();\n            result.setEntityCollection(sec);\n        }\n        return result;\n    }\n\n    /**\n     * Tests this container for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof BlockContainer)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        BlockContainer that \u003d (BlockContainer) obj;\n        if (!this.arrangement.equals(that.arrangement)) {\n            return false;\n        }\n        if (!this.blocks.equals(that.blocks)) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode(){\n        int hash \u003d 3;\n        hash \u003d 97 * hash + Objects.hashCode(this.blocks);\n        hash \u003d 97 * hash + Objects.hashCode(this.arrangement);\n        return hash;\n    }\n\n    /**\n     * Returns a clone of the container.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if there is a problem cloning.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        BlockContainer clone \u003d (BlockContainer) super.clone();\n        // TODO : complete this\n        return clone;\n    }\n\n}","methodCount":13,"staticMethodCount":0,"instanceMethodCount":13,"classLoc":207,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":1,"candidates":[{"lineStart":125,"lineEnd":132,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method add to class Arrangement","description":"Move method add to org.jfree.chart.block.Arrangement\nRationale: The method `add(Block block)` relies heavily on the Arrangement class, specifically on its `add(Block block, Object key, BlockContainer blockContainer)` method. The logic of adding a block to a container seems to be a fundamental part of the Arrangement class\u0027s responsibility, which makes it more appropriate for the method to reside within this class. Moving the method to the Arrangement class will help in maintaining the single responsibility principle by keeping block arrangement logic encapsulated within the Arrangement class.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false,"userRating":"Very Helpful"}]},"userSelectionTelemetryData":{"lineStart":125,"lineEnd":132,"functionSize":8,"positionInHostFunction":73,"selectedCandidateIndex":0,"candidateType":"AS_IS","elementsType":[{"elementType":"METHOD","quantity":1}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":34476}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":4223},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"add","method_signature":"public add(Block block)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"add","method_signature":"public add(Block block)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public add(Block block)":{"first":{"method_name":"add","method_signature":"public add(Block block)","target_class":"","rationale":""},"second":0.651610454111124}},"targetClassMap":{"add":{"target_classes":[{"class_name":"Arrangement","similarity_score":0.7580000326698021}],"target_classes_sorted_by_llm":["Arrangement"],"llm_response_time":3933,"similarity_computation_time":0,"similarity_metric":"cosine"}}}
{"id":"58011a99-9759-4d10-abe4-dadf7281d9df","hostFunctionTelemetryData":{"hostFunctionSize":345,"lineStart":57,"lineEnd":401,"bodyLineStart":57,"language":"java","filePath":"C:/Users/khush/IdeaProjects/jfreechart/src/main/java/org/jfree/chart/entity/ChartEntity.java","sourceCode":"/**\n * A class that captures information about some component of a chart (a bar,\n * line etc).\n */\npublic class ChartEntity implements Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -4445994133561919083L;\n\n    /** The area occupied by the entity (in Java 2D space). */\n    private transient Shape area;\n\n    /** The tool tip text for the entity. */\n    private String toolTipText;\n\n    /** The URL text for the entity. */\n    private String urlText;\n\n    /**\n     * Creates a new chart entity.\n     *\n     * @param area  the area ({@code null} not permitted).\n     */\n    public ChartEntity(Shape area) {\n        // defer argument checks...\n        this(area, null);\n    }\n\n    /**\n     * Creates a new chart entity.\n     *\n     * @param area  the area ({@code null} not permitted).\n     * @param toolTipText  the tool tip text ({@code null} permitted).\n     */\n    public ChartEntity(Shape area, String toolTipText) {\n        // defer argument checks...\n        this(area, toolTipText, null);\n    }\n\n    /**\n     * Creates a new entity.\n     *\n     * @param area  the area ({@code null} not permitted).\n     * @param toolTipText  the tool tip text ({@code null} permitted).\n     * @param urlText  the URL text for HTML image maps ({@code null}\n     *                 permitted).\n     */\n    public ChartEntity(Shape area, String toolTipText, String urlText) {\n        Args.nullNotPermitted(area, \"area\");\n        this.area \u003d area;\n        this.toolTipText \u003d toolTipText;\n        this.urlText \u003d urlText;\n    }\n\n    /**\n     * Returns the area occupied by the entity (in Java 2D space).\n     *\n     * @return The area (never {@code null}).\n     */\n    public Shape getArea() {\n        return this.area;\n    }\n\n    /**\n     * Sets the area for the entity.\n     * \u003cP\u003e\n     * This class conveys information about chart entities back to a client.\n     * Setting this area doesn\u0027t change the entity (which has already been\n     * drawn).\n     *\n     * @param area  the area ({@code null} not permitted).\n     */\n    public void setArea(Shape area) {\n        Args.nullNotPermitted(area, \"area\");\n        this.area \u003d area;\n    }\n\n    /**\n     * Returns the tool tip text for the entity.  Be aware that this text\n     * may have been generated from user supplied data, so for security\n     * reasons some form of filtering should be applied before incorporating\n     * this text into any HTML output.\n     *\n     * @return The tool tip text (possibly {@code null}).\n     */\n    public String getToolTipText() {\n        return this.toolTipText;\n    }\n\n    /**\n     * Sets the tool tip text.\n     *\n     * @param text  the text ({@code null} permitted).\n     */\n    public void setToolTipText(String text) {\n        this.toolTipText \u003d text;\n    }\n\n    /**\n     * Returns the URL text for the entity.  Be aware that this text\n     * may have been generated from user supplied data, so some form of\n     * filtering should be applied before this \"URL\" is used in any output.\n     *\n     * @return The URL text (possibly {@code null}).\n     */\n    public String getURLText() {\n        return this.urlText;\n    }\n\n    /**\n     * Sets the URL text.\n     *\n     * @param text the text ({@code null} permitted).\n     */\n    public void setURLText(String text) {\n        this.urlText \u003d text;\n    }\n\n    /**\n     * Returns a string describing the entity area.  This string is intended\n     * for use in an AREA tag when generating an image map.\n     *\n     * @return The shape type (never {@code null}).\n     */\n    public String getShapeType() {\n        if (this.area instanceof Rectangle2D) {\n            return \"rect\";\n        }\n        else {\n            return \"poly\";\n        }\n    }\n\n    /**\n     * Returns the shape coordinates as a string.\n     *\n     * @return The shape coordinates (never {@code null}).\n     */\n    public String getShapeCoords() {\n        if (this.area instanceof Rectangle2D) {\n            return getRectCoords((Rectangle2D) this.area);\n        }\n        else {\n            return getPolyCoords(this.area);\n        }\n    }\n\n    /**\n     * Returns a string containing the coordinates (x1, y1, x2, y2) for a given\n     * rectangle.  This string is intended for use in an image map.\n     *\n     * @param rectangle  the rectangle ({@code null} not permitted).\n     *\n     * @return Upper left and lower right corner of a rectangle.\n     */\n    private String getRectCoords(Rectangle2D rectangle) {\n        Args.nullNotPermitted(rectangle, \"rectangle\");\n        int x1 \u003d (int) rectangle.getX();\n        int y1 \u003d (int) rectangle.getY();\n        int x2 \u003d x1 + (int) rectangle.getWidth();\n        int y2 \u003d y1 + (int) rectangle.getHeight();\n        //      fix by rfuller\n        if (x2 \u003d\u003d x1) {\n            x2++;\n        }\n        if (y2 \u003d\u003d y1) {\n            y2++;\n        }\n        //      end fix by rfuller\n        return x1 + \",\" + y1 + \",\" + x2 + \",\" + y2;\n    }\n\n    /**\n     * Returns a string containing the coordinates for a given shape.  This\n     * string is intended for use in an image map.\n     *\n     * @param shape  the shape ({@code null} not permitted).\n     *\n     * @return The coordinates for a given shape as string.\n     */\n    private String getPolyCoords(Shape shape) {\n        Args.nullNotPermitted(shape, \"shape\");\n        StringBuilder result \u003d new StringBuilder();\n        boolean first \u003d true;\n        float[] coords \u003d new float[6];\n        PathIterator pi \u003d shape.getPathIterator(null, 1.0);\n        while (!pi.isDone()) {\n            pi.currentSegment(coords);\n            if (first) {\n                first \u003d false;\n                result.append((int) coords[0]);\n                result.append(\",\").append((int) coords[1]);\n            }\n            else {\n                result.append(\",\");\n                result.append((int) coords[0]);\n                result.append(\",\");\n                result.append((int) coords[1]);\n            }\n            pi.next();\n        }\n        return result.toString();\n    }\n\n    /**\n     * Returns an HTML image map tag for this entity.  The returned fragment\n     * should be {@code XHTML 1.0} compliant.\n     *\n     * @param toolTipTagFragmentGenerator  a generator for the HTML fragment\n     *     that will contain the tooltip text ({@code null} not permitted\n     *     if this entity contains tooltip information).\n     * @param urlTagFragmentGenerator  a generator for the HTML fragment that\n     *     will contain the URL reference ({@code null} not permitted if\n     *     this entity has a URL).\n     *\n     * @return The HTML tag.\n     */\n    public String getImageMapAreaTag(\n            ToolTipTagFragmentGenerator toolTipTagFragmentGenerator,\n            URLTagFragmentGenerator urlTagFragmentGenerator) {\n\n        StringBuilder tag \u003d new StringBuilder();\n        boolean hasURL \u003d (this.urlText \u003d\u003d null ? false\n                : !this.urlText.equals(\"\"));\n        boolean hasToolTip \u003d (this.toolTipText \u003d\u003d null ? false\n                : !this.toolTipText.equals(\"\"));\n        if (hasURL || hasToolTip) {\n            tag.append(\"\u003carea shape\u003d\\\"\").append(getShapeType()).append(\"\\\"\")\n                    .append(\" coords\u003d\\\"\").append(getShapeCoords()).append(\"\\\"\");\n            if (hasToolTip) {\n                tag.append(toolTipTagFragmentGenerator.generateToolTipFragment(\n                        this.toolTipText));\n            }\n            if (hasURL) {\n                tag.append(urlTagFragmentGenerator.generateURLFragment(\n                        this.urlText));\n            }\n            else {\n                tag.append(\" nohref\u003d\\\"nohref\\\"\");\n            }\n            // if there is a tool tip, we expect it to generate the title and\n            // alt values, so we only add an empty alt if there is no tooltip\n            if (!hasToolTip) {\n                tag.append(\" alt\u003d\\\"\\\"\");\n            }\n            tag.append(\"/\u003e\");\n        }\n        return tag.toString();\n    }\n\n    /**\n     * Returns a string representation of the chart entity, useful for\n     * debugging.\n     *\n     * @return A string.\n     */\n    @Override\n    public String toString() {\n        StringBuilder sb \u003d new StringBuilder(\"ChartEntity: \");\n        sb.append(\"tooltip \u003d \");\n        sb.append(this.toolTipText);\n        return sb.toString();\n    }\n\n    /**\n     * Tests the entity for equality with an arbitrary object.\n     *\n     * @param obj  the object to test against ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof ChartEntity)) {\n            return false;\n        }\n        ChartEntity that \u003d (ChartEntity) obj;\n        if (!this.area.equals(that.area)) {\n            return false;\n        }\n        if (!Objects.equals(this.toolTipText, that.toolTipText)) {\n            return false;\n        }\n        if (!Objects.equals(this.urlText, that.urlText)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this instance.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d 37;\n        result \u003d HashUtils.hashCode(result, this.toolTipText);\n        result \u003d HashUtils.hashCode(result, this.urlText);\n        return result;\n    }\n\n    /**\n     * Returns a clone of the entity.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if there is a problem cloning the\n     *         entity.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writeShape(this.area, stream);\n     }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.area \u003d SerialUtils.readShape(stream);\n    }\n\n}","methodCount":20,"staticMethodCount":0,"instanceMethodCount":20,"classLoc":345,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":1,"candidates":[{"lineStart":260,"lineEnd":304,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method getImageMapAreaTag to class ToolTipTagFragmentGenerator","description":"Move method getImageMapAreaTag to org.jfree.chart.imagemap.ToolTipTagFragmentGenerator\nRationale: The method getImageMapAreaTag heavily relies on generating HTML fragments for the tooltip and partially for the URL. While the full method deals with constructing an HTML map area tag, the primary focus seems to be on correctly generating tooltips, as evidenced by the complexity and checks around this functionality. Moving this method to ToolTipTagFragmentGenerator would centralize the tooltip generation logic, ensuring that it is managed by the class responsible for handling tooltip generation.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false,"userRating":"Helpful"}]},"userSelectionTelemetryData":{"lineStart":260,"lineEnd":304,"functionSize":45,"positionInHostFunction":203,"selectedCandidateIndex":0,"candidateType":"AS_IS","elementsType":[{"elementType":"METHOD","quantity":1}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":64362}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":20},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"getImageMapAreaTag","method_signature":"public getImageMapAreaTag(\n            ToolTipTagFragmentGenerator toolTipTagFragmentGenerator,\n            URLTagFragmentGenerator urlTagFragmentGenerator)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"getImageMapAreaTag","method_signature":"public getImageMapAreaTag(\n            ToolTipTagFragmentGenerator toolTipTagFragmentGenerator,\n            URLTagFragmentGenerator urlTagFragmentGenerator)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public getImageMapAreaTag(\n            ToolTipTagFragmentGenerator toolTipTagFragmentGenerator,\n            URLTagFragmentGenerator urlTagFragmentGenerator)":{"first":{"method_name":"getImageMapAreaTag","method_signature":"public getImageMapAreaTag(\n            ToolTipTagFragmentGenerator toolTipTagFragmentGenerator,\n            URLTagFragmentGenerator urlTagFragmentGenerator)","target_class":"","rationale":""},"second":0.7443622015220257}},"targetClassMap":{"getImageMapAreaTag":{"target_classes":[{"class_name":"ToolTipTagFragmentGenerator","similarity_score":0.6316695488364368},{"class_name":"URLTagFragmentGenerator","similarity_score":0.604824374344943}],"target_classes_sorted_by_llm":["ToolTipTagFragmentGenerator","URLTagFragmentGenerator"],"llm_response_time":0,"similarity_computation_time":1,"similarity_metric":"cosine"}}}
