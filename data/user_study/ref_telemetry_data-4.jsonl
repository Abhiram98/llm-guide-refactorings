{"id":"593ad471-1b4b-434e-b1fa-cba16b624fd3","hostFunctionTelemetryData":{"hostFunctionSize":1695,"lineStart":102,"lineEnd":1796,"bodyLineStart":102,"language":"java","filePath":"/Users/snehil/Documents/ConcordiaUniversity/Material/SOEN-6491-Refactoring/OpenSource/jfreechart/jfreechart/src/main/java/org/jfree/chart/StandardChartTheme.java","sourceCode":"/**\n * A default implementation of the {@link ChartTheme} interface.  This\n * implementation just collects a whole bunch of chart attributes and mimics\n * the manual process of applying each attribute to the right sub-object\n * within the JFreeChart instance.  It\u0027s not elegant code, but it works.\n */\npublic class StandardChartTheme implements ChartTheme, Cloneable,\n        PublicCloneable, Serializable {\n\n    /** The name of this theme. */\n    private final String name;\n\n    /**\n     * The largest font size.  Use for the main chart title.\n     */\n    private Font extraLargeFont;\n\n    /**\n     * A large font.  Used for subtitles.\n     */\n    private Font largeFont;\n\n    /**\n     * The regular font size.  Used for axis tick labels, legend items etc.\n     */\n    private Font regularFont;\n\n    /**\n     * The small font size.\n     */\n    private Font smallFont;\n\n    /** The paint used to display the main chart title. */\n    private transient Paint titlePaint;\n\n    /** The paint used to display subtitles. */\n    private transient Paint subtitlePaint;\n\n    /** The background paint for the chart. */\n    private transient Paint chartBackgroundPaint;\n\n    /** The legend background paint. */\n    private transient Paint legendBackgroundPaint;\n\n    /** The legend item paint. */\n    private transient Paint legendItemPaint;\n\n    /** The drawing supplier. */\n    private DrawingSupplier drawingSupplier;\n\n    /** The background paint for the plot. */\n    private transient Paint plotBackgroundPaint;\n\n    /** The plot outline paint. */\n    private transient Paint plotOutlinePaint;\n\n    /** The label link style for pie charts. */\n    private PieLabelLinkStyle labelLinkStyle;\n\n    /** The label link paint for pie charts. */\n    private transient Paint labelLinkPaint;\n\n    /** The domain grid line paint. */\n    private transient Paint domainGridlinePaint;\n\n    /** The range grid line paint. */\n    private transient Paint rangeGridlinePaint;\n\n    /**\n     * The baseline paint (used for domain and range zero baselines)\n     */\n    private transient Paint baselinePaint;\n\n    /** The crosshair paint. */\n    private transient Paint crosshairPaint;\n\n    /** The axis offsets. */\n    private RectangleInsets axisOffset;\n\n    /** The axis label paint. */\n    private transient Paint axisLabelPaint;\n\n    /** The tick label paint. */\n    private transient Paint tickLabelPaint;\n\n    /** The item label paint. */\n    private transient Paint itemLabelPaint;\n\n    /**\n     * A flag that controls whether or not shadows are visible (for example,\n     * in a bar renderer).\n     */\n    private boolean shadowVisible;\n\n    /** The shadow paint. */\n    private transient Paint shadowPaint;\n\n    /** The bar painter. */\n    private BarPainter barPainter;\n\n    /** The XY bar painter. */\n    private XYBarPainter xyBarPainter;\n\n    /** The thermometer paint. */\n    private transient Paint thermometerPaint;\n\n    /** The error indicator paint for the {@link StatisticalBarRenderer}. */\n    private transient Paint errorIndicatorPaint;\n\n    /** The grid band paint for a {@link SymbolAxis}. */\n    private transient Paint gridBandPaint \u003d SymbolAxis.DEFAULT_GRID_BAND_PAINT;\n\n    /** The grid band alternate paint for a {@link SymbolAxis}. */\n    private transient Paint gridBandAlternatePaint\n            \u003d SymbolAxis.DEFAULT_GRID_BAND_ALTERNATE_PAINT;\n\n    /**\n     * The shadow generator (can be null).\n     */\n    private ShadowGenerator shadowGenerator;\n\n    /**\n     * Creates and returns the default \u0027JFree\u0027 chart theme.\n     *\n     * @return A chart theme.\n     */\n    public static ChartTheme createJFreeTheme() {\n        return new StandardChartTheme(\"JFree\");\n    }\n\n    /**\n     * Creates and returns a theme called \"Darkness\".  In this theme, the\n     * charts have a black background.\n     *\n     * @return The \"Darkness\" theme.\n     */\n    public static ChartTheme createDarknessTheme() {\n        StandardChartTheme theme \u003d new StandardChartTheme(\"Darkness\");\n        theme.titlePaint \u003d Color.WHITE;\n        theme.subtitlePaint \u003d Color.WHITE;\n        theme.legendBackgroundPaint \u003d Color.BLACK;\n        theme.legendItemPaint \u003d Color.WHITE;\n        theme.chartBackgroundPaint \u003d Color.BLACK;\n        theme.plotBackgroundPaint \u003d Color.BLACK;\n        theme.plotOutlinePaint \u003d Color.YELLOW;\n        theme.baselinePaint \u003d Color.WHITE;\n        theme.crosshairPaint \u003d Color.RED;\n        theme.labelLinkPaint \u003d Color.LIGHT_GRAY;\n        theme.tickLabelPaint \u003d Color.WHITE;\n        theme.axisLabelPaint \u003d Color.WHITE;\n        theme.shadowPaint \u003d Color.DARK_GRAY;\n        theme.itemLabelPaint \u003d Color.WHITE;\n        theme.drawingSupplier \u003d new DefaultDrawingSupplier(\n                new Paint[] {Color.decode(\"0xFFFF00\"),\n                        Color.decode(\"0x0036CC\"), Color.decode(\"0xFF0000\"),\n                        Color.decode(\"0xFFFF7F\"), Color.decode(\"0x6681CC\"),\n                        Color.decode(\"0xFF7F7F\"), Color.decode(\"0xFFFFBF\"),\n                        Color.decode(\"0x99A6CC\"), Color.decode(\"0xFFBFBF\"),\n                        Color.decode(\"0xA9A938\"), Color.decode(\"0x2D4587\")},\n                new Paint[] {Color.decode(\"0xFFFF00\"),\n                        Color.decode(\"0x0036CC\")},\n                new Stroke[] {new BasicStroke(2.0f)},\n                new Stroke[] {new BasicStroke(0.5f)},\n                DefaultDrawingSupplier.DEFAULT_SHAPE_SEQUENCE);\n        theme.errorIndicatorPaint \u003d Color.LIGHT_GRAY;\n        theme.gridBandPaint \u003d new Color(255, 255, 255, 20);\n        theme.gridBandAlternatePaint \u003d new Color(255, 255, 255, 40);\n        theme.shadowGenerator \u003d null;\n        return theme;\n    }\n\n    /**\n     * Creates and returns a {@link ChartTheme} that doesn\u0027t apply any changes\n     * to the JFreeChart defaults.  This produces the \"legacy\" look for\n     * JFreeChart.\n     *\n     * @return A legacy theme.\n     */\n    public static ChartTheme createLegacyTheme() {\n        StandardChartTheme theme \u003d new StandardChartTheme(\"Legacy\") {\n            @Override\n            public void apply(JFreeChart chart) {\n                // do nothing at all\n            }\n        };\n        return theme;\n    }\n\n    /**\n     * Creates a new default instance.\n     *\n     * @param name  the name of the theme ({@code null} not permitted).\n     */\n    public StandardChartTheme(String name) {\n        this(name, false);\n    }\n\n    /**\n     * Creates a new default instance.\n     *\n     * @param name  the name of the theme ({@code null} not permitted).\n     * @param shadow  a flag that controls whether a shadow generator is \n     *                included.\n     */\n    public StandardChartTheme(String name, boolean shadow) {\n        Args.nullNotPermitted(name, \"name\");\n        this.name \u003d name;\n        this.extraLargeFont \u003d new Font(\"Tahoma\", Font.BOLD, 20);\n        this.largeFont \u003d new Font(\"Tahoma\", Font.BOLD, 14);\n        this.regularFont \u003d new Font(\"Tahoma\", Font.PLAIN, 12);\n        this.smallFont \u003d new Font(\"Tahoma\", Font.PLAIN, 10);\n        this.titlePaint \u003d Color.BLACK;\n        this.subtitlePaint \u003d Color.BLACK;\n        this.legendBackgroundPaint \u003d Color.WHITE;\n        this.legendItemPaint \u003d Color.DARK_GRAY;\n        this.chartBackgroundPaint \u003d Color.WHITE;\n        this.drawingSupplier \u003d new DefaultDrawingSupplier();\n        this.plotBackgroundPaint \u003d Color.LIGHT_GRAY;\n        this.plotOutlinePaint \u003d Color.BLACK;\n        this.labelLinkPaint \u003d Color.BLACK;\n        this.labelLinkStyle \u003d PieLabelLinkStyle.CUBIC_CURVE;\n        this.axisOffset \u003d new RectangleInsets(4, 4, 4, 4);\n        this.domainGridlinePaint \u003d Color.WHITE;\n        this.rangeGridlinePaint \u003d Color.WHITE;\n        this.baselinePaint \u003d Color.BLACK;\n        this.crosshairPaint \u003d Color.BLUE;\n        this.axisLabelPaint \u003d Color.DARK_GRAY;\n        this.tickLabelPaint \u003d Color.DARK_GRAY;\n        this.barPainter \u003d new GradientBarPainter();\n        this.xyBarPainter \u003d new GradientXYBarPainter();\n        this.shadowVisible \u003d false;\n        this.shadowPaint \u003d Color.GRAY;\n        this.itemLabelPaint \u003d Color.BLACK;\n        this.thermometerPaint \u003d Color.WHITE;\n        this.errorIndicatorPaint \u003d Color.BLACK;\n        this.shadowGenerator \u003d shadow ? new DefaultShadowGenerator() : null;\n    }\n\n    /**\n     * Returns the largest font for this theme.\n     *\n     * @return The largest font for this theme.\n     *\n     * @see #setExtraLargeFont(Font)\n     */\n    public Font getExtraLargeFont() {\n        return this.extraLargeFont;\n    }\n\n    /**\n     * Sets the largest font for this theme.\n     *\n     * @param font  the font ({@code null} not permitted).\n     *\n     * @see #getExtraLargeFont()\n     */\n    public void setExtraLargeFont(Font font) {\n        Args.nullNotPermitted(font, \"font\");\n        this.extraLargeFont \u003d font;\n    }\n\n    /**\n     * Returns the large font for this theme.\n     *\n     * @return The large font (never {@code null}).\n     *\n     * @see #setLargeFont(Font)\n     */\n    public Font getLargeFont() {\n        return this.largeFont;\n    }\n\n    /**\n     * Sets the large font for this theme.\n     *\n     * @param font  the font ({@code null} not permitted).\n     *\n     * @see #getLargeFont()\n     */\n    public void setLargeFont(Font font) {\n        Args.nullNotPermitted(font, \"font\");\n        this.largeFont \u003d font;\n    }\n\n    /**\n     * Returns the regular font.\n     *\n     * @return The regular font (never {@code null}).\n     *\n     * @see #setRegularFont(Font)\n     */\n    public Font getRegularFont() {\n        return this.regularFont;\n    }\n\n    /**\n     * Sets the regular font for this theme.\n     *\n     * @param font  the font ({@code null} not permitted).\n     *\n     * @see #getRegularFont()\n     */\n    public void setRegularFont(Font font) {\n        Args.nullNotPermitted(font, \"font\");\n        this.regularFont \u003d font;\n    }\n\n    /**\n     * Returns the small font.\n     *\n     * @return The small font (never {@code null}).\n     *\n     * @see #setSmallFont(Font)\n     */\n    public Font getSmallFont() {\n        return this.smallFont;\n    }\n\n    /**\n     * Sets the small font for this theme.\n     *\n     * @param font  the font ({@code null} not permitted).\n     *\n     * @see #getSmallFont()\n     */\n    public void setSmallFont(Font font) {\n        Args.nullNotPermitted(font, \"font\");\n        this.smallFont \u003d font;\n    }\n\n    /**\n     * Returns the title paint.\n     *\n     * @return The title paint (never {@code null}).\n     *\n     * @see #setTitlePaint(Paint)\n     */\n    public Paint getTitlePaint() {\n        return this.titlePaint;\n    }\n\n    /**\n     * Sets the title paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getTitlePaint()\n     */\n    public void setTitlePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.titlePaint \u003d paint;\n    }\n\n    /**\n     * Returns the subtitle paint.\n     *\n     * @return The subtitle paint (never {@code null}).\n     *\n     * @see #setSubtitlePaint(Paint)\n     */\n    public Paint getSubtitlePaint() {\n        return this.subtitlePaint;\n    }\n\n    /**\n     * Sets the subtitle paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getSubtitlePaint()\n     */\n    public void setSubtitlePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.subtitlePaint \u003d paint;\n    }\n\n    /**\n     * Returns the chart background paint.\n     *\n     * @return The chart background paint (never {@code null}).\n     *\n     * @see #setChartBackgroundPaint(Paint)\n     */\n    public Paint getChartBackgroundPaint() {\n        return this.chartBackgroundPaint;\n    }\n\n    /**\n     * Sets the chart background paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getChartBackgroundPaint()\n     */\n    public void setChartBackgroundPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.chartBackgroundPaint \u003d paint;\n    }\n\n    /**\n     * Returns the legend background paint.\n     *\n     * @return The legend background paint (never {@code null}).\n     *\n     * @see #setLegendBackgroundPaint(Paint)\n     */\n    public Paint getLegendBackgroundPaint() {\n        return this.legendBackgroundPaint;\n    }\n\n    /**\n     * Sets the legend background paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getLegendBackgroundPaint()\n     */\n    public void setLegendBackgroundPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.legendBackgroundPaint \u003d paint;\n    }\n\n    /**\n     * Returns the legend item paint.\n     *\n     * @return The legend item paint (never {@code null}).\n     *\n     * @see #setLegendItemPaint(Paint)\n     */\n    public Paint getLegendItemPaint() {\n        return this.legendItemPaint;\n    }\n\n    /**\n     * Sets the legend item paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getLegendItemPaint()\n     */\n    public void setLegendItemPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.legendItemPaint \u003d paint;\n    }\n\n    /**\n     * Returns the plot background paint.\n     *\n     * @return The plot background paint (never {@code null}).\n     *\n     * @see #setPlotBackgroundPaint(Paint)\n     */\n    public Paint getPlotBackgroundPaint() {\n        return this.plotBackgroundPaint;\n    }\n\n    /**\n     * Sets the plot background paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getPlotBackgroundPaint()\n     */\n    public void setPlotBackgroundPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.plotBackgroundPaint \u003d paint;\n    }\n\n    /**\n     * Returns the plot outline paint.\n     *\n     * @return The plot outline paint (never {@code null}).\n     *\n     * @see #setPlotOutlinePaint(Paint)\n     */\n    public Paint getPlotOutlinePaint() {\n        return this.plotOutlinePaint;\n    }\n\n    /**\n     * Sets the plot outline paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getPlotOutlinePaint()\n     */\n    public void setPlotOutlinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.plotOutlinePaint \u003d paint;\n    }\n\n    /**\n     * Returns the label link style for pie charts.\n     *\n     * @return The label link style (never {@code null}).\n     *\n     * @see #setLabelLinkStyle(PieLabelLinkStyle)\n     */\n    public PieLabelLinkStyle getLabelLinkStyle() {\n        return this.labelLinkStyle;\n    }\n\n    /**\n     * Sets the label link style for pie charts.\n     *\n     * @param style  the style ({@code null} not permitted).\n     *\n     * @see #getLabelLinkStyle()\n     */\n    public void setLabelLinkStyle(PieLabelLinkStyle style) {\n        Args.nullNotPermitted(style, \"style\");\n        this.labelLinkStyle \u003d style;\n    }\n\n    /**\n     * Returns the label link paint for pie charts.\n     *\n     * @return The label link paint (never {@code null}).\n     *\n     * @see #setLabelLinkPaint(Paint)\n     */\n    public Paint getLabelLinkPaint() {\n        return this.labelLinkPaint;\n    }\n\n    /**\n     * Sets the label link paint for pie charts.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getLabelLinkPaint()\n     */\n    public void setLabelLinkPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.labelLinkPaint \u003d paint;\n    }\n\n    /**\n     * Returns the domain grid line paint.\n     *\n     * @return The domain grid line paint (never {@code null}).\n     *\n     * @see #setDomainGridlinePaint(Paint)\n     */\n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    /**\n     * Sets the domain grid line paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getDomainGridlinePaint()\n     */\n    public void setDomainGridlinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.domainGridlinePaint \u003d paint;\n    }\n\n    /**\n     * Returns the range grid line paint.\n     *\n     * @return The range grid line paint (never {@code null}).\n     *\n     * @see #setRangeGridlinePaint(Paint)\n     */\n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    /**\n     * Sets the range grid line paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getRangeGridlinePaint()\n     */\n    public void setRangeGridlinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.rangeGridlinePaint \u003d paint;\n    }\n\n    /**\n     * Returns the baseline paint.\n     *\n     * @return The baseline paint.\n     */\n    public Paint getBaselinePaint() {\n        return this.baselinePaint;\n    }\n\n    /**\n     * Sets the baseline paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     */\n    public void setBaselinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.baselinePaint \u003d paint;\n    }\n\n    /**\n     * Returns the crosshair paint.\n     *\n     * @return The crosshair paint.\n     */\n    public Paint getCrosshairPaint() {\n        return this.crosshairPaint;\n    }\n\n    /**\n     * Sets the crosshair paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     */\n    public void setCrosshairPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.crosshairPaint \u003d paint;\n    }\n\n    /**\n     * Returns the axis offsets.\n     *\n     * @return The axis offsets (never {@code null}).\n     *\n     * @see #setAxisOffset(RectangleInsets)\n     */\n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    /**\n     * Sets the axis offset.\n     *\n     * @param offset  the offset ({@code null} not permitted).\n     *\n     * @see #getAxisOffset()\n     */\n    public void setAxisOffset(RectangleInsets offset) {\n        Args.nullNotPermitted(offset, \"offset\");\n        this.axisOffset \u003d offset;\n    }\n\n    /**\n     * Returns the axis label paint.\n     *\n     * @return The axis label paint (never {@code null}).\n     *\n     * @see #setAxisLabelPaint(Paint)\n     */\n    public Paint getAxisLabelPaint() {\n        return this.axisLabelPaint;\n    }\n\n    /**\n     * Sets the axis label paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getAxisLabelPaint()\n     */\n    public void setAxisLabelPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.axisLabelPaint \u003d paint;\n    }\n\n    /**\n     * Returns the tick label paint.\n     *\n     * @return The tick label paint (never {@code null}).\n     *\n     * @see #setTickLabelPaint(Paint)\n     */\n    public Paint getTickLabelPaint() {\n        return this.tickLabelPaint;\n    }\n\n    /**\n     * Sets the tick label paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getTickLabelPaint()\n     */\n    public void setTickLabelPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.tickLabelPaint \u003d paint;\n    }\n\n    /**\n     * Returns the item label paint.\n     *\n     * @return The item label paint (never {@code null}).\n     *\n     * @see #setItemLabelPaint(Paint)\n     */\n    public Paint getItemLabelPaint() {\n        return this.itemLabelPaint;\n    }\n\n    /**\n     * Sets the item label paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getItemLabelPaint()\n     */\n    public void setItemLabelPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.itemLabelPaint \u003d paint;\n    }\n\n    /**\n     * Returns the shadow visibility flag.\n     *\n     * @return The shadow visibility flag.\n     *\n     * @see #setShadowVisible(boolean)\n     */\n    public boolean isShadowVisible() {\n        return this.shadowVisible;\n    }\n\n    /**\n     * Sets the shadow visibility flag.\n     *\n     * @param visible  the flag.\n     *\n     * @see #isShadowVisible()\n     */\n    public void setShadowVisible(boolean visible) {\n        this.shadowVisible \u003d visible;\n    }\n\n    /**\n     * Returns the shadow paint.\n     *\n     * @return The shadow paint (never {@code null}).\n     *\n     * @see #setShadowPaint(Paint)\n     */\n    public Paint getShadowPaint() {\n        return this.shadowPaint;\n    }\n\n    /**\n     * Sets the shadow paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getShadowPaint()\n     */\n    public void setShadowPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.shadowPaint \u003d paint;\n    }\n\n    /**\n     * Returns the bar painter.\n     *\n     * @return The bar painter (never {@code null}).\n     *\n     * @see #setBarPainter(BarPainter)\n     */\n    public BarPainter getBarPainter() {\n        return this.barPainter;\n    }\n\n    /**\n     * Sets the bar painter.\n     *\n     * @param painter  the painter ({@code null} not permitted).\n     *\n     * @see #getBarPainter()\n     */\n    public void setBarPainter(BarPainter painter) {\n        Args.nullNotPermitted(painter, \"painter\");\n        this.barPainter \u003d painter;\n    }\n\n    /**\n     * Returns the XY bar painter.\n     *\n     * @return The XY bar painter (never {@code null}).\n     *\n     * @see #setXYBarPainter(XYBarPainter)\n     */\n    public XYBarPainter getXYBarPainter() {\n        return this.xyBarPainter;\n    }\n\n    /**\n     * Sets the XY bar painter.\n     *\n     * @param painter  the painter ({@code null} not permitted).\n     *\n     * @see #getXYBarPainter()\n     */\n    public void setXYBarPainter(XYBarPainter painter) {\n        Args.nullNotPermitted(painter, \"painter\");\n        this.xyBarPainter \u003d painter;\n    }\n\n    /**\n     * Returns the thermometer paint.\n     *\n     * @return The thermometer paint (never {@code null}).\n     *\n     * @see #setThermometerPaint(Paint)\n     */\n    public Paint getThermometerPaint() {\n        return this.thermometerPaint;\n    }\n\n    /**\n     * Sets the thermometer paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getThermometerPaint()\n     */\n    public void setThermometerPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.thermometerPaint \u003d paint;\n    }\n\n    /**\n     * Returns the error indicator paint.\n     *\n     * @return The error indicator paint (never {@code null}).\n     *\n     * @see #setErrorIndicatorPaint(Paint)\n     */\n    public Paint getErrorIndicatorPaint() {\n        return this.errorIndicatorPaint;\n    }\n\n    /**\n     * Sets the error indicator paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getErrorIndicatorPaint()\n     */\n    public void setErrorIndicatorPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.errorIndicatorPaint \u003d paint;\n    }\n\n    /**\n     * Returns the grid band paint.\n     *\n     * @return The grid band paint (never {@code null}).\n     *\n     * @see #setGridBandPaint(Paint)\n     */\n    public Paint getGridBandPaint() {\n        return this.gridBandPaint;\n    }\n\n    /**\n     * Sets the grid band paint.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getGridBandPaint()\n     */\n    public void setGridBandPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.gridBandPaint \u003d paint;\n    }\n\n    /**\n     * Returns the grid band alternate paint (used for a {@link SymbolAxis}).\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setGridBandAlternatePaint(Paint)\n     */\n    public Paint getGridBandAlternatePaint() {\n        return this.gridBandAlternatePaint;\n    }\n\n    /**\n     * Sets the grid band alternate paint (used for a {@link SymbolAxis}).\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getGridBandAlternatePaint()\n     */\n    public void setGridBandAlternatePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.gridBandAlternatePaint \u003d paint;\n    }\n\n    /**\n     * Returns the name of this theme.\n     *\n     * @return The name of this theme.\n     */\n    public String getName() {\n        return this.name;\n    }\n\n    /**\n     * Returns a clone of the drawing supplier for this theme.\n     *\n     * @return A clone of the drawing supplier.\n     */\n    public DrawingSupplier getDrawingSupplier() {\n        DrawingSupplier result \u003d null;\n        if (this.drawingSupplier instanceof PublicCloneable) {\n            PublicCloneable pc \u003d (PublicCloneable) this.drawingSupplier;\n              try {\n                result \u003d (DrawingSupplier) pc.clone();\n            }\n            catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the drawing supplier for this theme.\n     *\n     * @param supplier  the supplier ({@code null} not permitted).\n     *\n     * @see #getDrawingSupplier()\n     */\n    public void setDrawingSupplier(DrawingSupplier supplier) {\n        Args.nullNotPermitted(supplier, \"supplier\");\n        this.drawingSupplier \u003d supplier;\n    }\n\n    /**\n     * Applies this theme to the supplied chart.\n     *\n     * @param chart  the chart ({@code null} not permitted).\n     */\n    @Override\n    public void apply(JFreeChart chart) {\n        Args.nullNotPermitted(chart, \"chart\");\n        TextTitle title \u003d chart.getTitle();\n        if (title !\u003d null) {\n            title.setFont(this.extraLargeFont);\n            title.setPaint(this.titlePaint);\n        }\n\n        int subtitleCount \u003d chart.getSubtitleCount();\n        for (int i \u003d 0; i \u003c subtitleCount; i++) {\n            applyToTitle(chart.getSubtitle(i));\n        }\n\n        chart.setBackgroundPaint(this.chartBackgroundPaint);\n\n        // now process the plot if there is one\n        Plot plot \u003d chart.getPlot();\n        if (plot !\u003d null) {\n            applyToPlot(plot);\n        }\n    }\n\n    /**\n     * Applies the attributes of this theme to the specified title.\n     *\n     * @param title  the title.\n     */\n    protected void applyToTitle(Title title) {\n        if (title instanceof TextTitle) {\n            TextTitle tt \u003d (TextTitle) title;\n            tt.setFont(this.largeFont);\n            tt.setPaint(this.subtitlePaint);\n        }\n        else if (title instanceof LegendTitle) {\n            LegendTitle lt \u003d (LegendTitle) title;\n            if (lt.getBackgroundPaint() !\u003d null) {\n                lt.setBackgroundPaint(this.legendBackgroundPaint);\n            }\n            lt.setItemFont(this.regularFont);\n            lt.setItemPaint(this.legendItemPaint);\n            if (lt.getWrapper() !\u003d null) {\n                applyToBlockContainer(lt.getWrapper());\n            }\n        }\n        else if (title instanceof PaintScaleLegend) {\n            PaintScaleLegend psl \u003d (PaintScaleLegend) title;\n            psl.setBackgroundPaint(this.legendBackgroundPaint);\n            ValueAxis axis \u003d psl.getAxis();\n            if (axis !\u003d null) {\n                applyToValueAxis(axis);\n            }\n        }\n        else if (title instanceof CompositeTitle) {\n            CompositeTitle ct \u003d (CompositeTitle) title;\n            BlockContainer bc \u003d ct.getContainer();\n            for (Block b: bc.getBlocks()) {\n                if (b instanceof Title) {\n                    applyToTitle((Title) b);\n                }\n            }\n        }\n    }\n\n    /**\n     * Applies the attributes of this theme to the specified container.\n     *\n     * @param bc  a block container ({@code null} not permitted).\n     */\n    protected void applyToBlockContainer(BlockContainer bc) {\n        for (Block b : bc.getBlocks()) {\n            applyToBlock(b);\n        }\n    }\n\n    /**\n     * Applies the attributes of this theme to the specified block.\n     *\n     * @param b  the block.\n     */\n    protected void applyToBlock(Block b) {\n        if (b instanceof Title) {\n            applyToTitle((Title) b);\n        }\n        else if (b instanceof LabelBlock) {\n            LabelBlock lb \u003d (LabelBlock) b;\n            lb.setFont(this.regularFont);\n            lb.setPaint(this.legendItemPaint);\n        }\n    }\n\n    /**\n     * Applies the attributes of this theme to a plot.\n     *\n     * @param plot  the plot ({@code null} not permitted).\n     */\n    protected void applyToPlot(Plot plot) {\n        Args.nullNotPermitted(plot, \"plot\");\n        if (plot.getDrawingSupplier() !\u003d null) {\n            plot.setDrawingSupplier(getDrawingSupplier());\n        }\n        if (plot.getBackgroundPaint() !\u003d null) {\n            plot.setBackgroundPaint(this.plotBackgroundPaint);\n        }\n        plot.setOutlinePaint(this.plotOutlinePaint);\n\n        // now handle specific plot types (and yes, I know this is some\n        // really ugly code that has to be manually updated any time a new\n        // plot type is added - I should have written something much cooler,\n        // but I didn\u0027t and neither did anyone else).\n        if (plot instanceof PiePlot) {\n            applyToPiePlot((PiePlot) plot);\n        }\n        else if (plot instanceof MultiplePiePlot) {\n            applyToMultiplePiePlot((MultiplePiePlot) plot);\n        }\n        else if (plot instanceof CategoryPlot) {\n            applyToCategoryPlot((CategoryPlot) plot);\n        }\n        else if (plot instanceof XYPlot) {\n            applyToXYPlot((XYPlot) plot);\n        }\n        else if (plot instanceof FastScatterPlot) {\n            applyToFastScatterPlot((FastScatterPlot) plot);\n        }\n        else if (plot instanceof MeterPlot) {\n            applyToMeterPlot((MeterPlot) plot);\n        }\n        else if (plot instanceof ThermometerPlot) {\n            applyToThermometerPlot((ThermometerPlot) plot);\n        }\n        else if (plot instanceof SpiderWebPlot) {\n            applyToSpiderWebPlot((SpiderWebPlot) plot);\n        }\n        else if (plot instanceof PolarPlot) {\n            applyToPolarPlot((PolarPlot) plot);\n        }\n    }\n\n    /**\n     * Applies the attributes of this theme to a {@link PiePlot} instance.\n     * This method also clears any set values for the section paint, outline\n     * etc, so that the theme\u0027s {@link DrawingSupplier} will be used.\n     *\n     * @param plot  the plot ({@code null} not permitted).\n     */\n    protected void applyToPiePlot(PiePlot plot) {\n        plot.setLabelLinkPaint(this.labelLinkPaint);\n        plot.setLabelLinkStyle(this.labelLinkStyle);\n        plot.setLabelFont(this.regularFont);\n        plot.setShadowGenerator(this.shadowGenerator);\n\n        // clear the section attributes so that the theme\u0027s DrawingSupplier\n        // will be used\n        if (plot.getAutoPopulateSectionPaint()) {\n            plot.clearSectionPaints(false);\n        }\n        if (plot.getAutoPopulateSectionOutlinePaint()) {\n            plot.clearSectionOutlinePaints(false);\n        }\n        if (plot.getAutoPopulateSectionOutlineStroke()) {\n            plot.clearSectionOutlineStrokes(false);\n        }\n    }\n\n    /**\n     * Applies the attributes of this theme to a {@link MultiplePiePlot}.\n     *\n     * @param plot  the plot ({@code null} not permitted).\n     */\n    protected void applyToMultiplePiePlot(MultiplePiePlot plot) {\n        apply(plot.getPieChart());\n    }\n\n    /**\n     * Applies the attributes of this theme to a {@link CategoryPlot}.\n     *\n     * @param plot  the plot ({@code null} not permitted).\n     */\n    protected void applyToCategoryPlot(CategoryPlot plot) {\n        plot.setAxisOffset(this.axisOffset);\n        plot.setDomainGridlinePaint(this.domainGridlinePaint);\n        plot.setRangeGridlinePaint(this.rangeGridlinePaint);\n        plot.setRangeZeroBaselinePaint(this.baselinePaint);\n        plot.setShadowGenerator(this.shadowGenerator);\n\n        // process all domain axes\n        int domainAxisCount \u003d plot.getDomainAxisCount();\n        for (int i \u003d 0; i \u003c domainAxisCount; i++) {\n            CategoryAxis axis \u003d plot.getDomainAxis(i);\n            if (axis !\u003d null) {\n                applyToCategoryAxis(axis);\n            }\n        }\n\n        // process all range axes\n        int rangeAxisCount \u003d plot.getRangeAxisCount();\n        for (int i \u003d 0; i \u003c rangeAxisCount; i++) {\n            ValueAxis axis \u003d plot.getRangeAxis(i);\n            if (axis !\u003d null) {\n                applyToValueAxis(axis);\n            }\n        }\n\n        // process all renderers\n        int rendererCount \u003d plot.getRendererCount();\n        for (int i \u003d 0; i \u003c rendererCount; i++) {\n            CategoryItemRenderer r \u003d plot.getRenderer(i);\n            if (r !\u003d null) {\n                applyToCategoryItemRenderer(r);\n            }\n        }\n\n        if (plot instanceof CombinedDomainCategoryPlot) {\n            CombinedDomainCategoryPlot cp \u003d (CombinedDomainCategoryPlot) plot;\n            for (CategoryPlot subplot : cp.getSubplots()) {\n                if (subplot !\u003d null) {\n                    applyToPlot(subplot);\n                }\n            }\n        }\n        if (plot instanceof CombinedRangeCategoryPlot) {\n            CombinedRangeCategoryPlot cp \u003d (CombinedRangeCategoryPlot) plot;\n            for (CategoryPlot subplot : cp.getSubplots()) {\n                if (subplot !\u003d null) {\n                    applyToPlot(subplot);\n                }\n            }\n        }\n    }\n\n    /**\n     * Applies the attributes of this theme to a {@link XYPlot}.\n     *\n     * @param plot  the plot ({@code null} not permitted).\n     * \n     * @param \u003cS\u003e the type for the series keys.\n     */\n    protected \u003cS extends Comparable\u003cS\u003e\u003e void applyToXYPlot(XYPlot\u003cS\u003e plot) {\n        plot.setAxisOffset(this.axisOffset);\n        plot.setDomainZeroBaselinePaint(this.baselinePaint);\n        plot.setRangeZeroBaselinePaint(this.baselinePaint);\n        plot.setDomainGridlinePaint(this.domainGridlinePaint);\n        plot.setRangeGridlinePaint(this.rangeGridlinePaint);\n        plot.setDomainCrosshairPaint(this.crosshairPaint);\n        plot.setRangeCrosshairPaint(this.crosshairPaint);\n        plot.setShadowGenerator(this.shadowGenerator);\n\n        // process all domain axes\n        int domainAxisCount \u003d plot.getDomainAxisCount();\n        for (int i \u003d 0; i \u003c domainAxisCount; i++) {\n            ValueAxis axis \u003d plot.getDomainAxis(i);\n            if (axis !\u003d null) {\n                applyToValueAxis(axis);\n            }\n        }\n\n        // process all range axes\n        int rangeAxisCount \u003d plot.getRangeAxisCount();\n        for (int i \u003d 0; i \u003c rangeAxisCount; i++) {\n            ValueAxis axis \u003d plot.getRangeAxis(i);\n            if (axis !\u003d null) {\n                applyToValueAxis(axis);\n            }\n        }\n\n        // process all renderers\n        int rendererCount \u003d plot.getRendererCount();\n        for (int i \u003d 0; i \u003c rendererCount; i++) {\n            XYItemRenderer r \u003d plot.getRenderer(i);\n            if (r !\u003d null) {\n                applyToXYItemRenderer(r);\n            }\n        }\n        // process all annotations\n\n        for (XYAnnotation a : plot.getAnnotations()) {\n            applyToXYAnnotation(a);\n        }\n\n        if (plot instanceof CombinedDomainXYPlot) {\n            CombinedDomainXYPlot\u003cS\u003e cp \u003d (CombinedDomainXYPlot) plot;\n            for (XYPlot\u003cS\u003e subplot : cp.getSubplots()) {\n                if (subplot !\u003d null) {\n                    applyToPlot(subplot);\n                }\n            }\n        }\n        if (plot instanceof CombinedRangeXYPlot) {\n            CombinedRangeXYPlot\u003cS\u003e cp \u003d (CombinedRangeXYPlot) plot;\n            for (XYPlot subplot : cp.getSubplots()) {\n                if (subplot !\u003d null) {\n                    applyToPlot(subplot);\n                }\n            }\n        }\n    }\n\n    /**\n     * Applies the attributes of this theme to a {@link FastScatterPlot}.\n     * \n     * @param plot  the plot ({@code null} not permitted).\n     */\n    protected void applyToFastScatterPlot(FastScatterPlot plot) {\n        plot.setDomainGridlinePaint(this.domainGridlinePaint);\n        plot.setRangeGridlinePaint(this.rangeGridlinePaint);\n        ValueAxis xAxis \u003d plot.getDomainAxis();\n        if (xAxis !\u003d null) {\n            applyToValueAxis(xAxis);\n        }\n        ValueAxis yAxis \u003d plot.getRangeAxis();\n        if (yAxis !\u003d null) {\n            applyToValueAxis(yAxis);\n        }\n\n    }\n\n    /**\n     * Applies the attributes of this theme to a {@link PolarPlot}.  This\n     * method is called from the {@link #applyToPlot(Plot)} method.\n     *\n     * @param plot  the plot ({@code null} not permitted).\n     */\n    protected void applyToPolarPlot(PolarPlot plot) {\n        plot.setAngleLabelFont(this.regularFont);\n        plot.setAngleLabelPaint(this.tickLabelPaint);\n        plot.setAngleGridlinePaint(this.domainGridlinePaint);\n        plot.setRadiusGridlinePaint(this.rangeGridlinePaint);\n        ValueAxis axis \u003d plot.getAxis();\n        if (axis !\u003d null) {\n            applyToValueAxis(axis);\n        }\n    }\n\n    /**\n     * Applies the attributes of this theme to a {@link SpiderWebPlot}.\n     *\n     * @param plot  the plot ({@code null} not permitted).\n     */\n    protected void applyToSpiderWebPlot(SpiderWebPlot plot) {\n        plot.setLabelFont(this.regularFont);\n        plot.setLabelPaint(this.axisLabelPaint);\n        plot.setAxisLinePaint(this.axisLabelPaint);\n    }\n\n    /**\n     * Applies the attributes of this theme to a {@link MeterPlot}.\n     *\n     * @param plot  the plot ({@code null} not permitted).\n     */\n    protected void applyToMeterPlot(MeterPlot plot) {\n        plot.setDialBackgroundPaint(this.plotBackgroundPaint);\n        plot.setValueFont(this.largeFont);\n        plot.setValuePaint(this.axisLabelPaint);\n        plot.setDialOutlinePaint(this.plotOutlinePaint);\n        plot.setNeedlePaint(this.thermometerPaint);\n        plot.setTickLabelFont(this.regularFont);\n        plot.setTickLabelPaint(this.tickLabelPaint);\n    }\n\n    /**\n     * Applies the attributes for this theme to a {@link ThermometerPlot}.\n     * This method is called from the {@link #applyToPlot(Plot)} method.\n     *\n     * @param plot  the plot.\n     */\n    protected void applyToThermometerPlot(ThermometerPlot plot) {\n        plot.setValueFont(this.largeFont);\n        plot.setThermometerPaint(this.thermometerPaint);\n        ValueAxis axis \u003d plot.getRangeAxis();\n        if (axis !\u003d null) {\n            applyToValueAxis(axis);\n        }\n    }\n\n    /**\n     * Applies the attributes for this theme to a {@link CategoryAxis}.\n     *\n     * @param axis  the axis ({@code null} not permitted).\n     */\n    protected void applyToCategoryAxis(CategoryAxis axis) {\n        axis.setLabelFont(this.largeFont);\n        axis.setLabelPaint(this.axisLabelPaint);\n        axis.setTickLabelFont(this.regularFont);\n        axis.setTickLabelPaint(this.tickLabelPaint);\n        if (axis instanceof SubCategoryAxis) {\n            SubCategoryAxis sca \u003d (SubCategoryAxis) axis;\n            sca.setSubLabelFont(this.regularFont);\n            sca.setSubLabelPaint(this.tickLabelPaint);\n        }\n    }\n\n    /**\n     * Applies the attributes for this theme to a {@link ValueAxis}.\n     *\n     * @param axis  the axis ({@code null} not permitted).\n     */\n    protected void applyToValueAxis(ValueAxis axis) {\n        axis.setLabelFont(this.largeFont);\n        axis.setLabelPaint(this.axisLabelPaint);\n        axis.setTickLabelFont(this.regularFont);\n        axis.setTickLabelPaint(this.tickLabelPaint);\n        if (axis instanceof SymbolAxis) {\n            applyToSymbolAxis((SymbolAxis) axis);\n        }\n        if (axis instanceof PeriodAxis) {\n            applyToPeriodAxis((PeriodAxis) axis);\n        }\n    }\n\n    /**\n     * Applies the attributes for this theme to a {@link SymbolAxis}.\n     *\n     * @param axis  the axis ({@code null} not permitted).\n     */\n    protected void applyToSymbolAxis(SymbolAxis axis) {\n        axis.setGridBandPaint(this.gridBandPaint);\n        axis.setGridBandAlternatePaint(this.gridBandAlternatePaint);\n    }\n\n    /**\n     * Applies the attributes for this theme to a {@link PeriodAxis}.\n     *\n     * @param axis  the axis ({@code null} not permitted).\n     */\n    protected void applyToPeriodAxis(PeriodAxis axis) {\n        PeriodAxisLabelInfo[] info \u003d axis.getLabelInfo();\n        for (int i \u003d 0; i \u003c info.length; i++) {\n            PeriodAxisLabelInfo e \u003d info[i];\n            PeriodAxisLabelInfo n \u003d new PeriodAxisLabelInfo(e.getPeriodClass(),\n                    e.getDateFormat(), e.getPadding(), this.regularFont,\n                    this.tickLabelPaint, e.getDrawDividers(),\n                    e.getDividerStroke(), e.getDividerPaint());\n            info[i] \u003d n;\n        }\n        axis.setLabelInfo(info);\n    }\n\n    /**\n     * Applies the attributes for this theme to an {@link AbstractRenderer}.\n     *\n     * @param renderer  the renderer ({@code null} not permitted).\n     */\n    protected void applyToAbstractRenderer(AbstractRenderer renderer) {\n        if (renderer.getAutoPopulateSeriesPaint()) {\n            renderer.clearSeriesPaints(false);\n        }\n        if (renderer.getAutoPopulateSeriesStroke()) {\n            renderer.clearSeriesStrokes(false);\n        }\n    }\n\n    /**\n     * Applies the settings of this theme to the specified renderer.\n     *\n     * @param renderer  the renderer ({@code null} not permitted).\n     */\n    protected void applyToCategoryItemRenderer(CategoryItemRenderer renderer) {\n        Args.nullNotPermitted(renderer, \"renderer\");\n\n        if (renderer instanceof AbstractRenderer) {\n            applyToAbstractRenderer((AbstractRenderer) renderer);\n        }\n\n        renderer.setDefaultItemLabelFont(this.regularFont);\n        renderer.setDefaultItemLabelPaint(this.itemLabelPaint);\n\n        // now we handle some special cases - yes, UGLY code alert!\n\n        // BarRenderer\n        if (renderer instanceof BarRenderer) {\n            BarRenderer br \u003d (BarRenderer) renderer;\n            br.setBarPainter(this.barPainter);\n            br.setShadowVisible(this.shadowVisible);\n            br.setShadowPaint(this.shadowPaint);\n        }\n\n\n        //  StatisticalBarRenderer\n        if (renderer instanceof StatisticalBarRenderer) {\n            StatisticalBarRenderer sbr \u003d (StatisticalBarRenderer) renderer;\n            sbr.setErrorIndicatorPaint(this.errorIndicatorPaint);\n        }\n\n        // MinMaxCategoryRenderer\n        if (renderer instanceof MinMaxCategoryRenderer) {\n            MinMaxCategoryRenderer mmcr \u003d (MinMaxCategoryRenderer) renderer;\n            mmcr.setGroupPaint(this.errorIndicatorPaint);\n        }\n    }\n\n    /**\n     * Applies the settings of this theme to the specified renderer.\n     *\n     * @param renderer  the renderer ({@code null} not permitted).\n     */\n    protected void applyToXYItemRenderer(XYItemRenderer renderer) {\n        Args.nullNotPermitted(renderer, \"renderer\");\n        if (renderer instanceof AbstractRenderer) {\n            applyToAbstractRenderer((AbstractRenderer) renderer);\n        }\n        renderer.setDefaultItemLabelFont(this.regularFont);\n        renderer.setDefaultItemLabelPaint(this.itemLabelPaint);\n        if (renderer instanceof XYBarRenderer) {\n            XYBarRenderer br \u003d (XYBarRenderer) renderer;\n            br.setBarPainter(this.xyBarPainter);\n            br.setShadowVisible(this.shadowVisible);\n        }\n    }\n\n    /**\n     * Applies the settings of this theme to the specified annotation.\n     *\n     * @param annotation  the annotation.\n     */\n    protected void applyToXYAnnotation(XYAnnotation annotation) {\n        Args.nullNotPermitted(annotation, \"annotation\");\n        if (annotation instanceof XYTextAnnotation) {\n            XYTextAnnotation xyta \u003d (XYTextAnnotation) annotation;\n            xyta.setFont(this.smallFont);\n            xyta.setPaint(this.itemLabelPaint);\n        }\n    }\n\n    /**\n     * Tests this theme for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof StandardChartTheme)) {\n            return false;\n        }\n        StandardChartTheme that \u003d (StandardChartTheme) obj;\n        if (!this.name.equals(that.name)) {\n            return false;\n        }\n        if (!this.extraLargeFont.equals(that.extraLargeFont)) {\n            return false;\n        }\n        if (!this.largeFont.equals(that.largeFont)) {\n            return false;\n        }\n        if (!this.regularFont.equals(that.regularFont)) {\n            return false;\n        }\n        if (!this.smallFont.equals(that.smallFont)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.titlePaint, that.titlePaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.subtitlePaint, that.subtitlePaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.chartBackgroundPaint,\n                that.chartBackgroundPaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.legendBackgroundPaint,\n                that.legendBackgroundPaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.legendItemPaint, that.legendItemPaint)) {\n            return false;\n        }\n        if (!this.drawingSupplier.equals(that.drawingSupplier)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.plotBackgroundPaint,\n                that.plotBackgroundPaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.plotOutlinePaint,\n                that.plotOutlinePaint)) {\n            return false;\n        }\n        if (!this.labelLinkStyle.equals(that.labelLinkStyle)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.labelLinkPaint, that.labelLinkPaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.domainGridlinePaint,\n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.rangeGridlinePaint,\n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.crosshairPaint, that.crosshairPaint)) {\n            return false;\n        }\n        if (!this.axisOffset.equals(that.axisOffset)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.axisLabelPaint, that.axisLabelPaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.tickLabelPaint, that.tickLabelPaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.itemLabelPaint, that.itemLabelPaint)) {\n            return false;\n        }\n        if (this.shadowVisible !\u003d that.shadowVisible) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.shadowPaint, that.shadowPaint)) {\n            return false;\n        }\n        if (!this.barPainter.equals(that.barPainter)) {\n            return false;\n        }\n        if (!this.xyBarPainter.equals(that.xyBarPainter)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.thermometerPaint,\n                that.thermometerPaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.errorIndicatorPaint,\n                that.errorIndicatorPaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.gridBandPaint, that.gridBandPaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.gridBandAlternatePaint,\n                that.gridBandAlternatePaint)) {\n            return false;\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int hash \u003d 3;\n        hash \u003d 71 * hash + Objects.hashCode(this.name);\n        hash \u003d 71 * hash + Objects.hashCode(this.extraLargeFont);\n        hash \u003d 71 * hash + Objects.hashCode(this.largeFont);\n        hash \u003d 71 * hash + Objects.hashCode(this.regularFont);\n        hash \u003d 71 * hash + Objects.hashCode(this.smallFont);\n        hash \u003d 71 * hash + Objects.hashCode(this.titlePaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.subtitlePaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.chartBackgroundPaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.legendBackgroundPaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.legendItemPaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.plotBackgroundPaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.plotOutlinePaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.labelLinkStyle);\n        hash \u003d 71 * hash + Objects.hashCode(this.labelLinkPaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.domainGridlinePaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.rangeGridlinePaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.crosshairPaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.axisOffset);\n        hash \u003d 71 * hash + Objects.hashCode(this.axisLabelPaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.tickLabelPaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.itemLabelPaint);\n        hash \u003d 71 * hash + (this.shadowVisible ? 1 : 0);\n        hash \u003d 71 * hash + Objects.hashCode(this.shadowPaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.barPainter);\n        hash \u003d 71 * hash + Objects.hashCode(this.xyBarPainter);\n        hash \u003d 71 * hash + Objects.hashCode(this.thermometerPaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.errorIndicatorPaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.gridBandPaint);\n        hash \u003d 71 * hash + Objects.hashCode(this.gridBandAlternatePaint);\n        return hash;\n    }\n\n    /**\n     * Returns a clone of this theme.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if the theme cannot be cloned.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream ({@code null} not permitted).\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writePaint(this.titlePaint, stream);\n        SerialUtils.writePaint(this.subtitlePaint, stream);\n        SerialUtils.writePaint(this.chartBackgroundPaint, stream);\n        SerialUtils.writePaint(this.legendBackgroundPaint, stream);\n        SerialUtils.writePaint(this.legendItemPaint, stream);\n        SerialUtils.writePaint(this.plotBackgroundPaint, stream);\n        SerialUtils.writePaint(this.plotOutlinePaint, stream);\n        SerialUtils.writePaint(this.labelLinkPaint, stream);\n        SerialUtils.writePaint(this.baselinePaint, stream);\n        SerialUtils.writePaint(this.domainGridlinePaint, stream);\n        SerialUtils.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtils.writePaint(this.crosshairPaint, stream);\n        SerialUtils.writePaint(this.axisLabelPaint, stream);\n        SerialUtils.writePaint(this.tickLabelPaint, stream);\n        SerialUtils.writePaint(this.itemLabelPaint, stream);\n        SerialUtils.writePaint(this.shadowPaint, stream);\n        SerialUtils.writePaint(this.thermometerPaint, stream);\n        SerialUtils.writePaint(this.errorIndicatorPaint, stream);\n        SerialUtils.writePaint(this.gridBandPaint, stream);\n        SerialUtils.writePaint(this.gridBandAlternatePaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream ({@code null} not permitted).\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.titlePaint \u003d SerialUtils.readPaint(stream);\n        this.subtitlePaint \u003d SerialUtils.readPaint(stream);\n        this.chartBackgroundPaint \u003d SerialUtils.readPaint(stream);\n        this.legendBackgroundPaint \u003d SerialUtils.readPaint(stream);\n        this.legendItemPaint \u003d SerialUtils.readPaint(stream);\n        this.plotBackgroundPaint \u003d SerialUtils.readPaint(stream);\n        this.plotOutlinePaint \u003d SerialUtils.readPaint(stream);\n        this.labelLinkPaint \u003d SerialUtils.readPaint(stream);\n        this.baselinePaint \u003d SerialUtils.readPaint(stream);\n        this.domainGridlinePaint \u003d SerialUtils.readPaint(stream);\n        this.rangeGridlinePaint \u003d SerialUtils.readPaint(stream);\n        this.crosshairPaint \u003d SerialUtils.readPaint(stream);\n        this.axisLabelPaint \u003d SerialUtils.readPaint(stream);\n        this.tickLabelPaint \u003d SerialUtils.readPaint(stream);\n        this.itemLabelPaint \u003d SerialUtils.readPaint(stream);\n        this.shadowPaint \u003d SerialUtils.readPaint(stream);\n        this.thermometerPaint \u003d SerialUtils.readPaint(stream);\n        this.errorIndicatorPaint \u003d SerialUtils.readPaint(stream);\n        this.gridBandPaint \u003d SerialUtils.readPaint(stream);\n        this.gridBandAlternatePaint \u003d SerialUtils.readPaint(stream);\n    }\n\n}","methodCount":94,"staticMethodCount":3,"instanceMethodCount":91,"classLoc":1695,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":3,"candidates":[{"lineStart":1133,"lineEnd":1179,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method applyToPlot to class BarPainter","description":"Move method applyToPlot to org.jfree.chart.renderer.category.BarPainter\nRationale: The applyToPlot method involves setting and modifying drawing attributes for various plot types, including bars. The BarPainter interface, which handles painting bars, aligns closely with this functionality. Integrating applyToPlot in BarPainter would enhance cohesion by concentrating all painting-related operations in one place, making it easier to maintain and scale.","couldCreateRefObject":true,"valid":true,"applied":false,"startedRefactoringFlow":true,"undone":false,"userRating":"Unhelpful"},{"lineStart":1216,"lineEnd":1271,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method applyToCategoryPlot to class ShadowGenerator","description":"Move method applyToCategoryPlot to org.jfree.chart.util.ShadowGenerator\nRationale: The method applyToCategoryPlot aligns most closely with the responsibilities of the ShadowGenerator class. Since this method is responsible for applying visual attributes to a CategoryPlot, which includes shadow generation, it fits well within the ShadowGenerator\u0027s purpose of providing appearance-related functionalities. Moving the method to this class will centralize the visual theme application logic, which includes creating and manipulating shadows, making the code more modular and easier to maintain.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Unhelpful"},{"lineStart":1494,"lineEnd":1531,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method applyToCategoryItemRenderer to class CategoryItemRenderer","description":"Move method applyToCategoryItemRenderer to org.jfree.chart.renderer.category.CategoryItemRenderer\nRationale: The method `applyToCategoryItemRenderer` directly involves various implementations of the `CategoryItemRenderer` interface, such as `BarRenderer`, `StatisticalBarRenderer`, and `MinMaxCategoryRenderer`. Since this method is concerned with setting up renderers - specifically renderers that implement the `CategoryItemRenderer` - it is logical to move this method to the `CategoryItemRenderer` class itself. This class already deals extensively with renderer settings, item labels, paints, and other attributes pertinent to renderers. Thus, centralizing the theme application method there enhances coherence and encapsulation, making it easier to maintain and understand.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false,"userRating":"Somewhat Unhelpful"}]},"userSelectionTelemetryData":{"lineStart":1494,"lineEnd":1531,"functionSize":38,"positionInHostFunction":1392,"selectedCandidateIndex":2,"candidateType":"AS_IS","elementsType":[{"elementType":"METHOD","quantity":1}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":74009},{"candidateIndex":1,"elapsedTime":13541},{"candidateIndex":2,"elapsedTime":154623}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":104150},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"applyToBlockContainer","method_signature":"protected applyToBlockContainer(BlockContainer bc)","target_class":"","rationale":""},{"method_name":"applyToPlot","method_signature":"protected applyToPlot(Plot plot)","target_class":"","rationale":""},{"method_name":"applyToPiePlot","method_signature":"protected applyToPiePlot(PiePlot plot)","target_class":"","rationale":""},{"method_name":"applyToMultiplePiePlot","method_signature":"protected applyToMultiplePiePlot(MultiplePiePlot plot)","target_class":"","rationale":""},{"method_name":"applyToCategoryPlot","method_signature":"protected applyToCategoryPlot(CategoryPlot plot)","target_class":"","rationale":""},{"method_name":"applyToFastScatterPlot","method_signature":"protected applyToFastScatterPlot(FastScatterPlot plot)","target_class":"","rationale":""},{"method_name":"applyToPolarPlot","method_signature":"protected applyToPolarPlot(PolarPlot plot)","target_class":"","rationale":""},{"method_name":"applyToSpiderWebPlot","method_signature":"protected applyToSpiderWebPlot(SpiderWebPlot plot)","target_class":"","rationale":""},{"method_name":"applyToMeterPlot","method_signature":"protected applyToMeterPlot(MeterPlot plot)","target_class":"","rationale":""},{"method_name":"applyToThermometerPlot","method_signature":"protected applyToThermometerPlot(ThermometerPlot plot)","target_class":"","rationale":""},{"method_name":"applyToCategoryAxis","method_signature":"protected applyToCategoryAxis(CategoryAxis axis)","target_class":"","rationale":""},{"method_name":"applyToValueAxis","method_signature":"protected applyToValueAxis(ValueAxis axis)","target_class":"","rationale":""},{"method_name":"applyToSymbolAxis","method_signature":"protected applyToSymbolAxis(SymbolAxis axis)","target_class":"","rationale":""},{"method_name":"applyToPeriodAxis","method_signature":"protected applyToPeriodAxis(PeriodAxis axis)","target_class":"","rationale":""},{"method_name":"applyToAbstractRenderer","method_signature":"protected applyToAbstractRenderer(AbstractRenderer renderer)","target_class":"","rationale":""},{"method_name":"applyToCategoryItemRenderer","method_signature":"protected applyToCategoryItemRenderer(CategoryItemRenderer renderer)","target_class":"","rationale":""},{"method_name":"applyToXYItemRenderer","method_signature":"protected applyToXYItemRenderer(XYItemRenderer renderer)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"applyToPlot","method_signature":"protected applyToPlot(Plot plot)","target_class":"","rationale":""},{"method_name":"applyToCategoryPlot","method_signature":"protected applyToCategoryPlot(CategoryPlot plot)","target_class":"","rationale":""},{"method_name":"applyToCategoryItemRenderer","method_signature":"protected applyToCategoryItemRenderer(CategoryItemRenderer renderer)","target_class":"","rationale":""},{"method_name":"applyToPeriodAxis","method_signature":"protected applyToPeriodAxis(PeriodAxis axis)","target_class":"","rationale":""},{"method_name":"applyToMeterPlot","method_signature":"protected applyToMeterPlot(MeterPlot plot)","target_class":"","rationale":""},{"method_name":"applyToValueAxis","method_signature":"protected applyToValueAxis(ValueAxis axis)","target_class":"","rationale":""},{"method_name":"applyToSpiderWebPlot","method_signature":"protected applyToSpiderWebPlot(SpiderWebPlot plot)","target_class":"","rationale":""},{"method_name":"applyToPiePlot","method_signature":"protected applyToPiePlot(PiePlot plot)","target_class":"","rationale":""},{"method_name":"applyToXYItemRenderer","method_signature":"protected applyToXYItemRenderer(XYItemRenderer renderer)","target_class":"","rationale":""},{"method_name":"applyToSymbolAxis","method_signature":"protected applyToSymbolAxis(SymbolAxis axis)","target_class":"","rationale":""},{"method_name":"applyToMultiplePiePlot","method_signature":"protected applyToMultiplePiePlot(MultiplePiePlot plot)","target_class":"","rationale":""},{"method_name":"applyToBlockContainer","method_signature":"protected applyToBlockContainer(BlockContainer bc)","target_class":"","rationale":""},{"method_name":"applyToFastScatterPlot","method_signature":"protected applyToFastScatterPlot(FastScatterPlot plot)","target_class":"","rationale":""},{"method_name":"applyToCategoryAxis","method_signature":"protected applyToCategoryAxis(CategoryAxis axis)","target_class":"","rationale":""},{"method_name":"applyToAbstractRenderer","method_signature":"protected applyToAbstractRenderer(AbstractRenderer renderer)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"protected applyToPlot(Plot plot)":{"first":{"method_name":"applyToPlot","method_signature":"protected applyToPlot(Plot plot)","target_class":"","rationale":""},"second":0.43335447428956114},"protected applyToCategoryPlot(CategoryPlot plot)":{"first":{"method_name":"applyToCategoryPlot","method_signature":"protected applyToCategoryPlot(CategoryPlot plot)","target_class":"","rationale":""},"second":0.5605725434955385},"protected applyToCategoryItemRenderer(CategoryItemRenderer renderer)":{"first":{"method_name":"applyToCategoryItemRenderer","method_signature":"protected applyToCategoryItemRenderer(CategoryItemRenderer renderer)","target_class":"","rationale":""},"second":0.5717208640576393},"protected applyToPeriodAxis(PeriodAxis axis)":{"first":{"method_name":"applyToPeriodAxis","method_signature":"protected applyToPeriodAxis(PeriodAxis axis)","target_class":"","rationale":""},"second":0.6356280130831281},"protected applyToMeterPlot(MeterPlot plot)":{"first":{"method_name":"applyToMeterPlot","method_signature":"protected applyToMeterPlot(MeterPlot plot)","target_class":"","rationale":""},"second":0.649484366495219},"protected applyToValueAxis(ValueAxis axis)":{"first":{"method_name":"applyToValueAxis","method_signature":"protected applyToValueAxis(ValueAxis axis)","target_class":"","rationale":""},"second":0.6678797319281813},"protected applyToSpiderWebPlot(SpiderWebPlot plot)":{"first":{"method_name":"applyToSpiderWebPlot","method_signature":"protected applyToSpiderWebPlot(SpiderWebPlot plot)","target_class":"","rationale":""},"second":0.6797061260861798},"protected applyToPiePlot(PiePlot plot)":{"first":{"method_name":"applyToPiePlot","method_signature":"protected applyToPiePlot(PiePlot plot)","target_class":"","rationale":""},"second":0.682713957764455},"protected applyToXYItemRenderer(XYItemRenderer renderer)":{"first":{"method_name":"applyToXYItemRenderer","method_signature":"protected applyToXYItemRenderer(XYItemRenderer renderer)","target_class":"","rationale":""},"second":0.6831590851533244},"protected applyToSymbolAxis(SymbolAxis axis)":{"first":{"method_name":"applyToSymbolAxis","method_signature":"protected applyToSymbolAxis(SymbolAxis axis)","target_class":"","rationale":""},"second":0.6892976127710734},"protected applyToMultiplePiePlot(MultiplePiePlot plot)":{"first":{"method_name":"applyToMultiplePiePlot","method_signature":"protected applyToMultiplePiePlot(MultiplePiePlot plot)","target_class":"","rationale":""},"second":0.6962617838038051},"protected applyToBlockContainer(BlockContainer bc)":{"first":{"method_name":"applyToBlockContainer","method_signature":"protected applyToBlockContainer(BlockContainer bc)","target_class":"","rationale":""},"second":0.6989880804893643},"protected applyToFastScatterPlot(FastScatterPlot plot)":{"first":{"method_name":"applyToFastScatterPlot","method_signature":"protected applyToFastScatterPlot(FastScatterPlot plot)","target_class":"","rationale":""},"second":0.7030750560808411},"protected applyToCategoryAxis(CategoryAxis axis)":{"first":{"method_name":"applyToCategoryAxis","method_signature":"protected applyToCategoryAxis(CategoryAxis axis)","target_class":"","rationale":""},"second":0.7034848513018955},"protected applyToAbstractRenderer(AbstractRenderer renderer)":{"first":{"method_name":"applyToAbstractRenderer","method_signature":"protected applyToAbstractRenderer(AbstractRenderer renderer)","target_class":"","rationale":""},"second":0.7197542939227509}},"targetClassMap":{"applyToPlot":{"target_classes":[{"class_name":"DrawingSupplier","similarity_score":0.14114745420426947},{"class_name":"BarPainter","similarity_score":0.15434317254922725},{"class_name":"XYBarPainter","similarity_score":0.15434317254922725},{"class_name":"ShadowGenerator","similarity_score":0.17329964788974322}],"target_classes_sorted_by_llm":["BarPainter","XYBarPainter","ShadowGenerator"],"llm_response_time":6223,"similarity_computation_time":9,"similarity_metric":"cosine"},"applyToCategoryPlot":{"target_classes":[{"class_name":"DrawingSupplier","similarity_score":0.1419992674536708},{"class_name":"BarPainter","similarity_score":0.18975175410000636},{"class_name":"XYBarPainter","similarity_score":0.18975175410000636},{"class_name":"ShadowGenerator","similarity_score":0.20071495464747274}],"target_classes_sorted_by_llm":["ShadowGenerator","BarPainter","XYBarPainter"],"llm_response_time":8047,"similarity_computation_time":1,"similarity_metric":"cosine"},"applyToCategoryItemRenderer":{"target_classes":[{"class_name":"CategoryItemRenderer","similarity_score":0.3085942895071587},{"class_name":"DrawingSupplier","similarity_score":0.25375016641868336},{"class_name":"BarPainter","similarity_score":0.31739425017609046},{"class_name":"XYBarPainter","similarity_score":0.3118259299975626},{"class_name":"ShadowGenerator","similarity_score":0.3078632190131514}],"target_classes_sorted_by_llm":["CategoryItemRenderer","BarPainter","XYBarPainter"],"llm_response_time":7402,"similarity_computation_time":4,"similarity_metric":"cosine"},"applyToPeriodAxis":{"target_classes":[{"class_name":"DrawingSupplier","similarity_score":0.33142098915397},{"class_name":"BarPainter","similarity_score":0.3961353792103084},{"class_name":"XYBarPainter","similarity_score":0.3961353792103084},{"class_name":"ShadowGenerator","similarity_score":0.40701718986023494}],"target_classes_sorted_by_llm":["XYBarPainter","BarPainter","ShadowGenerator"],"llm_response_time":4924,"similarity_computation_time":2,"similarity_metric":"cosine"},"applyToMeterPlot":{"target_classes":[{"class_name":"DrawingSupplier","similarity_score":0.485130020774557},{"class_name":"BarPainter","similarity_score":0.5533071072115803},{"class_name":"XYBarPainter","similarity_score":0.5533071072115803},{"class_name":"ShadowGenerator","similarity_score":0.5609988156704171}],"target_classes_sorted_by_llm":["BarPainter","XYBarPainter","ShadowGenerator"],"llm_response_time":7244,"similarity_computation_time":1,"similarity_metric":"cosine"},"applyToValueAxis":{"target_classes":[{"class_name":"DrawingSupplier","similarity_score":0.38026217959816094},{"class_name":"BarPainter","similarity_score":0.43836324198602433},{"class_name":"XYBarPainter","similarity_score":0.43836324198602433},{"class_name":"ShadowGenerator","similarity_score":0.4540267270442151}],"target_classes_sorted_by_llm":["BarPainter","XYBarPainter","ShadowGenerator"],"llm_response_time":12751,"similarity_computation_time":1,"similarity_metric":"cosine"},"applyToSpiderWebPlot":{"target_classes":[{"class_name":"DrawingSupplier","similarity_score":0.5077061463702446},{"class_name":"BarPainter","similarity_score":0.5790559378558914},{"class_name":"XYBarPainter","similarity_score":0.5790559378558914},{"class_name":"ShadowGenerator","similarity_score":0.587105589482077}],"target_classes_sorted_by_llm":["BarPainter","XYBarPainter","ShadowGenerator"],"llm_response_time":5489,"similarity_computation_time":0,"similarity_metric":"cosine"},"applyToPiePlot":{"target_classes":[{"class_name":"DrawingSupplier","similarity_score":0.47704181619912706},{"class_name":"BarPainter","similarity_score":0.589196649311379},{"class_name":"XYBarPainter","similarity_score":0.589196649311379},{"class_name":"ShadowGenerator","similarity_score":0.5591196546738075}],"target_classes_sorted_by_llm":["ShadowGenerator","XYBarPainter","BarPainter"],"llm_response_time":5116,"similarity_computation_time":1,"similarity_metric":"cosine"},"applyToXYItemRenderer":{"target_classes":[{"class_name":"XYItemRenderer","similarity_score":0.48640699861328207},{"class_name":"DrawingSupplier","similarity_score":0.39100788954727456},{"class_name":"BarPainter","similarity_score":0.4864828448317238},{"class_name":"XYBarPainter","similarity_score":0.49090541614837585},{"class_name":"ShadowGenerator","similarity_score":0.46831156571143295}],"target_classes_sorted_by_llm":["XYItemRenderer","XYBarPainter","BarPainter"],"llm_response_time":7438,"similarity_computation_time":8,"similarity_metric":"cosine"},"applyToSymbolAxis":{"target_classes":[{"class_name":"DrawingSupplier","similarity_score":0.5138603849630473},{"class_name":"BarPainter","similarity_score":0.5956828417538632},{"class_name":"XYBarPainter","similarity_score":0.5956828417538632},{"class_name":"ShadowGenerator","similarity_score":0.6062267712265911}],"target_classes_sorted_by_llm":["BarPainter","XYBarPainter","ShadowGenerator"],"llm_response_time":6156,"similarity_computation_time":1,"similarity_metric":"cosine"},"applyToMultiplePiePlot":{"target_classes":[{"class_name":"MultiplePiePlot","similarity_score":0.624807382152508},{"class_name":"DrawingSupplier","similarity_score":0.5202439885430974},{"class_name":"PieLabelLinkStyle","similarity_score":0.42817441928883754},{"class_name":"RectangleInsets","similarity_score":0.5931951441064403},{"class_name":"BarPainter","similarity_score":0.5933557685945879},{"class_name":"XYBarPainter","similarity_score":0.5933557685945879},{"class_name":"ShadowGenerator","similarity_score":0.6016042069842531}],"target_classes_sorted_by_llm":["MultiplePiePlot","ShadowGenerator","BarPainter"],"llm_response_time":7138,"similarity_computation_time":5,"similarity_metric":"cosine"},"applyToBlockContainer":{"target_classes":[{"class_name":"DrawingSupplier","similarity_score":0.47798214806385336},{"class_name":"BarPainter","similarity_score":0.5597142728959406},{"class_name":"XYBarPainter","similarity_score":0.5597142728959406},{"class_name":"ShadowGenerator","similarity_score":0.5652674822065897}],"target_classes_sorted_by_llm":["XYBarPainter","BarPainter","ShadowGenerator"],"llm_response_time":4776,"similarity_computation_time":1,"similarity_metric":"cosine"},"applyToFastScatterPlot":{"target_classes":[{"class_name":"DrawingSupplier","similarity_score":0.3665955728590355},{"class_name":"BarPainter","similarity_score":0.4159357199480222},{"class_name":"XYBarPainter","similarity_score":0.4159357199480222},{"class_name":"ShadowGenerator","similarity_score":0.429371710799951}],"target_classes_sorted_by_llm":["XYBarPainter","BarPainter","ShadowGenerator"],"llm_response_time":5839,"similarity_computation_time":1,"similarity_metric":"cosine"},"applyToCategoryAxis":{"target_classes":[{"class_name":"DrawingSupplier","similarity_score":0.4305567227629434},{"class_name":"BarPainter","similarity_score":0.4977099223512029},{"class_name":"XYBarPainter","similarity_score":0.4977099223512029},{"class_name":"ShadowGenerator","similarity_score":0.5110545569864748}],"target_classes_sorted_by_llm":["BarPainter","XYBarPainter","ShadowGenerator"],"llm_response_time":5619,"similarity_computation_time":1,"similarity_metric":"cosine"},"applyToAbstractRenderer":{"target_classes":[{"class_name":"AbstractRenderer","similarity_score":0.6557506282182058},{"class_name":"DrawingSupplier","similarity_score":0.40326032357621344},{"class_name":"PieLabelLinkStyle","similarity_score":0.41871789467931186},{"class_name":"RectangleInsets","similarity_score":0.6019939335422758},{"class_name":"BarPainter","similarity_score":0.49088233197155356},{"class_name":"XYBarPainter","similarity_score":0.49088233197155356},{"class_name":"ShadowGenerator","similarity_score":0.5084224159378351}],"target_classes_sorted_by_llm":["AbstractRenderer","RectangleInsets","ShadowGenerator"],"llm_response_time":8740,"similarity_computation_time":21,"similarity_metric":"cosine"}}}
{"id":"1b051dbb-831e-4349-8fe6-62a1edee0761","hostFunctionTelemetryData":{"hostFunctionSize":1744,"lineStart":78,"lineEnd":1821,"bodyLineStart":78,"language":"java","filePath":"/Users/snehil/Documents/ConcordiaUniversity/Material/SOEN-6491-Refactoring/OpenSource/jfreechart/jfreechart/src/main/java/org/jfree/chart/axis/DateAxis.java","sourceCode":"/**\n * The base class for axes that display dates.  You will find it easier to\n * understand how this axis works if you bear in mind that it really\n * displays/measures integer (or long) data, where the integers are\n * milliseconds since midnight, 1-Jan-1970.  When displaying tick labels, the\n * millisecond values are converted back to dates using a {@code DateFormat} \n * instance.\n * \u003cP\u003e\n * You can also create a {@link org.jfree.chart.axis.Timeline} and supply in\n * the constructor to create an axis that only contains certain domain values.\n * For example, this allows you to create a date axis that only contains\n * working days.\n */\npublic class DateAxis extends ValueAxis implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -1013460999649007604L;\n\n    /** The default axis range. */\n    public static final DateRange DEFAULT_DATE_RANGE \u003d new DateRange();\n\n    /** The default minimum auto range size. */\n    public static final double\n            DEFAULT_AUTO_RANGE_MINIMUM_SIZE_IN_MILLISECONDS \u003d 2.0;\n\n    /** The default anchor date. */\n    public static final Date DEFAULT_ANCHOR_DATE \u003d new Date();\n\n    /** The current tick unit. */\n    private DateTickUnit tickUnit;\n\n    /** The override date format. */\n    private DateFormat dateFormatOverride;\n\n    /**\n     * Tick marks can be displayed at the start or the middle of the time\n     * period.\n     */\n    private DateTickMarkPosition tickMarkPosition \u003d DateTickMarkPosition.START;\n\n    /**\n     * A timeline that includes all milliseconds (as defined by\n     * {@code java.util.Date}) in the real time line.\n     */\n    private static class DefaultTimeline implements Timeline, Serializable {\n\n        /**\n         * Converts a millisecond into a timeline value.\n         *\n         * @param millisecond  the millisecond.\n         *\n         * @return The timeline value.\n         */\n        @Override\n        public long toTimelineValue(long millisecond) {\n            return millisecond;\n        }\n\n        /**\n         * Converts a date into a timeline value.\n         *\n         * @param date  the domain value.\n         *\n         * @return The timeline value.\n         */\n        @Override\n        public long toTimelineValue(Date date) {\n            return date.getTime();\n        }\n\n        /**\n         * Converts a timeline value into a millisecond (as encoded by\n         * {@code java.util.Date}).\n         *\n         * @param value  the value.\n         *\n         * @return The millisecond.\n         */\n        @Override\n        public long toMillisecond(long value) {\n            return value;\n        }\n\n        /**\n         * Returns {@code true} if the timeline includes the specified\n         * domain value.\n         *\n         * @param millisecond  the millisecond.\n         *\n         * @return {@code true}.\n         */\n        @Override\n        public boolean containsDomainValue(long millisecond) {\n            return true;\n        }\n\n        /**\n         * Returns {@code true} if the timeline includes the specified\n         * domain value.\n         *\n         * @param date  the date.\n         *\n         * @return {@code true}.\n         */\n        @Override\n        public boolean containsDomainValue(Date date) {\n            return true;\n        }\n\n        /**\n         * Returns {@code true} if the timeline includes the specified\n         * domain value range.\n         *\n         * @param from  the start value.\n         * @param to  the end value.\n         *\n         * @return {@code true}.\n         */\n        @Override\n        public boolean containsDomainRange(long from, long to) {\n            return true;\n        }\n\n        /**\n         * Returns {@code true} if the timeline includes the specified\n         * domain value range.\n         *\n         * @param from  the start date.\n         * @param to  the end date.\n         *\n         * @return {@code true}.\n         */\n        @Override\n        public boolean containsDomainRange(Date from, Date to) {\n            return true;\n        }\n\n        /**\n         * Tests an object for equality with this instance.\n         *\n         * @param object  the object.\n         *\n         * @return A boolean.\n         */\n        @Override\n        public boolean equals(Object object) {\n            if (object \u003d\u003d null) {\n                return false;\n            }\n            if (object \u003d\u003d this) {\n                return true;\n            }\n            if (object instanceof DefaultTimeline) {\n                return true;\n            }\n            return false;\n        }\n    }\n\n    /** A static default timeline shared by all standard DateAxis */\n    private static final Timeline DEFAULT_TIMELINE \u003d new DefaultTimeline();\n\n    /** The time zone for the axis. */\n    private TimeZone timeZone;\n\n    /**\n     * The locale for the axis ({@code null} is not permitted).\n     */\n    private Locale locale;\n\n    /** Our underlying timeline. */\n    private Timeline timeline;\n\n    /**\n     * Creates a date axis with no label.\n     */\n    public DateAxis() {\n        this(null);\n    }\n\n    /**\n     * Creates a date axis with the specified label.\n     *\n     * @param label  the axis label ({@code null} permitted).\n     */\n    public DateAxis(String label) {\n        this(label, TimeZone.getDefault(), Locale.getDefault());\n    }\n\n    /**\n     * Creates a date axis.\n     *\n     * @param label  the axis label ({@code null} permitted).\n     * @param zone  the time zone.\n     * @param locale  the locale ({@code null} not permitted).\n     */\n    public DateAxis(String label, TimeZone zone, Locale locale) {\n        super(label, DateAxis.createStandardDateTickUnits(zone, locale));\n        this.tickUnit \u003d new DateTickUnit(DateTickUnitType.DAY, 1, \n                new SimpleDateFormat());\n        setAutoRangeMinimumSize(\n                DEFAULT_AUTO_RANGE_MINIMUM_SIZE_IN_MILLISECONDS);\n        setRange(DEFAULT_DATE_RANGE, false, false);\n        this.dateFormatOverride \u003d null;\n        this.timeZone \u003d zone;\n        this.locale \u003d locale;\n        this.timeline \u003d DEFAULT_TIMELINE;\n    }\n\n    /**\n     * Returns the time zone for the axis.\n     *\n     * @return The time zone (never {@code null}).\n     *\n     * @see #setTimeZone(TimeZone)\n     */\n    public TimeZone getTimeZone() {\n        return this.timeZone;\n    }\n\n    /**\n     * Sets the time zone for the axis and sends an {@link AxisChangeEvent} to\n     * all registered listeners.\n     *\n     * @param zone  the time zone ({@code null} not permitted).\n     *\n     * @see #getTimeZone()\n     */\n    public void setTimeZone(TimeZone zone) {\n        Args.nullNotPermitted(zone, \"zone\");\n        this.timeZone \u003d zone;\n        setStandardTickUnits(createStandardDateTickUnits(zone, this.locale));\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the locale for this axis.\n     * \n     * @return The locale (never {@code null}).\n     */\n    public Locale getLocale() {\n        return this.locale;\n    }\n    \n    /**\n     * Sets the locale for the axis and sends a change event to all registered \n     * listeners.\n     * \n     * @param locale  the new locale ({@code null} not permitted).\n     */\n    public void setLocale(Locale locale) {\n        Args.nullNotPermitted(locale, \"locale\");\n        this.locale \u003d locale;\n        setStandardTickUnits(createStandardDateTickUnits(this.timeZone, \n                this.locale));\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the underlying timeline used by this axis.\n     *\n     * @return The timeline.\n     */\n    public Timeline getTimeline() {\n        return this.timeline;\n    }\n\n    /**\n     * Sets the underlying timeline to use for this axis.  If the timeline is \n     * changed, an {@link AxisChangeEvent} is sent to all registered listeners.\n     *\n     * @param timeline  the timeline.\n     */\n    public void setTimeline(Timeline timeline) {\n        if (this.timeline !\u003d timeline) {\n            this.timeline \u003d timeline;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the tick unit for the axis.\n     * \u003cp\u003e\n     * Note: if the {@code autoTickUnitSelection} flag is\n     * {@code true} the tick unit may be changed while the axis is being\n     * drawn, so in that case the return value from this method may be\n     * irrelevant if the method is called before the axis has been drawn.\n     *\n     * @return The tick unit (possibly {@code null}).\n     *\n     * @see #setTickUnit(DateTickUnit)\n     * @see ValueAxis#isAutoTickUnitSelection()\n     */\n    public DateTickUnit getTickUnit() {\n        return this.tickUnit;\n    }\n\n    /**\n     * Sets the tick unit for the axis.  The auto-tick-unit-selection flag is\n     * set to {@code false}, and registered listeners are notified that\n     * the axis has been changed.\n     *\n     * @param unit  the tick unit.\n     *\n     * @see #getTickUnit()\n     * @see #setTickUnit(DateTickUnit, boolean, boolean)\n     */\n    public void setTickUnit(DateTickUnit unit) {\n        setTickUnit(unit, true, true);\n    }\n\n    /**\n     * Sets the tick unit attribute and, if requested, sends an \n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param unit  the new tick unit.\n     * @param notify  notify registered listeners?\n     * @param turnOffAutoSelection  turn off auto selection?\n     *\n     * @see #getTickUnit()\n     */\n    public void setTickUnit(DateTickUnit unit, boolean notify,\n                            boolean turnOffAutoSelection) {\n\n        this.tickUnit \u003d unit;\n        if (turnOffAutoSelection) {\n            setAutoTickUnitSelection(false, false);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n\n    }\n\n    /**\n     * Returns the date format override.  If this is non-null, then it will be\n     * used to format the dates on the axis.\n     *\n     * @return The formatter (possibly {@code null}).\n     */\n    public DateFormat getDateFormatOverride() {\n        return this.dateFormatOverride;\n    }\n\n    /**\n     * Sets the date format override and sends an {@link AxisChangeEvent} to \n     * all registered listeners.  If this is non-null, then it will be\n     * used to format the dates on the axis.\n     *\n     * @param formatter  the date formatter ({@code null} permitted).\n     */\n    public void setDateFormatOverride(DateFormat formatter) {\n        this.dateFormatOverride \u003d formatter;\n        fireChangeEvent();\n    }\n\n    /**\n     * Sets the upper and lower bounds for the axis and sends an\n     * {@link AxisChangeEvent} to all registered listeners.  As a side-effect,\n     * the auto-range flag is set to false.\n     *\n     * @param range  the new range ({@code null} not permitted).\n     */\n    @Override\n    public void setRange(Range range) {\n        setRange(range, true, true);\n    }\n\n    /**\n     * Sets the range for the axis, if requested, sends an\n     * {@link AxisChangeEvent} to all registered listeners.  As a side-effect,\n     * the auto-range flag is set to {@code false} (optional).\n     *\n     * @param range  the range ({@code null} not permitted).\n     * @param turnOffAutoRange  a flag that controls whether or not the auto\n     *                          range is turned off.\n     * @param notify  a flag that controls whether or not listeners are\n     *                notified.\n     */\n    @Override\n    public void setRange(Range range, boolean turnOffAutoRange,\n                         boolean notify) {\n        Args.nullNotPermitted(range, \"range\");\n        // usually the range will be a DateRange, but if it isn\u0027t do a\n        // conversion...\n        if (!(range instanceof DateRange)) {\n            range \u003d new DateRange(range);\n        }\n        super.setRange(range, turnOffAutoRange, notify);\n    }\n\n    /**\n     * Sets the axis range and sends an {@link AxisChangeEvent} to all\n     * registered listeners.\n     *\n     * @param lower  the lower bound for the axis.\n     * @param upper  the upper bound for the axis.\n     */\n    public void setRange(Date lower, Date upper) {\n        if (lower.getTime() \u003e\u003d upper.getTime()) {\n            throw new IllegalArgumentException(\"Requires \u0027lower\u0027 \u003c \u0027upper\u0027.\");\n        }\n        setRange(new DateRange(lower, upper));\n    }\n\n    /**\n     * Sets the axis range and sends an {@link AxisChangeEvent} to all\n     * registered listeners.\n     *\n     * @param lower  the lower bound for the axis.\n     * @param upper  the upper bound for the axis.\n     */\n    @Override\n    public void setRange(double lower, double upper) {\n        if (lower \u003e\u003d upper) {\n            throw new IllegalArgumentException(\"Requires \u0027lower\u0027 \u003c \u0027upper\u0027.\");\n        }\n        setRange(new DateRange(lower, upper));\n    }\n\n    /**\n     * Returns the earliest date visible on the axis.\n     *\n     * @return The date.\n     *\n     * @see #setMinimumDate(Date)\n     * @see #getMaximumDate()\n     */\n    public Date getMinimumDate() {\n        Date result;\n        Range range \u003d getRange();\n        if (range instanceof DateRange) {\n            DateRange r \u003d (DateRange) range;\n            result \u003d r.getLowerDate();\n        }\n        else {\n            result \u003d new Date((long) range.getLowerBound());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the minimum date visible on the axis and sends an\n     * {@link AxisChangeEvent} to all registered listeners.  If\n     * {@code date} is on or after the current maximum date for\n     * the axis, the maximum date will be shifted to preserve the current\n     * length of the axis.\n     *\n     * @param date  the date ({@code null} not permitted).\n     *\n     * @see #getMinimumDate()\n     * @see #setMaximumDate(Date)\n     */\n    public void setMinimumDate(Date date) {\n        Args.nullNotPermitted(date, \"date\");\n        // check the new minimum date relative to the current maximum date\n        Date maxDate \u003d getMaximumDate();\n        long maxMillis \u003d maxDate.getTime();\n        long newMinMillis \u003d date.getTime();\n        if (maxMillis \u003c\u003d newMinMillis) {\n            Date oldMin \u003d getMinimumDate();\n            long length \u003d maxMillis - oldMin.getTime();\n            maxDate \u003d new Date(newMinMillis + length);\n        }\n        setRange(new DateRange(date, maxDate), true, false);\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the latest date visible on the axis.\n     *\n     * @return The date.\n     *\n     * @see #setMaximumDate(Date)\n     * @see #getMinimumDate()\n     */\n    public Date getMaximumDate() {\n        Date result;\n        Range range \u003d getRange();\n        if (range instanceof DateRange) {\n            DateRange r \u003d (DateRange) range;\n            result \u003d r.getUpperDate();\n        }\n        else {\n            result \u003d new Date((long) range.getUpperBound());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the maximum date visible on the axis and sends an\n     * {@link AxisChangeEvent} to all registered listeners.  If\n     * {@code maximumDate} is on or before the current minimum date for\n     * the axis, the minimum date will be shifted to preserve the current\n     * length of the axis.\n     *\n     * @param maximumDate  the date ({@code null} not permitted).\n     *\n     * @see #getMinimumDate()\n     * @see #setMinimumDate(Date)\n     */\n    public void setMaximumDate(Date maximumDate) {\n        Args.nullNotPermitted(maximumDate, \"maximumDate\");\n        // check the new maximum date relative to the current minimum date\n        Date minDate \u003d getMinimumDate();\n        long minMillis \u003d minDate.getTime();\n        long newMaxMillis \u003d maximumDate.getTime();\n        if (minMillis \u003e\u003d newMaxMillis) {\n            Date oldMax \u003d getMaximumDate();\n            long length \u003d oldMax.getTime() - minMillis;\n            minDate \u003d new Date(newMaxMillis - length);\n        }\n        setRange(new DateRange(minDate, maximumDate), true, false);\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the tick mark position (start, middle or end of the time period).\n     *\n     * @return The position (never {@code null}).\n     */\n    public DateTickMarkPosition getTickMarkPosition() {\n        return this.tickMarkPosition;\n    }\n\n    /**\n     * Sets the tick mark position (start, middle or end of the time period)\n     * and sends an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param position  the position ({@code null} not permitted).\n     */\n    public void setTickMarkPosition(DateTickMarkPosition position) {\n        Args.nullNotPermitted(position, \"position\");\n        this.tickMarkPosition \u003d position;\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the axis to work with the specified plot.  If the axis has\n     * auto-scaling, then sets the maximum and minimum values.\n     */\n    @Override\n    public void configure() {\n        if (isAutoRange()) {\n            autoAdjustRange();\n        }\n    }\n\n    /**\n     * Returns {@code true} if the axis hides this value, and\n     * {@code false} otherwise.\n     *\n     * @param millis  the data value.\n     *\n     * @return A value.\n     */\n    public boolean isHiddenValue(long millis) {\n        return (!this.timeline.containsDomainValue(new Date(millis)));\n    }\n\n    /**\n     * Translates the data value to the display coordinates (Java 2D User Space)\n     * of the chart.\n     *\n     * @param value  the date to be plotted.\n     * @param area  the rectangle (in Java2D space) where the data is to be\n     *              plotted.\n     * @param edge  the axis location.\n     *\n     * @return The coordinate corresponding to the supplied data value.\n     */\n    @Override\n    public double valueToJava2D(double value, Rectangle2D area,\n            RectangleEdge edge) {\n\n        value \u003d this.timeline.toTimelineValue((long) value);\n\n        DateRange range \u003d (DateRange) getRange();\n        double axisMin \u003d this.timeline.toTimelineValue(range.getLowerMillis());\n        double axisMax \u003d this.timeline.toTimelineValue(range.getUpperMillis());\n        double result \u003d 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            double minX \u003d area.getX();\n            double maxX \u003d area.getMaxX();\n            if (isInverted()) {\n                result \u003d maxX + ((value - axisMin) / (axisMax - axisMin))\n                         * (minX - maxX);\n            }\n            else {\n                result \u003d minX + ((value - axisMin) / (axisMax - axisMin))\n                         * (maxX - minX);\n            }\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            double minY \u003d area.getMinY();\n            double maxY \u003d area.getMaxY();\n            if (isInverted()) {\n                result \u003d minY + (((value - axisMin) / (axisMax - axisMin))\n                         * (maxY - minY));\n            }\n            else {\n                result \u003d maxY - (((value - axisMin) / (axisMax - axisMin))\n                         * (maxY - minY));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Translates a date to Java2D coordinates, based on the range displayed by\n     * this axis for the specified data area.\n     *\n     * @param date  the date.\n     * @param area  the rectangle (in Java2D space) where the data is to be\n     *              plotted.\n     * @param edge  the axis location.\n     *\n     * @return The coordinate corresponding to the supplied date.\n     */\n    public double dateToJava2D(Date date, Rectangle2D area, \n            RectangleEdge edge) {\n        double value \u003d date.getTime();\n        return valueToJava2D(value, area, edge);\n    }\n\n    /**\n     * Translates a Java2D coordinate into the corresponding data value.  To\n     * perform this translation, you need to know the area used for plotting\n     * data, and which edge the axis is located on.\n     *\n     * @param java2DValue  the coordinate in Java2D space.\n     * @param area  the rectangle (in Java2D space) where the data is to be\n     *              plotted.\n     * @param edge  the axis location.\n     *\n     * @return A data value.\n     */\n    @Override\n    public double java2DToValue(double java2DValue, Rectangle2D area, \n            RectangleEdge edge) {\n\n        DateRange range \u003d (DateRange) getRange();\n        double axisMin \u003d this.timeline.toTimelineValue(range.getLowerMillis());\n        double axisMax \u003d this.timeline.toTimelineValue(range.getUpperMillis());\n\n        double min \u003d 0.0;\n        double max \u003d 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            min \u003d area.getX();\n            max \u003d area.getMaxX();\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            min \u003d area.getMaxY();\n            max \u003d area.getY();\n        }\n\n        double result;\n        if (isInverted()) {\n             result \u003d axisMax - ((java2DValue - min) / (max - min)\n                      * (axisMax - axisMin));\n        }\n        else {\n             result \u003d axisMin + ((java2DValue - min) / (max - min)\n                      * (axisMax - axisMin));\n        }\n\n        return this.timeline.toMillisecond((long) result);\n    }\n\n    /**\n     * Calculates the value of the lowest visible tick on the axis.\n     *\n     * @param unit  date unit to use.\n     *\n     * @return The value of the lowest visible tick on the axis.\n     */\n    public Date calculateLowestVisibleTickValue(DateTickUnit unit) {\n        return nextStandardDate(getMinimumDate(), unit);\n    }\n\n    /**\n     * Calculates the value of the highest visible tick on the axis.\n     *\n     * @param unit  date unit to use.\n     *\n     * @return The value of the highest visible tick on the axis.\n     */\n    public Date calculateHighestVisibleTickValue(DateTickUnit unit) {\n        return previousStandardDate(getMaximumDate(), unit);\n    }\n\n    /**\n     * Returns the previous \"standard\" date, for a given date and tick unit.\n     *\n     * @param date  the reference date.\n     * @param unit  the tick unit.\n     *\n     * @return The previous \"standard\" date.\n     */\n    protected Date previousStandardDate(Date date, DateTickUnit unit) {\n\n        int milliseconds;\n        int seconds;\n        int minutes;\n        int hours;\n        int days;\n        int months;\n        int years;\n\n        Calendar calendar \u003d Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int count \u003d unit.getMultiple();\n        int current \u003d calendar.get(unit.getCalendarField());\n        int value \u003d count * (current / count);\n\n        if (DateTickUnitType.MILLISECOND.equals(unit.getUnitType())) {\n            years \u003d calendar.get(Calendar.YEAR);\n            months \u003d calendar.get(Calendar.MONTH);\n            days \u003d calendar.get(Calendar.DATE);\n            hours \u003d calendar.get(Calendar.HOUR_OF_DAY);\n            minutes \u003d calendar.get(Calendar.MINUTE);\n            seconds \u003d calendar.get(Calendar.SECOND);\n            calendar.set(years, months, days, hours, minutes, seconds);\n            calendar.set(Calendar.MILLISECOND, value);\n            Date mm \u003d calendar.getTime();\n            if (mm.getTime() \u003e\u003d date.getTime()) {\n                calendar.set(Calendar.MILLISECOND, value - count);\n                mm \u003d calendar.getTime();\n            }\n            return mm;\n        }\n        else if (DateTickUnitType.SECOND.equals(unit.getUnitType())) {\n            years \u003d calendar.get(Calendar.YEAR);\n            months \u003d calendar.get(Calendar.MONTH);\n            days \u003d calendar.get(Calendar.DATE);\n            hours \u003d calendar.get(Calendar.HOUR_OF_DAY);\n            minutes \u003d calendar.get(Calendar.MINUTE);\n            if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.START) {\n                milliseconds \u003d 0;\n            }\n            else if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.MIDDLE) {\n                milliseconds \u003d 500;\n            }\n            else {\n                milliseconds \u003d 999;\n            }\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n            calendar.set(years, months, days, hours, minutes, value);\n            Date dd \u003d calendar.getTime();\n            if (dd.getTime() \u003e\u003d date.getTime()) {\n                calendar.set(Calendar.SECOND, value - count);\n                dd \u003d calendar.getTime();\n            }\n            return dd;\n        }\n        else if (DateTickUnitType.MINUTE.equals(unit.getUnitType())) {\n            years \u003d calendar.get(Calendar.YEAR);\n            months \u003d calendar.get(Calendar.MONTH);\n            days \u003d calendar.get(Calendar.DATE);\n            hours \u003d calendar.get(Calendar.HOUR_OF_DAY);\n            if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.START) {\n                seconds \u003d 0;\n            }\n            else if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.MIDDLE) {\n                seconds \u003d 30;\n            }\n            else {\n                seconds \u003d 59;\n            }\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, months, days, hours, value, seconds);\n            Date d0 \u003d calendar.getTime();\n            if (d0.getTime() \u003e\u003d date.getTime()) {\n                calendar.set(Calendar.MINUTE, value - count);\n                d0 \u003d calendar.getTime();\n            }\n            return d0;\n        }\n        else if (DateTickUnitType.HOUR.equals(unit.getUnitType())) {\n            years \u003d calendar.get(Calendar.YEAR);\n            months \u003d calendar.get(Calendar.MONTH);\n            days \u003d calendar.get(Calendar.DATE);\n            if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.START) {\n                minutes \u003d 0;\n                seconds \u003d 0;\n            }\n            else if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.MIDDLE) {\n                minutes \u003d 30;\n                seconds \u003d 0;\n            }\n            else {\n                minutes \u003d 59;\n                seconds \u003d 59;\n            }\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, months, days, value, minutes, seconds);\n            Date d1 \u003d calendar.getTime();\n            if (d1.getTime() \u003e\u003d date.getTime()) {\n                calendar.set(Calendar.HOUR_OF_DAY, value - count);\n                d1 \u003d calendar.getTime();\n            }\n            return d1;\n        }\n        else if (DateTickUnitType.DAY.equals(unit.getUnitType())) {\n            years \u003d calendar.get(Calendar.YEAR);\n            months \u003d calendar.get(Calendar.MONTH);\n            if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.START) {\n                hours \u003d 0;\n            }\n            else if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.MIDDLE) {\n                hours \u003d 12;\n            }\n            else {\n                hours \u003d 23;\n            }\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, months, value, hours, 0, 0);\n            // long result \u003d calendar.getTimeInMillis();\n                // won\u0027t work with JDK 1.3\n            Date d2 \u003d calendar.getTime();\n            if (d2.getTime() \u003e\u003d date.getTime()) {\n                calendar.set(Calendar.DATE, value - count);\n                d2 \u003d calendar.getTime();\n            }\n            return d2;\n        }\n        else if (DateTickUnitType.MONTH.equals(unit.getUnitType())) {\n            value \u003d count * ((current + 1) / count) - 1;\n            years \u003d calendar.get(Calendar.YEAR);\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(years, value, 1, 0, 0, 0);\n            Month month \u003d new Month(calendar.getTime(), this.timeZone,\n                    this.locale);\n            Date standardDate \u003d calculateDateForPosition(\n                    month, this.tickMarkPosition);\n            long millis \u003d standardDate.getTime();\n            if (millis \u003e\u003d date.getTime()) {\n                for (int i \u003d 0; i \u003c count; i++) {\n                    month \u003d (Month) month.previous();\n                }\n                // need to peg the month in case the time zone isn\u0027t the\n                // default - see bug 2078057\n                month.peg(Calendar.getInstance(this.timeZone));\n                standardDate \u003d calculateDateForPosition(\n                        month, this.tickMarkPosition);\n            }\n            return standardDate;\n        }\n        else if (DateTickUnitType.YEAR.equals(unit.getUnitType())) {\n            if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.START) {\n                months \u003d 0;\n                days \u003d 1;\n            }\n            else if (this.tickMarkPosition \u003d\u003d DateTickMarkPosition.MIDDLE) {\n                months \u003d 6;\n                days \u003d 1;\n            }\n            else {\n                months \u003d 11;\n                days \u003d 31;\n            }\n            calendar.clear(Calendar.MILLISECOND);\n            calendar.set(value, months, days, 0, 0, 0);\n            Date d3 \u003d calendar.getTime();\n            if (d3.getTime() \u003e\u003d date.getTime()) {\n                calendar.set(Calendar.YEAR, value - count);\n                d3 \u003d calendar.getTime();\n            }\n            return d3;\n        }\n        return null;\n    }\n\n    /**\n     * Returns a {@link java.util.Date} corresponding to the specified position\n     * within a {@link RegularTimePeriod}.\n     *\n     * @param period  the period.\n     * @param position  the position ({@code null} not permitted).\n     *\n     * @return A date.\n     */\n    private Date calculateDateForPosition(RegularTimePeriod period,\n            DateTickMarkPosition position) {\n        Args.nullNotPermitted(period, \"period\");\n        Date result \u003d null;\n        if (position \u003d\u003d DateTickMarkPosition.START) {\n            result \u003d new Date(period.getFirstMillisecond());\n        }\n        else if (position \u003d\u003d DateTickMarkPosition.MIDDLE) {\n            result \u003d new Date(period.getMiddleMillisecond());\n        }\n        else if (position \u003d\u003d DateTickMarkPosition.END) {\n            result \u003d new Date(period.getLastMillisecond());\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the first \"standard\" date (based on the specified field and\n     * units).\n     *\n     * @param date  the reference date.\n     * @param unit  the date tick unit.\n     *\n     * @return The next \"standard\" date.\n     */\n    protected Date nextStandardDate(Date date, DateTickUnit unit) {\n        Date previous \u003d previousStandardDate(date, unit);\n        Calendar calendar \u003d Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(previous);\n        calendar.add(unit.getCalendarField(), unit.getMultiple());\n        return calendar.getTime();\n    }\n\n    /**\n     * Returns a collection of standard date tick units that uses the default\n     * time zone.  This collection will be used by default, but you are free\n     * to create your own collection if you want to (see the\n     * {@link ValueAxis#setStandardTickUnits(TickUnitSource)} method inherited\n     * from the {@link ValueAxis} class).\n     *\n     * @return A collection of standard date tick units.\n     */\n    public static TickUnitSource createStandardDateTickUnits() {\n        return createStandardDateTickUnits(TimeZone.getDefault(),\n                Locale.getDefault());\n    }\n\n    /**\n     * Returns a collection of standard date tick units.  This collection will\n     * be used by default, but you are free to create your own collection if\n     * you want to (see the\n     * {@link ValueAxis#setStandardTickUnits(TickUnitSource)} method inherited\n     * from the {@link ValueAxis} class).\n     *\n     * @param zone  the time zone ({@code null} not permitted).\n     * @param locale  the locale ({@code null} not permitted).\n     *\n     * @return A collection of standard date tick units.\n     */\n    public static TickUnitSource createStandardDateTickUnits(TimeZone zone,\n            Locale locale) {\n\n        Args.nullNotPermitted(zone, \"zone\");\n        Args.nullNotPermitted(locale, \"locale\");\n        TickUnits units \u003d new TickUnits();\n\n        // date formatters\n        DateFormat f1 \u003d new SimpleDateFormat(\"HH:mm:ss.SSS\", locale);\n        DateFormat f2 \u003d new SimpleDateFormat(\"HH:mm:ss\", locale);\n        DateFormat f3 \u003d new SimpleDateFormat(\"HH:mm\", locale);\n        DateFormat f4 \u003d new SimpleDateFormat(\"d-MMM, HH:mm\", locale);\n        DateFormat f5 \u003d new SimpleDateFormat(\"d-MMM\", locale);\n        DateFormat f6 \u003d new SimpleDateFormat(\"MMM-yyyy\", locale);\n        DateFormat f7 \u003d new SimpleDateFormat(\"yyyy\", locale);\n\n        f1.setTimeZone(zone);\n        f2.setTimeZone(zone);\n        f3.setTimeZone(zone);\n        f4.setTimeZone(zone);\n        f5.setTimeZone(zone);\n        f6.setTimeZone(zone);\n        f7.setTimeZone(zone);\n\n        // milliseconds\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 1, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 5,\n                DateTickUnitType.MILLISECOND, 1, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 10,\n                DateTickUnitType.MILLISECOND, 1, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 25,\n                DateTickUnitType.MILLISECOND, 5, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 50,\n                DateTickUnitType.MILLISECOND, 10, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 100,\n                DateTickUnitType.MILLISECOND, 10, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 250,\n                DateTickUnitType.MILLISECOND, 10, f1));\n        units.add(new DateTickUnit(DateTickUnitType.MILLISECOND, 500,\n                DateTickUnitType.MILLISECOND, 50, f1));\n\n        // seconds\n        units.add(new DateTickUnit(DateTickUnitType.SECOND, 1,\n                DateTickUnitType.MILLISECOND, 50, f2));\n        units.add(new DateTickUnit(DateTickUnitType.SECOND, 5,\n                DateTickUnitType.SECOND, 1, f2));\n        units.add(new DateTickUnit(DateTickUnitType.SECOND, 10,\n                DateTickUnitType.SECOND, 1, f2));\n        units.add(new DateTickUnit(DateTickUnitType.SECOND, 30,\n                DateTickUnitType.SECOND, 5, f2));\n\n        // minutes\n        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 1,\n                DateTickUnitType.SECOND, 5, f3));\n        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 2,\n                DateTickUnitType.SECOND, 10, f3));\n        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 5,\n                DateTickUnitType.MINUTE, 1, f3));\n        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 10,\n                DateTickUnitType.MINUTE, 1, f3));\n        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 15,\n                DateTickUnitType.MINUTE, 5, f3));\n        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 20,\n                DateTickUnitType.MINUTE, 5, f3));\n        units.add(new DateTickUnit(DateTickUnitType.MINUTE, 30,\n                DateTickUnitType.MINUTE, 5, f3));\n\n        // hours\n        units.add(new DateTickUnit(DateTickUnitType.HOUR, 1,\n                DateTickUnitType.MINUTE, 5, f3));\n        units.add(new DateTickUnit(DateTickUnitType.HOUR, 2,\n                DateTickUnitType.MINUTE, 10, f3));\n        units.add(new DateTickUnit(DateTickUnitType.HOUR, 4,\n                DateTickUnitType.MINUTE, 30, f3));\n        units.add(new DateTickUnit(DateTickUnitType.HOUR, 6,\n                DateTickUnitType.HOUR, 1, f3));\n        units.add(new DateTickUnit(DateTickUnitType.HOUR, 12,\n                DateTickUnitType.HOUR, 1, f4));\n\n        // days\n        units.add(new DateTickUnit(DateTickUnitType.DAY, 1,\n                DateTickUnitType.HOUR, 1, f5));\n        units.add(new DateTickUnit(DateTickUnitType.DAY, 2,\n                DateTickUnitType.HOUR, 1, f5));\n        units.add(new DateTickUnit(DateTickUnitType.DAY, 7,\n                DateTickUnitType.DAY, 1, f5));\n        units.add(new DateTickUnit(DateTickUnitType.DAY, 15,\n                DateTickUnitType.DAY, 1, f5));\n\n        // months\n        units.add(new DateTickUnit(DateTickUnitType.MONTH, 1,\n                DateTickUnitType.DAY, 1, f6));\n        units.add(new DateTickUnit(DateTickUnitType.MONTH, 2,\n                DateTickUnitType.DAY, 1, f6));\n        units.add(new DateTickUnit(DateTickUnitType.MONTH, 3,\n                DateTickUnitType.MONTH, 1, f6));\n        units.add(new DateTickUnit(DateTickUnitType.MONTH, 4,\n                DateTickUnitType.MONTH, 1, f6));\n        units.add(new DateTickUnit(DateTickUnitType.MONTH, 6,\n                DateTickUnitType.MONTH, 1, f6));\n\n        // years\n        units.add(new DateTickUnit(DateTickUnitType.YEAR, 1,\n                DateTickUnitType.MONTH, 1, f7));\n        units.add(new DateTickUnit(DateTickUnitType.YEAR, 2,\n                DateTickUnitType.MONTH, 3, f7));\n        units.add(new DateTickUnit(DateTickUnitType.YEAR, 5,\n                DateTickUnitType.YEAR, 1, f7));\n        units.add(new DateTickUnit(DateTickUnitType.YEAR, 10,\n                DateTickUnitType.YEAR, 1, f7));\n        units.add(new DateTickUnit(DateTickUnitType.YEAR, 25,\n                DateTickUnitType.YEAR, 5, f7));\n        units.add(new DateTickUnit(DateTickUnitType.YEAR, 50,\n                DateTickUnitType.YEAR, 10, f7));\n        units.add(new DateTickUnit(DateTickUnitType.YEAR, 100,\n                DateTickUnitType.YEAR, 20, f7));\n\n        return units;\n\n    }\n\n    /**\n     * Rescales the axis to ensure that all data is visible.\n     */\n    @Override\n    protected void autoAdjustRange() {\n\n        Plot plot \u003d getPlot();\n\n        if (plot \u003d\u003d null) {\n            return;  // no plot, no data\n        }\n\n        if (plot instanceof ValueAxisPlot) {\n            ValueAxisPlot vap \u003d (ValueAxisPlot) plot;\n\n            Range r \u003d vap.getDataRange(this);\n            if (r \u003d\u003d null) {\n                r \u003d new DateRange();\n            }\n\n            long upper \u003d this.timeline.toTimelineValue(\n                    (long) r.getUpperBound());\n            long lower;\n            long fixedAutoRange \u003d (long) getFixedAutoRange();\n            if (fixedAutoRange \u003e 0.0) {\n                lower \u003d upper - fixedAutoRange;\n            }\n            else {\n                lower \u003d this.timeline.toTimelineValue((long) r.getLowerBound());\n                double range \u003d upper - lower;\n                long minRange \u003d (long) getAutoRangeMinimumSize();\n                if (range \u003c minRange) {\n                    long expand \u003d (long) (minRange - range) / 2;\n                    upper \u003d upper + expand;\n                    lower \u003d lower - expand;\n                }\n                upper \u003d upper + (long) (range * getUpperMargin());\n                lower \u003d lower - (long) (range * getLowerMargin());\n            }\n\n            upper \u003d this.timeline.toMillisecond(upper);\n            lower \u003d this.timeline.toMillisecond(lower);\n            DateRange dr \u003d new DateRange(new Date(lower), new Date(upper));\n            setRange(dr, false, false);\n        }\n\n    }\n\n    /**\n     * Selects an appropriate tick value for the axis.  The strategy is to\n     * display as many ticks as possible (selected from an array of \u0027standard\u0027\n     * tick units) without the labels overlapping.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area defined by the axes.\n     * @param edge  the axis location.\n     */\n    protected void selectAutoTickUnit(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            selectHorizontalAutoTickUnit(g2, dataArea, edge);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            selectVerticalAutoTickUnit(g2, dataArea, edge);\n        }\n\n    }\n\n    /**\n     * Selects an appropriate tick size for the axis.  The strategy is to\n     * display as many ticks as possible (selected from a collection of\n     * \u0027standard\u0027 tick units) without the labels overlapping.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area defined by the axes.\n     * @param edge  the axis location.\n     */\n    protected void selectHorizontalAutoTickUnit(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        double zero \u003d valueToJava2D(0.0, dataArea, edge);\n        double tickLabelWidth \u003d estimateMaximumTickLabelWidth(g2,\n                getTickUnit());\n\n        // start with the current tick unit...\n        TickUnitSource tickUnits \u003d getStandardTickUnits();\n        TickUnit unit1 \u003d tickUnits.getCeilingTickUnit(getTickUnit());\n        double x1 \u003d valueToJava2D(unit1.getSize(), dataArea, edge);\n        double unit1Width \u003d Math.abs(x1 - zero);\n\n        // then extrapolate...\n        double guess \u003d (tickLabelWidth / unit1Width) * unit1.getSize();\n        DateTickUnit unit2 \u003d (DateTickUnit) tickUnits.getCeilingTickUnit(guess);\n        double x2 \u003d valueToJava2D(unit2.getSize(), dataArea, edge);\n        double unit2Width \u003d Math.abs(x2 - zero);\n        tickLabelWidth \u003d estimateMaximumTickLabelWidth(g2, unit2);\n        if (tickLabelWidth \u003e unit2Width) {\n            unit2 \u003d (DateTickUnit) tickUnits.getLargerTickUnit(unit2);\n        }\n        setTickUnit(unit2, false, false);\n    }\n\n    /**\n     * Selects an appropriate tick size for the axis.  The strategy is to\n     * display as many ticks as possible (selected from a collection of\n     * \u0027standard\u0027 tick units) without the labels overlapping.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area in which the plot should be drawn.\n     * @param edge  the axis location.\n     */\n    protected void selectVerticalAutoTickUnit(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        // start with the current tick unit...\n        TickUnitSource tickUnits \u003d getStandardTickUnits();\n        double zero \u003d valueToJava2D(0.0, dataArea, edge);\n\n        // start with a unit that is at least 1/10th of the axis length\n        double estimate1 \u003d getRange().getLength() / 10.0;\n        DateTickUnit candidate1\n            \u003d (DateTickUnit) tickUnits.getCeilingTickUnit(estimate1);\n        double labelHeight1 \u003d estimateMaximumTickLabelHeight(g2, candidate1);\n        double y1 \u003d valueToJava2D(candidate1.getSize(), dataArea, edge);\n        double candidate1UnitHeight \u003d Math.abs(y1 - zero);\n\n        // now extrapolate based on label height and unit height...\n        double estimate2\n            \u003d (labelHeight1 / candidate1UnitHeight) * candidate1.getSize();\n        DateTickUnit candidate2\n            \u003d (DateTickUnit) tickUnits.getCeilingTickUnit(estimate2);\n        double labelHeight2 \u003d estimateMaximumTickLabelHeight(g2, candidate2);\n        double y2 \u003d valueToJava2D(candidate2.getSize(), dataArea, edge);\n        double unit2Height \u003d Math.abs(y2 - zero);\n\n       // make final selection...\n       DateTickUnit finalUnit;\n       if (labelHeight2 \u003c unit2Height) {\n           finalUnit \u003d candidate2;\n       }\n       else {\n           finalUnit \u003d (DateTickUnit) tickUnits.getLargerTickUnit(candidate2);\n       }\n       setTickUnit(finalUnit, false, false);\n\n    }\n\n    /**\n     * Estimates the maximum width of the tick labels, assuming the specified\n     * tick unit is used.\n     * \u003cP\u003e\n     * Rather than computing the string bounds of every tick on the axis, we\n     * just look at two values: the lower bound and the upper bound for the\n     * axis.  These two values will usually be representative.\n     *\n     * @param g2  the graphics device.\n     * @param unit  the tick unit to use for calculation.\n     *\n     * @return The estimated maximum width of the tick labels.\n     */\n    private double estimateMaximumTickLabelWidth(Graphics2D g2, \n            DateTickUnit unit) {\n\n        RectangleInsets tickLabelInsets \u003d getTickLabelInsets();\n        double result \u003d tickLabelInsets.getLeft() + tickLabelInsets.getRight();\n\n        Font tickLabelFont \u003d getTickLabelFont();\n        FontRenderContext frc \u003d g2.getFontRenderContext();\n        LineMetrics lm \u003d tickLabelFont.getLineMetrics(\"ABCxyz\", frc);\n        if (isVerticalTickLabels()) {\n            // all tick labels have the same width (equal to the height of\n            // the font)...\n            result +\u003d lm.getHeight();\n        }\n        else {\n            // look at lower and upper bounds...\n            DateRange range \u003d (DateRange) getRange();\n            Date lower \u003d range.getLowerDate();\n            Date upper \u003d range.getUpperDate();\n            String lowerStr, upperStr;\n            DateFormat formatter \u003d getDateFormatOverride();\n            if (formatter !\u003d null) {\n                lowerStr \u003d formatter.format(lower);\n                upperStr \u003d formatter.format(upper);\n            }\n            else {\n                lowerStr \u003d unit.dateToString(lower);\n                upperStr \u003d unit.dateToString(upper);\n            }\n            FontMetrics fm \u003d g2.getFontMetrics(tickLabelFont);\n            double w1 \u003d fm.stringWidth(lowerStr);\n            double w2 \u003d fm.stringWidth(upperStr);\n            result +\u003d Math.max(w1, w2);\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Estimates the maximum width of the tick labels, assuming the specified\n     * tick unit is used.\n     * \u003cP\u003e\n     * Rather than computing the string bounds of every tick on the axis, we\n     * just look at two values: the lower bound and the upper bound for the\n     * axis.  These two values will usually be representative.\n     *\n     * @param g2  the graphics device.\n     * @param unit  the tick unit to use for calculation.\n     *\n     * @return The estimated maximum width of the tick labels.\n     */\n    private double estimateMaximumTickLabelHeight(Graphics2D g2,\n            DateTickUnit unit) {\n\n        RectangleInsets tickLabelInsets \u003d getTickLabelInsets();\n        double result \u003d tickLabelInsets.getTop() + tickLabelInsets.getBottom();\n\n        Font tickLabelFont \u003d getTickLabelFont();\n        FontRenderContext frc \u003d g2.getFontRenderContext();\n        LineMetrics lm \u003d tickLabelFont.getLineMetrics(\"ABCxyz\", frc);\n        if (!isVerticalTickLabels()) {\n            // all tick labels have the same width (equal to the height of\n            // the font)...\n            result +\u003d lm.getHeight();\n        }\n        else {\n            // look at lower and upper bounds...\n            DateRange range \u003d (DateRange) getRange();\n            Date lower \u003d range.getLowerDate();\n            Date upper \u003d range.getUpperDate();\n            String lowerStr, upperStr;\n            DateFormat formatter \u003d getDateFormatOverride();\n            if (formatter !\u003d null) {\n                lowerStr \u003d formatter.format(lower);\n                upperStr \u003d formatter.format(upper);\n            }\n            else {\n                lowerStr \u003d unit.dateToString(lower);\n                upperStr \u003d unit.dateToString(upper);\n            }\n            FontMetrics fm \u003d g2.getFontMetrics(tickLabelFont);\n            double w1 \u003d fm.stringWidth(lowerStr);\n            double w2 \u003d fm.stringWidth(upperStr);\n            result +\u003d Math.max(w1, w2);\n        }\n\n        return result;\n\n    }\n\n    /**\n     * Calculates the positions of the tick labels for the axis, storing the\n     * results in the tick label list (ready for drawing).\n     *\n     * @param g2  the graphics device.\n     * @param state  the axis state.\n     * @param dataArea  the area in which the plot should be drawn.\n     * @param edge  the location of the axis.\n     *\n     * @return A list of ticks.\n     */\n    @Override\n    public List\u003c? extends Tick\u003e refreshTicks(Graphics2D g2, AxisState state, \n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        List\u003c? extends Tick\u003e result \u003d null;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            result \u003d refreshTicksHorizontal(g2, dataArea, edge);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            result \u003d refreshTicksVertical(g2, dataArea, edge);\n        }\n        return result;\n\n    }\n\n    /**\n     * Corrects the given tick date for the position setting.\n     *\n     * @param time  the tick date/time.\n     * @param unit  the tick unit.\n     * @param position  the tick position.\n     *\n     * @return The adjusted time.\n     */\n    private Date correctTickDateForPosition(Date time, DateTickUnit unit,\n            DateTickMarkPosition position) {\n        Date result \u003d time;\n        if (unit.getUnitType().equals(DateTickUnitType.MONTH)) {\n            result \u003d calculateDateForPosition(new Month(time, this.timeZone,\n                    this.locale), position);\n        } else if (unit.getUnitType().equals(DateTickUnitType.YEAR)) {\n            result \u003d calculateDateForPosition(new Year(time, this.timeZone,\n                    this.locale), position);\n        }\n        return result;\n    }\n\n    /**\n     * Recalculates the ticks for the date axis.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area in which the data is to be drawn.\n     * @param edge  the location of the axis.\n     *\n     * @return A list of ticks.\n     */\n    protected List\u003c? extends Tick\u003e refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge) {\n\n        List\u003cDateTick\u003e result \u003d new ArrayList\u003c\u003e();\n\n        Font tickLabelFont \u003d getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        DateTickUnit unit \u003d getTickUnit();\n        Date tickDate \u003d calculateLowestVisibleTickValue(unit);\n        Date upperDate \u003d getMaximumDate();\n\n        boolean hasRolled \u003d false;\n        while (tickDate.before(upperDate)) {\n            // could add a flag to make the following correction optional...\n            if (!hasRolled) {\n                tickDate \u003d correctTickDateForPosition(tickDate, unit,\n                     this.tickMarkPosition);\n            }\n\n            long lowestTickTime \u003d tickDate.getTime();\n            long distance \u003d unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces \u003d getMinorTickCount();\n            if (minorTickSpaces \u003c\u003d 0) {\n                minorTickSpaces \u003d unit.getMinorTickCount();\n            }\n            for (int minorTick \u003d 1; minorTick \u003c minorTickSpaces; minorTick++) {\n                long minorTickTime \u003d lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime \u003e 0 \u0026\u0026 getRange().contains(minorTickTime)\n                        \u0026\u0026 (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n\n            if (!isHiddenValue(tickDate.getTime())) {\n                // work out the value, label and position\n                String tickLabel;\n                DateFormat formatter \u003d getDateFormatOverride();\n                if (formatter !\u003d null) {\n                    tickLabel \u003d formatter.format(tickDate);\n                }\n                else {\n                    tickLabel \u003d this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle \u003d 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor \u003d TextAnchor.CENTER_RIGHT;\n                    rotationAnchor \u003d TextAnchor.CENTER_RIGHT;\n                    if (edge \u003d\u003d RectangleEdge.TOP) {\n                        angle \u003d Math.PI / 2.0;\n                    }\n                    else {\n                        angle \u003d -Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge \u003d\u003d RectangleEdge.TOP) {\n                        anchor \u003d TextAnchor.BOTTOM_CENTER;\n                        rotationAnchor \u003d TextAnchor.BOTTOM_CENTER;\n                    }\n                    else {\n                        anchor \u003d TextAnchor.TOP_CENTER;\n                        rotationAnchor \u003d TextAnchor.TOP_CENTER;\n                    }\n                }\n\n                DateTick tick \u003d new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled \u003d false;\n\n                long currentTickTime \u003d tickDate.getTime();\n                tickDate \u003d unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime \u003d tickDate.getTime();\n                for (int minorTick \u003d 1; minorTick \u003c minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime \u003d currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            \u0026\u0026 (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n\n            }\n            else {\n                tickDate \u003d unit.rollDate(tickDate, this.timeZone);\n                hasRolled \u003d true;\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Recalculates the ticks for the date axis.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area in which the plot should be drawn.\n     * @param edge  the location of the axis.\n     *\n     * @return A list of ticks.\n     */\n    protected List\u003c? extends Tick\u003e refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        List\u003cDateTick\u003e result \u003d new ArrayList\u003c\u003e();\n\n        Font tickLabelFont \u003d getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n        DateTickUnit unit \u003d getTickUnit();\n        Date tickDate \u003d calculateLowestVisibleTickValue(unit);\n        Date upperDate \u003d getMaximumDate();\n\n        boolean hasRolled \u003d false;\n        while (tickDate.before(upperDate)) {\n\n            // could add a flag to make the following correction optional...\n            if (!hasRolled) {\n                tickDate \u003d correctTickDateForPosition(tickDate, unit,\n                    this.tickMarkPosition);\n            }\n\n            long lowestTickTime \u003d tickDate.getTime();\n            long distance \u003d unit.addToDate(tickDate, this.timeZone).getTime()\n                    - lowestTickTime;\n            int minorTickSpaces \u003d getMinorTickCount();\n            if (minorTickSpaces \u003c\u003d 0) {\n                minorTickSpaces \u003d unit.getMinorTickCount();\n            }\n            for (int minorTick \u003d 1; minorTick \u003c minorTickSpaces; minorTick++) {\n                long minorTickTime \u003d lowestTickTime - distance\n                        * minorTick / minorTickSpaces;\n                if (minorTickTime \u003e 0 \u0026\u0026 getRange().contains(minorTickTime)\n                        \u0026\u0026 (!isHiddenValue(minorTickTime))) {\n                    result.add(new DateTick(TickType.MINOR,\n                            new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER,\n                            TextAnchor.CENTER, 0.0));\n                }\n            }\n            if (!isHiddenValue(tickDate.getTime())) {\n                // work out the value, label and position\n                String tickLabel;\n                DateFormat formatter \u003d getDateFormatOverride();\n                if (formatter !\u003d null) {\n                    tickLabel \u003d formatter.format(tickDate);\n                }\n                else {\n                    tickLabel \u003d this.tickUnit.dateToString(tickDate);\n                }\n                TextAnchor anchor, rotationAnchor;\n                double angle \u003d 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor \u003d TextAnchor.BOTTOM_CENTER;\n                    rotationAnchor \u003d TextAnchor.BOTTOM_CENTER;\n                    if (edge \u003d\u003d RectangleEdge.LEFT) {\n                        angle \u003d -Math.PI / 2.0;\n                    }\n                    else {\n                        angle \u003d Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge \u003d\u003d RectangleEdge.LEFT) {\n                        anchor \u003d TextAnchor.CENTER_RIGHT;\n                        rotationAnchor \u003d TextAnchor.CENTER_RIGHT;\n                    }\n                    else {\n                        anchor \u003d TextAnchor.CENTER_LEFT;\n                        rotationAnchor \u003d TextAnchor.CENTER_LEFT;\n                    }\n                }\n\n                DateTick tick \u003d new DateTick(tickDate, tickLabel, anchor,\n                        rotationAnchor, angle);\n                result.add(tick);\n                hasRolled \u003d false;\n\n                long currentTickTime \u003d tickDate.getTime();\n                tickDate \u003d unit.addToDate(tickDate, this.timeZone);\n                long nextTickTime \u003d tickDate.getTime();\n                for (int minorTick \u003d 1; minorTick \u003c minorTickSpaces;\n                        minorTick++) {\n                    long minorTickTime \u003d currentTickTime\n                            + (nextTickTime - currentTickTime)\n                            * minorTick / minorTickSpaces;\n                    if (getRange().contains(minorTickTime)\n                            \u0026\u0026 (!isHiddenValue(minorTickTime))) {\n                        result.add(new DateTick(TickType.MINOR,\n                                new Date(minorTickTime), \"\",\n                                TextAnchor.TOP_CENTER, TextAnchor.CENTER,\n                                0.0));\n                    }\n                }\n            }\n            else {\n                tickDate \u003d unit.rollDate(tickDate, this.timeZone);\n                hasRolled \u003d true;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Draws the axis on a Java 2D graphics device (such as the screen or a\n     * printer).\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param cursor  the cursor location.\n     * @param plotArea  the area within which the axes and data should be\n     *                  drawn ({@code null} not permitted).\n     * @param dataArea  the area within which the data should be drawn\n     *                  ({@code null} not permitted).\n     * @param edge  the location of the axis ({@code null} not permitted).\n     * @param plotState  collects information about the plot\n     *                   ({@code null} permitted).\n     *\n     * @return The axis state (never {@code null}).\n     */\n    @Override\n    public AxisState draw(Graphics2D g2, double cursor, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge,\n            PlotRenderingInfo plotState) {\n\n        // if the axis is not visible, don\u0027t draw it...\n        if (!isVisible()) {\n            AxisState state \u003d new AxisState(cursor);\n            // even though the axis is not visible, we need to refresh ticks in\n            // case the grid is being drawn...\n            List ticks \u003d refreshTicks(g2, state, dataArea, edge);\n            state.setTicks(ticks);\n            return state;\n        }\n\n        // draw the tick marks and labels...\n        AxisState state \u003d drawTickMarksAndLabels(g2, cursor, plotArea,\n                dataArea, edge);\n\n        // draw the axis label (note that \u0027state\u0027 is passed in *and*\n        // returned)...\n        if (getAttributedLabel() !\u003d null) {\n            state \u003d drawAttributedLabel(getAttributedLabel(), g2, plotArea, \n                    dataArea, edge, state);\n            \n        } else {\n            state \u003d drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);\n        }\n        createAndAddEntity(cursor, state, dataArea, edge, plotState);\n        return state;\n\n    }\n\n    /**\n     * Zooms in on the current range (zoom-in stops once the axis length \n     * reaches the equivalent of one millisecond).  \n     *\n     * @param lowerPercent  the new lower bound.\n     * @param upperPercent  the new upper bound.\n     */\n    @Override\n    public void zoomRange(double lowerPercent, double upperPercent) {\n        double start \u003d this.timeline.toTimelineValue(\n                (long) getRange().getLowerBound());\n        double end \u003d this.timeline.toTimelineValue(\n                (long) getRange().getUpperBound());\n        double length \u003d end - start;\n        Range adjusted;\n        long adjStart, adjEnd;\n        if (isInverted()) {\n            adjStart \u003d (long) (start + (length * (1 - upperPercent)));\n            adjEnd \u003d (long) (start + (length * (1 - lowerPercent)));\n        }\n        else {\n            adjStart \u003d (long) (start + length * lowerPercent);\n            adjEnd \u003d (long) (start + length * upperPercent);\n        }\n        // when zooming to sub-millisecond ranges, it can be the case that\n        // adjEnd \u003d\u003d adjStart...and we can\u0027t have an axis with zero length\n        // so we apply this instead:\n        if (adjEnd \u003c\u003d adjStart) {\n            adjEnd \u003d adjStart + 1L;\n        } \n        adjusted \u003d new DateRange(this.timeline.toMillisecond(adjStart),\n               this.timeline.toMillisecond(adjEnd));\n        setRange(adjusted);\n    }\n\n    /**\n     * Tests this axis for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof DateAxis)) {\n            return false;\n        }\n        DateAxis that \u003d (DateAxis) obj;\n        if (!Objects.equals(this.timeZone, that.timeZone)) {\n            return false;\n        }\n        if (!Objects.equals(this.locale, that.locale)) {\n            return false;\n        }\n        if (!Objects.equals(this.tickUnit, that.tickUnit)) {\n            return false;\n        }\n        if (!Objects.equals(this.dateFormatOverride, that.dateFormatOverride)) {\n            return false;\n        }\n        if (!Objects.equals(this.tickMarkPosition, that.tickMarkPosition)) {\n            return false;\n        }\n        if (!Objects.equals(this.timeline, that.timeline)) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a hash code for this object.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * Returns a clone of the object.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if some component of the axis does\n     *         not support cloning.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        DateAxis clone \u003d (DateAxis) super.clone();\n        // \u0027dateTickUnit\u0027 is immutable : no need to clone\n        if (this.dateFormatOverride !\u003d null) {\n            clone.dateFormatOverride\n                \u003d (DateFormat) this.dateFormatOverride.clone();\n        }\n        // \u0027tickMarkPosition\u0027 is immutable : no need to clone\n        return clone;\n    }\n\n}","methodCount":59,"staticMethodCount":2,"instanceMethodCount":57,"classLoc":1744,"innerClassCount":1},"candidatesTelemetryData":{"numberOfSuggestions":3,"candidates":[{"lineStart":625,"lineEnd":635,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method isHiddenValue to class Timeline","description":"Move method isHiddenValue to org.jfree.chart.axis.Timeline\nRationale: The method isHiddenValue(long millis) relies on the containsDomainValue(Date date) method of the Timeline interface. The logic of determining whether a value is hidden is directly related to the timeline\u0027s domain values and their containment logic. Therefore, it is more appropriate to move this method to the Timeline class as it encapsulates the knowledge and functionality required for this determination, ensuring better cohesion and reducing dependencies with other classes.","couldCreateRefObject":true,"valid":true,"applied":false,"startedRefactoringFlow":true,"undone":false,"userRating":"Very Helpful"},{"lineStart":976,"lineEnd":991,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method nextStandardDate to class Timeline","description":"Move method nextStandardDate to org.jfree.chart.axis.Timeline\nRationale: The method nextStandardDate(Date, DateTickUnit) is directly related to timelines and dates, which aligns well with the responsibilities of a Timeline. The class Timeline already handles date transformations and domain value checks, making it a suitable place for a method that computes a \u0027standard\u0027 date based on specific criteria. Adding the method to Timeline keeps date-related logic contained within a single class, adhering to the single responsibility principle and enhancing maintainability.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Somewhat Helpful"},{"lineStart":1556,"lineEnd":1667,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method refreshTicksVertical to class Timeline","description":"Move method refreshTicksVertical to org.jfree.chart.axis.Timeline\nRationale: The method `refreshTicksVertical` deals extensively with date and time calculations, axis tick placements, and transformations which are core to the purpose of the `Timeline` interface. The `Timeline` interface is designed to handle date-related axis transformations and providing values for date-related axes, which aligns with the objective of `refreshTicksVertical`. The method calls various date-related methods, such as `calculateLowestVisibleTickValue`, `getMaximumDate`, and `selectAutoTickUnit`, which would logically fit within the domain of managing a timeline. Moving the method to `Timeline` allows for better cohesion and centralization of date and timeline related functionalities within the `Timeline` interface.","couldCreateRefObject":true,"valid":true,"applied":false,"startedRefactoringFlow":true,"undone":false}]},"userSelectionTelemetryData":{"lineStart":976,"lineEnd":991,"functionSize":16,"positionInHostFunction":898,"selectedCandidateIndex":1,"candidateType":"AS_IS","elementsType":[]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":442111},{"candidateIndex":1,"elapsedTime":4209473}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":43760},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"isHiddenValue","method_signature":"public isHiddenValue(long millis)","target_class":"","rationale":""},{"method_name":"previousStandardDate","method_signature":"protected previousStandardDate(Date date, DateTickUnit unit)","target_class":"","rationale":""},{"method_name":"calculateDateForPosition","method_signature":"private calculateDateForPosition(RegularTimePeriod period,\n            DateTickMarkPosition position)","target_class":"","rationale":""},{"method_name":"nextStandardDate","method_signature":"protected nextStandardDate(Date date, DateTickUnit unit)","target_class":"","rationale":""},{"method_name":"estimateMaximumTickLabelWidth","method_signature":"private estimateMaximumTickLabelWidth(Graphics2D g2, \n            DateTickUnit unit)","target_class":"","rationale":""},{"method_name":"estimateMaximumTickLabelHeight","method_signature":"private estimateMaximumTickLabelHeight(Graphics2D g2,\n            DateTickUnit unit)","target_class":"","rationale":""},{"method_name":"correctTickDateForPosition","method_signature":"private correctTickDateForPosition(Date time, DateTickUnit unit,\n            DateTickMarkPosition position)","target_class":"","rationale":""},{"method_name":"refreshTicksHorizontal","method_signature":"protected refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge)","target_class":"","rationale":""},{"method_name":"refreshTicksVertical","method_signature":"protected refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"previousStandardDate","method_signature":"protected previousStandardDate(Date date, DateTickUnit unit)","target_class":"","rationale":""},{"method_name":"isHiddenValue","method_signature":"public isHiddenValue(long millis)","target_class":"","rationale":""},{"method_name":"nextStandardDate","method_signature":"protected nextStandardDate(Date date, DateTickUnit unit)","target_class":"","rationale":""},{"method_name":"refreshTicksVertical","method_signature":"protected refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge)","target_class":"","rationale":""},{"method_name":"refreshTicksHorizontal","method_signature":"protected refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge)","target_class":"","rationale":""},{"method_name":"calculateDateForPosition","method_signature":"private calculateDateForPosition(RegularTimePeriod period,\n            DateTickMarkPosition position)","target_class":"","rationale":""},{"method_name":"correctTickDateForPosition","method_signature":"private correctTickDateForPosition(Date time, DateTickUnit unit,\n            DateTickMarkPosition position)","target_class":"","rationale":""},{"method_name":"estimateMaximumTickLabelHeight","method_signature":"private estimateMaximumTickLabelHeight(Graphics2D g2,\n            DateTickUnit unit)","target_class":"","rationale":""},{"method_name":"estimateMaximumTickLabelWidth","method_signature":"private estimateMaximumTickLabelWidth(Graphics2D g2, \n            DateTickUnit unit)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"protected previousStandardDate(Date date, DateTickUnit unit)":{"first":{"method_name":"previousStandardDate","method_signature":"protected previousStandardDate(Date date, DateTickUnit unit)","target_class":"","rationale":""},"second":0.5821732401086368},"public isHiddenValue(long millis)":{"first":{"method_name":"isHiddenValue","method_signature":"public isHiddenValue(long millis)","target_class":"","rationale":""},"second":0.6643634754003933},"protected nextStandardDate(Date date, DateTickUnit unit)":{"first":{"method_name":"nextStandardDate","method_signature":"protected nextStandardDate(Date date, DateTickUnit unit)","target_class":"","rationale":""},"second":0.7103494305280967},"protected refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge)":{"first":{"method_name":"refreshTicksVertical","method_signature":"protected refreshTicksVertical(Graphics2D g2,\n            Rectangle2D dataArea, RectangleEdge edge)","target_class":"","rationale":""},"second":0.7369448117161602},"protected refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge)":{"first":{"method_name":"refreshTicksHorizontal","method_signature":"protected refreshTicksHorizontal(Graphics2D g2,\n                Rectangle2D dataArea, RectangleEdge edge)","target_class":"","rationale":""},"second":0.7393024942813281},"private calculateDateForPosition(RegularTimePeriod period,\n            DateTickMarkPosition position)":{"first":{"method_name":"calculateDateForPosition","method_signature":"private calculateDateForPosition(RegularTimePeriod period,\n            DateTickMarkPosition position)","target_class":"","rationale":""},"second":0.7549558793392384},"private correctTickDateForPosition(Date time, DateTickUnit unit,\n            DateTickMarkPosition position)":{"first":{"method_name":"correctTickDateForPosition","method_signature":"private correctTickDateForPosition(Date time, DateTickUnit unit,\n            DateTickMarkPosition position)","target_class":"","rationale":""},"second":0.7805112754114129},"private estimateMaximumTickLabelHeight(Graphics2D g2,\n            DateTickUnit unit)":{"first":{"method_name":"estimateMaximumTickLabelHeight","method_signature":"private estimateMaximumTickLabelHeight(Graphics2D g2,\n            DateTickUnit unit)","target_class":"","rationale":""},"second":0.8320859346755809},"private estimateMaximumTickLabelWidth(Graphics2D g2, \n            DateTickUnit unit)":{"first":{"method_name":"estimateMaximumTickLabelWidth","method_signature":"private estimateMaximumTickLabelWidth(Graphics2D g2, \n            DateTickUnit unit)","target_class":"","rationale":""},"second":0.8321817309915978}},"targetClassMap":{"previousStandardDate":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":6724,"similarity_computation_time":0,"similarity_metric":"cosine"},"isHiddenValue":{"target_classes":[{"class_name":"Timeline","similarity_score":0.7807028472864754},{"class_name":"Timeline","similarity_score":0.7807028472864754}],"target_classes_sorted_by_llm":["Timeline","Timeline"],"llm_response_time":3686,"similarity_computation_time":1,"similarity_metric":"cosine"},"nextStandardDate":{"target_classes":[{"class_name":"Timeline","similarity_score":0.6553760708797578},{"class_name":"Timeline","similarity_score":0.6553760708797578}],"target_classes_sorted_by_llm":["Timeline","Timeline"],"llm_response_time":4094,"similarity_computation_time":0,"similarity_metric":"cosine"},"refreshTicksVertical":{"target_classes":[{"class_name":"Timeline","similarity_score":0.26464152775617245},{"class_name":"Timeline","similarity_score":0.26464152775617245}],"target_classes_sorted_by_llm":["Timeline","Timeline"],"llm_response_time":4052,"similarity_computation_time":1,"similarity_metric":"cosine"},"refreshTicksHorizontal":{"target_classes":[{"class_name":"Timeline","similarity_score":0.26880112587092475},{"class_name":"Timeline","similarity_score":0.26880112587092475}],"target_classes_sorted_by_llm":["Timeline","Timeline"],"llm_response_time":4915,"similarity_computation_time":0,"similarity_metric":"cosine"},"calculateDateForPosition":{"target_classes":[{"class_name":"RegularTimePeriod","similarity_score":0.6462685527714653},{"class_name":"DateTickMarkPosition","similarity_score":0.3366501646120693},{"class_name":"DateRange","similarity_score":0.6326948931973279},{"class_name":"DateTickUnit","similarity_score":0.6967858219474778},{"class_name":"DateTickMarkPosition","similarity_score":0.3366501646120693},{"class_name":"Timeline","similarity_score":0.5495501040844966},{"class_name":"Timeline","similarity_score":0.5495501040844966}],"target_classes_sorted_by_llm":["RegularTimePeriod","DateTickUnit","DateRange"],"llm_response_time":7433,"similarity_computation_time":5,"similarity_metric":"cosine"},"correctTickDateForPosition":{"target_classes":[{"class_name":"Timeline","similarity_score":0.5909692029727589},{"class_name":"Timeline","similarity_score":0.5909692029727589}],"target_classes_sorted_by_llm":["Timeline","Timeline"],"llm_response_time":3422,"similarity_computation_time":0,"similarity_metric":"cosine"},"estimateMaximumTickLabelHeight":{"target_classes":[{"class_name":"DateTickUnit","similarity_score":0.6620025933834841},{"class_name":"DateRange","similarity_score":0.6412898280652509},{"class_name":"DateTickUnit","similarity_score":0.6620025933834841},{"class_name":"DateTickMarkPosition","similarity_score":0.32109027532432616},{"class_name":"Timeline","similarity_score":0.5167363106398684},{"class_name":"Timeline","similarity_score":0.5167363106398684}],"target_classes_sorted_by_llm":["DateRange","DateTickUnit","DateTickUnit"],"llm_response_time":4312,"similarity_computation_time":3,"similarity_metric":"cosine"},"estimateMaximumTickLabelWidth":{"target_classes":[{"class_name":"DateTickUnit","similarity_score":0.6620025933834841},{"class_name":"DateRange","similarity_score":0.6412898280652509},{"class_name":"DateTickUnit","similarity_score":0.6620025933834841},{"class_name":"DateTickMarkPosition","similarity_score":0.32109027532432616},{"class_name":"Timeline","similarity_score":0.5167363106398684},{"class_name":"Timeline","similarity_score":0.5167363106398684}],"target_classes_sorted_by_llm":["DateTickUnit","DateTickUnit","DateRange"],"llm_response_time":4611,"similarity_computation_time":2,"similarity_metric":"cosine"}}}
{"id":"222700c0-c3d3-424e-8190-08d26beb776b","hostFunctionTelemetryData":{"hostFunctionSize":1328,"lineStart":76,"lineEnd":1403,"bodyLineStart":76,"language":"java","filePath":"/Users/snehil/Documents/ConcordiaUniversity/Material/SOEN-6491-Refactoring/OpenSource/jfreechart/jfreechart/src/main/java/org/jfree/chart/axis/CategoryAxis.java","sourceCode":"/**\n * An axis that displays categories.\n */\npublic class CategoryAxis extends Axis implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d 5886554608114265863L;\n\n    /**\n     * The default margin for the axis (used for both lower and upper margins).\n     */\n    public static final double DEFAULT_AXIS_MARGIN \u003d 0.05;\n\n    /**\n     * The default margin between categories (a percentage of the overall axis\n     * length).\n     */\n    public static final double DEFAULT_CATEGORY_MARGIN \u003d 0.20;\n\n    /** The amount of space reserved at the start of the axis. */\n    private double lowerMargin;\n\n    /** The amount of space reserved at the end of the axis. */\n    private double upperMargin;\n\n    /** The amount of space reserved between categories. */\n    private double categoryMargin;\n\n    /** The maximum number of lines for category labels. */\n    private int maximumCategoryLabelLines;\n\n    /**\n     * A ratio that is multiplied by the width of one category to determine the\n     * maximum label width.\n     */\n    private float maximumCategoryLabelWidthRatio;\n\n    /** The category label offset. */\n    private int categoryLabelPositionOffset;\n\n    /**\n     * A structure defining the category label positions for each axis\n     * location.\n     */\n    private CategoryLabelPositions categoryLabelPositions;\n\n    /** Storage for tick label font overrides (if any). */\n    private Map\u003cComparable, Font\u003e tickLabelFontMap; \n\n    /** Storage for tick label paint overrides (if any). */\n    private transient Map\u003cComparable, Paint\u003e tickLabelPaintMap;\n\n    /** Storage for the category label tooltips (if any). */\n    private Map\u003cComparable, String\u003e categoryLabelToolTips;\n\n    /** Storage for the category label URLs (if any). */\n    private Map\u003cComparable, String\u003e categoryLabelURLs;\n    \n    /**\n     * Creates a new category axis with no label.\n     */\n    public CategoryAxis() {\n        this(null);\n    }\n\n    /**\n     * Constructs a category axis, using default values where necessary.\n     *\n     * @param label  the axis label ({@code null} permitted).\n     */\n    public CategoryAxis(String label) {\n        super(label);\n\n        this.lowerMargin \u003d DEFAULT_AXIS_MARGIN;\n        this.upperMargin \u003d DEFAULT_AXIS_MARGIN;\n        this.categoryMargin \u003d DEFAULT_CATEGORY_MARGIN;\n        this.maximumCategoryLabelLines \u003d 1;\n        this.maximumCategoryLabelWidthRatio \u003d 0.0f;\n\n        this.categoryLabelPositionOffset \u003d 4;\n        this.categoryLabelPositions \u003d CategoryLabelPositions.STANDARD;\n        this.tickLabelFontMap \u003d new HashMap\u003c\u003e();\n        this.tickLabelPaintMap \u003d new HashMap\u003c\u003e();\n        this.categoryLabelToolTips \u003d new HashMap\u003c\u003e();\n        this.categoryLabelURLs \u003d new HashMap\u003c\u003e();\n    }\n\n    /**\n     * Returns the lower margin for the axis.\n     *\n     * @return The margin.\n     *\n     * @see #getUpperMargin()\n     * @see #setLowerMargin(double)\n     */\n    public double getLowerMargin() {\n        return this.lowerMargin;\n    }\n\n    /**\n     * Sets the lower margin for the axis and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param margin  the margin as a percentage of the axis length (for\n     *                example, 0.05 is five percent).\n     *\n     * @see #getLowerMargin()\n     */\n    public void setLowerMargin(double margin) {\n        this.lowerMargin \u003d margin;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the upper margin for the axis.\n     *\n     * @return The margin.\n     *\n     * @see #getLowerMargin()\n     * @see #setUpperMargin(double)\n     */\n    public double getUpperMargin() {\n        return this.upperMargin;\n    }\n\n    /**\n     * Sets the upper margin for the axis and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @param margin  the margin as a percentage of the axis length (for\n     *                example, 0.05 is five percent).\n     *\n     * @see #getUpperMargin()\n     */\n    public void setUpperMargin(double margin) {\n        this.upperMargin \u003d margin;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the category margin.\n     *\n     * @return The margin.\n     *\n     * @see #setCategoryMargin(double)\n     */\n    public double getCategoryMargin() {\n        return this.categoryMargin;\n    }\n\n    /**\n     * Sets the category margin and sends an {@link AxisChangeEvent} to all\n     * registered listeners.  The overall category margin is distributed over\n     * N-1 gaps, where N is the number of categories on the axis.\n     *\n     * @param margin  the margin as a percentage of the axis length (for\n     *                example, 0.05 is five percent).\n     *\n     * @see #getCategoryMargin()\n     */\n    public void setCategoryMargin(double margin) {\n        this.categoryMargin \u003d margin;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the maximum number of lines to use for each category label.\n     *\n     * @return The maximum number of lines.\n     *\n     * @see #setMaximumCategoryLabelLines(int)\n     */\n    public int getMaximumCategoryLabelLines() {\n        return this.maximumCategoryLabelLines;\n    }\n\n    /**\n     * Sets the maximum number of lines to use for each category label and\n     * sends an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param lines  the maximum number of lines.\n     *\n     * @see #getMaximumCategoryLabelLines()\n     */\n    public void setMaximumCategoryLabelLines(int lines) {\n        this.maximumCategoryLabelLines \u003d lines;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the category label width ratio.\n     *\n     * @return The ratio.\n     *\n     * @see #setMaximumCategoryLabelWidthRatio(float)\n     */\n    public float getMaximumCategoryLabelWidthRatio() {\n        return this.maximumCategoryLabelWidthRatio;\n    }\n\n    /**\n     * Sets the maximum category label width ratio and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param ratio  the ratio.\n     *\n     * @see #getMaximumCategoryLabelWidthRatio()\n     */\n    public void setMaximumCategoryLabelWidthRatio(float ratio) {\n        this.maximumCategoryLabelWidthRatio \u003d ratio;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the offset between the axis and the category labels (before\n     * label positioning is taken into account).\n     *\n     * @return The offset (in Java2D units).\n     *\n     * @see #setCategoryLabelPositionOffset(int)\n     */\n    public int getCategoryLabelPositionOffset() {\n        return this.categoryLabelPositionOffset;\n    }\n\n    /**\n     * Sets the offset between the axis and the category labels (before label\n     * positioning is taken into account) and sends a change event to all \n     * registered listeners.\n     *\n     * @param offset  the offset (in Java2D units).\n     *\n     * @see #getCategoryLabelPositionOffset()\n     */\n    public void setCategoryLabelPositionOffset(int offset) {\n        this.categoryLabelPositionOffset \u003d offset;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the category label position specification (this contains label\n     * positioning info for all four possible axis locations).\n     *\n     * @return The positions (never {@code null}).\n     *\n     * @see #setCategoryLabelPositions(CategoryLabelPositions)\n     */\n    public CategoryLabelPositions getCategoryLabelPositions() {\n        return this.categoryLabelPositions;\n    }\n\n    /**\n     * Sets the category label position specification for the axis and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param positions  the positions ({@code null} not permitted).\n     *\n     * @see #getCategoryLabelPositions()\n     */\n    public void setCategoryLabelPositions(CategoryLabelPositions positions) {\n        Args.nullNotPermitted(positions, \"positions\");\n        this.categoryLabelPositions \u003d positions;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the font for the tick label for the given category.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @return The font (never {@code null}).\n     *\n     * @see #setTickLabelFont(Comparable, Font)\n     */\n    public Font getTickLabelFont(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        Font result \u003d this.tickLabelFontMap.get(category);\n        // if there is no specific font, use the general one...\n        if (result \u003d\u003d null) {\n            result \u003d getTickLabelFont();\n        }\n        return result;\n    }\n\n    /**\n     * Sets the font for the tick label for the specified category and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     * @param font  the font ({@code null} permitted).\n     *\n     * @see #getTickLabelFont(Comparable)\n     */\n    public void setTickLabelFont(Comparable category, Font font) {\n        Args.nullNotPermitted(category, \"category\");\n        if (font \u003d\u003d null) {\n            this.tickLabelFontMap.remove(category);\n        } else {\n            this.tickLabelFontMap.put(category, font);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the tick label for the given category.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setTickLabelPaint(Paint)\n     */\n    public Paint getTickLabelPaint(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        Paint result \u003d this.tickLabelPaintMap.get(category);\n        // if there is no specific paint, use the general one...\n        if (result \u003d\u003d null) {\n            result \u003d getTickLabelPaint();\n        }\n        return result;\n    }\n\n    /**\n     * Sets the paint for the tick label for the specified category and sends\n     * an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     * @param paint  the paint ({@code null} permitted).\n     *\n     * @see #getTickLabelPaint(Comparable)\n     */\n    public void setTickLabelPaint(Comparable category, Paint paint) {\n        Args.nullNotPermitted(category, \"category\");\n        if (paint \u003d\u003d null) {\n            this.tickLabelPaintMap.remove(category);\n        } else {\n            this.tickLabelPaintMap.put(category, paint);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a tooltip to the specified category and sends an\n     * {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     * @param tooltip  the tooltip text ({@code null} permitted).\n     *\n     * @see #removeCategoryLabelToolTip(Comparable)\n     */\n    public void addCategoryLabelToolTip(Comparable category, String tooltip) {\n        Args.nullNotPermitted(category, \"category\");\n        this.categoryLabelToolTips.put(category, tooltip);\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the tool tip text for the label belonging to the specified\n     * category.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @return The tool tip text (possibly {@code null}).\n     *\n     * @see #addCategoryLabelToolTip(Comparable, String)\n     * @see #removeCategoryLabelToolTip(Comparable)\n     */\n    public String getCategoryLabelToolTip(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        return this.categoryLabelToolTips.get(category);\n    }\n\n    /**\n     * Removes the tooltip for the specified category and, if there was a value\n     * associated with that category, sends an {@link AxisChangeEvent} to all \n     * registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @see #addCategoryLabelToolTip(Comparable, String)\n     * @see #clearCategoryLabelToolTips()\n     */\n    public void removeCategoryLabelToolTip(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        if (this.categoryLabelToolTips.remove(category) !\u003d null) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears the category label tooltips and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @see #addCategoryLabelToolTip(Comparable, String)\n     * @see #removeCategoryLabelToolTip(Comparable)\n     */\n    public void clearCategoryLabelToolTips() {\n        this.categoryLabelToolTips.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a URL (to be used in image maps) to the specified category and \n     * sends an {@link AxisChangeEvent} to all registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     * @param url  the URL text ({@code null} permitted).\n     *\n     * @see #removeCategoryLabelURL(Comparable)\n     */\n    public void addCategoryLabelURL(Comparable category, String url) {\n        Args.nullNotPermitted(category, \"category\");\n        this.categoryLabelURLs.put(category, url);\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the URL for the label belonging to the specified category.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @return The URL text (possibly {@code null}).\n     * \n     * @see #addCategoryLabelURL(Comparable, String)\n     * @see #removeCategoryLabelURL(Comparable)\n     */\n    public String getCategoryLabelURL(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        return this.categoryLabelURLs.get(category);\n    }\n\n    /**\n     * Removes the URL for the specified category and, if there was a URL \n     * associated with that category, sends an {@link AxisChangeEvent} to all \n     * registered listeners.\n     *\n     * @param category  the category ({@code null} not permitted).\n     *\n     * @see #addCategoryLabelURL(Comparable, String)\n     * @see #clearCategoryLabelURLs()\n     */\n    public void removeCategoryLabelURL(Comparable category) {\n        Args.nullNotPermitted(category, \"category\");\n        if (this.categoryLabelURLs.remove(category) !\u003d null) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears the category label URLs and sends an {@link AxisChangeEvent}\n     * to all registered listeners.\n     *\n     * @see #addCategoryLabelURL(Comparable, String)\n     * @see #removeCategoryLabelURL(Comparable)\n     */\n    public void clearCategoryLabelURLs() {\n        this.categoryLabelURLs.clear();\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the Java 2D coordinate for a category.\n     *\n     * @param anchor  the anchor point ({@code null} not permitted).\n     * @param category  the category index.\n     * @param categoryCount  the category count.\n     * @param area  the data area.\n     * @param edge  the location of the axis.\n     *\n     * @return The coordinate.\n     */\n    public double getCategoryJava2DCoordinate(CategoryAnchor anchor, \n            int category, int categoryCount, Rectangle2D area, \n            RectangleEdge edge) {\n        Args.nullNotPermitted(anchor, \"anchor\");\n        double result \u003d 0.0;\n        switch (anchor) {\n            case START:\n                result \u003d getCategoryStart(category, categoryCount, area, edge);\n                break;\n            case MIDDLE:\n                result \u003d getCategoryMiddle(category, categoryCount, area, edge);\n                break;\n            case END:\n                result \u003d getCategoryEnd(category, categoryCount, area, edge);\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected anchor value.\");\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the starting coordinate for the specified category.\n     *\n     * @param category  the category.\n     * @param categoryCount  the number of categories.\n     * @param area  the data area.\n     * @param edge  the axis location.\n     *\n     * @return The coordinate.\n     *\n     * @see #getCategoryMiddle(int, int, Rectangle2D, RectangleEdge)\n     * @see #getCategoryEnd(int, int, Rectangle2D, RectangleEdge)\n     */\n    public double getCategoryStart(int category, int categoryCount, \n            Rectangle2D area, RectangleEdge edge) {\n\n        double result \u003d 0.0;\n        if ((edge \u003d\u003d RectangleEdge.TOP) || (edge \u003d\u003d RectangleEdge.BOTTOM)) {\n            result \u003d area.getX() + area.getWidth() * getLowerMargin();\n        }\n        else if ((edge \u003d\u003d RectangleEdge.LEFT)\n                || (edge \u003d\u003d RectangleEdge.RIGHT)) {\n            result \u003d area.getMinY() + area.getHeight() * getLowerMargin();\n        }\n\n        double categorySize \u003d calculateCategorySize(categoryCount, area, edge);\n        double categoryGapWidth \u003d calculateCategoryGapSize(categoryCount, area,\n                edge);\n\n        result \u003d result + category * (categorySize + categoryGapWidth);\n        return result;\n    }\n\n    /**\n     * Returns the middle coordinate for the specified category.\n     *\n     * @param category  the category.\n     * @param categoryCount  the number of categories.\n     * @param area  the data area.\n     * @param edge  the axis location.\n     *\n     * @return The coordinate.\n     *\n     * @see #getCategoryStart(int, int, Rectangle2D, RectangleEdge)\n     * @see #getCategoryEnd(int, int, Rectangle2D, RectangleEdge)\n     */\n    public double getCategoryMiddle(int category, int categoryCount,\n            Rectangle2D area, RectangleEdge edge) {\n\n        if (category \u003c 0 || category \u003e\u003d categoryCount) {\n            throw new IllegalArgumentException(\"Invalid category index: \"\n                    + category);\n        }\n        return getCategoryStart(category, categoryCount, area, edge)\n               + calculateCategorySize(categoryCount, area, edge) / 2;\n\n    }\n\n    /**\n     * Returns the end coordinate for the specified category.\n     *\n     * @param category  the category.\n     * @param categoryCount  the number of categories.\n     * @param area  the data area.\n     * @param edge  the axis location.\n     *\n     * @return The coordinate.\n     *\n     * @see #getCategoryStart(int, int, Rectangle2D, RectangleEdge)\n     * @see #getCategoryMiddle(int, int, Rectangle2D, RectangleEdge)\n     */\n    public double getCategoryEnd(int category, int categoryCount,\n            Rectangle2D area, RectangleEdge edge) {\n        return getCategoryStart(category, categoryCount, area, edge)\n               + calculateCategorySize(categoryCount, area, edge);\n    }\n\n    /**\n     * A convenience method that returns the axis coordinate for the centre of\n     * a category.\n     *\n     * @param category  the category key ({@code null} not permitted).\n     * @param categories  the categories ({@code null} not permitted).\n     * @param area  the data area ({@code null} not permitted).\n     * @param edge  the edge along which the axis lies ({@code null} not\n     *     permitted).\n     *\n     * @return The centre coordinate.\n     *\n     * @see #getCategorySeriesMiddle(Comparable, Comparable, CategoryDataset,\n     *     double, Rectangle2D, RectangleEdge)\n     */\n    public double getCategoryMiddle(Comparable category,\n            List categories, Rectangle2D area, RectangleEdge edge) {\n        Args.nullNotPermitted(categories, \"categories\");\n        int categoryIndex \u003d categories.indexOf(category);\n        int categoryCount \u003d categories.size();\n        return getCategoryMiddle(categoryIndex, categoryCount, area, edge);\n    }\n\n    /**\n     * Returns the middle coordinate (in Java2D space) for a series within a\n     * category.\n     *\n     * @param category  the category ({@code null} not permitted).\n     * @param seriesKey  the series key ({@code null} not permitted).\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param itemMargin  the item margin (0.0 \u0026lt;\u003d itemMargin \u0026lt; 1.0);\n     * @param area  the area ({@code null} not permitted).\n     * @param edge  the edge ({@code null} not permitted).\n     *\n     * @return The coordinate in Java2D space.\n     */\n    public double getCategorySeriesMiddle(Comparable category,\n            Comparable seriesKey, CategoryDataset dataset, double itemMargin,\n            Rectangle2D area, RectangleEdge edge) {\n\n        int categoryIndex \u003d dataset.getColumnIndex(category);\n        int categoryCount \u003d dataset.getColumnCount();\n        int seriesIndex \u003d dataset.getRowIndex(seriesKey);\n        int seriesCount \u003d dataset.getRowCount();\n        double start \u003d getCategoryStart(categoryIndex, categoryCount, area,\n                edge);\n        double end \u003d getCategoryEnd(categoryIndex, categoryCount, area, edge);\n        double width \u003d end - start;\n        if (seriesCount \u003d\u003d 1) {\n            return start + width / 2.0;\n        }\n        else {\n            double gap \u003d (width * itemMargin) / (seriesCount - 1);\n            double ww \u003d (width * (1 - itemMargin)) / seriesCount;\n            return start + (seriesIndex * (ww + gap)) + ww / 2.0;\n        }\n    }\n\n    /**\n     * Returns the middle coordinate (in Java2D space) for a series within a\n     * category.\n     *\n     * @param categoryIndex  the category index.\n     * @param categoryCount  the category count.\n     * @param seriesIndex the series index.\n     * @param seriesCount the series count.\n     * @param itemMargin  the item margin (0.0 \u0026lt;\u003d itemMargin \u0026lt; 1.0);\n     * @param area  the area ({@code null} not permitted).\n     * @param edge  the edge ({@code null} not permitted).\n     *\n     * @return The coordinate in Java2D space.\n     */\n    public double getCategorySeriesMiddle(int categoryIndex, int categoryCount,\n            int seriesIndex, int seriesCount, double itemMargin,\n            Rectangle2D area, RectangleEdge edge) {\n\n        double start \u003d getCategoryStart(categoryIndex, categoryCount, area,\n                edge);\n        double end \u003d getCategoryEnd(categoryIndex, categoryCount, area, edge);\n        double width \u003d end - start;\n        if (seriesCount \u003d\u003d 1) {\n            return start + width / 2.0;\n        }\n        else {\n            double gap \u003d (width * itemMargin) / (seriesCount - 1);\n            double ww \u003d (width * (1 - itemMargin)) / seriesCount;\n            return start + (seriesIndex * (ww + gap)) + ww / 2.0;\n        }\n    }\n\n    /**\n     * Calculates the size (width or height, depending on the location of the\n     * axis) of a category.\n     *\n     * @param categoryCount  the number of categories.\n     * @param area  the area within which the categories will be drawn.\n     * @param edge  the axis location.\n     *\n     * @return The category size.\n     */\n    protected double calculateCategorySize(int categoryCount, Rectangle2D area,\n            RectangleEdge edge) {\n        double result;\n        double available \u003d 0.0;\n\n        if ((edge \u003d\u003d RectangleEdge.TOP) || (edge \u003d\u003d RectangleEdge.BOTTOM)) {\n            available \u003d area.getWidth();\n        }\n        else if ((edge \u003d\u003d RectangleEdge.LEFT)\n                || (edge \u003d\u003d RectangleEdge.RIGHT)) {\n            available \u003d area.getHeight();\n        }\n        if (categoryCount \u003e 1) {\n            result \u003d available * (1 - getLowerMargin() - getUpperMargin()\n                     - getCategoryMargin());\n            result \u003d result / categoryCount;\n        }\n        else {\n            result \u003d available * (1 - getLowerMargin() - getUpperMargin());\n        }\n        return result;\n    }\n\n    /**\n     * Calculates the size (width or height, depending on the location of the\n     * axis) of a category gap.\n     *\n     * @param categoryCount  the number of categories.\n     * @param area  the area within which the categories will be drawn.\n     * @param edge  the axis location.\n     *\n     * @return The category gap width.\n     */\n    protected double calculateCategoryGapSize(int categoryCount, \n            Rectangle2D area, RectangleEdge edge) {\n\n        double result \u003d 0.0;\n        double available \u003d 0.0;\n\n        if ((edge \u003d\u003d RectangleEdge.TOP) || (edge \u003d\u003d RectangleEdge.BOTTOM)) {\n            available \u003d area.getWidth();\n        }\n        else if ((edge \u003d\u003d RectangleEdge.LEFT)\n                || (edge \u003d\u003d RectangleEdge.RIGHT)) {\n            available \u003d area.getHeight();\n        }\n\n        if (categoryCount \u003e 1) {\n            result \u003d available * getCategoryMargin() / (categoryCount - 1);\n        }\n        return result;\n    }\n\n    /**\n     * Estimates the space required for the axis, given a specific drawing area.\n     *\n     * @param g2  the graphics device (used to obtain font information).\n     * @param plot  the plot that the axis belongs to.\n     * @param plotArea  the area within which the axis should be drawn.\n     * @param edge  the axis location ({@code null} not permitted).\n     * @param space  the space already reserved.\n     *\n     * @return The space required to draw the axis.\n     */\n    @Override\n    public AxisSpace reserveSpace(Graphics2D g2, Plot plot, \n            Rectangle2D plotArea, RectangleEdge edge, AxisSpace space) {\n\n        // create a new space object if one wasn\u0027t supplied...\n        if (space \u003d\u003d null) {\n            space \u003d new AxisSpace();\n        }\n\n        // if the axis is not visible, no additional space is required...\n        if (!isVisible()) {\n            return space;\n        }\n\n        // calculate the max size of the tick labels (if visible)...\n        double tickLabelHeight \u003d 0.0;\n        double tickLabelWidth \u003d 0.0;\n        if (isTickLabelsVisible()) {\n            g2.setFont(getTickLabelFont());\n            AxisState state \u003d new AxisState();\n            // we call refresh ticks just to get the maximum width or height\n            refreshTicks(g2, state, plotArea, edge);\n            switch (edge) {\n                case TOP:\n                    tickLabelHeight \u003d state.getMax();\n                    break;\n                case BOTTOM:\n                    tickLabelHeight \u003d state.getMax();\n                    break;\n                case LEFT:\n                    tickLabelWidth \u003d state.getMax();\n                    break;\n                case RIGHT:\n                    tickLabelWidth \u003d state.getMax();\n                    break;\n                default:\n                    throw new IllegalStateException(\"Unexpected RectangleEdge value.\");\n            }\n        }\n\n        // get the axis label size and update the space object...\n        Rectangle2D labelEnclosure \u003d getLabelEnclosure(g2, edge);\n        double labelHeight, labelWidth;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            labelHeight \u003d labelEnclosure.getHeight();\n            space.add(labelHeight + tickLabelHeight\n                    + this.categoryLabelPositionOffset, edge);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            labelWidth \u003d labelEnclosure.getWidth();\n            space.add(labelWidth + tickLabelWidth\n                    + this.categoryLabelPositionOffset, edge);\n        }\n        return space;\n    }\n\n    /**\n     * Configures the axis against the current plot.\n     */\n    @Override\n    public void configure() {\n        // nothing required\n    }\n\n    /**\n     * Draws the axis on a Java 2D graphics device (such as the screen or a\n     * printer).\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param cursor  the cursor location.\n     * @param plotArea  the area within which the axis should be drawn\n     *                  ({@code null} not permitted).\n     * @param dataArea  the area within which the plot is being drawn\n     *                  ({@code null} not permitted).\n     * @param edge  the location of the axis ({@code null} not permitted).\n     * @param plotState  collects information about the plot\n     *                   ({@code null} permitted).\n     *\n     * @return The axis state (never {@code null}).\n     */\n    @Override\n    public AxisState draw(Graphics2D g2, double cursor, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge,\n            PlotRenderingInfo plotState) {\n\n        // if the axis is not visible, don\u0027t draw it...\n        if (!isVisible()) {\n            return new AxisState(cursor);\n        }\n\n        if (isAxisLineVisible()) {\n            drawAxisLine(g2, cursor, dataArea, edge);\n        }\n        AxisState state \u003d new AxisState(cursor);\n        if (isTickMarksVisible()) {\n            drawTickMarks(g2, cursor, dataArea, edge, state);\n        }\n\n        createAndAddEntity(cursor, state, dataArea, edge, plotState);\n\n        // draw the category labels and axis label\n        state \u003d drawCategoryLabels(g2, plotArea, dataArea, edge, state,\n                plotState);\n        if (getAttributedLabel() !\u003d null) {\n            state \u003d drawAttributedLabel(getAttributedLabel(), g2, plotArea, \n                    dataArea, edge, state);\n            \n        } else {\n            state \u003d drawLabel(getLabel(), g2, plotArea, dataArea, edge, state);\n        }\n        return state;\n\n    }\n\n    /**\n     * Draws the category labels and returns the updated axis state.\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param plotArea  the plot area ({@code null} not permitted).\n     * @param dataArea  the area inside the axes ({@code null} not\n     *                  permitted).\n     * @param edge  the axis location ({@code null} not permitted).\n     * @param state  the axis state ({@code null} not permitted).\n     * @param plotState  collects information about the plot ({@code null}\n     *                   permitted).\n     *\n     * @return The updated axis state (never {@code null}).\n     */\n    protected AxisState drawCategoryLabels(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state,\n            PlotRenderingInfo plotState) {\n\n        Args.nullNotPermitted(state, \"state\");\n        if (!isTickLabelsVisible()) {\n            return state;\n        }\n \n        List ticks \u003d refreshTicks(g2, state, plotArea, edge);\n        state.setTicks(ticks);\n        int categoryIndex \u003d 0;\n        for (Object o : ticks) {\n            CategoryTick tick \u003d (CategoryTick) o;\n            g2.setFont(getTickLabelFont(tick.getCategory()));\n            g2.setPaint(getTickLabelPaint(tick.getCategory()));\n\n            CategoryLabelPosition position\n                    \u003d this.categoryLabelPositions.getLabelPosition(edge);\n            double x0 \u003d 0.0;\n            double x1 \u003d 0.0;\n            double y0 \u003d 0.0;\n            double y1 \u003d 0.0;\n            if (edge \u003d\u003d RectangleEdge.TOP) {\n                x0 \u003d getCategoryStart(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                x1 \u003d getCategoryEnd(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                y1 \u003d state.getCursor() - this.categoryLabelPositionOffset;\n                y0 \u003d y1 - state.getMax();\n            }\n            else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n                x0 \u003d getCategoryStart(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                x1 \u003d getCategoryEnd(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                y0 \u003d state.getCursor() + this.categoryLabelPositionOffset;\n                y1 \u003d y0 + state.getMax();\n            }\n            else if (edge \u003d\u003d RectangleEdge.LEFT) {\n                y0 \u003d getCategoryStart(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                y1 \u003d getCategoryEnd(categoryIndex, ticks.size(), dataArea,\n                        edge);\n                x1 \u003d state.getCursor() - this.categoryLabelPositionOffset;\n                x0 \u003d x1 - state.getMax();\n            }\n            else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n                y0 \u003d getCategoryStart(categoryIndex, ticks.size(), dataArea, \n                        edge);\n                y1 \u003d getCategoryEnd(categoryIndex, ticks.size(), dataArea,\n                        edge);\n                x0 \u003d state.getCursor() + this.categoryLabelPositionOffset;\n                x1 \u003d x0 - state.getMax();\n            }\n            Rectangle2D area \u003d new Rectangle2D.Double(x0, y0, (x1 - x0),\n                    (y1 - y0));\n            Point2D anchorPoint \u003d position.getCategoryAnchor().getAnchorPoint(area);\n            TextBlock block \u003d tick.getLabel();\n            block.draw(g2, (float) anchorPoint.getX(),\n                    (float) anchorPoint.getY(), position.getLabelAnchor(),\n                    (float) anchorPoint.getX(), (float) anchorPoint.getY(),\n                    position.getAngle());\n            Shape bounds \u003d block.calculateBounds(g2,\n                    (float) anchorPoint.getX(), (float) anchorPoint.getY(),\n                    position.getLabelAnchor(), (float) anchorPoint.getX(),\n                    (float) anchorPoint.getY(), position.getAngle());\n            if (plotState !\u003d null \u0026\u0026 plotState.getOwner() !\u003d null) {\n                EntityCollection entities \u003d plotState.getOwner()\n                        .getEntityCollection();\n                if (entities !\u003d null) {\n                    String tooltip \u003d getCategoryLabelToolTip(\n                            tick.getCategory());\n                    String url \u003d getCategoryLabelURL(tick.getCategory());\n                    entities.add(new CategoryLabelEntity(tick.getCategory(),\n                            bounds, tooltip, url));\n                }\n            }\n            categoryIndex++;\n        }\n\n        if (edge.equals(RectangleEdge.TOP)) {\n            double h \u003d state.getMax() + this.categoryLabelPositionOffset;\n            state.cursorUp(h);\n        }\n        else if (edge.equals(RectangleEdge.BOTTOM)) {\n            double h \u003d state.getMax() + this.categoryLabelPositionOffset;\n            state.cursorDown(h);\n        }\n        else if (edge \u003d\u003d RectangleEdge.LEFT) {\n            double w \u003d state.getMax() + this.categoryLabelPositionOffset;\n            state.cursorLeft(w);\n        }\n        else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n            double w \u003d state.getMax() + this.categoryLabelPositionOffset;\n            state.cursorRight(w);\n        }\n        return state;\n    }\n\n    /**\n     * Creates a temporary list of ticks that can be used when drawing the axis.\n     *\n     * @param g2  the graphics device (used to get font measurements).\n     * @param state  the axis state.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the location of the axis.\n     *\n     * @return A list of ticks.\n     */\n    @Override\n    public List refreshTicks(Graphics2D g2, AxisState state, \n            Rectangle2D dataArea, RectangleEdge edge) {\n\n        List ticks \u003d new java.util.ArrayList(); // FIXME generics\n\n        // sanity check for data area...\n        if (dataArea.getHeight() \u003c\u003d 0.0 || dataArea.getWidth() \u003c 0.0) {\n            return ticks;\n        }\n\n        CategoryPlot plot \u003d (CategoryPlot) getPlot();\n        List categories \u003d plot.getCategoriesForAxis(this);\n        double max \u003d 0.0;\n\n        if (categories !\u003d null) {\n            CategoryLabelPosition position\n                    \u003d this.categoryLabelPositions.getLabelPosition(edge);\n            float r \u003d this.maximumCategoryLabelWidthRatio;\n            if (r \u003c\u003d 0.0) {\n                r \u003d position.getWidthRatio();\n            }\n\n            float l;\n            if (position.getWidthType() \u003d\u003d CategoryLabelWidthType.CATEGORY) {\n                l \u003d (float) calculateCategorySize(categories.size(), dataArea,\n                        edge);\n            }\n            else {\n                if (RectangleEdge.isLeftOrRight(edge)) {\n                    l \u003d (float) dataArea.getWidth();\n                }\n                else {\n                    l \u003d (float) dataArea.getHeight();\n                }\n            }\n            int categoryIndex \u003d 0;\n            for (Object o : categories) {\n                Comparable category \u003d (Comparable) o;\n                g2.setFont(getTickLabelFont(category));\n                TextBlock label \u003d createLabel(category, l * r, edge, g2);\n                if (edge \u003d\u003d RectangleEdge.TOP || edge \u003d\u003d RectangleEdge.BOTTOM) {\n                    max \u003d Math.max(max, calculateCategoryLabelHeight(label,\n                            position, getTickLabelInsets(), g2));\n                } else if (edge \u003d\u003d RectangleEdge.LEFT\n                        || edge \u003d\u003d RectangleEdge.RIGHT) {\n                    max \u003d Math.max(max, calculateCategoryLabelWidth(label,\n                            position, getTickLabelInsets(), g2));\n                }\n                Tick tick \u003d new CategoryTick(category, label,\n                        position.getLabelAnchor(),\n                        position.getRotationAnchor(), position.getAngle());\n                ticks.add(tick);\n                categoryIndex \u003d categoryIndex + 1;\n            }\n        }\n        state.setMax(max);\n        return ticks;\n\n    }\n\n    /**\n     * Draws the tick marks.\n     * \n     * @param g2  the graphics target.\n     * @param cursor  the cursor position (an offset when drawing multiple axes)\n     * @param dataArea  the area for plotting the data.\n     * @param edge  the location of the axis.\n     * @param state  the axis state.\n     */\n    public void drawTickMarks(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state) {\n\n        Plot p \u003d getPlot();\n        if (p \u003d\u003d null) {\n            return;\n        }\n        CategoryPlot plot \u003d (CategoryPlot) p;\n        double il \u003d getTickMarkInsideLength();\n        double ol \u003d getTickMarkOutsideLength();\n        Line2D line \u003d new Line2D.Double();\n        List\u003cComparable\u003e categories \u003d plot.getCategoriesForAxis(this);\n        g2.setPaint(getTickMarkPaint());\n        g2.setStroke(getTickMarkStroke());\n        Object saved \u003d g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, \n                RenderingHints.VALUE_STROKE_NORMALIZE);\n        if (edge.equals(RectangleEdge.TOP)) {\n            for (Comparable category : categories) {\n                double x \u003d getCategoryMiddle(category, categories, dataArea, edge);\n                line.setLine(x, cursor, x, cursor + il);\n                g2.draw(line);\n                line.setLine(x, cursor, x, cursor - ol);\n                g2.draw(line);\n            }\n            state.cursorUp(ol);\n        } else if (edge.equals(RectangleEdge.BOTTOM)) {\n            for (Comparable category : categories) {\n                double x \u003d getCategoryMiddle(category, categories, dataArea, edge);\n                line.setLine(x, cursor, x, cursor - il);\n                g2.draw(line);\n                line.setLine(x, cursor, x, cursor + ol);\n                g2.draw(line);\n            }\n            state.cursorDown(ol);\n        } else if (edge.equals(RectangleEdge.LEFT)) {\n            for (Comparable category : categories) {\n                double y \u003d getCategoryMiddle(category, categories, dataArea, edge);\n                line.setLine(cursor, y, cursor + il, y);\n                g2.draw(line);\n                line.setLine(cursor, y, cursor - ol, y);\n                g2.draw(line);\n            }\n            state.cursorLeft(ol);\n        } else if (edge.equals(RectangleEdge.RIGHT)) {\n            for (Comparable category : categories) {\n                double y \u003d getCategoryMiddle(category, categories, dataArea, edge);\n                line.setLine(cursor, y, cursor - il, y);\n                g2.draw(line);\n                line.setLine(cursor, y, cursor + ol, y);\n                g2.draw(line);\n            }\n            state.cursorRight(ol);\n        }\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, saved);\n    }\n\n    /**\n     * Creates a label.\n     *\n     * @param category  the category.\n     * @param width  the available width.\n     * @param edge  the edge on which the axis appears.\n     * @param g2  the graphics device.\n     *\n     * @return A label.\n     */\n    protected TextBlock createLabel(Comparable category, float width,\n            RectangleEdge edge, Graphics2D g2) {\n        TextBlock label \u003d TextUtils.createTextBlock(category.toString(),\n                getTickLabelFont(category), getTickLabelPaint(category), width,\n                this.maximumCategoryLabelLines, new G2TextMeasurer(g2));\n        return label;\n    }\n\n    /**\n     * Calculates the width of a category label when rendered.\n     *\n     * @param label  the text block ({@code null} not permitted).\n     * @param position  the position.\n     * @param insets  the label insets.\n     * @param g2  the graphics device.\n     *\n     * @return The width.\n     */\n    protected double calculateCategoryLabelWidth(TextBlock label, \n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2) {\n        Size2D size \u003d label.calculateDimensions(g2);\n        Rectangle2D box \u003d new Rectangle2D.Double(0.0, 0.0, size.getWidth(),\n                size.getHeight());\n        Shape rotatedBox \u003d ShapeUtils.rotateShape(box, position.getAngle(),\n                0.0f, 0.0f);\n        double w \u003d rotatedBox.getBounds2D().getWidth() + insets.getLeft()\n                + insets.getRight();\n        return w;\n    }\n\n    /**\n     * Calculates the height of a category label when rendered.\n     *\n     * @param block  the text block ({@code null} not permitted).\n     * @param position  the label position ({@code null} not permitted).\n     * @param insets  the label insets ({@code null} not permitted).\n     * @param g2  the graphics device ({@code null} not permitted).\n     *\n     * @return The height.\n     */\n    protected double calculateCategoryLabelHeight(TextBlock block,\n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2) {\n        Size2D size \u003d block.calculateDimensions(g2);\n        Rectangle2D box \u003d new Rectangle2D.Double(0.0, 0.0, size.getWidth(),\n                size.getHeight());\n        Shape rotatedBox \u003d ShapeUtils.rotateShape(box, position.getAngle(),\n                0.0f, 0.0f);\n        double h \u003d rotatedBox.getBounds2D().getHeight()\n                   + insets.getTop() + insets.getBottom();\n        return h;\n    }\n\n    /**\n     * Creates a clone of the axis.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException if some component of the axis does\n     *         not support cloning.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        CategoryAxis clone \u003d (CategoryAxis) super.clone();\n        clone.tickLabelFontMap \u003d new HashMap\u003c\u003e(this.tickLabelFontMap);\n        clone.tickLabelPaintMap \u003d new HashMap\u003c\u003e(this.tickLabelPaintMap);\n        clone.categoryLabelToolTips \u003d new HashMap\u003c\u003e(this.categoryLabelToolTips);\n        clone.categoryLabelURLs \u003d new HashMap\u003c\u003e(this.categoryLabelToolTips);\n        return clone;\n    }\n\n    /**\n     * Tests this axis for equality with an arbitrary object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryAxis)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        CategoryAxis that \u003d (CategoryAxis) obj;\n        if (that.lowerMargin !\u003d this.lowerMargin) {\n            return false;\n        }\n        if (that.upperMargin !\u003d this.upperMargin) {\n            return false;\n        }\n        if (that.categoryMargin !\u003d this.categoryMargin) {\n            return false;\n        }\n        if (that.maximumCategoryLabelWidthRatio\n                !\u003d this.maximumCategoryLabelWidthRatio) {\n            return false;\n        }\n        if (that.categoryLabelPositionOffset\n                !\u003d this.categoryLabelPositionOffset) {\n            return false;\n        }\n        if (!Objects.equals(that.categoryLabelPositions, this.categoryLabelPositions)) {\n            return false;\n        }\n        if (!Objects.equals(that.categoryLabelToolTips, this.categoryLabelToolTips)) {\n            return false;\n        }\n        if (!Objects.equals(this.categoryLabelURLs, that.categoryLabelURLs)) {\n            return false;\n        }\n        if (!Objects.equals(this.tickLabelFontMap, that.tickLabelFontMap)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.tickLabelPaintMap, that.tickLabelPaintMap)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this object.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        return super.hashCode();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        writePaintMap(this.tickLabelPaintMap, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.tickLabelPaintMap \u003d readPaintMap(stream);\n    }\n\n    /**\n     * Reads a {@code Map} of ({@code Comparable}, {@code Paint})\n     * elements from a stream.\n     *\n     * @param in  the input stream.\n     *\n     * @return The map.\n     *\n     * @throws IOException\n     * @throws ClassNotFoundException\n     *\n     * @see #writePaintMap(Map, ObjectOutputStream)\n     */\n    private Map readPaintMap(ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n        boolean isNull \u003d in.readBoolean();\n        if (isNull) {\n            return null;\n        }\n        Map result \u003d new HashMap();\n        int count \u003d in.readInt();\n        for (int i \u003d 0; i \u003c count; i++) {\n            Comparable category \u003d (Comparable) in.readObject();\n            Paint paint \u003d SerialUtils.readPaint(in);\n            result.put(category, paint);\n        }\n        return result;\n    }\n\n    /**\n     * Writes a map of ({@code Comparable}, {@code Paint})\n     * elements to a stream.\n     *\n     * @param map  the map ({@code null} permitted).\n     *\n     * @param out\n     * @throws IOException\n     *\n     * @see #readPaintMap(ObjectInputStream)\n     */\n    private void writePaintMap(Map map, ObjectOutputStream out)\n            throws IOException {\n        if (map \u003d\u003d null) {\n            out.writeBoolean(true);\n        }\n        else {\n            out.writeBoolean(false);\n            Set keys \u003d map.keySet();\n            int count \u003d keys.size();\n            out.writeInt(count);\n            for (Object o : keys) {\n                Comparable key \u003d (Comparable) o;\n                out.writeObject(key);\n                SerialUtils.writePaint((Paint) map.get(key), out);\n            }\n        }\n    }\n\n}","methodCount":53,"staticMethodCount":0,"instanceMethodCount":53,"classLoc":1328,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":3,"candidates":[{"lineStart":1108,"lineEnd":1172,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method drawTickMarks to class AxisState","description":"Move method drawTickMarks to org.jfree.chart.axis.AxisState\nRationale: The \u0027drawTickMarks\u0027 method involves updating the cursor position during the drawing process based on the provided \u0027edge\u0027 parameter, which directly affects the state of the axis. \u0027AxisState\u0027 is responsible for maintaining the state information of an axis during the drawing process. It manages the cursor position and ticks, which aligns with the operations performed in \u0027drawTickMarks\u0027. Therefore, placing this method in \u0027AxisState\u0027 makes the most sense as it can effectively manage the drawing state and updates required for the tick marks.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false,"userRating":"Helpful"},{"lineStart":1214,"lineEnd":1234,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method calculateCategoryLabelHeight to class TextBlock","description":"Move method calculateCategoryLabelHeight to org.jfree.chart.text.TextBlock\nRationale: The method `calculateCategoryLabelHeight` relies heavily on the `TextBlock` class for its main functionality, specifically the `calculateDimensions` method to determine the size of the text block. Since text block dimension calculation is a core responsibility of the `TextBlock` class, moving this method there aligns with the principle of cohesion, ensuring that related functionalities are grouped together. This will also enhance maintainability as any changes to text dimension calculations will be localized within the `TextBlock` class.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Helpful"},{"lineStart":668,"lineEnd":701,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method getCategorySeriesMiddle to class CategoryDataset","description":"Move method getCategorySeriesMiddle to org.jfree.data.category.CategoryDataset\nRationale: The method getCategorySeriesMiddle() is tightly coupled with the CategoryDataset interface since it deals heavily with the dataset\u0027s category and series indices. This method is logically related to data operations that can be directly performed on the dataset itself. Moving this method to CategoryDataset would encapsulate all category series-related calculation logic within the dataset, making it more cohesive and easier to maintain.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false,"userRating":"Somewhat Helpful"}]},"userSelectionTelemetryData":{"lineStart":668,"lineEnd":701,"functionSize":34,"positionInHostFunction":592,"selectedCandidateIndex":2,"candidateType":"AS_IS","elementsType":[{"elementType":"METHOD","quantity":1}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":665742},{"candidateIndex":1,"elapsedTime":152931},{"candidateIndex":2,"elapsedTime":382372}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":33232},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"getCategorySeriesMiddle","method_signature":"public getCategorySeriesMiddle(Comparable category,\n            Comparable seriesKey, CategoryDataset dataset, double itemMargin,\n            Rectangle2D area, RectangleEdge edge)","target_class":"","rationale":""},{"method_name":"drawCategoryLabels","method_signature":"protected drawCategoryLabels(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state,\n            PlotRenderingInfo plotState)","target_class":"","rationale":""},{"method_name":"drawTickMarks","method_signature":"public drawTickMarks(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state)","target_class":"","rationale":""},{"method_name":"calculateCategoryLabelWidth","method_signature":"protected calculateCategoryLabelWidth(TextBlock label, \n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""},{"method_name":"calculateCategoryLabelHeight","method_signature":"protected calculateCategoryLabelHeight(TextBlock block,\n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"drawTickMarks","method_signature":"public drawTickMarks(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state)","target_class":"","rationale":""},{"method_name":"drawCategoryLabels","method_signature":"protected drawCategoryLabels(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state,\n            PlotRenderingInfo plotState)","target_class":"","rationale":""},{"method_name":"calculateCategoryLabelHeight","method_signature":"protected calculateCategoryLabelHeight(TextBlock block,\n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""},{"method_name":"getCategorySeriesMiddle","method_signature":"public getCategorySeriesMiddle(Comparable category,\n            Comparable seriesKey, CategoryDataset dataset, double itemMargin,\n            Rectangle2D area, RectangleEdge edge)","target_class":"","rationale":""},{"method_name":"calculateCategoryLabelWidth","method_signature":"protected calculateCategoryLabelWidth(TextBlock label, \n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public drawTickMarks(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state)":{"first":{"method_name":"drawTickMarks","method_signature":"public drawTickMarks(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state)","target_class":"","rationale":""},"second":0.5957687788428276},"protected drawCategoryLabels(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state,\n            PlotRenderingInfo plotState)":{"first":{"method_name":"drawCategoryLabels","method_signature":"protected drawCategoryLabels(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, AxisState state,\n            PlotRenderingInfo plotState)","target_class":"","rationale":""},"second":0.5990457865804262},"protected calculateCategoryLabelHeight(TextBlock block,\n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)":{"first":{"method_name":"calculateCategoryLabelHeight","method_signature":"protected calculateCategoryLabelHeight(TextBlock block,\n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""},"second":0.7492838377176047},"public getCategorySeriesMiddle(Comparable category,\n            Comparable seriesKey, CategoryDataset dataset, double itemMargin,\n            Rectangle2D area, RectangleEdge edge)":{"first":{"method_name":"getCategorySeriesMiddle","method_signature":"public getCategorySeriesMiddle(Comparable category,\n            Comparable seriesKey, CategoryDataset dataset, double itemMargin,\n            Rectangle2D area, RectangleEdge edge)","target_class":"","rationale":""},"second":0.7869275000000587},"protected calculateCategoryLabelWidth(TextBlock label, \n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)":{"first":{"method_name":"calculateCategoryLabelWidth","method_signature":"protected calculateCategoryLabelWidth(TextBlock label, \n            CategoryLabelPosition position, RectangleInsets insets, Graphics2D g2)","target_class":"","rationale":""},"second":0.8052308864395809}},"targetClassMap":{"drawTickMarks":{"target_classes":[{"class_name":"RectangleEdge","similarity_score":0.361986331459829},{"class_name":"AxisState","similarity_score":0.521351834157547},{"class_name":"CategoryLabelPositions","similarity_score":0.4240434314852193}],"target_classes_sorted_by_llm":["AxisState","CategoryLabelPositions","RectangleEdge"],"llm_response_time":7150,"similarity_computation_time":2,"similarity_metric":"cosine"},"drawCategoryLabels":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5242,"similarity_computation_time":0,"similarity_metric":"cosine"},"calculateCategoryLabelHeight":{"target_classes":[{"class_name":"TextBlock","similarity_score":0.7011913103331406},{"class_name":"CategoryLabelPosition","similarity_score":0.7361336689221182},{"class_name":"RectangleInsets","similarity_score":0.6933703123527621},{"class_name":"CategoryLabelPositions","similarity_score":0.6654201622829171}],"target_classes_sorted_by_llm":["TextBlock","CategoryLabelPosition","RectangleInsets"],"llm_response_time":7675,"similarity_computation_time":3,"similarity_metric":"cosine"},"getCategorySeriesMiddle":{"target_classes":[{"class_name":"CategoryDataset","similarity_score":0.4133068570297462},{"class_name":"RectangleEdge","similarity_score":0.5433384646359788},{"class_name":"CategoryLabelPositions","similarity_score":0.6277228465829806}],"target_classes_sorted_by_llm":["CategoryDataset","RectangleEdge","CategoryLabelPositions"],"llm_response_time":6374,"similarity_computation_time":2,"similarity_metric":"cosine"},"calculateCategoryLabelWidth":{"target_classes":[{"class_name":"TextBlock","similarity_score":0.7646439778966989},{"class_name":"CategoryLabelPosition","similarity_score":0.7621550089818219},{"class_name":"RectangleInsets","similarity_score":0.7712776634736744},{"class_name":"CategoryLabelPositions","similarity_score":0.6868161123688303}],"target_classes_sorted_by_llm":["CategoryLabelPosition","TextBlock","RectangleInsets"],"llm_response_time":6629,"similarity_computation_time":4,"similarity_metric":"cosine"}}}
{"id":"55fd0711-135e-456c-b6c0-f99c8dd7d453","hostFunctionTelemetryData":{"hostFunctionSize":4791,"lineStart":112,"lineEnd":4902,"bodyLineStart":112,"language":"java","filePath":"/Users/snehil/Documents/ConcordiaUniversity/Material/SOEN-6491-Refactoring/OpenSource/jfreechart/jfreechart/src/main/java/org/jfree/chart/plot/CategoryPlot.java","sourceCode":"/**\n * A general plotting class that uses data from a {@link CategoryDataset} and\n * renders each data item using a {@link CategoryItemRenderer}.\n */\npublic class CategoryPlot\u003cR extends Comparable\u003cR\u003e, C extends Comparable\u003cC\u003e\u003e \n        extends Plot implements ValueAxisPlot, Pannable,\n        Zoomable, AnnotationChangeListener, RendererChangeListener,\n        Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -3537691700434728188L;\n\n    /**\n     * The default visibility of the grid lines plotted against the domain\n     * axis.\n     */\n    public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE \u003d false;\n\n    /**\n     * The default visibility of the grid lines plotted against the range\n     * axis.\n     */\n    public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE \u003d true;\n\n    /** The default grid line stroke. */\n    public static final Stroke DEFAULT_GRIDLINE_STROKE \u003d new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[]\n            {2.0f, 2.0f}, 0.0f);\n\n    /** The default grid line paint. */\n    public static final Paint DEFAULT_GRIDLINE_PAINT \u003d Color.LIGHT_GRAY;\n\n    /** The default value label font. */\n    public static final Font DEFAULT_VALUE_LABEL_FONT \u003d new Font(\"SansSerif\",\n            Font.PLAIN, 10);\n\n    /**\n     * The default crosshair visibility.\n     */\n    public static final boolean DEFAULT_CROSSHAIR_VISIBLE \u003d false;\n\n    /**\n     * The default crosshair stroke.\n     */\n    public static final Stroke DEFAULT_CROSSHAIR_STROKE\n            \u003d DEFAULT_GRIDLINE_STROKE;\n\n    /**\n     * The default crosshair paint.\n     */\n    public static final Paint DEFAULT_CROSSHAIR_PAINT \u003d Color.BLUE;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources\n            \u003d ResourceBundle.getBundle(\"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** The plot orientation. */\n    private PlotOrientation orientation;\n\n    /** The offset between the data area and the axes. */\n    private RectangleInsets axisOffset;\n\n    /** Storage for the domain axes. */\n    private Map\u003cInteger, CategoryAxis\u003e domainAxes;\n\n    /** Storage for the domain axis locations. */\n    private Map\u003cInteger, AxisLocation\u003e domainAxisLocations;\n\n    /**\n     * A flag that controls whether or not the shared domain axis is drawn\n     * (only relevant when the plot is being used as a subplot).\n     */\n    private boolean drawSharedDomainAxis;\n\n    /** Storage for the range axes. */\n    private Map\u003cInteger, ValueAxis\u003e rangeAxes;\n\n    /** Storage for the range axis locations. */\n    private Map\u003cInteger, AxisLocation\u003e rangeAxisLocations;\n\n    /** Storage for the datasets. */\n    private Map\u003cInteger, CategoryDataset\u003cR, C\u003e\u003e datasets;\n\n    /** \n     * Storage for keys that map each dataset to one or more domain axes.\n     * Typically a dataset is rendered using the scale of a single axis, but\n     * a dataset can contribute to the \"auto-range\" of any number of axes.\n     */\n    private TreeMap\u003cInteger, List\u003cInteger\u003e\u003e datasetToDomainAxesMap;\n\n    /** \n     * Storage for keys that map each dataset to one or more range axes. \n     * Typically a dataset is rendered using the scale of a single axis, but\n     * a dataset can contribute to the \"auto-range\" of any number of axes.\n     */\n    private TreeMap\u003cInteger, List\u003cInteger\u003e\u003e datasetToRangeAxesMap;\n\n    /** Storage for the renderers. */\n    private Map\u003cInteger, CategoryItemRenderer\u003e renderers;\n\n    /** The dataset rendering order. */\n    private DatasetRenderingOrder renderingOrder\n            \u003d DatasetRenderingOrder.REVERSE;\n\n    /**\n     * Controls the order in which the columns are traversed when rendering the\n     * data items.\n     */\n    private SortOrder columnRenderingOrder \u003d SortOrder.ASCENDING;\n\n    /**\n     * Controls the order in which the rows are traversed when rendering the\n     * data items.\n     */\n    private SortOrder rowRenderingOrder \u003d SortOrder.ASCENDING;\n\n    /**\n     * A flag that controls whether the grid-lines for the domain axis are\n     * visible.\n     */\n    private boolean domainGridlinesVisible;\n\n    /** The position of the domain gridlines relative to the category. */\n    private CategoryAnchor domainGridlinePosition;\n\n    /** The stroke used to draw the domain grid-lines. */\n    private transient Stroke domainGridlineStroke;\n\n    /** The paint used to draw the domain  grid-lines. */\n    private transient Paint domainGridlinePaint;\n\n    /**\n     * A flag that controls whether or not the zero baseline against the range\n     * axis is visible.\n     */\n    private boolean rangeZeroBaselineVisible;\n\n    /**\n     * The stroke used for the zero baseline against the range axis.\n     */\n    private transient Stroke rangeZeroBaselineStroke;\n\n    /**\n     * The paint used for the zero baseline against the range axis.\n     */\n    private transient Paint rangeZeroBaselinePaint;\n\n    /**\n     * A flag that controls whether the grid-lines for the range axis are\n     * visible.\n     */\n    private boolean rangeGridlinesVisible;\n\n    /** The stroke used to draw the range axis grid-lines. */\n    private transient Stroke rangeGridlineStroke;\n\n    /** The paint used to draw the range axis grid-lines. */\n    private transient Paint rangeGridlinePaint;\n\n    /**\n     * A flag that controls whether or not gridlines are shown for the minor\n     * tick values on the primary range axis.\n     */\n    private boolean rangeMinorGridlinesVisible;\n\n    /**\n     * The stroke used to draw the range minor grid-lines.\n     */\n    private transient Stroke rangeMinorGridlineStroke;\n\n    /**\n     * The paint used to draw the range minor grid-lines.\n     */\n    private transient Paint rangeMinorGridlinePaint;\n\n    /** The anchor value. */\n    private double anchorValue;\n\n    /**\n     * The index for the dataset that the crosshairs are linked to (this\n     * determines which axes the crosshairs are plotted against).\n     */\n    private int crosshairDatasetIndex;\n\n    /**\n     * A flag that controls the visibility of the domain crosshair.\n     */\n    private boolean domainCrosshairVisible;\n\n    /**\n     * The row key for the crosshair point.\n     */\n    private R domainCrosshairRowKey;\n\n    /**\n     * The column key for the crosshair point.\n     */\n    private C domainCrosshairColumnKey;\n\n    /**\n     * The stroke used to draw the domain crosshair if it is visible.\n     */\n    private transient Stroke domainCrosshairStroke;\n\n    /**\n     * The paint used to draw the domain crosshair if it is visible.\n     */\n    private transient Paint domainCrosshairPaint;\n\n    /** A flag that controls whether or not a range crosshair is drawn. */\n    private boolean rangeCrosshairVisible;\n\n    /** The range crosshair value. */\n    private double rangeCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke rangeCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint rangeCrosshairPaint;\n\n    /**\n     * A flag that controls whether or not the crosshair locks onto actual\n     * data points.\n     */\n    private boolean rangeCrosshairLockedOnData \u003d true;\n\n    /** A map containing lists of markers for the domain axes. */\n    private Map\u003cInteger, Collection\u003cCategoryMarker\u003e\u003e foregroundDomainMarkers;\n\n    /** A map containing lists of markers for the domain axes. */\n    private Map\u003cInteger, Collection\u003cCategoryMarker\u003e\u003e backgroundDomainMarkers;\n\n    /** A map containing lists of markers for the range axes. */\n    private Map\u003cInteger, Collection\u003cMarker\u003e\u003e foregroundRangeMarkers;\n\n    /** A map containing lists of markers for the range axes. */\n    private Map\u003cInteger, Collection\u003cMarker\u003e\u003e backgroundRangeMarkers;\n\n    /**\n     * A (possibly empty) list of annotations for the plot.  The list should\n     * be initialised in the constructor and never allowed to be {@code null}.\n     */\n    private List\u003cCategoryAnnotation\u003e annotations;\n\n    /**\n     * The weight for the plot (only relevant when the plot is used as a subplot\n     * within a combined plot).\n     */\n    private int weight;\n\n    /** The fixed space for the domain axis. */\n    private AxisSpace fixedDomainAxisSpace;\n\n    /** The fixed space for the range axis. */\n    private AxisSpace fixedRangeAxisSpace;\n\n    /**\n     * An optional collection of legend items that can be returned by the\n     * getLegendItems() method.\n     */\n    private LegendItemCollection fixedLegendItems;\n\n    /**\n     * A flag that controls whether or not panning is enabled for the\n     * range axis/axes.\n     */\n    private boolean rangePannable;\n\n    /**\n     * The shadow generator for the plot ({@code null} permitted).\n     */\n    private ShadowGenerator shadowGenerator;\n\n    /**\n     * Default constructor.\n     */\n    public CategoryPlot() {\n        this(null, null, null, null);\n    }\n\n    /**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset ({@code null} permitted).\n     * @param domainAxis  the domain axis ({@code null} permitted).\n     * @param rangeAxis  the range axis ({@code null} permitted).\n     * @param renderer  the item renderer ({@code null} permitted).\n     *\n     */\n    public CategoryPlot(CategoryDataset\u003cR, C\u003e dataset, CategoryAxis domainAxis,\n            ValueAxis rangeAxis, CategoryItemRenderer renderer) {\n\n        super();\n\n        this.orientation \u003d PlotOrientation.VERTICAL;\n\n        // allocate storage for dataset, axes and renderers\n        this.domainAxes \u003d new HashMap\u003c\u003e();\n        this.domainAxisLocations \u003d new HashMap\u003c\u003e();\n        this.rangeAxes \u003d new HashMap\u003c\u003e();\n        this.rangeAxisLocations \u003d new HashMap\u003c\u003e();\n\n        this.datasetToDomainAxesMap \u003d new TreeMap\u003c\u003e();\n        this.datasetToRangeAxesMap \u003d new TreeMap\u003c\u003e();\n\n        this.renderers \u003d new HashMap\u003c\u003e();\n\n        this.datasets \u003d new HashMap\u003c\u003e();\n        this.datasets.put(0, dataset);\n        if (dataset !\u003d null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.axisOffset \u003d RectangleInsets.ZERO_INSETS;\n        this.domainAxisLocations.put(0, AxisLocation.BOTTOM_OR_LEFT);\n        this.rangeAxisLocations.put(0, AxisLocation.TOP_OR_LEFT);\n\n        this.renderers.put(0, renderer);\n        if (renderer !\u003d null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.put(0, domainAxis);\n        mapDatasetToDomainAxis(0, 0);\n        if (domainAxis !\u003d null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.drawSharedDomainAxis \u003d false;\n\n        this.rangeAxes.put(0, rangeAxis);\n        mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis !\u003d null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n\n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible \u003d DEFAULT_DOMAIN_GRIDLINES_VISIBLE;\n        this.domainGridlinePosition \u003d CategoryAnchor.MIDDLE;\n        this.domainGridlineStroke \u003d DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint \u003d DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeZeroBaselineVisible \u003d false;\n        this.rangeZeroBaselinePaint \u003d Color.BLACK;\n        this.rangeZeroBaselineStroke \u003d new BasicStroke(0.5f);\n\n        this.rangeGridlinesVisible \u003d DEFAULT_RANGE_GRIDLINES_VISIBLE;\n        this.rangeGridlineStroke \u003d DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint \u003d DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeMinorGridlinesVisible \u003d false;\n        this.rangeMinorGridlineStroke \u003d DEFAULT_GRIDLINE_STROKE;\n        this.rangeMinorGridlinePaint \u003d Color.WHITE;\n\n        this.foregroundDomainMarkers \u003d new HashMap\u003c\u003e();\n        this.backgroundDomainMarkers \u003d new HashMap\u003c\u003e();\n        this.foregroundRangeMarkers \u003d new HashMap\u003c\u003e();\n        this.backgroundRangeMarkers \u003d new HashMap\u003c\u003e();\n\n        this.anchorValue \u003d 0.0;\n\n        this.domainCrosshairVisible \u003d false;\n        this.domainCrosshairStroke \u003d DEFAULT_CROSSHAIR_STROKE;\n        this.domainCrosshairPaint \u003d DEFAULT_CROSSHAIR_PAINT;\n\n        this.rangeCrosshairVisible \u003d DEFAULT_CROSSHAIR_VISIBLE;\n        this.rangeCrosshairValue \u003d 0.0;\n        this.rangeCrosshairStroke \u003d DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint \u003d DEFAULT_CROSSHAIR_PAINT;\n\n        this.annotations \u003d new ArrayList\u003c\u003e();\n\n        this.rangePannable \u003d false;\n        this.shadowGenerator \u003d null;\n    }\n\n    /**\n     * Returns a string describing the type of plot.\n     *\n     * @return The type.\n     */\n    @Override\n    public String getPlotType() {\n        return localizationResources.getString(\"Category_Plot\");\n    }\n\n    /**\n     * Returns the orientation of the plot.\n     *\n     * @return The orientation of the plot (never {@code null}).\n     *\n     * @see #setOrientation(PlotOrientation)\n     */\n    @Override\n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param orientation  the orientation ({@code null} not permitted).\n     *\n     * @see #getOrientation()\n     */\n    public void setOrientation(PlotOrientation orientation) {\n        Args.nullNotPermitted(orientation, \"orientation\");\n        this.orientation \u003d orientation;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the axis offset.\n     *\n     * @return The axis offset (never {@code null}).\n     *\n     * @see #setAxisOffset(RectangleInsets)\n     */\n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    /**\n     * Sets the axis offsets (gap between the data area and the axes) and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset ({@code null} not permitted).\n     *\n     * @see #getAxisOffset()\n     */\n    public void setAxisOffset(RectangleInsets offset) {\n        Args.nullNotPermitted(offset, \"offset\");\n        this.axisOffset \u003d offset;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain axis for the plot.  If the domain axis for this plot\n     * is {@code null}, then the method will return the parent plot\u0027s\n     * domain axis (if there is a parent plot).\n     *\n     * @return The domain axis ({@code null} permitted).\n     *\n     * @see #setDomainAxis(CategoryAxis)\n     */\n    public CategoryAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    /**\n     * Returns a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis ({@code null} possible).\n     *\n     * @see #setDomainAxis(int, CategoryAxis)\n     */\n    public CategoryAxis getDomainAxis(int index) {\n        CategoryAxis result \u003d this.domainAxes.get(index);\n        if (result \u003d\u003d null) {\n            Plot parent \u003d getParent();\n            if (parent instanceof CategoryPlot) {\n                @SuppressWarnings(\"unchecked\")\n                CategoryPlot\u003cR, C\u003e cp \u003d (CategoryPlot) parent;\n                result \u003d cp.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a map containing the domain axes that are assigned to this plot.\n     * The map is unmodifiable.\n     * \n     * @return A map containing the domain axes that are assigned to the plot \n     *     (never {@code null}).\n     * \n     * @since 1.5.4\n     */\n    public Map\u003cInteger, CategoryAxis\u003e getDomainAxes() {\n        return Collections.unmodifiableMap(this.domainAxes);\n    }\n    \n    /**\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis ({@code null} permitted).\n     *\n     * @see #getDomainAxis()\n     */\n    public void setDomainAxis(CategoryAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    /**\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis ({@code null} permitted).\n     *\n     * @see #getDomainAxis(int)\n     */\n    public void setDomainAxis(int index, CategoryAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n\n    /**\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis ({@code null} permitted).\n     * @param notify  notify listeners?\n     */\n    public void setDomainAxis(int index, CategoryAxis axis, boolean notify) {\n        CategoryAxis existing \u003d this.domainAxes.get(index);\n        if (existing !\u003d null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis !\u003d null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.put(index, axis);\n        if (axis !\u003d null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axes  the axes ({@code null} not permitted).\n     *\n     * @see #setRangeAxes(ValueAxis[])\n     */\n    public void setDomainAxes(CategoryAxis[] axes) {\n        for (int i \u003d 0; i \u003c axes.length; i++) {\n            setDomainAxis(i, axes[i], false);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the index of the specified axis, or {@code -1} if the axis\n     * is not assigned to the plot.\n     *\n     * @param axis  the axis ({@code null} not permitted).\n     *\n     * @return The axis index.\n     *\n     * @see #getDomainAxis(int)\n     * @see #getRangeAxisIndex(ValueAxis)\n     */\n    public int getDomainAxisIndex(CategoryAxis axis) {\n        Args.nullNotPermitted(axis, \"axis\");\n        for (Entry\u003cInteger, CategoryAxis\u003e entry : this.domainAxes.entrySet()) {\n            if (entry.getValue() \u003d\u003d axis) {\n                return entry.getKey();\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the domain axis location for the primary domain axis.\n     *\n     * @return The location (never {@code null}).\n     *\n     * @see #getRangeAxisLocation()\n     */\n    public AxisLocation getDomainAxisLocation() {\n        return getDomainAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     *\n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result \u003d this.domainAxisLocations.get(index);\n        if (result \u003d\u003d null) {\n            result \u003d AxisLocation.getOpposite(getDomainAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the axis location ({@code null} not permitted).\n     *\n     * @see #getDomainAxisLocation()\n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the axis location ({@code null} not permitted).\n     * @param notify  a flag that controls whether listeners are notified.\n     */\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     *\n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     *\n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location,\n            boolean notify) {\n        if (index \u003d\u003d 0 \u0026\u0026 location \u003d\u003d null) {\n            throw new IllegalArgumentException(\n                    \"Null \u0027location\u0027 for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.put(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the domain axis edge.  This is derived from the axis location\n     * and the plot orientation.\n     *\n     * @return The edge (never {@code null}).\n     */\n    public RectangleEdge getDomainAxisEdge() {\n        return getDomainAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge (never {@code null}).\n     */\n    public RectangleEdge getDomainAxisEdge(int index) {\n        RectangleEdge result;\n        AxisLocation location \u003d getDomainAxisLocation(index);\n        if (location !\u003d null) {\n            result \u003d Plot.resolveDomainAxisLocation(location, this.orientation);\n        } else {\n            result \u003d RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of domain axes.\n     *\n     * @return The axis count.\n     */\n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    /**\n     * Clears the domain axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     */\n    public void clearDomainAxes() {\n        for (CategoryAxis xAxis : this.domainAxes.values()) {\n            if (xAxis !\u003d null) {\n                xAxis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the domain axes.\n     */\n    public void configureDomainAxes() {\n        for (CategoryAxis xAxis : this.domainAxes.values()) {\n            if (xAxis !\u003d null) {\n                xAxis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the range axis for the plot.  If the range axis for this plot is\n     * null, then the method will return the parent plot\u0027s range axis (if there\n     * is a parent plot).\n     *\n     * @return The range axis (possibly {@code null}).\n     */\n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    /**\n     * Returns a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis ({@code null} possible).\n     */\n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result \u003d this.rangeAxes.get(index);\n        if (result \u003d\u003d null) {\n            Plot parent \u003d getParent();\n            if (parent instanceof CategoryPlot) {\n                @SuppressWarnings(\"unchecked\")\n                CategoryPlot\u003cR, C\u003e cp \u003d (CategoryPlot) parent;\n                result \u003d cp.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a map containing the range axes that are assigned to this plot.\n     * The map is unmodifiable.\n     * \n     * @return A map containing the domain axes that are assigned to the plot \n     *     (never {@code null}).\n     * \n     * @since 1.5.4\n     */\n    public Map\u003cInteger, ValueAxis\u003e getRangeAxes() {\n        return Collections.unmodifiableMap(this.rangeAxes);\n    }\n\n    /**\n     * Sets the range axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis ({@code null} permitted).\n     */\n    public void setRangeAxis(ValueAxis axis) {\n        setRangeAxis(0, axis);\n    }\n\n    /**\n     * Sets a range axis and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     */\n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    }\n\n    /**\n     * Sets a range axis and, if requested, sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     * @param notify  notify listeners?\n     */\n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing \u003d this.rangeAxes.get(index);\n        if (existing !\u003d null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis !\u003d null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.put(index, axis);\n        if (axis !\u003d null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the range axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axes  the axes ({@code null} not permitted).\n     *\n     * @see #setDomainAxes(CategoryAxis[])\n     */\n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i \u003d 0; i \u003c axes.length; i++) {\n            setRangeAxis(i, axes[i], false);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the index of the specified axis, or {@code -1} if the axis\n     * is not assigned to the plot.\n     *\n     * @param axis  the axis ({@code null} not permitted).\n     *\n     * @return The axis index.\n     *\n     * @see #getRangeAxis(int)\n     * @see #getDomainAxisIndex(CategoryAxis)\n     */\n    public int getRangeAxisIndex(ValueAxis axis) {\n        Args.nullNotPermitted(axis, \"axis\");\n        int result \u003d findRangeAxisIndex(axis);\n        if (result \u003c 0) { // try the parent plot\n            Plot parent \u003d getParent();\n            if (parent instanceof CategoryPlot) {\n                @SuppressWarnings(\"unchecked\")\n                CategoryPlot\u003cR, C\u003e p \u003d (CategoryPlot) parent;\n                result \u003d p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    private int findRangeAxisIndex(ValueAxis axis) {\n        for (Entry\u003cInteger, ValueAxis\u003e entry : this.rangeAxes.entrySet()) {\n            if (entry.getValue() \u003d\u003d axis) {\n                return entry.getKey();\n            }\n        }\n        return -1;\n    }\n    \n    /**\n     * Returns the range axis location.\n     *\n     * @return The location (never {@code null}).\n     */\n    public AxisLocation getRangeAxisLocation() {\n        return getRangeAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     *\n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result \u003d this.rangeAxisLocations.get(index);\n        if (result \u003d\u003d null) {\n            result \u003d AxisLocation.getOpposite(getRangeAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the location ({@code null} not permitted).\n     *\n     * @see #setRangeAxisLocation(AxisLocation, boolean)\n     * @see #setDomainAxisLocation(AxisLocation)\n     */\n    public void setRangeAxisLocation(AxisLocation location) {\n        // defer argument checking...\n        setRangeAxisLocation(location, true);\n    }\n\n    /**\n     * Sets the location of the range axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location ({@code null} not permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #setDomainAxisLocation(AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     *\n     * @see #getRangeAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        setRangeAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     *\n     * @see #getRangeAxisLocation(int)\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location,\n            boolean notify) {\n        if (index \u003d\u003d 0 \u0026\u0026 location \u003d\u003d null) {\n            throw new IllegalArgumentException(\n                    \"Null \u0027location\u0027 for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.put(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the edge where the primary range axis is located.\n     *\n     * @return The edge (never {@code null}).\n     */\n    public RectangleEdge getRangeAxisEdge() {\n        return getRangeAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     */\n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location \u003d getRangeAxisLocation(index);\n        return Plot.resolveRangeAxisLocation(location, this.orientation);\n    }\n\n    /**\n     * Returns the number of range axes.\n     *\n     * @return The axis count.\n     */\n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    /**\n     * Clears the range axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     */\n    public void clearRangeAxes() {\n        for (ValueAxis yAxis : this.rangeAxes.values()) {\n            if (yAxis !\u003d null) {\n                yAxis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the range axes.\n     */\n    public void configureRangeAxes() {\n        for (ValueAxis yAxis : this.rangeAxes.values()) {\n            if (yAxis !\u003d null) {\n                yAxis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the primary dataset for the plot.\n     *\n     * @return The primary dataset (possibly {@code null}).\n     *\n     * @see #setDataset(CategoryDataset)\n     */\n    public CategoryDataset\u003cR, C\u003e getDataset() {\n        return getDataset(0);\n    }\n\n    /**\n     * Returns the dataset with the given index, or {@code null} if there is\n     * no dataset.\n     *\n     * @param index  the dataset index (must be \u0026gt;\u003d 0).\n     *\n     * @return The dataset (possibly {@code null}).\n     *\n     * @see #setDataset(int, CategoryDataset)\n     */\n    public CategoryDataset\u003cR, C\u003e getDataset(int index) {\n        return this.datasets.get(index);\n    }\n\n    /**\n     * Returns a map containing the datasets that are assigned to this plot.\n     * The map is unmodifiable.\n     * \n     * @return A map containing the datasets that are assigned to the plot \n     *     (never {@code null}).\n     * \n     * @since 1.5.4\n     */\n    public Map\u003cInteger, CategoryDataset\u003e getDatasets() {\n        return Collections.unmodifiableMap(this.datasets);\n    }\n\n    /**\n     * Sets the dataset for the plot, replacing the existing dataset, if there\n     * is one.  This method also calls the\n     * {@link #datasetChanged(DatasetChangeEvent)} method, which adjusts the\n     * axis ranges if necessary and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param dataset  the dataset ({@code null} permitted).\n     *\n     * @see #getDataset()\n     */\n    public void setDataset(CategoryDataset\u003cR, C\u003e dataset) {\n        setDataset(0, dataset);\n    }\n\n    /**\n     * Sets a dataset for the plot and sends a change notification to all\n     * registered listeners.\n     *\n     * @param index  the dataset index (must be \u0026gt;\u003d 0).\n     * @param dataset  the dataset ({@code null} permitted).\n     *\n     * @see #getDataset(int)\n     */\n    public void setDataset(int index, CategoryDataset\u003cR, C\u003e dataset) {\n        CategoryDataset\u003cR, C\u003e existing \u003d this.datasets.get(index);\n        if (existing !\u003d null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.put(index, dataset);\n        if (dataset !\u003d null) {\n            dataset.addChangeListener(this);\n        }\n        // send a dataset change event to self...\n        DatasetChangeEvent event \u003d new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n    }\n\n    /**\n     * Returns the number of datasets.\n     *\n     * @return The number of datasets.\n     */\n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    /**\n     * Returns the index of the specified dataset, or {@code -1} if the\n     * dataset does not belong to the plot.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The index.\n     */\n    public int indexOf(CategoryDataset\u003cR, C\u003e dataset) {\n        for (Entry\u003cInteger, CategoryDataset\u003cR, C\u003e\u003e entry: this.datasets.entrySet()) {\n            if (entry.getValue() \u003d\u003d dataset) {\n                return entry.getKey();\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Maps a dataset to a particular domain axis.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index (zero-based).\n     *\n     * @see #getDomainAxisForDataset(int)\n     */\n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        List\u003cInteger\u003e axisIndices \u003d new ArrayList\u003c\u003e(1);\n        axisIndices.add(axisIndex);\n        mapDatasetToDomainAxes(index, axisIndices);\n    }\n\n    /**\n     * Maps the specified dataset to the axes in the list.  Note that the\n     * conversion of data values into Java2D space is always performed using\n     * the first axis in the list.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndices  the axis indices ({@code null} permitted).\n     */\n    public void mapDatasetToDomainAxes(int index, List\u003cInteger\u003e axisIndices) {\n        Args.requireNonNegative(index, \"index\");\n        checkAxisIndices(axisIndices);\n        this.datasetToDomainAxesMap.put(index, new ArrayList\u003c\u003e(axisIndices));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    /**\n     * This method is used to perform argument checking on the list of\n     * axis indices passed to mapDatasetToDomainAxes() and\n     * mapDatasetToRangeAxes().\n     *\n     * @param indices  the list of indices ({@code null} permitted).\n     */\n    private void checkAxisIndices(List\u003cInteger\u003e indices) {\n        // axisIndices can be:\n        // 1.  null;\n        // 2.  non-empty, containing only Integer objects that are unique.\n        if (indices \u003d\u003d null) {\n            return;  // OK\n        }\n        int count \u003d indices.size();\n        if (count \u003d\u003d 0) {\n            throw new IllegalArgumentException(\"Empty list not permitted.\");\n        }\n        HashSet\u003cInteger\u003e set \u003d new HashSet\u003c\u003e();\n        for (int i \u003d 0; i \u003c count; i++) {\n            Integer item \u003d indices.get(i);\n            if (set.contains(item)) {\n                throw new IllegalArgumentException(\"Indices must be unique.\");\n            }\n            set.add(item);\n        }\n    }\n\n    /**\n     * Returns the domain axis for a dataset.  You can change the axis for a\n     * dataset using the {@link #mapDatasetToDomainAxis(int, int)} method.\n     *\n     * @param index  the dataset index (must be \u0026gt;\u003d 0).\n     *\n     * @return The domain axis.\n     *\n     * @see #mapDatasetToDomainAxis(int, int)\n     */\n    public CategoryAxis getDomainAxisForDataset(int index) {\n        Args.requireNonNegative(index, \"index\");\n        CategoryAxis axis;\n        List\u003cInteger\u003e axisIndices \u003d this.datasetToDomainAxesMap.get(index);\n        if (axisIndices !\u003d null) {\n            // the first axis in the list is used for data \u003c--\u003e Java2D\n            Integer axisIndex \u003d axisIndices.get(0);\n            axis \u003d getDomainAxis(axisIndex);\n        } else {\n            axis \u003d getDomainAxis(0);\n        }\n        return axis;\n    }\n\n    /**\n     * Maps a dataset to a particular range axis.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index (zero-based).\n     *\n     * @see #getRangeAxisForDataset(int)\n     */\n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        List\u003cInteger\u003e axisIndices \u003d new ArrayList\u003c\u003e(1);\n        axisIndices.add(axisIndex);\n        mapDatasetToRangeAxes(index, axisIndices);\n    }\n\n    /**\n     * Maps the specified dataset to the axes in the list.  Note that the\n     * conversion of data values into Java2D space is always performed using\n     * the first axis in the list.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndices  the axis indices ({@code null} permitted).\n     */\n    public void mapDatasetToRangeAxes(int index, List\u003cInteger\u003e axisIndices) {\n        Args.requireNonNegative(index, \"index\");\n        checkAxisIndices(axisIndices);\n        this.datasetToRangeAxesMap.put(index, new ArrayList\u003c\u003e(axisIndices));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    /**\n     * Returns the range axis for a dataset.  You can change the axis for a\n     * dataset using the {@link #mapDatasetToRangeAxis(int, int)} method.\n     *\n     * @param index  the dataset index (must be \u0026gt;\u003d 0).\n     *\n     * @return The range axis.\n     *\n     * @see #mapDatasetToRangeAxis(int, int)\n     */\n    public ValueAxis getRangeAxisForDataset(int index) {\n        Args.requireNonNegative(index, \"index\");\n        ValueAxis axis;\n        List\u003cInteger\u003e axisIndices \u003d this.datasetToRangeAxesMap.get(index);\n        if (axisIndices !\u003d null) {\n            // the first axis in the list is used for data \u003c--\u003e Java2D\n            axis \u003d getRangeAxis(axisIndices.get(0));\n        } else {\n            axis \u003d getRangeAxis(0);\n        }\n        return axis;\n    }\n\n    /**\n     * Returns the number of renderer slots for this plot.\n     *\n     * @return The number of renderer slots.\n     */\n    public int getRendererCount() {\n        return this.renderers.size();\n    }\n\n    /**\n     * Returns a reference to the renderer for the plot.\n     *\n     * @return The renderer.\n     *\n     * @see #setRenderer(CategoryItemRenderer)\n     */\n    public CategoryItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    /**\n     * Returns the renderer at the given index.\n     *\n     * @param index  the renderer index.\n     *\n     * @return The renderer (possibly {@code null}).\n     *\n     * @see #setRenderer(int, CategoryItemRenderer)\n     */\n    public CategoryItemRenderer getRenderer(int index) {\n        CategoryItemRenderer renderer \u003d this.renderers.get(index);\n        if (renderer \u003d\u003d null) {\n            return this.renderers.get(0);\n        }\n        return renderer;\n    }\n\n    /**\n     * Returns a map containing the renderers that are assigned to this plot.\n     * The map is unmodifiable.\n     * \n     * @return A map containing the renderers that are assigned to the plot \n     *     (never {@code null}).\n     * \n     * @since 1.5.4\n     */\n    public Map\u003cInteger, CategoryItemRenderer\u003e getRenderers() {\n        return Collections.unmodifiableMap(this.renderers);\n    }\n\n    /**\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\"\n     * renderer) and sends a change event to all registered listeners.\n     *\n     * @param renderer  the renderer ({@code null} permitted.\n     *\n     * @see #getRenderer()\n     */\n    public void setRenderer(CategoryItemRenderer renderer) {\n        setRenderer(0, renderer, true);\n    }\n\n    /**\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\"\n     * renderer) and, if requested, sends a change event to all registered \n     * listeners.\n     * \u003cp\u003e\n     * You can set the renderer to {@code null}, but this is not\n     * recommended because:\n     * \u003cul\u003e\n     *   \u003cli\u003eno data will be displayed;\u003c/li\u003e\n     *   \u003cli\u003ethe plot background will not be painted;\u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * @param renderer  the renderer ({@code null} permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getRenderer()\n     */\n    public void setRenderer(CategoryItemRenderer renderer, boolean notify) {\n        setRenderer(0, renderer, notify);\n    }\n\n    /**\n     * Sets the renderer to use for the dataset with the specified index and\n     * sends a change event to all registered listeners.  Note that each\n     * dataset should have its own renderer, you should not use one renderer\n     * for multiple datasets.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer ({@code null} permitted).\n     *\n     * @see #getRenderer(int)\n     * @see #setRenderer(int, CategoryItemRenderer, boolean)\n     */\n    public void setRenderer(int index, CategoryItemRenderer renderer) {\n        setRenderer(index, renderer, true);\n    }\n\n    /**\n     * Sets the renderer to use for the dataset with the specified index and,\n     * if requested, sends a change event to all registered listeners.  Note \n     * that each dataset should have its own renderer, you should not use one \n     * renderer for multiple datasets.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer ({@code null} permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, CategoryItemRenderer renderer,\n            boolean notify) {\n        CategoryItemRenderer existing \u003d this.renderers.get(index);\n        if (existing !\u003d null) {\n            existing.removeChangeListener(this);\n        }\n        this.renderers.put(index, renderer);\n        if (renderer !\u003d null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        configureDomainAxes();\n        configureRangeAxes();\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the renderers for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param renderers  the renderers.\n     */\n    public void setRenderers(CategoryItemRenderer[] renderers) {\n        for (int i \u003d 0; i \u003c renderers.length; i++) {\n            setRenderer(i, renderers[i], false);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the renderer for the specified dataset.  If the dataset doesn\u0027t\n     * belong to the plot, this method will return {@code null}.\n     *\n     * @param dataset  the dataset ({@code null} permitted).\n     *\n     * @return The renderer (possibly {@code null}).\n     */\n    public CategoryItemRenderer getRendererForDataset(CategoryDataset\u003cR, C\u003e dataset) {\n        int datasetIndex \u003d indexOf(dataset);\n        if (datasetIndex \u003c 0) {\n            return null;\n        } \n        CategoryItemRenderer renderer \u003d this.renderers.get(datasetIndex);\n        if (renderer \u003d\u003d null) {\n            return getRenderer();\n        }\n        return renderer;\n    }\n\n    /**\n     * Returns the index of the specified renderer, or {@code -1} if the\n     * renderer is not assigned to this plot.\n     *\n     * @param renderer  the renderer ({@code null} permitted).\n     *\n     * @return The renderer index.\n     */\n    public int getIndexOf(CategoryItemRenderer renderer) {\n        for (Entry\u003cInteger, CategoryItemRenderer\u003e entry \n                : this.renderers.entrySet()) {\n            if (entry.getValue() \u003d\u003d renderer) {\n                return entry.getKey();\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the dataset rendering order.\n     *\n     * @return The order (never {@code null}).\n     *\n     * @see #setDatasetRenderingOrder(DatasetRenderingOrder)\n     */\n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.renderingOrder;\n    }\n\n    /**\n     * Sets the rendering order and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  By default, the plot renders the primary dataset\n     * last (so that the primary dataset overlays the secondary datasets).  You\n     * can reverse this if you want to.\n     *\n     * @param order  the rendering order ({@code null} not permitted).\n     *\n     * @see #getDatasetRenderingOrder()\n     */\n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        Args.nullNotPermitted(order, \"order\");\n        this.renderingOrder \u003d order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the order in which the columns are rendered.  The default value\n     * is {@code SortOrder.ASCENDING}.\n     *\n     * @return The column rendering order (never {@code null}).\n     *\n     * @see #setColumnRenderingOrder(SortOrder)\n     */\n    public SortOrder getColumnRenderingOrder() {\n        return this.columnRenderingOrder;\n    }\n\n    /**\n     * Sets the column order in which the items in each dataset should be\n     * rendered and sends a {@link PlotChangeEvent} to all registered\n     * listeners.  Note that this affects the order in which items are drawn,\n     * NOT their position in the chart.\n     *\n     * @param order  the order ({@code null} not permitted).\n     *\n     * @see #getColumnRenderingOrder()\n     * @see #setRowRenderingOrder(SortOrder)\n     */\n    public void setColumnRenderingOrder(SortOrder order) {\n        Args.nullNotPermitted(order, \"order\");\n        this.columnRenderingOrder \u003d order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the order in which the rows should be rendered.  The default\n     * value is {@code SortOrder.ASCENDING}.\n     *\n     * @return The order (never {@code null}).\n     *\n     * @see #setRowRenderingOrder(SortOrder)\n     */\n    public SortOrder getRowRenderingOrder() {\n        return this.rowRenderingOrder;\n    }\n\n    /**\n     * Sets the row order in which the items in each dataset should be\n     * rendered and sends a {@link PlotChangeEvent} to all registered\n     * listeners.  Note that this affects the order in which items are drawn,\n     * NOT their position in the chart.\n     *\n     * @param order  the order ({@code null} not permitted).\n     *\n     * @see #getRowRenderingOrder()\n     * @see #setColumnRenderingOrder(SortOrder)\n     */\n    public void setRowRenderingOrder(SortOrder order) {\n        Args.nullNotPermitted(order, \"order\");\n        this.rowRenderingOrder \u003d order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the flag that controls whether the domain grid-lines are visible.\n     *\n     * @return The {@code true} or {@code false}.\n     *\n     * @see #setDomainGridlinesVisible(boolean)\n     */\n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not grid-lines are drawn against\n     * the domain axis.\n     * \u003cp\u003e\n     * If the flag value changes, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     *\n     * @see #isDomainGridlinesVisible()\n     */\n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible !\u003d visible) {\n            this.domainGridlinesVisible \u003d visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the position used for the domain gridlines.\n     *\n     * @return The gridline position (never {@code null}).\n     *\n     * @see #setDomainGridlinePosition(CategoryAnchor)\n     */\n    public CategoryAnchor getDomainGridlinePosition() {\n        return this.domainGridlinePosition;\n    }\n\n    /**\n     * Sets the position used for the domain gridlines and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param position  the position ({@code null} not permitted).\n     *\n     * @see #getDomainGridlinePosition()\n     */\n    public void setDomainGridlinePosition(CategoryAnchor position) {\n        Args.nullNotPermitted(position, \"position\");\n        this.domainGridlinePosition \u003d position;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used to draw grid-lines against the domain axis.\n     *\n     * @return The stroke (never {@code null}).\n     *\n     * @see #setDomainGridlineStroke(Stroke)\n     */\n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw grid-lines against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getDomainGridlineStroke()\n     */\n    public void setDomainGridlineStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.domainGridlineStroke \u003d stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw grid-lines against the domain axis.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setDomainGridlinePaint(Paint)\n     */\n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the grid-lines (if any) against the domain\n     * axis and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getDomainGridlinePaint()\n     */\n    public void setDomainGridlinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.domainGridlinePaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag that controls whether or not a zero baseline is\n     * displayed for the range axis.\n     *\n     * @return A boolean.\n     *\n     * @see #setRangeZeroBaselineVisible(boolean)\n     */\n    public boolean isRangeZeroBaselineVisible() {\n        return this.rangeZeroBaselineVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the zero baseline is\n     * displayed for the range axis, and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param visible  the flag.\n     *\n     * @see #isRangeZeroBaselineVisible()\n     */\n    public void setRangeZeroBaselineVisible(boolean visible) {\n        this.rangeZeroBaselineVisible \u003d visible;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used for the zero baseline against the range axis.\n     *\n     * @return The stroke (never {@code null}).\n     *\n     * @see #setRangeZeroBaselineStroke(Stroke)\n     */\n    public Stroke getRangeZeroBaselineStroke() {\n        return this.rangeZeroBaselineStroke;\n    }\n\n    /**\n     * Sets the stroke for the zero baseline for the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getRangeZeroBaselineStroke()\n     */\n    public void setRangeZeroBaselineStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.rangeZeroBaselineStroke \u003d stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the zero baseline (if any) plotted against the\n     * range axis.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setRangeZeroBaselinePaint(Paint)\n     */\n    public Paint getRangeZeroBaselinePaint() {\n        return this.rangeZeroBaselinePaint;\n    }\n\n    /**\n     * Sets the paint for the zero baseline plotted against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getRangeZeroBaselinePaint()\n     */\n    public void setRangeZeroBaselinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.rangeZeroBaselinePaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the flag that controls whether the range grid-lines are visible.\n     *\n     * @return The flag.\n     *\n     * @see #setRangeGridlinesVisible(boolean)\n     */\n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not grid-lines are drawn against\n     * the range axis.  If the flag changes value, a {@link PlotChangeEvent} is\n     * sent to all registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     *\n     * @see #isRangeGridlinesVisible()\n     */\n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible !\u003d visible) {\n            this.rangeGridlinesVisible \u003d visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke used to draw the grid-lines against the range axis.\n     *\n     * @return The stroke (never {@code null}).\n     *\n     * @see #setRangeGridlineStroke(Stroke)\n     */\n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the grid-lines against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getRangeGridlineStroke()\n     */\n    public void setRangeGridlineStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.rangeGridlineStroke \u003d stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw the grid-lines against the range axis.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setRangeGridlinePaint(Paint)\n     */\n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the grid lines against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getRangeGridlinePaint()\n     */\n    public void setRangeGridlinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.rangeGridlinePaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns {@code true} if the range axis minor grid is visible, and\n     * {@code false} otherwise.\n     *\n     * @return A boolean.\n     *\n     * @see #setRangeMinorGridlinesVisible(boolean)\n     */\n    public boolean isRangeMinorGridlinesVisible() {\n        return this.rangeMinorGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the range axis minor grid\n     * lines are visible.\n     * \u003cp\u003e\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     *\n     * @see #isRangeMinorGridlinesVisible()\n     */\n    public void setRangeMinorGridlinesVisible(boolean visible) {\n        if (this.rangeMinorGridlinesVisible !\u003d visible) {\n            this.rangeMinorGridlinesVisible \u003d visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the minor grid lines (if any) plotted against the\n     * range axis.\n     *\n     * @return The stroke (never {@code null}).\n     *\n     * @see #setRangeMinorGridlineStroke(Stroke)\n     */\n    public Stroke getRangeMinorGridlineStroke() {\n        return this.rangeMinorGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the minor grid lines plotted against the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getRangeMinorGridlineStroke()\n     */\n    public void setRangeMinorGridlineStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.rangeMinorGridlineStroke \u003d stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the minor grid lines (if any) plotted against the\n     * range axis.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setRangeMinorGridlinePaint(Paint)\n     */\n    public Paint getRangeMinorGridlinePaint() {\n        return this.rangeMinorGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the minor grid lines plotted against the range axis\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getRangeMinorGridlinePaint()\n     */\n    public void setRangeMinorGridlinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.rangeMinorGridlinePaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the fixed legend items, if any.\n     *\n     * @return The legend items (possibly {@code null}).\n     *\n     * @see #setFixedLegendItems(LegendItemCollection)\n     */\n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;\n    }\n\n    /**\n     * Sets the fixed legend items for the plot.  Leave this set to\n     * {@code null} if you prefer the legend items to be created\n     * automatically.\n     *\n     * @param items  the legend items ({@code null} permitted).\n     *\n     * @see #getFixedLegendItems()\n     */\n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems \u003d items;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend items for the plot.  By default, this method creates\n     * a legend item for each series in each of the datasets.  You can change\n     * this behaviour by overriding this method.\n     *\n     * @return The legend items.\n     */\n    @Override\n    public LegendItemCollection getLegendItems() {\n        if (this.fixedLegendItems !\u003d null) {\n            return this.fixedLegendItems;\n        }\n        LegendItemCollection result \u003d new LegendItemCollection();\n        // get the legend items for the datasets...\n        for (CategoryDataset\u003cR, C\u003e dataset: this.datasets.values()) {\n            if (dataset !\u003d null) {\n                int datasetIndex \u003d indexOf(dataset);\n                CategoryItemRenderer renderer \u003d getRenderer(datasetIndex);\n                if (renderer !\u003d null) {\n                    result.addAll(renderer.getLegendItems());\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Handles a \u0027click\u0027 on the plot by updating the anchor value.\n     *\n     * @param x  x-coordinate of the click (in Java2D space).\n     * @param y  y-coordinate of the click (in Java2D space).\n     * @param info  information about the plot\u0027s dimensions.\n     *\n     */\n    @Override\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea \u003d info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            // set the anchor value for the range axis...\n            double java2D \u003d 0.0;\n            if (this.orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n                java2D \u003d x;\n            } else if (this.orientation \u003d\u003d PlotOrientation.VERTICAL) {\n                java2D \u003d y;\n            }\n            RectangleEdge edge \u003d Plot.resolveRangeAxisLocation(\n                    getRangeAxisLocation(), this.orientation);\n            double value \u003d getRangeAxis().java2DToValue(\n                    java2D, info.getDataArea(), edge);\n            setAnchorValue(value);\n            setRangeCrosshairValue(value);\n        }\n\n    }\n\n    /**\n     * Zooms (in or out) on the plot\u0027s value axis.\n     * \u003cp\u003e\n     * If the value 0.0 is passed in as the zoom percent, the auto-range\n     * calculation for the axis is restored (which sets the range to include\n     * the minimum and maximum data values, thus displaying all the data).\n     *\n     * @param percent  the zoom amount.\n     */\n    @Override\n    public void zoom(double percent) {\n        if (percent \u003e 0.0) {\n            double range \u003d getRangeAxis().getRange().getLength();\n            double scaledRange \u003d range * percent;\n            getRangeAxis().setRange(this.anchorValue - scaledRange / 2.0,\n                    this.anchorValue + scaledRange / 2.0);\n        }\n        else {\n            getRangeAxis().setAutoRange(true);\n        }\n    }\n\n    /**\n     * Receives notification of a change to an {@link Annotation} added to\n     * this plot.\n     *\n     * @param event  information about the event (not used here).\n     */\n    @Override\n    public void annotationChanged(AnnotationChangeEvent event) {\n        if (getParent() !\u003d null) {\n            getParent().annotationChanged(event);\n        } else {\n            PlotChangeEvent e \u003d new PlotChangeEvent(this);\n            notifyListeners(e);\n        }\n    }\n\n    /**\n     * Receives notification of a change to the plot\u0027s dataset.\n     * \u003cP\u003e\n     * The range axis bounds will be recalculated if necessary.\n     *\n     * @param event  information about the event (not used here).\n     */\n    @Override\n    public void datasetChanged(DatasetChangeEvent event) {\n        for (ValueAxis yAxis : this.rangeAxes.values()) {\n            if (yAxis !\u003d null) {\n                yAxis.configure();\n            }\n        }\n        if (getParent() !\u003d null) {\n            getParent().datasetChanged(event);\n        } else {\n            PlotChangeEvent e \u003d new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n\n    }\n\n    /**\n     * Receives notification of a renderer change event.\n     *\n     * @param event  the event.\n     */\n    @Override\n    public void rendererChanged(RendererChangeEvent event) {\n        Plot parent \u003d getParent();\n        if (parent !\u003d null) {\n            if (parent instanceof RendererChangeListener) {\n                RendererChangeListener rcl \u003d (RendererChangeListener) parent;\n                rcl.rendererChanged(event);\n            } else {\n                // this should never happen with the existing code, but throw\n                // an exception in case future changes make it possible...\n                throw new RuntimeException(\n                    \"The renderer has changed and I don\u0027t know what to do!\");\n            }\n        } else {\n            configureRangeAxes();\n            PlotChangeEvent e \u003d new PlotChangeEvent(this);\n            notifyListeners(e);\n        }\n    }\n\n    /**\n     * Adds a marker for display (in the foreground) against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a\n     * marker will be drawn by the renderer as a line perpendicular to the\n     * domain axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker ({@code null} not permitted).\n     *\n     * @see #removeDomainMarker(CategoryMarker)\n     */\n    public void addDomainMarker(CategoryMarker marker) {\n        addDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds a marker for display against the domain axis and sends a\n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker\n     * will be drawn by the renderer as a line perpendicular to the domain\n     * axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker ({@code null} not permitted).\n     * @param layer  the layer (foreground or background) ({@code null}\n     *               not permitted).\n     *\n     * @see #removeDomainMarker(CategoryMarker, Layer)\n     */\n    public void addDomainMarker(CategoryMarker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \u003cP\u003e\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a domain axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker ({@code null} not permitted).\n     * @param layer  the layer ({@code null} not permitted).\n     *\n     * @see #removeDomainMarker(int, CategoryMarker, Layer)\n     */\n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer) {\n        addDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and, if requested,\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     * \u003cP\u003e\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a domain axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker ({@code null} not permitted).\n     * @param layer  the layer ({@code null} not permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #removeDomainMarker(int, CategoryMarker, Layer, boolean)\n     */\n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer,\n            boolean notify) {\n        Args.nullNotPermitted(marker, \"marker\");\n        Args.nullNotPermitted(layer, \"layer\");\n        Collection\u003cCategoryMarker\u003e markers;\n        if (layer \u003d\u003d Layer.FOREGROUND) {\n            markers \u003d this.foregroundDomainMarkers.get(index);\n            if (markers \u003d\u003d null) {\n                markers \u003d new ArrayList\u003c\u003e();\n                this.foregroundDomainMarkers.put(index, markers);\n            }\n            markers.add(marker);\n        } else if (layer \u003d\u003d Layer.BACKGROUND) {\n            markers \u003d this.backgroundDomainMarkers.get(index);\n            if (markers \u003d\u003d null) {\n                markers \u003d new ArrayList\u003c\u003e();\n                this.backgroundDomainMarkers.put(index, markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears all the domain markers for the plot and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @see #clearRangeMarkers()\n     */\n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers !\u003d null) {\n            Set\u003cInteger\u003e keys \u003d this.backgroundDomainMarkers.keySet();\n            for (Integer key : keys) {\n                clearDomainMarkers(key);\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers !\u003d null) {\n            Set\u003cInteger\u003e keys \u003d this.foregroundDomainMarkers.keySet();\n            for (Integer key : keys) {\n                clearDomainMarkers(key);\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the list of domain markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     *\n     * @return The list of domain markers.\n     */\n    public Collection\u003cCategoryMarker\u003e getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of domain markers for a particular renderer and\n     * layer.\n     *\n     * @param index  the renderer index.\n     * @param layer  the layer.\n     *\n     * @return A collection of markers (possibly {@code null}).\n     */\n    public Collection\u003cCategoryMarker\u003e getDomainMarkers(int index, Layer layer) {\n        Collection\u003cCategoryMarker\u003e result \u003d null;\n        Integer key \u003d index;\n        if (layer \u003d\u003d Layer.FOREGROUND) {\n            result \u003d this.foregroundDomainMarkers.get(key);\n        }\n        else if (layer \u003d\u003d Layer.BACKGROUND) {\n            result \u003d this.backgroundDomainMarkers.get(key);\n        }\n        if (result !\u003d null) {\n            result \u003d Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    /**\n     * Clears all the domain markers for the specified renderer.\n     *\n     * @param index  the renderer index.\n     *\n     * @see #clearRangeMarkers(int)\n     */\n    public void clearDomainMarkers(int index) {\n        Integer key \u003d index;\n        if (this.backgroundDomainMarkers !\u003d null) {\n            Collection\u003cCategoryMarker\u003e markers\n                \u003d this.backgroundDomainMarkers.get(key);\n            if (markers !\u003d null) {\n                for (CategoryMarker m : markers) {\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundDomainMarkers !\u003d null) {\n            Collection\u003cCategoryMarker\u003e markers\n                \u003d this.foregroundDomainMarkers.get(key);\n            if (markers !\u003d null) {\n                for (Marker m : markers) {\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Removes a marker for the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param marker  the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     */\n    public boolean removeDomainMarker(CategoryMarker marker) {\n        return removeDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker ({@code null} not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     */\n    public boolean removeDomainMarker(CategoryMarker marker, Layer layer) {\n        return removeDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     */\n    public boolean removeDomainMarker(int index, CategoryMarker marker, Layer layer) {\n        return removeDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and, if requested,\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     */\n    public boolean removeDomainMarker(int index, CategoryMarker marker, Layer layer,\n            boolean notify) {\n        Collection\u003cCategoryMarker\u003e markers;\n        if (layer \u003d\u003d Layer.FOREGROUND) {\n            markers \u003d this.foregroundDomainMarkers.get(index);\n        } else {\n            markers \u003d this.backgroundDomainMarkers.get(index);\n        }\n        if (markers \u003d\u003d null) {\n            return false;\n        }\n        boolean removed \u003d markers.remove(marker);\n        if (removed \u0026\u0026 notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Adds a marker for display (in the foreground) against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a\n     * marker will be drawn by the renderer as a line perpendicular to the\n     * range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker ({@code null} not permitted).\n     *\n     * @see #removeRangeMarker(Marker)\n     */\n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds a marker for display against the range axis and sends a\n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker\n     * will be drawn by the renderer as a line perpendicular to the range axis,\n     * however this is entirely up to the renderer.\n     *\n     * @param marker  the marker ({@code null} not permitted).\n     * @param layer  the layer (foreground or background) ({@code null}\n     *               not permitted).\n     *\n     * @see #removeRangeMarker(Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \u003cP\u003e\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer.\n     *\n     * @see #removeRangeMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n        addRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \u003cP\u003e\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer.\n     * @param notify  notify listeners?\n     *\n     * @see #removeRangeMarker(int, Marker, Layer, boolean)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        Collection\u003cMarker\u003e markers;\n        if (layer \u003d\u003d Layer.FOREGROUND) {\n            markers \u003d this.foregroundRangeMarkers.get(index);\n            if (markers \u003d\u003d null) {\n                markers \u003d new ArrayList\u003c\u003e();\n                this.foregroundRangeMarkers.put(index, markers);\n            }\n            markers.add(marker);\n        } else if (layer \u003d\u003d Layer.BACKGROUND) {\n            markers \u003d this.backgroundRangeMarkers.get(index);\n            if (markers \u003d\u003d null) {\n                markers \u003d new ArrayList\u003c\u003e();\n                this.backgroundRangeMarkers.put(index, markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears all the range markers for the plot and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @see #clearDomainMarkers()\n     */\n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers !\u003d null) {\n            Set\u003cInteger\u003e keys \u003d this.backgroundRangeMarkers.keySet();\n            for (Integer key : keys) {\n                clearRangeMarkers(key);\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers !\u003d null) {\n            Set\u003cInteger\u003e keys \u003d this.foregroundRangeMarkers.keySet();\n            for (Integer key : keys) {\n                clearRangeMarkers(key);\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the list of range markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     *\n     * @return The list of range markers.\n     *\n     * @see #getRangeMarkers(int, Layer)\n     */\n    public Collection\u003cMarker\u003e getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of range markers for a particular renderer and\n     * layer.\n     *\n     * @param index  the renderer index.\n     * @param layer  the layer.\n     *\n     * @return A collection of markers (possibly {@code null}).\n     */\n    public Collection\u003cMarker\u003e getRangeMarkers(int index, Layer layer) {\n        Collection\u003cMarker\u003e result \u003d null;\n        if (layer \u003d\u003d Layer.FOREGROUND) {\n            result \u003d this.foregroundRangeMarkers.get(index);\n        }\n        else if (layer \u003d\u003d Layer.BACKGROUND) {\n            result \u003d this.backgroundRangeMarkers.get(index);\n        }\n        if (result !\u003d null) {\n            result \u003d Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    /**\n     * Clears all the range markers for the specified renderer.\n     *\n     * @param index  the renderer index.\n     *\n     * @see #clearDomainMarkers(int)\n     */\n    public void clearRangeMarkers(int index) {\n        Integer key \u003d index;\n        if (this.backgroundRangeMarkers !\u003d null) {\n            Collection\u003cMarker\u003e markers\n                \u003d this.backgroundRangeMarkers.get(key);\n            if (markers !\u003d null) {\n                for (Marker m : markers) {\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers !\u003d null) {\n            Collection\u003cMarker\u003e markers\n                \u003d this.foregroundRangeMarkers.get(key);\n            if (markers !\u003d null) {\n                for (Marker m : markers) {\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Removes a marker for the range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param marker the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @see #addRangeMarker(Marker)\n     */\n    public boolean removeRangeMarker(Marker marker) {\n        return removeRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker ({@code null} not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @see #addRangeMarker(Marker, Layer)\n     */\n    public boolean removeRangeMarker(Marker marker, Layer layer) {\n        return removeRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n        return removeRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners.\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     *\n     * @see #addRangeMarker(int, Marker, Layer, boolean)\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        Args.nullNotPermitted(marker, \"marker\");\n        Collection\u003cMarker\u003e markers;\n        if (layer \u003d\u003d Layer.FOREGROUND) {\n            markers \u003d this.foregroundRangeMarkers.get(index);\n        } else {\n            markers \u003d this.backgroundRangeMarkers.get(index);\n        }\n        if (markers \u003d\u003d null) {\n            return false;\n        }\n        boolean removed \u003d markers.remove(marker);\n        if (removed \u0026\u0026 notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Returns the flag that controls whether or not the domain crosshair is\n     * displayed by the plot.\n     *\n     * @return A boolean.\n     *\n     * @see #setDomainCrosshairVisible(boolean)\n     */\n    public boolean isDomainCrosshairVisible() {\n        return this.domainCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the domain crosshair is\n     * displayed by the plot, and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param flag  the new flag value.\n     *\n     * @see #isDomainCrosshairVisible()\n     * @see #setRangeCrosshairVisible(boolean)\n     */\n    public void setDomainCrosshairVisible(boolean flag) {\n        if (this.domainCrosshairVisible !\u003d flag) {\n            this.domainCrosshairVisible \u003d flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the row key for the domain crosshair.\n     *\n     * @return The row key.\n     */\n    public R getDomainCrosshairRowKey() {\n        return this.domainCrosshairRowKey;\n    }\n\n    /**\n     * Sets the row key for the domain crosshair and sends a\n     * {PlotChangeEvent} to all registered listeners.\n     *\n     * @param key  the key.\n     */\n    public void setDomainCrosshairRowKey(R key) {\n        setDomainCrosshairRowKey(key, true);\n    }\n\n    /**\n     * Sets the row key for the domain crosshair and, if requested, sends a\n     * {PlotChangeEvent} to all registered listeners.\n     *\n     * @param key  the key.\n     * @param notify  notify listeners?\n     */\n    public void setDomainCrosshairRowKey(R key, boolean notify) {\n        this.domainCrosshairRowKey \u003d key;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the column key for the domain crosshair.\n     *\n     * @return The column key.\n     */\n    public C getDomainCrosshairColumnKey() {\n        return this.domainCrosshairColumnKey;\n    }\n\n    /**\n     * Sets the column key for the domain crosshair and sends\n     * a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param key  the key.\n     */\n    public void setDomainCrosshairColumnKey(C key) {\n        setDomainCrosshairColumnKey(key, true);\n    }\n\n    /**\n     * Sets the column key for the domain crosshair and, if requested, sends\n     * a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param key  the key.\n     * @param notify  notify listeners?\n     */\n    public void setDomainCrosshairColumnKey(C key, boolean notify) {\n        this.domainCrosshairColumnKey \u003d key;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the dataset index for the crosshair.\n     *\n     * @return The dataset index.\n     */\n    public int getCrosshairDatasetIndex() {\n        return this.crosshairDatasetIndex;\n    }\n\n    /**\n     * Sets the dataset index for the crosshair and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the index.\n     */\n    public void setCrosshairDatasetIndex(int index) {\n        setCrosshairDatasetIndex(index, true);\n    }\n\n    /**\n     * Sets the dataset index for the crosshair and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the index.\n     * @param notify  notify listeners?\n     */\n    public void setCrosshairDatasetIndex(int index, boolean notify) {\n        this.crosshairDatasetIndex \u003d index;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the paint used to draw the domain crosshair.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setDomainCrosshairPaint(Paint)\n     * @see #getDomainCrosshairStroke()\n     */\n    public Paint getDomainCrosshairPaint() {\n        return this.domainCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the domain crosshair.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getDomainCrosshairPaint()\n     */\n    public void setDomainCrosshairPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.domainCrosshairPaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used to draw the domain crosshair.\n     *\n     * @return The stroke (never {@code null}).\n     *\n     * @see #setDomainCrosshairStroke(Stroke)\n     * @see #getDomainCrosshairPaint()\n     */\n    public Stroke getDomainCrosshairStroke() {\n        return this.domainCrosshairStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the domain crosshair, and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getDomainCrosshairStroke()\n     */\n    public void setDomainCrosshairStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.domainCrosshairStroke \u003d stroke;\n    }\n\n    /**\n     * Returns a flag indicating whether or not the range crosshair is visible.\n     *\n     * @return The flag.\n     *\n     * @see #setRangeCrosshairVisible(boolean)\n     */\n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair is visible.\n     *\n     * @param flag  the new value of the flag.\n     *\n     * @see #isRangeCrosshairVisible()\n     */\n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible !\u003d flag) {\n            this.rangeCrosshairVisible \u003d flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     *\n     * @see #setRangeCrosshairLockedOnData(boolean)\n     */\n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair should\n     * \"lock-on\" to actual data values, and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param flag  the flag.\n     *\n     * @see #isRangeCrosshairLockedOnData()\n     */\n    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData !\u003d flag) {\n            this.rangeCrosshairLockedOnData \u003d flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the range crosshair value.\n     *\n     * @return The value.\n     *\n     * @see #setRangeCrosshairValue(double)\n     */\n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    /**\n     * Sets the range crosshair value and, if the crosshair is visible, sends\n     * a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param value  the new value.\n     *\n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the range crosshair value and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners (but only if the\n     * crosshair is visible).\n     *\n     * @param value  the new value.\n     * @param notify  a flag that controls whether or not listeners are\n     *                notified.\n     *\n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue \u003d value;\n        if (isRangeCrosshairVisible() \u0026\u0026 notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the pen-style ({@code Stroke}) used to draw the crosshair\n     * (if visible).\n     *\n     * @return The crosshair stroke (never {@code null}).\n     *\n     * @see #setRangeCrosshairStroke(Stroke)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairPaint()\n     */\n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    /**\n     * Sets the pen-style ({@code Stroke}) used to draw the range\n     * crosshair (if visible), and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param stroke  the new crosshair stroke ({@code null} not\n     *         permitted).\n     *\n     * @see #getRangeCrosshairStroke()\n     */\n    public void setRangeCrosshairStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.rangeCrosshairStroke \u003d stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw the range crosshair.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setRangeCrosshairPaint(Paint)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairStroke()\n     */\n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the range crosshair (if visible) and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getRangeCrosshairPaint()\n     */\n    public void setRangeCrosshairPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.rangeCrosshairPaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the list of annotations.\n     *\n     * @return The list of annotations (never {@code null}).\n     *\n     * @see #addAnnotation(CategoryAnnotation)\n     * @see #clearAnnotations()\n     */\n    public List\u003cCategoryAnnotation\u003e getAnnotations() {\n        return this.annotations;\n    }\n\n    /**\n     * Adds an annotation to the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param annotation  the annotation ({@code null} not permitted).\n     *\n     * @see #removeAnnotation(CategoryAnnotation)\n     */\n    public void addAnnotation(CategoryAnnotation annotation) {\n        addAnnotation(annotation, true);\n    }\n\n    /**\n     * Adds an annotation to the plot and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation ({@code null} not permitted).\n     * @param notify  notify listeners?\n     */\n    public void addAnnotation(CategoryAnnotation annotation, boolean notify) {\n        Args.nullNotPermitted(annotation, \"annotation\");\n        this.annotations.add(annotation);\n        annotation.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation ({@code null} not permitted).\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     *\n     * @see #addAnnotation(CategoryAnnotation)\n     */\n    public boolean removeAnnotation(CategoryAnnotation annotation) {\n        return removeAnnotation(annotation, true);\n    }\n\n    /**\n     * Removes an annotation from the plot and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation ({@code null} not permitted).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     */\n    public boolean removeAnnotation(CategoryAnnotation annotation,\n            boolean notify) {\n        Args.nullNotPermitted(annotation, \"annotation\");\n        boolean removed \u003d this.annotations.remove(annotation);\n        annotation.removeChangeListener(this);\n        if (removed \u0026\u0026 notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Clears all the annotations and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     */\n    public void clearAnnotations() {\n        for (int i \u003d 0; i \u003c this.annotations.size(); i++) {\n            CategoryAnnotation annotation \u003d this.annotations.get(i);\n            annotation.removeChangeListener(this);\n        }\n        this.annotations.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the shadow generator for the plot, if any.\n     *\n     * @return The shadow generator (possibly {@code null}).\n     */\n    public ShadowGenerator getShadowGenerator() {\n        return this.shadowGenerator;\n    }\n\n    /**\n     * Sets the shadow generator for the plot and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator ({@code null} permitted).\n     */\n    public void setShadowGenerator(ShadowGenerator generator) {\n        this.shadowGenerator \u003d generator;\n        fireChangeEvent();\n    }\n\n    /**\n     * Calculates the space required for the domain axis/axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result ({@code null} permitted).\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2,\n            Rectangle2D plotArea, AxisSpace space) {\n\n        if (space \u003d\u003d null) {\n            space \u003d new AxisSpace();\n        }\n\n        // reserve some space for the domain axis...\n        if (this.fixedDomainAxisSpace !\u003d null) {\n            if (this.orientation.isHorizontal()) {\n                space.ensureAtLeast(\n                    this.fixedDomainAxisSpace.getLeft(), RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(),\n                        RectangleEdge.RIGHT);\n            } else if (this.orientation.isVertical()) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(),\n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(),\n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            // reserve space for the primary domain axis...\n            RectangleEdge domainEdge \u003d Plot.resolveDomainAxisLocation(\n                    getDomainAxisLocation(), this.orientation);\n            if (this.drawSharedDomainAxis) {\n                space \u003d getDomainAxis().reserveSpace(g2, this, plotArea,\n                        domainEdge, space);\n            }\n\n            // reserve space for any domain axes...\n            for (CategoryAxis xAxis : this.domainAxes.values()) {\n                if (xAxis !\u003d null) {\n                    int i \u003d getDomainAxisIndex(xAxis);\n                    RectangleEdge edge \u003d getDomainAxisEdge(i);\n                    space \u003d xAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n\n    }\n\n    /**\n     * Calculates the space required for the range axis/axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result ({@code null} permitted).\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2,\n            Rectangle2D plotArea, AxisSpace space) {\n\n        if (space \u003d\u003d null) {\n            space \u003d new AxisSpace();\n        }\n\n        // reserve some space for the range axis...\n        if (this.fixedRangeAxisSpace !\u003d null) {\n            if (this.orientation.isHorizontal()) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(),\n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(),\n                        RectangleEdge.BOTTOM);\n            } else if (this.orientation \u003d\u003d PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(),\n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(),\n                        RectangleEdge.RIGHT);\n            }\n        } else {\n            // reserve space for the range axes (if any)...\n            for (ValueAxis yAxis : this.rangeAxes.values()) {\n                if (yAxis !\u003d null) {\n                    int i \u003d findRangeAxisIndex(yAxis);\n                    RectangleEdge edge \u003d getRangeAxisEdge(i);\n                    space \u003d yAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n\n    }\n\n    /**\n     * Trims a rectangle to integer coordinates.\n     *\n     * @param rect  the incoming rectangle.\n     *\n     * @return A rectangle with integer coordinates.\n     */\n    private Rectangle integerise(Rectangle2D rect) {\n        int x0 \u003d (int) Math.ceil(rect.getMinX());\n        int y0 \u003d (int) Math.ceil(rect.getMinY());\n        int x1 \u003d (int) Math.floor(rect.getMaxX());\n        int y1 \u003d (int) Math.floor(rect.getMaxY());\n        return new Rectangle(x0, y0, (x1 - x0), (y1 - y0));\n    }\n\n    /**\n     * Calculates the space required for the axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     *\n     * @return The space required for the axes.\n     */\n    protected AxisSpace calculateAxisSpace(Graphics2D g2, \n            Rectangle2D plotArea) {\n        AxisSpace space \u003d new AxisSpace();\n        space \u003d calculateRangeAxisSpace(g2, plotArea, space);\n        space \u003d calculateDomainAxisSpace(g2, plotArea, space);\n        return space;\n    }\n\n    /**\n     * Receives a chart element visitor.  Many plot subclasses will override\n     * this method to handle their subcomponents.\n     * \n     * @param visitor  the visitor ({@code null} not permitted).\n     */\n    @Override\n    public void receive(ChartElementVisitor visitor) {\n        // visit the domain axes\n        for (Entry\u003cInteger, CategoryAxis\u003e entry : this.domainAxes.entrySet()) {\n            if (entry.getValue() !\u003d null) {\n                entry.getValue().receive(visitor);\n            }\n        }\n        // visit the range axes\n        for (Entry\u003cInteger, ValueAxis\u003e entry : this.rangeAxes.entrySet()) {\n            if (entry.getValue() !\u003d null) {\n                entry.getValue().receive(visitor);\n            }\n        }\n        // visit the renderers\n        for (Entry\u003cInteger, CategoryItemRenderer\u003e entry : this.renderers.entrySet()) {\n            if (entry.getValue() !\u003d null) {\n                entry.getValue().receive(visitor);\n            }            \n        }\n        // and finally this plot\n        visitor.visit(this);\n    }\n\n    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a\n     * printer).\n     * \u003cP\u003e\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\n     * If you do, it will be populated with information about the drawing,\n     * including various plot dimensions and tooltip info.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot (including axes) should\n     *              be drawn.\n     * @param anchor  the anchor point ({@code null} permitted).\n     * @param parentState  the state from the parent plot, if there is one.\n     * @param state  collects info as the chart is drawn (possibly\n     *               {@code null}).\n     */\n    @Override\n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n            PlotState parentState, PlotRenderingInfo state) {\n\n        // if the plot area is too small, just return...\n        boolean b1 \u003d (area.getWidth() \u003c\u003d MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 \u003d (area.getHeight() \u003c\u003d MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        // record the plot area...\n        if (state \u003d\u003d null) {\n            // if the incoming state is null, no information will be passed\n            // back to the caller - but we create a temporary state to record\n            // the plot area, since that is used later by the axes\n            state \u003d new PlotRenderingInfo(null);\n        }\n        state.setPlotArea(area);\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets \u003d getInsets();\n        insets.trim(area);\n\n        // calculate the data area...\n        AxisSpace space \u003d calculateAxisSpace(g2, area);\n        Rectangle2D dataArea \u003d space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n        dataArea \u003d integerise(dataArea);\n        if (dataArea.isEmpty()) {\n            return;\n        }\n        state.setDataArea(dataArea);\n        createAndAddEntity((Rectangle2D) dataArea.clone(), state, null, null);\n\n        // if there is a renderer, it draws the background, otherwise use the\n        // default background...\n        if (getRenderer() !\u003d null) {\n            getRenderer().drawBackground(g2, this, dataArea);\n        } else {\n            drawBackground(g2, dataArea);\n        }\n\n        Map\u003cAxis, AxisState\u003e axisStateMap \u003d drawAxes(g2, area, dataArea, state);\n\n        // the anchor point is typically the point where the mouse last\n        // clicked - the crosshairs will be driven off this point...\n        if (anchor !\u003d null \u0026\u0026 !dataArea.contains(anchor)) {\n            anchor \u003d ShapeUtils.getPointInRectangle(anchor.getX(),\n                    anchor.getY(), dataArea);\n        }\n        CategoryCrosshairState\u003cR, C\u003e crosshairState \u003d new CategoryCrosshairState\u003c\u003e();\n        crosshairState.setCrosshairDistance(Double.POSITIVE_INFINITY);\n        crosshairState.setAnchor(anchor);\n\n        // specify the anchor X and Y coordinates in Java2D space, for the\n        // cases where these are not updated during rendering (i.e. no lock\n        // on data)\n        crosshairState.setAnchorX(Double.NaN);\n        crosshairState.setAnchorY(Double.NaN);\n        if (anchor !\u003d null) {\n            ValueAxis rangeAxis \u003d getRangeAxis();\n            if (rangeAxis !\u003d null) {\n                double y;\n                if (getOrientation() \u003d\u003d PlotOrientation.VERTICAL) {\n                    y \u003d rangeAxis.java2DToValue(anchor.getY(), dataArea,\n                            getRangeAxisEdge());\n                }\n                else {\n                    y \u003d rangeAxis.java2DToValue(anchor.getX(), dataArea,\n                            getRangeAxisEdge());\n                }\n                crosshairState.setAnchorY(y);\n            }\n        }\n        crosshairState.setRowKey(getDomainCrosshairRowKey());\n        crosshairState.setColumnKey(getDomainCrosshairColumnKey());\n        crosshairState.setCrosshairY(getRangeCrosshairValue());\n\n        // don\u0027t let anyone draw outside the data area\n        Shape savedClip \u003d g2.getClip();\n        g2.clip(dataArea);\n\n        drawDomainGridlines(g2, dataArea);\n\n        AxisState rangeAxisState \u003d axisStateMap.get(getRangeAxis());\n        if (rangeAxisState \u003d\u003d null) {\n            if (parentState !\u003d null) {\n                rangeAxisState \u003d parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (rangeAxisState !\u003d null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n            drawZeroRangeBaseline(g2, dataArea);\n        }\n\n        Graphics2D savedG2 \u003d g2;\n        BufferedImage dataImage \u003d null;\n        boolean suppressShadow \u003d Boolean.TRUE.equals(g2.getRenderingHint(\n                JFreeChart.KEY_SUPPRESS_SHADOW_GENERATION));\n        if (this.shadowGenerator !\u003d null \u0026\u0026 !suppressShadow) {\n            dataImage \u003d new BufferedImage((int) dataArea.getWidth(),\n                    (int)dataArea.getHeight(), BufferedImage.TYPE_INT_ARGB);\n            g2 \u003d dataImage.createGraphics();\n            g2.translate(-dataArea.getX(), -dataArea.getY());\n            g2.setRenderingHints(savedG2.getRenderingHints());\n        }\n\n        // draw the markers...\n        for (CategoryItemRenderer renderer : this.renderers.values()) {\n            int i \u003d getIndexOf(renderer);\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n        for (CategoryItemRenderer renderer : this.renderers.values()) {\n            int i \u003d getIndexOf(renderer);\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        // now render data items...\n        boolean foundData \u003d false;\n\n        // set up the alpha-transparency...\n        Composite originalComposite \u003d g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\n\n        DatasetRenderingOrder order \u003d getDatasetRenderingOrder();\n        List\u003cInteger\u003e datasetIndices \u003d getDatasetIndices(order);\n        for (int i : datasetIndices) {\n            foundData \u003d render(g2, dataArea, i, state, crosshairState)\n                    || foundData;\n        }\n\n        // draw the foreground markers...\n        List\u003cInteger\u003e rendererIndices \u003d getRendererIndices(order);\n        for (int i : rendererIndices) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i : rendererIndices) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        // draw the annotations (if any)...\n        drawAnnotations(g2, dataArea);\n\n        if (this.shadowGenerator !\u003d null \u0026\u0026 !suppressShadow) {\n            BufferedImage shadowImage \u003d this.shadowGenerator.createDropShadow(\n                    dataImage);\n            g2 \u003d savedG2;\n            g2.drawImage(shadowImage, (int) dataArea.getX()\n                    + this.shadowGenerator.calculateOffsetX(),\n                    (int) dataArea.getY()\n                    + this.shadowGenerator.calculateOffsetY(), null);\n            g2.drawImage(dataImage, (int) dataArea.getX(),\n                    (int) dataArea.getY(), null);\n        }\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        int datasetIndex \u003d crosshairState.getDatasetIndex();\n        setCrosshairDatasetIndex(datasetIndex, false);\n\n        // draw domain crosshair if required...\n        R rowKey \u003d crosshairState.getRowKey();\n        C columnKey \u003d crosshairState.getColumnKey();\n        setDomainCrosshairRowKey(rowKey, false);\n        setDomainCrosshairColumnKey(columnKey, false);\n        if (isDomainCrosshairVisible() \u0026\u0026 columnKey !\u003d null) {\n            Paint paint \u003d getDomainCrosshairPaint();\n            Stroke stroke \u003d getDomainCrosshairStroke();\n            drawDomainCrosshair(g2, dataArea, this.orientation,\n                    datasetIndex, rowKey, columnKey, stroke, paint);\n        }\n\n        // draw range crosshair if required...\n        ValueAxis yAxis \u003d getRangeAxisForDataset(datasetIndex);\n        RectangleEdge yAxisEdge \u003d getRangeAxisEdge();\n        if (!this.rangeCrosshairLockedOnData \u0026\u0026 anchor !\u003d null) {\n            double yy;\n            if (getOrientation() \u003d\u003d PlotOrientation.VERTICAL) {\n                yy \u003d yAxis.java2DToValue(anchor.getY(), dataArea, yAxisEdge);\n            }\n            else {\n                yy \u003d yAxis.java2DToValue(anchor.getX(), dataArea, yAxisEdge);\n            }\n            crosshairState.setCrosshairY(yy);\n        }\n        setRangeCrosshairValue(crosshairState.getCrosshairY(), false);\n        if (isRangeCrosshairVisible()) {\n            double y \u003d getRangeCrosshairValue();\n            Paint paint \u003d getRangeCrosshairPaint();\n            Stroke stroke \u003d getRangeCrosshairStroke();\n            drawRangeCrosshair(g2, dataArea, getOrientation(), y, yAxis,\n                    stroke, paint);\n        }\n\n        // draw an outline around the plot area...\n        if (isOutlineVisible()) {\n            if (getRenderer() !\u003d null) {\n                getRenderer().drawOutline(g2, this, dataArea);\n            }\n            else {\n                drawOutline(g2, dataArea);\n            }\n        }\n\n    }\n\n    /**\n     * Returns the indices of the non-null datasets in the specified order.\n     * \n     * @param order  the order ({@code null} not permitted).\n     * \n     * @return The list of indices. \n     */\n    private List\u003cInteger\u003e getDatasetIndices(DatasetRenderingOrder order) {\n        List\u003cInteger\u003e result \u003d new ArrayList\u003c\u003e();\n        for (Map.Entry\u003cInteger, CategoryDataset\u003cR, C\u003e\u003e entry : \n                this.datasets.entrySet()) {\n            if (entry.getValue() !\u003d null) {\n                result.add(entry.getKey());\n            }\n        }\n        Collections.sort(result);\n        if (order \u003d\u003d DatasetRenderingOrder.REVERSE) {\n            Collections.reverse(result);\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the indices of the non-null renderers for the plot, in the \n     * specified order.\n     * \n     * @param order  the rendering order {@code null} not permitted).\n     * \n     * @return A list of indices.\n     */\n    private List\u003cInteger\u003e getRendererIndices(DatasetRenderingOrder order) {\n        List\u003cInteger\u003e result \u003d new ArrayList\u003c\u003e();\n        for (Map.Entry\u003cInteger, CategoryItemRenderer\u003e entry: \n                this.renderers.entrySet()) {\n            if (entry.getValue() !\u003d null) {\n                result.add(entry.getKey());\n            }\n        }\n        Collections.sort(result);\n        if (order \u003d\u003d DatasetRenderingOrder.REVERSE) {\n            Collections.reverse(result);\n        }\n        return result;        \n    }\n    \n    /**\n     * Draws the plot background (the background color and/or image).\n     * \u003cP\u003e\n     * This method will be called during the chart drawing process and is\n     * declared public so that it can be accessed by the renderers used by\n     * certain subclasses.  You shouldn\u0027t need to call this method directly.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     */\n    @Override\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawBackgroundImage(g2, area);\n    }\n\n    /**\n     * A utility method for drawing the plot\u0027s axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param dataArea  the data area.\n     * @param plotState  collects information about the plot ({@code null}\n     *                   permitted).\n     *\n     * @return A map containing the axis states.\n     */\n    protected Map\u003cAxis, AxisState\u003e drawAxes(Graphics2D g2, Rectangle2D plotArea, \n            Rectangle2D dataArea, PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection \u003d new AxisCollection();\n\n        // add domain axes to lists...\n        for (CategoryAxis xAxis : this.domainAxes.values()) {\n            if (xAxis !\u003d null) {\n                int index \u003d getDomainAxisIndex(xAxis);\n                axisCollection.add(xAxis, getDomainAxisEdge(index));\n            }\n        }\n\n        // add range axes to lists...\n        for (ValueAxis yAxis : this.rangeAxes.values()) {\n            if (yAxis !\u003d null) {\n                int index \u003d findRangeAxisIndex(yAxis);\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map\u003cAxis, AxisState\u003e axisStateMap \u003d new HashMap\u003c\u003e();\n\n        // draw the top axes\n        double cursor \u003d dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        for (Axis axis: axisCollection.getAxesAtTop()) {\n            if (axis !\u003d null) {\n                AxisState axisState \u003d axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.TOP, plotState);\n                cursor \u003d axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the bottom axes\n        cursor \u003d dataArea.getMaxY()\n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        for (Axis axis : axisCollection.getAxesAtBottom()) {\n            if (axis !\u003d null) {\n                AxisState axisState \u003d axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.BOTTOM, plotState);\n                cursor \u003d axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the left axes\n        cursor \u003d dataArea.getMinX()\n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        for (Axis axis : axisCollection.getAxesAtLeft()) {\n            if (axis !\u003d null) {\n                AxisState axisState \u003d axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.LEFT, plotState);\n                cursor \u003d axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the right axes\n        cursor \u003d dataArea.getMaxX()\n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        for (Axis axis: axisCollection.getAxesAtRight()) {\n            if (axis !\u003d null) {\n                AxisState axisState \u003d axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.RIGHT, plotState);\n                cursor \u003d axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n        return axisStateMap;\n    }\n\n    /**\n     * Draws a representation of a dataset within the dataArea region using the\n     * appropriate renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the region in which the data is to be drawn.\n     * @param index  the dataset and renderer index.\n     * @param info  an optional object for collection dimension information.\n     * @param crosshairState  a state object for tracking crosshair info\n     *        ({@code null} permitted).\n     *\n     * @return A boolean that indicates whether or not real data was found.\n     */\n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index,\n            PlotRenderingInfo info, CategoryCrosshairState\u003cR, C\u003e crosshairState) {\n\n        boolean foundData \u003d false;\n        CategoryDataset\u003cR, C\u003e currentDataset \u003d getDataset(index);\n        CategoryItemRenderer renderer \u003d getRenderer(index);\n        CategoryAxis domainAxis \u003d getDomainAxisForDataset(index);\n        ValueAxis rangeAxis \u003d getRangeAxisForDataset(index);\n        boolean hasData \u003d !DatasetUtils.isEmptyOrNull(currentDataset);\n        if (hasData \u0026\u0026 renderer !\u003d null) {\n\n            foundData \u003d true;\n            CategoryItemRendererState state \u003d renderer.initialise(g2, dataArea,\n                    this, index, info);\n            state.setCrosshairState(crosshairState);\n            int columnCount \u003d currentDataset.getColumnCount();\n            int rowCount \u003d currentDataset.getRowCount();\n            int passCount \u003d renderer.getPassCount();\n            for (int pass \u003d 0; pass \u003c passCount; pass++) {\n                if (this.columnRenderingOrder \u003d\u003d SortOrder.ASCENDING) {\n                    for (int column \u003d 0; column \u003c columnCount; column++) {\n                        if (this.rowRenderingOrder \u003d\u003d SortOrder.ASCENDING) {\n                            for (int row \u003d 0; row \u003c rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this,\n                                        domainAxis, rangeAxis, currentDataset,\n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row \u003d rowCount - 1; row \u003e\u003d 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this,\n                                        domainAxis, rangeAxis, currentDataset,\n                                        row, column, pass);\n                            }\n                        }\n                    }\n                }\n                else {\n                    for (int column \u003d columnCount - 1; column \u003e\u003d 0; column--) {\n                        if (this.rowRenderingOrder \u003d\u003d SortOrder.ASCENDING) {\n                            for (int row \u003d 0; row \u003c rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this,\n                                        domainAxis, rangeAxis, currentDataset,\n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row \u003d rowCount - 1; row \u003e\u003d 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this,\n                                        domainAxis, rangeAxis, currentDataset,\n                                        row, column, pass);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n\n    }\n\n    /**\n     * Draws the domain gridlines for the plot, if they are visible.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area inside the axes.\n     *\n     * @see #drawRangeGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea) {\n\n        if (!isDomainGridlinesVisible()) {\n            return;\n        }\n        CategoryAnchor anchor \u003d getDomainGridlinePosition();\n        RectangleEdge domainAxisEdge \u003d getDomainAxisEdge();\n        CategoryDataset\u003cR, C\u003e dataset \u003d getDataset();\n        if (dataset \u003d\u003d null) {\n            return;\n        }\n        CategoryAxis axis \u003d getDomainAxis();\n        if (axis !\u003d null) {\n            int columnCount \u003d dataset.getColumnCount();\n            for (int c \u003d 0; c \u003c columnCount; c++) {\n                double xx \u003d axis.getCategoryJava2DCoordinate(anchor, c,\n                        columnCount, dataArea, domainAxisEdge);\n                CategoryItemRenderer renderer1 \u003d getRenderer();\n                if (renderer1 !\u003d null) {\n                    renderer1.drawDomainGridline(g2, this, dataArea, xx);\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the range gridlines for the plot, if they are visible.\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param dataArea  the area inside the axes ({@code null} not permitted).\n     * @param ticks  the ticks.\n     *\n     * @see #drawDomainGridlines(Graphics2D, Rectangle2D)\n     */\n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                      List\u003cValueTick\u003e ticks) {\n        // draw the range grid lines, if any...\n        if (!isRangeGridlinesVisible() \u0026\u0026 !isRangeMinorGridlinesVisible()) {\n            return;\n        }\n        // no axis, no gridlines...\n        ValueAxis axis \u003d getRangeAxis();\n        if (axis \u003d\u003d null) {\n            return;\n        }\n        // no renderer, no gridlines...\n        CategoryItemRenderer r \u003d getRenderer();\n        if (r \u003d\u003d null) {\n            return;\n        }\n\n        Stroke gridStroke \u003d null;\n        Paint gridPaint \u003d null;\n        boolean paintLine;\n        for (ValueTick tick : ticks) {\n            paintLine \u003d false;\n            if ((tick.getTickType() \u003d\u003d TickType.MINOR)\n                    \u0026\u0026 isRangeMinorGridlinesVisible()) {\n                gridStroke \u003d getRangeMinorGridlineStroke();\n                gridPaint \u003d getRangeMinorGridlinePaint();\n                paintLine \u003d true;\n            }\n            else if ((tick.getTickType() \u003d\u003d TickType.MAJOR)\n                    \u0026\u0026 isRangeGridlinesVisible()) {\n                gridStroke \u003d getRangeGridlineStroke();\n                gridPaint \u003d getRangeGridlinePaint();\n                paintLine \u003d true;\n            }\n            if (((tick.getValue() !\u003d 0.0)\n                    || !isRangeZeroBaselineVisible()) \u0026\u0026 paintLine) {\n                r .drawRangeLine(g2, this, axis, dataArea,\n                            tick.getValue(), gridPaint, gridStroke);\n            }\n        }\n    }\n\n    /**\n     * Draws a base line across the chart at value zero on the range axis.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     *\n     * @see #setRangeZeroBaselineVisible(boolean)\n     */\n    protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area) {\n        if (!isRangeZeroBaselineVisible()) {\n            return;\n        }\n        CategoryItemRenderer r \u003d getRenderer();\n        r.drawRangeLine(g2, this, getRangeAxis(), area, 0.0,\n                    this.rangeZeroBaselinePaint, this.rangeZeroBaselineStroke);\n    }\n\n    /**\n     * Draws the annotations.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     */\n    protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea) {\n        if (getAnnotations() !\u003d null) {\n            for (CategoryAnnotation annotation : getAnnotations()) {\n                annotation.draw(g2, this, dataArea, getDomainAxis(),\n                        getRangeAxis());\n            }\n        }\n    }\n\n    /**\n     * Draws the domain markers (if any) for an axis and layer.  This method is\n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     *\n     * @see #drawRangeMarkers(Graphics2D, Rectangle2D, int, Layer)\n     */\n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                     int index, Layer layer) {\n\n        CategoryItemRenderer r \u003d getRenderer(index);\n        if (r \u003d\u003d null) {\n            return;\n        }\n\n        Collection\u003cCategoryMarker\u003e markers \u003d getDomainMarkers(index, layer);\n        CategoryAxis axis \u003d getDomainAxisForDataset(index);\n        if (markers !\u003d null \u0026\u0026 axis !\u003d null) {\n            for (CategoryMarker marker : markers) {\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n\n    }\n\n    /**\n     * Draws the range markers (if any) for an axis and layer.  This method is\n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     *\n     * @see #drawDomainMarkers(Graphics2D, Rectangle2D, int, Layer)\n     */\n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea,\n            int index, Layer layer) {\n\n        CategoryItemRenderer r \u003d getRenderer(index);\n        if (r \u003d\u003d null) {\n            return;\n        }\n\n        Collection\u003cMarker\u003e markers \u003d getRangeMarkers(index, layer);\n        ValueAxis axis \u003d getRangeAxisForDataset(index);\n        if (markers !\u003d null \u0026\u0026 axis !\u003d null) {\n            for (Marker marker : markers) {\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n\n    }\n\n    /**\n     * Utility method for drawing a line perpendicular to the range axis (used\n     * for crosshairs).\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area defined by the axes.\n     * @param value  the data value.\n     * @param stroke  the line stroke ({@code null} not permitted).\n     * @param paint  the line paint ({@code null} not permitted).\n     */\n    protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea,\n            double value, Stroke stroke, Paint paint) {\n\n        double java2D \u003d getRangeAxis().valueToJava2D(value, dataArea,\n                getRangeAxisEdge());\n        Line2D line \u003d null;\n        if (this.orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n            line \u003d new Line2D.Double(java2D, dataArea.getMinY(), java2D,\n                    dataArea.getMaxY());\n        }\n        else if (this.orientation \u003d\u003d PlotOrientation.VERTICAL) {\n            line \u003d new Line2D.Double(dataArea.getMinX(), java2D,\n                    dataArea.getMaxX(), java2D);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }\n\n    /**\n     * Draws a domain crosshair.\n     *\n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param datasetIndex  the dataset index.\n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     *\n     * @see #drawRangeCrosshair(Graphics2D, Rectangle2D, PlotOrientation,\n     *     double, ValueAxis, Stroke, Paint)\n     */\n    protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, int datasetIndex, R rowKey, C columnKey,\n            Stroke stroke, Paint paint) {\n        CategoryDataset\u003cR, C\u003e dataset \u003d getDataset(datasetIndex);\n        CategoryAxis axis \u003d getDomainAxisForDataset(datasetIndex);\n        CategoryItemRenderer renderer \u003d getRenderer(datasetIndex);\n        Line2D line;\n        if (orientation \u003d\u003d PlotOrientation.VERTICAL) {\n            double xx \u003d renderer.getItemMiddle(rowKey, columnKey, dataset, axis,\n                    dataArea, RectangleEdge.BOTTOM);\n            line \u003d new Line2D.Double(xx, dataArea.getMinY(), xx,\n                    dataArea.getMaxY());\n        }\n        else {\n            double yy \u003d renderer.getItemMiddle(rowKey, columnKey, dataset, axis,\n                    dataArea, RectangleEdge.LEFT);\n            line \u003d new Line2D.Double(dataArea.getMinX(), yy,\n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }\n\n    /**\n     * Draws a range crosshair.\n     *\n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     *\n     * @see #drawDomainCrosshair(Graphics2D, Rectangle2D, PlotOrientation, int,\n     *      Comparable, Comparable, Stroke, Paint)\n     */\n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, double value, ValueAxis axis,\n            Stroke stroke, Paint paint) {\n\n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Line2D line;\n        if (orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n            double xx \u003d axis.valueToJava2D(value, dataArea,\n                    RectangleEdge.BOTTOM);\n            line \u003d new Line2D.Double(xx, dataArea.getMinY(), xx,\n                    dataArea.getMaxY());\n        }\n        else {\n            double yy \u003d axis.valueToJava2D(value, dataArea,\n                    RectangleEdge.LEFT);\n            line \u003d new Line2D.Double(dataArea.getMinX(), yy,\n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }\n\n    /**\n     * Returns the range of data values that will be plotted against the range\n     * axis.  If the dataset is {@code null}, this method returns\n     * {@code null}.\n     *\n     * @param axis  the axis.\n     *\n     * @return The data range.\n     */\n    @Override\n    public Range getDataRange(ValueAxis axis) {\n        Range result \u003d null;\n        List\u003cCategoryDataset\u003cR, C\u003e\u003e mappedDatasets \u003d new ArrayList\u003c\u003e();\n        int rangeIndex \u003d findRangeAxisIndex(axis);\n        if (rangeIndex \u003e\u003d 0) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(rangeIndex));\n        }\n        else if (axis \u003d\u003d getRangeAxis()) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(0));\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        for (CategoryDataset\u003cR, C\u003e d : mappedDatasets) {\n            CategoryItemRenderer r \u003d getRendererForDataset(d);\n            if (r !\u003d null) {\n                result \u003d Range.combine(result, r.findRangeBounds(d));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a list of the datasets that are mapped to the axis with the\n     * specified index.\n     *\n     * @param axisIndex  the axis index.\n     *\n     * @return The list (possibly empty, but never {@code null}).\n     */\n    private List\u003cCategoryDataset\u003cR, C\u003e\u003e datasetsMappedToDomainAxis(int axisIndex) {\n        List\u003cCategoryDataset\u003cR, C\u003e\u003e result \u003d new ArrayList\u003c\u003e();\n        for (Entry\u003cInteger, CategoryDataset\u003cR, C\u003e\u003e entry : this.datasets.entrySet()) {\n            CategoryDataset\u003cR, C\u003e dataset \u003d entry.getValue();\n            if (dataset \u003d\u003d null) {\n                continue;\n            }\n            Integer datasetIndex \u003d entry.getKey();\n            List\u003cInteger\u003e mappedAxes \u003d this.datasetToDomainAxesMap.get(datasetIndex);\n            if (mappedAxes \u003d\u003d null) {\n                if (axisIndex \u003d\u003d 0) {\n                    result.add(dataset);\n                }\n            } else {\n                if (mappedAxes.contains(axisIndex)) {\n                    result.add(dataset);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * A utility method that returns a list of datasets that are mapped to a\n     * given range axis.\n     *\n     * @param axisIndex  the axis index.\n     *\n     * @return The list (possibly empty, but never {@code null}).\n     */\n    private List\u003cCategoryDataset\u003cR, C\u003e\u003e datasetsMappedToRangeAxis(int axisIndex) {\n        List\u003cCategoryDataset\u003cR, C\u003e\u003e result \u003d new ArrayList\u003c\u003e();\n        for (Entry\u003cInteger, CategoryDataset\u003cR, C\u003e\u003e entry : this.datasets.entrySet()) {\n            Integer datasetIndex \u003d entry.getKey();\n            CategoryDataset\u003cR, C\u003e dataset \u003d entry.getValue();\n            List\u003cInteger\u003e mappedAxes \u003d this.datasetToRangeAxesMap.get(\n                    datasetIndex);\n            if (mappedAxes \u003d\u003d null) {\n                if (axisIndex \u003d\u003d 0) {\n                    result.add(dataset);\n                }\n            } else {\n                if (mappedAxes.contains(axisIndex)) {\n                    result.add(dataset);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the weight for this plot when it is used as a subplot within a\n     * combined plot.\n     *\n     * @return The weight.\n     *\n     * @see #setWeight(int)\n     */\n    public int getWeight() {\n        return this.weight;\n    }\n\n    /**\n     * Sets the weight for the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param weight  the weight.\n     *\n     * @see #getWeight()\n     */\n    public void setWeight(int weight) {\n        this.weight \u003d weight;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the fixed domain axis space.\n     *\n     * @return The fixed domain axis space (possibly {@code null}).\n     *\n     * @see #setFixedDomainAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space ({@code null} permitted).\n     *\n     * @see #getFixedDomainAxisSpace()\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        setFixedDomainAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space ({@code null} permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getFixedDomainAxisSpace()\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace \u003d space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the fixed range axis space.\n     *\n     * @return The fixed range axis space (possibly {@code null}).\n     *\n     * @see #setFixedRangeAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space ({@code null} permitted).\n     *\n     * @see #getFixedRangeAxisSpace()\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        setFixedRangeAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space ({@code null} permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getFixedRangeAxisSpace()\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace \u003d space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a list of the categories in the plot\u0027s primary dataset.\n     *\n     * @return A list of the categories in the plot\u0027s primary dataset.\n     *\n     * @see #getCategoriesForAxis(CategoryAxis)\n     */\n    public List\u003cC\u003e getCategories() {\n        List\u003cC\u003e result \u003d null;\n        if (getDataset() !\u003d null) {\n            result \u003d Collections.unmodifiableList(getDataset().getColumnKeys());\n        }\n        return result;\n    }\n\n    /**\n     * Returns a list of the categories that should be displayed for the\n     * specified axis.\n     *\n     * @param axis  the axis ({@code null} not permitted)\n     *\n     * @return The categories.\n     */\n    public List\u003cC\u003e getCategoriesForAxis(CategoryAxis axis) {\n        List\u003cC\u003e result \u003d new ArrayList\u003c\u003e();\n        int axisIndex \u003d getDomainAxisIndex(axis);\n        for (CategoryDataset\u003cR, C\u003e dataset : datasetsMappedToDomainAxis(axisIndex)) {\n            // add the unique categories from this dataset\n            for (int i \u003d 0; i \u003c dataset.getColumnCount(); i++) {\n                C category \u003d dataset.getColumnKey(i);\n                if (!result.contains(category)) {\n                    result.add(category);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the flag that controls whether or not the shared domain axis is\n     * drawn for each subplot.\n     *\n     * @return A boolean.\n     *\n     * @see #setDrawSharedDomainAxis(boolean)\n     */\n    public boolean getDrawSharedDomainAxis() {\n        return this.drawSharedDomainAxis;\n    }\n\n    /**\n     * Sets the flag that controls whether the shared domain axis is drawn when\n     * this plot is being used as a subplot.\n     *\n     * @param draw  a boolean.\n     *\n     * @see #getDrawSharedDomainAxis()\n     */\n    public void setDrawSharedDomainAxis(boolean draw) {\n        this.drawSharedDomainAxis \u003d draw;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns {@code false} always, because the plot cannot be panned\n     * along the domain axis/axes.\n     *\n     * @return A boolean.\n     *\n     * @see #isRangePannable()\n     */\n    @Override\n    public boolean isDomainPannable() {\n        return false;\n    }\n\n    /**\n     * Returns {@code true} if panning is enabled for the range axes,\n     * and {@code false} otherwise.\n     *\n     * @return A boolean.\n     *\n     * @see #setRangePannable(boolean)\n     * @see #isDomainPannable()\n     */\n    @Override\n    public boolean isRangePannable() {\n        return this.rangePannable;\n    }\n\n    /**\n     * Sets the flag that enables or disables panning of the plot along\n     * the range axes.\n     *\n     * @param pannable  the new flag value.\n     *\n     * @see #isRangePannable()\n     */\n    public void setRangePannable(boolean pannable) {\n        this.rangePannable \u003d pannable;\n    }\n\n    /**\n     * Pans the domain axes by the specified percentage.\n     *\n     * @param percent  the distance to pan (as a percentage of the axis length).\n     * @param info the plot info\n     * @param source the source point where the pan action started.\n     */\n    @Override\n    public void panDomainAxes(double percent, PlotRenderingInfo info,\n            Point2D source) {\n        // do nothing, because the plot is not pannable along the domain axes\n    }\n\n    /**\n     * Pans the range axes by the specified percentage.\n     *\n     * @param percent  the distance to pan (as a percentage of the axis length).\n     * @param info the plot info\n     * @param source the source point where the pan action started.\n     */\n    @Override\n    public void panRangeAxes(double percent, PlotRenderingInfo info,\n            Point2D source) {\n        if (!isRangePannable()) {\n            return;\n        }\n        for (ValueAxis axis : this.rangeAxes.values()) {\n            if (axis \u003d\u003d null) {\n                continue;\n            }\n            double length \u003d axis.getRange().getLength();\n            double adj \u003d percent * length;\n            if (axis.isInverted()) {\n                adj \u003d -adj;\n            }\n            axis.setRange(axis.getLowerBound() + adj,\n                    axis.getUpperBound() + adj);\n        }\n    }\n\n    /**\n     * Returns {@code false} to indicate that the domain axes are not\n     * zoomable.\n     *\n     * @return A boolean.\n     *\n     * @see #isRangeZoomable()\n     */\n    @Override\n    public boolean isDomainZoomable() {\n        return false;\n    }\n\n    /**\n     * Returns {@code true} to indicate that the range axes are zoomable.\n     *\n     * @return A boolean.\n     *\n     * @see #isDomainZoomable()\n     */\n    @Override\n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    /**\n     * This method does nothing, because {@code CategoryPlot} doesn\u0027t\n     * support zooming on the domain.\n     *\n     * @param factor  the zoom factor.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    @Override\n    public void zoomDomainAxes(double factor, PlotRenderingInfo state,\n                               Point2D source) {\n        // can\u0027t zoom domain axis\n    }\n\n    /**\n     * This method does nothing, because {@code CategoryPlot} doesn\u0027t\n     * support zooming on the domain.\n     *\n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    @Override\n    public void zoomDomainAxes(double lowerPercent, double upperPercent,\n                               PlotRenderingInfo state, Point2D source) {\n        // can\u0027t zoom domain axis\n    }\n\n    /**\n     * This method does nothing, because {@code CategoryPlot} doesn\u0027t\n     * support zooming on the domain.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * @param useAnchor  use source point as zoom anchor?\n     *\n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean)\n     */\n    @Override\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source, boolean useAnchor) {\n        // can\u0027t zoom domain axis\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    @Override\n    public void zoomRangeAxes(double factor, PlotRenderingInfo state,\n                              Point2D source) {\n        // delegate to other method\n        zoomRangeAxes(factor, state, source, false);\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * @param useAnchor  a flag that controls whether or not the source point\n     *         is used for the zoom anchor.\n     *\n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     */\n    @Override\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source, boolean useAnchor) {\n\n        // perform the zoom on each range axis\n        for (ValueAxis rangeAxis : this.rangeAxes.values()) {\n            if (rangeAxis \u003d\u003d null) {\n                continue;\n            }\n            if (useAnchor) {\n                // get the relevant source coordinate given the plot orientation\n                double sourceY \u003d source.getY();\n                if (this.orientation.isHorizontal()) {\n                    sourceY \u003d source.getX();\n                }\n                double anchorY \u003d rangeAxis.java2DToValue(sourceY,\n                        info.getDataArea(), getRangeAxisEdge());\n                rangeAxis.resizeRange2(factor, anchorY);\n            } else {\n                rangeAxis.resizeRange(factor);\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the range axes.\n     *\n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    @Override\n    public void zoomRangeAxes(double lowerPercent, double upperPercent,\n            PlotRenderingInfo state, Point2D source) {\n        for (ValueAxis yAxis : this.rangeAxes.values()) {\n            if (yAxis !\u003d null) {\n                yAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    /**\n     * Returns the anchor value.\n     *\n     * @return The anchor value.\n     *\n     * @see #setAnchorValue(double)\n     */\n    public double getAnchorValue() {\n        return this.anchorValue;\n    }\n\n    /**\n     * Sets the anchor value and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param value  the anchor value.\n     *\n     * @see #getAnchorValue()\n     */\n    public void setAnchorValue(double value) {\n        setAnchorValue(value, true);\n    }\n\n    /**\n     * Sets the anchor value and, if requested, sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param value  the value.\n     * @param notify  notify listeners?\n     *\n     * @see #getAnchorValue()\n     */\n    public void setAnchorValue(double value, boolean notify) {\n        this.anchorValue \u003d value;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Tests the plot for equality with an arbitrary object.\n     *\n     * @param obj  the object to test against ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryPlot)) {\n            return false;\n        }               \n        @SuppressWarnings(\"unchecked\")\n        CategoryPlot\u003cR, C\u003e that \u003d (CategoryPlot) obj;\n        if (this.orientation !\u003d that.orientation) {\n            return false;\n        }\n        if (!Objects.equals(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.drawSharedDomainAxis !\u003d that.drawSharedDomainAxis) {\n            return false;\n        }\n        if (!this.rangeAxes.equals(that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!Objects.equals(this.datasetToDomainAxesMap, that.datasetToDomainAxesMap)) {\n            return false;\n        }\n        if (!Objects.equals(this.datasetToRangeAxesMap, that.datasetToRangeAxesMap)) {\n            return false;\n        }\n        if (!Objects.equals(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (this.renderingOrder !\u003d that.renderingOrder) {\n            return false;\n        }\n        if (this.columnRenderingOrder !\u003d that.columnRenderingOrder) {\n            return false;\n        }\n        if (this.rowRenderingOrder !\u003d that.rowRenderingOrder) {\n            return false;\n        }\n        if (this.domainGridlinesVisible !\u003d that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.domainGridlinePosition !\u003d that.domainGridlinePosition) {\n            return false;\n        }\n        if (!Objects.equals(this.domainGridlineStroke, that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.domainGridlinePaint,\n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible !\u003d that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (!Objects.equals(this.rangeGridlineStroke, that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.rangeGridlinePaint,\n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (this.anchorValue !\u003d that.anchorValue) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible !\u003d that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue !\u003d that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!Objects.equals(this.rangeCrosshairStroke, that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.rangeCrosshairPaint,\n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData\n                !\u003d that.rangeCrosshairLockedOnData) {\n            return false;\n        }\n        if (!Objects.equals(this.foregroundDomainMarkers, that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!Objects.equals(this.datasets, that.datasets)){\n            return false;\n        }\n        if (!Objects.equals(this.backgroundDomainMarkers, that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!Objects.equals(this.foregroundRangeMarkers, that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!Objects.equals(this.backgroundRangeMarkers, that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!Objects.equals(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (this.weight !\u003d that.weight) {\n            return false;\n        }\n        if (!Objects.equals(this.fixedDomainAxisSpace, that.fixedDomainAxisSpace)) {\n            return false;\n        }\n        if (!Objects.equals(this.fixedRangeAxisSpace, that.fixedRangeAxisSpace)) {\n            return false;\n        }\n        if (!Objects.equals(this.fixedLegendItems, that.fixedLegendItems)) {\n            return false;\n        }\n        if (this.domainCrosshairVisible !\u003d that.domainCrosshairVisible) {\n            return false;\n        }\n        if (this.crosshairDatasetIndex !\u003d that.crosshairDatasetIndex) {\n            return false;\n        }\n        if (!Objects.equals(this.domainCrosshairColumnKey, that.domainCrosshairColumnKey)) {\n            return false;\n        }\n        if (!Objects.equals(this.domainCrosshairRowKey, that.domainCrosshairRowKey)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.domainCrosshairPaint,\n                that.domainCrosshairPaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.domainCrosshairStroke, that.domainCrosshairStroke)) {\n            return false;\n        }\n        if (this.rangeMinorGridlinesVisible\n                !\u003d that.rangeMinorGridlinesVisible) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.rangeMinorGridlinePaint,\n                that.rangeMinorGridlinePaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.rangeMinorGridlineStroke, that.rangeMinorGridlineStroke)) {\n            return false;\n        }\n        if (this.rangeZeroBaselineVisible !\u003d that.rangeZeroBaselineVisible) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.rangeZeroBaselinePaint,\n                that.rangeZeroBaselinePaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.rangeZeroBaselineStroke, that.rangeZeroBaselineStroke)) {\n            return false;\n        }\n        if (!Objects.equals(this.shadowGenerator, that.shadowGenerator)) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    @Override\n    public int hashCode()\n    {\n        int hash \u003d 7;\n        hash \u003d 37 * hash +\n                (this.orientation !\u003d null ? this.orientation.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.axisOffset !\u003d null ? this.axisOffset.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.domainAxes !\u003d null ? this.domainAxes.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.domainAxisLocations !\u003d null ? this.domainAxisLocations.hashCode() : 0);\n        hash \u003d 37 * hash + (this.drawSharedDomainAxis ? 1 : 0);\n        hash \u003d 37 * hash +\n                (this.rangeAxes !\u003d null ? this.rangeAxes.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.rangeAxisLocations !\u003d null ? this.rangeAxisLocations.hashCode() : 0);\n        hash \u003d 37 * hash + (this.datasets !\u003d null ? this.datasets.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.datasetToDomainAxesMap !\u003d null ? this.datasetToDomainAxesMap.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.datasetToRangeAxesMap !\u003d null ? this.datasetToRangeAxesMap.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.renderers !\u003d null ? this.renderers.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.renderingOrder !\u003d null ? this.renderingOrder.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.columnRenderingOrder !\u003d null ? this.columnRenderingOrder.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.rowRenderingOrder !\u003d null ? this.rowRenderingOrder.hashCode() : 0);\n        hash \u003d 37 * hash + (this.domainGridlinesVisible ? 1 : 0);\n        hash \u003d 37 * hash +\n                (this.domainGridlinePosition !\u003d null ? this.domainGridlinePosition.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.domainGridlineStroke !\u003d null ? this.domainGridlineStroke.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.domainGridlinePaint !\u003d null ? this.domainGridlinePaint.hashCode() : 0);\n        hash \u003d 37 * hash + (this.rangeZeroBaselineVisible ? 1 : 0);\n        hash \u003d 37 * hash +\n                (this.rangeZeroBaselineStroke !\u003d null ? this.rangeZeroBaselineStroke.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.rangeZeroBaselinePaint !\u003d null ? this.rangeZeroBaselinePaint.hashCode() : 0);\n        hash \u003d 37 * hash + (this.rangeGridlinesVisible ? 1 : 0);\n        hash \u003d 37 * hash +\n                (this.rangeGridlineStroke !\u003d null ? this.rangeGridlineStroke.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.rangeGridlinePaint !\u003d null ? this.rangeGridlinePaint.hashCode() : 0);\n        hash \u003d 37 * hash + (this.rangeMinorGridlinesVisible ? 1 : 0);\n        hash \u003d 37 * hash +\n                (this.rangeMinorGridlineStroke !\u003d null ? this.rangeMinorGridlineStroke.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.rangeMinorGridlinePaint !\u003d null ? this.rangeMinorGridlinePaint.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (int) (Double.doubleToLongBits(this.anchorValue) ^\n                (Double.doubleToLongBits(this.anchorValue) \u003e\u003e\u003e 32));\n        hash \u003d 37 * hash + this.crosshairDatasetIndex;\n        hash \u003d 37 * hash + (this.domainCrosshairVisible ? 1 : 0);\n        hash \u003d 37 * hash +\n                (this.domainCrosshairRowKey !\u003d null ? this.domainCrosshairRowKey.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.domainCrosshairColumnKey !\u003d null ? this.domainCrosshairColumnKey.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.domainCrosshairStroke !\u003d null ? this.domainCrosshairStroke.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.domainCrosshairPaint !\u003d null ? this.domainCrosshairPaint.hashCode() : 0);\n        hash \u003d 37 * hash + (this.rangeCrosshairVisible ? 1 : 0);\n        hash \u003d 37 * hash +\n                (int) (Double.doubleToLongBits(this.rangeCrosshairValue) ^\n                (Double.doubleToLongBits(this.rangeCrosshairValue) \u003e\u003e\u003e 32));\n        hash \u003d 37 * hash +\n                (this.rangeCrosshairStroke !\u003d null ? this.rangeCrosshairStroke.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.rangeCrosshairPaint !\u003d null ? this.rangeCrosshairPaint.hashCode() : 0);\n        hash \u003d 37 * hash + (this.rangeCrosshairLockedOnData ? 1 : 0);\n        hash \u003d 37 * hash +\n                (this.foregroundDomainMarkers !\u003d null ? this.foregroundDomainMarkers.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.backgroundDomainMarkers !\u003d null ? this.backgroundDomainMarkers.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.foregroundRangeMarkers !\u003d null ? this.foregroundRangeMarkers.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.backgroundRangeMarkers !\u003d null ? this.backgroundRangeMarkers.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.annotations !\u003d null ? this.annotations.hashCode() : 0);\n        hash \u003d 37 * hash + this.weight;\n        hash \u003d 37 * hash +\n                (this.fixedDomainAxisSpace !\u003d null ? this.fixedDomainAxisSpace.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.fixedRangeAxisSpace !\u003d null ? this.fixedRangeAxisSpace.hashCode() : 0);\n        hash \u003d 37 * hash +\n                (this.fixedLegendItems !\u003d null ? this.fixedLegendItems.hashCode() : 0);\n        hash \u003d 37 * hash + (this.rangePannable ? 1 : 0);\n        hash \u003d 37 * hash +\n                (this.shadowGenerator !\u003d null ? this.shadowGenerator.hashCode() : 0);\n        return hash;\n    }\n\n    /**\n     * Returns a clone of the plot.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  if the cloning is not supported.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        @SuppressWarnings(\"unchecked\")\n        CategoryPlot\u003cR, C\u003e clone \u003d (CategoryPlot) super.clone();\n        clone.domainAxes \u003d CloneUtils.cloneMapValues(this.domainAxes);\n        for (CategoryAxis axis : clone.domainAxes.values()) {\n            if (axis !\u003d null) {\n                axis.setPlot(clone);\n                axis.addChangeListener(clone);\n            }\n        }\n        clone.rangeAxes \u003d CloneUtils.cloneMapValues(this.rangeAxes);\n        for (ValueAxis axis : clone.rangeAxes.values()) {\n            if (axis !\u003d null) {\n                axis.setPlot(clone);\n                axis.addChangeListener(clone);\n            }\n        }\n\n        // AxisLocation is immutable, so we can just copy the maps\n        clone.domainAxisLocations \u003d new HashMap\u003c\u003e(\n                this.domainAxisLocations);\n        clone.rangeAxisLocations \u003d new HashMap\u003c\u003e(\n                this.rangeAxisLocations);\n\n        clone.datasets \u003d new HashMap\u003c\u003e(this.datasets);\n        for (CategoryDataset\u003cR, C\u003e dataset : clone.datasets.values()) {\n            if (dataset !\u003d null) {\n                dataset.addChangeListener(clone);\n            }\n        }\n        clone.datasetToDomainAxesMap \u003d new TreeMap\u003c\u003e();\n        clone.datasetToDomainAxesMap.putAll(this.datasetToDomainAxesMap);\n        clone.datasetToRangeAxesMap \u003d new TreeMap\u003c\u003e();\n        clone.datasetToRangeAxesMap.putAll(this.datasetToRangeAxesMap);\n\n        clone.renderers \u003d CloneUtils.cloneMapValues(this.renderers);\n        for (CategoryItemRenderer renderer : clone.renderers.values()) {\n            if (renderer !\u003d null) {\n                renderer.setPlot(clone);\n                renderer.addChangeListener(clone);\n            }\n        }\n        if (this.fixedDomainAxisSpace !\u003d null) {\n            clone.fixedDomainAxisSpace \u003d CloneUtils.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace !\u003d null) {\n            clone.fixedRangeAxisSpace \u003d CloneUtils.clone(\n                    this.fixedRangeAxisSpace);\n        }\n\n        clone.annotations \u003d CloneUtils.cloneList(this.annotations);\n        clone.foregroundDomainMarkers \u003d CloneUtils.cloneMapValues(\n                this.foregroundDomainMarkers);\n        clone.backgroundDomainMarkers \u003d CloneUtils.cloneMapValues(\n                this.backgroundDomainMarkers);\n        clone.foregroundRangeMarkers \u003d CloneUtils.cloneMapValues(\n                this.foregroundRangeMarkers);\n        clone.backgroundRangeMarkers \u003d CloneUtils.cloneMapValues(\n                this.backgroundRangeMarkers);\n        if (this.fixedLegendItems !\u003d null) {\n            clone.fixedLegendItems \u003d CloneUtils.clone(this.fixedLegendItems);\n        }\n        return clone;\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtils.writePaint(this.domainGridlinePaint, stream);\n        SerialUtils.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtils.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtils.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtils.writePaint(this.rangeCrosshairPaint, stream);\n        SerialUtils.writeStroke(this.domainCrosshairStroke, stream);\n        SerialUtils.writePaint(this.domainCrosshairPaint, stream);\n        SerialUtils.writeStroke(this.rangeMinorGridlineStroke, stream);\n        SerialUtils.writePaint(this.rangeMinorGridlinePaint, stream);\n        SerialUtils.writeStroke(this.rangeZeroBaselineStroke, stream);\n        SerialUtils.writePaint(this.rangeZeroBaselinePaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke \u003d SerialUtils.readStroke(stream);\n        this.domainGridlinePaint \u003d SerialUtils.readPaint(stream);\n        this.rangeGridlineStroke \u003d SerialUtils.readStroke(stream);\n        this.rangeGridlinePaint \u003d SerialUtils.readPaint(stream);\n        this.rangeCrosshairStroke \u003d SerialUtils.readStroke(stream);\n        this.rangeCrosshairPaint \u003d SerialUtils.readPaint(stream);\n        this.domainCrosshairStroke \u003d SerialUtils.readStroke(stream);\n        this.domainCrosshairPaint \u003d SerialUtils.readPaint(stream);\n        this.rangeMinorGridlineStroke \u003d SerialUtils.readStroke(stream);\n        this.rangeMinorGridlinePaint \u003d SerialUtils.readPaint(stream);\n        this.rangeZeroBaselineStroke \u003d SerialUtils.readStroke(stream);\n        this.rangeZeroBaselinePaint \u003d SerialUtils.readPaint(stream);\n\n        for (CategoryAxis xAxis : this.domainAxes.values()) {\n            if (xAxis !\u003d null) {\n                xAxis.setPlot(this);\n                xAxis.addChangeListener(this);\n            }\n        }\n        for (ValueAxis yAxis : this.rangeAxes.values()) {\n            if (yAxis !\u003d null) {\n                yAxis.setPlot(this);\n                yAxis.addChangeListener(this);\n            }\n        }\n        for (CategoryDataset\u003cR, C\u003e dataset : this.datasets.values()) {\n            if (dataset !\u003d null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        for (CategoryItemRenderer renderer : this.renderers.values()) {\n            if (renderer !\u003d null) {\n                renderer.addChangeListener(this);\n            }\n        }\n\n    }\n\n}","methodCount":225,"staticMethodCount":0,"instanceMethodCount":225,"classLoc":4791,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":3,"candidates":[{"lineStart":4851,"lineEnd":4899,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method readObject to class ShadowGenerator","description":"Move method readObject to org.jfree.chart.util.ShadowGenerator\nRationale: The method readObject() handles serialization in a detailed manner specific to various graphical properties (like gridline strokes and paints). Although this functionality is important, it does not align with the core responsibility of the class that originally contained it. Moving this method to ShadowGenerator, which already handles graphical rendering operations (albeit specific to shadow creation), would consolidate related graphical operations within a single class. Moreover, the connection to graphic serialization and the potential use of serializable graphical properties in generating shadows makes ShadowGenerator a suitable home for the readObject() method.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Somewhat Unhelpful"},{"lineStart":3719,"lineEnd":3768,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method drawRangeGridlines to class AxisSpace","description":"Move method drawRangeGridlines to org.jfree.chart.axis.AxisSpace\nRationale: The method drawRangeGridlines() is responsible for rendering aspect calculation and visual representation tied closely to axis space configurations (such as gridlines visibility, axis presence, and renderer usage). The AxisSpace class manages the space around a plot\u0027s axes, which aligns better with handling visual elements like gridlines. Moving the method here leverages existing functionality related to axis space, preserving cohesion.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Somewhat Helpful"},{"lineStart":817,"lineEnd":829,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method clearDomainAxes to class ShadowGenerator","description":"Move method clearDomainAxes to org.jfree.chart.util.ShadowGenerator\nRationale: clearDomainAxes() is unrelated and doesn\u0027t align with the responsibilities defined within the ShadowGenerator class, which focuses on creating and manipulating shadow images. Hence, it is essential to find another class within the codebase that handles domain axis management for the method instead of moving it to ShadowGenerator.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Very Unhelpful"}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":527834},{"candidateIndex":1,"elapsedTime":44648},{"candidateIndex":2,"elapsedTime":135319}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":70165},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"setDomainAxis","method_signature":"public setDomainAxis(int index, CategoryAxis axis, boolean notify)","target_class":"","rationale":""},{"method_name":"clearDomainAxes","method_signature":"public clearDomainAxes()","target_class":"","rationale":""},{"method_name":"configureDomainAxes","method_signature":"public configureDomainAxes()","target_class":"","rationale":""},{"method_name":"setRangeAxis","method_signature":"public setRangeAxis(int index, ValueAxis axis, boolean notify)","target_class":"","rationale":""},{"method_name":"clearRangeAxes","method_signature":"public clearRangeAxes()","target_class":"","rationale":""},{"method_name":"configureRangeAxes","method_signature":"public configureRangeAxes()","target_class":"","rationale":""},{"method_name":"setRenderer","method_signature":"public setRenderer(int index, CategoryItemRenderer renderer,\n            boolean notify)","target_class":"","rationale":""},{"method_name":"addDomainMarker","method_signature":"public addDomainMarker(int index, CategoryMarker marker, Layer layer,\n            boolean notify)","target_class":"","rationale":""},{"method_name":"clearDomainMarkers","method_signature":"public clearDomainMarkers(int index)","target_class":"","rationale":""},{"method_name":"addRangeMarker","method_signature":"public addRangeMarker(int index, Marker marker, Layer layer,\n            boolean notify)","target_class":"","rationale":""},{"method_name":"clearRangeMarkers","method_signature":"public clearRangeMarkers(int index)","target_class":"","rationale":""},{"method_name":"addAnnotation","method_signature":"public addAnnotation(CategoryAnnotation annotation, boolean notify)","target_class":"","rationale":""},{"method_name":"removeAnnotation","method_signature":"public removeAnnotation(CategoryAnnotation annotation,\n            boolean notify)","target_class":"","rationale":""},{"method_name":"calculateDomainAxisSpace","method_signature":"protected calculateDomainAxisSpace(Graphics2D g2,\n            Rectangle2D plotArea, AxisSpace space)","target_class":"","rationale":""},{"method_name":"calculateRangeAxisSpace","method_signature":"protected calculateRangeAxisSpace(Graphics2D g2,\n            Rectangle2D plotArea, AxisSpace space)","target_class":"","rationale":""},{"method_name":"drawAxes","method_signature":"protected drawAxes(Graphics2D g2, Rectangle2D plotArea, \n            Rectangle2D dataArea, PlotRenderingInfo plotState)","target_class":"","rationale":""},{"method_name":"drawRangeGridlines","method_signature":"protected drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                      List\u003cValueTick\u003e ticks)","target_class":"","rationale":""},{"method_name":"drawAnnotations","method_signature":"protected drawAnnotations(Graphics2D g2, Rectangle2D dataArea)","target_class":"","rationale":""},{"method_name":"drawRangeCrosshair","method_signature":"protected drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, double value, ValueAxis axis,\n            Stroke stroke, Paint paint)","target_class":"","rationale":""},{"method_name":"readObject","method_signature":"private readObject(ObjectInputStream stream)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"configureDomainAxes","method_signature":"public configureDomainAxes()","target_class":"","rationale":""},{"method_name":"configureRangeAxes","method_signature":"public configureRangeAxes()","target_class":"","rationale":""},{"method_name":"readObject","method_signature":"private readObject(ObjectInputStream stream)","target_class":"","rationale":""},{"method_name":"drawAxes","method_signature":"protected drawAxes(Graphics2D g2, Rectangle2D plotArea, \n            Rectangle2D dataArea, PlotRenderingInfo plotState)","target_class":"","rationale":""},{"method_name":"drawRangeGridlines","method_signature":"protected drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                      List\u003cValueTick\u003e ticks)","target_class":"","rationale":""},{"method_name":"clearRangeMarkers","method_signature":"public clearRangeMarkers(int index)","target_class":"","rationale":""},{"method_name":"clearDomainAxes","method_signature":"public clearDomainAxes()","target_class":"","rationale":""},{"method_name":"clearDomainMarkers","method_signature":"public clearDomainMarkers(int index)","target_class":"","rationale":""},{"method_name":"clearRangeAxes","method_signature":"public clearRangeAxes()","target_class":"","rationale":""},{"method_name":"calculateDomainAxisSpace","method_signature":"protected calculateDomainAxisSpace(Graphics2D g2,\n            Rectangle2D plotArea, AxisSpace space)","target_class":"","rationale":""},{"method_name":"addAnnotation","method_signature":"public addAnnotation(CategoryAnnotation annotation, boolean notify)","target_class":"","rationale":""},{"method_name":"removeAnnotation","method_signature":"public removeAnnotation(CategoryAnnotation annotation,\n            boolean notify)","target_class":"","rationale":""},{"method_name":"setDomainAxis","method_signature":"public setDomainAxis(int index, CategoryAxis axis, boolean notify)","target_class":"","rationale":""},{"method_name":"setRangeAxis","method_signature":"public setRangeAxis(int index, ValueAxis axis, boolean notify)","target_class":"","rationale":""},{"method_name":"drawAnnotations","method_signature":"protected drawAnnotations(Graphics2D g2, Rectangle2D dataArea)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public configureDomainAxes()":{"first":{"method_name":"configureDomainAxes","method_signature":"public configureDomainAxes()","target_class":"","rationale":""},"second":0.5654535317476835},"public configureRangeAxes()":{"first":{"method_name":"configureRangeAxes","method_signature":"public configureRangeAxes()","target_class":"","rationale":""},"second":0.5679834234503369},"private readObject(ObjectInputStream stream)":{"first":{"method_name":"readObject","method_signature":"private readObject(ObjectInputStream stream)","target_class":"","rationale":""},"second":0.5721838035357966},"protected drawAxes(Graphics2D g2, Rectangle2D plotArea, \n            Rectangle2D dataArea, PlotRenderingInfo plotState)":{"first":{"method_name":"drawAxes","method_signature":"protected drawAxes(Graphics2D g2, Rectangle2D plotArea, \n            Rectangle2D dataArea, PlotRenderingInfo plotState)","target_class":"","rationale":""},"second":0.6345563115277165},"protected drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                      List\u003cValueTick\u003e ticks)":{"first":{"method_name":"drawRangeGridlines","method_signature":"protected drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                      List\u003cValueTick\u003e ticks)","target_class":"","rationale":""},"second":0.678710698335946},"public clearRangeMarkers(int index)":{"first":{"method_name":"clearRangeMarkers","method_signature":"public clearRangeMarkers(int index)","target_class":"","rationale":""},"second":0.6791165957101535},"public clearDomainAxes()":{"first":{"method_name":"clearDomainAxes","method_signature":"public clearDomainAxes()","target_class":"","rationale":""},"second":0.6795691996699038},"public clearDomainMarkers(int index)":{"first":{"method_name":"clearDomainMarkers","method_signature":"public clearDomainMarkers(int index)","target_class":"","rationale":""},"second":0.6811721237001316},"public clearRangeAxes()":{"first":{"method_name":"clearRangeAxes","method_signature":"public clearRangeAxes()","target_class":"","rationale":""},"second":0.6815787698603165},"protected calculateDomainAxisSpace(Graphics2D g2,\n            Rectangle2D plotArea, AxisSpace space)":{"first":{"method_name":"calculateDomainAxisSpace","method_signature":"protected calculateDomainAxisSpace(Graphics2D g2,\n            Rectangle2D plotArea, AxisSpace space)","target_class":"","rationale":""},"second":0.7010045217381521},"public addAnnotation(CategoryAnnotation annotation, boolean notify)":{"first":{"method_name":"addAnnotation","method_signature":"public addAnnotation(CategoryAnnotation annotation, boolean notify)","target_class":"","rationale":""},"second":0.7286471905564339},"public removeAnnotation(CategoryAnnotation annotation,\n            boolean notify)":{"first":{"method_name":"removeAnnotation","method_signature":"public removeAnnotation(CategoryAnnotation annotation,\n            boolean notify)","target_class":"","rationale":""},"second":0.7325575699227583},"public setDomainAxis(int index, CategoryAxis axis, boolean notify)":{"first":{"method_name":"setDomainAxis","method_signature":"public setDomainAxis(int index, CategoryAxis axis, boolean notify)","target_class":"","rationale":""},"second":0.7332878291528863},"public setRangeAxis(int index, ValueAxis axis, boolean notify)":{"first":{"method_name":"setRangeAxis","method_signature":"public setRangeAxis(int index, ValueAxis axis, boolean notify)","target_class":"","rationale":""},"second":0.7388049897042204},"protected drawAnnotations(Graphics2D g2, Rectangle2D dataArea)":{"first":{"method_name":"drawAnnotations","method_signature":"protected drawAnnotations(Graphics2D g2, Rectangle2D dataArea)","target_class":"","rationale":""},"second":0.7472688534805256}},"targetClassMap":{"configureDomainAxes":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.3117337842874747}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":3440,"similarity_computation_time":1,"similarity_metric":"cosine"},"configureRangeAxes":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.3117337842874747}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":2812,"similarity_computation_time":0,"similarity_metric":"cosine"},"readObject":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.26604634690878237}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":3398,"similarity_computation_time":0,"similarity_metric":"cosine"},"drawAxes":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.37570783309456507}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":3449,"similarity_computation_time":0,"similarity_metric":"cosine"},"drawRangeGridlines":{"target_classes":[{"class_name":"PlotOrientation","similarity_score":0.3800116577880773},{"class_name":"RectangleInsets","similarity_score":0.6203973311021309},{"class_name":"DatasetRenderingOrder","similarity_score":0.3203839834958223},{"class_name":"SortOrder","similarity_score":0.172680240519555},{"class_name":"SortOrder","similarity_score":0.172680240519555},{"class_name":"CategoryAnchor","similarity_score":0.1531859609675296},{"class_name":"AxisSpace","similarity_score":0.6535349845435386},{"class_name":"AxisSpace","similarity_score":0.6535349845435386},{"class_name":"LegendItemCollection","similarity_score":0.5469491534755746},{"class_name":"ShadowGenerator","similarity_score":0.3825402978513832}],"target_classes_sorted_by_llm":["AxisSpace","AxisSpace","RectangleInsets"],"llm_response_time":6352,"similarity_computation_time":3,"similarity_metric":"cosine"},"clearRangeMarkers":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.3926555951015235}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":3623,"similarity_computation_time":0,"similarity_metric":"cosine"},"clearDomainAxes":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.4479720414934765}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":4452,"similarity_computation_time":0,"similarity_metric":"cosine"},"clearDomainMarkers":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.3941514313567777}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":5456,"similarity_computation_time":0,"similarity_metric":"cosine"},"clearRangeAxes":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.4479720414934765}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":3032,"similarity_computation_time":0,"similarity_metric":"cosine"},"calculateDomainAxisSpace":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.4613273602074178}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":7143,"similarity_computation_time":0,"similarity_metric":"cosine"},"addAnnotation":{"target_classes":[{"class_name":"CategoryAnnotation","similarity_score":0.6231420729465461},{"class_name":"ShadowGenerator","similarity_score":0.5659167335720786}],"target_classes_sorted_by_llm":["CategoryAnnotation","ShadowGenerator"],"llm_response_time":3055,"similarity_computation_time":0,"similarity_metric":"cosine"},"removeAnnotation":{"target_classes":[{"class_name":"CategoryAnnotation","similarity_score":0.5996090780342954},{"class_name":"ShadowGenerator","similarity_score":0.5845881890137911}],"target_classes_sorted_by_llm":["CategoryAnnotation","ShadowGenerator"],"llm_response_time":4083,"similarity_computation_time":0,"similarity_metric":"cosine"},"setDomainAxis":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.4302544190796162}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":8002,"similarity_computation_time":0,"similarity_metric":"cosine"},"setRangeAxis":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.4396886460483518}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":4704,"similarity_computation_time":0,"similarity_metric":"cosine"},"drawAnnotations":{"target_classes":[{"class_name":"PlotOrientation","similarity_score":0.5027528770714567},{"class_name":"RectangleInsets","similarity_score":0.6449879910630929},{"class_name":"DatasetRenderingOrder","similarity_score":0.47425139862049276},{"class_name":"SortOrder","similarity_score":0.2748832530976198},{"class_name":"SortOrder","similarity_score":0.2748832530976198},{"class_name":"CategoryAnchor","similarity_score":0.2558831578595795},{"class_name":"AxisSpace","similarity_score":0.6858813326913926},{"class_name":"AxisSpace","similarity_score":0.6858813326913926},{"class_name":"LegendItemCollection","similarity_score":0.6400627642375886},{"class_name":"ShadowGenerator","similarity_score":0.5737617582233945}],"target_classes_sorted_by_llm":["RectangleInsets","AxisSpace","AxisSpace"],"llm_response_time":5718,"similarity_computation_time":1,"similarity_metric":"cosine"}}}
{"id":"e83679f7-4d63-4866-b4e7-4e3b4de14d0d","hostFunctionTelemetryData":{"hostFunctionSize":5301,"lineStart":93,"lineEnd":5393,"bodyLineStart":93,"language":"java","filePath":"/Users/snehil/Documents/ConcordiaUniversity/Material/SOEN-6491-Refactoring/OpenSource/jfreechart/jfreechart/src/main/java/org/jfree/chart/plot/XYPlot.java","sourceCode":"/**\n * A general class for plotting data in the form of (x, y) pairs.  This plot can\n * use data from any class that implements the {@link XYDataset} interface.\n * \u003cP\u003e\n * {@code XYPlot} makes use of an {@link XYItemRenderer} to draw each point\n * on the plot.  By using different renderers, various chart types can be\n * produced.\n * \u003cp\u003e\n * The {@link org.jfree.chart.ChartFactory} class contains static methods for\n * creating pre-configured charts.\n * \n * @param \u003cS\u003eThe type for the series keys.\n */\npublic class XYPlot\u003cS extends Comparable\u003cS\u003e\u003e extends Plot \n        implements ValueAxisPlot, Pannable, Zoomable,\n        RendererChangeListener, Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d 7044148245716569264L;\n\n    /** The default grid line stroke. */\n    public static final Stroke DEFAULT_GRIDLINE_STROKE \u003d new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f,\n            new float[] {2.0f, 2.0f}, 0.0f);\n\n    /** The default grid line paint. */\n    public static final Paint DEFAULT_GRIDLINE_PAINT \u003d Color.LIGHT_GRAY;\n\n    /** The default crosshair visibility. */\n    public static final boolean DEFAULT_CROSSHAIR_VISIBLE \u003d false;\n\n    /** The default crosshair stroke. */\n    public static final Stroke DEFAULT_CROSSHAIR_STROKE\n            \u003d DEFAULT_GRIDLINE_STROKE;\n\n    /** The default crosshair paint. */\n    public static final Paint DEFAULT_CROSSHAIR_PAINT \u003d Color.BLUE;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources\n            \u003d ResourceBundle.getBundle(\"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** The plot orientation. */\n    private PlotOrientation orientation;\n\n    /** The offset between the data area and the axes. */\n    private RectangleInsets axisOffset;\n\n    /** The domain axis / axes (used for the x-values). */\n    private Map\u003cInteger, ValueAxis\u003e domainAxes;\n\n    /** The domain axis locations. */\n    private Map\u003cInteger, AxisLocation\u003e domainAxisLocations;\n\n    /** The range axis (used for the y-values). */\n    private Map\u003cInteger, ValueAxis\u003e rangeAxes;\n\n    /** The range axis location. */\n    private Map\u003cInteger, AxisLocation\u003e rangeAxisLocations;\n\n    /** Storage for the datasets. */\n    private Map\u003cInteger, XYDataset\u003cS\u003e\u003e datasets;\n\n    /** Storage for the renderers. */\n    private Map\u003cInteger, XYItemRenderer\u003e renderers;\n\n    /**\n     * Storage for the mapping between datasets/renderers and domain axes.  The\n     * keys in the map are Integer objects, corresponding to the dataset\n     * index.  The values in the map are List objects containing Integer\n     * objects (corresponding to the axis indices).  If the map contains no\n     * entry for a dataset, it is assumed to map to the primary domain axis\n     * (index \u003d 0).\n     */\n    private Map\u003cInteger, List\u003cInteger\u003e\u003e datasetToDomainAxesMap;\n\n    /**\n     * Storage for the mapping between datasets/renderers and range axes.  The\n     * keys in the map are Integer objects, corresponding to the dataset\n     * index.  The values in the map are List objects containing Integer\n     * objects (corresponding to the axis indices).  If the map contains no\n     * entry for a dataset, it is assumed to map to the primary domain axis\n     * (index \u003d 0).\n     */\n    private Map\u003cInteger, List\u003cInteger\u003e\u003e datasetToRangeAxesMap;\n\n    /** The origin point for the quadrants (if drawn). */\n    private transient Point2D quadrantOrigin \u003d new Point2D.Double(0.0, 0.0);\n\n    /** The paint used for each quadrant. */\n    private transient Paint[] quadrantPaint\n            \u003d new Paint[] {null, null, null, null};\n\n    /** A flag that controls whether the domain grid-lines are visible. */\n    private boolean domainGridlinesVisible;\n\n    /** The stroke used to draw the domain grid-lines. */\n    private transient Stroke domainGridlineStroke;\n\n    /** The paint used to draw the domain grid-lines. */\n    private transient Paint domainGridlinePaint;\n\n    /** A flag that controls whether the range grid-lines are visible. */\n    private boolean rangeGridlinesVisible;\n\n    /** The stroke used to draw the range grid-lines. */\n    private transient Stroke rangeGridlineStroke;\n\n    /** The paint used to draw the range grid-lines. */\n    private transient Paint rangeGridlinePaint;\n\n    /**\n     * A flag that controls whether the domain minor grid-lines are visible.\n     */\n    private boolean domainMinorGridlinesVisible;\n\n    /**\n     * The stroke used to draw the domain minor grid-lines.\n     */\n    private transient Stroke domainMinorGridlineStroke;\n\n    /**\n     * The paint used to draw the domain minor grid-lines.\n     */\n    private transient Paint domainMinorGridlinePaint;\n\n    /**\n     * A flag that controls whether the range minor grid-lines are visible.\n     */\n    private boolean rangeMinorGridlinesVisible;\n\n    /**\n     * The stroke used to draw the range minor grid-lines.\n     */\n    private transient Stroke rangeMinorGridlineStroke;\n\n    /**\n     * The paint used to draw the range minor grid-lines.\n     */\n    private transient Paint rangeMinorGridlinePaint;\n\n    /**\n     * A flag that controls whether or not the zero baseline against the domain\n     * axis is visible.\n     */\n    private boolean domainZeroBaselineVisible;\n\n    /**\n     * The stroke used for the zero baseline against the domain axis.\n     */\n    private transient Stroke domainZeroBaselineStroke;\n\n    /**\n     * The paint used for the zero baseline against the domain axis.\n     */\n    private transient Paint domainZeroBaselinePaint;\n\n    /**\n     * A flag that controls whether or not the zero baseline against the range\n     * axis is visible.\n     */\n    private boolean rangeZeroBaselineVisible;\n\n    /** The stroke used for the zero baseline against the range axis. */\n    private transient Stroke rangeZeroBaselineStroke;\n\n    /** The paint used for the zero baseline against the range axis. */\n    private transient Paint rangeZeroBaselinePaint;\n\n    /** A flag that controls whether or not a domain crosshair is drawn..*/\n    private boolean domainCrosshairVisible;\n\n    /** The domain crosshair value. */\n    private double domainCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke domainCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint domainCrosshairPaint;\n\n    /**\n     * A flag that controls whether or not the crosshair locks onto actual\n     * data points.\n     */\n    private boolean domainCrosshairLockedOnData \u003d true;\n\n    /** A flag that controls whether or not a range crosshair is drawn..*/\n    private boolean rangeCrosshairVisible;\n\n    /** The range crosshair value. */\n    private double rangeCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke rangeCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint rangeCrosshairPaint;\n\n    /**\n     * A flag that controls whether or not the crosshair locks onto actual\n     * data points.\n     */\n    private boolean rangeCrosshairLockedOnData \u003d true;\n\n    /** A map of lists of foreground markers (optional) for the domain axes. */\n    private Map\u003cInteger, List\u003cMarker\u003e\u003e foregroundDomainMarkers;\n\n    /** A map of lists of background markers (optional) for the domain axes. */\n    private Map\u003cInteger, List\u003cMarker\u003e\u003e backgroundDomainMarkers;\n\n    /** A map of lists of foreground markers (optional) for the range axes. */\n    private Map\u003cInteger, List\u003cMarker\u003e\u003e foregroundRangeMarkers;\n\n    /** A map of lists of background markers (optional) for the range axes. */\n    private Map\u003cInteger, List\u003cMarker\u003e\u003e backgroundRangeMarkers;\n\n    /**\n     * A (possibly empty) list of annotations for the plot.  The list should\n     * be initialised in the constructor and never allowed to be\n     * {@code null}.\n     */\n    private List\u003cXYAnnotation\u003e annotations;\n\n    /** The paint used for the domain tick bands (if any). */\n    private transient Paint domainTickBandPaint;\n\n    /** The paint used for the range tick bands (if any). */\n    private transient Paint rangeTickBandPaint;\n\n    /** The fixed domain axis space. */\n    private AxisSpace fixedDomainAxisSpace;\n\n    /** The fixed range axis space. */\n    private AxisSpace fixedRangeAxisSpace;\n\n    /**\n     * The order of the dataset rendering (REVERSE draws the primary dataset\n     * last so that it appears to be on top).\n     */\n    private DatasetRenderingOrder datasetRenderingOrder\n            \u003d DatasetRenderingOrder.REVERSE;\n\n    /**\n     * The order of the series rendering (REVERSE draws the primary series\n     * last so that it appears to be on top).\n     */\n    private SeriesRenderingOrder seriesRenderingOrder\n            \u003d SeriesRenderingOrder.REVERSE;\n\n    /**\n     * The weight for this plot (only relevant if this is a subplot in a\n     * combined plot).\n     */\n    private int weight;\n\n    /**\n     * An optional collection of legend items that can be returned by the\n     * getLegendItems() method.\n     */\n    private LegendItemCollection fixedLegendItems;\n\n    /**\n     * A flag that controls whether or not panning is enabled for the domain\n     * axis/axes.\n     */\n    private boolean domainPannable;\n\n    /**\n     * A flag that controls whether or not panning is enabled for the range\n     * axis/axes.\n     */\n    private boolean rangePannable;\n\n    /**\n     * The shadow generator ({@code null} permitted).\n     */\n    private ShadowGenerator shadowGenerator;\n\n    /**\n     * Creates a new {@code XYPlot} instance with no dataset, no axes and\n     * no renderer.  You should specify these items before using the plot.\n     */\n    public XYPlot() {\n        this(null, null, null, null);\n    }\n\n    /**\n     * Creates a new plot with the specified dataset, axes and renderer.  Any\n     * of the arguments can be {@code null}, but in that case you should\n     * take care to specify the value before using the plot (otherwise a\n     * {@code NullPointerException} may be thrown).\n     *\n     * @param dataset  the dataset ({@code null} permitted).\n     * @param domainAxis  the domain axis ({@code null} permitted).\n     * @param rangeAxis  the range axis ({@code null} permitted).\n     * @param renderer  the renderer ({@code null} permitted).\n     */\n    public XYPlot(XYDataset\u003cS\u003e dataset, ValueAxis domainAxis, ValueAxis rangeAxis,\n            XYItemRenderer renderer) {\n        super();\n        this.orientation \u003d PlotOrientation.VERTICAL;\n        this.weight \u003d 1;  // only relevant when this is a subplot\n        this.axisOffset \u003d RectangleInsets.ZERO_INSETS;\n\n        // allocate storage for datasets, axes and renderers (all optional)\n        this.domainAxes \u003d new HashMap\u003c\u003e();\n        this.domainAxisLocations \u003d new HashMap\u003c\u003e();\n        this.foregroundDomainMarkers \u003d new HashMap\u003c\u003e();\n        this.backgroundDomainMarkers \u003d new HashMap\u003c\u003e();\n\n        this.rangeAxes \u003d new HashMap\u003c\u003e();\n        this.rangeAxisLocations \u003d new HashMap\u003c\u003e();\n        this.foregroundRangeMarkers \u003d new HashMap\u003c\u003e();\n        this.backgroundRangeMarkers \u003d new HashMap\u003c\u003e();\n\n        this.datasets \u003d new HashMap\u003c\u003e();\n        this.renderers \u003d new HashMap\u003c\u003e();\n\n        this.datasetToDomainAxesMap \u003d new TreeMap\u003c\u003e();\n        this.datasetToRangeAxesMap \u003d new TreeMap\u003c\u003e();\n\n        this.annotations \u003d new ArrayList\u003c\u003e();\n\n        if (dataset !\u003d null) {\n            dataset.addChangeListener(this);\n\n            this.datasets.put(0, dataset);\n        }\n\n        if (renderer !\u003d null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n            this.renderers.put(0, renderer);\n        }\n\n        if (domainAxis !\u003d null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n            this.domainAxes.put(0, domainAxis);\n            mapDatasetToDomainAxis(0, 0);\n        }\n\n        this.domainAxisLocations.put(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        if (rangeAxis !\u003d null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n            this.rangeAxes.put(0, rangeAxis);\n            mapDatasetToRangeAxis(0, 0);\n        }\n        this.rangeAxisLocations.put(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible \u003d true;\n        this.domainGridlineStroke \u003d DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint \u003d DEFAULT_GRIDLINE_PAINT;\n\n        this.domainMinorGridlinesVisible \u003d false;\n        this.domainMinorGridlineStroke \u003d DEFAULT_GRIDLINE_STROKE;\n        this.domainMinorGridlinePaint \u003d Color.WHITE;\n\n        this.domainZeroBaselineVisible \u003d false;\n        this.domainZeroBaselinePaint \u003d Color.BLACK;\n        this.domainZeroBaselineStroke \u003d new BasicStroke(0.5f);\n\n        this.rangeGridlinesVisible \u003d true;\n        this.rangeGridlineStroke \u003d DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint \u003d DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeMinorGridlinesVisible \u003d false;\n        this.rangeMinorGridlineStroke \u003d DEFAULT_GRIDLINE_STROKE;\n        this.rangeMinorGridlinePaint \u003d Color.WHITE;\n\n        this.rangeZeroBaselineVisible \u003d false;\n        this.rangeZeroBaselinePaint \u003d Color.BLACK;\n        this.rangeZeroBaselineStroke \u003d new BasicStroke(0.5f);\n\n        this.domainCrosshairVisible \u003d false;\n        this.domainCrosshairValue \u003d 0.0;\n        this.domainCrosshairStroke \u003d DEFAULT_CROSSHAIR_STROKE;\n        this.domainCrosshairPaint \u003d DEFAULT_CROSSHAIR_PAINT;\n\n        this.rangeCrosshairVisible \u003d false;\n        this.rangeCrosshairValue \u003d 0.0;\n        this.rangeCrosshairStroke \u003d DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint \u003d DEFAULT_CROSSHAIR_PAINT;\n        this.shadowGenerator \u003d null;\n    }\n\n    /**\n     * Returns the plot type as a string.\n     *\n     * @return A short string describing the type of plot.\n     */\n    @Override\n    public String getPlotType() {\n        return localizationResources.getString(\"XY_Plot\");\n    }\n\n    /**\n     * Returns the orientation of the plot.\n     *\n     * @return The orientation (never {@code null}).\n     *\n     * @see #setOrientation(PlotOrientation)\n     */\n    @Override\n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param orientation  the orientation ({@code null} not allowed).\n     *\n     * @see #getOrientation()\n     */\n    public void setOrientation(PlotOrientation orientation) {\n        Args.nullNotPermitted(orientation, \"orientation\");\n        if (orientation !\u003d this.orientation) {\n            this.orientation \u003d orientation;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the axis offset.\n     *\n     * @return The axis offset (never {@code null}).\n     *\n     * @see #setAxisOffset(RectangleInsets)\n     */\n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    /**\n     * Sets the axis offsets (gap between the data area and the axes) and sends\n     * a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset ({@code null} not permitted).\n     *\n     * @see #getAxisOffset()\n     */\n    public void setAxisOffset(RectangleInsets offset) {\n        Args.nullNotPermitted(offset, \"offset\");\n        this.axisOffset \u003d offset;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain axis with index 0.  If the domain axis for this plot\n     * is {@code null}, then the method will return the parent plot\u0027s\n     * domain axis (if there is a parent plot).\n     *\n     * @return The domain axis (possibly {@code null}).\n     *\n     * @see #getDomainAxis(int)\n     * @see #setDomainAxis(ValueAxis)\n     */\n    public ValueAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    /**\n     * Returns the domain axis with the specified index, or {@code null} if \n     * there is no axis with that index.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis ({@code null} possible).\n     *\n     * @see #setDomainAxis(int, ValueAxis)\n     */\n    public ValueAxis getDomainAxis(int index) {\n        ValueAxis result \u003d this.domainAxes.get(index);\n        if (result \u003d\u003d null) {\n            Plot parent \u003d getParent();\n            if (parent instanceof XYPlot) {\n                @SuppressWarnings(\"unchecked\")\n                XYPlot\u003cS\u003e xy \u003d (XYPlot) parent;\n                result \u003d xy.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a map containing the domain axes that are assigned to this plot.\n     * The map is unmodifiable.\n     * \n     * @return A map containing the domain axes that are assigned to the plot \n     *     (never {@code null}).\n     * \n     * @since 1.5.4\n     */\n    public Map\u003cInteger, ValueAxis\u003e getDomainAxes() {\n        return Collections.unmodifiableMap(this.domainAxes);\n    }\n    \n    /**\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axis  the new axis ({@code null} permitted).\n     *\n     * @see #getDomainAxis()\n     * @see #setDomainAxis(int, ValueAxis)\n     */\n    public void setDomainAxis(ValueAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    /**\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis ({@code null} permitted).\n     *\n     * @see #getDomainAxis(int)\n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public void setDomainAxis(int index, ValueAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n\n    /**\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     * @param notify  notify listeners?\n     *\n     * @see #getDomainAxis(int)\n     */\n    public void setDomainAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing \u003d getDomainAxis(index);\n        if (existing !\u003d null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis !\u003d null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.put(index, axis);\n        if (axis !\u003d null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axes  the axes ({@code null} not permitted).\n     *\n     * @see #setRangeAxes(ValueAxis[])\n     */\n    public void setDomainAxes(ValueAxis[] axes) {\n        for (int i \u003d 0; i \u003c axes.length; i++) {\n            setDomainAxis(i, axes[i], false);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the location of the primary domain axis.\n     *\n     * @return The location (never {@code null}).\n     *\n     * @see #setDomainAxisLocation(AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation() {\n        return this.domainAxisLocations.get(0);\n    }\n\n    /**\n     * Sets the location of the primary domain axis and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location ({@code null} not permitted).\n     *\n     * @see #getDomainAxisLocation()\n     */\n    public void setDomainAxisLocation(AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location ({@code null} not permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getDomainAxisLocation()\n     */\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Returns the edge for the primary domain axis (taking into account the\n     * plot\u0027s orientation).\n     *\n     * @return The edge.\n     *\n     * @see #getDomainAxisLocation()\n     * @see #getOrientation()\n     */\n    public RectangleEdge getDomainAxisEdge() {\n        return Plot.resolveDomainAxisLocation(getDomainAxisLocation(),\n                this.orientation);\n    }\n\n    /**\n     * Returns the number of domain axes.\n     *\n     * @return The axis count.\n     *\n     * @see #getRangeAxisCount()\n     */\n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    /**\n     * Clears the domain axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @see #clearRangeAxes()\n     */\n    public void clearDomainAxes() {\n        for (ValueAxis axis: this.domainAxes.values()) {\n            if (axis !\u003d null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the domain axes.\n     */\n    public void configureDomainAxes() {\n        for (ValueAxis axis: this.domainAxes.values()) {\n            if (axis !\u003d null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the location for a domain axis.  If this hasn\u0027t been set\n     * explicitly, the method returns the location that is opposite to the\n     * primary domain axis location.\n     *\n     * @param index  the axis index (must be \u0026gt;\u003d 0).\n     *\n     * @return The location (never {@code null}).\n     *\n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result \u003d this.domainAxisLocations.get(index);\n        if (result \u003d\u003d null) {\n            result \u003d AxisLocation.getOpposite(getDomainAxisLocation());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location ({@code null} not permitted for index\n     *     0).\n     *\n     * @see #getDomainAxisLocation(int)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the axis index (must be \u0026gt;\u003d 0).\n     * @param location  the location ({@code null} not permitted for\n     *     index 0).\n     * @param notify  notify listeners?\n     *\n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location,\n            boolean notify) {\n        if (index \u003d\u003d 0 \u0026\u0026 location \u003d\u003d null) {\n            throw new IllegalArgumentException(\n                    \"Null \u0027location\u0027 for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.put(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the edge for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     *\n     * @see #getRangeAxisEdge(int)\n     */\n    public RectangleEdge getDomainAxisEdge(int index) {\n        AxisLocation location \u003d getDomainAxisLocation(index);\n        return Plot.resolveDomainAxisLocation(location, this.orientation);\n    }\n\n    /**\n     * Returns the range axis for the plot.  If the range axis for this plot is\n     * {@code null}, then the method will return the parent plot\u0027s range\n     * axis (if there is a parent plot).\n     *\n     * @return The range axis.\n     *\n     * @see #getRangeAxis(int)\n     * @see #setRangeAxis(ValueAxis)\n     */\n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    /**\n     * Sets the range axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis ({@code null} permitted).\n     *\n     * @see #getRangeAxis()\n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public void setRangeAxis(ValueAxis axis)  {\n        if (axis !\u003d null) {\n            axis.setPlot(this);\n        }\n        // plot is likely registered as a listener with the existing axis...\n        ValueAxis existing \u003d getRangeAxis();\n        if (existing !\u003d null) {\n            existing.removeChangeListener(this);\n        }\n        this.rangeAxes.put(0, axis);\n        if (axis !\u003d null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the location of the primary range axis.\n     *\n     * @return The location (never {@code null}).\n     *\n     * @see #setRangeAxisLocation(AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation() {\n        return this.rangeAxisLocations.get(0);\n    }\n\n    /**\n     * Sets the location of the primary range axis and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location ({@code null} not permitted).\n     *\n     * @see #getRangeAxisLocation()\n     */\n    public void setRangeAxisLocation(AxisLocation location) {\n        // delegate...\n        setRangeAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the primary range axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location ({@code null} not permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getRangeAxisLocation()\n     */\n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Returns the edge for the primary range axis.\n     *\n     * @return The range axis edge.\n     *\n     * @see #getRangeAxisLocation()\n     * @see #getOrientation()\n     */\n    public RectangleEdge getRangeAxisEdge() {\n        return Plot.resolveRangeAxisLocation(getRangeAxisLocation(),\n                this.orientation);\n    }\n\n    /**\n     * Returns the range axis with the specified index, or {@code null} if \n     * there is no axis with that index.\n     *\n     * @param index  the axis index (must be \u0026gt;\u003d 0).\n     *\n     * @return The axis ({@code null} possible).\n     *\n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result \u003d this.rangeAxes.get(index);\n        if (result \u003d\u003d null) {\n            Plot parent \u003d getParent();\n            if (parent instanceof XYPlot) {\n                @SuppressWarnings(\"unchecked\")\n                XYPlot\u003cS\u003e xy \u003d (XYPlot) parent;\n                result \u003d xy.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns a map containing the range axes that are assigned to this plot.\n     * The map is unmodifiable.\n     * \n     * @return A map containing the range axes that are assigned to the plot \n     *     (never {@code null}).\n     * \n     * @since 1.5.4\n     */\n    public Map\u003cInteger, ValueAxis\u003e getRangeAxes() {\n        return Collections.unmodifiableMap(this.rangeAxes);\n    }\n\n    /**\n     * Sets a range axis and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis ({@code null} permitted).\n     *\n     * @see #getRangeAxis(int)\n     */\n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    }\n\n    /**\n     * Sets a range axis and, if requested, sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis ({@code null} permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getRangeAxis(int)\n     */\n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing \u003d getRangeAxis(index);\n        if (existing !\u003d null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis !\u003d null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.put(index, axis);\n        if (axis !\u003d null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the range axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axes  the axes ({@code null} not permitted).\n     *\n     * @see #setDomainAxes(ValueAxis[])\n     */\n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i \u003d 0; i \u003c axes.length; i++) {\n            setRangeAxis(i, axes[i], false);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the number of range axes.\n     *\n     * @return The axis count.\n     *\n     * @see #getDomainAxisCount()\n     */\n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    /**\n     * Clears the range axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @see #clearDomainAxes()\n     */\n    public void clearRangeAxes() {\n        for (ValueAxis axis: this.rangeAxes.values()) {\n            if (axis !\u003d null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the range axes.\n     *\n     * @see #configureDomainAxes()\n     */\n    public void configureRangeAxes() {\n        for (ValueAxis axis: this.rangeAxes.values()) {\n            if (axis !\u003d null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the location for a range axis.  If this hasn\u0027t been set\n     * explicitly, the method returns the location that is opposite to the\n     * primary range axis location.\n     *\n     * @param index  the axis index (must be \u0026gt;\u003d 0).\n     *\n     * @return The location (never {@code null}).\n     *\n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result \u003d this.rangeAxisLocations.get(index);\n        if (result \u003d\u003d null) {\n            result \u003d AxisLocation.getOpposite(getRangeAxisLocation());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location ({@code null} permitted).\n     *\n     * @see #getRangeAxisLocation(int)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setRangeAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location ({@code null} not permitted for index 0).\n     * @param notify  notify listeners?\n     *\n     * @see #getRangeAxisLocation(int)\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location,\n            boolean notify) {\n        if (index \u003d\u003d 0 \u0026\u0026 location \u003d\u003d null) {\n            throw new IllegalArgumentException(\n                    \"Null \u0027location\u0027 for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.put(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the edge for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     *\n     * @see #getRangeAxisLocation(int)\n     * @see #getOrientation()\n     */\n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location \u003d getRangeAxisLocation(index);\n        return Plot.resolveRangeAxisLocation(location, this.orientation);\n    }\n\n    /**\n     * Returns the primary dataset for the plot.\n     *\n     * @return The primary dataset (possibly {@code null}).\n     *\n     * @see #getDataset(int)\n     * @see #setDataset(XYDataset)\n     */\n    public XYDataset\u003cS\u003e getDataset() {\n        return getDataset(0);\n    }\n\n    /**\n     * Returns the dataset with the specified index, or {@code null} if there\n     * is no dataset with that index.\n     *\n     * @param index  the dataset index (must be \u0026gt;\u003d 0).\n     *\n     * @return The dataset (possibly {@code null}).\n     *\n     * @see #setDataset(int, XYDataset)\n     */\n    public XYDataset\u003cS\u003e getDataset(int index) {\n        return this.datasets.get(index);\n    }\n\n    /**\n     * Returns a map containing the datasets that are assigned to this plot.\n     * The map is unmodifiable.\n     * \n     * @return A map containing the datasets that are assigned to the plot \n     *     (never {@code null}).\n     * \n     * @since 1.5.4\n     */\n    public Map\u003cInteger, XYDataset\u003e getDatasets() {\n        return Collections.unmodifiableMap(this.datasets);\n    }\n\n    /**\n     * Sets the primary dataset for the plot, replacing the existing dataset if\n     * there is one.\n     *\n     * @param dataset  the dataset ({@code null} permitted).\n     *\n     * @see #getDataset()\n     * @see #setDataset(int, XYDataset)\n     */\n    public void setDataset(XYDataset\u003cS\u003e dataset) {\n        setDataset(0, dataset);\n    }\n\n    /**\n     * Sets a dataset for the plot and sends a change event to all registered\n     * listeners.\n     *\n     * @param index  the dataset index (must be \u0026gt;\u003d 0).\n     * @param dataset  the dataset ({@code null} permitted).\n     *\n     * @see #getDataset(int)\n     */\n    public void setDataset(int index, XYDataset\u003cS\u003e dataset) {\n        XYDataset\u003cS\u003e existing \u003d getDataset(index);\n        if (existing !\u003d null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.put(index, dataset);\n        if (dataset !\u003d null) {\n            dataset.addChangeListener(this);\n        }\n\n        // send a dataset change event to self...\n        DatasetChangeEvent event \u003d new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n    }\n\n    /**\n     * Returns the number of datasets.\n     *\n     * @return The number of datasets.\n     */\n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    /**\n     * Returns the index of the specified dataset, or {@code -1} if the\n     * dataset does not belong to the plot.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The index or -1.\n     */\n    public int indexOf(XYDataset\u003cS\u003e dataset) {\n        for (Map.Entry\u003cInteger, XYDataset\u003cS\u003e\u003e entry: this.datasets.entrySet()) {\n            if (dataset \u003d\u003d entry.getValue()) {\n                return entry.getKey();\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Maps a dataset to a particular domain axis.  All data will be plotted\n     * against axis zero by default, no mapping is required for this case.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index.\n     *\n     * @see #mapDatasetToRangeAxis(int, int)\n     */\n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        List\u003cInteger\u003e axisIndices \u003d new ArrayList\u003c\u003e(1);\n        axisIndices.add(axisIndex);\n        mapDatasetToDomainAxes(index, axisIndices);\n    }\n\n    /**\n     * Maps the specified dataset to the axes in the list.  Note that the\n     * conversion of data values into Java2D space is always performed using\n     * the first axis in the list.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndices  the axis indices ({@code null} permitted).\n     */\n    public void mapDatasetToDomainAxes(int index, List\u003cInteger\u003e axisIndices) {\n        Args.requireNonNegative(index, \"index\");\n        checkAxisIndices(axisIndices);\n        this.datasetToDomainAxesMap.put(index, new ArrayList\u003c\u003e(axisIndices));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    /**\n     * Maps a dataset to a particular range axis.  All data will be plotted\n     * against axis zero by default, no mapping is required for this case.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index.\n     *\n     * @see #mapDatasetToDomainAxis(int, int)\n     */\n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        List\u003cInteger\u003e axisIndices \u003d new ArrayList\u003c\u003e(1);\n        axisIndices.add(axisIndex);\n        mapDatasetToRangeAxes(index, axisIndices);\n    }\n\n    /**\n     * Maps the specified dataset to the axes in the list.  Note that the\n     * conversion of data values into Java2D space is always performed using\n     * the first axis in the list.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndices  the axis indices ({@code null} permitted).\n     */\n    public void mapDatasetToRangeAxes(int index, List\u003cInteger\u003e axisIndices) {\n        Args.requireNonNegative(index, \"index\");\n        checkAxisIndices(axisIndices);\n        this.datasetToRangeAxesMap.put(index, new ArrayList\u003c\u003e(axisIndices));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    /**\n     * This method is used to perform argument checking on the list of\n     * axis indices passed to mapDatasetToDomainAxes() and\n     * mapDatasetToRangeAxes().\n     *\n     * @param indices  the list of indices ({@code null} permitted).\n     */\n    private void checkAxisIndices(List\u003cInteger\u003e indices) {\n        // axisIndices can be:\n        // 1.  null;\n        // 2.  non-empty, containing only Integer objects that are unique.\n        if (indices \u003d\u003d null) {\n            return;  // OK\n        }\n        int count \u003d indices.size();\n        if (count \u003d\u003d 0) {\n            throw new IllegalArgumentException(\"Empty list not permitted.\");\n        }\n        Set\u003cInteger\u003e set \u003d new HashSet\u003c\u003e();\n        for (Integer item : indices) {\n            if (set.contains(item)) {\n                throw new IllegalArgumentException(\"Indices must be unique.\");\n            }\n            set.add(item);\n        }\n    }\n\n    /**\n     * Returns the number of renderer slots for this plot.\n     *\n     * @return The number of renderer slots.\n     */\n    public int getRendererCount() {\n        return this.renderers.size();\n    }\n\n    /**\n     * Returns the renderer for the primary dataset.\n     *\n     * @return The item renderer (possibly {@code null}).\n     *\n     * @see #setRenderer(XYItemRenderer)\n     */\n    public XYItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    /**\n     * Returns the renderer with the specified index, or {@code null}.\n     *\n     * @param index  the renderer index (must be \u0026gt;\u003d 0).\n     *\n     * @return The renderer (possibly {@code null}).\n     *\n     * @see #setRenderer(int, XYItemRenderer)\n     */\n    public XYItemRenderer getRenderer(int index) {\n        return this.renderers.get(index);\n    }\n\n    /**\n     * Returns a map containing the renderers that are assigned to this plot.\n     * The map is unmodifiable.\n     * \n     * @return A map containing the renderers that are assigned to the plot \n     *     (never {@code null}).\n     * \n     * @since 1.5.4\n     */\n    public Map\u003cInteger, XYItemRenderer\u003e getRenderers() {\n        return Collections.unmodifiableMap(this.renderers);\n    }\n\n    /**\n     * Sets the renderer for the primary dataset and sends a change event to \n     * all registered listeners.  If the renderer is set to {@code null}, \n     * no data will be displayed.\n     *\n     * @param renderer  the renderer ({@code null} permitted).\n     *\n     * @see #getRenderer()\n     */\n    public void setRenderer(XYItemRenderer renderer) {\n        setRenderer(0, renderer);\n    }\n\n    /**\n     * Sets the renderer for the dataset with the specified index and sends a \n     * change event to all registered listeners.  Note that each dataset should \n     * have its own renderer, you should not use one renderer for multiple \n     * datasets.\n     *\n     * @param index  the index (must be \u0026gt;\u003d 0).\n     * @param renderer  the renderer.\n     *\n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, XYItemRenderer renderer) {\n        setRenderer(index, renderer, true);\n    }\n\n    /**\n     * Sets the renderer for the dataset with the specified index and, if \n     * requested, sends a change event to all registered listeners.  Note that \n     * each dataset should have its own renderer, you should not use one \n     * renderer for multiple datasets.\n     *\n     * @param index  the index (must be \u0026gt;\u003d 0).\n     * @param renderer  the renderer.\n     * @param notify  notify listeners?\n     *\n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, XYItemRenderer renderer, \n            boolean notify) {\n        XYItemRenderer existing \u003d getRenderer(index);\n        if (existing !\u003d null) {\n            existing.removeChangeListener(this);\n        }\n        this.renderers.put(index, renderer);\n        if (renderer !\u003d null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        configureDomainAxes();\n        configureRangeAxes();\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the renderers for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param renderers  the renderers ({@code null} not permitted).\n     */\n    public void setRenderers(XYItemRenderer[] renderers) {\n        for (int i \u003d 0; i \u003c renderers.length; i++) {\n            setRenderer(i, renderers[i], false);\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the dataset rendering order.\n     *\n     * @return The order (never {@code null}).\n     *\n     * @see #setDatasetRenderingOrder(DatasetRenderingOrder)\n     */\n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.datasetRenderingOrder;\n    }\n\n    /**\n     * Sets the rendering order and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  By default, the plot renders the primary dataset\n     * last (so that the primary dataset overlays the secondary datasets).\n     * You can reverse this if you want to.\n     *\n     * @param order  the rendering order ({@code null} not permitted).\n     *\n     * @see #getDatasetRenderingOrder()\n     */\n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        Args.nullNotPermitted(order, \"order\");\n        this.datasetRenderingOrder \u003d order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the series rendering order.\n     *\n     * @return the order (never {@code null}).\n     *\n     * @see #setSeriesRenderingOrder(SeriesRenderingOrder)\n     */\n    public SeriesRenderingOrder getSeriesRenderingOrder() {\n        return this.seriesRenderingOrder;\n    }\n\n    /**\n     * Sets the series order and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  By default, the plot renders the primary series\n     * last (so that the primary series appears to be on top).\n     * You can reverse this if you want to.\n     *\n     * @param order  the rendering order ({@code null} not permitted).\n     *\n     * @see #getSeriesRenderingOrder()\n     */\n    public void setSeriesRenderingOrder(SeriesRenderingOrder order) {\n        Args.nullNotPermitted(order, \"order\");\n        this.seriesRenderingOrder \u003d order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the index of the specified renderer, or {@code -1} if the\n     * renderer is not assigned to this plot.\n     *\n     * @param renderer  the renderer ({@code null} permitted).\n     *\n     * @return The renderer index.\n     */\n    public int getIndexOf(XYItemRenderer renderer) {\n        for (Map.Entry\u003cInteger, XYItemRenderer\u003e entry \n                : this.renderers.entrySet()) {\n            if (entry.getValue() \u003d\u003d renderer) {\n                return entry.getKey();\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the renderer for the specified dataset (this is either the\n     * renderer with the same index as the dataset or, if there isn\u0027t a \n     * renderer with the same index, the default renderer).  If the dataset\n     * does not belong to the plot, this method will return {@code null}.\n     *\n     * @param dataset  the dataset ({@code null} permitted).\n     *\n     * @return The renderer (possibly {@code null}).\n     */\n    public XYItemRenderer getRendererForDataset(XYDataset\u003cS\u003e dataset) {\n        int datasetIndex \u003d indexOf(dataset);\n        if (datasetIndex \u003c 0) {\n            return null;\n        } \n        XYItemRenderer result \u003d this.renderers.get(datasetIndex);\n        if (result \u003d\u003d null) {\n            result \u003d getRenderer();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the weight for this plot when it is used as a subplot within a\n     * combined plot.\n     *\n     * @return The weight.\n     *\n     * @see #setWeight(int)\n     */\n    public int getWeight() {\n        return this.weight;\n    }\n\n    /**\n     * Sets the weight for the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param weight  the weight.\n     *\n     * @see #getWeight()\n     */\n    public void setWeight(int weight) {\n        this.weight \u003d weight;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns {@code true} if the domain gridlines are visible, and\n     * {@code false} otherwise.\n     *\n     * @return {@code true} or {@code false}.\n     *\n     * @see #setDomainGridlinesVisible(boolean)\n     */\n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the domain grid-lines are\n     * visible.\n     * \u003cp\u003e\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     *\n     * @see #isDomainGridlinesVisible()\n     */\n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible !\u003d visible) {\n            this.domainGridlinesVisible \u003d visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns {@code true} if the domain minor gridlines are visible, and\n     * {@code false} otherwise.\n     *\n     * @return {@code true} or {@code false}.\n     *\n     * @see #setDomainMinorGridlinesVisible(boolean)\n     */\n    public boolean isDomainMinorGridlinesVisible() {\n        return this.domainMinorGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the domain minor grid-lines\n     * are visible.\n     * \u003cp\u003e\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     *\n     * @see #isDomainMinorGridlinesVisible()\n     */\n    public void setDomainMinorGridlinesVisible(boolean visible) {\n        if (this.domainMinorGridlinesVisible !\u003d visible) {\n            this.domainMinorGridlinesVisible \u003d visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the grid-lines (if any) plotted against the\n     * domain axis.\n     *\n     * @return The stroke (never {@code null}).\n     *\n     * @see #setDomainGridlineStroke(Stroke)\n     */\n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the grid lines plotted against the domain axis, and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getDomainGridlineStroke()\n     */\n    public void setDomainGridlineStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.domainGridlineStroke \u003d stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke for the minor grid-lines (if any) plotted against the\n     * domain axis.\n     *\n     * @return The stroke (never {@code null}).\n     *\n     * @see #setDomainMinorGridlineStroke(Stroke)\n     */\n\n    public Stroke getDomainMinorGridlineStroke() {\n        return this.domainMinorGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the minor grid lines plotted against the domain\n     * axis, and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getDomainMinorGridlineStroke()\n     */\n    public void setDomainMinorGridlineStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.domainMinorGridlineStroke \u003d stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the grid lines (if any) plotted against the domain\n     * axis.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setDomainGridlinePaint(Paint)\n     */\n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the grid lines plotted against the domain axis, and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getDomainGridlinePaint()\n     */\n    public void setDomainGridlinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.domainGridlinePaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the minor grid lines (if any) plotted against the\n     * domain axis.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setDomainMinorGridlinePaint(Paint)\n     */\n    public Paint getDomainMinorGridlinePaint() {\n        return this.domainMinorGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the minor grid lines plotted against the domain axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getDomainMinorGridlinePaint()\n     */\n    public void setDomainMinorGridlinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.domainMinorGridlinePaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns {@code true} if the range axis grid is visible, and\n     * {@code false} otherwise.\n     *\n     * @return A boolean.\n     *\n     * @see #setRangeGridlinesVisible(boolean)\n     */\n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the range axis grid lines\n     * are visible.\n     * \u003cp\u003e\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     *\n     * @see #isRangeGridlinesVisible()\n     */\n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible !\u003d visible) {\n            this.rangeGridlinesVisible \u003d visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the grid lines (if any) plotted against the\n     * range axis.\n     *\n     * @return The stroke (never {@code null}).\n     *\n     * @see #setRangeGridlineStroke(Stroke)\n     */\n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the grid lines plotted against the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getRangeGridlineStroke()\n     */\n    public void setRangeGridlineStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.rangeGridlineStroke \u003d stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the grid lines (if any) plotted against the range\n     * axis.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setRangeGridlinePaint(Paint)\n     */\n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the grid lines plotted against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getRangeGridlinePaint()\n     */\n    public void setRangeGridlinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.rangeGridlinePaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns {@code true} if the range axis minor grid is visible, and\n     * {@code false} otherwise.\n     *\n     * @return A boolean.\n     *\n     * @see #setRangeMinorGridlinesVisible(boolean)\n     */\n    public boolean isRangeMinorGridlinesVisible() {\n        return this.rangeMinorGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the range axis minor grid\n     * lines are visible.\n     * \u003cp\u003e\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     *\n     * @see #isRangeMinorGridlinesVisible()\n     */\n    public void setRangeMinorGridlinesVisible(boolean visible) {\n        if (this.rangeMinorGridlinesVisible !\u003d visible) {\n            this.rangeMinorGridlinesVisible \u003d visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the minor grid lines (if any) plotted against the\n     * range axis.\n     *\n     * @return The stroke (never {@code null}).\n     *\n     * @see #setRangeMinorGridlineStroke(Stroke)\n     */\n    public Stroke getRangeMinorGridlineStroke() {\n        return this.rangeMinorGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the minor grid lines plotted against the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getRangeMinorGridlineStroke()\n     */\n    public void setRangeMinorGridlineStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.rangeMinorGridlineStroke \u003d stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the minor grid lines (if any) plotted against the\n     * range axis.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setRangeMinorGridlinePaint(Paint)\n     */\n    public Paint getRangeMinorGridlinePaint() {\n        return this.rangeMinorGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the minor grid lines plotted against the range axis\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getRangeMinorGridlinePaint()\n     */\n    public void setRangeMinorGridlinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.rangeMinorGridlinePaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag that controls whether or not a zero baseline is\n     * displayed for the domain axis.\n     *\n     * @return A boolean.\n     *\n     * @see #setDomainZeroBaselineVisible(boolean)\n     */\n    public boolean isDomainZeroBaselineVisible() {\n        return this.domainZeroBaselineVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the zero baseline is\n     * displayed for the domain axis, and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param visible  the flag.\n     *\n     * @see #isDomainZeroBaselineVisible()\n     */\n    public void setDomainZeroBaselineVisible(boolean visible) {\n        this.domainZeroBaselineVisible \u003d visible;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used for the zero baseline against the domain axis.\n     *\n     * @return The stroke (never {@code null}).\n     *\n     * @see #setDomainZeroBaselineStroke(Stroke)\n     */\n    public Stroke getDomainZeroBaselineStroke() {\n        return this.domainZeroBaselineStroke;\n    }\n\n    /**\n     * Sets the stroke for the zero baseline for the domain axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getRangeZeroBaselineStroke()\n     */\n    public void setDomainZeroBaselineStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.domainZeroBaselineStroke \u003d stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the zero baseline (if any) plotted against the\n     * domain axis.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setDomainZeroBaselinePaint(Paint)\n     */\n    public Paint getDomainZeroBaselinePaint() {\n        return this.domainZeroBaselinePaint;\n    }\n\n    /**\n     * Sets the paint for the zero baseline plotted against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getDomainZeroBaselinePaint()\n     */\n    public void setDomainZeroBaselinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.domainZeroBaselinePaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag that controls whether or not a zero baseline is\n     * displayed for the range axis.\n     *\n     * @return A boolean.\n     *\n     * @see #setRangeZeroBaselineVisible(boolean)\n     */\n    public boolean isRangeZeroBaselineVisible() {\n        return this.rangeZeroBaselineVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the zero baseline is\n     * displayed for the range axis, and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param visible  the flag.\n     *\n     * @see #isRangeZeroBaselineVisible()\n     */\n    public void setRangeZeroBaselineVisible(boolean visible) {\n        this.rangeZeroBaselineVisible \u003d visible;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used for the zero baseline against the range axis.\n     *\n     * @return The stroke (never {@code null}).\n     *\n     * @see #setRangeZeroBaselineStroke(Stroke)\n     */\n    public Stroke getRangeZeroBaselineStroke() {\n        return this.rangeZeroBaselineStroke;\n    }\n\n    /**\n     * Sets the stroke for the zero baseline for the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     *\n     * @see #getRangeZeroBaselineStroke()\n     */\n    public void setRangeZeroBaselineStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.rangeZeroBaselineStroke \u003d stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the zero baseline (if any) plotted against the\n     * range axis.\n     *\n     * @return The paint (never {@code null}).\n     *\n     * @see #setRangeZeroBaselinePaint(Paint)\n     */\n    public Paint getRangeZeroBaselinePaint() {\n        return this.rangeZeroBaselinePaint;\n    }\n\n    /**\n     * Sets the paint for the zero baseline plotted against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     *\n     * @see #getRangeZeroBaselinePaint()\n     */\n    public void setRangeZeroBaselinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.rangeZeroBaselinePaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the domain tick bands.  If this is\n     * {@code null}, no tick bands will be drawn.\n     *\n     * @return The paint (possibly {@code null}).\n     *\n     * @see #setDomainTickBandPaint(Paint)\n     */\n    public Paint getDomainTickBandPaint() {\n        return this.domainTickBandPaint;\n    }\n\n    /**\n     * Sets the paint for the domain tick bands.\n     *\n     * @param paint  the paint ({@code null} permitted).\n     *\n     * @see #getDomainTickBandPaint()\n     */\n    public void setDomainTickBandPaint(Paint paint) {\n        this.domainTickBandPaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the range tick bands.  If this is\n     * {@code null}, no tick bands will be drawn.\n     *\n     * @return The paint (possibly {@code null}).\n     *\n     * @see #setRangeTickBandPaint(Paint)\n     */\n    public Paint getRangeTickBandPaint() {\n        return this.rangeTickBandPaint;\n    }\n\n    /**\n     * Sets the paint for the range tick bands.\n     *\n     * @param paint  the paint ({@code null} permitted).\n     *\n     * @see #getRangeTickBandPaint()\n     */\n    public void setRangeTickBandPaint(Paint paint) {\n        this.rangeTickBandPaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the origin for the quadrants that can be displayed on the plot.\n     * This defaults to (0, 0).\n     *\n     * @return The origin point (never {@code null}).\n     *\n     * @see #setQuadrantOrigin(Point2D)\n     */\n    public Point2D getQuadrantOrigin() {\n        return this.quadrantOrigin;\n    }\n\n    /**\n     * Sets the quadrant origin and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param origin  the origin ({@code null} not permitted).\n     *\n     * @see #getQuadrantOrigin()\n     */\n    public void setQuadrantOrigin(Point2D origin) {\n        Args.nullNotPermitted(origin, \"origin\");\n        this.quadrantOrigin \u003d origin;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the specified quadrant.\n     *\n     * @param index  the quadrant index (0-3).\n     *\n     * @return The paint (possibly {@code null}).\n     *\n     * @see #setQuadrantPaint(int, Paint)\n     */\n    public Paint getQuadrantPaint(int index) {\n        if (index \u003c 0 || index \u003e 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index\n                    + \") should be in the range 0 to 3.\");\n        }\n        return this.quadrantPaint[index];\n    }\n\n    /**\n     * Sets the paint used for the specified quadrant and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the quadrant index (0-3).\n     * @param paint  the paint ({@code null} permitted).\n     *\n     * @see #getQuadrantPaint(int)\n     */\n    public void setQuadrantPaint(int index, Paint paint) {\n        if (index \u003c 0 || index \u003e 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index\n                    + \") should be in the range 0 to 3.\");\n        }\n        this.quadrantPaint[index] \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \u003cP\u003e\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the domain axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker ({@code null} not permitted).\n     *\n     * @see #addDomainMarker(Marker, Layer)\n     * @see #clearDomainMarkers()\n     */\n    public void addDomainMarker(Marker marker) {\n        // defer argument checking...\n        addDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \u003cP\u003e\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the domain axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker ({@code null} not permitted).\n     * @param layer  the layer (foreground or background).\n     *\n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(Marker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Clears all the (foreground and background) domain markers and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers !\u003d null) {\n            Set\u003cInteger\u003e keys \u003d this.backgroundDomainMarkers.keySet();\n            for (Integer key : keys) {\n                clearDomainMarkers(key);\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers !\u003d null) {\n            Set\u003cInteger\u003e keys \u003d this.foregroundDomainMarkers.keySet();\n            for (Integer key : keys) {\n                clearDomainMarkers(key);\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Clears the (foreground and background) domain markers for a particular\n     * renderer and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the renderer index.\n     *\n     * @see #clearRangeMarkers(int)\n     */\n    public void clearDomainMarkers(int index) {\n        if (this.backgroundDomainMarkers !\u003d null) {\n            List\u003cMarker\u003e markers \u003d this.backgroundDomainMarkers.get(index);\n            if (markers !\u003d null) {\n                for (Marker m : markers) {\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers !\u003d null) {\n            List\u003cMarker\u003e markers \u003d this.foregroundDomainMarkers.get(index);\n            if (markers !\u003d null) {\n                for (Marker m : markers) {\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \u003cP\u003e\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the domain axis (that the renderer is mapped to), however this is\n     * entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     *\n     * @see #clearDomainMarkers(int)\n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(int index, Marker marker, Layer layer) {\n        addDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \u003cP\u003e\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the domain axis (that the renderer is mapped to), however this is\n     * entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     */\n    public void addDomainMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        Args.nullNotPermitted(marker, \"marker\");\n        Args.nullNotPermitted(layer, \"layer\");\n        List\u003cMarker\u003e markers;\n        if (layer \u003d\u003d Layer.FOREGROUND) {\n            markers \u003d this.foregroundDomainMarkers.get(index);\n            if (markers \u003d\u003d null) {\n                markers \u003d new ArrayList\u003c\u003e();\n                this.foregroundDomainMarkers.put(index, markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer \u003d\u003d Layer.BACKGROUND) {\n            markers \u003d this.backgroundDomainMarkers.get(index);\n            if (markers \u003d\u003d null) {\n                markers \u003d new ArrayList\u003c\u003e();\n                this.backgroundDomainMarkers.put(index, markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes a marker for the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param marker  the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     */\n    public boolean removeDomainMarker(Marker marker) {\n        return removeDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker ({@code null} not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     */\n    public boolean removeDomainMarker(Marker marker, Layer layer) {\n        return removeDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n        return removeDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and, if requested,\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        List\u003cMarker\u003e markers;\n        if (layer \u003d\u003d Layer.FOREGROUND) {\n            markers \u003d this.foregroundDomainMarkers.get(index);\n        } else {\n            markers \u003d this.backgroundDomainMarkers.get(index);\n        }\n        if (markers \u003d\u003d null) {\n            return false;\n        }\n        boolean removed \u003d markers.remove(marker);\n        if (removed \u0026\u0026 notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Adds a marker for the range axis and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     * \u003cP\u003e\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker ({@code null} not permitted).\n     *\n     * @see #addRangeMarker(Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \u003cP\u003e\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker ({@code null} not permitted).\n     * @param layer  the layer (foreground or background).\n     *\n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Clears all the range markers and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @see #clearRangeMarkers()\n     */\n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers !\u003d null) {\n            Set\u003cInteger\u003e keys \u003d this.backgroundRangeMarkers.keySet();\n            for (Integer key : keys) {\n                clearRangeMarkers(key);\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers !\u003d null) {\n            Set\u003cInteger\u003e keys \u003d this.foregroundRangeMarkers.keySet();\n            for (Integer key : keys) {\n                clearRangeMarkers(key);\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \u003cP\u003e\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     *\n     * @see #clearRangeMarkers(int)\n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n        addRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \u003cP\u003e\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        List\u003cMarker\u003e markers;\n        if (layer \u003d\u003d Layer.FOREGROUND) {\n            markers \u003d this.foregroundRangeMarkers.get(index);\n            if (markers \u003d\u003d null) {\n                markers \u003d new ArrayList\u003c\u003e();\n                this.foregroundRangeMarkers.put(index, markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer \u003d\u003d Layer.BACKGROUND) {\n            markers \u003d this.backgroundRangeMarkers.get(index);\n            if (markers \u003d\u003d null) {\n                markers \u003d new ArrayList\u003c\u003e();\n                this.backgroundRangeMarkers.put(index, markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears the (foreground and background) range markers for a particular\n     * renderer.\n     *\n     * @param index  the renderer index.\n     */\n    public void clearRangeMarkers(int index) {\n        if (this.backgroundRangeMarkers !\u003d null) {\n            List\u003cMarker\u003e markers \u003d this.backgroundRangeMarkers.get(index);\n            if (markers !\u003d null) {\n                for (Marker m : markers) {\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers !\u003d null) {\n            List\u003cMarker\u003e markers \u003d this.foregroundRangeMarkers.get(index);\n            if (markers !\u003d null) {\n                for (Marker m : markers) {\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Removes a marker for the range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param marker the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     */\n    public boolean removeRangeMarker(Marker marker) {\n        return removeRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker ({@code null} not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     */\n    public boolean removeRangeMarker(Marker marker, Layer layer) {\n        return removeRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker ({@code null} not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n        return removeRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker ({@code null} not permitted).\n     * @param layer  the layer (foreground or background) ({@code null} not permitted).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean indicating whether or not the marker was actually\n     *         removed.\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n            boolean notify) {\n        Args.nullNotPermitted(marker, \"marker\");\n        Args.nullNotPermitted(layer, \"layer\");\n        List\u003cMarker\u003e markers;\n        if (layer \u003d\u003d Layer.FOREGROUND) {\n            markers \u003d this.foregroundRangeMarkers.get(index);\n        } else {\n            markers \u003d this.backgroundRangeMarkers.get(index);\n        }\n        if (markers \u003d\u003d null) {\n            return false;\n        }\n        boolean removed \u003d markers.remove(marker);\n        if (removed \u0026\u0026 notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Adds an annotation to the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param annotation  the annotation ({@code null} not permitted).\n     *\n     * @see #getAnnotations()\n     * @see #removeAnnotation(XYAnnotation)\n     */\n    public void addAnnotation(XYAnnotation annotation) {\n        addAnnotation(annotation, true);\n    }\n\n    /**\n     * Adds an annotation to the plot and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation ({@code null} not permitted).\n     * @param notify  notify listeners?\n     */\n    public void addAnnotation(XYAnnotation annotation, boolean notify) {\n        Args.nullNotPermitted(annotation, \"annotation\");\n        this.annotations.add(annotation);\n        annotation.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation ({@code null} not permitted).\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     *\n     * @see #addAnnotation(XYAnnotation)\n     * @see #getAnnotations()\n     */\n    public boolean removeAnnotation(XYAnnotation annotation) {\n        return removeAnnotation(annotation, true);\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation ({@code null} not permitted).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     */\n    public boolean removeAnnotation(XYAnnotation annotation, boolean notify) {\n        Args.nullNotPermitted(annotation, \"annotation\");\n        boolean removed \u003d this.annotations.remove(annotation);\n        annotation.removeChangeListener(this);\n        if (removed \u0026\u0026 notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Returns the list of annotations.\n     *\n     * @return The list of annotations.\n     *\n     * @see #addAnnotation(XYAnnotation)\n     */\n    public List\u003cXYAnnotation\u003e getAnnotations() {\n        return new ArrayList\u003c\u003e(this.annotations);\n    }\n\n    /**\n     * Clears all the annotations and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @see #addAnnotation(XYAnnotation)\n     */\n    public void clearAnnotations() {\n        for (XYAnnotation annotation : this.annotations) {\n            annotation.removeChangeListener(this);\n        }\n        this.annotations.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the shadow generator for the plot, if any.\n     *\n     * @return The shadow generator (possibly {@code null}).\n     */\n    public ShadowGenerator getShadowGenerator() {\n        return this.shadowGenerator;\n    }\n\n    /**\n     * Sets the shadow generator for the plot and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param generator  the generator ({@code null} permitted).\n     */\n    public void setShadowGenerator(ShadowGenerator generator) {\n        this.shadowGenerator \u003d generator;\n        fireChangeEvent();\n    }\n\n    /**\n     * Calculates the space required for all the axes in the plot.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateAxisSpace(Graphics2D g2,\n                                           Rectangle2D plotArea) {\n        AxisSpace space \u003d new AxisSpace();\n        space \u003d calculateRangeAxisSpace(g2, plotArea, space);\n        Rectangle2D revPlotArea \u003d space.shrink(plotArea, null);\n        space \u003d calculateDomainAxisSpace(g2, revPlotArea, space);\n        return space;\n    }\n\n    /**\n     * Calculates the space required for the domain axis/axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result ({@code null} permitted).\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, \n            Rectangle2D plotArea, AxisSpace space) {\n\n        if (space \u003d\u003d null) {\n            space \u003d new AxisSpace();\n        }\n\n        // reserve some space for the domain axis...\n        if (this.fixedDomainAxisSpace !\u003d null) {\n            if (this.orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getLeft(),\n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(),\n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation \u003d\u003d PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(),\n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(),\n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            // reserve space for the domain axes...\n            for (ValueAxis axis: this.domainAxes.values()) {\n                if (axis !\u003d null) {\n                    RectangleEdge edge \u003d getDomainAxisEdge(\n                            findDomainAxisIndex(axis));\n                    space \u003d axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n\n    }\n\n    /**\n     * Calculates the space required for the range axis/axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result ({@code null} permitted).\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, \n            Rectangle2D plotArea, AxisSpace space) {\n\n        if (space \u003d\u003d null) {\n            space \u003d new AxisSpace();\n        }\n\n        // reserve some space for the range axis...\n        if (this.fixedRangeAxisSpace !\u003d null) {\n            if (this.orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(),\n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(),\n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation \u003d\u003d PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(),\n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(),\n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            // reserve space for the range axes...\n            for (ValueAxis axis: this.rangeAxes.values()) {\n                if (axis !\u003d null) {\n                    RectangleEdge edge \u003d getRangeAxisEdge(\n                            findRangeAxisIndex(axis));\n                    space \u003d axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n\n    }\n\n    /**\n     * Trims a rectangle to integer coordinates.\n     *\n     * @param rect  the incoming rectangle.\n     *\n     * @return A rectangle with integer coordinates.\n     */\n    private Rectangle integerise(Rectangle2D rect) {\n        int x0 \u003d (int) Math.ceil(rect.getMinX());\n        int y0 \u003d (int) Math.ceil(rect.getMinY());\n        int x1 \u003d (int) Math.floor(rect.getMaxX());\n        int y1 \u003d (int) Math.floor(rect.getMaxY());\n        return new Rectangle(x0, y0, (x1 - x0), (y1 - y0));\n    }\n\n    /**\n     * Receives a chart element visitor.  Many plot subclasses will override\n     * this method to handle their subcomponents.\n     * \n     * @param visitor  the visitor ({@code null} not permitted).\n     */\n    @Override\n    public void receive(ChartElementVisitor visitor) {\n        for (Entry\u003cInteger, ValueAxis\u003e entry : this.domainAxes.entrySet()) {\n            if (entry.getValue() !\u003d null) {\n                entry.getValue().receive(visitor);\n            }\n        }\n        for (Entry\u003cInteger, ValueAxis\u003e entry : this.rangeAxes.entrySet()) {\n            if (entry.getValue() !\u003d null) {\n                entry.getValue().receive(visitor);\n            }\n        }\n        // visit the renderers\n        for (Entry\u003cInteger, XYItemRenderer\u003e entry : this.renderers.entrySet()) {\n            if (entry.getValue() !\u003d null) {\n                entry.getValue().receive(visitor);\n            }            \n        }\n\n        visitor.visit(this);\n    }\n\n    /**\n     * Draws the plot within the specified area on a graphics device.\n     *\n     * @param g2  the graphics device.\n     * @param area  the plot area (in Java2D space).\n     * @param anchor  an anchor point in Java2D space ({@code null}\n     *                permitted).\n     * @param parentState  the state from the parent plot, if there is one\n     *                     ({@code null} permitted).\n     * @param info  collects chart drawing information ({@code null}\n     *              permitted).\n     */\n    @Override\n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n            PlotState parentState, PlotRenderingInfo info) {\n\n        // if the plot area is too small, just return...\n        boolean b1 \u003d (area.getWidth() \u003c\u003d MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 \u003d (area.getHeight() \u003c\u003d MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        // record the plot area...\n        if (info !\u003d null) {\n            info.setPlotArea(area);\n        }\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets \u003d getInsets();\n        insets.trim(area);\n\n        AxisSpace space \u003d calculateAxisSpace(g2, area);\n        Rectangle2D dataArea \u003d space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        dataArea \u003d integerise(dataArea);\n        if (dataArea.isEmpty()) {\n            return;\n        }\n        createAndAddEntity((Rectangle2D) dataArea.clone(), info, null, null);\n        if (info !\u003d null) {\n            info.setDataArea(dataArea);\n        }\n\n        // draw the plot background and axes...\n        drawBackground(g2, dataArea);\n        Map\u003cAxis, AxisState\u003e axisStateMap \u003d drawAxes(g2, area, dataArea, info);\n\n        PlotOrientation orient \u003d getOrientation();\n\n        // the anchor point is typically the point where the mouse last\n        // clicked - the crosshairs will be driven off this point...\n        if (anchor !\u003d null \u0026\u0026 !dataArea.contains(anchor)) {\n            anchor \u003d null;\n        }\n        CrosshairState crosshairState \u003d new CrosshairState();\n        crosshairState.setCrosshairDistance(Double.POSITIVE_INFINITY);\n        crosshairState.setAnchor(anchor);\n\n        crosshairState.setAnchorX(Double.NaN);\n        crosshairState.setAnchorY(Double.NaN);\n        if (anchor !\u003d null) {\n            ValueAxis domainAxis \u003d getDomainAxis();\n            if (domainAxis !\u003d null) {\n                double x;\n                if (orient \u003d\u003d PlotOrientation.VERTICAL) {\n                    x \u003d domainAxis.java2DToValue(anchor.getX(), dataArea,\n                            getDomainAxisEdge());\n                }\n                else {\n                    x \u003d domainAxis.java2DToValue(anchor.getY(), dataArea,\n                            getDomainAxisEdge());\n                }\n                crosshairState.setAnchorX(x);\n            }\n            ValueAxis rangeAxis \u003d getRangeAxis();\n            if (rangeAxis !\u003d null) {\n                double y;\n                if (orient \u003d\u003d PlotOrientation.VERTICAL) {\n                    y \u003d rangeAxis.java2DToValue(anchor.getY(), dataArea,\n                            getRangeAxisEdge());\n                }\n                else {\n                    y \u003d rangeAxis.java2DToValue(anchor.getX(), dataArea,\n                            getRangeAxisEdge());\n                }\n                crosshairState.setAnchorY(y);\n            }\n        }\n        crosshairState.setCrosshairX(getDomainCrosshairValue());\n        crosshairState.setCrosshairY(getRangeCrosshairValue());\n        Shape originalClip \u003d g2.getClip();\n        Composite originalComposite \u003d g2.getComposite();\n\n        g2.clip(dataArea);\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                getForegroundAlpha()));\n\n        AxisState domainAxisState \u003d axisStateMap.get(getDomainAxis());\n        if (domainAxisState \u003d\u003d null) {\n            if (parentState !\u003d null) {\n                domainAxisState \u003d parentState.getSharedAxisStates()\n                        .get(getDomainAxis());\n            }\n        }\n\n        AxisState rangeAxisState \u003d axisStateMap.get(getRangeAxis());\n        if (rangeAxisState \u003d\u003d null) {\n            if (parentState !\u003d null) {\n                rangeAxisState \u003d parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (domainAxisState !\u003d null) {\n            drawDomainTickBands(g2, dataArea, domainAxisState.getTicks());\n        }\n        if (rangeAxisState !\u003d null) {\n            drawRangeTickBands(g2, dataArea, rangeAxisState.getTicks());\n        }\n        if (domainAxisState !\u003d null) {\n            drawDomainGridlines(g2, dataArea, domainAxisState.getTicks());\n            drawZeroDomainBaseline(g2, dataArea);\n        }\n        if (rangeAxisState !\u003d null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n            drawZeroRangeBaseline(g2, dataArea);\n        }\n\n        Graphics2D savedG2 \u003d g2;\n        BufferedImage dataImage \u003d null;\n        boolean suppressShadow \u003d Boolean.TRUE.equals(g2.getRenderingHint(\n                JFreeChart.KEY_SUPPRESS_SHADOW_GENERATION));\n        if (this.shadowGenerator !\u003d null \u0026\u0026 !suppressShadow) {\n            dataImage \u003d new BufferedImage((int) dataArea.getWidth(),\n                    (int)dataArea.getHeight(), BufferedImage.TYPE_INT_ARGB);\n            g2 \u003d dataImage.createGraphics();\n            g2.translate(-dataArea.getX(), -dataArea.getY());\n            g2.setRenderingHints(savedG2.getRenderingHints());\n        }\n\n        // draw the markers that are associated with a specific dataset...\n        for (XYDataset\u003cS\u003e dataset: this.datasets.values()) {\n            int datasetIndex \u003d indexOf(dataset);\n            drawDomainMarkers(g2, dataArea, datasetIndex, Layer.BACKGROUND);\n        }\n        for (XYDataset\u003cS\u003e dataset: this.datasets.values()) {\n            int datasetIndex \u003d indexOf(dataset);\n            drawRangeMarkers(g2, dataArea, datasetIndex, Layer.BACKGROUND);\n        }\n\n        // now draw annotations and render data items...\n        boolean foundData \u003d false;\n        DatasetRenderingOrder order \u003d getDatasetRenderingOrder();\n        List\u003cInteger\u003e rendererIndices \u003d getRendererIndices(order);\n        List\u003cInteger\u003e datasetIndices \u003d getDatasetIndices(order);\n\n        // draw background annotations\n        for (int i : rendererIndices) {\n            XYItemRenderer renderer \u003d getRenderer(i);\n            if (renderer !\u003d null) {\n                ValueAxis domainAxis \u003d getDomainAxisForDataset(i);\n                ValueAxis rangeAxis \u003d getRangeAxisForDataset(i);\n                renderer.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, \n                        Layer.BACKGROUND, info);\n            }\n        }\n\n        // render data items...\n        for (int datasetIndex : datasetIndices) {\n            foundData \u003d render(g2, dataArea, datasetIndex, info, \n                    crosshairState) || foundData;\n        }\n\n        // draw foreground annotations\n        for (int i : rendererIndices) {\n            XYItemRenderer renderer \u003d getRenderer(i);\n            if (renderer !\u003d null) {\n                    ValueAxis domainAxis \u003d getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis \u003d getRangeAxisForDataset(i);\n                renderer.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, \n                            Layer.FOREGROUND, info);\n            }\n        }\n\n        // draw domain crosshair if required...\n        int datasetIndex \u003d crosshairState.getDatasetIndex();\n        ValueAxis xAxis \u003d getDomainAxisForDataset(datasetIndex);\n        RectangleEdge xAxisEdge \u003d getDomainAxisEdge(getDomainAxisIndex(xAxis));\n        if (!this.domainCrosshairLockedOnData \u0026\u0026 anchor !\u003d null) {\n            double xx;\n            if (orient \u003d\u003d PlotOrientation.VERTICAL) {\n                xx \u003d xAxis.java2DToValue(anchor.getX(), dataArea, xAxisEdge);\n            }\n            else {\n                xx \u003d xAxis.java2DToValue(anchor.getY(), dataArea, xAxisEdge);\n            }\n            crosshairState.setCrosshairX(xx);\n        }\n        setDomainCrosshairValue(crosshairState.getCrosshairX(), false);\n        if (isDomainCrosshairVisible()) {\n            double x \u003d getDomainCrosshairValue();\n            Paint paint \u003d getDomainCrosshairPaint();\n            Stroke stroke \u003d getDomainCrosshairStroke();\n            drawDomainCrosshair(g2, dataArea, orient, x, xAxis, stroke, paint);\n        }\n\n        // draw range crosshair if required...\n        ValueAxis yAxis \u003d getRangeAxisForDataset(datasetIndex);\n        RectangleEdge yAxisEdge \u003d getRangeAxisEdge(getRangeAxisIndex(yAxis));\n        if (!this.rangeCrosshairLockedOnData \u0026\u0026 anchor !\u003d null) {\n            double yy;\n            if (orient \u003d\u003d PlotOrientation.VERTICAL) {\n                yy \u003d yAxis.java2DToValue(anchor.getY(), dataArea, yAxisEdge);\n            } else {\n                yy \u003d yAxis.java2DToValue(anchor.getX(), dataArea, yAxisEdge);\n            }\n            crosshairState.setCrosshairY(yy);\n        }\n        setRangeCrosshairValue(crosshairState.getCrosshairY(), false);\n        if (isRangeCrosshairVisible()) {\n            double y \u003d getRangeCrosshairValue();\n            Paint paint \u003d getRangeCrosshairPaint();\n            Stroke stroke \u003d getRangeCrosshairStroke();\n            drawRangeCrosshair(g2, dataArea, orient, y, yAxis, stroke, paint);\n        }\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        for (int i : rendererIndices) { \n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i : rendererIndices) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        drawAnnotations(g2, dataArea, info);\n        if (this.shadowGenerator !\u003d null \u0026\u0026 !suppressShadow) {\n            BufferedImage shadowImage\n                    \u003d this.shadowGenerator.createDropShadow(dataImage);\n            g2 \u003d savedG2;\n            g2.drawImage(shadowImage, (int) dataArea.getX()\n                    + this.shadowGenerator.calculateOffsetX(),\n                    (int) dataArea.getY()\n                    + this.shadowGenerator.calculateOffsetY(), null);\n            g2.drawImage(dataImage, (int) dataArea.getX(),\n                    (int) dataArea.getY(), null);\n        }\n        g2.setClip(originalClip);\n        g2.setComposite(originalComposite);\n\n        drawOutline(g2, dataArea);\n\n    }\n\n    /**\n     * Returns the indices of the non-null datasets in the specified order.\n     * \n     * @param order  the order ({@code null} not permitted).\n     * \n     * @return The list of indices. \n     */\n    private List\u003cInteger\u003e getDatasetIndices(DatasetRenderingOrder order) {\n        List\u003cInteger\u003e result \u003d new ArrayList\u003c\u003e();\n        for (Entry\u003cInteger, XYDataset\u003cS\u003e\u003e entry : this.datasets.entrySet()) {\n            if (entry.getValue() !\u003d null) {\n                result.add(entry.getKey());\n            }\n        }\n        Collections.sort(result);\n        if (order \u003d\u003d DatasetRenderingOrder.REVERSE) {\n            Collections.reverse(result);\n        }\n        return result;\n    }\n    \n    private List\u003cInteger\u003e getRendererIndices(DatasetRenderingOrder order) {\n        List\u003cInteger\u003e result \u003d new ArrayList\u003c\u003e();\n        for (Entry\u003cInteger, XYItemRenderer\u003e entry : this.renderers.entrySet()) {\n            if (entry.getValue() !\u003d null) {\n                result.add(entry.getKey());\n            }\n        }\n        Collections.sort(result);\n        if (order \u003d\u003d DatasetRenderingOrder.REVERSE) {\n            Collections.reverse(result);\n        }\n        return result;        \n    }\n    \n    /**\n     * Draws the background for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     */\n    @Override\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawQuadrants(g2, area);\n        drawBackgroundImage(g2, area);\n    }\n\n    /**\n     * Draws the quadrants.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     *\n     * @see #setQuadrantOrigin(Point2D)\n     * @see #setQuadrantPaint(int, Paint)\n     */\n    protected void drawQuadrants(Graphics2D g2, Rectangle2D area) {\n        //  0 | 1\n        //  --+--\n        //  2 | 3\n        boolean somethingToDraw \u003d false;\n\n        ValueAxis xAxis \u003d getDomainAxis();\n        if (xAxis \u003d\u003d null) {  // we can\u0027t draw quadrants without a valid x-axis\n            return;\n        }\n        double x \u003d xAxis.getRange().constrain(this.quadrantOrigin.getX());\n        double xx \u003d xAxis.valueToJava2D(x, area, getDomainAxisEdge());\n\n        ValueAxis yAxis \u003d getRangeAxis();\n        if (yAxis \u003d\u003d null) {  // we can\u0027t draw quadrants without a valid y-axis\n            return;\n        }\n        double y \u003d yAxis.getRange().constrain(this.quadrantOrigin.getY());\n        double yy \u003d yAxis.valueToJava2D(y, area, getRangeAxisEdge());\n\n        double xmin \u003d xAxis.getLowerBound();\n        double xxmin \u003d xAxis.valueToJava2D(xmin, area, getDomainAxisEdge());\n\n        double xmax \u003d xAxis.getUpperBound();\n        double xxmax \u003d xAxis.valueToJava2D(xmax, area, getDomainAxisEdge());\n\n        double ymin \u003d yAxis.getLowerBound();\n        double yymin \u003d yAxis.valueToJava2D(ymin, area, getRangeAxisEdge());\n\n        double ymax \u003d yAxis.getUpperBound();\n        double yymax \u003d yAxis.valueToJava2D(ymax, area, getRangeAxisEdge());\n\n        Rectangle2D[] r \u003d new Rectangle2D[] {null, null, null, null};\n        if (this.quadrantPaint[0] !\u003d null) {\n            if (x \u003e xmin \u0026\u0026 y \u003c ymax) {\n                if (this.orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n                    r[0] \u003d new Rectangle2D.Double(Math.min(yymax, yy),\n                            Math.min(xxmin, xx), Math.abs(yy - yymax),\n                            Math.abs(xx - xxmin));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[0] \u003d new Rectangle2D.Double(Math.min(xxmin, xx),\n                            Math.min(yymax, yy), Math.abs(xx - xxmin),\n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw \u003d true;\n            }\n        }\n        if (this.quadrantPaint[1] !\u003d null) {\n            if (x \u003c xmax \u0026\u0026 y \u003c ymax) {\n                if (this.orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n                    r[1] \u003d new Rectangle2D.Double(Math.min(yymax, yy),\n                            Math.min(xxmax, xx), Math.abs(yy - yymax),\n                            Math.abs(xx - xxmax));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[1] \u003d new Rectangle2D.Double(Math.min(xx, xxmax),\n                            Math.min(yymax, yy), Math.abs(xx - xxmax),\n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw \u003d true;\n            }\n        }\n        if (this.quadrantPaint[2] !\u003d null) {\n            if (x \u003e xmin \u0026\u0026 y \u003e ymin) {\n                if (this.orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n                    r[2] \u003d new Rectangle2D.Double(Math.min(yymin, yy),\n                            Math.min(xxmin, xx), Math.abs(yy - yymin),\n                            Math.abs(xx - xxmin));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[2] \u003d new Rectangle2D.Double(Math.min(xxmin, xx),\n                            Math.min(yymin, yy), Math.abs(xx - xxmin),\n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw \u003d true;\n            }\n        }\n        if (this.quadrantPaint[3] !\u003d null) {\n            if (x \u003c xmax \u0026\u0026 y \u003e ymin) {\n                if (this.orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n                    r[3] \u003d new Rectangle2D.Double(Math.min(yymin, yy),\n                            Math.min(xxmax, xx), Math.abs(yy - yymin),\n                            Math.abs(xx - xxmax));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[3] \u003d new Rectangle2D.Double(Math.min(xx, xxmax),\n                            Math.min(yymin, yy), Math.abs(xx - xxmax),\n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw \u003d true;\n            }\n        }\n        if (somethingToDraw) {\n            Composite originalComposite \u003d g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                    getBackgroundAlpha()));\n            for (int i \u003d 0; i \u003c 4; i++) {\n                if (this.quadrantPaint[i] !\u003d null \u0026\u0026 r[i] !\u003d null) {\n                    g2.setPaint(this.quadrantPaint[i]);\n                    g2.fill(r[i]);\n                }\n            }\n            g2.setComposite(originalComposite);\n        }\n    }\n\n    /**\n     * Draws the domain tick bands, if any.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     *\n     * @see #setDomainTickBandPaint(Paint)\n     */\n    public void drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                    List\u003cValueTick\u003e ticks) {\n        Paint bandPaint \u003d getDomainTickBandPaint();\n        if (bandPaint !\u003d null) {\n            boolean fillBand \u003d false;\n            ValueAxis xAxis \u003d getDomainAxis();\n            double previous \u003d xAxis.getLowerBound();\n            for (ValueTick tick : ticks) {\n                double current \u003d tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea,\n                            previous, current);\n                }\n                previous \u003d current;\n                fillBand \u003d !fillBand;\n            }\n            double end \u003d xAxis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea,\n                        previous, end);\n            }\n        }\n    }\n\n    /**\n     * Draws the range tick bands, if any.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     *\n     * @see #setRangeTickBandPaint(Paint)\n     */\n    public void drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                   List\u003cValueTick\u003e ticks) {\n        Paint bandPaint \u003d getRangeTickBandPaint();\n        if (bandPaint !\u003d null) {\n            boolean fillBand \u003d false;\n            ValueAxis axis \u003d getRangeAxis();\n            double previous \u003d axis.getLowerBound();\n            for (ValueTick tick : ticks) {\n                double current \u003d tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillRangeGridBand(g2, this, axis, dataArea,\n                            previous, current);\n                }\n                previous \u003d current;\n                fillBand \u003d !fillBand;\n            }\n            double end \u003d axis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillRangeGridBand(g2, this, axis, dataArea,\n                        previous, end);\n            }\n        }\n    }\n\n    /**\n     * A utility method for drawing the axes.\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param plotArea  the plot area ({@code null} not permitted).\n     * @param dataArea  the data area ({@code null} not permitted).\n     * @param plotState  collects information about the plot ({@code null}\n     *                   permitted).\n     *\n     * @return A map containing the state for each axis drawn.\n     */\n    protected Map\u003cAxis, AxisState\u003e drawAxes(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection \u003d new AxisCollection();\n\n        // add domain axes to lists...\n        for (ValueAxis axis : this.domainAxes.values()) {\n            if (axis !\u003d null) {\n                int axisIndex \u003d findDomainAxisIndex(axis);\n                axisCollection.add(axis, getDomainAxisEdge(axisIndex));\n            }\n        }\n\n        // add range axes to lists...\n        for (ValueAxis axis : this.rangeAxes.values()) {\n            if (axis !\u003d null) {\n                int axisIndex \u003d findRangeAxisIndex(axis);\n                axisCollection.add(axis, getRangeAxisEdge(axisIndex));\n            }\n        }\n\n        Map\u003cAxis, AxisState\u003e axisStateMap \u003d new HashMap\u003c\u003e();\n\n        // draw the top axes\n        double cursor \u003d dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        for (Axis axis : axisCollection.getAxesAtTop()) {\n            AxisState info \u003d axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.TOP, plotState);\n            cursor \u003d info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the bottom axes\n        cursor \u003d dataArea.getMaxY()\n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        for (Axis axis : axisCollection.getAxesAtBottom()) {\n            AxisState info \u003d axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.BOTTOM, plotState);\n            cursor \u003d info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the left axes\n        cursor \u003d dataArea.getMinX()\n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        for (Axis axis : axisCollection.getAxesAtLeft()) {\n            AxisState info \u003d axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.LEFT, plotState);\n            cursor \u003d info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the right axes\n        cursor \u003d dataArea.getMaxX()\n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        for (Axis axis : axisCollection.getAxesAtRight()) {\n            AxisState info \u003d axis.draw(g2, cursor, plotArea, dataArea,\n                    RectangleEdge.RIGHT, plotState);\n            cursor \u003d info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        return axisStateMap;\n    }\n\n    /**\n     * Draws a representation of the data within the dataArea region, using the\n     * current renderer.\n     * \u003cP\u003e\n     * The {@code info} and {@code crosshairState} arguments may be\n     * {@code null}.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the region in which the data is to be drawn.\n     * @param index  the dataset index.\n     * @param info  an optional object for collection dimension information.\n     * @param crosshairState  collects crosshair information\n     *                        ({@code null} permitted).\n     *\n     * @return A flag that indicates whether any data was actually rendered.\n     */\n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index,\n            PlotRenderingInfo info, CrosshairState crosshairState) {\n\n        boolean foundData \u003d false;\n        XYDataset\u003cS\u003e dataset \u003d getDataset(index);\n        if (!DatasetUtils.isEmptyOrNull(dataset)) {\n            foundData \u003d true;\n            ValueAxis xAxis \u003d getDomainAxisForDataset(index);\n            ValueAxis yAxis \u003d getRangeAxisForDataset(index);\n            if (xAxis \u003d\u003d null || yAxis \u003d\u003d null) {\n                return foundData;  // can\u0027t render anything without axes\n            }\n            XYItemRenderer renderer \u003d getRenderer(index);\n            if (renderer \u003d\u003d null) {\n                renderer \u003d getRenderer();\n                if (renderer \u003d\u003d null) { // no default renderer available\n                    return foundData;\n                }\n            }\n\n            XYItemRendererState state \u003d renderer.initialise(g2, dataArea, this,\n                    dataset, info);\n            int passCount \u003d renderer.getPassCount();\n\n            SeriesRenderingOrder seriesOrder \u003d getSeriesRenderingOrder();\n            if (seriesOrder \u003d\u003d SeriesRenderingOrder.REVERSE) {\n                //render series in reverse order\n                for (int pass \u003d 0; pass \u003c passCount; pass++) {\n                    int seriesCount \u003d dataset.getSeriesCount();\n                    for (int series \u003d seriesCount - 1; series \u003e\u003d 0; series--) {\n                        int firstItem \u003d 0;\n                        int lastItem \u003d dataset.getItemCount(series) - 1;\n                        if (lastItem \u003d\u003d -1) {\n                            continue;\n                        }\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds \u003d RendererUtils.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(),\n                                    xAxis.getUpperBound());\n                            firstItem \u003d Math.max(itemBounds[0] - 1, 0);\n                            lastItem \u003d Math.min(itemBounds[1] + 1, lastItem);\n                        }\n                        state.startSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                        for (int item \u003d firstItem; item \u003c\u003d lastItem; item++) {\n                            renderer.drawItem(g2, state, dataArea, info,\n                                    this, xAxis, yAxis, dataset, series, item,\n                                    crosshairState, pass);\n                        }\n                        state.endSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                    }\n                }\n            }\n            else {\n                //render series in forward order\n                for (int pass \u003d 0; pass \u003c passCount; pass++) {\n                    int seriesCount \u003d dataset.getSeriesCount();\n                    for (int series \u003d 0; series \u003c seriesCount; series++) {\n                        int firstItem \u003d 0;\n                        int lastItem \u003d dataset.getItemCount(series) - 1;\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds \u003d RendererUtils.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(),\n                                    xAxis.getUpperBound());\n                            firstItem \u003d Math.max(itemBounds[0] - 1, 0);\n                            lastItem \u003d Math.min(itemBounds[1] + 1, lastItem);\n                        }\n                        state.startSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                        for (int item \u003d firstItem; item \u003c\u003d lastItem; item++) {\n                            renderer.drawItem(g2, state, dataArea, info,\n                                    this, xAxis, yAxis, dataset, series, item,\n                                    crosshairState, pass);\n                        }\n                        state.endSeriesPass(dataset, series, firstItem,\n                                lastItem, pass, passCount);\n                    }\n                }\n            }\n        }\n        return foundData;\n    }\n\n    /**\n     * Returns the domain axis for a dataset.\n     *\n     * @param index  the dataset index (must be \u0026gt;\u003d 0).\n     *\n     * @return The axis.\n     */\n    public ValueAxis getDomainAxisForDataset(int index) {\n        Args.requireNonNegative(index, \"index\");\n        ValueAxis valueAxis;\n        List\u003cInteger\u003e axisIndices \u003d this.datasetToDomainAxesMap.get(index);\n        if (axisIndices !\u003d null) {\n            // the first axis in the list is used for data \u003c--\u003e Java2D\n            Integer axisIndex \u003d axisIndices.get(0);\n            valueAxis \u003d getDomainAxis(axisIndex);\n        }\n        else {\n            valueAxis \u003d getDomainAxis(0);\n        }\n        return valueAxis;\n    }\n\n    /**\n     * Returns the range axis for a dataset.\n     *\n     * @param index  the dataset index (must be \u0026gt;\u003d 0).\n     *\n     * @return The axis.\n     */\n    public ValueAxis getRangeAxisForDataset(int index) {\n        Args.requireNonNegative(index, \"index\");\n        ValueAxis valueAxis;\n        List\u003cInteger\u003e axisIndices \u003d this.datasetToRangeAxesMap.get(index);\n        if (axisIndices !\u003d null) {\n            // the first axis in the list is used for data \u003c--\u003e Java2D\n            Integer axisIndex \u003d axisIndices.get(0);\n            valueAxis \u003d getRangeAxis(axisIndex);\n        }\n        else {\n            valueAxis \u003d getRangeAxis(0);\n        }\n        return valueAxis;\n    }\n\n    /**\n     * Draws the gridlines for the plot, if they are visible.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     *\n     * @see #drawRangeGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                       List\u003cValueTick\u003e ticks) {\n\n        // no renderer, no gridlines...\n        if (getRenderer() \u003d\u003d null) {\n            return;\n        }\n\n        // draw the domain grid lines, if any...\n        if (isDomainGridlinesVisible() || isDomainMinorGridlinesVisible()) {\n            Stroke gridStroke \u003d null;\n            Paint gridPaint \u003d null;\n            for (ValueTick tick : ticks) {\n                boolean paintLine \u003d false;\n                if ((tick.getTickType() \u003d\u003d TickType.MINOR)\n                        \u0026\u0026 isDomainMinorGridlinesVisible()) {\n                    gridStroke \u003d getDomainMinorGridlineStroke();\n                    gridPaint \u003d getDomainMinorGridlinePaint();\n                    paintLine \u003d true;\n                } else if ((tick.getTickType() \u003d\u003d TickType.MAJOR)\n                        \u0026\u0026 isDomainGridlinesVisible()) {\n                    gridStroke \u003d getDomainGridlineStroke();\n                    gridPaint \u003d getDomainGridlinePaint();\n                    paintLine \u003d true;\n                }\n                XYItemRenderer r \u003d getRenderer();\n                if ((r instanceof AbstractXYItemRenderer) \u0026\u0026 paintLine) {\n                    ((AbstractXYItemRenderer) r).drawDomainLine(g2, this,\n                            getDomainAxis(), dataArea, tick.getValue(),\n                            gridPaint, gridStroke);\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the gridlines for the plot\u0027s primary range axis, if they are\n     * visible.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     * @param ticks  the ticks.\n     *\n     * @see #drawDomainGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D area,\n                                      List\u003cValueTick\u003e ticks) {\n\n        // no renderer, no gridlines...\n        if (getRenderer() \u003d\u003d null) {\n            return;\n        }\n\n        // draw the range grid lines, if any...\n        if (isRangeGridlinesVisible() || isRangeMinorGridlinesVisible()) {\n            Stroke gridStroke \u003d null;\n            Paint gridPaint \u003d null;\n            ValueAxis axis \u003d getRangeAxis();\n            if (axis !\u003d null) {\n                for (ValueTick tick : ticks) {\n                     boolean paintLine \u003d false;\n                    if ((tick.getTickType() \u003d\u003d TickType.MINOR)\n                            \u0026\u0026 isRangeMinorGridlinesVisible()) {\n                        gridStroke \u003d getRangeMinorGridlineStroke();\n                        gridPaint \u003d getRangeMinorGridlinePaint();\n                        paintLine \u003d true;\n                    } else if ((tick.getTickType() \u003d\u003d TickType.MAJOR)\n                            \u0026\u0026 isRangeGridlinesVisible()) {\n                        gridStroke \u003d getRangeGridlineStroke();\n                        gridPaint \u003d getRangeGridlinePaint();\n                        paintLine \u003d true;\n                    }\n                    if ((tick.getValue() !\u003d 0.0\n                            || !isRangeZeroBaselineVisible()) \u0026\u0026 paintLine) {\n                        getRenderer().drawRangeLine(g2, this, getRangeAxis(),\n                                area, tick.getValue(), gridPaint, gridStroke);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws a base line across the chart at value zero on the domain axis.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     *\n     * @see #setDomainZeroBaselineVisible(boolean)\n     */\n    protected void drawZeroDomainBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isDomainZeroBaselineVisible() \u0026\u0026 getRenderer() !\u003d null) {\n            getRenderer().drawDomainLine(g2, this, getDomainAxis(), area, 0.0,\n                        this.domainZeroBaselinePaint,\n                        this.domainZeroBaselineStroke);\n        }\n    }\n\n    /**\n     * Draws a base line across the chart at value zero on the range axis.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     *\n     * @see #setRangeZeroBaselineVisible(boolean)\n     */\n    protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isRangeZeroBaselineVisible()) {\n            getRenderer().drawRangeLine(g2, this, getRangeAxis(), area, 0.0,\n                    this.rangeZeroBaselinePaint, this.rangeZeroBaselineStroke);\n        }\n    }\n\n    /**\n     * Draws the annotations for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param info  the chart rendering info.\n     */\n    public void drawAnnotations(Graphics2D g2, Rectangle2D dataArea,\n                                PlotRenderingInfo info) {\n\n        for (XYAnnotation annotation : this.annotations) {\n            ValueAxis xAxis \u003d getDomainAxis();\n            ValueAxis yAxis \u003d getRangeAxis();\n            annotation.draw(g2, this, dataArea, xAxis, yAxis, 0, info);\n        }\n\n    }\n\n    /**\n     * Draws the domain markers (if any) for an axis and layer.  This method is\n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the dataset/renderer index.\n     * @param layer  the layer (foreground or background).\n     */\n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                     int index, Layer layer) {\n\n        XYItemRenderer r \u003d getRenderer(index);\n        if (r \u003d\u003d null) {\n            return;\n        }\n        // check that the renderer has a corresponding dataset (it doesn\u0027t\n        // matter if the dataset is null)\n        if (index \u003e\u003d getDatasetCount()) {\n            return;\n        }\n        Collection\u003cMarker\u003e markers \u003d getDomainMarkers(index, layer);\n        ValueAxis axis \u003d getDomainAxisForDataset(index);\n        if (markers !\u003d null \u0026\u0026 axis !\u003d null) {\n            for (Marker marker : markers) {\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n\n    }\n\n    /**\n     * Draws the range markers (if any) for a renderer and layer.  This method\n     * is typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     */\n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                    int index, Layer layer) {\n\n        XYItemRenderer r \u003d getRenderer(index);\n        if (r \u003d\u003d null) {\n            return;\n        }\n        // check that the renderer has a corresponding dataset (it doesn\u0027t\n        // matter if the dataset is null)\n        if (index \u003e\u003d getDatasetCount()) {\n            return;\n        }\n        Collection\u003cMarker\u003e markers \u003d getRangeMarkers(index, layer);\n        ValueAxis axis \u003d getRangeAxisForDataset(index);\n        if (markers !\u003d null \u0026\u0026 axis !\u003d null) {\n            for (Marker marker : markers) {\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n    }\n\n    /**\n     * Returns the list of domain markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     *\n     * @return The list of domain markers.\n     *\n     * @see #getRangeMarkers(Layer)\n     */\n    public Collection\u003cMarker\u003e getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    /**\n     * Returns the list of range markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     *\n     * @return The list of range markers.\n     *\n     * @see #getDomainMarkers(Layer)\n     */\n    public Collection\u003cMarker\u003e getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of domain markers for a particular renderer and\n     * layer.\n     *\n     * @param index  the renderer index.\n     * @param layer  the layer.\n     *\n     * @return A collection of markers (possibly {@code null}).\n     *\n     * @see #getRangeMarkers(int, Layer)\n     */\n    public Collection\u003cMarker\u003e getDomainMarkers(int index, Layer layer) {\n        Collection\u003cMarker\u003e result \u003d null;\n        if (layer \u003d\u003d Layer.FOREGROUND) {\n            result \u003d this.foregroundDomainMarkers.get(index);\n        }\n        else if (layer \u003d\u003d Layer.BACKGROUND) {\n            result \u003d this.backgroundDomainMarkers.get(index);\n        }\n        if (result !\u003d null) {\n            result \u003d Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a collection of range markers for a particular renderer and\n     * layer.\n     *\n     * @param index  the renderer index.\n     * @param layer  the layer.\n     *\n     * @return A collection of markers (possibly {@code null}).\n     *\n     * @see #getDomainMarkers(int, Layer)\n     */\n    public Collection\u003cMarker\u003e getRangeMarkers(int index, Layer layer) {\n        Collection\u003cMarker\u003e result \u003d null;\n        if (layer \u003d\u003d Layer.FOREGROUND) {\n            result \u003d this.foregroundRangeMarkers.get(index);\n        }\n        else if (layer \u003d\u003d Layer.BACKGROUND) {\n            result \u003d this.backgroundRangeMarkers.get(index);\n        }\n        if (result !\u003d null) {\n            result \u003d Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    /**\n     * Utility method for drawing a horizontal line across the data area of the\n     * plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param value  the coordinate, where to draw the line.\n     * @param stroke  the stroke to use.\n     * @param paint  the paint to use.\n     */\n    protected void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea,\n                                      double value, Stroke stroke,\n                                      Paint paint) {\n\n        ValueAxis axis \u003d getRangeAxis();\n        if (getOrientation() \u003d\u003d PlotOrientation.HORIZONTAL) {\n            axis \u003d getDomainAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double yy \u003d axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\n            Line2D line \u003d new Line2D.Double(dataArea.getMinX(), yy,\n                    dataArea.getMaxX(), yy);\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n\n    /**\n     * Draws a domain crosshair.\n     *\n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     */\n    protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, double value, ValueAxis axis,\n            Stroke stroke, Paint paint) {\n\n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Line2D line;\n        if (orientation \u003d\u003d PlotOrientation.VERTICAL) {\n            double xx \u003d axis.valueToJava2D(value, dataArea,\n                    RectangleEdge.BOTTOM);\n            line \u003d new Line2D.Double(xx, dataArea.getMinY(), xx,\n                    dataArea.getMaxY());\n        } else {\n            double yy \u003d axis.valueToJava2D(value, dataArea,\n                    RectangleEdge.LEFT);\n            line \u003d new Line2D.Double(dataArea.getMinX(), yy,\n                    dataArea.getMaxX(), yy);\n        }\n        Object saved \u003d g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, \n                RenderingHints.VALUE_STROKE_NORMALIZE);\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, saved);\n    }\n\n    /**\n     * Utility method for drawing a vertical line on the data area of the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param value  the coordinate, where to draw the line.\n     * @param stroke  the stroke to use.\n     * @param paint  the paint to use.\n     */\n    protected void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea,\n                                    double value, Stroke stroke, Paint paint) {\n\n        ValueAxis axis \u003d getDomainAxis();\n        if (getOrientation() \u003d\u003d PlotOrientation.HORIZONTAL) {\n            axis \u003d getRangeAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double xx \u003d axis.valueToJava2D(value, dataArea,\n                    RectangleEdge.BOTTOM);\n            Line2D line \u003d new Line2D.Double(xx, dataArea.getMinY(), xx,\n                    dataArea.getMaxY());\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n\n    /**\n     * Draws a range crosshair.\n     *\n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     */\n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, double value, ValueAxis axis,\n            Stroke stroke, Paint paint) {\n\n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Object saved \u003d g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, \n                RenderingHints.VALUE_STROKE_NORMALIZE);\n        Line2D line;\n        if (orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n            double xx \u003d axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            line \u003d new Line2D.Double(xx, dataArea.getMinY(), xx,\n                    dataArea.getMaxY());\n        } else {\n            double yy \u003d axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\n            line \u003d new Line2D.Double(dataArea.getMinX(), yy,\n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n        g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, saved);\n    }\n\n    /**\n     * Handles a \u0027click\u0027 on the plot by updating the anchor values.\n     *\n     * @param x  the x-coordinate, where the click occurred, in Java2D space.\n     * @param y  the y-coordinate, where the click occurred, in Java2D space.\n     * @param info  object containing information about the plot dimensions.\n     */\n    @Override\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea \u003d info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            // set the anchor value for the horizontal axis...\n            ValueAxis xaxis \u003d getDomainAxis();\n            if (xaxis !\u003d null) {\n                double hvalue \u003d xaxis.java2DToValue(x, info.getDataArea(),\n                        getDomainAxisEdge());\n                setDomainCrosshairValue(hvalue);\n            }\n\n            // set the anchor value for the vertical axis...\n            ValueAxis yaxis \u003d getRangeAxis();\n            if (yaxis !\u003d null) {\n                double vvalue \u003d yaxis.java2DToValue(y, info.getDataArea(),\n                        getRangeAxisEdge());\n                setRangeCrosshairValue(vvalue);\n            }\n        }\n    }\n\n    /**\n     * A utility method that returns a list of datasets that are mapped to a\n     * particular axis.\n     *\n     * @param axisIndex  the axis index ({@code null} not permitted).\n     *\n     * @return A list of datasets.\n     */\n    private List\u003cXYDataset\u003cS\u003e\u003e getDatasetsMappedToDomainAxis(Integer axisIndex) {\n        Args.nullNotPermitted(axisIndex, \"axisIndex\");\n        List\u003cXYDataset\u003cS\u003e\u003e result \u003d new ArrayList\u003c\u003e();\n        for (Entry\u003cInteger, XYDataset\u003cS\u003e\u003e entry : this.datasets.entrySet()) {\n            int index \u003d entry.getKey();\n            List\u003cInteger\u003e mappedAxes \u003d this.datasetToDomainAxesMap.get(index);\n            if (mappedAxes \u003d\u003d null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(entry.getValue());\n                }\n            } else {\n                if (mappedAxes.contains(axisIndex)) {\n                    result.add(entry.getValue());\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * A utility method that returns a list of datasets that are mapped to a\n     * particular axis.\n     *\n     * @param axisIndex  the axis index ({@code null} not permitted).\n     *\n     * @return A list of datasets.\n     */\n    private List\u003cXYDataset\u003cS\u003e\u003e getDatasetsMappedToRangeAxis(Integer axisIndex) {\n        Args.nullNotPermitted(axisIndex, \"axisIndex\");\n        List\u003cXYDataset\u003cS\u003e\u003e result \u003d new ArrayList\u003c\u003e();\n        for (Entry\u003cInteger, XYDataset\u003cS\u003e\u003e entry : this.datasets.entrySet()) {\n            int index \u003d entry.getKey();\n            List\u003cInteger\u003e mappedAxes \u003d this.datasetToRangeAxesMap.get(index);\n            if (mappedAxes \u003d\u003d null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(entry.getValue());\n                }\n            } else {\n                if (mappedAxes.contains(axisIndex)) {\n                    result.add(entry.getValue());\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index of the given domain axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The axis index.\n     *\n     * @see #getRangeAxisIndex(ValueAxis)\n     */\n    public int getDomainAxisIndex(ValueAxis axis) {\n        int result \u003d findDomainAxisIndex(axis);\n        if (result \u003c 0) {\n            // try the parent plot\n            Plot parent \u003d getParent();\n            if (parent instanceof XYPlot) {\n                @SuppressWarnings(\"unchecked\")\n                XYPlot\u003cS\u003e p \u003d (XYPlot) parent;\n                result \u003d p.getDomainAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n    \n    private int findDomainAxisIndex(ValueAxis axis) {\n        for (Map.Entry\u003cInteger, ValueAxis\u003e entry : this.domainAxes.entrySet()) {\n            if (entry.getValue() \u003d\u003d axis) {\n                return entry.getKey();\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the index of the given range axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The axis index.\n     *\n     * @see #getDomainAxisIndex(ValueAxis)\n     */\n    public int getRangeAxisIndex(ValueAxis axis) {\n        int result \u003d findRangeAxisIndex(axis);\n        if (result \u003c 0) {\n            // try the parent plot\n            Plot parent \u003d getParent();\n            if (parent instanceof XYPlot) {\n                @SuppressWarnings(\"unchecked\")\n                XYPlot\u003cS\u003e p \u003d (XYPlot) parent;\n                result \u003d p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    private int findRangeAxisIndex(ValueAxis axis) {\n        for (Map.Entry\u003cInteger, ValueAxis\u003e entry : this.rangeAxes.entrySet()) {\n            if (entry.getValue() \u003d\u003d axis) {\n                return entry.getKey();\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the range for the specified axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The range.\n     */\n    @Override\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result \u003d null;\n        List\u003cXYDataset\u003cS\u003e\u003e mappedDatasets \u003d new ArrayList\u003c\u003e();\n        List\u003cXYAnnotation\u003e includedAnnotations \u003d new ArrayList\u003c\u003e();\n        boolean isDomainAxis \u003d true;\n\n        // is it a domain axis?\n        int domainIndex \u003d getDomainAxisIndex(axis);\n        if (domainIndex \u003e\u003d 0) {\n            isDomainAxis \u003d true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(domainIndex));\n            if (domainIndex \u003d\u003d 0) {\n                // grab the plot\u0027s annotations\n                for (XYAnnotation annotation : this.annotations) {\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // or is it a range axis?\n        int rangeIndex \u003d getRangeAxisIndex(axis);\n        if (rangeIndex \u003e\u003d 0) {\n            isDomainAxis \u003d false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(rangeIndex));\n            if (rangeIndex \u003d\u003d 0) {\n                for (XYAnnotation annotation : this.annotations) {\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        for (XYDataset\u003cS\u003e d : mappedDatasets) {\n            if (d !\u003d null) {\n                XYItemRenderer r \u003d getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r !\u003d null) {\n                        result \u003d Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result \u003d Range.combine(result,\n                                DatasetUtils.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r !\u003d null) {\n                        result \u003d Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result \u003d Range.combine(result,\n                                DatasetUtils.findRangeBounds(d));\n                    }\n                }\n                if (r !\u003d null) {\n                    for (XYAnnotation annotation : r.getAnnotations()) {\n                        if (annotation instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(annotation);\n                        }\n                    }\n                }\n            }\n        }\n\n        for (XYAnnotation includedAnnotation : includedAnnotations) {\n            XYAnnotationBoundsInfo xyabi \u003d (XYAnnotationBoundsInfo) includedAnnotation;\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result \u003d Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result \u003d Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Receives notification of a change to an {@link Annotation} added to\n     * this plot.\n     *\n     * @param event  information about the event (not used here).\n     */\n    @Override\n    public void annotationChanged(AnnotationChangeEvent event) {\n        if (getParent() !\u003d null) {\n            getParent().annotationChanged(event);\n        }\n        else {\n            PlotChangeEvent e \u003d new PlotChangeEvent(this);\n            notifyListeners(e);\n        }\n    }\n\n    /**\n     * Receives notification of a change to the plot\u0027s dataset.\n     * \u003cP\u003e\n     * The axis ranges are updated if necessary.\n     *\n     * @param event  information about the event (not used here).\n     */\n    @Override\n    public void datasetChanged(DatasetChangeEvent event) {\n        configureDomainAxes();\n        configureRangeAxes();\n        if (getParent() !\u003d null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e \u003d new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n    }\n\n    /**\n     * Receives notification of a renderer change event.\n     *\n     * @param event  the event.\n     */\n    @Override\n    public void rendererChanged(RendererChangeEvent event) {\n        // if the event was caused by a change to series visibility, then\n        // the axis ranges might need updating...\n        if (event.getSeriesVisibilityChanged()) {\n            configureDomainAxes();\n            configureRangeAxes();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag indicating whether or not the domain crosshair is visible.\n     *\n     * @return The flag.\n     *\n     * @see #setDomainCrosshairVisible(boolean)\n     */\n    public boolean isDomainCrosshairVisible() {\n        return this.domainCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the domain crosshair is visible\n     * and, if the flag changes, sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param flag  the new value of the flag.\n     *\n     * @see #isDomainCrosshairVisible()\n     */\n    public void setDomainCrosshairVisible(boolean flag) {\n        if (this.domainCrosshairVisible !\u003d flag) {\n            this.domainCrosshairVisible \u003d flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     *\n     * @see #setDomainCrosshairLockedOnData(boolean)\n     */\n    public boolean isDomainCrosshairLockedOnData() {\n        return this.domainCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the domain crosshair should\n     * \"lock-on\" to actual data values.  If the flag value changes, this\n     * method sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     *\n     * @see #isDomainCrosshairLockedOnData()\n     */\n    public void setDomainCrosshairLockedOnData(boolean flag) {\n        if (this.domainCrosshairLockedOnData !\u003d flag) {\n            this.domainCrosshairLockedOnData \u003d flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the domain crosshair value.\n     *\n     * @return The value.\n     *\n     * @see #setDomainCrosshairValue(double)\n     */\n    public double getDomainCrosshairValue() {\n        return this.domainCrosshairValue;\n    }\n\n    /**\n     * Sets the domain crosshair value and sends a {@link PlotChangeEvent} to\n     * all registered listeners (provided that the domain crosshair is visible).\n     *\n     * @param value  the value.\n     *\n     * @see #getDomainCrosshairValue()\n     */\n    public void setDomainCrosshairValue(double value) {\n        setDomainCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the domain crosshair value and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners (provided that the\n     * domain crosshair is visible).\n     *\n     * @param value  the new value.\n     * @param notify  notify listeners?\n     *\n     * @see #getDomainCrosshairValue()\n     */\n    public void setDomainCrosshairValue(double value, boolean notify) {\n        this.domainCrosshairValue \u003d value;\n        if (isDomainCrosshairVisible() \u0026\u0026 notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the {@link Stroke} used to draw the crosshair (if visible).\n     *\n     * @return The crosshair stroke (never {@code null}).\n     *\n     * @see #setDomainCrosshairStroke(Stroke)\n     * @see #isDomainCrosshairVisible()\n     * @see #getDomainCrosshairPaint()\n     */\n    public Stroke getDomainCrosshairStroke() {\n        return this.domainCrosshairStroke;\n    }\n\n    /**\n     * Sets the Stroke used to draw the crosshairs (if visible) and notifies\n     * registered listeners that the axis has been modified.\n     *\n     * @param stroke  the new crosshair stroke ({@code null} not permitted).\n     *\n     * @see #getDomainCrosshairStroke()\n     */\n    public void setDomainCrosshairStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.domainCrosshairStroke \u003d stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain crosshair paint.\n     *\n     * @return The crosshair paint (never {@code null}).\n     *\n     * @see #setDomainCrosshairPaint(Paint)\n     * @see #isDomainCrosshairVisible()\n     * @see #getDomainCrosshairStroke()\n     */\n    public Paint getDomainCrosshairPaint() {\n        return this.domainCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the crosshairs (if visible) and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint the new crosshair paint ({@code null} not permitted).\n     *\n     * @see #getDomainCrosshairPaint()\n     */\n    public void setDomainCrosshairPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.domainCrosshairPaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag indicating whether or not the range crosshair is visible.\n     *\n     * @return The flag.\n     *\n     * @see #setRangeCrosshairVisible(boolean)\n     * @see #isDomainCrosshairVisible()\n     */\n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair is visible.\n     * If the flag value changes, this method sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param flag  the new value of the flag.\n     *\n     * @see #isRangeCrosshairVisible()\n     */\n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible !\u003d flag) {\n            this.rangeCrosshairVisible \u003d flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     *\n     * @see #setRangeCrosshairLockedOnData(boolean)\n     */\n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair should\n     * \"lock-on\" to actual data values.  If the flag value changes, this method\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     *\n     * @see #isRangeCrosshairLockedOnData()\n     */\n    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData !\u003d flag) {\n            this.rangeCrosshairLockedOnData \u003d flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the range crosshair value.\n     *\n     * @return The value.\n     *\n     * @see #setRangeCrosshairValue(double)\n     */\n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    /**\n     * Sets the range crosshair value.\n     * \u003cP\u003e\n     * Registered listeners are notified that the plot has been modified, but\n     * only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     *\n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the range crosshair value and sends a {@link PlotChangeEvent} to\n     * all registered listeners, but only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     * @param notify  a flag that controls whether or not listeners are\n     *                notified.\n     *\n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue \u003d value;\n        if (isRangeCrosshairVisible() \u0026\u0026 notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke used to draw the crosshair (if visible).\n     *\n     * @return The crosshair stroke (never {@code null}).\n     *\n     * @see #setRangeCrosshairStroke(Stroke)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairPaint()\n     */\n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the crosshairs (if visible) and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the new crosshair stroke ({@code null} not\n     *         permitted).\n     *\n     * @see #getRangeCrosshairStroke()\n     */\n    public void setRangeCrosshairStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.rangeCrosshairStroke \u003d stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the range crosshair paint.\n     *\n     * @return The crosshair paint (never {@code null}).\n     *\n     * @see #setRangeCrosshairPaint(Paint)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairStroke()\n     */\n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to color the crosshairs (if visible) and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint the new crosshair paint ({@code null} not permitted).\n     *\n     * @see #getRangeCrosshairPaint()\n     */\n    public void setRangeCrosshairPaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.rangeCrosshairPaint \u003d paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the fixed domain axis space.\n     *\n     * @return The fixed domain axis space (possibly {@code null}).\n     *\n     * @see #setFixedDomainAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space ({@code null} permitted).\n     *\n     * @see #getFixedDomainAxisSpace()\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        setFixedDomainAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed domain axis space and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param space  the space ({@code null} permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getFixedDomainAxisSpace()\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace \u003d space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the fixed range axis space.\n     *\n     * @return The fixed range axis space (possibly {@code null}).\n     *\n     * @see #setFixedRangeAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space ({@code null} permitted).\n     *\n     * @see #getFixedRangeAxisSpace()\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        setFixedRangeAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed range axis space and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param space  the space ({@code null} permitted).\n     * @param notify  notify listeners?\n     *\n     * @see #getFixedRangeAxisSpace()\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace \u003d space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns {@code true} if panning is enabled for the domain axes,\n     * and {@code false} otherwise.\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean isDomainPannable() {\n        return this.domainPannable;\n    }\n\n    /**\n     * Sets the flag that enables or disables panning of the plot along the\n     * domain axes.\n     *\n     * @param pannable  the new flag value.\n     */\n    public void setDomainPannable(boolean pannable) {\n        this.domainPannable \u003d pannable;\n    }\n\n    /**\n     * Returns {@code true} if panning is enabled for the range axis/axes,\n     * and {@code false} otherwise.  The default value is {@code false}.\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean isRangePannable() {\n        return this.rangePannable;\n    }\n\n    /**\n     * Sets the flag that enables or disables panning of the plot along\n     * the range axis/axes.\n     *\n     * @param pannable  the new flag value.\n     */\n    public void setRangePannable(boolean pannable) {\n        this.rangePannable \u003d pannable;\n    }\n\n    /**\n     * Pans the domain axes by the specified percentage.\n     *\n     * @param percent  the distance to pan (as a percentage of the axis length).\n     * @param info the plot info\n     * @param source the source point where the pan action started.\n     */\n    @Override\n    public void panDomainAxes(double percent, PlotRenderingInfo info,\n            Point2D source) {\n        if (!isDomainPannable()) {\n            return;\n        }\n        int domainAxisCount \u003d getDomainAxisCount();\n        for (int i \u003d 0; i \u003c domainAxisCount; i++) {\n            ValueAxis axis \u003d getDomainAxis(i);\n            if (axis \u003d\u003d null) {\n                continue;\n            }\n\n            axis.pan(axis.isInverted() ? -percent : percent);\n        }\n    }\n\n    /**\n     * Pans the range axes by the specified percentage.\n     *\n     * @param percent  the distance to pan (as a percentage of the axis length).\n     * @param info the plot info\n     * @param source the source point where the pan action started.\n     */\n    @Override\n    public void panRangeAxes(double percent, PlotRenderingInfo info,\n            Point2D source) {\n        if (!isRangePannable()) {\n            return;\n        }\n        int rangeAxisCount \u003d getRangeAxisCount();\n        for (int i \u003d 0; i \u003c rangeAxisCount; i++) {\n            ValueAxis axis \u003d getRangeAxis(i);\n            if (axis \u003d\u003d null) {\n                continue;\n            }\n\n            axis.pan(axis.isInverted() ? -percent : percent);\n        }\n    }\n\n    /**\n     * Multiplies the range on the domain axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     *\n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D)\n     */\n    @Override\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source) {\n        // delegate to other method\n        zoomDomainAxes(factor, info, source, false);\n    }\n\n    /**\n     * Multiplies the range on the domain axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * @param useAnchor  use source point as zoom anchor?\n     *\n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean)\n     */\n    @Override\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source, boolean useAnchor) {\n\n        // perform the zoom on each domain axis\n        for (ValueAxis xAxis : this.domainAxes.values()) {\n            if (xAxis \u003d\u003d null) {\n                continue;\n            }\n            if (useAnchor) {\n                // get the relevant source coordinate given the plot orientation\n                double sourceX \u003d source.getX();\n                if (this.orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n                    sourceX \u003d source.getY();\n                }\n                double anchorX \u003d xAxis.java2DToValue(sourceX,\n                        info.getDataArea(), getDomainAxisEdge());\n                xAxis.resizeRange2(factor, anchorX);\n            } else {\n                xAxis.resizeRange(factor);\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the domain axis/axes.  The new lower and upper bounds are\n     * specified as percentages of the current axis range, where 0 percent is\n     * the current lower bound and 100 percent is the current upper bound.\n     *\n     * @param lowerPercent  a percentage that determines the new lower bound\n     *                      for the axis (e.g. 0.20 is twenty percent).\n     * @param upperPercent  a percentage that determines the new upper bound\n     *                      for the axis (e.g. 0.80 is eighty percent).\n     * @param info  the plot rendering info.\n     * @param source  the source point (ignored).\n     *\n     * @see #zoomRangeAxes(double, double, PlotRenderingInfo, Point2D)\n     */\n    @Override\n    public void zoomDomainAxes(double lowerPercent, double upperPercent,\n                               PlotRenderingInfo info, Point2D source) {\n        for (ValueAxis xAxis : this.domainAxes.values()) {\n            if (xAxis !\u003d null) {\n                xAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     *\n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     */\n    @Override\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source) {\n        // delegate to other method\n        zoomRangeAxes(factor, info, source, false);\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * @param useAnchor  a flag that controls whether or not the source point\n     *         is used for the zoom anchor.\n     *\n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     */\n    @Override\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source, boolean useAnchor) {\n\n        // perform the zoom on each range axis\n        for (ValueAxis yAxis : this.rangeAxes.values()) {\n            if (yAxis \u003d\u003d null) {\n                continue;\n            }\n            if (useAnchor) {\n                // get the relevant source coordinate given the plot orientation\n                double sourceY \u003d source.getY();\n                if (this.orientation \u003d\u003d PlotOrientation.HORIZONTAL) {\n                    sourceY \u003d source.getX();\n                }\n                double anchorY \u003d yAxis.java2DToValue(sourceY,\n                        info.getDataArea(), getRangeAxisEdge());\n                yAxis.resizeRange2(factor, anchorY);\n            } else {\n                yAxis.resizeRange(factor);\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the range axes.\n     *\n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     *\n     * @see #zoomDomainAxes(double, double, PlotRenderingInfo, Point2D)\n     */\n    @Override\n    public void zoomRangeAxes(double lowerPercent, double upperPercent,\n                              PlotRenderingInfo info, Point2D source) {\n        for (ValueAxis yAxis : this.rangeAxes.values()) {\n            if (yAxis !\u003d null) {\n                yAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    /**\n     * Returns {@code true}, indicating that the domain axis/axes for this\n     * plot are zoomable.\n     *\n     * @return A boolean.\n     *\n     * @see #isRangeZoomable()\n     */\n    @Override\n    public boolean isDomainZoomable() {\n        return true;\n    }\n\n    /**\n     * Returns {@code true}, indicating that the range axis/axes for this\n     * plot are zoomable.\n     *\n     * @return A boolean.\n     *\n     * @see #isDomainZoomable()\n     */\n    @Override\n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    /**\n     * Returns the number of series in the primary dataset for this plot.  If\n     * the dataset is {@code null}, the method returns 0.\n     *\n     * @return The series count.\n     */\n    public int getSeriesCount() {\n        int result \u003d 0;\n        XYDataset\u003cS\u003e dataset \u003d getDataset();\n        if (dataset !\u003d null) {\n            result \u003d dataset.getSeriesCount();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the fixed legend items, if any.\n     *\n     * @return The legend items (possibly {@code null}).\n     *\n     * @see #setFixedLegendItems(LegendItemCollection)\n     */\n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;\n    }\n\n    /**\n     * Sets the fixed legend items for the plot.  Leave this set to\n     * {@code null} if you prefer the legend items to be created\n     * automatically.\n     *\n     * @param items  the legend items ({@code null} permitted).\n     *\n     * @see #getFixedLegendItems()\n     */\n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems \u003d items;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend items for the plot.  Each legend item is generated by\n     * the plot\u0027s renderer, since the renderer is responsible for the visual\n     * representation of the data.\n     *\n     * @return The legend items.\n     */\n    @Override\n    public LegendItemCollection getLegendItems() {\n        if (this.fixedLegendItems !\u003d null) {\n            return this.fixedLegendItems;\n        }\n        LegendItemCollection result \u003d new LegendItemCollection();\n        for (XYDataset\u003cS\u003e dataset : this.datasets.values()) {\n            if (dataset \u003d\u003d null) {\n                continue;\n            }\n            int datasetIndex \u003d indexOf(dataset);\n            XYItemRenderer renderer \u003d getRenderer(datasetIndex);\n            if (renderer \u003d\u003d null) {\n                renderer \u003d getRenderer(0);\n            }\n            if (renderer !\u003d null) {\n                int seriesCount \u003d dataset.getSeriesCount();\n                for (int i \u003d 0; i \u003c seriesCount; i++) {\n                    if (renderer.isSeriesVisible(i)\n                            \u0026\u0026 renderer.isSeriesVisibleInLegend(i)) {\n                        LegendItem item \u003d renderer.getLegendItem(\n                                datasetIndex, i);\n                        if (item !\u003d null) {\n                            result.add(item);\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Tests this plot for equality with another object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return {@code true} or {@code false}.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof XYPlot)) {\n            return false;\n        }\n        @SuppressWarnings(\"unchecked\")\n        XYPlot\u003cS\u003e that \u003d (XYPlot) obj;\n        if (this.weight !\u003d that.weight) {\n            return false;\n        }\n        if (this.orientation !\u003d that.orientation) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData\n                !\u003d that.rangeCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.domainGridlinesVisible !\u003d that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible !\u003d that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (this.domainMinorGridlinesVisible\n                !\u003d that.domainMinorGridlinesVisible) {\n            return false;\n        }\n        if (this.rangeMinorGridlinesVisible\n                !\u003d that.rangeMinorGridlinesVisible) {\n            return false;\n        }\n        if (this.domainZeroBaselineVisible !\u003d that.domainZeroBaselineVisible) {\n            return false;\n        }\n        if (this.rangeZeroBaselineVisible !\u003d that.rangeZeroBaselineVisible) {\n            return false;\n        }\n        if (this.domainCrosshairVisible !\u003d that.domainCrosshairVisible) {\n            return false;\n        }\n        if (this.domainCrosshairValue !\u003d that.domainCrosshairValue) {\n            return false;\n        }\n        if (this.domainCrosshairLockedOnData\n                !\u003d that.domainCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible !\u003d that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue !\u003d that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!Objects.equals(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!Objects.equals(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (!Objects.equals(this.rangeAxes, that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!Objects.equals(this.datasetToDomainAxesMap, that.datasetToDomainAxesMap)) {\n            return false;\n        }\n        if (!Objects.equals(this.datasetToRangeAxesMap, that.datasetToRangeAxesMap)) {\n            return false;\n        }\n        if (!Objects.equals(this.domainGridlineStroke, that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.domainGridlinePaint,\n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.rangeGridlineStroke, that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.rangeGridlinePaint,\n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.domainMinorGridlineStroke, that.domainMinorGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.domainMinorGridlinePaint,\n                that.domainMinorGridlinePaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.rangeMinorGridlineStroke, that.rangeMinorGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.rangeMinorGridlinePaint,\n                that.rangeMinorGridlinePaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.domainZeroBaselinePaint,\n                that.domainZeroBaselinePaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.domainZeroBaselineStroke, that.domainZeroBaselineStroke)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.rangeZeroBaselinePaint,\n                that.rangeZeroBaselinePaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.rangeZeroBaselineStroke, that.rangeZeroBaselineStroke)) {\n            return false;\n        }\n        if (!Objects.equals(this.domainCrosshairStroke, that.domainCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.domainCrosshairPaint,\n                that.domainCrosshairPaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.rangeCrosshairStroke, that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.rangeCrosshairPaint,\n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.foregroundDomainMarkers, that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!Objects.equals(this.backgroundDomainMarkers, that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!Objects.equals(this.foregroundRangeMarkers, that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!Objects.equals(this.backgroundRangeMarkers, that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!Objects.equals(this.foregroundDomainMarkers, that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!Objects.equals(this.backgroundDomainMarkers, that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!Objects.equals(this.foregroundRangeMarkers, that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!Objects.equals(this.backgroundRangeMarkers, that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!Objects.equals(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (!Objects.equals(this.fixedLegendItems, that.fixedLegendItems)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.domainTickBandPaint,\n                that.domainTickBandPaint)) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.rangeTickBandPaint,\n                that.rangeTickBandPaint)) {\n            return false;\n        }\n        if (!this.quadrantOrigin.equals(that.quadrantOrigin)) {\n            return false;\n        }\n        for (int i \u003d 0; i \u003c 4; i++) {\n            if (!PaintUtils.equal(this.quadrantPaint[i],\n                    that.quadrantPaint[i])) {\n                return false;\n            }\n        }\n        if (!Objects.equals(this.shadowGenerator, that.shadowGenerator)) {\n            return false;\n        }\n        return super.equals(obj);\n    }\n\n    @Override\n    public int hashCode()\n    {\n        int hash \u003d 7;\n        hash \u003d 43 * hash + Objects.hashCode(this.orientation);\n        hash \u003d 43 * hash + Objects.hashCode(this.axisOffset);\n        hash \u003d 43 * hash + Objects.hashCode(this.domainAxes);\n        hash \u003d 43 * hash + Objects.hashCode(this.domainAxisLocations);\n        hash \u003d 43 * hash + Objects.hashCode(this.rangeAxes);\n        hash \u003d 43 * hash + Objects.hashCode(this.rangeAxisLocations);\n        hash \u003d 43 * hash + Objects.hashCode(this.renderers);\n        hash \u003d 43 * hash + Objects.hashCode(this.datasetToDomainAxesMap);\n        hash \u003d 43 * hash + Objects.hashCode(this.datasetToRangeAxesMap);\n        hash \u003d 43 * hash + Objects.hashCode(this.quadrantOrigin);\n        hash \u003d 43 * hash + Arrays.deepHashCode(this.quadrantPaint);\n        hash \u003d 43 * hash + (this.domainGridlinesVisible ? 1 : 0);\n        hash \u003d 43 * hash + Objects.hashCode(this.domainGridlineStroke);\n        hash \u003d 43 * hash + Objects.hashCode(this.domainGridlinePaint);\n        hash \u003d 43 * hash + (this.rangeGridlinesVisible ? 1 : 0);\n        hash \u003d 43 * hash + Objects.hashCode(this.rangeGridlineStroke);\n        hash \u003d 43 * hash + Objects.hashCode(this.rangeGridlinePaint);\n        hash \u003d 43 * hash + (this.domainMinorGridlinesVisible ? 1 : 0);\n        hash \u003d 43 * hash + Objects.hashCode(this.domainMinorGridlineStroke);\n        hash \u003d 43 * hash + Objects.hashCode(this.domainMinorGridlinePaint);\n        hash \u003d 43 * hash + (this.rangeMinorGridlinesVisible ? 1 : 0);\n        hash \u003d 43 * hash + Objects.hashCode(this.rangeMinorGridlineStroke);\n        hash \u003d 43 * hash + Objects.hashCode(this.rangeMinorGridlinePaint);\n        hash \u003d 43 * hash + (this.domainZeroBaselineVisible ? 1 : 0);\n        hash \u003d 43 * hash + Objects.hashCode(this.domainZeroBaselineStroke);\n        hash \u003d 43 * hash + Objects.hashCode(this.domainZeroBaselinePaint);\n        hash \u003d 43 * hash + (this.rangeZeroBaselineVisible ? 1 : 0);\n        hash \u003d 43 * hash + Objects.hashCode(this.rangeZeroBaselineStroke);\n        hash \u003d 43 * hash + Objects.hashCode(this.rangeZeroBaselinePaint);\n        hash \u003d 43 * hash + (this.domainCrosshairVisible ? 1 : 0);\n        hash \u003d 43 * hash +\n                (int) (Double.doubleToLongBits(this.domainCrosshairValue) ^\n                (Double.doubleToLongBits(this.domainCrosshairValue) \u003e\u003e\u003e 32));\n        hash \u003d 43 * hash + Objects.hashCode(this.domainCrosshairStroke);\n        hash \u003d 43 * hash + Objects.hashCode(this.domainCrosshairPaint);\n        hash \u003d 43 * hash + (this.domainCrosshairLockedOnData ? 1 : 0);\n        hash \u003d 43 * hash + (this.rangeCrosshairVisible ? 1 : 0);\n        hash \u003d 43 * hash +\n                (int) (Double.doubleToLongBits(this.rangeCrosshairValue) ^\n                (Double.doubleToLongBits(this.rangeCrosshairValue) \u003e\u003e\u003e 32));\n        hash \u003d 43 * hash + Objects.hashCode(this.rangeCrosshairStroke);\n        hash \u003d 43 * hash + Objects.hashCode(this.rangeCrosshairPaint);\n        hash \u003d 43 * hash + (this.rangeCrosshairLockedOnData ? 1 : 0);\n        hash \u003d 43 * hash + Objects.hashCode(this.foregroundDomainMarkers);\n        hash \u003d 43 * hash + Objects.hashCode(this.backgroundDomainMarkers);\n        hash \u003d 43 * hash + Objects.hashCode(this.foregroundRangeMarkers);\n        hash \u003d 43 * hash + Objects.hashCode(this.backgroundRangeMarkers);\n        hash \u003d 43 * hash + Objects.hashCode(this.annotations);\n        hash \u003d 43 * hash + Objects.hashCode(this.domainTickBandPaint);\n        hash \u003d 43 * hash + Objects.hashCode(this.rangeTickBandPaint);\n        hash \u003d 43 * hash + this.weight;\n        hash \u003d 43 * hash + Objects.hashCode(this.fixedLegendItems);\n        hash \u003d 43 * hash + Objects.hashCode(this.shadowGenerator);\n        return hash;\n    }\n\n    /**\n     * Returns a clone of the plot.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this can occur if some component of\n     *         the plot cannot be cloned.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        @SuppressWarnings(\"unchecked\")\n        XYPlot\u003cS\u003e clone \u003d (XYPlot) super.clone();\n        clone.domainAxes \u003d CloneUtils.cloneMapValues(this.domainAxes);\n        for (ValueAxis axis : clone.domainAxes.values()) {\n            if (axis !\u003d null) {\n                axis.setPlot(clone);\n                axis.addChangeListener(clone);\n            }\n        }\n        clone.rangeAxes \u003d CloneUtils.cloneMapValues(this.rangeAxes);\n        for (ValueAxis axis : clone.rangeAxes.values()) {\n            if (axis !\u003d null) {\n                axis.setPlot(clone);\n                axis.addChangeListener(clone);\n            }\n        }\n        clone.domainAxisLocations \u003d new HashMap\u003c\u003e(this.domainAxisLocations);\n        clone.rangeAxisLocations \u003d new HashMap\u003c\u003e(this.rangeAxisLocations);\n\n        // the datasets are not cloned, but listeners need to be added...\n        clone.datasets \u003d new HashMap\u003c\u003e(this.datasets);\n        for (XYDataset\u003cS\u003e dataset : clone.datasets.values()) {\n            if (dataset !\u003d null) {\n                dataset.addChangeListener(clone);\n            }\n        }\n\n        clone.datasetToDomainAxesMap \u003d new TreeMap\u003c\u003e();\n        clone.datasetToDomainAxesMap.putAll(this.datasetToDomainAxesMap);\n        clone.datasetToRangeAxesMap \u003d new TreeMap\u003c\u003e();\n        clone.datasetToRangeAxesMap.putAll(this.datasetToRangeAxesMap);\n\n        clone.renderers \u003d CloneUtils.cloneMapValues(this.renderers);\n        for (XYItemRenderer renderer : clone.renderers.values()) {\n            if (renderer !\u003d null) {\n                renderer.setPlot(clone);\n                renderer.addChangeListener(clone);\n            }\n        }\n        clone.foregroundDomainMarkers \u003d CloneUtils.clone(\n                this.foregroundDomainMarkers);\n        clone.backgroundDomainMarkers \u003d CloneUtils.clone(\n                this.backgroundDomainMarkers);\n        clone.foregroundRangeMarkers \u003d CloneUtils.clone(\n                this.foregroundRangeMarkers);\n        clone.backgroundRangeMarkers \u003d CloneUtils.clone(\n                this.backgroundRangeMarkers);\n        clone.annotations \u003d CloneUtils.cloneList(this.annotations);\n        if (this.fixedDomainAxisSpace !\u003d null) {\n            clone.fixedDomainAxisSpace \u003d CloneUtils.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace !\u003d null) {\n            clone.fixedRangeAxisSpace \u003d CloneUtils.clone(\n                    this.fixedRangeAxisSpace);\n        }\n        if (this.fixedLegendItems !\u003d null) {\n            clone.fixedLegendItems\n                    \u003d (LegendItemCollection) this.fixedLegendItems.clone();\n        }\n        clone.quadrantOrigin \u003d CloneUtils.clone(this.quadrantOrigin);\n        clone.quadrantPaint \u003d this.quadrantPaint.clone();\n        return clone;\n\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtils.writePaint(this.domainGridlinePaint, stream);\n        SerialUtils.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtils.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtils.writeStroke(this.domainMinorGridlineStroke, stream);\n        SerialUtils.writePaint(this.domainMinorGridlinePaint, stream);\n        SerialUtils.writeStroke(this.rangeMinorGridlineStroke, stream);\n        SerialUtils.writePaint(this.rangeMinorGridlinePaint, stream);\n        SerialUtils.writeStroke(this.rangeZeroBaselineStroke, stream);\n        SerialUtils.writePaint(this.rangeZeroBaselinePaint, stream);\n        SerialUtils.writeStroke(this.domainCrosshairStroke, stream);\n        SerialUtils.writePaint(this.domainCrosshairPaint, stream);\n        SerialUtils.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtils.writePaint(this.rangeCrosshairPaint, stream);\n        SerialUtils.writePaint(this.domainTickBandPaint, stream);\n        SerialUtils.writePaint(this.rangeTickBandPaint, stream);\n        SerialUtils.writePoint2D(this.quadrantOrigin, stream);\n        for (int i \u003d 0; i \u003c 4; i++) {\n            SerialUtils.writePaint(this.quadrantPaint[i], stream);\n        }\n        SerialUtils.writeStroke(this.domainZeroBaselineStroke, stream);\n        SerialUtils.writePaint(this.domainZeroBaselinePaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke \u003d SerialUtils.readStroke(stream);\n        this.domainGridlinePaint \u003d SerialUtils.readPaint(stream);\n        this.rangeGridlineStroke \u003d SerialUtils.readStroke(stream);\n        this.rangeGridlinePaint \u003d SerialUtils.readPaint(stream);\n        this.domainMinorGridlineStroke \u003d SerialUtils.readStroke(stream);\n        this.domainMinorGridlinePaint \u003d SerialUtils.readPaint(stream);\n        this.rangeMinorGridlineStroke \u003d SerialUtils.readStroke(stream);\n        this.rangeMinorGridlinePaint \u003d SerialUtils.readPaint(stream);\n        this.rangeZeroBaselineStroke \u003d SerialUtils.readStroke(stream);\n        this.rangeZeroBaselinePaint \u003d SerialUtils.readPaint(stream);\n        this.domainCrosshairStroke \u003d SerialUtils.readStroke(stream);\n        this.domainCrosshairPaint \u003d SerialUtils.readPaint(stream);\n        this.rangeCrosshairStroke \u003d SerialUtils.readStroke(stream);\n        this.rangeCrosshairPaint \u003d SerialUtils.readPaint(stream);\n        this.domainTickBandPaint \u003d SerialUtils.readPaint(stream);\n        this.rangeTickBandPaint \u003d SerialUtils.readPaint(stream);\n        this.quadrantOrigin \u003d SerialUtils.readPoint2D(stream);\n        this.quadrantPaint \u003d new Paint[4];\n        for (int i \u003d 0; i \u003c 4; i++) {\n            this.quadrantPaint[i] \u003d SerialUtils.readPaint(stream);\n        }\n\n        this.domainZeroBaselineStroke \u003d SerialUtils.readStroke(stream);\n        this.domainZeroBaselinePaint \u003d SerialUtils.readPaint(stream);\n\n        // register the plot as a listener with its axes, datasets, and\n        // renderers...\n        for (ValueAxis axis : this.domainAxes.values()) {\n            if (axis !\u003d null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        for (ValueAxis axis : this.rangeAxes.values()) {\n            if (axis !\u003d null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        for (XYDataset\u003cS\u003e dataset : this.datasets.values()) {\n            if (dataset !\u003d null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        for (XYItemRenderer renderer : this.renderers.values()) {\n            if (renderer !\u003d null) {\n                renderer.addChangeListener(this);\n            }\n        }\n\n    }\n\n}","methodCount":236,"staticMethodCount":0,"instanceMethodCount":236,"classLoc":5301,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":3,"candidates":[{"lineStart":746,"lineEnd":755,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method configureDomainAxes to class ShadowGenerator","description":"Move method configureDomainAxes to org.jfree.chart.util.ShadowGenerator\nRationale: The \u0027configureDomainAxes()\u0027 method appears to be related to domain axes in a plotting context and does not fit well within the \u0027ShadowGenerator\u0027 class, which is specialized in creating shadows for images. The methods and the purpose of \u0027ShadowGenerator\u0027 (creating drop shadows, calculating offsets for shadows) do not align with configuring domain axes, making it an inappropriate target class for relocating \u0027configureDomainAxes()\u0027. Instead, the \u0027configureDomainAxes()\u0027 method likely belongs to another class that deals with axes or plotting in general.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Somewhat Unhelpful"},{"lineStart":2470,"lineEnd":2496,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method clearRangeMarkers to class ShadowGenerator","description":"Move method clearRangeMarkers to org.jfree.chart.util.ShadowGenerator\nRationale: The clearRangeMarkers(int index) method is responsible for managing and clearing range markers, which is not related to the primary responsibility of the ShadowGenerator interface, which is to generate drop shadows for images. Therefore, ShadowGenerator is not a suitable class for this method. It would make more sense to place it in a class that is responsible for managing markers or the context the markers belong to, such as a chart or plot class. However, since no such class is listed here, ShadowGenerator is not appropriate.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Somewhat Unhelpful"},{"lineStart":3539,"lineEnd":3581,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method drawDomainGridlines to class AxisSpace","description":"Move method drawDomainGridlines to org.jfree.chart.axis.AxisSpace\nRationale: The drawDomainGridlines() method doesn\u0027t fit logically within AxisSpace. AxisSpace class encapsulates the space around the plot\u0027s axes, aiming to provide methods for manipulating and ensuring reserved space. The drawDomainGridlines() method pertains more to rendering, which doesn\u0027t align with the responsibilities of AxisSpace. Furthermore, AxisSpace focuses on spacing rather than drawing operations.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Somewhat Unhelpful"}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":223729},{"candidateIndex":1,"elapsedTime":43582},{"candidateIndex":2,"elapsedTime":51218}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":70951},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"setDomainAxis","method_signature":"public setDomainAxis(int index, ValueAxis axis, boolean notify)","target_class":"","rationale":""},{"method_name":"clearDomainAxes","method_signature":"public clearDomainAxes()","target_class":"","rationale":""},{"method_name":"configureDomainAxes","method_signature":"public configureDomainAxes()","target_class":"","rationale":""},{"method_name":"setRangeAxis","method_signature":"public setRangeAxis(int index, ValueAxis axis, boolean notify)","target_class":"","rationale":""},{"method_name":"clearRangeAxes","method_signature":"public clearRangeAxes()","target_class":"","rationale":""},{"method_name":"configureRangeAxes","method_signature":"public configureRangeAxes()","target_class":"","rationale":""},{"method_name":"setRenderer","method_signature":"public setRenderer(int index, XYItemRenderer renderer, \n            boolean notify)","target_class":"","rationale":""},{"method_name":"clearDomainMarkers","method_signature":"public clearDomainMarkers(int index)","target_class":"","rationale":""},{"method_name":"addDomainMarker","method_signature":"public addDomainMarker(int index, Marker marker, Layer layer,\n            boolean notify)","target_class":"","rationale":""},{"method_name":"addRangeMarker","method_signature":"public addRangeMarker(int index, Marker marker, Layer layer,\n            boolean notify)","target_class":"","rationale":""},{"method_name":"clearRangeMarkers","method_signature":"public clearRangeMarkers(int index)","target_class":"","rationale":""},{"method_name":"addAnnotation","method_signature":"public addAnnotation(XYAnnotation annotation, boolean notify)","target_class":"","rationale":""},{"method_name":"removeAnnotation","method_signature":"public removeAnnotation(XYAnnotation annotation, boolean notify)","target_class":"","rationale":""},{"method_name":"clearAnnotations","method_signature":"public clearAnnotations()","target_class":"","rationale":""},{"method_name":"calculateDomainAxisSpace","method_signature":"protected calculateDomainAxisSpace(Graphics2D g2, \n            Rectangle2D plotArea, AxisSpace space)","target_class":"","rationale":""},{"method_name":"calculateRangeAxisSpace","method_signature":"protected calculateRangeAxisSpace(Graphics2D g2, \n            Rectangle2D plotArea, AxisSpace space)","target_class":"","rationale":""},{"method_name":"drawDomainTickBands","method_signature":"public drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                    List\u003cValueTick\u003e ticks)","target_class":"","rationale":""},{"method_name":"drawRangeTickBands","method_signature":"public drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                   List\u003cValueTick\u003e ticks)","target_class":"","rationale":""},{"method_name":"drawAxes","method_signature":"protected drawAxes(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, PlotRenderingInfo plotState)","target_class":"","rationale":""},{"method_name":"drawDomainGridlines","method_signature":"protected drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                       List\u003cValueTick\u003e ticks)","target_class":"","rationale":""},{"method_name":"drawRangeGridlines","method_signature":"protected drawRangeGridlines(Graphics2D g2, Rectangle2D area,\n                                      List\u003cValueTick\u003e ticks)","target_class":"","rationale":""},{"method_name":"drawAnnotations","method_signature":"public drawAnnotations(Graphics2D g2, Rectangle2D dataArea,\n                                PlotRenderingInfo info)","target_class":"","rationale":""},{"method_name":"drawDomainCrosshair","method_signature":"protected drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, double value, ValueAxis axis,\n            Stroke stroke, Paint paint)","target_class":"","rationale":""},{"method_name":"drawRangeCrosshair","method_signature":"protected drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea,\n            PlotOrientation orientation, double value, ValueAxis axis,\n            Stroke stroke, Paint paint)","target_class":"","rationale":""},{"method_name":"readObject","method_signature":"private readObject(ObjectInputStream stream)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"readObject","method_signature":"private readObject(ObjectInputStream stream)","target_class":"","rationale":""},{"method_name":"configureDomainAxes","method_signature":"public configureDomainAxes()","target_class":"","rationale":""},{"method_name":"drawAxes","method_signature":"protected drawAxes(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, PlotRenderingInfo plotState)","target_class":"","rationale":""},{"method_name":"clearRangeMarkers","method_signature":"public clearRangeMarkers(int index)","target_class":"","rationale":""},{"method_name":"clearDomainMarkers","method_signature":"public clearDomainMarkers(int index)","target_class":"","rationale":""},{"method_name":"clearAnnotations","method_signature":"public clearAnnotations()","target_class":"","rationale":""},{"method_name":"drawDomainGridlines","method_signature":"protected drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                       List\u003cValueTick\u003e ticks)","target_class":"","rationale":""},{"method_name":"configureRangeAxes","method_signature":"public configureRangeAxes()","target_class":"","rationale":""},{"method_name":"addAnnotation","method_signature":"public addAnnotation(XYAnnotation annotation, boolean notify)","target_class":"","rationale":""},{"method_name":"removeAnnotation","method_signature":"public removeAnnotation(XYAnnotation annotation, boolean notify)","target_class":"","rationale":""},{"method_name":"drawRangeGridlines","method_signature":"protected drawRangeGridlines(Graphics2D g2, Rectangle2D area,\n                                      List\u003cValueTick\u003e ticks)","target_class":"","rationale":""},{"method_name":"drawDomainTickBands","method_signature":"public drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                    List\u003cValueTick\u003e ticks)","target_class":"","rationale":""},{"method_name":"drawRangeTickBands","method_signature":"public drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                   List\u003cValueTick\u003e ticks)","target_class":"","rationale":""},{"method_name":"drawAnnotations","method_signature":"public drawAnnotations(Graphics2D g2, Rectangle2D dataArea,\n                                PlotRenderingInfo info)","target_class":"","rationale":""},{"method_name":"calculateDomainAxisSpace","method_signature":"protected calculateDomainAxisSpace(Graphics2D g2, \n            Rectangle2D plotArea, AxisSpace space)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"private readObject(ObjectInputStream stream)":{"first":{"method_name":"readObject","method_signature":"private readObject(ObjectInputStream stream)","target_class":"","rationale":""},"second":0.5340809440306001},"public configureDomainAxes()":{"first":{"method_name":"configureDomainAxes","method_signature":"public configureDomainAxes()","target_class":"","rationale":""},"second":0.5782716461338847},"protected drawAxes(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, PlotRenderingInfo plotState)":{"first":{"method_name":"drawAxes","method_signature":"protected drawAxes(Graphics2D g2, Rectangle2D plotArea,\n            Rectangle2D dataArea, PlotRenderingInfo plotState)","target_class":"","rationale":""},"second":0.6342444985011457},"public clearRangeMarkers(int index)":{"first":{"method_name":"clearRangeMarkers","method_signature":"public clearRangeMarkers(int index)","target_class":"","rationale":""},"second":0.6388109594355014},"public clearDomainMarkers(int index)":{"first":{"method_name":"clearDomainMarkers","method_signature":"public clearDomainMarkers(int index)","target_class":"","rationale":""},"second":0.7064407720977118},"public clearAnnotations()":{"first":{"method_name":"clearAnnotations","method_signature":"public clearAnnotations()","target_class":"","rationale":""},"second":0.7151182304897293},"protected drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                       List\u003cValueTick\u003e ticks)":{"first":{"method_name":"drawDomainGridlines","method_signature":"protected drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                       List\u003cValueTick\u003e ticks)","target_class":"","rationale":""},"second":0.716725734775294},"public configureRangeAxes()":{"first":{"method_name":"configureRangeAxes","method_signature":"public configureRangeAxes()","target_class":"","rationale":""},"second":0.7182577092299113},"public addAnnotation(XYAnnotation annotation, boolean notify)":{"first":{"method_name":"addAnnotation","method_signature":"public addAnnotation(XYAnnotation annotation, boolean notify)","target_class":"","rationale":""},"second":0.7216292323090291},"public removeAnnotation(XYAnnotation annotation, boolean notify)":{"first":{"method_name":"removeAnnotation","method_signature":"public removeAnnotation(XYAnnotation annotation, boolean notify)","target_class":"","rationale":""},"second":0.7250579919814586},"protected drawRangeGridlines(Graphics2D g2, Rectangle2D area,\n                                      List\u003cValueTick\u003e ticks)":{"first":{"method_name":"drawRangeGridlines","method_signature":"protected drawRangeGridlines(Graphics2D g2, Rectangle2D area,\n                                      List\u003cValueTick\u003e ticks)","target_class":"","rationale":""},"second":0.7365754978938828},"public drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                    List\u003cValueTick\u003e ticks)":{"first":{"method_name":"drawDomainTickBands","method_signature":"public drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                    List\u003cValueTick\u003e ticks)","target_class":"","rationale":""},"second":0.7378011159848014},"public drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                   List\u003cValueTick\u003e ticks)":{"first":{"method_name":"drawRangeTickBands","method_signature":"public drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                   List\u003cValueTick\u003e ticks)","target_class":"","rationale":""},"second":0.7425661903441486},"public drawAnnotations(Graphics2D g2, Rectangle2D dataArea,\n                                PlotRenderingInfo info)":{"first":{"method_name":"drawAnnotations","method_signature":"public drawAnnotations(Graphics2D g2, Rectangle2D dataArea,\n                                PlotRenderingInfo info)","target_class":"","rationale":""},"second":0.7443216785828108},"protected calculateDomainAxisSpace(Graphics2D g2, \n            Rectangle2D plotArea, AxisSpace space)":{"first":{"method_name":"calculateDomainAxisSpace","method_signature":"protected calculateDomainAxisSpace(Graphics2D g2, \n            Rectangle2D plotArea, AxisSpace space)","target_class":"","rationale":""},"second":0.7506929506141299}},"targetClassMap":{"readObject":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.21864775993594085}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":4164,"similarity_computation_time":1,"similarity_metric":"cosine"},"configureDomainAxes":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.3159183176210574}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":5103,"similarity_computation_time":1,"similarity_metric":"cosine"},"drawAxes":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.3995603502495965}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":3415,"similarity_computation_time":1,"similarity_metric":"cosine"},"clearRangeMarkers":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.3377715727285724}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":3550,"similarity_computation_time":0,"similarity_metric":"cosine"},"clearDomainMarkers":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.41113048537854324}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":3110,"similarity_computation_time":0,"similarity_metric":"cosine"},"clearAnnotations":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.5648492302202017}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":6127,"similarity_computation_time":0,"similarity_metric":"cosine"},"drawDomainGridlines":{"target_classes":[{"class_name":"PlotOrientation","similarity_score":0.3926353271327092},{"class_name":"RectangleInsets","similarity_score":0.6385822249094932},{"class_name":"AxisSpace","similarity_score":0.67582400083061},{"class_name":"AxisSpace","similarity_score":0.67582400083061},{"class_name":"DatasetRenderingOrder","similarity_score":0.34129609512863074},{"class_name":"SeriesRenderingOrder","similarity_score":0.33520452794116545},{"class_name":"LegendItemCollection","similarity_score":0.5666563743935131},{"class_name":"ShadowGenerator","similarity_score":0.41190738851496106}],"target_classes_sorted_by_llm":["AxisSpace","AxisSpace","RectangleInsets"],"llm_response_time":6271,"similarity_computation_time":4,"similarity_metric":"cosine"},"configureRangeAxes":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.4821200444535561}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":5424,"similarity_computation_time":0,"similarity_metric":"cosine"},"addAnnotation":{"target_classes":[{"class_name":"XYAnnotation","similarity_score":0.6226246993329055},{"class_name":"ShadowGenerator","similarity_score":0.5659167335720786}],"target_classes_sorted_by_llm":["XYAnnotation","ShadowGenerator"],"llm_response_time":4767,"similarity_computation_time":1,"similarity_metric":"cosine"},"removeAnnotation":{"target_classes":[{"class_name":"XYAnnotation","similarity_score":0.6072321894161995},{"class_name":"ShadowGenerator","similarity_score":0.5950556311554102}],"target_classes_sorted_by_llm":["XYAnnotation","ShadowGenerator"],"llm_response_time":3426,"similarity_computation_time":1,"similarity_metric":"cosine"},"drawRangeGridlines":{"target_classes":[{"class_name":"PlotOrientation","similarity_score":0.4150035543653907},{"class_name":"RectangleInsets","similarity_score":0.6461375945080049},{"class_name":"AxisSpace","similarity_score":0.689258145332306},{"class_name":"AxisSpace","similarity_score":0.689258145332306},{"class_name":"DatasetRenderingOrder","similarity_score":0.344524735938476},{"class_name":"SeriesRenderingOrder","similarity_score":0.33709204944831106},{"class_name":"LegendItemCollection","similarity_score":0.5773825219789087},{"class_name":"ShadowGenerator","similarity_score":0.41590987978995675}],"target_classes_sorted_by_llm":["AxisSpace","AxisSpace","RectangleInsets"],"llm_response_time":5267,"similarity_computation_time":2,"similarity_metric":"cosine"},"drawDomainTickBands":{"target_classes":[{"class_name":"PlotOrientation","similarity_score":0.4206058973528972},{"class_name":"RectangleInsets","similarity_score":0.7071765277728443},{"class_name":"AxisSpace","similarity_score":0.6798285863300251},{"class_name":"AxisSpace","similarity_score":0.6798285863300251},{"class_name":"DatasetRenderingOrder","similarity_score":0.36874152661350107},{"class_name":"SeriesRenderingOrder","similarity_score":0.35770274903071114},{"class_name":"LegendItemCollection","similarity_score":0.5985919731877624},{"class_name":"ShadowGenerator","similarity_score":0.45041673572915986}],"target_classes_sorted_by_llm":["AxisSpace","AxisSpace","RectangleInsets"],"llm_response_time":5836,"similarity_computation_time":3,"similarity_metric":"cosine"},"drawRangeTickBands":{"target_classes":[{"class_name":"PlotOrientation","similarity_score":0.43139066395168946},{"class_name":"RectangleInsets","similarity_score":0.7071765277728443},{"class_name":"AxisSpace","similarity_score":0.6805826945788659},{"class_name":"AxisSpace","similarity_score":0.6805826945788659},{"class_name":"DatasetRenderingOrder","similarity_score":0.36874152661350107},{"class_name":"SeriesRenderingOrder","similarity_score":0.35770274903071114},{"class_name":"LegendItemCollection","similarity_score":0.5985919731877624},{"class_name":"ShadowGenerator","similarity_score":0.45041673572915986}],"target_classes_sorted_by_llm":["AxisSpace","AxisSpace","RectangleInsets"],"llm_response_time":6063,"similarity_computation_time":2,"similarity_metric":"cosine"},"drawAnnotations":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.6306453762663369}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":3301,"similarity_computation_time":1,"similarity_metric":"cosine"},"calculateDomainAxisSpace":{"target_classes":[{"class_name":"ShadowGenerator","similarity_score":0.5154123532605308}],"target_classes_sorted_by_llm":["ShadowGenerator"],"llm_response_time":3350,"similarity_computation_time":0,"similarity_metric":"cosine"}}}
{"id":"5fa8df3f-47f9-49d3-81d9-8e30156a7a98","hostFunctionTelemetryData":{"hostFunctionSize":129,"lineStart":44,"lineEnd":172,"bodyLineStart":44,"language":"java","filePath":"/Users/snehil/Documents/ConcordiaUniversity/Material/SOEN-6491-Refactoring/OpenSource/jfreechart/jfreechart/src/main/java/org/jfree/chart/renderer/OutlierListCollection.java","sourceCode":"/**\n * A collection of outlier lists for a box and whisker plot. Each collection is\n * associated with a single box and whisker entity.\n *\n * Outliers are grouped in lists for each entity. Lists contain\n * one or more outliers, determined by whether overlaps have\n * occurred. Overlapping outliers are grouped in the same list.\n *\n * @see org.jfree.chart.renderer.OutlierList\n */\npublic class OutlierListCollection {\n\n    /** Storage for the outlier lists. */\n    private List\u003cOutlierList\u003e outlierLists;\n\n    /**\n     * Unbelievably, outliers which are more than 2 * interquartile range are\n     * called far outs...  See Tukey EDA  (a classic one of a kind...)\n     */\n    private boolean highFarOut \u003d false;\n\n    /**\n     * A flag that indicates whether or not the collection contains low far\n     * out values.\n     */\n    private boolean lowFarOut \u003d false;\n\n    /**\n     * Creates a new empty collection.\n     */\n    public OutlierListCollection() {\n        this.outlierLists \u003d new ArrayList\u003c\u003e();\n    }\n\n    /**\n     * A flag to indicate the presence of one or more far out values at the\n     * top end of the range.\n     *\n     * @return A {@code boolean}.\n     */\n    public boolean isHighFarOut() {\n        return this.highFarOut;\n    }\n\n    /**\n     * Sets the flag that indicates the presence of one or more far out values\n     * at the top end of the range.\n     *\n     * @param farOut  the flag.\n     */\n    public void setHighFarOut(boolean farOut) {\n        this.highFarOut \u003d farOut;\n    }\n\n    /**\n     * A flag to indicate the presence of one or more far out values at the\n     * bottom end of the range.\n     *\n     * @return A {@code boolean}.\n     */\n    public boolean isLowFarOut() {\n        return this.lowFarOut;\n    }\n\n    /**\n     * Sets the flag that indicates the presence of one or more far out values\n     * at the bottom end of the range.\n     *\n     * @param farOut  the flag.\n     */\n    public void setLowFarOut(boolean farOut) {\n        this.lowFarOut \u003d farOut;\n    }\n    /**\n     * Appends the specified element as a new {@code OutlierList} to the\n     * end of this list if it does not overlap an outlier in an existing list.\n     *\n     * If it does overlap, it is appended to the outlier list which it overlaps\n     * and that list is updated.\n     *\n     * @param outlier  element to be appended to this list.\n     *\n     * @return {@code true} (as per the general contract of Collection.add).\n     */\n    public boolean add(Outlier outlier) {\n        if (this.outlierLists.isEmpty()) {\n            return this.outlierLists.add(new OutlierList(outlier));\n        } else {\n            boolean updated \u003d false;\n            for (OutlierList list : this.outlierLists) {\n                if (list.isOverlapped(outlier)) {\n                    updated \u003d updateOutlierList(list, outlier);\n                }\n            }\n            if (!updated) {\n                updated \u003d this.outlierLists.add(new OutlierList(outlier));\n            }\n            return updated;\n        }\n    }\n\n    /**\n     * Returns an iterator for the outlier lists.\n     *\n     * @return An iterator.\n     */\n    public Iterator\u003cOutlierList\u003e iterator() {\n        return this.outlierLists.iterator();\n    }\n\n\n    /**\n     * Updates the outlier list by adding the outlier to the end of the list and\n     * setting the averaged outlier to the average x and y coordinate values\n     * of the outliers in the list.\n     *\n     * @param list  the outlier list to be updated.\n     * @param outlier  the outlier to be added\n     *\n     * @return \u003ctt\u003etrue\u003c/tt\u003e (as per the general contract of Collection.add).\n     */\n    private boolean updateOutlierList(OutlierList list, Outlier outlier) {\n        boolean result \u003d list.add(outlier);\n        list.updateAveragedOutlier();\n        list.setMultiple(true);\n        return result;\n    }\n\n}","methodCount":8,"staticMethodCount":0,"instanceMethodCount":8,"classLoc":129,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":1,"candidates":[{"lineStart":154,"lineEnd":169,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method updateOutlierList to class OutlierList","description":"Move method updateOutlierList to org.jfree.chart.renderer.OutlierList\nRationale: The method updateOutlierList directly manipulates the OutlierList class, which includes adding an Outlier, updating the averaged outlier, and setting the multiple flag. Since it operates on the core functionalities of the OutlierList class, it makes more sense for it to reside within OutlierList. This ensures encapsulation and that all related functionalities are maintained within a single class, promoting better code organization and maintainability.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false,"userRating":"Very Helpful"}]},"userSelectionTelemetryData":{"lineStart":154,"lineEnd":169,"functionSize":16,"positionInHostFunction":110,"selectedCandidateIndex":0,"candidateType":"AS_IS","elementsType":[{"elementType":"METHOD","quantity":1}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":154369}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":8951},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"add","method_signature":"public add(Outlier outlier)","target_class":"","rationale":""},{"method_name":"updateOutlierList","method_signature":"private updateOutlierList(OutlierList list, Outlier outlier)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"add","method_signature":"public add(Outlier outlier)","target_class":"","rationale":""},{"method_name":"updateOutlierList","method_signature":"private updateOutlierList(OutlierList list, Outlier outlier)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public add(Outlier outlier)":{"first":{"method_name":"add","method_signature":"public add(Outlier outlier)","target_class":"","rationale":""},"second":0.6624609340663695},"private updateOutlierList(OutlierList list, Outlier outlier)":{"first":{"method_name":"updateOutlierList","method_signature":"private updateOutlierList(OutlierList list, Outlier outlier)","target_class":"","rationale":""},"second":0.713227910440244}},"targetClassMap":{"add":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":4678,"similarity_computation_time":0,"similarity_metric":"cosine"},"updateOutlierList":{"target_classes":[{"class_name":"OutlierList","similarity_score":0.7140240603554819},{"class_name":"Outlier","similarity_score":0.759199192484853}],"target_classes_sorted_by_llm":["OutlierList","Outlier"],"llm_response_time":3864,"similarity_computation_time":1,"similarity_metric":"cosine"}}}
{"id":"3f7ed400-40c0-403e-bfbd-7dff376ad9a9","hostFunctionTelemetryData":{"hostFunctionSize":264,"lineStart":44,"lineEnd":307,"bodyLineStart":44,"language":"java","filePath":"/Users/snehil/Documents/ConcordiaUniversity/Material/SOEN-6491-Refactoring/OpenSource/jfreechart/jfreechart/src/main/java/org/jfree/data/general/WaferMapDataset.java","sourceCode":"/**\n * A dataset that can be used with the {@link org.jfree.chart.plot.WaferMapPlot}\n * class.\n */\npublic class WaferMapDataset extends AbstractDataset {\n\n    /**\n     * Storage structure for the data values (row key is chipx, column is\n     * chipy)\n     */\n    private DefaultKeyedValues2D data;\n\n    /** wafer x dimension */\n    private int maxChipX;\n\n    /** wafer y dimension */\n    private int maxChipY;\n\n    /** space to draw between chips */\n    private double chipSpace;\n\n    /** maximum value in this dataset */\n    private Double maxValue;\n\n    /** minimum value in this dataset */\n    private Double minValue;\n\n    /** default chip spacing */\n    private static final double DEFAULT_CHIP_SPACE \u003d 1d;\n\n    /**\n     * Creates a new dataset using the default chipspace.\n     *\n     * @param maxChipX  the wafer x-dimension.\n     * @param maxChipY  the wafer y-dimension.\n     */\n    public WaferMapDataset(int maxChipX, int maxChipY) {\n        this(maxChipX, maxChipY, null);\n    }\n\n    /**\n     * Creates a new dataset.\n     *\n     * @param maxChipX  the wafer x-dimension.\n     * @param maxChipY  the wafer y-dimension.\n     * @param chipSpace  the space between chips.\n     */\n    public WaferMapDataset(int maxChipX, int maxChipY, Number chipSpace) {\n\n        this.maxValue \u003d Double.NEGATIVE_INFINITY;\n        this.minValue \u003d Double.POSITIVE_INFINITY;\n        this.data \u003d new DefaultKeyedValues2D();\n\n        this.maxChipX \u003d maxChipX;\n        this.maxChipY \u003d maxChipY;\n        if (chipSpace \u003d\u003d null) {\n            this.chipSpace \u003d DEFAULT_CHIP_SPACE;\n        }\n        else {\n            this.chipSpace \u003d chipSpace.doubleValue();\n        }\n\n    }\n\n    /**\n     * Sets a value in the dataset.\n     *\n     * @param value  the value.\n     * @param chipx  the x-index for the chip.\n     * @param chipy  the y-index for the chip.\n     */\n    public void addValue(Number value, Comparable chipx, Comparable chipy) {\n        setValue(value, chipx, chipy);\n    }\n\n    /**\n     * Adds a value to the dataset.\n     *\n     * @param v  the value.\n     * @param x  the x-index.\n     * @param y  the y-index.\n     */\n    public void addValue(int v, int x, int y) {\n        setValue((double) v, x, y);\n    }\n\n    /**\n     * Sets a value in the dataset and updates min and max value entries.\n     *\n     * @param value  the value.\n     * @param chipx  the x-index.\n     * @param chipy  the y-index.\n     */\n    public void setValue(Number value, Comparable chipx, Comparable chipy) {\n        this.data.setValue(value, chipx, chipy);\n        if (isMaxValue(value)) {\n            this.maxValue \u003d (Double) value;\n        }\n        if (isMinValue(value)) {\n            this.minValue \u003d (Double) value;\n        }\n    }\n\n    /**\n     * Returns the number of unique values.\n     *\n     * @return The number of unique values.\n     */\n    public int getUniqueValueCount() {\n        return getUniqueValues().size();\n    }\n\n    /**\n     * Returns the set of unique values.\n     *\n     * @return The set of unique values.\n     */\n    public Set getUniqueValues() {\n        Set unique \u003d new TreeSet();\n        //step through all the values and add them to the hash\n        for (int r \u003d 0; r \u003c this.data.getRowCount(); r++) {\n            for (int c \u003d 0; c \u003c this.data.getColumnCount(); c++) {\n                Number value \u003d this.data.getValue(r, c);\n                if (value !\u003d null) {\n                    unique.add(value);\n                }\n            }\n        }\n        return unique;\n    }\n\n    /**\n     * Returns the data value for a chip.\n     *\n     * @param chipx  the x-index.\n     * @param chipy  the y-index.\n     *\n     * @return The data value.\n     */\n    public Number getChipValue(int chipx, int chipy) {\n        return getChipValue(Integer.valueOf(chipx), Integer.valueOf(chipy));\n    }\n\n    /**\n     * Returns the value for a given chip x and y or null.\n     *\n     * @param chipx  the x-index.\n     * @param chipy  the y-index.\n     *\n     * @return The data value.\n     */\n    public Number getChipValue(Comparable chipx, Comparable chipy) {\n        int rowIndex \u003d this.data.getRowIndex(chipx);\n        if (rowIndex \u003c 0) {\n            return null;\n        }\n        int colIndex \u003d this.data.getColumnIndex(chipy);\n        if (colIndex \u003c 0) {\n            return null;\n        }\n        return this.data.getValue(rowIndex, colIndex);\n    }\n\n    /**\n     * Tests to see if the passed value is larger than the stored maxvalue.\n     *\n     * @param check  the number to check.\n     *\n     * @return A boolean.\n     */\n    public boolean isMaxValue(Number check) {\n        if (check.doubleValue() \u003e this.maxValue) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Tests to see if the passed value is smaller than the stored minvalue.\n     *\n     * @param check  the number to check.\n     *\n     * @return A boolean.\n     */\n    public boolean isMinValue(Number check) {\n        if (check.doubleValue() \u003c this.minValue) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Returns the maximum value stored in the dataset.\n     *\n     * @return The maximum value.\n     */\n    public Number getMaxValue() {\n        return this.maxValue;\n    }\n\n    /**\n     * Returns the minimum value stored in the dataset.\n     *\n     * @return The minimum value.\n     */\n    public Number getMinValue() {\n        return this.minValue;\n    }\n\n    /**\n     * Returns the wafer x-dimension.\n     *\n     * @return The number of chips in the x-dimension.\n     */\n    public int getMaxChipX() {\n        return this.maxChipX;\n    }\n\n    /**\n     * Sets wafer x dimension.\n     *\n     * @param maxChipX  the number of chips in the x-dimension.\n     */\n    public void setMaxChipX(int maxChipX) {\n        this.maxChipX \u003d maxChipX;\n    }\n\n    /**\n     * Returns the number of chips in the y-dimension.\n     *\n     * @return The number of chips.\n     */\n    public int getMaxChipY() {\n        return this.maxChipY;\n    }\n\n    /**\n     * Sets the number of chips in the y-dimension.\n     *\n     * @param maxChipY  the number of chips.\n     */\n    public void setMaxChipY(int maxChipY) {\n        this.maxChipY \u003d maxChipY;\n    }\n\n    /**\n     * Returns the space to draw between chips.\n     *\n     * @return The space.\n     */\n    public double getChipSpace() {\n        return this.chipSpace;\n    }\n\n    /**\n     * Sets the space to draw between chips.\n     *\n     * @param space  the space.\n     */\n    public void setChipSpace(double space) {\n        this.chipSpace \u003d space;\n    }\n\n}","methodCount":19,"staticMethodCount":0,"instanceMethodCount":19,"classLoc":264,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":1,"candidates":[{"lineStart":186,"lineEnd":204,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method getChipValue to class DefaultKeyedValues2D","description":"Move method getChipValue to org.jfree.data.DefaultKeyedValues2D\nRationale: The getChipValue() method is heavily dependent on the data structure to fetch row and column indices, and retrieve the corresponding value. Since DefaultKeyedValues2D already handles similar functionality with methods like getValue(int, int), getRowIndex(Comparable), and getColumnIndex(Comparable), moving getChipValue() to DefaultKeyedValues2D aligns it with the other data access operations that this class is designed to handle. Moreover, DefaultKeyedValues2D maintains the integrity and encapsulation of the data structure, making it the most appropriate location for this method.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false,"userRating":"Very Helpful"}]},"userSelectionTelemetryData":{"lineStart":186,"lineEnd":204,"functionSize":19,"positionInHostFunction":142,"selectedCandidateIndex":0,"candidateType":"AS_IS","elementsType":[{"elementType":"METHOD","quantity":1}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":107922}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":10003},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"setValue","method_signature":"public setValue(Number value, Comparable chipx, Comparable chipy)","target_class":"","rationale":""},{"method_name":"getChipValue","method_signature":"public getChipValue(Comparable chipx, Comparable chipy)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"setValue","method_signature":"public setValue(Number value, Comparable chipx, Comparable chipy)","target_class":"","rationale":""},{"method_name":"getChipValue","method_signature":"public getChipValue(Comparable chipx, Comparable chipy)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public setValue(Number value, Comparable chipx, Comparable chipy)":{"first":{"method_name":"setValue","method_signature":"public setValue(Number value, Comparable chipx, Comparable chipy)","target_class":"","rationale":""},"second":0.7533459306339886},"public getChipValue(Comparable chipx, Comparable chipy)":{"first":{"method_name":"getChipValue","method_signature":"public getChipValue(Comparable chipx, Comparable chipy)","target_class":"","rationale":""},"second":0.7958348603970249}},"targetClassMap":{"setValue":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5189,"similarity_computation_time":0,"similarity_metric":"cosine"},"getChipValue":{"target_classes":[{"class_name":"DefaultKeyedValues2D","similarity_score":0.7820778974783874}],"target_classes_sorted_by_llm":["DefaultKeyedValues2D"],"llm_response_time":4733,"similarity_computation_time":1,"similarity_metric":"cosine"}}}
{"id":"dd92ec0f-de55-472f-ba3f-06f1f3a6283b","hostFunctionTelemetryData":{"hostFunctionSize":355,"lineStart":47,"lineEnd":401,"bodyLineStart":47,"language":"java","filePath":"/Users/snehil/Documents/ConcordiaUniversity/Material/SOEN-6491-Refactoring/OpenSource/jfreechart/jfreechart/src/main/java/org/jfree/chart/axis/CategoryLabelPositions.java","sourceCode":"/**\n * Records the label positions for a category axis.  Instances of this class\n * are immutable.\n */\npublic class CategoryLabelPositions implements Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID \u003d -8999557901920364580L;\n\n    /** STANDARD category label positions. */\n    public static final CategoryLabelPositions\n        STANDARD \u003d new CategoryLabelPositions(\n            new CategoryLabelPosition(\n                RectangleAnchor.BOTTOM, TextBlockAnchor.BOTTOM_CENTER), // TOP\n            new CategoryLabelPosition(\n                RectangleAnchor.TOP, TextBlockAnchor.TOP_CENTER), // BOTTOM\n            new CategoryLabelPosition(\n                RectangleAnchor.RIGHT, TextBlockAnchor.CENTER_RIGHT,\n                CategoryLabelWidthType.RANGE, 0.30f), // LEFT\n            new CategoryLabelPosition(\n                RectangleAnchor.LEFT, TextBlockAnchor.CENTER_LEFT,\n                CategoryLabelWidthType.RANGE, 0.30f) // RIGHT\n        );\n\n    /** UP_90 category label positions. */\n    public static final CategoryLabelPositions\n        UP_90 \u003d new CategoryLabelPositions(\n            new CategoryLabelPosition(\n                RectangleAnchor.BOTTOM, TextBlockAnchor.CENTER_LEFT,\n                TextAnchor.CENTER_LEFT, -Math.PI / 2.0,\n                CategoryLabelWidthType.RANGE, 0.30f), // TOP\n            new CategoryLabelPosition(\n                RectangleAnchor.TOP, TextBlockAnchor.CENTER_RIGHT,\n                TextAnchor.CENTER_RIGHT, -Math.PI / 2.0,\n                CategoryLabelWidthType.RANGE, 0.30f), // BOTTOM\n            new CategoryLabelPosition(\n                RectangleAnchor.RIGHT, TextBlockAnchor.BOTTOM_CENTER,\n                TextAnchor.BOTTOM_CENTER, -Math.PI / 2.0,\n                CategoryLabelWidthType.CATEGORY, 0.9f), // LEFT\n            new CategoryLabelPosition(\n                RectangleAnchor.LEFT, TextBlockAnchor.TOP_CENTER,\n                TextAnchor.TOP_CENTER, -Math.PI / 2.0,\n                CategoryLabelWidthType.CATEGORY, 0.90f) // RIGHT\n        );\n\n    /** DOWN_90 category label positions. */\n    public static final CategoryLabelPositions\n        DOWN_90 \u003d new CategoryLabelPositions(\n            new CategoryLabelPosition(\n                RectangleAnchor.BOTTOM, TextBlockAnchor.CENTER_RIGHT,\n                TextAnchor.CENTER_RIGHT, Math.PI / 2.0,\n                CategoryLabelWidthType.RANGE, 0.30f), // TOP\n            new CategoryLabelPosition(\n                RectangleAnchor.TOP, TextBlockAnchor.CENTER_LEFT,\n                TextAnchor.CENTER_LEFT, Math.PI / 2.0,\n                CategoryLabelWidthType.RANGE, 0.30f), // BOTTOM\n            new CategoryLabelPosition(\n                RectangleAnchor.RIGHT, TextBlockAnchor.TOP_CENTER,\n                TextAnchor.TOP_CENTER, Math.PI / 2.0,\n                CategoryLabelWidthType.CATEGORY, 0.90f), // LEFT\n            new CategoryLabelPosition(\n                RectangleAnchor.LEFT, TextBlockAnchor.BOTTOM_CENTER,\n                TextAnchor.BOTTOM_CENTER, Math.PI / 2.0,\n                CategoryLabelWidthType.CATEGORY, 0.90f) // RIGHT\n        );\n\n    /** UP_45 category label positions. */\n    public static final CategoryLabelPositions UP_45\n        \u003d createUpRotationLabelPositions(Math.PI / 4.0);\n\n    /** DOWN_45 category label positions. */\n    public static final CategoryLabelPositions DOWN_45\n        \u003d createDownRotationLabelPositions(Math.PI / 4.0);\n\n    /**\n     * Creates a new instance where the category labels angled upwards by the\n     * specified amount.\n     *\n     * @param angle  the rotation angle (should be \u0026lt; Math.PI / 2.0).\n     *\n     * @return A category label position specification.\n     */\n    public static CategoryLabelPositions createUpRotationLabelPositions(\n            double angle) {\n        return new CategoryLabelPositions(\n            new CategoryLabelPosition(\n                RectangleAnchor.BOTTOM, TextBlockAnchor.BOTTOM_LEFT,\n                TextAnchor.BOTTOM_LEFT, -angle,\n                CategoryLabelWidthType.RANGE, 0.50f), // TOP\n            new CategoryLabelPosition(\n                RectangleAnchor.TOP, TextBlockAnchor.TOP_RIGHT,\n                TextAnchor.TOP_RIGHT, -angle,\n                CategoryLabelWidthType.RANGE, 0.50f), // BOTTOM\n            new CategoryLabelPosition(\n                RectangleAnchor.RIGHT, TextBlockAnchor.BOTTOM_RIGHT,\n                TextAnchor.BOTTOM_RIGHT, -angle,\n                CategoryLabelWidthType.RANGE, 0.50f), // LEFT\n            new CategoryLabelPosition(\n                RectangleAnchor.LEFT, TextBlockAnchor.TOP_LEFT,\n                TextAnchor.TOP_LEFT, -angle,\n                CategoryLabelWidthType.RANGE, 0.50f) // RIGHT\n        );\n    }\n\n    /**\n     * Creates a new instance where the category labels angled downwards by the\n     * specified amount.\n     *\n     * @param angle  the rotation angle (should be \u0026lt; Math.PI / 2.0).\n     *\n     * @return A category label position specification.\n     */\n    public static CategoryLabelPositions createDownRotationLabelPositions(\n            double angle) {\n        return new CategoryLabelPositions(\n            new CategoryLabelPosition(\n                RectangleAnchor.BOTTOM, TextBlockAnchor.BOTTOM_RIGHT,\n                TextAnchor.BOTTOM_RIGHT, angle,\n                CategoryLabelWidthType.RANGE, 0.50f), // TOP\n            new CategoryLabelPosition(\n                RectangleAnchor.TOP, TextBlockAnchor.TOP_LEFT,\n                TextAnchor.TOP_LEFT, angle,\n                CategoryLabelWidthType.RANGE, 0.50f), // BOTTOM\n            new CategoryLabelPosition(\n                RectangleAnchor.RIGHT, TextBlockAnchor.TOP_RIGHT,\n                TextAnchor.TOP_RIGHT, angle,\n                CategoryLabelWidthType.RANGE, 0.50f), // LEFT\n            new CategoryLabelPosition(\n                RectangleAnchor.LEFT, TextBlockAnchor.BOTTOM_LEFT,\n                TextAnchor.BOTTOM_LEFT, angle,\n                CategoryLabelWidthType.RANGE, 0.50f) // RIGHT\n        );\n    }\n\n    /**\n     * The label positioning details used when an axis is at the top of a\n     * chart.\n     */\n    private final CategoryLabelPosition positionForAxisAtTop;\n\n    /**\n     * The label positioning details used when an axis is at the bottom of a\n     * chart.\n     */\n    private final CategoryLabelPosition positionForAxisAtBottom;\n\n    /**\n     * The label positioning details used when an axis is at the left of a\n     * chart.\n     */\n    private final CategoryLabelPosition positionForAxisAtLeft;\n\n    /**\n     * The label positioning details used when an axis is at the right of a\n     * chart.\n     */\n    private final CategoryLabelPosition positionForAxisAtRight;\n\n    /**\n     * Default constructor.\n     */\n    public CategoryLabelPositions() {\n        this.positionForAxisAtTop \u003d new CategoryLabelPosition();\n        this.positionForAxisAtBottom \u003d new CategoryLabelPosition();\n        this.positionForAxisAtLeft \u003d new CategoryLabelPosition();\n        this.positionForAxisAtRight \u003d new CategoryLabelPosition();\n    }\n\n    /**\n     * Creates a new position specification.\n     *\n     * @param top  the label position info used when an axis is at the top\n     *             ({@code null} not permitted).\n     * @param bottom  the label position info used when an axis is at the\n     *                bottom ({@code null} not permitted).\n     * @param left  the label position info used when an axis is at the left\n     *              ({@code null} not permitted).\n     * @param right  the label position info used when an axis is at the right\n     *               ({@code null} not permitted).\n     */\n    public CategoryLabelPositions(CategoryLabelPosition top,\n            CategoryLabelPosition bottom, CategoryLabelPosition left,\n            CategoryLabelPosition right) {\n\n        Args.nullNotPermitted(top, \"top\");\n        Args.nullNotPermitted(bottom, \"bottom\");\n        Args.nullNotPermitted(left, \"left\");\n        Args.nullNotPermitted(right, \"right\");\n\n        this.positionForAxisAtTop \u003d top;\n        this.positionForAxisAtBottom \u003d bottom;\n        this.positionForAxisAtLeft \u003d left;\n        this.positionForAxisAtRight \u003d right;\n    }\n\n    /**\n     * Returns the category label position specification for an axis at the\n     * given location.\n     *\n     * @param edge  the axis location.\n     *\n     * @return The category label position specification.\n     */\n    public CategoryLabelPosition getLabelPosition(RectangleEdge edge) {\n        CategoryLabelPosition result \u003d null;\n        if (edge \u003d\u003d RectangleEdge.TOP) {\n            result \u003d this.positionForAxisAtTop;\n        }\n        else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n            result \u003d this.positionForAxisAtBottom;\n        }\n        else if (edge \u003d\u003d RectangleEdge.LEFT) {\n            result \u003d this.positionForAxisAtLeft;\n        }\n        else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n            result \u003d this.positionForAxisAtRight;\n        }\n        return result;\n    }\n\n    /**\n     * Returns a new instance based on an existing instance but with the top\n     * position changed.\n     *\n     * @param base  the base ({@code null} not permitted).\n     * @param top  the top position ({@code null} not permitted).\n     *\n     * @return A new instance (never {@code null}).\n     */\n    public static CategoryLabelPositions replaceTopPosition(\n            CategoryLabelPositions base, CategoryLabelPosition top) {\n\n        Args.nullNotPermitted(base, \"base\");\n        Args.nullNotPermitted(top, \"top\");\n\n        return new CategoryLabelPositions(top,\n            base.getLabelPosition(RectangleEdge.BOTTOM),\n            base.getLabelPosition(RectangleEdge.LEFT),\n            base.getLabelPosition(RectangleEdge.RIGHT));\n    }\n\n    /**\n     * Returns a new instance based on an existing instance but with the bottom\n     * position changed.\n     *\n     * @param base  the base ({@code null} not permitted).\n     * @param bottom  the bottom position ({@code null} not permitted).\n     *\n     * @return A new instance (never {@code null}).\n     */\n    public static CategoryLabelPositions replaceBottomPosition(\n            CategoryLabelPositions base, CategoryLabelPosition bottom) {\n\n        Args.nullNotPermitted(base, \"base\");\n        Args.nullNotPermitted(bottom, \"bottom\");\n\n        return new CategoryLabelPositions(\n            base.getLabelPosition(RectangleEdge.TOP),\n            bottom,\n            base.getLabelPosition(RectangleEdge.LEFT),\n            base.getLabelPosition(RectangleEdge.RIGHT));\n    }\n\n    /**\n     * Returns a new instance based on an existing instance but with the left\n     * position changed.\n     *\n     * @param base  the base ({@code null} not permitted).\n     * @param left  the left position ({@code null} not permitted).\n     *\n     * @return A new instance (never {@code null}).\n     */\n    public static CategoryLabelPositions replaceLeftPosition(\n            CategoryLabelPositions base, CategoryLabelPosition left) {\n\n        Args.nullNotPermitted(base, \"base\");\n        Args.nullNotPermitted(left, \"left\");\n\n        return new CategoryLabelPositions(\n            base.getLabelPosition(RectangleEdge.TOP),\n            base.getLabelPosition(RectangleEdge.BOTTOM),\n            left,\n            base.getLabelPosition(RectangleEdge.RIGHT));\n    }\n\n    /**\n     * Returns a new instance based on an existing instance but with the right\n     * position changed.\n     *\n     * @param base  the base ({@code null} not permitted).\n     * @param right  the right position ({@code null} not permitted).\n     *\n     * @return A new instance (never {@code null}).\n     */\n    public static CategoryLabelPositions replaceRightPosition(\n            CategoryLabelPositions base, CategoryLabelPosition right) {\n\n        Args.nullNotPermitted(base, \"base\");\n        Args.nullNotPermitted(right, \"right\");\n        return new CategoryLabelPositions(\n            base.getLabelPosition(RectangleEdge.TOP),\n            base.getLabelPosition(RectangleEdge.BOTTOM),\n            base.getLabelPosition(RectangleEdge.LEFT),\n            right);\n    }\n\n    /**\n     * Returns {@code true} if this object is equal to the specified\n     * object, and {@code false} otherwise.\n     *\n     * @param obj  the other object.\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (this \u003d\u003d obj) {\n            return true;\n        }\n        if (!(obj instanceof CategoryLabelPositions)) {\n            return false;\n        }\n\n        CategoryLabelPositions that \u003d (CategoryLabelPositions) obj;\n        if (!this.positionForAxisAtTop.equals(that.positionForAxisAtTop)) {\n            return false;\n        }\n        if (!this.positionForAxisAtBottom.equals(\n                that.positionForAxisAtBottom)) {\n            return false;\n        }\n        if (!this.positionForAxisAtLeft.equals(that.positionForAxisAtLeft)) {\n            return false;\n        }\n        if (!this.positionForAxisAtRight.equals(that.positionForAxisAtRight)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code for this object.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d 19;\n        result \u003d 37 * result + this.positionForAxisAtTop.hashCode();\n        result \u003d 37 * result + this.positionForAxisAtBottom.hashCode();\n        result \u003d 37 * result + this.positionForAxisAtLeft.hashCode();\n        result \u003d 37 * result + this.positionForAxisAtRight.hashCode();\n        return result;\n    }\n}","methodCount":11,"staticMethodCount":6,"instanceMethodCount":5,"classLoc":355,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":3,"candidates":[{"lineStart":266,"lineEnd":285,"refactoringType":"MyMoveStaticMethodRefactoring","refactoringInfo":"Move Static method replaceTopPosition to class CategoryLabelPosition","description":"move method replaceTopPosition to PsiClass:CategoryLabelPosition\nRationale: The method `replaceTopPosition` deals directly with the replacement of a label position within `CategoryLabelPositions` by modifying the `top` position, which is directly related to the `CategoryLabelPosition` class\u0027 core responsibility. The `CategoryLabelPosition` already contains methods and properties related to setting different positions for labels, making it the most fitting place for such a method.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Somewhat Helpful"},{"lineStart":287,"lineEnd":307,"refactoringType":"MyMoveStaticMethodRefactoring","refactoringInfo":"Move Static method replaceBottomPosition to class CategoryLabelPosition","description":"move method replaceBottomPosition to PsiClass:CategoryLabelPosition\nRationale: The method `replaceBottomPosition` is directly related to manipulating `CategoryLabelPosition` objects and creating a new instance of `CategoryLabelPositions` with a modified bottom label position. This operation pertains to the layout and positioning of category labels, which is the primary concern of the `CategoryLabelPosition` class. Moving the method here consolidates all label positioning logic in one place, thereby enhancing cohesiveness and maintaining the integrity of the class design principles.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Somewhat Helpful"},{"lineStart":309,"lineEnd":329,"refactoringType":"MyMoveStaticMethodRefactoring","refactoringInfo":"Move Static method replaceLeftPosition to class CategoryLabelPosition","description":"move method replaceLeftPosition to PsiClass:CategoryLabelPosition\nRationale: The method replaceLeftPosition() returns a new instance of CategoryLabelPositions based on modifications to a CategoryLabelPosition object. It manipulates CategoryLabelPosition instances and is tightly coupled with their logic. Moving this method to CategoryLabelPosition makes sense because it directly relates to and extends the functionality of CategoryLabelPosition objects.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Somewhat Helpful"}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":87280},{"candidateIndex":1,"elapsedTime":4411},{"candidateIndex":2,"elapsedTime":7498}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":27039},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"replaceTopPosition","method_signature":"public static replaceTopPosition(\n            CategoryLabelPositions base, CategoryLabelPosition top)","target_class":"","rationale":""},{"method_name":"replaceBottomPosition","method_signature":"public static replaceBottomPosition(\n            CategoryLabelPositions base, CategoryLabelPosition bottom)","target_class":"","rationale":""},{"method_name":"replaceLeftPosition","method_signature":"public static replaceLeftPosition(\n            CategoryLabelPositions base, CategoryLabelPosition left)","target_class":"","rationale":""},{"method_name":"replaceRightPosition","method_signature":"public static replaceRightPosition(\n            CategoryLabelPositions base, CategoryLabelPosition right)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"replaceTopPosition","method_signature":"public static replaceTopPosition(\n            CategoryLabelPositions base, CategoryLabelPosition top)","target_class":"","rationale":""},{"method_name":"replaceBottomPosition","method_signature":"public static replaceBottomPosition(\n            CategoryLabelPositions base, CategoryLabelPosition bottom)","target_class":"","rationale":""},{"method_name":"replaceLeftPosition","method_signature":"public static replaceLeftPosition(\n            CategoryLabelPositions base, CategoryLabelPosition left)","target_class":"","rationale":""},{"method_name":"replaceRightPosition","method_signature":"public static replaceRightPosition(\n            CategoryLabelPositions base, CategoryLabelPosition right)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public static replaceTopPosition(\n            CategoryLabelPositions base, CategoryLabelPosition top)":{"first":{"method_name":"replaceTopPosition","method_signature":"public static replaceTopPosition(\n            CategoryLabelPositions base, CategoryLabelPosition top)","target_class":"","rationale":""},"second":0.756707650856262},"public static replaceBottomPosition(\n            CategoryLabelPositions base, CategoryLabelPosition bottom)":{"first":{"method_name":"replaceBottomPosition","method_signature":"public static replaceBottomPosition(\n            CategoryLabelPositions base, CategoryLabelPosition bottom)","target_class":"","rationale":""},"second":0.7594985779589156},"public static replaceLeftPosition(\n            CategoryLabelPositions base, CategoryLabelPosition left)":{"first":{"method_name":"replaceLeftPosition","method_signature":"public static replaceLeftPosition(\n            CategoryLabelPositions base, CategoryLabelPosition left)","target_class":"","rationale":""},"second":0.7594985779589156},"public static replaceRightPosition(\n            CategoryLabelPositions base, CategoryLabelPosition right)":{"first":{"method_name":"replaceRightPosition","method_signature":"public static replaceRightPosition(\n            CategoryLabelPositions base, CategoryLabelPosition right)","target_class":"","rationale":""},"second":0.7594985779589156}},"targetClassMap":{"replaceTopPosition":{"target_classes":[{"class_name":"LineUtils","similarity_score":0.38235372775473475},{"class_name":"ExportUtils","similarity_score":0.6014267969747461},{"class_name":"EncoderUtil","similarity_score":0.5282585894985207},{"class_name":"HashUtils","similarity_score":0.6339401714756494},{"class_name":"CloneUtils","similarity_score":0.5916444609061859},{"class_name":"RendererUtils","similarity_score":0.3728942744521448},{"class_name":"RendererXYPackageUtils","similarity_score":0.4498669229602721},{"class_name":"ImageMapUtils","similarity_score":0.6670959477807669},{"class_name":"TestUtils","similarity_score":0.4559626604089598},{"class_name":"TextUtils","similarity_score":0.5897434603847396},{"class_name":"ShapeUtils","similarity_score":0.6722609954918499},{"class_name":"SerialUtils","similarity_score":0.5423013402084842},{"class_name":"AttrStringUtils","similarity_score":0.536178169775797},{"class_name":"UIUtils","similarity_score":0.6104007298602714},{"class_name":"ArrayUtils","similarity_score":0.47044636662741396},{"class_name":"PaintUtils","similarity_score":0.45077525068889446},{"class_name":"StringUtils","similarity_score":0.5782197896276667},{"class_name":"JSONUtils","similarity_score":0.5811690262487655},{"class_name":"DatasetUtils","similarity_score":0.5603905235142501},{"class_name":"FlowDatasetUtils","similarity_score":0.5925733515413276},{"class_name":"AttributedStringUtils","similarity_score":0.377917773253318},{"class_name":"LineUtilsTest","similarity_score":0.1238143085185992},{"class_name":"HashUtilsTest","similarity_score":0.2540837929778085},{"class_name":"ObjectWithMapOfPaint","similarity_score":0.1032318134468489},{"class_name":"ObjectWithMapOfStroke","similarity_score":0.1032318134468489},{"class_name":"SerialUtilsTest","similarity_score":0.1832485848776168},{"class_name":"ShapeUtilsTest","similarity_score":0.37216962512851526},{"class_name":"CloneUtilsTest","similarity_score":0.3959307181859459},{"class_name":"RendererUtilsTest","similarity_score":0.19359378175010986},{"class_name":"ImageMapUtilsTest","similarity_score":0.273392380570664},{"class_name":"DataUtilsTest","similarity_score":0.23822180928399705},{"class_name":"DatasetUtilsTest","similarity_score":0.29714988358071454},{"class_name":"Args","similarity_score":0.53782696656758},{"class_name":"PaintAlpha","similarity_score":0.6310401041736052},{"class_name":"ImageEncoderFactory","similarity_score":0.5525730354763054},{"class_name":"ChartEditorManager","similarity_score":0.6179435387903899},{"class_name":"MovingAverage","similarity_score":0.5249469333179847},{"class_name":"DatasetReader","similarity_score":0.6325832396982786},{"class_name":"ChartColor","similarity_score":0.35328655076318755},{"class_name":"NumberAxis","similarity_score":0.5755074930894724},{"class_name":"GanttChartTest","similarity_score":0.46801271946661926},{"class_name":"PieChartTest","similarity_score":0.5102291262093425},{"class_name":"JSONObject","similarity_score":0.6551299269043744},{"class_name":"DateTickUnit","similarity_score":0.6710332102698021},{"class_name":"DateAxis","similarity_score":0.5726425109025204},{"class_name":"MarkerAxisBand","similarity_score":0.5498341515361024},{"class_name":"MarkerAxisBandTest","similarity_score":0.16689409886074044},{"class_name":"CategoryAnchorTest","similarity_score":0.2891045563237118},{"class_name":"CategoryAxis","similarity_score":0.6644381968807551},{"class_name":"CategoryAxisTest","similarity_score":0.2048461655914735},{"class_name":"CategoryLabelPosition","similarity_score":0.6887190024131205},{"class_name":"CategoryLabelPositionsTest","similarity_score":0.25547684713325886},{"class_name":"CategoryLabelPositionTest","similarity_score":0.18939286664863605},{"class_name":"CategoryLabelWidthTypeTest","similarity_score":0.3136919210616374},{"class_name":"CategoryTick","similarity_score":0.5992871822748967},{"class_name":"CategoryTickTest","similarity_score":0.20234063313204814},{"class_name":"ExtendedCategoryAxis","similarity_score":0.6563038396128065},{"class_name":"ExtendedCategoryAxisTest","similarity_score":0.24696515960780477},{"class_name":"NumberAxisTest","similarity_score":0.2988641226972616},{"class_name":"LogarithmicAxis","similarity_score":0.4450377813667634},{"class_name":"LogarithmicAxisTest","similarity_score":0.3907581114627765},{"class_name":"LogAxis","similarity_score":0.5853962435774641},{"class_name":"LogAxisTest","similarity_score":0.33875224999182096},{"class_name":"NumberTick","similarity_score":0.6035011071168881},{"class_name":"NumberTickUnit","similarity_score":0.6267861435371729},{"class_name":"NumberTickUnitSource","similarity_score":0.2710418903995995},{"class_name":"NumberTickUnitTest","similarity_score":0.324879874589469},{"class_name":"LogTick","similarity_score":0.632299943843871},{"class_name":"AxisCollection","similarity_score":0.5180096315013587},{"class_name":"AxisLocationTest","similarity_score":0.28963356784814454},{"class_name":"AxisSpace","similarity_score":0.5451338779950718},{"class_name":"AxisSpaceTest","similarity_score":0.2691400850578561},{"class_name":"AxisState","similarity_score":0.5483044822401676},{"class_name":"AxisTest","similarity_score":0.10183107429663985},{"class_name":"ModuloAxis","similarity_score":0.5719427505465469},{"class_name":"ModuloAxisTest","similarity_score":0.3148568299398463},{"class_name":"MonthDateFormat","similarity_score":0.6545771422042024},{"class_name":"MonthDateFormatTest","similarity_score":0.24718417357136846},{"class_name":"DefaultTimeline","similarity_score":0.6388601267840877},{"class_name":"CyclicNumberAxis","similarity_score":0.5544568404496376},{"class_name":"CyclicNumberAxisTest","similarity_score":0.22517665519790112},{"class_name":"DateTick","similarity_score":0.6357812876987435},{"class_name":"CycleBoundTick","similarity_score":0.5699161819610755},{"class_name":"DateTickMarkPositionTest","similarity_score":0.2844435844500243},{"class_name":"DateTickTest","similarity_score":0.17030269182353527},{"class_name":"DateTickUnitTest","similarity_score":0.32251750938460555},{"class_name":"DateAxisTest","similarity_score":0.19280523228349428},{"class_name":"CompassFormat","similarity_score":0.5823575728486333},{"class_name":"MyDateAxis","similarity_score":0.4360070194091799},{"class_name":"MyLogarithmicAxis","similarity_score":0.49546252205588626},{"class_name":"PeriodAxis","similarity_score":0.598766374269804},{"class_name":"PeriodAxisLabelInfo","similarity_score":0.6620917585580188},{"class_name":"PeriodAxisLabelInfoTest","similarity_score":0.20544884665344684},{"class_name":"PeriodAxisTest","similarity_score":0.3131778017963438},{"class_name":"RelativeDateFormatTest","similarity_score":0.35228267904098093},{"class_name":"QuarterDateFormat","similarity_score":0.6433128588805314},{"class_name":"QuarterDateFormatTest","similarity_score":0.2511098047471192},{"class_name":"TickUnits","similarity_score":0.6311777071499766},{"class_name":"TickUnitsTest","similarity_score":0.3296817097484501},{"class_name":"SymbolAxis","similarity_score":0.5649445707881954}],"target_classes_sorted_by_llm":["CategoryLabelPosition","ShapeUtils","DateTickUnit"],"llm_response_time":4974,"similarity_computation_time":69,"similarity_metric":"cosine"},"replaceBottomPosition":{"target_classes":[{"class_name":"CloneUtils","similarity_score":0.5897078126301563},{"class_name":"LineUtils","similarity_score":0.38110215736640457},{"class_name":"TestUtils","similarity_score":0.45447014360442073},{"class_name":"HashUtils","similarity_score":0.6318650753303837},{"class_name":"EncoderUtil","similarity_score":0.5265294241733129},{"class_name":"ExportUtils","similarity_score":0.5994581278728074},{"class_name":"ImageMapUtils","similarity_score":0.6649123217983022},{"class_name":"RendererUtils","similarity_score":0.37167366798749035},{"class_name":"RendererXYPackageUtils","similarity_score":0.44839435952334},{"class_name":"TextUtils","similarity_score":0.5865610367690264},{"class_name":"ShapeUtils","similarity_score":0.6700604625975384},{"class_name":"SerialUtils","similarity_score":0.5405262083091763},{"class_name":"AttrStringUtils","similarity_score":0.5344230810413388},{"class_name":"UIUtils","similarity_score":0.6084026861037888},{"class_name":"ArrayUtils","similarity_score":0.4689064398553489},{"class_name":"PaintUtils","similarity_score":0.44929971399446417},{"class_name":"StringUtils","similarity_score":0.5763270847470471},{"class_name":"JSONUtils","similarity_score":0.5792666675398838},{"class_name":"DatasetUtils","similarity_score":0.5585561797267582},{"class_name":"FlowDatasetUtils","similarity_score":0.590633662698596},{"class_name":"AttributedStringUtils","similarity_score":0.3766807232132804},{"class_name":"CloneUtilsTest","similarity_score":0.39463470581117},{"class_name":"LineUtilsTest","similarity_score":0.12340902327892486},{"class_name":"SerialUtilsTest","similarity_score":0.18264875156650195},{"class_name":"ShapeUtilsTest","similarity_score":0.3709513906811044},{"class_name":"HashUtilsTest","similarity_score":0.2532520925696209},{"class_name":"ImageMapUtilsTest","similarity_score":0.2724974767601882},{"class_name":"ObjectWithMapOfPaint","similarity_score":0.1028939015305655},{"class_name":"ObjectWithMapOfStroke","similarity_score":0.1028939015305655},{"class_name":"RendererUtilsTest","similarity_score":0.1929600851832525},{"class_name":"DatasetUtilsTest","similarity_score":0.2961772135942879},{"class_name":"DataUtilsTest","similarity_score":0.23744203040200448},{"class_name":"Args","similarity_score":0.536066480775133},{"class_name":"ImageEncoderFactory","similarity_score":0.5507642809163512},{"class_name":"PaintAlpha","similarity_score":0.6289745009091352},{"class_name":"ChartEditorManager","similarity_score":0.6159208049220645},{"class_name":"DatasetReader","similarity_score":0.6305125852401423},{"class_name":"JSONValue","similarity_score":0.5071373634841698},{"class_name":"MovingAverage","similarity_score":0.5232286081402923},{"class_name":"ChartColor","similarity_score":0.3521301268723392},{"class_name":"NumberAxis","similarity_score":0.573623666453748},{"class_name":"PieChartTest","similarity_score":0.5085589772889251},{"class_name":"GanttChartTest","similarity_score":0.4664807588277471},{"class_name":"JSONObject","similarity_score":0.6465940947643803},{"class_name":"DateTickUnit","similarity_score":0.6688366963231706},{"class_name":"DateAxis","similarity_score":0.5707680623023897},{"class_name":"CategoryAnchorTest","similarity_score":0.2881582213580483},{"class_name":"CategoryAxis","similarity_score":0.6622632705972461},{"class_name":"CategoryAxisTest","similarity_score":0.20417563624545984},{"class_name":"CategoryLabelPosition","similarity_score":0.6864645970111847},{"class_name":"CategoryLabelPositionsTest","similarity_score":0.26671840119098855},{"class_name":"CategoryLabelPositionTest","similarity_score":0.18877292106826907},{"class_name":"CategoryLabelWidthTypeTest","similarity_score":0.3126651035077335},{"class_name":"CategoryTick","similarity_score":0.5973255168405213},{"class_name":"CategoryTickTest","similarity_score":0.20167830522361857},{"class_name":"CycleBoundTick","similarity_score":0.5680506575385434},{"class_name":"CyclicNumberAxis","similarity_score":0.5526419195720804},{"class_name":"CyclicNumberAxisTest","similarity_score":0.22443957742584994},{"class_name":"DateAxisTest","similarity_score":0.19217411690021252},{"class_name":"AxisCollection","similarity_score":0.5176481591502577},{"class_name":"DateTick","similarity_score":0.633700164970293},{"class_name":"DateTickMarkPositionTest","similarity_score":0.2835125063890397},{"class_name":"AxisSpace","similarity_score":0.5438800889823968},{"class_name":"DateTickTest","similarity_score":0.16974523470812833},{"class_name":"AxisSpaceTest","similarity_score":0.2682591004189744},{"class_name":"AxisState","similarity_score":0.5465097000687206},{"class_name":"AxisTest","similarity_score":0.10149774746352662},{"class_name":"DateTickUnitTest","similarity_score":0.32146180275704345},{"class_name":"CompassFormat","similarity_score":0.5804513236330779},{"class_name":"TickUnits","similarity_score":0.6291116534653902},{"class_name":"TickUnitsTest","similarity_score":0.32860255232027963},{"class_name":"DefaultTimeline","similarity_score":0.6367689259955845},{"class_name":"SymbolAxis","similarity_score":0.5630953200956536},{"class_name":"SymbolAxisTest","similarity_score":0.254817263448359},{"class_name":"LogarithmicAxis","similarity_score":0.4435810253097018},{"class_name":"LogarithmicAxisTest","similarity_score":0.3894790307429977},{"class_name":"LogAxis","similarity_score":0.5834800477861908},{"class_name":"LogAxisTest","similarity_score":0.3376434016812274},{"class_name":"LogTick","similarity_score":0.6302302167068953},{"class_name":"StandardTickUnitSource","similarity_score":0.6542831981784125},{"class_name":"StandardTickUnitSourceTest","similarity_score":0.3440794525122213},{"class_name":"SubCategoryAxis","similarity_score":0.6002594342107624},{"class_name":"SubCategoryAxisTest","similarity_score":0.3222985438675237},{"class_name":"ValueAxisTest","similarity_score":0.18455379733155833},{"class_name":"ExtendedCategoryAxis","similarity_score":0.6541555397747737},{"class_name":"ExtendedCategoryAxisTest","similarity_score":0.2461567608443628},{"class_name":"MarkerAxisBand","similarity_score":0.548034362250416},{"class_name":"MarkerAxisBandTest","similarity_score":0.16634779919904305},{"class_name":"NumberAxisTest","similarity_score":0.2978858414384423},{"class_name":"NumberTick","similarity_score":0.6015256481108326},{"class_name":"NumberTickUnit","similarity_score":0.6247344648947981},{"class_name":"NumberTickUnitSource","similarity_score":0.2701546805219473},{"class_name":"NumberTickUnitTest","similarity_score":0.3238164351581646},{"class_name":"RelativeDateFormatTest","similarity_score":0.3511295411547665},{"class_name":"QuarterDateFormat","similarity_score":0.6412070828251103},{"class_name":"QuarterDateFormatTest","similarity_score":0.25028783918740993},{"class_name":"PeriodAxis","similarity_score":0.5968064136125232},{"class_name":"PeriodAxisLabelInfo","similarity_score":0.6599245129442918},{"class_name":"PeriodAxisLabelInfoTest","similarity_score":0.20477634453270652},{"class_name":"PeriodAxisTest","similarity_score":0.31215266712507406}],"target_classes_sorted_by_llm":["CategoryLabelPosition","ShapeUtils","DateTickUnit"],"llm_response_time":6627,"similarity_computation_time":62,"similarity_metric":"cosine"},"replaceLeftPosition":{"target_classes":[{"class_name":"ExportUtils","similarity_score":0.5994581278728074},{"class_name":"HashUtils","similarity_score":0.6318650753303837},{"class_name":"EncoderUtil","similarity_score":0.5265294241733129},{"class_name":"LineUtils","similarity_score":0.38110215736640457},{"class_name":"CloneUtils","similarity_score":0.5897078126301563},{"class_name":"ImageMapUtils","similarity_score":0.6649123217983022},{"class_name":"TestUtils","similarity_score":0.45447014360442073},{"class_name":"RendererUtils","similarity_score":0.37167366798749035},{"class_name":"RendererXYPackageUtils","similarity_score":0.44839435952334},{"class_name":"TextUtils","similarity_score":0.5878130347130371},{"class_name":"ShapeUtils","similarity_score":0.6700604625975384},{"class_name":"SerialUtils","similarity_score":0.5405262083091763},{"class_name":"AttrStringUtils","similarity_score":0.5344230810413388},{"class_name":"UIUtils","similarity_score":0.6084026861037888},{"class_name":"ArrayUtils","similarity_score":0.4689064398553489},{"class_name":"PaintUtils","similarity_score":0.44929971399446417},{"class_name":"StringUtils","similarity_score":0.5763270847470471},{"class_name":"JSONUtils","similarity_score":0.5792666675398838},{"class_name":"DatasetUtils","similarity_score":0.5585561797267582},{"class_name":"FlowDatasetUtils","similarity_score":0.590633662698596},{"class_name":"AttributedStringUtils","similarity_score":0.3766807232132804},{"class_name":"HashUtilsTest","similarity_score":0.2532520925696209},{"class_name":"LineUtilsTest","similarity_score":0.12340902327892486},{"class_name":"SerialUtilsTest","similarity_score":0.18264875156650195},{"class_name":"ShapeUtilsTest","similarity_score":0.3709513906811044},{"class_name":"CloneUtilsTest","similarity_score":0.39463470581117},{"class_name":"ImageMapUtilsTest","similarity_score":0.2724974767601882},{"class_name":"ObjectWithMapOfPaint","similarity_score":0.1028939015305655},{"class_name":"ObjectWithMapOfStroke","similarity_score":0.1028939015305655},{"class_name":"RendererUtilsTest","similarity_score":0.1929600851832525},{"class_name":"DatasetUtilsTest","similarity_score":0.2961772135942879},{"class_name":"DataUtilsTest","similarity_score":0.23744203040200448},{"class_name":"Args","similarity_score":0.536066480775133},{"class_name":"ImageEncoderFactory","similarity_score":0.5507642809163512},{"class_name":"PaintAlpha","similarity_score":0.6289745009091352},{"class_name":"ChartEditorManager","similarity_score":0.6159208049220645},{"class_name":"JSONValue","similarity_score":0.5071373634841698},{"class_name":"MovingAverage","similarity_score":0.5232286081402923},{"class_name":"DatasetReader","similarity_score":0.6305125852401423},{"class_name":"ChartColor","similarity_score":0.3521301268723392},{"class_name":"NumberAxis","similarity_score":0.573623666453748},{"class_name":"GanttChartTest","similarity_score":0.4664807588277471},{"class_name":"PieChartTest","similarity_score":0.5085589772889251},{"class_name":"JSONObject","similarity_score":0.6465940947643803},{"class_name":"DateTickUnit","similarity_score":0.6688366963231706},{"class_name":"DateAxis","similarity_score":0.5707680623023897},{"class_name":"TickUnits","similarity_score":0.6291116534653902},{"class_name":"TickUnitsTest","similarity_score":0.32860255232027963},{"class_name":"CategoryAnchorTest","similarity_score":0.2881582213580483},{"class_name":"CategoryAxis","similarity_score":0.6622632705972461},{"class_name":"CategoryAxisTest","similarity_score":0.20417563624545984},{"class_name":"CategoryLabelPosition","similarity_score":0.6864645970111847},{"class_name":"CategoryLabelPositionsTest","similarity_score":0.26671840119098855},{"class_name":"CategoryLabelPositionTest","similarity_score":0.18877292106826907},{"class_name":"CategoryLabelWidthTypeTest","similarity_score":0.3126651035077335},{"class_name":"CategoryTick","similarity_score":0.5973255168405213},{"class_name":"CategoryTickTest","similarity_score":0.20167830522361857},{"class_name":"ExtendedCategoryAxis","similarity_score":0.6541555397747737},{"class_name":"ExtendedCategoryAxisTest","similarity_score":0.2461567608443628},{"class_name":"StandardTickUnitSource","similarity_score":0.6542831981784125},{"class_name":"StandardTickUnitSourceTest","similarity_score":0.3440794525122213},{"class_name":"AxisCollection","similarity_score":0.5203164486304137},{"class_name":"AxisLocationTest","similarity_score":0.2886855012525505},{"class_name":"AxisSpace","similarity_score":0.5449413184243137},{"class_name":"AxisSpaceTest","similarity_score":0.2682591004189744},{"class_name":"AxisState","similarity_score":0.5490516056504355},{"class_name":"AxisTest","similarity_score":0.10149774746352662},{"class_name":"SubCategoryAxis","similarity_score":0.5988234068561912},{"class_name":"SubCategoryAxisTest","similarity_score":0.3222985438675237},{"class_name":"SymbolAxis","similarity_score":0.5630953200956536},{"class_name":"SymbolAxisTest","similarity_score":0.254817263448359},{"class_name":"CompassFormat","similarity_score":0.5804513236330779},{"class_name":"LogarithmicAxis","similarity_score":0.4435810253097018},{"class_name":"LogarithmicAxisTest","similarity_score":0.3909215456716755},{"class_name":"LogAxis","similarity_score":0.5839702298481787},{"class_name":"LogAxisTest","similarity_score":0.3376434016812274},{"class_name":"LogTick","similarity_score":0.6302302167068953},{"class_name":"ValueAxisTest","similarity_score":0.18455379733155833},{"class_name":"NumberAxisTest","similarity_score":0.2978858414384423},{"class_name":"NumberTick","similarity_score":0.6015256481108326},{"class_name":"NumberTickUnit","similarity_score":0.6247344648947981},{"class_name":"NumberTickUnitSource","similarity_score":0.2701546805219473},{"class_name":"NumberTickUnitTest","similarity_score":0.3238164351581646},{"class_name":"MarkerAxisBand","similarity_score":0.5365572028315592},{"class_name":"MarkerAxisBandTest","similarity_score":0.16634779919904305},{"class_name":"ModuloAxis","similarity_score":0.5700705924938253},{"class_name":"ModuloAxisTest","similarity_score":0.31382619925336064},{"class_name":"PeriodAxis","similarity_score":0.5963044738197456},{"class_name":"PeriodAxisLabelInfo","similarity_score":0.6599245129442918},{"class_name":"PeriodAxisLabelInfoTest","similarity_score":0.20477634453270652},{"class_name":"PeriodAxisTest","similarity_score":0.31215266712507406},{"class_name":"MonthDateFormat","similarity_score":0.6524344944186784},{"class_name":"MonthDateFormatTest","similarity_score":0.24637505790268524},{"class_name":"DefaultTimeline","similarity_score":0.6367689259955845},{"class_name":"RelativeDateFormatTest","similarity_score":0.3511295411547665},{"class_name":"CyclicNumberAxis","similarity_score":0.5526419195720804},{"class_name":"CyclicNumberAxisTest","similarity_score":0.22443957742584994},{"class_name":"DateTick","similarity_score":0.633700164970293},{"class_name":"DateTickMarkPositionTest","similarity_score":0.2835125063890397},{"class_name":"DateTickTest","similarity_score":0.16974523470812833}],"target_classes_sorted_by_llm":["CategoryLabelPosition","ShapeUtils","DateTickUnit"],"llm_response_time":5295,"similarity_computation_time":43,"similarity_metric":"cosine"},"replaceRightPosition":{"target_classes":[{"class_name":"CloneUtils","similarity_score":0.5897078126301563},{"class_name":"HashUtils","similarity_score":0.6318650753303837},{"class_name":"LineUtils","similarity_score":0.38110215736640457},{"class_name":"RendererUtils","similarity_score":0.37167366798749035},{"class_name":"RendererXYPackageUtils","similarity_score":0.44839435952334},{"class_name":"EncoderUtil","similarity_score":0.5265294241733129},{"class_name":"ImageMapUtils","similarity_score":0.6649123217983022},{"class_name":"ExportUtils","similarity_score":0.5994581278728074},{"class_name":"TestUtils","similarity_score":0.45447014360442073},{"class_name":"TextUtils","similarity_score":0.5865610367690264},{"class_name":"ShapeUtils","similarity_score":0.6700604625975384},{"class_name":"SerialUtils","similarity_score":0.5405262083091763},{"class_name":"AttrStringUtils","similarity_score":0.5344230810413388},{"class_name":"UIUtils","similarity_score":0.6084026861037888},{"class_name":"ArrayUtils","similarity_score":0.4689064398553489},{"class_name":"PaintUtils","similarity_score":0.44929971399446417},{"class_name":"JSONUtils","similarity_score":0.5792666675398838},{"class_name":"StringUtils","similarity_score":0.5763270847470471},{"class_name":"DatasetUtils","similarity_score":0.5585561797267582},{"class_name":"FlowDatasetUtils","similarity_score":0.590633662698596},{"class_name":"AttributedStringUtils","similarity_score":0.3766807232132804},{"class_name":"CloneUtilsTest","similarity_score":0.39463470581117},{"class_name":"HashUtilsTest","similarity_score":0.2532520925696209},{"class_name":"SerialUtilsTest","similarity_score":0.18264875156650195},{"class_name":"LineUtilsTest","similarity_score":0.12340902327892486},{"class_name":"ObjectWithMapOfPaint","similarity_score":0.1028939015305655},{"class_name":"ObjectWithMapOfStroke","similarity_score":0.1028939015305655},{"class_name":"ShapeUtilsTest","similarity_score":0.3709513906811044},{"class_name":"RendererUtilsTest","similarity_score":0.1929600851832525},{"class_name":"ImageMapUtilsTest","similarity_score":0.2724974767601882},{"class_name":"DatasetUtilsTest","similarity_score":0.2961772135942879},{"class_name":"DataUtilsTest","similarity_score":0.23744203040200448},{"class_name":"Args","similarity_score":0.536066480775133},{"class_name":"PaintAlpha","similarity_score":0.6289745009091352},{"class_name":"ImageEncoderFactory","similarity_score":0.5507642809163512},{"class_name":"ChartEditorManager","similarity_score":0.6249784638179772},{"class_name":"DatasetReader","similarity_score":0.6305125852401423},{"class_name":"MovingAverage","similarity_score":0.5232286081402923},{"class_name":"JSONValue","similarity_score":0.5071373634841698},{"class_name":"ChartColor","similarity_score":0.3521301268723392},{"class_name":"NumberAxis","similarity_score":0.573623666453748},{"class_name":"PieChartTest","similarity_score":0.5085589772889251},{"class_name":"GanttChartTest","similarity_score":0.4664807588277471},{"class_name":"JSONObject","similarity_score":0.6465940947643803},{"class_name":"DateTickUnit","similarity_score":0.6688366963231706},{"class_name":"DateAxis","similarity_score":0.5707680623023897},{"class_name":"CategoryAnchorTest","similarity_score":0.2881582213580483},{"class_name":"CategoryAxis","similarity_score":0.6622632705972461},{"class_name":"CategoryAxisTest","similarity_score":0.20417563624545984},{"class_name":"CategoryLabelPosition","similarity_score":0.6864645970111847},{"class_name":"CategoryLabelPositionsTest","similarity_score":0.26671840119098855},{"class_name":"CategoryLabelPositionTest","similarity_score":0.18877292106826907},{"class_name":"CategoryLabelWidthTypeTest","similarity_score":0.3126651035077335},{"class_name":"CategoryTick","similarity_score":0.5973255168405213},{"class_name":"CategoryTickTest","similarity_score":0.20167830522361857},{"class_name":"CycleBoundTick","similarity_score":0.5680506575385434},{"class_name":"CyclicNumberAxis","similarity_score":0.5526419195720804},{"class_name":"CyclicNumberAxisTest","similarity_score":0.22443957742584994},{"class_name":"DateAxisTest","similarity_score":0.19217411690021252},{"class_name":"AxisCollection","similarity_score":0.5203164486304137},{"class_name":"AxisLocationTest","similarity_score":0.2886855012525505},{"class_name":"AxisSpace","similarity_score":0.5449413184243137},{"class_name":"AxisSpaceTest","similarity_score":0.2682591004189744},{"class_name":"AxisState","similarity_score":0.5490516056504355},{"class_name":"AxisTest","similarity_score":0.10149774746352662},{"class_name":"DateTick","similarity_score":0.633700164970293},{"class_name":"DateTickMarkPositionTest","similarity_score":0.2835125063890397},{"class_name":"DateTickTest","similarity_score":0.16974523470812833},{"class_name":"DateTickUnitTest","similarity_score":0.32146180275704345},{"class_name":"CompassFormat","similarity_score":0.5804513236330779},{"class_name":"NumberTickUnitSource","similarity_score":0.2701546805219473},{"class_name":"NumberTickUnitTest","similarity_score":0.3238164351581646},{"class_name":"DefaultTimeline","similarity_score":0.6367689259955845},{"class_name":"NumberAxisTest","similarity_score":0.2978858414384423},{"class_name":"NumberTick","similarity_score":0.6015256481108326},{"class_name":"NumberTickUnit","similarity_score":0.6247344648947981},{"class_name":"MarkerAxisBand","similarity_score":0.5365572028315592},{"class_name":"MarkerAxisBandTest","similarity_score":0.16634779919904305},{"class_name":"ModuloAxis","similarity_score":0.5700705924938253},{"class_name":"ModuloAxisTest","similarity_score":0.31382619925336064},{"class_name":"MonthDateFormat","similarity_score":0.6524344944186784},{"class_name":"MonthDateFormatTest","similarity_score":0.24637505790268524},{"class_name":"PeriodAxis","similarity_score":0.5963044738197456},{"class_name":"PeriodAxisLabelInfo","similarity_score":0.6599245129442918},{"class_name":"PeriodAxisLabelInfoTest","similarity_score":0.20477634453270652},{"class_name":"PeriodAxisTest","similarity_score":0.31215266712507406},{"class_name":"RelativeDateFormatTest","similarity_score":0.3511295411547665},{"class_name":"QuarterDateFormat","similarity_score":0.6412070828251103},{"class_name":"QuarterDateFormatTest","similarity_score":0.25028783918740993},{"class_name":"LogarithmicAxis","similarity_score":0.4435810253097018},{"class_name":"LogarithmicAxisTest","similarity_score":0.3894790307429977},{"class_name":"LogAxis","similarity_score":0.5841336238688413},{"class_name":"LogAxisTest","similarity_score":0.3376434016812274},{"class_name":"LogTick","similarity_score":0.6302302167068953},{"class_name":"TickUnits","similarity_score":0.6291116534653902},{"class_name":"TickUnitsTest","similarity_score":0.32860255232027963},{"class_name":"MyDateAxis","similarity_score":0.43457982402703715},{"class_name":"MyLogarithmicAxis","similarity_score":0.49384070912163314},{"class_name":"ExtendedCategoryAxis","similarity_score":0.6541555397747737},{"class_name":"ExtendedCategoryAxisTest","similarity_score":0.2461567608443628}],"target_classes_sorted_by_llm":["CategoryLabelPosition","ShapeUtils","DateTickUnit"],"llm_response_time":4167,"similarity_computation_time":33,"similarity_metric":"cosine"}}}
{"id":"f51d18e5-6345-4413-a23a-712559e10a4f","hostFunctionTelemetryData":{"hostFunctionSize":1102,"lineStart":64,"lineEnd":1165,"bodyLineStart":64,"language":"java","filePath":"/Users/snehil/Documents/ConcordiaUniversity/Material/SOEN-6491-Refactoring/OpenSource/jfreechart/jfreechart/src/main/java/org/jfree/chart/axis/CyclicNumberAxis.java","sourceCode":"/**\nThis class extends NumberAxis and handles cycling.\n\nTraditional representation of data in the range x0..x1\n\u003cpre\u003e\n|-------------------------|\nx0                       x1\n\u003c/pre\u003e\n\nHere, the range bounds are at the axis extremities.\nWith cyclic axis, however, the time is split in\n\"cycles\", or \"time frames\", or the same duration : the period.\n\nA cycle axis cannot by definition handle a larger interval\nthan the period : \u003cpre\u003ex1 - x0 \u0026gt;\u003d period\u003c/pre\u003e. Thus, at most a full\nperiod can be represented with such an axis.\n\nThe cycle bound is the number between x0 and x1 which marks\nthe beginning of new time frame:\n\u003cpre\u003e\n|---------------------|----------------------------|\nx0                   cb                           x1\n\u0026lt;---previous cycle---\u0026gt;\u0026lt;-------current cycle--------\u0026gt;\n\u003c/pre\u003e\n\nIt is actually a multiple of the period, plus optionally\na start offset: \u003cpre\u003ecb \u003d n * period + offset\u003c/pre\u003e\n\nThus, by definition, two consecutive cycle bounds\nperiod apart, which is precisely why it is called a\nperiod.\n\nThe visual representation of a cyclic axis is like that:\n\u003cpre\u003e\n|----------------------------|---------------------|\ncb                         x1|x0                  cb\n\u0026lt;-------current cycle--------\u0026gt;\u0026lt;---previous cycle---\u0026gt;\n\u003c/pre\u003e\n\nThe cycle bound is at the axis ends, then current\ncycle is shown, then the last cycle. When using\ndynamic data, the visual effect is the current cycle\nerases the last cycle as x grows. Then, the next cycle\nbound is reached, and the process starts over, erasing\nthe previous cycle.\n\nA Cyclic item renderer is provided to do exactly this.\n\n */\npublic class CyclicNumberAxis extends NumberAxis {\n\n    /** For serialization. */\n    static final long serialVersionUID \u003d -7514160997164582554L;\n\n    /** The default axis line stroke. */\n    public static Stroke DEFAULT_ADVANCE_LINE_STROKE \u003d new BasicStroke(1.0f);\n\n    /** The default axis line paint. */\n    public static final Paint DEFAULT_ADVANCE_LINE_PAINT \u003d Color.GRAY;\n\n    /** The offset. */\n    protected double offset;\n\n    /** The period.*/\n    protected double period;\n\n    /** ??. */\n    protected boolean boundMappedToLastCycle;\n\n    /** A flag that controls whether or not the advance line is visible. */\n    protected boolean advanceLineVisible;\n\n    /** The advance line stroke. */\n    protected transient Stroke advanceLineStroke \u003d DEFAULT_ADVANCE_LINE_STROKE;\n\n    /** The advance line paint. */\n    protected transient Paint advanceLinePaint;\n\n    private transient boolean internalMarkerWhenTicksOverlap;\n    private transient Tick internalMarkerCycleBoundTick;\n\n    /**\n     * Creates a CycleNumberAxis with the given period.\n     *\n     * @param period  the period.\n     */\n    public CyclicNumberAxis(double period) {\n        this(period, 0.0);\n    }\n\n    /**\n     * Creates a CycleNumberAxis with the given period and offset.\n     *\n     * @param period  the period.\n     * @param offset  the offset.\n     */\n    public CyclicNumberAxis(double period, double offset) {\n        this(period, offset, null);\n    }\n\n    /**\n     * Creates a named CycleNumberAxis with the given period.\n     *\n     * @param period  the period.\n     * @param label  the label.\n     */\n    public CyclicNumberAxis(double period, String label) {\n        this(0, period, label);\n    }\n\n    /**\n     * Creates a named CycleNumberAxis with the given period and offset.\n     *\n     * @param period  the period.\n     * @param offset  the offset.\n     * @param label  the label.\n     */\n    public CyclicNumberAxis(double period, double offset, String label) {\n        super(label);\n        this.period \u003d period;\n        this.offset \u003d offset;\n        setFixedAutoRange(period);\n        this.advanceLineVisible \u003d true;\n        this.advanceLinePaint \u003d DEFAULT_ADVANCE_LINE_PAINT;\n    }\n\n    /**\n     * The advance line is the line drawn at the limit of the current cycle,\n     * when erasing the previous cycle.\n     *\n     * @return A boolean.\n     */\n    public boolean isAdvanceLineVisible() {\n        return this.advanceLineVisible;\n    }\n\n    /**\n     * The advance line is the line drawn at the limit of the current cycle,\n     * when erasing the previous cycle.\n     *\n     * @param visible  the flag.\n     */\n    public void setAdvanceLineVisible(boolean visible) {\n        this.advanceLineVisible \u003d visible;\n    }\n\n    /**\n     * The advance line is the line drawn at the limit of the current cycle,\n     * when erasing the previous cycle.\n     *\n     * @return The paint (never {@code null}).\n     */\n    public Paint getAdvanceLinePaint() {\n        return this.advanceLinePaint;\n    }\n\n    /**\n     * The advance line is the line drawn at the limit of the current cycle,\n     * when erasing the previous cycle.\n     *\n     * @param paint  the paint ({@code null} not permitted).\n     */\n    public void setAdvanceLinePaint(Paint paint) {\n        Args.nullNotPermitted(paint, \"paint\");\n        this.advanceLinePaint \u003d paint;\n    }\n\n    /**\n     * The advance line is the line drawn at the limit of the current cycle,\n     * when erasing the previous cycle.\n     *\n     * @return The stroke (never {@code null}).\n     */\n    public Stroke getAdvanceLineStroke() {\n        return this.advanceLineStroke;\n    }\n    /**\n     * The advance line is the line drawn at the limit of the current cycle,\n     * when erasing the previous cycle.\n     *\n     * @param stroke  the stroke ({@code null} not permitted).\n     */\n    public void setAdvanceLineStroke(Stroke stroke) {\n        Args.nullNotPermitted(stroke, \"stroke\");\n        this.advanceLineStroke \u003d stroke;\n    }\n\n    /**\n     * The cycle bound can be associated either with the current or with the\n     * last cycle.  It\u0027s up to the user\u0027s choice to decide which, as this is\n     * just a convention.  By default, the cycle bound is mapped to the current\n     * cycle.\n     * \u003cbr\u003e\n     * Note that this has no effect on visual appearance, as the cycle bound is\n     * mapped successively for both axis ends. Use this function for correct\n     * results in translateValueToJava2D.\n     *\n     * @return {@code true} if the cycle bound is mapped to the last\n     *         cycle, {@code false} if it is bound to the current cycle\n     *         (default)\n     */\n    public boolean isBoundMappedToLastCycle() {\n        return this.boundMappedToLastCycle;\n    }\n\n    /**\n     * The cycle bound can be associated either with the current or with the\n     * last cycle.  It\u0027s up to the user\u0027s choice to decide which, as this is\n     * just a convention. By default, the cycle bound is mapped to the current\n     * cycle.\n     * \u003cbr\u003e\n     * Note that this has no effect on visual appearance, as the cycle bound is\n     * mapped successively for both axis ends. Use this function for correct\n     * results in valueToJava2D.\n     *\n     * @param boundMappedToLastCycle Set it to true to map the cycle bound to\n     *        the last cycle.\n     */\n    public void setBoundMappedToLastCycle(boolean boundMappedToLastCycle) {\n        this.boundMappedToLastCycle \u003d boundMappedToLastCycle;\n    }\n\n    /**\n     * Selects a tick unit when the axis is displayed horizontally.\n     *\n     * @param g2  the graphics device.\n     * @param drawArea  the drawing area.\n     * @param dataArea  the data area.\n     * @param edge  the side of the rectangle on which the axis is displayed.\n     */\n    protected void selectHorizontalAutoTickUnit(Graphics2D g2,\n            Rectangle2D drawArea, Rectangle2D dataArea, RectangleEdge edge) {\n\n        double tickLabelWidth\n            \u003d estimateMaximumTickLabelWidth(g2, getTickUnit());\n\n        // Compute number of labels\n        double n \u003d getRange().getLength()\n                   * tickLabelWidth / dataArea.getWidth();\n\n        setTickUnit(\n                (NumberTickUnit) getStandardTickUnits().getCeilingTickUnit(n),\n                false, false);\n\n     }\n\n    /**\n     * Selects a tick unit when the axis is displayed vertically.\n     *\n     * @param g2  the graphics device.\n     * @param drawArea  the drawing area.\n     * @param dataArea  the data area.\n     * @param edge  the side of the rectangle on which the axis is displayed.\n     */\n    protected void selectVerticalAutoTickUnit(Graphics2D g2,\n            Rectangle2D drawArea, Rectangle2D dataArea, RectangleEdge edge) {\n\n        double tickLabelWidth\n            \u003d estimateMaximumTickLabelWidth(g2, getTickUnit());\n\n        // Compute number of labels\n        double n \u003d getRange().getLength()\n                   * tickLabelWidth / dataArea.getHeight();\n\n        setTickUnit(\n            (NumberTickUnit) getStandardTickUnits().getCeilingTickUnit(n),\n            false, false);\n     }\n\n    /**\n     * A special Number tick that also hold information about the cycle bound\n     * mapping for this tick.  This is especially useful for having a tick at\n     * each axis end with the cycle bound value.  See also\n     * isBoundMappedToLastCycle()\n     */\n    protected static class CycleBoundTick extends NumberTick {\n\n        /** Map to last cycle. */\n        public boolean mapToLastCycle;\n\n        /**\n         * Creates a new tick.\n         *\n         * @param mapToLastCycle  map to last cycle?\n         * @param number  the number.\n         * @param label  the label.\n         * @param textAnchor  the text anchor.\n         * @param rotationAnchor  the rotation anchor.\n         * @param angle  the rotation angle.\n         */\n        public CycleBoundTick(boolean mapToLastCycle, Number number,\n                              String label, TextAnchor textAnchor,\n                              TextAnchor rotationAnchor, double angle) {\n            super(number, label, textAnchor, rotationAnchor, angle);\n            this.mapToLastCycle \u003d mapToLastCycle;\n        }\n    }\n\n    /**\n     * Calculates the anchor point for a tick.\n     *\n     * @param tick  the tick.\n     * @param cursor  the cursor.\n     * @param dataArea  the data area.\n     * @param edge  the side on which the axis is displayed.\n     *\n     * @return The anchor point.\n     */\n    @Override\n    protected float[] calculateAnchorPoint(ValueTick tick, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge) {\n        if (tick instanceof CycleBoundTick) {\n            boolean mapsav \u003d this.boundMappedToLastCycle;\n            this.boundMappedToLastCycle\n                \u003d ((CycleBoundTick) tick).mapToLastCycle;\n            float[] ret \u003d super.calculateAnchorPoint(\n                tick, cursor, dataArea, edge\n            );\n            this.boundMappedToLastCycle \u003d mapsav;\n            return ret;\n        }\n        return super.calculateAnchorPoint(tick, cursor, dataArea, edge);\n    }\n\n\n\n    /**\n     * Builds a list of ticks for the axis.  This method is called when the\n     * axis is at the top or bottom of the chart (so the axis is \"horizontal\").\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param edge  the edge.\n     *\n     * @return A list of ticks.\n     */\n    @Override\n    protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        List result \u003d new java.util.ArrayList();\n\n        Font tickLabelFont \u003d getTickLabelFont();\n        g2.setFont(tickLabelFont);\n\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        double unit \u003d getTickUnit().getSize();\n        double cycleBound \u003d getCycleBound();\n        double currentTickValue \u003d Math.ceil(cycleBound / unit) * unit;\n        double upperValue \u003d getRange().getUpperBound();\n        boolean cycled \u003d false;\n\n        boolean boundMapping \u003d this.boundMappedToLastCycle;\n        this.boundMappedToLastCycle \u003d false;\n\n        CycleBoundTick lastTick \u003d null;\n        float lastX \u003d 0.0f;\n\n        if (upperValue \u003d\u003d cycleBound) {\n            currentTickValue \u003d calculateLowestVisibleTickValue();\n            cycled \u003d true;\n            this.boundMappedToLastCycle \u003d true;\n        }\n\n        while (currentTickValue \u003c\u003d upperValue) {\n\n            // Cycle when necessary\n            boolean cyclenow \u003d false;\n            if ((currentTickValue + unit \u003e upperValue) \u0026\u0026 !cycled) {\n                cyclenow \u003d true;\n            }\n\n            double xx \u003d valueToJava2D(currentTickValue, dataArea, edge);\n            String tickLabel;\n            NumberFormat formatter \u003d getNumberFormatOverride();\n            if (formatter !\u003d null) {\n                tickLabel \u003d formatter.format(currentTickValue);\n            }\n            else {\n                tickLabel \u003d getTickUnit().valueToString(currentTickValue);\n            }\n            float x \u003d (float) xx;\n            TextAnchor anchor;\n            TextAnchor rotationAnchor;\n            double angle \u003d 0.0;\n            if (isVerticalTickLabels()) {\n                if (edge \u003d\u003d RectangleEdge.TOP) {\n                    angle \u003d Math.PI / 2.0;\n                }\n                else {\n                    angle \u003d -Math.PI / 2.0;\n                }\n                anchor \u003d TextAnchor.CENTER_RIGHT;\n                // If tick overlap when cycling, update last tick too\n                if ((lastTick !\u003d null) \u0026\u0026 (lastX \u003d\u003d x)\n                        \u0026\u0026 (currentTickValue !\u003d cycleBound)) {\n                    anchor \u003d isInverted()\n                        ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT;\n                    result.remove(result.size() - 1);\n                    result.add(new CycleBoundTick(\n                        this.boundMappedToLastCycle, lastTick.getNumber(),\n                        lastTick.getText(), anchor, anchor,\n                        lastTick.getAngle())\n                    );\n                    this.internalMarkerWhenTicksOverlap \u003d true;\n                    anchor \u003d isInverted()\n                        ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT;\n                }\n                rotationAnchor \u003d anchor;\n            }\n            else {\n                if (edge \u003d\u003d RectangleEdge.TOP) {\n                    anchor \u003d TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick !\u003d null) \u0026\u0026 (lastX \u003d\u003d x)\n                            \u0026\u0026 (currentTickValue !\u003d cycleBound)) {\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap \u003d true;\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor \u003d anchor;\n                }\n                else {\n                    anchor \u003d TextAnchor.TOP_CENTER;\n                    if ((lastTick !\u003d null) \u0026\u0026 (lastX \u003d\u003d x)\n                            \u0026\u0026 (currentTickValue !\u003d cycleBound)) {\n                        anchor \u003d isInverted()\n                            ? TextAnchor.TOP_LEFT : TextAnchor.TOP_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap \u003d true;\n                        anchor \u003d isInverted()\n                            ? TextAnchor.TOP_RIGHT : TextAnchor.TOP_LEFT;\n                    }\n                    rotationAnchor \u003d anchor;\n                }\n            }\n\n            CycleBoundTick tick \u003d new CycleBoundTick(this.boundMappedToLastCycle, \n                    currentTickValue, tickLabel, anchor, rotationAnchor, angle);\n            if (currentTickValue \u003d\u003d cycleBound) {\n                this.internalMarkerCycleBoundTick \u003d tick;\n            }\n            result.add(tick);\n            lastTick \u003d tick;\n            lastX \u003d x;\n\n            currentTickValue +\u003d unit;\n\n            if (cyclenow) {\n                currentTickValue \u003d calculateLowestVisibleTickValue();\n                upperValue \u003d cycleBound;\n                cycled \u003d true;\n                this.boundMappedToLastCycle \u003d true;\n            }\n\n        }\n        this.boundMappedToLastCycle \u003d boundMapping;\n        return result;\n\n    }\n\n    /**\n     * Builds a list of ticks for the axis.  This method is called when the\n     * axis is at the left or right of the chart (so the axis is \"vertical\").\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param edge  the edge.\n     *\n     * @return A list of ticks.\n     */\n    protected List refreshVerticalTicks(Graphics2D g2, Rectangle2D dataArea,\n            RectangleEdge edge) {\n\n        List result \u003d new java.util.ArrayList();\n        result.clear();\n\n        Font tickLabelFont \u003d getTickLabelFont();\n        g2.setFont(tickLabelFont);\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        double unit \u003d getTickUnit().getSize();\n        double cycleBound \u003d getCycleBound();\n        double currentTickValue \u003d Math.ceil(cycleBound / unit) * unit;\n        double upperValue \u003d getRange().getUpperBound();\n        boolean cycled \u003d false;\n\n        boolean boundMapping \u003d this.boundMappedToLastCycle;\n        this.boundMappedToLastCycle \u003d true;\n\n        NumberTick lastTick \u003d null;\n        float lastY \u003d 0.0f;\n\n        if (upperValue \u003d\u003d cycleBound) {\n            currentTickValue \u003d calculateLowestVisibleTickValue();\n            cycled \u003d true;\n            this.boundMappedToLastCycle \u003d true;\n        }\n\n        while (currentTickValue \u003c\u003d upperValue) {\n\n            // Cycle when necessary\n            boolean cyclenow \u003d false;\n            if ((currentTickValue + unit \u003e upperValue) \u0026\u0026 !cycled) {\n                cyclenow \u003d true;\n            }\n\n            double yy \u003d valueToJava2D(currentTickValue, dataArea, edge);\n            String tickLabel;\n            NumberFormat formatter \u003d getNumberFormatOverride();\n            if (formatter !\u003d null) {\n                tickLabel \u003d formatter.format(currentTickValue);\n            }\n            else {\n                tickLabel \u003d getTickUnit().valueToString(currentTickValue);\n            }\n\n            float y \u003d (float) yy;\n            TextAnchor anchor;\n            TextAnchor rotationAnchor;\n            double angle \u003d 0.0;\n            if (isVerticalTickLabels()) {\n\n                if (edge \u003d\u003d RectangleEdge.LEFT) {\n                    anchor \u003d TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick !\u003d null) \u0026\u0026 (lastY \u003d\u003d y)\n                            \u0026\u0026 (currentTickValue !\u003d cycleBound)) {\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap \u003d true;\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor \u003d anchor;\n                    angle \u003d -Math.PI / 2.0;\n                }\n                else {\n                    anchor \u003d TextAnchor.BOTTOM_CENTER;\n                    if ((lastTick !\u003d null) \u0026\u0026 (lastY \u003d\u003d y)\n                            \u0026\u0026 (currentTickValue !\u003d cycleBound)) {\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap \u003d true;\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;\n                    }\n                    rotationAnchor \u003d anchor;\n                    angle \u003d Math.PI / 2.0;\n                }\n            }\n            else {\n                if (edge \u003d\u003d RectangleEdge.LEFT) {\n                    anchor \u003d TextAnchor.CENTER_RIGHT;\n                    if ((lastTick !\u003d null) \u0026\u0026 (lastY \u003d\u003d y)\n                            \u0026\u0026 (currentTickValue !\u003d cycleBound)) {\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap \u003d true;\n                        anchor \u003d isInverted()\n                            ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT;\n                    }\n                    rotationAnchor \u003d anchor;\n                }\n                else {\n                    anchor \u003d TextAnchor.CENTER_LEFT;\n                    if ((lastTick !\u003d null) \u0026\u0026 (lastY \u003d\u003d y)\n                            \u0026\u0026 (currentTickValue !\u003d cycleBound)) {\n                        anchor \u003d isInverted()\n                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.TOP_LEFT;\n                        result.remove(result.size() - 1);\n                        result.add(new CycleBoundTick(\n                            this.boundMappedToLastCycle, lastTick.getNumber(),\n                            lastTick.getText(), anchor, anchor,\n                            lastTick.getAngle())\n                        );\n                        this.internalMarkerWhenTicksOverlap \u003d true;\n                        anchor \u003d isInverted()\n                            ? TextAnchor.TOP_LEFT : TextAnchor.BOTTOM_LEFT;\n                    }\n                    rotationAnchor \u003d anchor;\n                }\n            }\n\n            CycleBoundTick tick \u003d new CycleBoundTick(this.boundMappedToLastCycle, \n                    currentTickValue, tickLabel, anchor, rotationAnchor, angle);\n            if (currentTickValue \u003d\u003d cycleBound) {\n                this.internalMarkerCycleBoundTick \u003d tick;\n            }\n            result.add(tick);\n            lastTick \u003d tick;\n            lastY \u003d y;\n\n            if (currentTickValue \u003d\u003d cycleBound) {\n                this.internalMarkerCycleBoundTick \u003d tick;\n            }\n\n            currentTickValue +\u003d unit;\n\n            if (cyclenow) {\n                currentTickValue \u003d calculateLowestVisibleTickValue();\n                upperValue \u003d cycleBound;\n                cycled \u003d true;\n                this.boundMappedToLastCycle \u003d false;\n            }\n\n        }\n        this.boundMappedToLastCycle \u003d boundMapping;\n        return result;\n    }\n\n    /**\n     * Converts a coordinate from Java 2D space to data space.\n     *\n     * @param java2DValue  the coordinate in Java2D space.\n     * @param dataArea  the data area.\n     * @param edge  the edge.\n     *\n     * @return The data value.\n     */\n    @Override\n    public double java2DToValue(double java2DValue, Rectangle2D dataArea,\n            RectangleEdge edge) {\n        Range range \u003d getRange();\n\n        double vmax \u003d range.getUpperBound();\n        double vp \u003d getCycleBound();\n\n        double jmin \u003d 0.0;\n        double jmax \u003d 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            jmin \u003d dataArea.getMinX();\n            jmax \u003d dataArea.getMaxX();\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            jmin \u003d dataArea.getMaxY();\n            jmax \u003d dataArea.getMinY();\n        }\n\n        if (isInverted()) {\n            double jbreak \u003d jmax - (vmax - vp) * (jmax - jmin) / this.period;\n            if (java2DValue \u003e\u003d jbreak) {\n                return vp + (jmax - java2DValue) * this.period / (jmax - jmin);\n            }\n            else {\n                return vp - (java2DValue - jmin) * this.period / (jmax - jmin);\n            }\n        }\n        else {\n            double jbreak \u003d (vmax - vp) * (jmax - jmin) / this.period + jmin;\n            if (java2DValue \u003c\u003d jbreak) {\n                return vp + (java2DValue - jmin) * this.period / (jmax - jmin);\n            }\n            else {\n                return vp - (jmax - java2DValue) * this.period / (jmax - jmin);\n            }\n        }\n    }\n\n    /**\n     * Translates a value from data space to Java 2D space.\n     *\n     * @param value  the data value.\n     * @param dataArea  the data area.\n     * @param edge  the edge.\n     *\n     * @return The Java 2D value.\n     */\n    @Override\n    public double valueToJava2D(double value, Rectangle2D dataArea,\n            RectangleEdge edge) {\n        Range range \u003d getRange();\n\n        double vmin \u003d range.getLowerBound();\n        double vmax \u003d range.getUpperBound();\n        double vp \u003d getCycleBound();\n\n        if ((value \u003c vmin) || (value \u003e vmax)) {\n            return Double.NaN;\n        }\n\n\n        double jmin \u003d 0.0;\n        double jmax \u003d 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            jmin \u003d dataArea.getMinX();\n            jmax \u003d dataArea.getMaxX();\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            jmax \u003d dataArea.getMinY();\n            jmin \u003d dataArea.getMaxY();\n        }\n\n        if (isInverted()) {\n            if (value \u003d\u003d vp) {\n                return this.boundMappedToLastCycle ? jmin : jmax;\n            }\n            else if (value \u003e vp) {\n                return jmax - (value - vp) * (jmax - jmin) / this.period;\n            }\n            else {\n                return jmin + (vp - value) * (jmax - jmin) / this.period;\n            }\n        }\n        else {\n            if (value \u003d\u003d vp) {\n                return this.boundMappedToLastCycle ? jmax : jmin;\n            }\n            else if (value \u003e\u003d vp) {\n                return jmin + (value - vp) * (jmax - jmin) / this.period;\n            }\n            else {\n                return jmax - (vp - value) * (jmax - jmin) / this.period;\n            }\n        }\n    }\n\n    /**\n     * Centers the range about the given value.\n     *\n     * @param value  the data value.\n     */\n    @Override\n    public void centerRange(double value) {\n        setRange(value - this.period / 2.0, value + this.period / 2.0);\n    }\n\n    /**\n     * This function is nearly useless since the auto range is fixed for this\n     * class to the period.  The period is extended if necessary to fit the\n     * minimum size.\n     *\n     * @param size  the size.\n     * @param notify  notify?\n     *\n     * @see org.jfree.chart.axis.ValueAxis#setAutoRangeMinimumSize(double,\n     *      boolean)\n     */\n    @Override\n    public void setAutoRangeMinimumSize(double size, boolean notify) {\n        if (size \u003e this.period) {\n            this.period \u003d size;\n        }\n        super.setAutoRangeMinimumSize(size, notify);\n    }\n\n    /**\n     * The auto range is fixed for this class to the period by default.\n     * This function will thus set a new period.\n     *\n     * @param length  the length.\n     *\n     * @see org.jfree.chart.axis.ValueAxis#setFixedAutoRange(double)\n     */\n    @Override\n    public void setFixedAutoRange(double length) {\n        this.period \u003d length;\n        super.setFixedAutoRange(length);\n    }\n\n    /**\n     * Sets a new axis range. The period is extended to fit the range size, if\n     * necessary.\n     *\n     * @param range  the range.\n     * @param turnOffAutoRange  switch off the auto range.\n     * @param notify notify?\n     *\n     * @see org.jfree.chart.axis.ValueAxis#setRange(Range, boolean, boolean)\n     */\n    @Override\n    public void setRange(Range range, boolean turnOffAutoRange,\n            boolean notify) {\n        double size \u003d range.getUpperBound() - range.getLowerBound();\n        if (size \u003e this.period) {\n            this.period \u003d size;\n        }\n        super.setRange(range, turnOffAutoRange, notify);\n    }\n\n    /**\n     * The cycle bound is defined as the higest value x such that\n     * \"offset + period * i \u003d x\", with i and integer and x \u0026lt;\n     * range.getUpperBound() This is the value which is at both ends of the\n     * axis :  x...up|low...x\n     * The values from x to up are the valued in the current cycle.\n     * The values from low to x are the valued in the previous cycle.\n     *\n     * @return The cycle bound.\n     */\n    public double getCycleBound() {\n        return Math.floor(\n            (getRange().getUpperBound() - this.offset) / this.period\n        ) * this.period + this.offset;\n    }\n\n    /**\n     * The cycle bound is a multiple of the period, plus optionally a start\n     * offset.\n     * \u003cpre\u003ecb \u003d n * period + offset\u003c/pre\u003e\n     *\n     * @return The current offset.\n     *\n     * @see #getCycleBound()\n     */\n    public double getOffset() {\n        return this.offset;\n    }\n\n    /**\n     * The cycle bound is a multiple of the period, plus optionally a start\n     * offset.\n     * \u003cpre\u003ecb \u003d n * period + offset\u003c/pre\u003e\n     *\n     * @param offset The offset to set.\n     *\n     * @see #getCycleBound()\n     */\n    public void setOffset(double offset) {\n        this.offset \u003d offset;\n    }\n\n    /**\n     * The cycle bound is a multiple of the period, plus optionally a start\n     * offset.\n     * \u003cpre\u003ecb \u003d n * period + offset\u003c/pre\u003e\n     *\n     * @return The current period.\n     *\n     * @see #getCycleBound()\n     */\n    public double getPeriod() {\n        return this.period;\n    }\n\n    /**\n     * The cycle bound is a multiple of the period, plus optionally a start\n     * offset.\n     * \u003cpre\u003ecb \u003d n * period + offset\u003c/pre\u003e\n     *\n     * @param period The period to set.\n     *\n     * @see #getCycleBound()\n     */\n    public void setPeriod(double period) {\n        this.period \u003d period;\n    }\n\n    /**\n     * Draws the tick marks and labels.\n     *\n     * @param g2  the graphics device.\n     * @param cursor  the cursor.\n     * @param plotArea  the plot area.\n     * @param dataArea  the area inside the axes.\n     * @param edge  the side on which the axis is displayed.\n     *\n     * @return The axis state.\n     */\n    @Override\n    protected AxisState drawTickMarksAndLabels(Graphics2D g2, double cursor,\n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge) {\n        this.internalMarkerWhenTicksOverlap \u003d false;\n        AxisState ret \u003d super.drawTickMarksAndLabels(g2, cursor, plotArea,\n                dataArea, edge);\n\n        // continue and separate the labels only if necessary\n        if (!this.internalMarkerWhenTicksOverlap) {\n            return ret;\n        }\n\n        double ol;\n        FontMetrics fm \u003d g2.getFontMetrics(getTickLabelFont());\n        if (isVerticalTickLabels()) {\n            ol \u003d fm.getMaxAdvance();\n        }\n        else {\n            ol \u003d fm.getHeight();\n        }\n\n        double il \u003d 0;\n        if (isTickMarksVisible()) {\n            float xx \u003d (float) valueToJava2D(getRange().getUpperBound(),\n                    dataArea, edge);\n            Line2D mark \u003d null;\n            g2.setStroke(getTickMarkStroke());\n            g2.setPaint(getTickMarkPaint());\n            if (edge \u003d\u003d RectangleEdge.LEFT) {\n                mark \u003d new Line2D.Double(cursor - ol, xx, cursor + il, xx);\n            }\n            else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n                mark \u003d new Line2D.Double(cursor + ol, xx, cursor - il, xx);\n            }\n            else if (edge \u003d\u003d RectangleEdge.TOP) {\n                mark \u003d new Line2D.Double(xx, cursor - ol, xx, cursor + il);\n            }\n            else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n                mark \u003d new Line2D.Double(xx, cursor + ol, xx, cursor - il);\n            }\n            g2.draw(mark);\n        }\n        return ret;\n    }\n\n    /**\n     * Draws the axis.\n     *\n     * @param g2  the graphics device ({@code null} not permitted).\n     * @param cursor  the cursor position.\n     * @param plotArea  the plot area ({@code null} not permitted).\n     * @param dataArea  the data area ({@code null} not permitted).\n     * @param edge  the edge ({@code null} not permitted).\n     * @param plotState  collects information about the plot\n     *                   ({@code null} permitted).\n     *\n     * @return The axis state (never {@code null}).\n     */\n    @Override\n    public AxisState draw(Graphics2D g2, double cursor, Rectangle2D plotArea,\n            Rectangle2D dataArea, RectangleEdge edge, PlotRenderingInfo plotState) {\n\n        AxisState ret \u003d super.draw(g2, cursor, plotArea, dataArea, edge, \n                plotState);\n        if (isAdvanceLineVisible()) {\n            double xx \u003d valueToJava2D(getRange().getUpperBound(), dataArea, \n                    edge);\n            Line2D mark \u003d null;\n            g2.setStroke(getAdvanceLineStroke());\n            g2.setPaint(getAdvanceLinePaint());\n            if (edge \u003d\u003d RectangleEdge.LEFT) {\n                mark \u003d new Line2D.Double(cursor, xx, cursor \n                        + dataArea.getWidth(), xx);\n            }\n            else if (edge \u003d\u003d RectangleEdge.RIGHT) {\n                mark \u003d new Line2D.Double(cursor - dataArea.getWidth(), xx, \n                        cursor, xx);\n            }\n            else if (edge \u003d\u003d RectangleEdge.TOP) {\n                mark \u003d new Line2D.Double(xx, cursor + dataArea.getHeight(), xx, \n                        cursor);\n            }\n            else if (edge \u003d\u003d RectangleEdge.BOTTOM) {\n                mark \u003d new Line2D.Double(xx, cursor, xx, \n                        cursor - dataArea.getHeight());\n            }\n            g2.draw(mark);\n        }\n        return ret;\n    }\n\n    /**\n     * Reserve some space on each axis side because we draw a centered label at\n     * each extremity.\n     *\n     * @param g2  the graphics device.\n     * @param plot  the plot.\n     * @param plotArea  the plot area.\n     * @param edge  the edge.\n     * @param space  the space already reserved.\n     *\n     * @return The reserved space.\n     */\n    @Override\n    public AxisSpace reserveSpace(Graphics2D g2, Plot plot,\n            Rectangle2D plotArea, RectangleEdge edge, AxisSpace space) {\n\n        this.internalMarkerCycleBoundTick \u003d null;\n        AxisSpace ret \u003d super.reserveSpace(g2, plot, plotArea, edge, space);\n        if (this.internalMarkerCycleBoundTick \u003d\u003d null) {\n            return ret;\n        }\n\n        FontMetrics fm \u003d g2.getFontMetrics(getTickLabelFont());\n        Rectangle2D r \u003d TextUtils.getTextBounds(\n            this.internalMarkerCycleBoundTick.getText(), g2, fm\n        );\n\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            if (isVerticalTickLabels()) {\n                space.add(r.getHeight() / 2, RectangleEdge.RIGHT);\n            }\n            else {\n                space.add(r.getWidth() / 2, RectangleEdge.RIGHT);\n            }\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            if (isVerticalTickLabels()) {\n                space.add(r.getWidth() / 2, RectangleEdge.TOP);\n            }\n            else {\n                space.add(r.getHeight() / 2, RectangleEdge.TOP);\n            }\n        }\n\n        return ret;\n\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtils.writePaint(this.advanceLinePaint, stream);\n        SerialUtils.writeStroke(this.advanceLineStroke, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n            throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.advanceLinePaint \u003d SerialUtils.readPaint(stream);\n        this.advanceLineStroke \u003d SerialUtils.readStroke(stream);\n    }\n\n\n    /**\n     * Tests the axis for equality with another object.\n     *\n     * @param obj  the object to test against.\n     *\n     * @return A boolean.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj \u003d\u003d this) {\n            return true;\n        }\n        if (!(obj instanceof CyclicNumberAxis)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        CyclicNumberAxis that \u003d (CyclicNumberAxis) obj;\n        if (this.period !\u003d that.period) {\n            return false;\n        }\n        if (this.offset !\u003d that.offset) {\n            return false;\n        }\n        if (!PaintUtils.equal(this.advanceLinePaint,\n                that.advanceLinePaint)) {\n            return false;\n        }\n        if (!Objects.equals(this.advanceLineStroke, that.advanceLineStroke)) {\n            return false;\n        }\n        if (this.advanceLineVisible !\u003d that.advanceLineVisible) {\n            return false;\n        }\n        if (this.boundMappedToLastCycle !\u003d that.boundMappedToLastCycle) {\n            return false;\n        }\n        return true;\n    }\n}","methodCount":35,"staticMethodCount":0,"instanceMethodCount":35,"classLoc":1102,"innerClassCount":1},"candidatesTelemetryData":{"numberOfSuggestions":0,"candidates":[]},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[],"llm_response_time":0}],"methodCompatibilityScores":{},"targetClassMap":{}}
{"id":"d9977ed8-a745-4eb5-a195-abaf6550aa6d","hostFunctionTelemetryData":{"hostFunctionSize":430,"lineStart":15,"lineEnd":444,"bodyLineStart":15,"language":"java","filePath":"/Users/snehil/Documents/ConcordiaUniversity/Material/SOEN-6491-Refactoring/OpenSource/jsoup/jsoup/src/main/java/org/jsoup/select/QueryParser.java","sourceCode":"/**\n * Parses a CSS selector into an Evaluator tree.\n */\npublic class QueryParser {\n    private final static char[] Combinators \u003d {\u0027,\u0027, \u0027\u003e\u0027, \u0027+\u0027, \u0027~\u0027, \u0027 \u0027};\n    private final static String[] AttributeEvals \u003d new String[]{\"\u003d\", \"!\u003d\", \"^\u003d\", \"$\u003d\", \"*\u003d\", \"~\u003d\"};\n\n    private final TokenQueue tq;\n    private final String query;\n    private final List\u003cEvaluator\u003e evals \u003d new ArrayList\u003c\u003e();\n\n    /**\n     * Create a new QueryParser.\n     * @param query CSS query\n     */\n    private QueryParser(String query) {\n        Validate.notEmpty(query);\n        query \u003d query.trim();\n        this.query \u003d query;\n        this.tq \u003d new TokenQueue(query);\n    }\n\n    /**\n     * Parse a CSS query into an Evaluator.\n     * @param query CSS query\n     * @return Evaluator\n     * @see Selector selector query syntax\n     */\n    public static Evaluator parse(String query) {\n        try {\n            QueryParser p \u003d new QueryParser(query);\n            return p.parse();\n        } catch (IllegalArgumentException e) {\n            throw new Selector.SelectorParseException(e.getMessage());\n        }\n    }\n\n    /**\n     * Parse the query\n     * @return Evaluator\n     */\n    Evaluator parse() {\n        tq.consumeWhitespace();\n\n        if (tq.matchesAny(Combinators)) { // if starts with a combinator, use root as elements\n            evals.add(new StructuralEvaluator.Root());\n            combinator(tq.consume());\n        } else {\n            evals.add(consumeEvaluator());\n        }\n\n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite \u003d tq.consumeWhitespace();\n\n            if (tq.matchesAny(Combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(\u0027 \u0027);\n            } else { // E.class, E#id, E[attr] etc. AND\n                evals.add(consumeEvaluator()); // take next el, #. etc off queue\n            }\n        }\n\n        if (evals.size() \u003d\u003d 1)\n            return evals.get(0);\n\n        return new CombiningEvaluator.And(evals);\n    }\n\n    private void combinator(char combinator) {\n        tq.consumeWhitespace();\n        String subQuery \u003d consumeSubQuery(); // support multi \u003e childs\n\n        Evaluator rootEval; // the new topmost evaluator\n        Evaluator currentEval; // the evaluator the new eval will be combined to. could be root, or rightmost or.\n        Evaluator newEval \u003d parse(subQuery); // the evaluator to add into target evaluator\n        boolean replaceRightMost \u003d false;\n\n        if (evals.size() \u003d\u003d 1) {\n            rootEval \u003d currentEval \u003d evals.get(0);\n            // make sure OR (,) has precedence:\n            if (rootEval instanceof CombiningEvaluator.Or \u0026\u0026 combinator !\u003d \u0027,\u0027) {\n                currentEval \u003d ((CombiningEvaluator.Or) currentEval).rightMostEvaluator();\n                assert currentEval !\u003d null; // rightMost signature can return null (if none set), but always will have one by this point\n                replaceRightMost \u003d true;\n            }\n        }\n        else {\n            rootEval \u003d currentEval \u003d new CombiningEvaluator.And(evals);\n        }\n        evals.clear();\n\n        // for most combinators: change the current eval into an AND of the current eval and the new eval\n        switch (combinator) {\n            case \u0027\u003e\u0027:\n                ImmediateParentRun run \u003d currentEval instanceof ImmediateParentRun ?\n                        (ImmediateParentRun) currentEval : new ImmediateParentRun(currentEval);\n                run.add(newEval);\n                currentEval \u003d run;\n                break;\n            case \u0027 \u0027:\n                currentEval \u003d new CombiningEvaluator.And(new StructuralEvaluator.Parent(currentEval), newEval);\n                break;\n            case \u0027+\u0027:\n                currentEval \u003d new CombiningEvaluator.And(new StructuralEvaluator.ImmediatePreviousSibling(currentEval), newEval);\n                break;\n            case \u0027~\u0027:\n                currentEval \u003d new CombiningEvaluator.And(new StructuralEvaluator.PreviousSibling(currentEval), newEval);\n                break;\n            case \u0027,\u0027:\n                CombiningEvaluator.Or or;\n                if (currentEval instanceof CombiningEvaluator.Or) {\n                    or \u003d (CombiningEvaluator.Or) currentEval;\n                } else {\n                    or \u003d new CombiningEvaluator.Or();\n                    or.add(currentEval);\n                }\n                or.add(newEval);\n                currentEval \u003d or;\n                break;\n            default:\n                throw new Selector.SelectorParseException(\"Unknown combinator \u0027%s\u0027\", combinator);\n        }\n\n        if (replaceRightMost)\n            ((CombiningEvaluator.Or) rootEval).replaceRightMostEvaluator(currentEval);\n        else rootEval \u003d currentEval;\n        evals.add(rootEval);\n    }\n\n    private String consumeSubQuery() {\n        StringBuilder sq \u003d StringUtil.borrowBuilder();\n        boolean seenClause \u003d false; // eat until we hit a combinator after eating something else\n        while (!tq.isEmpty()) {\n            if (tq.matchesAny(Combinators)) {\n                if (seenClause)\n                    break;\n                sq.append(tq.consume());\n                continue;\n            }\n            seenClause \u003d true;\n            if (tq.matches(\"(\"))\n                sq.append(\"(\").append(tq.chompBalanced(\u0027(\u0027, \u0027)\u0027)).append(\")\");\n            else if (tq.matches(\"[\"))\n                sq.append(\"[\").append(tq.chompBalanced(\u0027[\u0027, \u0027]\u0027)).append(\"]\");\n            else if (tq.matches(\"\\\\\")) { // bounce over escapes\n                sq.append(tq.consume());\n                if (!tq.isEmpty()) sq.append(tq.consume());\n            } else\n                sq.append(tq.consume());\n        }\n        return StringUtil.releaseBuilder(sq);\n    }\n\n    private Evaluator consumeEvaluator() {\n        if (tq.matchChomp(\"#\"))\n            return byId();\n        else if (tq.matchChomp(\".\"))\n            return byClass();\n        else if (tq.matchesWord() || tq.matches(\"*|\"))\n            return byTag();\n        else if (tq.matches(\"[\"))\n            return byAttribute();\n        else if (tq.matchChomp(\"*\"))\n            return new Evaluator.AllElements();\n        else if (tq.matchChomp(\":\"))\n            return parsePseudoSelector();\n\t\telse // unhandled\n            throw new Selector.SelectorParseException(\"Could not parse query \u0027%s\u0027: unexpected token at \u0027%s\u0027\", query, tq.remainder());\n    }\n\n    private Evaluator parsePseudoSelector() {\n        final String pseudo \u003d tq.consumeCssIdentifier();\n        switch (pseudo) {\n            case \"lt\":\n                return new Evaluator.IndexLessThan(consumeIndex());\n            case \"gt\":\n                return new Evaluator.IndexGreaterThan(consumeIndex());\n            case \"eq\":\n                return new Evaluator.IndexEquals(consumeIndex());\n            case \"has\":\n                return has();\n            case \"is\":\n                return is();\n            case \"contains\":\n                return contains(false);\n            case \"containsOwn\":\n                return contains(true);\n            case \"containsWholeText\":\n                return containsWholeText(false);\n            case \"containsWholeOwnText\":\n                return containsWholeText(true);\n            case \"containsData\":\n                return containsData();\n            case \"matches\":\n                return matches(false);\n            case \"matchesOwn\":\n                return matches(true);\n            case \"matchesWholeText\":\n                return matchesWholeText(false);\n            case \"matchesWholeOwnText\":\n                return matchesWholeText(true);\n            case \"not\":\n                return not();\n            case \"nth-child\":\n                return cssNthChild(false, false);\n            case \"nth-last-child\":\n                return cssNthChild(true, false);\n            case \"nth-of-type\":\n                return cssNthChild(false, true);\n            case \"nth-last-of-type\":\n                return cssNthChild(true, true);\n            case \"first-child\":\n                return new Evaluator.IsFirstChild();\n            case \"last-child\":\n                return new Evaluator.IsLastChild();\n            case \"first-of-type\":\n                return new Evaluator.IsFirstOfType();\n            case \"last-of-type\":\n                return new Evaluator.IsLastOfType();\n            case \"only-child\":\n                return new Evaluator.IsOnlyChild();\n            case \"only-of-type\":\n                return new Evaluator.IsOnlyOfType();\n            case \"empty\":\n                return new Evaluator.IsEmpty();\n            case \"root\":\n                return new Evaluator.IsRoot();\n            case \"matchText\":\n                return new Evaluator.MatchText();\n            default:\n                throw new Selector.SelectorParseException(\"Could not parse query \u0027%s\u0027: unexpected token at \u0027%s\u0027\", query, tq.remainder());\n        }\n    }\n\n    private Evaluator byId() {\n        String id \u003d tq.consumeCssIdentifier();\n        Validate.notEmpty(id);\n        return new Evaluator.Id(id);\n    }\n\n    private Evaluator byClass() {\n        String className \u003d tq.consumeCssIdentifier();\n        Validate.notEmpty(className);\n        return new Evaluator.Class(className.trim());\n    }\n\n    private Evaluator byTag() {\n        // todo - these aren\u0027t dealing perfectly with case sensitivity. For case sensitive parsers, we should also make\n        // the tag in the selector case-sensitive (and also attribute names). But for now, normalize (lower-case) for\n        // consistency - both the selector and the element tag\n        String tagName \u003d normalize(tq.consumeElementSelector());\n        Validate.notEmpty(tagName);\n\n        // namespaces:\n        if (tagName.startsWith(\"*|\")) { // namespaces: wildcard match equals(tagName) or ending in \":\"+tagName\n            String plainTag \u003d tagName.substring(2); // strip *|\n            return new CombiningEvaluator.Or(\n                new Evaluator.Tag(plainTag),\n                new Evaluator.TagEndsWith(\":\" + plainTag)\n            );\n        } else if (tagName.endsWith(\"|*\")) { // ns|*\n            String ns \u003d tagName.substring(0, tagName.length() - 2) + \":\"; // strip |*, to ns:\n            return new Evaluator.TagStartsWith(ns);\n        } else if (tagName.contains(\"|\")) { // flip \"abc|def\" to \"abc:def\"\n            tagName \u003d tagName.replace(\"|\", \":\");\n        }\n\n        return new Evaluator.Tag(tagName);\n    }\n\n    private Evaluator byAttribute() {\n        TokenQueue cq \u003d new TokenQueue(tq.chompBalanced(\u0027[\u0027, \u0027]\u0027)); // content queue\n        String key \u003d cq.consumeToAny(AttributeEvals); // eq, not, start, end, contain, match, (no val)\n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n        final Evaluator eval;\n\n        if (cq.isEmpty()) {\n            if (key.startsWith(\"^\"))\n                eval \u003d new Evaluator.AttributeStarting(key.substring(1));\n            else if (key.equals(\"*\")) // any attribute\n                eval \u003d new Evaluator.AttributeStarting(\"\");\n            else\n                eval \u003d new Evaluator.Attribute(key);\n        } else {\n            if (cq.matchChomp(\"\u003d\"))\n                eval \u003d new Evaluator.AttributeWithValue(key, cq.remainder());\n            else if (cq.matchChomp(\"!\u003d\"))\n                eval \u003d new Evaluator.AttributeWithValueNot(key, cq.remainder());\n            else if (cq.matchChomp(\"^\u003d\"))\n                eval \u003d new Evaluator.AttributeWithValueStarting(key, cq.remainder());\n            else if (cq.matchChomp(\"$\u003d\"))\n                eval \u003d new Evaluator.AttributeWithValueEnding(key, cq.remainder());\n            else if (cq.matchChomp(\"*\u003d\"))\n                eval \u003d new Evaluator.AttributeWithValueContaining(key, cq.remainder());\n            else if (cq.matchChomp(\"~\u003d\"))\n                eval \u003d new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder()));\n            else\n                throw new Selector.SelectorParseException(\"Could not parse attribute query \u0027%s\u0027: unexpected token at \u0027%s\u0027\", query, cq.remainder());\n        }\n        return eval;\n    }\n\n    //pseudo selectors :first-child, :last-child, :nth-child, ...\n    private static final Pattern NTH_AB \u003d Pattern.compile(\"(([+-])?(\\\\d+)?)n(\\\\s*([+-])?\\\\s*\\\\d+)?\", Pattern.CASE_INSENSITIVE);\n    private static final Pattern NTH_B  \u003d Pattern.compile(\"([+-])?(\\\\d+)\");\n\n\tprivate Evaluator cssNthChild(boolean backwards, boolean ofType) {\n\t\tString arg \u003d normalize(consumeParens());\n\t\tMatcher mAB \u003d NTH_AB.matcher(arg);\n\t\tMatcher mB \u003d NTH_B.matcher(arg);\n\t\tfinal int a, b;\n\t\tif (\"odd\".equals(arg)) {\n\t\t\ta \u003d 2;\n\t\t\tb \u003d 1;\n\t\t} else if (\"even\".equals(arg)) {\n\t\t\ta \u003d 2;\n\t\t\tb \u003d 0;\n\t\t} else if (mAB.matches()) {\n\t\t\ta \u003d mAB.group(3) !\u003d null ? Integer.parseInt(mAB.group(1).replaceFirst(\"^\\\\+\", \"\")) : 1;\n\t\t\tb \u003d mAB.group(4) !\u003d null ? Integer.parseInt(mAB.group(4).replaceFirst(\"^\\\\+\", \"\")) : 0;\n\t\t} else if (mB.matches()) {\n\t\t\ta \u003d 0;\n\t\t\tb \u003d Integer.parseInt(mB.group().replaceFirst(\"^\\\\+\", \"\"));\n\t\t} else {\n\t\t\tthrow new Selector.SelectorParseException(\"Could not parse nth-index \u0027%s\u0027: unexpected format\", arg);\n\t\t}\n\n        final Evaluator eval;\n\t\tif (ofType)\n\t\t\tif (backwards)\n\t\t\t\teval \u003d new Evaluator.IsNthLastOfType(a, b);\n\t\t\telse\n\t\t\t\teval \u003d new Evaluator.IsNthOfType(a, b);\n\t\telse {\n\t\t\tif (backwards)\n\t\t\t\teval \u003d (new Evaluator.IsNthLastChild(a, b));\n\t\t\telse\n\t\t\t\teval \u003d new Evaluator.IsNthChild(a, b);\n\t\t}\n        return eval;\n\t}\n\n    private String consumeParens() {\n        return tq.chompBalanced(\u0027(\u0027, \u0027)\u0027);\n    }\n\n    private int consumeIndex() {\n        String index \u003d consumeParens().trim();\n        Validate.isTrue(StringUtil.isNumeric(index), \"Index must be numeric\");\n        return Integer.parseInt(index);\n    }\n\n    // pseudo selector :has(el)\n    private Evaluator has() {\n        String subQuery \u003d consumeParens();\n        Validate.notEmpty(subQuery, \":has(selector) sub-select must not be empty\");\n        return new StructuralEvaluator.Has(parse(subQuery));\n    }\n\n    // psuedo selector :is()\n    private Evaluator is() {\n        String subQuery \u003d consumeParens();\n        Validate.notEmpty(subQuery, \":is(selector) sub-select must not be empty\");\n        return new StructuralEvaluator.Is(parse(subQuery));\n    }\n\n    // pseudo selector :contains(text), containsOwn(text)\n    private Evaluator contains(boolean own) {\n        String query \u003d own ? \":containsOwn\" : \":contains\";\n        String searchText \u003d TokenQueue.unescape(consumeParens());\n        Validate.notEmpty(searchText, query + \"(text) query must not be empty\");\n        return own\n            ? new Evaluator.ContainsOwnText(searchText)\n            : new Evaluator.ContainsText(searchText);\n    }\n\n    private Evaluator containsWholeText(boolean own) {\n        String query \u003d own ? \":containsWholeOwnText\" : \":containsWholeText\";\n        String searchText \u003d TokenQueue.unescape(consumeParens());\n        Validate.notEmpty(searchText, query + \"(text) query must not be empty\");\n        return own\n            ? new Evaluator.ContainsWholeOwnText(searchText)\n            : new Evaluator.ContainsWholeText(searchText);\n    }\n\n    // pseudo selector :containsData(data)\n    private Evaluator containsData() {\n        String searchText \u003d TokenQueue.unescape(consumeParens());\n        Validate.notEmpty(searchText, \":containsData(text) query must not be empty\");\n        return new Evaluator.ContainsData(searchText);\n    }\n\n    // :matches(regex), matchesOwn(regex)\n    private Evaluator matches(boolean own) {\n        String query \u003d own ? \":matchesOwn\" : \":matches\";\n        String regex \u003d consumeParens(); // don\u0027t unescape, as regex bits will be escaped\n        Validate.notEmpty(regex, query + \"(regex) query must not be empty\");\n\n        return own\n            ? new Evaluator.MatchesOwn(Pattern.compile(regex))\n            : new Evaluator.Matches(Pattern.compile(regex));\n    }\n\n    // :matches(regex), matchesOwn(regex)\n    private Evaluator matchesWholeText(boolean own) {\n        String query \u003d own ? \":matchesWholeOwnText\" : \":matchesWholeText\";\n        String regex \u003d consumeParens(); // don\u0027t unescape, as regex bits will be escaped\n        Validate.notEmpty(regex, query + \"(regex) query must not be empty\");\n\n        return own\n            ? new Evaluator.MatchesWholeOwnText(Pattern.compile(regex))\n            : new Evaluator.MatchesWholeText(Pattern.compile(regex));\n    }\n\n    // :not(selector)\n    private Evaluator not() {\n        String subQuery \u003d consumeParens();\n        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n\n        return new StructuralEvaluator.Not(parse(subQuery));\n    }\n\n    @Override\n    public String toString() {\n        return query;\n    }\n}","methodCount":23,"staticMethodCount":1,"instanceMethodCount":22,"classLoc":430,"innerClassCount":0},"candidatesTelemetryData":{"numberOfSuggestions":3,"candidates":[{"lineStart":359,"lineEnd":361,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method consumeParens to class TokenQueue","description":"Move method consumeParens to org.jsoup.parser.TokenQueue\nRationale: The method consumeParens() is highly related to the existing methods within the TokenQueue class. Specifically, it directly interacts with the chompBalanced method, which is a core feature of TokenQueue. TokenQueue is inherently designed to consume, match, and manipulate sequences of tokens, making it the most appropriate location for this method. Moving consumeParens() to TokenQueue will centralize token handling functionality, promote reusability, and maintain cohesive design.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false,"userRating":"Very Helpful"},{"lineStart":250,"lineEnd":254,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method byId to class TokenQueue","description":"Move method byId to org.jsoup.parser.TokenQueue\nRationale: The byId() method uses the consumeCssIdentifier() method, which is part of the TokenQueue class. This indicates that the functionality of consumeCssIdentifier() is closely related to the purpose of byId(). Since TokenQueue is responsible for handling CSS identifiers and parsing operations, it makes sense for the byId() method to be part of TokenQueue. Additionally, moving byId() to TokenQueue will encapsulate related functionality within the same class, promoting cohesion and reducing inter-class dependencies.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Helpful"},{"lineStart":256,"lineEnd":260,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method byClass to class TokenQueue","description":"Move method byClass to org.jsoup.parser.TokenQueue\nRationale: The method byClass() consumes a CSS identifier through the method consumeCssIdentifier() from the TokenQueue class. Since the method heavily relies on functionality provided by TokenQueue, it is most appropriate to place it within the TokenQueue class to maintain encapsulation and cohesion. Keeping the related parsing logic together will make the code easier to maintain and understand.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Helpful"}]},"userSelectionTelemetryData":{"lineStart":359,"lineEnd":361,"functionSize":3,"positionInHostFunction":344,"selectedCandidateIndex":0,"candidateType":"AS_IS","elementsType":[{"elementType":"METHOD","quantity":1}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":135939},{"candidateIndex":1,"elapsedTime":20095},{"candidateIndex":2,"elapsedTime":9379}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":43815},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"parse","method_signature":" parse()","target_class":"","rationale":""},{"method_name":"combinator","method_signature":"private combinator(char combinator)","target_class":"","rationale":""},{"method_name":"consumeSubQuery","method_signature":"private consumeSubQuery()","target_class":"","rationale":""},{"method_name":"consumeEvaluator","method_signature":"private consumeEvaluator()","target_class":"","rationale":""},{"method_name":"parsePseudoSelector","method_signature":"private parsePseudoSelector()","target_class":"","rationale":""},{"method_name":"byId","method_signature":"private byId()","target_class":"","rationale":""},{"method_name":"byClass","method_signature":"private byClass()","target_class":"","rationale":""},{"method_name":"byTag","method_signature":"private byTag()","target_class":"","rationale":""},{"method_name":"byAttribute","method_signature":"private byAttribute()","target_class":"","rationale":""},{"method_name":"consumeParens","method_signature":"private consumeParens()","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"parsePseudoSelector","method_signature":"private parsePseudoSelector()","target_class":"","rationale":""},{"method_name":"consumeParens","method_signature":"private consumeParens()","target_class":"","rationale":""},{"method_name":"consumeEvaluator","method_signature":"private consumeEvaluator()","target_class":"","rationale":""},{"method_name":"consumeSubQuery","method_signature":"private consumeSubQuery()","target_class":"","rationale":""},{"method_name":"parse","method_signature":" parse()","target_class":"","rationale":""},{"method_name":"byId","method_signature":"private byId()","target_class":"","rationale":""},{"method_name":"byClass","method_signature":"private byClass()","target_class":"","rationale":""},{"method_name":"byTag","method_signature":"private byTag()","target_class":"","rationale":""},{"method_name":"byAttribute","method_signature":"private byAttribute()","target_class":"","rationale":""},{"method_name":"combinator","method_signature":"private combinator(char combinator)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"private parsePseudoSelector()":{"first":{"method_name":"parsePseudoSelector","method_signature":"private parsePseudoSelector()","target_class":"","rationale":""},"second":0.3201898499188461},"private consumeParens()":{"first":{"method_name":"consumeParens","method_signature":"private consumeParens()","target_class":"","rationale":""},"second":0.431298989949924},"private consumeEvaluator()":{"first":{"method_name":"consumeEvaluator","method_signature":"private consumeEvaluator()","target_class":"","rationale":""},"second":0.5263291588529811},"private consumeSubQuery()":{"first":{"method_name":"consumeSubQuery","method_signature":"private consumeSubQuery()","target_class":"","rationale":""},"second":0.5453322059542641}," parse()":{"first":{"method_name":"parse","method_signature":" parse()","target_class":"","rationale":""},"second":0.5687055701842021},"private byId()":{"first":{"method_name":"byId","method_signature":"private byId()","target_class":"","rationale":""},"second":0.616121018249073},"private byClass()":{"first":{"method_name":"byClass","method_signature":"private byClass()","target_class":"","rationale":""},"second":0.616121018249073},"private byTag()":{"first":{"method_name":"byTag","method_signature":"private byTag()","target_class":"","rationale":""},"second":0.6270631716207286},"private byAttribute()":{"first":{"method_name":"byAttribute","method_signature":"private byAttribute()","target_class":"","rationale":""},"second":0.6539860884833942},"private combinator(char combinator)":{"first":{"method_name":"combinator","method_signature":"private combinator(char combinator)","target_class":"","rationale":""},"second":0.6652009714811995}},"targetClassMap":{"parsePseudoSelector":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":4046,"similarity_computation_time":0,"similarity_metric":"cosine"},"consumeParens":{"target_classes":[{"class_name":"TokenQueue","similarity_score":0.41815006391643533}],"target_classes_sorted_by_llm":["TokenQueue"],"llm_response_time":4017,"similarity_computation_time":1,"similarity_metric":"cosine"},"consumeEvaluator":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":4526,"similarity_computation_time":0,"similarity_metric":"cosine"},"consumeSubQuery":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":3710,"similarity_computation_time":0,"similarity_metric":"cosine"},"parse":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":3222,"similarity_computation_time":0,"similarity_metric":"cosine"},"byId":{"target_classes":[{"class_name":"TokenQueue","similarity_score":0.4193295188017078}],"target_classes_sorted_by_llm":["TokenQueue"],"llm_response_time":4813,"similarity_computation_time":1,"similarity_metric":"cosine"},"byClass":{"target_classes":[{"class_name":"TokenQueue","similarity_score":0.4193295188017078}],"target_classes_sorted_by_llm":["TokenQueue"],"llm_response_time":3674,"similarity_computation_time":1,"similarity_metric":"cosine"},"byTag":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5116,"similarity_computation_time":0,"similarity_metric":"cosine"},"byAttribute":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":6224,"similarity_computation_time":0,"similarity_metric":"cosine"},"combinator":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":4333,"similarity_computation_time":0,"similarity_metric":"cosine"}}}
{"id":"1c31f726-6e10-4db0-9818-3d3827512e07","hostFunctionTelemetryData":{"hostFunctionSize":945,"lineStart":21,"lineEnd":965,"bodyLineStart":21,"language":"java","filePath":"/Users/snehil/Documents/ConcordiaUniversity/Material/SOEN-6491-Refactoring/OpenSource/jsoup/jsoup/src/main/java/org/jsoup/nodes/Node.java","sourceCode":"/**\n The base, abstract Node model. {@link Element}, {@link Document}, {@link Comment}, {@link TextNode}, et al.,\n are instances of Node.\n\n @author Jonathan Hedley, jonathan@hedley.net */\npublic abstract class Node implements Cloneable {\n    static final List\u003cNode\u003e EmptyNodes \u003d Collections.emptyList();\n    static final String EmptyString \u003d \"\";\n    @Nullable Node parentNode; // Nodes don\u0027t always have parents\n    int siblingIndex;\n\n    /**\n     * Default constructor. Doesn\u0027t set up base uri, children, or attributes; use with caution.\n     */\n    protected Node() {\n    }\n\n    /**\n     Get the node name of this node. Use for debugging purposes and not logic switching (for that, use instanceof).\n     @return node name\n     */\n    public abstract String nodeName();\n\n    /**\n     Get the normalized name of this node. For node types other than Element, this is the same as {@link #nodeName()}.\n     For an Element, will be the lower-cased tag name.\n     @return normalized node name\n     @since 1.15.4.\n     */\n    public String normalName() {\n        return nodeName();\n    }\n\n    /**\n     Test if this node has the specified normalized name, in any namespace.\n     * @param normalName a normalized element name (e.g. {@code div}).\n     * @return true if the element\u0027s normal name matches exactly\n     * @since 1.17.2\n     */\n    public boolean nameIs(String normalName) {\n        return normalName().equals(normalName);\n    }\n\n    /**\n     Test if this node\u0027s parent has the specified normalized name.\n     * @param normalName a normalized name (e.g. {@code div}).\n     * @return true if the parent element\u0027s normal name matches exactly\n     * @since 1.17.2\n     */\n    public boolean parentNameIs(String normalName) {\n        return parentNode !\u003d null \u0026\u0026 parentNode.normalName().equals(normalName);\n    }\n\n    /**\n     Test if this node\u0027s parent is an Element with the specified normalized name and namespace.\n     * @param normalName a normalized element name (e.g. {@code div}).\n     * @param namespace the namespace\n     * @return true if the parent element\u0027s normal name matches exactly, and that element is in the specified namespace\n     * @since 1.17.2\n     */\n    public boolean parentElementIs(String normalName, String namespace) {\n        return parentNode !\u003d null \u0026\u0026 parentNode instanceof Element\n            \u0026\u0026 ((Element) parentNode).elementIs(normalName, namespace);\n    }\n\n    /**\n     * Check if this Node has an actual Attributes object.\n     */\n    protected abstract boolean hasAttributes();\n\n    /**\n     Checks if this node has a parent. Nodes won\u0027t have parents if (e.g.) they are newly created and not added as a child\n     to an existing node, or if they are a {@link #shallowClone()}. In such cases, {@link #parent()} will return {@code null}.\n     @return if this node has a parent.\n     */\n    public boolean hasParent() {\n        return parentNode !\u003d null;\n    }\n\n    /**\n     * Get an attribute\u0027s value by its key. \u003cb\u003eCase insensitive\u003c/b\u003e\n     * \u003cp\u003e\n     * To get an absolute URL from an attribute that may be a relative URL, prefix the key with \u003ccode\u003e\u003cb\u003eabs:\u003c/b\u003e\u003c/code\u003e,\n     * which is a shortcut to the {@link #absUrl} method.\n     * \u003c/p\u003e\n     * E.g.:\n     * \u003cblockquote\u003e\u003ccode\u003eString url \u003d a.attr(\"abs:href\");\u003c/code\u003e\u003c/blockquote\u003e\n     *\n     * @param attributeKey The attribute key.\n     * @return The attribute, or empty string if not present (to avoid nulls).\n     * @see #attributes()\n     * @see #hasAttr(String)\n     * @see #absUrl(String)\n     */\n    public String attr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        if (!hasAttributes())\n            return EmptyString;\n\n        String val \u003d attributes().getIgnoreCase(attributeKey);\n        if (val.length() \u003e 0)\n            return val;\n        else if (attributeKey.startsWith(\"abs:\"))\n            return absUrl(attributeKey.substring(\"abs:\".length()));\n        else return \"\";\n    }\n\n    /**\n     * Get each of the Element\u0027s attributes.\n     * @return attributes (which implements Iterable, with the same order as presented in the original HTML).\n     */\n    public abstract Attributes attributes();\n\n    /**\n     Get the number of attributes that this Node has.\n     @return the number of attributes\n     @since 1.14.2\n     */\n    public int attributesSize() {\n        // added so that we can test how many attributes exist without implicitly creating the Attributes object\n        return hasAttributes() ? attributes().size() : 0;\n    }\n\n    /**\n     * Set an attribute (key\u003dvalue). If the attribute already exists, it is replaced. The attribute key comparison is\n     * \u003cb\u003ecase insensitive\u003c/b\u003e. The key will be set with case sensitivity as set in the parser settings.\n     * @param attributeKey The attribute key.\n     * @param attributeValue The attribute value.\n     * @return this (for chaining)\n     */\n    public Node attr(String attributeKey, String attributeValue) {\n        attributeKey \u003d NodeUtils.parser(this).settings().normalizeAttribute(attributeKey);\n        attributes().putIgnoreCase(attributeKey, attributeValue);\n        return this;\n    }\n\n    /**\n     * Test if this Node has an attribute. \u003cb\u003eCase insensitive\u003c/b\u003e.\n     * @param attributeKey The attribute key to check.\n     * @return true if the attribute exists, false if not.\n     */\n    public boolean hasAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        if (!hasAttributes())\n            return false;\n\n        if (attributeKey.startsWith(\"abs:\")) {\n            String key \u003d attributeKey.substring(\"abs:\".length());\n            if (attributes().hasKeyIgnoreCase(key) \u0026\u0026 !absUrl(key).isEmpty())\n                return true;\n        }\n        return attributes().hasKeyIgnoreCase(attributeKey);\n    }\n\n    /**\n     * Remove an attribute from this node.\n     * @param attributeKey The attribute to remove.\n     * @return this (for chaining)\n     */\n    public Node removeAttr(String attributeKey) {\n        Validate.notNull(attributeKey);\n        if (hasAttributes())\n            attributes().removeIgnoreCase(attributeKey);\n        return this;\n    }\n\n    /**\n     * Clear (remove) each of the attributes in this node.\n     * @return this, for chaining\n     */\n    public Node clearAttributes() {\n        if (hasAttributes()) {\n            Iterator\u003cAttribute\u003e it \u003d attributes().iterator();\n            while (it.hasNext()) {\n                it.next();\n                it.remove();\n            }\n        }\n        return this;\n    }\n\n    /**\n     Get the base URI that applies to this node. Will return an empty string if not defined. Used to make relative links\n     absolute.\n\n     @return base URI\n     @see #absUrl\n     */\n    public abstract String baseUri();\n\n    /**\n     * Set the baseUri for just this node (not its descendants), if this Node tracks base URIs.\n     * @param baseUri new URI\n     */\n    protected abstract void doSetBaseUri(String baseUri);\n\n    /**\n     Update the base URI of this node and all of its descendants.\n     @param baseUri base URI to set\n     */\n    public void setBaseUri(final String baseUri) {\n        Validate.notNull(baseUri);\n        doSetBaseUri(baseUri);\n    }\n\n    /**\n     * Get an absolute URL from a URL attribute that may be relative (such as an \u003ccode\u003e\u0026lt;a href\u0026gt;\u003c/code\u003e or\n     * \u003ccode\u003e\u0026lt;img src\u0026gt;\u003c/code\u003e).\n     * \u003cp\u003e\n     * E.g.: \u003ccode\u003eString absUrl \u003d linkEl.absUrl(\"href\");\u003c/code\u003e\n     * \u003c/p\u003e\n     * \u003cp\u003e\n     * If the attribute value is already absolute (i.e. it starts with a protocol, like\n     * \u003ccode\u003ehttp://\u003c/code\u003e or \u003ccode\u003ehttps://\u003c/code\u003e etc), and it successfully parses as a URL, the attribute is\n     * returned directly. Otherwise, it is treated as a URL relative to the element\u0027s {@link #baseUri}, and made\n     * absolute using that.\n     * \u003c/p\u003e\n     * \u003cp\u003e\n     * As an alternate, you can use the {@link #attr} method with the \u003ccode\u003eabs:\u003c/code\u003e prefix, e.g.:\n     * \u003ccode\u003eString absUrl \u003d linkEl.attr(\"abs:href\");\u003c/code\u003e\n     * \u003c/p\u003e\n     *\n     * @param attributeKey The attribute key\n     * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n     * could not be made successfully into a URL.\n     * @see #attr\n     * @see java.net.URL#URL(java.net.URL, String)\n     */\n    public String absUrl(String attributeKey) {\n        Validate.notEmpty(attributeKey);\n        if (!(hasAttributes() \u0026\u0026 attributes().hasKeyIgnoreCase(attributeKey))) // not using hasAttr, so that we don\u0027t recurse down hasAttr-\u003eabsUrl\n            return \"\";\n\n        return StringUtil.resolve(baseUri(), attributes().getIgnoreCase(attributeKey));\n    }\n\n    protected abstract List\u003cNode\u003e ensureChildNodes();\n\n    /**\n     Get a child node by its 0-based index.\n     @param index index of child node\n     @return the child node at this index.\n     @throws IndexOutOfBoundsException if the index is out of bounds.\n     */\n    public Node childNode(int index) {\n        return ensureChildNodes().get(index);\n    }\n\n    /**\n     Get this node\u0027s children. Presented as an unmodifiable list: new children can not be added, but the child nodes\n     themselves can be manipulated.\n     @return list of children. If no children, returns an empty list.\n     */\n    public List\u003cNode\u003e childNodes() {\n        if (childNodeSize() \u003d\u003d 0)\n            return EmptyNodes;\n\n        List\u003cNode\u003e children \u003d ensureChildNodes();\n        List\u003cNode\u003e rewrap \u003d new ArrayList\u003c\u003e(children.size()); // wrapped so that looping and moving will not throw a CME as the source changes\n        rewrap.addAll(children);\n        return Collections.unmodifiableList(rewrap);\n    }\n\n    /**\n     * Returns a deep copy of this node\u0027s children. Changes made to these nodes will not be reflected in the original\n     * nodes\n     * @return a deep copy of this node\u0027s children\n     */\n    public List\u003cNode\u003e childNodesCopy() {\n        final List\u003cNode\u003e nodes \u003d ensureChildNodes();\n        final ArrayList\u003cNode\u003e children \u003d new ArrayList\u003c\u003e(nodes.size());\n        for (Node node : nodes) {\n            children.add(node.clone());\n        }\n        return children;\n    }\n\n    /**\n     * Get the number of child nodes that this node holds.\n     * @return the number of child nodes that this node holds.\n     */\n    public abstract int childNodeSize();\n\n    protected Node[] childNodesAsArray() {\n        return ensureChildNodes().toArray(new Node[0]);\n    }\n\n    /**\n     * Delete all this node\u0027s children.\n     * @return this node, for chaining\n     */\n    public abstract Node empty();\n\n\n    /**\n     Gets this node\u0027s parent node.\n     @return parent node; or null if no parent.\n     @see #hasParent()\n     */\n    public @Nullable Node parent() {\n        return parentNode;\n    }\n\n    /**\n     Gets this node\u0027s parent node. Not overridable by extending classes, so useful if you really just need the Node type.\n     @return parent node; or null if no parent.\n     */\n    public @Nullable final Node parentNode() {\n        return parentNode;\n    }\n\n    /**\n     * Get this node\u0027s root node; that is, its topmost ancestor. If this node is the top ancestor, returns {@code this}.\n     * @return topmost ancestor.\n     */\n    public Node root() {\n        Node node \u003d this;\n        while (node.parentNode !\u003d null)\n            node \u003d node.parentNode;\n        return node;\n    }\n\n    /**\n     * Gets the Document associated with this Node.\n     * @return the Document associated with this Node, or null if there is no such Document.\n     */\n    public @Nullable Document ownerDocument() {\n        Node root \u003d root();\n        return (root instanceof Document) ? (Document) root : null;\n    }\n\n    /**\n     * Remove (delete) this node from the DOM tree. If this node has children, they are also removed. If this node is\n     * an orphan, nothing happens.\n     */\n    public void remove() {\n        if (parentNode !\u003d null)\n            parentNode.removeChild(this);\n    }\n\n    /**\n     * Insert the specified HTML into the DOM before this node (as a preceding sibling).\n     * @param html HTML to add before this node\n     * @return this node, for chaining\n     * @see #after(String)\n     */\n    public Node before(String html) {\n        addSiblingHtml(siblingIndex, html);\n        return this;\n    }\n\n    /**\n     * Insert the specified node into the DOM before this node (as a preceding sibling).\n     * @param node to add before this node\n     * @return this node, for chaining\n     * @see #after(Node)\n     */\n    public Node before(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        // if the incoming node is a sibling of this, remove it first so siblingIndex is correct on add\n        if (node.parentNode \u003d\u003d parentNode) node.remove();\n\n        parentNode.addChildren(siblingIndex, node);\n        return this;\n    }\n\n    /**\n     * Insert the specified HTML into the DOM after this node (as a following sibling).\n     * @param html HTML to add after this node\n     * @return this node, for chaining\n     * @see #before(String)\n     */\n    public Node after(String html) {\n        addSiblingHtml(siblingIndex + 1, html);\n        return this;\n    }\n\n    /**\n     * Insert the specified node into the DOM after this node (as a following sibling).\n     * @param node to add after this node\n     * @return this node, for chaining\n     * @see #before(Node)\n     */\n    public Node after(Node node) {\n        Validate.notNull(node);\n        Validate.notNull(parentNode);\n\n        // if the incoming node is a sibling of this, remove it first so siblingIndex is correct on add\n        if (node.parentNode \u003d\u003d parentNode) node.remove();\n\n        parentNode.addChildren(siblingIndex + 1, node);\n        return this;\n    }\n\n    private void addSiblingHtml(int index, String html) {\n        Validate.notNull(html);\n        Validate.notNull(parentNode);\n\n        Element context \u003d parentNode instanceof Element ? (Element) parentNode : null;\n        List\u003cNode\u003e nodes \u003d NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());\n        parentNode.addChildren(index, nodes.toArray(new Node[0]));\n    }\n\n    /**\n     Wrap the supplied HTML around this node.\n\n     @param html HTML to wrap around this node, e.g. {@code \u003cdiv class\u003d\"head\"\u003e\u003c/div\u003e}. Can be arbitrarily deep. If\n     the input HTML does not parse to a result starting with an Element, this will be a no-op.\n     @return this node, for chaining.\n     */\n    public Node wrap(String html) {\n        Validate.notEmpty(html);\n\n        // Parse context - parent (because wrapping), this, or null\n        Element context \u003d\n            parentNode !\u003d null \u0026\u0026 parentNode instanceof Element ? (Element) parentNode :\n                this instanceof Element ? (Element) this :\n                    null;\n        List\u003cNode\u003e wrapChildren \u003d NodeUtils.parser(this).parseFragmentInput(html, context, baseUri());\n        Node wrapNode \u003d wrapChildren.get(0);\n        if (!(wrapNode instanceof Element)) // nothing to wrap with; noop\n            return this;\n\n        Element wrap \u003d (Element) wrapNode;\n        Element deepest \u003d getDeepChild(wrap);\n        if (parentNode !\u003d null)\n            parentNode.replaceChild(this, wrap);\n        deepest.addChildren(this); // side effect of tricking wrapChildren to lose first\n\n        // remainder (unbalanced wrap, like \u003cdiv\u003e\u003c/div\u003e\u003cp\u003e\u003c/p\u003e -- The \u003cp\u003e is remainder\n        if (wrapChildren.size() \u003e 0) {\n            //noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\n            for (int i \u003d 0; i \u003c wrapChildren.size(); i++) {\n                Node remainder \u003d wrapChildren.get(i);\n                // if no parent, this could be the wrap node, so skip\n                if (wrap \u003d\u003d remainder)\n                    continue;\n\n                if (remainder.parentNode !\u003d null)\n                    remainder.parentNode.removeChild(remainder);\n                wrap.after(remainder);\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Removes this node from the DOM, and moves its children up into the node\u0027s parent. This has the effect of dropping\n     * the node but keeping its children.\n     * \u003cp\u003e\n     * For example, with the input html:\n     * \u003c/p\u003e\n     * \u003cp\u003e{@code \u003cdiv\u003eOne \u003cspan\u003eTwo \u003cb\u003eThree\u003c/b\u003e\u003c/span\u003e\u003c/div\u003e}\u003c/p\u003e\n     * Calling {@code element.unwrap()} on the {@code span} element will result in the html:\n     * \u003cp\u003e{@code \u003cdiv\u003eOne Two \u003cb\u003eThree\u003c/b\u003e\u003c/div\u003e}\u003c/p\u003e\n     * and the {@code \"Two \"} {@link TextNode} being returned.\n     *\n     * @return the first child of this node, after the node has been unwrapped. @{code Null} if the node had no children.\n     * @see #remove()\n     * @see #wrap(String)\n     */\n    public @Nullable Node unwrap() {\n        Validate.notNull(parentNode);\n        Node firstChild \u003d firstChild();\n        parentNode.addChildren(siblingIndex, this.childNodesAsArray());\n        this.remove();\n\n        return firstChild;\n    }\n\n    private static Element getDeepChild(Element el) {\n        Element child \u003d el.firstElementChild();\n        while (child !\u003d null) {\n            el \u003d child;\n            child \u003d child.firstElementChild();\n        }\n        return el;\n    }\n\n    void nodelistChanged() {\n        // Element overrides this to clear its shadow children elements\n    }\n\n    /**\n     * Replace this node in the DOM with the supplied node.\n     * @param in the node that will replace the existing node.\n     */\n    public void replaceWith(Node in) {\n        Validate.notNull(in);\n        Validate.notNull(parentNode);\n        parentNode.replaceChild(this, in);\n    }\n\n    protected void setParentNode(Node parentNode) {\n        Validate.notNull(parentNode);\n        if (this.parentNode !\u003d null)\n            this.parentNode.removeChild(this);\n        this.parentNode \u003d parentNode;\n    }\n\n    protected void replaceChild(Node out, Node in) {\n        Validate.isTrue(out.parentNode \u003d\u003d this);\n        Validate.notNull(in);\n        if (out \u003d\u003d in) return; // no-op self replacement\n\n        if (in.parentNode !\u003d null)\n            in.parentNode.removeChild(in);\n\n        final int index \u003d out.siblingIndex;\n        ensureChildNodes().set(index, in);\n        in.parentNode \u003d this;\n        in.setSiblingIndex(index);\n        out.parentNode \u003d null;\n    }\n\n    protected void removeChild(Node out) {\n        Validate.isTrue(out.parentNode \u003d\u003d this);\n        final int index \u003d out.siblingIndex;\n        ensureChildNodes().remove(index);\n        reindexChildren(index);\n        out.parentNode \u003d null;\n    }\n\n    protected void addChildren(Node... children) {\n        //most used. short circuit addChildren(int), which hits reindex children and array copy\n        final List\u003cNode\u003e nodes \u003d ensureChildNodes();\n\n        for (Node child: children) {\n            reparentChild(child);\n            nodes.add(child);\n            child.setSiblingIndex(nodes.size()-1);\n        }\n    }\n\n    protected void addChildren(int index, Node... children) {\n        Validate.notNull(children);\n        if (children.length \u003d\u003d 0) {\n            return;\n        }\n        final List\u003cNode\u003e nodes \u003d ensureChildNodes();\n\n        // fast path - if used as a wrap (index\u003d0, children \u003d child[0].parent.children - do inplace\n        final Node firstParent \u003d children[0].parent();\n        if (firstParent !\u003d null \u0026\u0026 firstParent.childNodeSize() \u003d\u003d children.length) {\n            boolean sameList \u003d true;\n            final List\u003cNode\u003e firstParentNodes \u003d firstParent.ensureChildNodes();\n            // identity check contents to see if same\n            int i \u003d children.length;\n            while (i-- \u003e 0) {\n                if (children[i] !\u003d firstParentNodes.get(i)) {\n                    sameList \u003d false;\n                    break;\n                }\n            }\n            if (sameList) { // moving, so OK to empty firstParent and short-circuit\n                boolean wasEmpty \u003d childNodeSize() \u003d\u003d 0;\n                firstParent.empty();\n                nodes.addAll(index, Arrays.asList(children));\n                i \u003d children.length;\n                while (i-- \u003e 0) {\n                    children[i].parentNode \u003d this;\n                }\n                if (!(wasEmpty \u0026\u0026 children[0].siblingIndex \u003d\u003d 0)) // skip reindexing if we just moved\n                    reindexChildren(index);\n                return;\n            }\n        }\n\n        Validate.noNullElements(children);\n        for (Node child : children) {\n            reparentChild(child);\n        }\n        nodes.addAll(index, Arrays.asList(children));\n        reindexChildren(index);\n    }\n    \n    protected void reparentChild(Node child) {\n        child.setParentNode(this);\n    }\n\n    private void reindexChildren(int start) {\n        final int size \u003d childNodeSize();\n        if (size \u003d\u003d 0) return;\n        final List\u003cNode\u003e childNodes \u003d ensureChildNodes();\n        for (int i \u003d start; i \u003c size; i++) {\n            childNodes.get(i).setSiblingIndex(i);\n        }\n    }\n\n    /**\n     Retrieves this node\u0027s sibling nodes. Similar to {@link #childNodes() node.parent.childNodes()}, but does not\n     include this node (a node is not a sibling of itself).\n     @return node siblings. If the node has no parent, returns an empty list.\n     */\n    public List\u003cNode\u003e siblingNodes() {\n        if (parentNode \u003d\u003d null)\n            return Collections.emptyList();\n\n        List\u003cNode\u003e nodes \u003d parentNode.ensureChildNodes();\n        List\u003cNode\u003e siblings \u003d new ArrayList\u003c\u003e(nodes.size() - 1);\n        for (Node node: nodes)\n            if (node !\u003d this)\n                siblings.add(node);\n        return siblings;\n    }\n\n    /**\n     Get this node\u0027s next sibling.\n     @return next sibling, or {@code null} if this is the last sibling\n     */\n    public @Nullable Node nextSibling() {\n        if (parentNode \u003d\u003d null)\n            return null; // root\n\n        final List\u003cNode\u003e siblings \u003d parentNode.ensureChildNodes();\n        final int index \u003d siblingIndex+1;\n        if (siblings.size() \u003e index)\n            return siblings.get(index);\n        else\n            return null;\n    }\n\n    /**\n     Get this node\u0027s previous sibling.\n     @return the previous sibling, or @{code null} if this is the first sibling\n     */\n    public @Nullable Node previousSibling() {\n        if (parentNode \u003d\u003d null)\n            return null; // root\n\n        if (siblingIndex \u003e 0)\n            return parentNode.ensureChildNodes().get(siblingIndex-1);\n        else\n            return null;\n    }\n\n    /**\n     * Get the list index of this node in its node sibling list. E.g. if this is the first node\n     * sibling, returns 0.\n     * @return position in node sibling list\n     * @see org.jsoup.nodes.Element#elementSiblingIndex()\n     */\n    public int siblingIndex() {\n        return siblingIndex;\n    }\n\n    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex \u003d siblingIndex;\n    }\n\n    /**\n     Gets the first child node of this node, or {@code null} if there is none. This could be any Node type, such as an\n     Element, TextNode, Comment, etc. Use {@link Element#firstElementChild()} to get the first Element child.\n     @return the first child node, or null if there are no children.\n     @see Element#firstElementChild()\n     @see #lastChild()\n     @since 1.15.2\n     */\n    public @Nullable Node firstChild() {\n        if (childNodeSize() \u003d\u003d 0) return null;\n        return ensureChildNodes().get(0);\n    }\n\n    /**\n     Gets the last child node of this node, or {@code null} if there is none.\n     @return the last child node, or null if there are no children.\n     @see Element#lastElementChild()\n     @see #firstChild()\n     @since 1.15.2\n     */\n    public @Nullable Node lastChild() {\n        final int size \u003d childNodeSize();\n        if (size \u003d\u003d 0) return null;\n        List\u003cNode\u003e children \u003d ensureChildNodes();\n        return children.get(size - 1);\n    }\n\n    /**\n     * Perform a depth-first traversal through this node and its descendants.\n     * @param nodeVisitor the visitor callbacks to perform on each node\n     * @return this node, for chaining\n     */\n    public Node traverse(NodeVisitor nodeVisitor) {\n        Validate.notNull(nodeVisitor);\n        NodeTraversor.traverse(nodeVisitor, this);\n        return this;\n    }\n\n    /**\n     Perform the supplied action on this Node and each of its descendants, during a depth-first traversal. Nodes may be\n     inspected, changed, added, replaced, or removed.\n     @param action the function to perform on the node\n     @return this Node, for chaining\n     @see Element#forEach(Consumer)\n     */\n    public Node forEachNode(Consumer\u003c? super Node\u003e action) {\n        Validate.notNull(action);\n        nodeStream().forEach(action);\n        return this;\n    }\n\n    /**\n     * Perform a depth-first filtered traversal through this node and its descendants.\n     * @param nodeFilter the filter callbacks to perform on each node\n     * @return this node, for chaining\n     */\n    public Node filter(NodeFilter nodeFilter) {\n        Validate.notNull(nodeFilter);\n        NodeTraversor.filter(nodeFilter, this);\n        return this;\n    }\n\n    /**\n     Returns a Stream of this Node and all of its descendant Nodes. The stream has document order.\n     @return a stream of all nodes.\n     @see Element#stream()\n     @since 1.17.1\n     */\n    public Stream\u003cNode\u003e nodeStream() {\n        return NodeUtils.stream(this, Node.class);\n    }\n\n    /**\n     Returns a Stream of this and descendant nodes, containing only nodes of the specified type. The stream has document\n     order.\n     @return a stream of nodes filtered by type.\n     @see Element#stream()\n     @since 1.17.1\n     */\n    public \u003cT extends Node\u003e Stream\u003cT\u003e nodeStream(Class\u003cT\u003e type) {\n        return NodeUtils.stream(this, type);\n    }\n\n    /**\n     Get the outer HTML of this node. For example, on a {@code p} element, may return {@code \u003cp\u003ePara\u003c/p\u003e}.\n     @return outer HTML\n     @see Element#html()\n     @see Element#text()\n     */\n    public String outerHtml() {\n        StringBuilder accum \u003d StringUtil.borrowBuilder();\n        outerHtml(accum);\n        return StringUtil.releaseBuilder(accum);\n    }\n\n    protected void outerHtml(Appendable accum) {\n        NodeTraversor.traverse(new OuterHtmlVisitor(accum, NodeUtils.outputSettings(this)), this);\n    }\n\n    /**\n     Get the outer HTML of this node.\n     @param accum accumulator to place HTML into\n     @throws IOException if appending to the given accumulator fails.\n     */\n    abstract void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException;\n\n    abstract void outerHtmlTail(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException;\n\n    /**\n     * Write this node and its children to the given {@link Appendable}.\n     *\n     * @param appendable the {@link Appendable} to write to.\n     * @return the supplied {@link Appendable}, for chaining.\n     */\n    public \u003cT extends Appendable\u003e T html(T appendable) {\n        outerHtml(appendable);\n        return appendable;\n    }\n\n    /**\n     Get the source range (start and end positions) in the original input source from which this node was parsed.\n     Position tracking must be enabled prior to parsing the content. For an Element, this will be the positions of the\n     start tag.\n     @return the range for the start of the node, or {@code untracked} if its range was not tracked.\n     @see org.jsoup.parser.Parser#setTrackPosition(boolean)\n     @see Range#isImplicit()\n     @see Element#endSourceRange()\n     @see Attributes#sourceRange(String name)\n     @since 1.15.2\n     */\n    public Range sourceRange() {\n        return Range.of(this, true);\n    }\n\n    /** Test if this node is the first child, or first following blank text. */\n    final boolean isEffectivelyFirst() {\n        if (siblingIndex \u003d\u003d 0) return true;\n        if (siblingIndex \u003d\u003d 1) {\n            final Node prev \u003d previousSibling();\n            return prev instanceof TextNode \u0026\u0026 (((TextNode) prev).isBlank());\n        }\n        return false;\n    }\n\n    /**\n     * Gets this node\u0027s outer HTML.\n     * @return outer HTML.\n     * @see #outerHtml()\n     */\n\tpublic String toString() {\n        return outerHtml();\n    }\n\n    protected void indent(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        accum.append(\u0027\\n\u0027).append(StringUtil.padding(depth * out.indentAmount(), out.maxPaddingWidth()));\n    }\n\n    /**\n     * Check if this node is the same instance of another (object identity test).\n     * \u003cp\u003eFor an node value equality check, see {@link #hasSameValue(Object)}\u003c/p\u003e\n     * @param o other object to compare to\n     * @return true if the content of this node is the same as the other\n     * @see Node#hasSameValue(Object)\n     */\n    @Override\n    public boolean equals(@Nullable Object o) {\n        // implemented just so that javadoc is clear this is an identity test\n        return this \u003d\u003d o;\n    }\n\n    /**\n     Provides a hashCode for this Node, based on its object identity. Changes to the Node\u0027s content will not impact the\n     result.\n     @return an object identity based hashcode for this Node\n     */\n    @Override\n    public int hashCode() {\n        // implemented so that javadoc and scanners are clear this is an identity test\n        return super.hashCode();\n    }\n\n    /**\n     * Check if this node has the same content as another node. A node is considered the same if its name, attributes and content match the\n     * other node; particularly its position in the tree does not influence its similarity.\n     * @param o other object to compare to\n     * @return true if the content of this node is the same as the other\n     */\n    public boolean hasSameValue(@Nullable Object o) {\n        if (this \u003d\u003d o) return true;\n        if (o \u003d\u003d null || getClass() !\u003d o.getClass()) return false;\n\n        return this.outerHtml().equals(((Node) o).outerHtml());\n    }\n\n    /**\n     * Create a stand-alone, deep copy of this node, and all of its children. The cloned node will have no siblings or\n     * parent node. As a stand-alone object, any changes made to the clone or any of its children will not impact the\n     * original node.\n     * \u003cp\u003e\n     * The cloned node may be adopted into another Document or node structure using {@link Element#appendChild(Node)}.\n     * @return a stand-alone cloned node, including clones of any children\n     * @see #shallowClone()\n     */\n    @SuppressWarnings(\"MethodDoesntCallSuperMethod\") // because it does call super.clone in doClone - analysis just isn\u0027t following\n    @Override\n    public Node clone() {\n        Node thisClone \u003d doClone(null); // splits for orphan\n\n        // Queue up nodes that need their children cloned (BFS).\n        final LinkedList\u003cNode\u003e nodesToProcess \u003d new LinkedList\u003c\u003e();\n        nodesToProcess.add(thisClone);\n\n        while (!nodesToProcess.isEmpty()) {\n            Node currParent \u003d nodesToProcess.remove();\n\n            final int size \u003d currParent.childNodeSize();\n            for (int i \u003d 0; i \u003c size; i++) {\n                final List\u003cNode\u003e childNodes \u003d currParent.ensureChildNodes();\n                Node childClone \u003d childNodes.get(i).doClone(currParent);\n                childNodes.set(i, childClone);\n                nodesToProcess.add(childClone);\n            }\n        }\n\n        return thisClone;\n    }\n\n    /**\n     * Create a stand-alone, shallow copy of this node. None of its children (if any) will be cloned, and it will have\n     * no parent or sibling nodes.\n     * @return a single independent copy of this node\n     * @see #clone()\n     */\n    public Node shallowClone() {\n        return doClone(null);\n    }\n\n    /*\n     * Return a clone of the node using the given parent (which can be null).\n     * Not a deep copy of children.\n     */\n    protected Node doClone(@Nullable Node parent) {\n        Node clone;\n\n        try {\n            clone \u003d (Node) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n\n        clone.parentNode \u003d parent; // can be null, to create an orphan split\n        clone.siblingIndex \u003d parent \u003d\u003d null ? 0 : siblingIndex;\n        // if not keeping the parent, shallowClone the ownerDocument to preserve its settings\n        if (parent \u003d\u003d null \u0026\u0026 !(this instanceof Document)) {\n            Document doc \u003d ownerDocument();\n            if (doc !\u003d null) {\n                Document docClone \u003d doc.shallowClone();\n                clone.parentNode \u003d docClone;\n                docClone.ensureChildNodes().add(clone);\n            }\n        }\n\n        return clone;\n    }\n\n    private static class OuterHtmlVisitor implements NodeVisitor {\n        private final Appendable accum;\n        private final Document.OutputSettings out;\n\n        OuterHtmlVisitor(Appendable accum, Document.OutputSettings out) {\n            this.accum \u003d accum;\n            this.out \u003d out;\n        }\n\n        @Override public void head(Node node, int depth) {\n            try {\n\t\t\t\tnode.outerHtmlHead(accum, depth, out);\n\t\t\t} catch (IOException exception) {\n\t\t\t\tthrow new SerializationException(exception);\n\t\t\t}\n        }\n\n        @Override public void tail(Node node, int depth) {\n            if (!node.nodeName().equals(\"#text\")) { // saves a void hit.\n\t\t\t\ttry {\n\t\t\t\t\tnode.outerHtmlTail(accum, depth, out);\n\t\t\t\t} catch (IOException exception) {\n\t\t\t\t\tthrow new SerializationException(exception);\n\t\t\t\t}\n            }\n        }\n    }\n}","methodCount":78,"staticMethodCount":1,"instanceMethodCount":77,"classLoc":945,"innerClassCount":1},"candidatesTelemetryData":{"numberOfSuggestions":2,"candidates":[{"lineStart":825,"lineEnd":827,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method indent to class OutputSettings","description":"Move method indent to org.jsoup.nodes.Document.OutputSettings\nRationale: The \u0027indent\u0027 method is closely related to configuration parameters such as \u0027indentAmount\u0027 and \u0027maxPaddingWidth\u0027, which are defined and managed within the OutputSettings class. This method adjusts the formatting of output based on these settings, making OutputSettings the optimal location. Moving \u0027indent\u0027 to OutputSettings encapsulates all formatting behaviors within a single class, enhancing cohesion and maintainability.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false,"userRating":"Very Helpful"},{"lineStart":492,"lineEnd":499,"refactoringType":"MyMoveStaticMethodRefactoring","refactoringInfo":"Move Static method getDeepChild to class HtmlTreeBuilder","description":"move method getDeepChild to PsiClass:HtmlTreeBuilder\nRationale: The `getDeepChild` method is focused on DOM manipulation, which is a core responsibility of the `HtmlTreeBuilder` class. This class already has several methods dealing with element traversal and manipulation, making it a natural fit for the `getDeepChild` method. The method is used to find the deepest child element, a common operation in tree-like structures, aligning well with the `HtmlTreeBuilder`\u0027s purpose of creating and modifying the HTML DOM.","couldCreateRefObject":true,"applied":false,"startedRefactoringFlow":false,"undone":false,"userRating":"Somewhat Helpful"}]},"userSelectionTelemetryData":{"lineStart":825,"lineEnd":827,"functionSize":3,"positionInHostFunction":804,"selectedCandidateIndex":0,"candidateType":"AS_IS","elementsType":[{"elementType":"METHOD","quantity":1}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":74998},{"candidateIndex":1,"elapsedTime":75314}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":71667},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"parentNameIs","method_signature":"public parentNameIs(String normalName)","target_class":"","rationale":""},{"method_name":"childNodesCopy","method_signature":"public childNodesCopy()","target_class":"","rationale":""},{"method_name":"remove","method_signature":"public remove()","target_class":"","rationale":""},{"method_name":"before","method_signature":"public before(Node node)","target_class":"","rationale":""},{"method_name":"after","method_signature":"public after(Node node)","target_class":"","rationale":""},{"method_name":"addSiblingHtml","method_signature":"private addSiblingHtml(int index, String html)","target_class":"","rationale":""},{"method_name":"wrap","method_signature":"public wrap(String html)","target_class":"","rationale":""},{"method_name":"unwrap","method_signature":"public @Nullable unwrap()","target_class":"","rationale":""},{"method_name":"getDeepChild","method_signature":"private static getDeepChild(Element el)","target_class":"","rationale":""},{"method_name":"replaceWith","method_signature":"public replaceWith(Node in)","target_class":"","rationale":""},{"method_name":"replaceChild","method_signature":"protected replaceChild(Node out, Node in)","target_class":"","rationale":""},{"method_name":"removeChild","method_signature":"protected removeChild(Node out)","target_class":"","rationale":""},{"method_name":"addChildren","method_signature":"protected addChildren(Node... children)","target_class":"","rationale":""},{"method_name":"reparentChild","method_signature":"protected reparentChild(Node child)","target_class":"","rationale":""},{"method_name":"siblingNodes","method_signature":"public siblingNodes()","target_class":"","rationale":""},{"method_name":"nextSibling","method_signature":"public @Nullable nextSibling()","target_class":"","rationale":""},{"method_name":"previousSibling","method_signature":"public @Nullable previousSibling()","target_class":"","rationale":""},{"method_name":"indent","method_signature":"protected indent(Appendable accum, int depth, Document.OutputSettings out)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"addSiblingHtml","method_signature":"private addSiblingHtml(int index, String html)","target_class":"","rationale":""},{"method_name":"reparentChild","method_signature":"protected reparentChild(Node child)","target_class":"","rationale":""},{"method_name":"addChildren","method_signature":"protected addChildren(Node... children)","target_class":"","rationale":""},{"method_name":"removeChild","method_signature":"protected removeChild(Node out)","target_class":"","rationale":""},{"method_name":"indent","method_signature":"protected indent(Appendable accum, int depth, Document.OutputSettings out)","target_class":"","rationale":""},{"method_name":"getDeepChild","method_signature":"private static getDeepChild(Element el)","target_class":"","rationale":""},{"method_name":"replaceChild","method_signature":"protected replaceChild(Node out, Node in)","target_class":"","rationale":""},{"method_name":"nextSibling","method_signature":"public @Nullable nextSibling()","target_class":"","rationale":""},{"method_name":"previousSibling","method_signature":"public @Nullable previousSibling()","target_class":"","rationale":""},{"method_name":"wrap","method_signature":"public wrap(String html)","target_class":"","rationale":""},{"method_name":"siblingNodes","method_signature":"public siblingNodes()","target_class":"","rationale":""},{"method_name":"parentNameIs","method_signature":"public parentNameIs(String normalName)","target_class":"","rationale":""},{"method_name":"replaceWith","method_signature":"public replaceWith(Node in)","target_class":"","rationale":""},{"method_name":"childNodesCopy","method_signature":"public childNodesCopy()","target_class":"","rationale":""},{"method_name":"remove","method_signature":"public remove()","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"private addSiblingHtml(int index, String html)":{"first":{"method_name":"addSiblingHtml","method_signature":"private addSiblingHtml(int index, String html)","target_class":"","rationale":""},"second":0.2198838357684721},"protected reparentChild(Node child)":{"first":{"method_name":"reparentChild","method_signature":"protected reparentChild(Node child)","target_class":"","rationale":""},"second":0.226479314151215},"protected addChildren(Node... children)":{"first":{"method_name":"addChildren","method_signature":"protected addChildren(Node... children)","target_class":"","rationale":""},"second":0.2522832968606858},"protected removeChild(Node out)":{"first":{"method_name":"removeChild","method_signature":"protected removeChild(Node out)","target_class":"","rationale":""},"second":0.265975226737987},"protected indent(Appendable accum, int depth, Document.OutputSettings out)":{"first":{"method_name":"indent","method_signature":"protected indent(Appendable accum, int depth, Document.OutputSettings out)","target_class":"","rationale":""},"second":0.26840897078223713},"private static getDeepChild(Element el)":{"first":{"method_name":"getDeepChild","method_signature":"private static getDeepChild(Element el)","target_class":"","rationale":""},"second":0.32105102540093117},"protected replaceChild(Node out, Node in)":{"first":{"method_name":"replaceChild","method_signature":"protected replaceChild(Node out, Node in)","target_class":"","rationale":""},"second":0.33954385662684433},"public @Nullable nextSibling()":{"first":{"method_name":"nextSibling","method_signature":"public @Nullable nextSibling()","target_class":"","rationale":""},"second":0.5579986434085961},"public @Nullable previousSibling()":{"first":{"method_name":"previousSibling","method_signature":"public @Nullable previousSibling()","target_class":"","rationale":""},"second":0.5745681531415624},"public wrap(String html)":{"first":{"method_name":"wrap","method_signature":"public wrap(String html)","target_class":"","rationale":""},"second":0.5772514100351415},"public siblingNodes()":{"first":{"method_name":"siblingNodes","method_signature":"public siblingNodes()","target_class":"","rationale":""},"second":0.5778470331248318},"public parentNameIs(String normalName)":{"first":{"method_name":"parentNameIs","method_signature":"public parentNameIs(String normalName)","target_class":"","rationale":""},"second":0.5833756759700045},"public replaceWith(Node in)":{"first":{"method_name":"replaceWith","method_signature":"public replaceWith(Node in)","target_class":"","rationale":""},"second":0.5989911510418869},"public childNodesCopy()":{"first":{"method_name":"childNodesCopy","method_signature":"public childNodesCopy()","target_class":"","rationale":""},"second":0.6101083466846278},"public remove()":{"first":{"method_name":"remove","method_signature":"public remove()","target_class":"","rationale":""},"second":0.6424120071742012}},"targetClassMap":{"addSiblingHtml":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":6184,"similarity_computation_time":0,"similarity_metric":"cosine"},"reparentChild":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":3761,"similarity_computation_time":0,"similarity_metric":"cosine"},"addChildren":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":7157,"similarity_computation_time":0,"similarity_metric":"cosine"},"removeChild":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":4042,"similarity_computation_time":0,"similarity_metric":"cosine"},"indent":{"target_classes":[{"class_name":"OutputSettings","similarity_score":0.24149925981519563}],"target_classes_sorted_by_llm":["OutputSettings"],"llm_response_time":3562,"similarity_computation_time":0,"similarity_metric":"cosine"},"getDeepChild":{"target_classes":[{"class_name":"NodeUtils","similarity_score":0.3486173191636377},{"class_name":"StringUtil","similarity_score":0.35294824998780056},{"class_name":"DataUtil","similarity_score":0.37236149683300035},{"class_name":"StringJoiner","similarity_score":0.323509509399102},{"class_name":"Entities","similarity_score":0.5014594988679825},{"class_name":"NodeTraversor","similarity_score":0.39456525468480846},{"class_name":"Normalizer","similarity_score":0.23293005442924333},{"class_name":"Wikipedia","similarity_score":0.4243387589068118},{"class_name":"ListLinks","similarity_score":0.41736285205886114},{"class_name":"Jsoup","similarity_score":0.12987764144422595},{"class_name":"Validate","similarity_score":0.1297235779888963},{"class_name":"Selector","similarity_score":0.15197015254735333},{"class_name":"Functions","similarity_score":0.4111864233022261},{"class_name":"Attribute","similarity_score":0.41475464513018906},{"class_name":"Collector","similarity_score":0.2238997153862308},{"class_name":"TextNode","similarity_score":0.35710219093260465},{"class_name":"HtmlToPlainText","similarity_score":0.4248094695898597},{"class_name":"NodeIterator","similarity_score":0.38883911350472916},{"class_name":"Comment","similarity_score":0.40127534340206866},{"class_name":"Attributes","similarity_score":0.4651343412505398},{"class_name":"Range","similarity_score":0.304238210806693},{"class_name":"Element","similarity_score":0.3655178147251931},{"class_name":"Document","similarity_score":0.36690092409894554},{"class_name":"Response","similarity_score":0.58734040064612},{"class_name":"XmlDeclaration","similarity_score":0.38690641917512275},{"class_name":"W3CDom","similarity_score":0.44586810052865883},{"class_name":"OuterHtmlVisitor","similarity_score":0.44257374207148364},{"class_name":"OutputSettings","similarity_score":0.25012622358146197},{"class_name":"DocumentType","similarity_score":0.3551740354134461},{"class_name":"CDataNode","similarity_score":0.3090434456865326},{"class_name":"FormElement","similarity_score":0.37402241063585606},{"class_name":"DataNode","similarity_score":0.24781494958150413},{"class_name":"AttributeRange","similarity_score":0.4092192957336808},{"class_name":"Position","similarity_score":0.236614071384008},{"class_name":"PseudoTextElement","similarity_score":0.2664693550105965},{"class_name":"Parser","similarity_score":0.3079022838571252},{"class_name":"ParseErrorList","similarity_score":0.42374403015076784},{"class_name":"Safelist","similarity_score":0.39430903163622194},{"class_name":"Tag","similarity_score":0.3984671307215202},{"class_name":"ControllableInputStream","similarity_score":0.4517575618252887},{"class_name":"KeyVal","similarity_score":0.4439737092702863},{"class_name":"ParseSettings","similarity_score":0.3774224822202903},{"class_name":"HttpConnection","similarity_score":0.5866532504716443},{"class_name":"TokenQueue","similarity_score":0.4270778333923914},{"class_name":"HtmlTreeBuilder","similarity_score":0.599029161419487},{"class_name":"QueryParser","similarity_score":0.49436752338352974},{"class_name":"CharacterReader","similarity_score":0.506913574659471},{"class_name":"ValidationException","similarity_score":0.3707336495572356},{"class_name":"Matches","similarity_score":0.4736654667156709},{"class_name":"MatchesOwn","similarity_score":0.45311890501439905},{"class_name":"MatchesWholeOwnText","similarity_score":0.4434426533185908},{"class_name":"MatchesWholeText","similarity_score":0.46383051057040525},{"class_name":"SharedConstants","similarity_score":0.31521258597805757},{"class_name":"StreamParser","similarity_score":0.2799238633146558},{"class_name":"MatchText","similarity_score":0.43583586846268},{"class_name":"XmlTreeBuilder","similarity_score":0.5325302312408317},{"class_name":"SerializationException","similarity_score":0.09718353554808491},{"class_name":"SelectorParseException","similarity_score":0.30246429052072016},{"class_name":"TagEndsWith","similarity_score":0.3906726924487462},{"class_name":"TagStartsWith","similarity_score":0.3906726924487462},{"class_name":"IndexEquals","similarity_score":0.40509574683346666},{"class_name":"IndexGreaterThan","similarity_score":0.3525058226889108},{"class_name":"IndexLessThan","similarity_score":0.39020521655021173},{"class_name":"SoftPool","similarity_score":0.27229161710404226},{"class_name":"AllElements","similarity_score":0.4006683379765067},{"class_name":"Or","similarity_score":0.4102129485888},{"class_name":"UnsupportedMimeTypeException","similarity_score":0.3401258096495938},{"class_name":"And","similarity_score":0.48894813859523983},{"class_name":"UncheckedIOException","similarity_score":0.2838067394000256},{"class_name":"IsEmpty","similarity_score":0.40874910638367024},{"class_name":"IsFirstChild","similarity_score":0.4219747362848611},{"class_name":"IsFirstOfType","similarity_score":0.35445877847928325},{"class_name":"IsLastChild","similarity_score":0.4219747362848611},{"class_name":"IsLastOfType","similarity_score":0.35445877847928325},{"class_name":"IsNthChild","similarity_score":0.3564445574817219},{"class_name":"IsNthLastChild","similarity_score":0.3682947537517004},{"class_name":"IsNthLastOfType","similarity_score":0.6014228144237643},{"class_name":"IsNthOfType","similarity_score":0.5032599119588452},{"class_name":"HttpStatusException","similarity_score":0.325101610132231},{"class_name":"ParseError","similarity_score":0.43492022722474183},{"class_name":"IsOnlyChild","similarity_score":0.4303808866757065},{"class_name":"IsOnlyOfType","similarity_score":0.5588715604081793},{"class_name":"IsRoot","similarity_score":0.4293117386281832},{"class_name":"Elements","similarity_score":0.3194919150544442},{"class_name":"Id","similarity_score":0.4459957386704484},{"class_name":"Context","similarity_score":0.2809373736616237},{"class_name":"Cleaner","similarity_score":0.409411372390929},{"class_name":"ContainsData","similarity_score":0.4239501477893962},{"class_name":"ContainsOwnText","similarity_score":0.4085752815378834},{"class_name":"ContainsText","similarity_score":0.4459957386704484},{"class_name":"ContainsWholeOwnText","similarity_score":0.4088564366232198},{"class_name":"ContainsWholeText","similarity_score":0.43041423101055826},{"class_name":"Class","similarity_score":0.43306556956861336},{"class_name":"AttributeStarting","similarity_score":0.4437847440736991},{"class_name":"AttributeWithValue","similarity_score":0.36943597501129466},{"class_name":"AttributeWithValueContaining","similarity_score":0.3596571059090113},{"class_name":"AttributeWithValueEnding","similarity_score":0.36100666827129496},{"class_name":"AttributeWithValueMatching","similarity_score":0.4156194667729049},{"class_name":"AttributeWithValueNot","similarity_score":0.3836450509732675},{"class_name":"AttributeWithValueStarting","similarity_score":0.3596571059090113}],"target_classes_sorted_by_llm":["HtmlTreeBuilder","IsNthLastOfType","Response"],"llm_response_time":7097,"similarity_computation_time":23,"similarity_metric":"cosine"},"replaceChild":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":7099,"similarity_computation_time":0,"similarity_metric":"cosine"},"nextSibling":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":2670,"similarity_computation_time":0,"similarity_metric":"cosine"},"previousSibling":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":2783,"similarity_computation_time":0,"similarity_metric":"cosine"},"wrap":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":5841,"similarity_computation_time":0,"similarity_metric":"cosine"},"siblingNodes":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":3250,"similarity_computation_time":0,"similarity_metric":"cosine"},"parentNameIs":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":4797,"similarity_computation_time":0,"similarity_metric":"cosine"},"replaceWith":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":4996,"similarity_computation_time":0,"similarity_metric":"cosine"},"childNodesCopy":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":3641,"similarity_computation_time":0,"similarity_metric":"cosine"},"remove":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":3538,"similarity_computation_time":0,"similarity_metric":"cosine"}}}
{"id":"de66ff73-2cfa-496a-af15-3e44e6fbe53a","hostFunctionTelemetryData":{"hostFunctionSize":623,"lineStart":29,"lineEnd":651,"bodyLineStart":29,"language":"java","filePath":"/Users/snehil/Documents/ConcordiaUniversity/Material/SOEN-6491-Refactoring/OpenSource/jsoup/jsoup/src/main/java/org/jsoup/nodes/Attributes.java","sourceCode":"/**\n * The attributes of an Element.\n * \u003cp\u003e\n * During parsing, attributes in with the same name in an element are deduplicated, according to the configured parser\u0027s\n * attribute case-sensitive setting. It is possible to have duplicate attributes subsequently if\n * {@link #add(String, String)} vs {@link #put(String, String)} is used.\n * \u003c/p\u003e\n * \u003cp\u003e\n * Attribute name and value comparisons are generally \u003cb\u003ecase sensitive\u003c/b\u003e. By default for HTML, attribute names are\n * normalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by\n * name.\n * \u003c/p\u003e\n *\n * @author Jonathan Hedley, jonathan@hedley.net\n */\npublic class Attributes implements Iterable\u003cAttribute\u003e, Cloneable {\n    // Indicates an internal key. Can\u0027t be set via HTML. (It could be set via accessor, but not too worried about\n    // that. Suppressed from list, iter.)\n    static final char InternalPrefix \u003d \u0027/\u0027;\n\n    // The Attributes object is only created on the first use of an attribute; the Element will just have a null\n    // Attribute slot otherwise\n    protected static final String dataPrefix \u003d \"data-\";\n    private static final int InitialCapacity \u003d 3; // sampling found mean count when attrs present \u003d 1.49; 1.08 overall. 2.6:1 don\u0027t have any attrs.\n\n    // manages the key/val arrays\n    private static final int GrowthFactor \u003d 2;\n    static final int NotFound \u003d -1;\n    private static final String EmptyString \u003d \"\";\n\n    // the number of instance fields is kept as low as possible giving an object size of 24 bytes\n    private int size \u003d 0; // number of slots used (not total capacity, which is keys.length)\n    @Nullable String[] keys \u003d new String[InitialCapacity]; // keys is not null, but contents may be. Same for vals\n    @Nullable Object[] vals \u003d new Object[InitialCapacity]; // Genericish: all non-internal attribute values must be Strings and are cast on access.\n    // todo - make keys iterable without creating Attribute objects\n\n    // check there\u0027s room for more\n    private void checkCapacity(int minNewSize) {\n        Validate.isTrue(minNewSize \u003e\u003d size);\n        int curCap \u003d keys.length;\n        if (curCap \u003e\u003d minNewSize)\n            return;\n        int newCap \u003d curCap \u003e\u003d InitialCapacity ? size * GrowthFactor : InitialCapacity;\n        if (minNewSize \u003e newCap)\n            newCap \u003d minNewSize;\n\n        keys \u003d Arrays.copyOf(keys, newCap);\n        vals \u003d Arrays.copyOf(vals, newCap);\n    }\n\n    int indexOfKey(String key) {\n        Validate.notNull(key);\n        for (int i \u003d 0; i \u003c size; i++) {\n            if (key.equals(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    private int indexOfKeyIgnoreCase(String key) {\n        Validate.notNull(key);\n        for (int i \u003d 0; i \u003c size; i++) {\n            if (key.equalsIgnoreCase(keys[i]))\n                return i;\n        }\n        return NotFound;\n    }\n\n    // we track boolean attributes as null in values - they\u0027re just keys. so returns empty for consumers\n    // casts to String, so only for non-internal attributes\n    static String checkNotNull(@Nullable Object val) {\n        return val \u003d\u003d null ? EmptyString : (String) val;\n    }\n\n    /**\n     Get an attribute value by key.\n     @param key the (case-sensitive) attribute key\n     @return the attribute value if set; or empty string if not set (or a boolean attribute).\n     @see #hasKey(String)\n     */\n    public String get(String key) {\n        int i \u003d indexOfKey(key);\n        return i \u003d\u003d NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     Get an Attribute by key. The Attribute will remain connected to these Attributes, so changes made via\n     {@link Attribute#setKey(String)}, {@link Attribute#setValue(String)} etc will cascade back to these Attributes and\n     their owning Element.\n     @param key the (case-sensitive) attribute key\n     @return the Attribute for this key, or null if not present.\n     @since 1.17.2\n     */\n    @Nullable public Attribute attribute(String key) {\n        int i \u003d indexOfKey(key);\n        return i \u003d\u003d NotFound ? null : new Attribute(key, checkNotNull(vals[i]), this);\n    }\n\n    /**\n     * Get an attribute\u0027s value by case-insensitive key\n     * @param key the attribute name\n     * @return the first matching attribute value if set; or empty string if not set (ora boolean attribute).\n     */\n    public String getIgnoreCase(String key) {\n        int i \u003d indexOfKeyIgnoreCase(key);\n        return i \u003d\u003d NotFound ? EmptyString : checkNotNull(vals[i]);\n    }\n\n    /**\n     * Adds a new attribute. Will produce duplicates if the key already exists.\n     * @see Attributes#put(String, String)\n     */\n    public Attributes add(String key, @Nullable String value) {\n        addObject(key, value);\n        return this;\n    }\n\n    private void addObject(String key, @Nullable Object value) {\n        checkCapacity(size + 1);\n        keys[size] \u003d key;\n        vals[size] \u003d value;\n        size++;\n    }\n\n    /**\n     * Set a new attribute, or replace an existing one by key.\n     * @param key case sensitive attribute key (not null)\n     * @param value attribute value (which can be null, to set a true boolean attribute)\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, @Nullable String value) {\n        Validate.notNull(key);\n        int i \u003d indexOfKey(key);\n        if (i !\u003d NotFound)\n            vals[i] \u003d value;\n        else\n            add(key, value);\n        return this;\n    }\n\n    /**\n     Get the map holding any user-data associated with these Attributes. Will be created empty on first use. Held as\n     an internal attribute, not a field member, to reduce the memory footprint of Attributes when not used. Can hold\n     arbitrary objects; use for source ranges, connecting W3C nodes to Elements, etc.\n     * @return the map holding user-data\n     */\n    Map\u003cString, Object\u003e userData() {\n        final Map\u003cString, Object\u003e userData;\n        int i \u003d indexOfKey(SharedConstants.UserDataKey);\n        if (i \u003d\u003d NotFound) {\n            userData \u003d new HashMap\u003c\u003e();\n            addObject(SharedConstants.UserDataKey, userData);\n        } else {\n            //noinspection unchecked\n            userData \u003d (Map\u003cString, Object\u003e) vals[i];\n        }\n        assert userData !\u003d null;\n        return userData;\n    }\n\n    /**\n     Get an arbitrary user-data object by key.\n     * @param key case-sensitive key to the object.\n     * @return the object associated to this key, or {@code null} if not found.\n     * @see #userData(String key, Object val)\n     * @since 1.17.1\n     */\n    @Nullable\n    public Object userData(String key) {\n        Validate.notNull(key);\n        if (!hasKey(SharedConstants.UserDataKey)) return null; // no user data exists\n        Map\u003cString, Object\u003e userData \u003d userData();\n        return userData.get(key);\n    }\n\n    /**\n     Set an arbitrary user-data object by key. Will be treated as an internal attribute, so will not be emitted in HTML.\n     * @param key case-sensitive key\n     * @param value object value\n     * @return these attributes\n     * @see #userData(String key)\n     * @since 1.17.1\n     */\n    public Attributes userData(String key, Object value) {\n        Validate.notNull(key);\n        userData().put(key, value);\n        return this;\n    }\n\n    void putIgnoreCase(String key, @Nullable String value) {\n        int i \u003d indexOfKeyIgnoreCase(key);\n        if (i !\u003d NotFound) {\n            vals[i] \u003d value;\n            String old \u003d keys[i];\n            assert old !\u003d null;\n            if (!old.equals(key)) // case changed, update\n                keys[i] \u003d key;\n        }\n        else\n            add(key, value);\n    }\n\n    /**\n     * Set a new boolean attribute. Removes the attribute if the value is false.\n     * @param key case \u003cb\u003einsensitive\u003c/b\u003e attribute key\n     * @param value attribute value\n     * @return these attributes, for chaining\n     */\n    public Attributes put(String key, boolean value) {\n        if (value)\n            putIgnoreCase(key, null);\n        else\n            remove(key);\n        return this;\n    }\n\n    /**\n     Set a new attribute, or replace an existing one by key.\n     @param attribute attribute with case-sensitive key\n     @return these attributes, for chaining\n     */\n    public Attributes put(Attribute attribute) {\n        Validate.notNull(attribute);\n        put(attribute.getKey(), attribute.getValue());\n        attribute.parent \u003d this;\n        return this;\n    }\n\n    // removes and shifts up\n    @SuppressWarnings(\"AssignmentToNull\")\n    private void remove(int index) {\n        Validate.isFalse(index \u003e\u003d size);\n        int shifted \u003d size - index - 1;\n        if (shifted \u003e 0) {\n            System.arraycopy(keys, index + 1, keys, index, shifted);\n            System.arraycopy(vals, index + 1, vals, index, shifted);\n        }\n        size--;\n        keys[size] \u003d null; // release hold\n        vals[size] \u003d null;\n    }\n\n    /**\n     Remove an attribute by key. \u003cb\u003eCase sensitive.\u003c/b\u003e\n     @param key attribute key to remove\n     */\n    public void remove(String key) {\n        int i \u003d indexOfKey(key);\n        if (i !\u003d NotFound)\n            remove(i);\n    }\n\n    /**\n     Remove an attribute by key. \u003cb\u003eCase insensitive.\u003c/b\u003e\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        int i \u003d indexOfKeyIgnoreCase(key);\n        if (i !\u003d NotFound)\n            remove(i);\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKey(String key) {\n        return indexOfKey(key) !\u003d NotFound;\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKeyIgnoreCase(String key) {\n        return indexOfKeyIgnoreCase(key) !\u003d NotFound;\n    }\n\n    /**\n     * Check if these attributes contain an attribute with a value for this key.\n     * @param key key to check for\n     * @return true if key exists, and it has a value\n     */\n    public boolean hasDeclaredValueForKey(String key) {\n        int i \u003d indexOfKey(key);\n        return i !\u003d NotFound \u0026\u0026 vals[i] !\u003d null;\n    }\n\n    /**\n     * Check if these attributes contain an attribute with a value for this key.\n     * @param key case-insensitive key to check for\n     * @return true if key exists, and it has a value\n     */\n    public boolean hasDeclaredValueForKeyIgnoreCase(String key) {\n        int i \u003d indexOfKeyIgnoreCase(key);\n        return i !\u003d NotFound \u0026\u0026 vals[i] !\u003d null;\n    }\n\n    /**\n     Get the number of attributes in this set, including any jsoup internal-only attributes. Internal attributes are\n     excluded from the {@link #html()}, {@link #asList()}, and {@link #iterator()} methods.\n     @return size\n     */\n    public int size() {\n        return size;\n        // todo - exclude internal attributes from this count - maintain size, count of internals\n    }\n\n    /**\n     * Test if this Attributes list is empty (size\u003d\u003d0).\n     */\n    public boolean isEmpty() {\n        return size \u003d\u003d 0;\n    }\n\n    /**\n     Add all the attributes from the incoming set to this set.\n     @param incoming attributes to add to these attributes.\n     */\n    public void addAll(Attributes incoming) {\n        if (incoming.size() \u003d\u003d 0)\n            return;\n        checkCapacity(size + incoming.size);\n\n        boolean needsPut \u003d size !\u003d 0; // if this set is empty, no need to check existing set, so can add() vs put()\n        // (and save bashing on the indexOfKey()\n        for (Attribute attr : incoming) {\n            if (needsPut)\n                put(attr);\n            else\n                add(attr.getKey(), attr.getValue());\n        }\n    }\n\n    /**\n     Get the source ranges (start to end position) in the original input source from which this attribute\u0027s \u003cb\u003ename\u003c/b\u003e\n     and \u003cb\u003evalue\u003c/b\u003e were parsed.\n     \u003cp\u003ePosition tracking must be enabled prior to parsing the content.\u003c/p\u003e\n     @param key the attribute name\n     @return the ranges for the attribute\u0027s name and value, or {@code untracked} if the attribute does not exist or its range\n     was not tracked.\n     @see org.jsoup.parser.Parser#setTrackPosition(boolean)\n     @see Attribute#sourceRange()\n     @see Node#sourceRange()\n     @see Element#endSourceRange()\n     @since 1.17.1\n     */\n    public Range.AttributeRange sourceRange(String key) {\n        if (!hasKey(key)) return UntrackedAttr;\n        Map\u003cString, Range.AttributeRange\u003e ranges \u003d getRanges();\n        if (ranges \u003d\u003d null) return Range.AttributeRange.UntrackedAttr;\n        Range.AttributeRange range \u003d ranges.get(key);\n        return range !\u003d null ? range : Range.AttributeRange.UntrackedAttr;\n    }\n\n    /** Get the Ranges, if tracking is enabled; null otherwise. */\n    @Nullable Map\u003cString, Range.AttributeRange\u003e getRanges() {\n        //noinspection unchecked\n        return (Map\u003cString, Range.AttributeRange\u003e) userData(AttrRangeKey);\n    }\n\n\n    @Override\n    public Iterator\u003cAttribute\u003e iterator() {\n        //noinspection ReturnOfInnerClass\n        return new Iterator\u003cAttribute\u003e() {\n            int expectedSize \u003d size;\n            int i \u003d 0;\n\n            @Override\n            public boolean hasNext() {\n                checkModified();\n                while (i \u003c size) {\n                    String key \u003d keys[i];\n                    assert key !\u003d null;\n                    if (isInternalKey(key)) // skip over internal keys\n                        i++;\n                    else\n                        break;\n                }\n\n                return i \u003c size;\n            }\n\n            @Override\n            public Attribute next() {\n                checkModified();\n                if (i \u003e\u003d size) throw new NoSuchElementException();\n                String key \u003d keys[i];\n                assert key !\u003d null;\n                final Attribute attr \u003d new Attribute(key, (String) vals[i], Attributes.this);\n                i++;\n                return attr;\n            }\n\n            private void checkModified() {\n                if (size !\u003d expectedSize) throw new ConcurrentModificationException(\"Use Iterator#remove() instead to remove attributes while iterating.\");\n            }\n\n            @Override\n            public void remove() {\n                Attributes.this.remove(--i); // next() advanced, so rewind\n                expectedSize--;\n            }\n        };\n    }\n\n    /**\n     Get the attributes as a List, for iteration.\n     @return a view of the attributes as an unmodifiable List.\n     */\n    public List\u003cAttribute\u003e asList() {\n        ArrayList\u003cAttribute\u003e list \u003d new ArrayList\u003c\u003e(size);\n        for (int i \u003d 0; i \u003c size; i++) {\n            String key \u003d keys[i];\n            assert key !\u003d null;\n            if (isInternalKey(key))\n                continue; // skip internal keys\n            Attribute attr \u003d new Attribute(key, (String) vals[i], Attributes.this);\n            list.add(attr);\n        }\n        return Collections.unmodifiableList(list);\n    }\n\n    /**\n     * Retrieves a filtered view of attributes that are HTML5 custom data attributes; that is, attributes with keys\n     * starting with {@code data-}.\n     * @return map of custom data attributes.\n     */\n    public Map\u003cString, String\u003e dataset() {\n        return new Dataset(this);\n    }\n\n    /**\n     Get the HTML representation of these attributes.\n     @return HTML\n     */\n    public String html() {\n        StringBuilder sb \u003d StringUtil.borrowBuilder();\n        try {\n            html(sb, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used\n        } catch (IOException e) { // ought never happen\n            throw new SerializationException(e);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n    final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n        final int sz \u003d size;\n        for (int i \u003d 0; i \u003c sz; i++) {\n            String key \u003d keys[i];\n            assert key !\u003d null;\n            if (isInternalKey(key))\n                continue;\n            final String validated \u003d Attribute.getValidKey(key, out.syntax());\n            if (validated !\u003d null)\n                Attribute.htmlNoValidate(validated, (String) vals[i], accum.append(\u0027 \u0027), out);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return html();\n    }\n\n    /**\n     * Checks if these attributes are equal to another set of attributes, by comparing the two sets. Note that the order\n     * of the attributes does not impact this equality (as per the Map interface equals()).\n     * @param o attributes to compare with\n     * @return if both sets of attributes have the same content\n     */\n    @Override\n    public boolean equals(@Nullable Object o) {\n        if (this \u003d\u003d o) return true;\n        if (o \u003d\u003d null || getClass() !\u003d o.getClass()) return false;\n\n        Attributes that \u003d (Attributes) o;\n        if (size !\u003d that.size) return false;\n        for (int i \u003d 0; i \u003c size; i++) {\n            String key \u003d keys[i];\n            assert key !\u003d null;\n            int thatI \u003d that.indexOfKey(key);\n            if (thatI \u003d\u003d NotFound || !Objects.equals(vals[i], that.vals[thatI]))\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Calculates the hashcode of these attributes, by iterating all attributes and summing their hashcodes.\n     * @return calculated hashcode\n     */\n    @Override\n    public int hashCode() {\n        int result \u003d size;\n        result \u003d 31 * result + Arrays.hashCode(keys);\n        result \u003d 31 * result + Arrays.hashCode(vals);\n        return result;\n    }\n\n    @Override\n    public Attributes clone() {\n        Attributes clone;\n        try {\n            clone \u003d (Attributes) super.clone();\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e);\n        }\n        clone.size \u003d size;\n        clone.keys \u003d Arrays.copyOf(keys, size);\n        clone.vals \u003d Arrays.copyOf(vals, size);\n        return clone;\n    }\n\n    /**\n     * Internal method. Lowercases all (non-internal) keys.\n     */\n    public void normalize() {\n        for (int i \u003d 0; i \u003c size; i++) {\n            assert keys[i] !\u003d null;\n            String key \u003d keys[i];\n            assert key !\u003d null;\n            if (!isInternalKey(key))\n                keys[i] \u003d lowerCase(key);\n        }\n    }\n\n    /**\n     * Internal method. Removes duplicate attribute by name. Settings for case sensitivity of key names.\n     * @param settings case sensitivity\n     * @return number of removed dupes\n     */\n    public int deduplicate(ParseSettings settings) {\n        if (isEmpty())\n            return 0;\n        boolean preserve \u003d settings.preserveAttributeCase();\n        int dupes \u003d 0;\n        for (int i \u003d 0; i \u003c size; i++) {\n            String keyI \u003d keys[i];\n            assert keyI !\u003d null;\n            for (int j \u003d i + 1; j \u003c size; j++) {\n                if ((preserve \u0026\u0026 keyI.equals(keys[j])) || (!preserve \u0026\u0026 keyI.equalsIgnoreCase(keys[j]))) {\n                    dupes++;\n                    remove(j);\n                    j--;\n                }\n            }\n        }\n        return dupes;\n    }\n\n    private static class Dataset extends AbstractMap\u003cString, String\u003e {\n        private final Attributes attributes;\n\n        private Dataset(Attributes attributes) {\n            this.attributes \u003d attributes;\n        }\n\n        @Override\n        public Set\u003cEntry\u003cString, String\u003e\u003e entrySet() {\n            return new EntrySet();\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String dataKey \u003d dataKey(key);\n            String oldValue \u003d attributes.hasKey(dataKey) ? attributes.get(dataKey) : null;\n            attributes.put(dataKey, value);\n            return oldValue;\n        }\n\n        private class EntrySet extends AbstractSet\u003cMap.Entry\u003cString, String\u003e\u003e {\n\n            @Override\n            public Iterator\u003cMap.Entry\u003cString, String\u003e\u003e iterator() {\n                return new DatasetIterator();\n            }\n\n            @Override\n            public int size() {\n                int count \u003d 0;\n                Iterator\u003cEntry\u003cString, String\u003e\u003e iter \u003d new DatasetIterator();\n                while (iter.hasNext())\n                    count++;\n                return count;\n            }\n        }\n\n        private class DatasetIterator implements Iterator\u003cMap.Entry\u003cString, String\u003e\u003e {\n            private final Iterator\u003cAttribute\u003e attrIter \u003d attributes.iterator();\n            private Attribute attr;\n            @Override public boolean hasNext() {\n                while (attrIter.hasNext()) {\n                    attr \u003d attrIter.next();\n                    if (attr.isDataAttribute()) return true;\n                }\n                return false;\n            }\n\n            @Override public Entry\u003cString, String\u003e next() {\n                return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());\n            }\n\n            @Override public void remove() {\n                attributes.remove(attr.getKey());\n            }\n        }\n    }\n\n    private static String dataKey(String key) {\n        return dataPrefix + key;\n    }\n\n    static String internalKey(String key) {\n        return InternalPrefix + key;\n    }\n\n    static boolean isInternalKey(String key) {\n        return key.length() \u003e 1 \u0026\u0026 key.charAt(0) \u003d\u003d InternalPrefix;\n    }\n}","methodCount":54,"staticMethodCount":4,"instanceMethodCount":50,"classLoc":623,"innerClassCount":1},"candidatesTelemetryData":{"numberOfSuggestions":1,"candidates":[{"lineStart":244,"lineEnd":254,"refactoringType":"MyMoveInstanceMethodRefactoring","refactoringInfo":"Move method put to class Attribute","description":"Move method put to org.jsoup.nodes.Attribute\nRationale: The method put(Attribute attribute) is designed to work with instances of Attribute, as evidenced by its parameter and the operations it performs. Specifically, the method sets the parent attribute of the passed Attribute instance, and it validates the key and value of the Attribute, operations that are directly related to the Attribute class. Moving this method to the Attribute class centralizes attribute-specific operations within their own class, which enhances cohesion and makes the class more self-contained. Given that the primary focus of this method is to handle attributes—storing them, validating their values, and linking parent-child relationships—it logically belongs to the Attribute class.","couldCreateRefObject":true,"valid":true,"applied":true,"startedRefactoringFlow":true,"undone":false,"userRating":"Very Helpful"}]},"userSelectionTelemetryData":{"lineStart":244,"lineEnd":254,"functionSize":11,"positionInHostFunction":215,"selectedCandidateIndex":0,"candidateType":"AS_IS","elementsType":[{"elementType":"METHOD","quantity":1}]},"elapsedTime":[{"candidateIndex":0,"elapsedTime":83886}],"processingTime":{"llmResponseTime":-1,"pluginProcessingTime":-1,"totalTime":19681},"iterationData":[{"iteration_num":-1,"suggested_move_methods":[{"method_name":"put","method_signature":"public put(Attribute attribute)","target_class":"","rationale":""},{"method_name":"addAll","method_signature":"public addAll(Attributes incoming)","target_class":"","rationale":""},{"method_name":"html","method_signature":"final html(final Appendable accum, final Document.OutputSettings out)","target_class":"","rationale":""},{"method_name":"deduplicate","method_signature":"public deduplicate(ParseSettings settings)","target_class":"","rationale":""}],"llm_response_time":0},{"iteration_num":-2,"suggested_move_methods":[{"method_name":"put","method_signature":"public put(Attribute attribute)","target_class":"","rationale":""},{"method_name":"addAll","method_signature":"public addAll(Attributes incoming)","target_class":"","rationale":""},{"method_name":"html","method_signature":"final html(final Appendable accum, final Document.OutputSettings out)","target_class":"","rationale":""},{"method_name":"deduplicate","method_signature":"public deduplicate(ParseSettings settings)","target_class":"","rationale":""}],"llm_response_time":0}],"methodCompatibilityScores":{"public put(Attribute attribute)":{"first":{"method_name":"put","method_signature":"public put(Attribute attribute)","target_class":"","rationale":""},"second":0.48642948270366976},"public addAll(Attributes incoming)":{"first":{"method_name":"addAll","method_signature":"public addAll(Attributes incoming)","target_class":"","rationale":""},"second":0.49339093943538676},"final html(final Appendable accum, final Document.OutputSettings out)":{"first":{"method_name":"html","method_signature":"final html(final Appendable accum, final Document.OutputSettings out)","target_class":"","rationale":""},"second":0.5302021267106619},"public deduplicate(ParseSettings settings)":{"first":{"method_name":"deduplicate","method_signature":"public deduplicate(ParseSettings settings)","target_class":"","rationale":""},"second":0.6688603324532219}},"targetClassMap":{"put":{"target_classes":[{"class_name":"Attribute","similarity_score":0.44075489741573587}],"target_classes_sorted_by_llm":["Attribute"],"llm_response_time":4448,"similarity_computation_time":1,"similarity_metric":"cosine"},"addAll":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":4786,"similarity_computation_time":0,"similarity_metric":"cosine"},"html":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":3781,"similarity_computation_time":0,"similarity_metric":"cosine"},"deduplicate":{"target_classes":[],"target_classes_sorted_by_llm":[],"llm_response_time":6418,"similarity_computation_time":0,"similarity_metric":"cosine"}}}
